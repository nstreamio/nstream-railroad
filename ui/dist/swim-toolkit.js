// @swim/toolkit v4.0.0-dev.20210927.1 (c) 2015-2021 Swim.inc
(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("@swim/runtime"), require("@swim/runtime"), require("@swim/runtime"), require("@swim/runtime"), require("@swim/runtime"), require("@swim/runtime"), require("@swim/runtime"), require("@swim/runtime"), require("@swim/runtime"), require("@swim/runtime"), require("@swim/runtime")) : typeof define === "function" && define.amd ? define([ "exports", "@swim/runtime", "@swim/runtime", "@swim/runtime", "@swim/runtime", "@swim/runtime", "@swim/runtime", "@swim/runtime", "@swim/runtime", "@swim/runtime", "@swim/runtime", "@swim/runtime" ], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, 
  factory(global.swim = global.swim || {}, global.swim, global.swim, global.swim, global.swim, global.swim, global.swim, global.swim, global.swim, global.swim, global.swim, global.swim));
})(this, (function(exports, util, component, client, math, codec, structure, time, constraint, uri, collections, geo) {
  "use strict";
  function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  const ModelContext = function() {
    const ModelContext = {};
    ModelContext.current = null;
    ModelContext.create = function() {
      return {
        updateTime: performance.now()
      };
    };
    return ModelContext;
  }();
  class RefreshService extends component.Service {
    constructor() {
      super();
      this.flags = 0;
      this.modelContext = ModelContext.create();
      this.updateDelay = RefreshService.MinUpdateDelay;
      this.analyzeTimer = 0;
      this.refreshTimer = 0;
      this.runAnalyzePass = this.runAnalyzePass.bind(this);
      this.runRefreshPass = this.runRefreshPass.bind(this);
      this.onVisibilityChange = this.onVisibilityChange.bind(this);
    }
    setFlags(flags) {
      this.flags = flags;
    }
    updatedModelContext() {
      const modelContext = this.modelContext;
      modelContext.updateTime = performance.now();
      return modelContext;
    }
    needsUpdate(updateFlags, immediate) {
      return updateFlags;
    }
    requestUpdate(target, updateFlags, immediate) {
      updateFlags = this.needsUpdate(updateFlags, immediate);
      let deltaUpdateFlags = this.flags & ~updateFlags & Model.UpdateMask;
      if ((updateFlags & Model.AnalyzeMask) !== 0) {
        deltaUpdateFlags |= Model.NeedsAnalyze;
      }
      if ((updateFlags & Model.RefreshMask) !== 0) {
        deltaUpdateFlags |= Model.NeedsRefresh;
      }
      this.setFlags(this.flags | deltaUpdateFlags);
      if (immediate && (this.flags & (Model.AnalyzingFlag | Model.RefreshingFlag)) === 0 && this.updateDelay <= RefreshService.MaxAnalyzeInterval) {
        this.runImmediatePass();
      } else {
        this.scheduleUpdate();
      }
    }
    scheduleUpdate() {
      const flags = this.flags;
      if ((flags & Model.AnalyzingFlag) === 0 && (flags & Model.AnalyzeMask) !== 0) {
        this.scheduleAnalyzePass(this.updateDelay);
      } else if ((flags & Model.RefreshingFlag) === 0 && (flags & Model.RefreshMask) !== 0) {
        this.scheduleRefreshPass(RefreshService.MinAnalyzeInterval);
      }
    }
    cancelUpdate() {
      this.cancelAnalyzePass();
      this.cancelRefreshPass();
    }
    runImmediatePass() {
      if ((this.flags & Model.AnalyzeMask) !== 0) {
        this.cancelUpdate();
        this.runAnalyzePass(true);
      }
      if ((this.flags & Model.RefreshMask) !== 0 && this.updateDelay <= RefreshService.MaxAnalyzeInterval) {
        this.cancelUpdate();
        this.runRefreshPass(true);
      }
    }
    scheduleAnalyzePass(updateDelay) {
      if (this.analyzeTimer === 0) {
        this.analyzeTimer = setTimeout(this.runAnalyzePass, updateDelay);
      }
    }
    cancelAnalyzePass() {
      if (this.analyzeTimer !== 0) {
        clearTimeout(this.analyzeTimer);
        this.analyzeTimer = 0;
      }
    }
    runAnalyzePass(immediate = false) {
      this.setFlags(this.flags & ~Model.AnalyzeMask | Model.AnalyzingFlag);
      try {
        const t0 = performance.now();
        const roots = this.roots;
        const modelContext = this.modelContext;
        modelContext.updateTime = t0;
        for (let i = 0; i < roots.length; i += 1) {
          const root = roots[i];
          if ((root.flags & Model.AnalyzeMask) !== 0) {
            root.cascadeAnalyze(0, modelContext);
          }
        }
        const t1 = performance.now();
        let analyzeDelay = Math.max(RefreshService.MinAnalyzeInterval, this.updateDelay);
        if (t1 - t0 > analyzeDelay) {
          this.updateDelay = Math.min(Math.max(2, this.updateDelay * 2), RefreshService.MaxUpdateDelay);
        } else {
          this.updateDelay = Math.min(RefreshService.MinUpdateDelay, this.updateDelay / 2);
        }
        this.cancelAnalyzePass();
        if ((this.flags & Model.RefreshMask) !== 0) {
          this.scheduleRefreshPass(RefreshService.MinRefreshInterval);
        } else if ((this.flags & Model.AnalyzeMask) !== 0) {
          if (immediate) {
            analyzeDelay = Math.max(RefreshService.MaxAnalyzeInterval, analyzeDelay);
          }
          this.cancelRefreshPass();
          this.scheduleAnalyzePass(analyzeDelay);
        }
      } finally {
        this.setFlags(this.flags & ~Model.AnalyzingFlag);
      }
    }
    scheduleRefreshPass(updateDelay) {
      if (this.refreshTimer === 0) {
        this.refreshTimer = setTimeout(this.runRefreshPass, updateDelay);
      }
    }
    cancelRefreshPass() {
      if (this.refreshTimer !== 0) {
        clearTimeout(this.refreshTimer);
        this.refreshTimer = 0;
      }
    }
    runRefreshPass(immediate = false) {
      this.setFlags(this.flags & ~Model.RefreshMask | Model.RefreshingFlag);
      try {
        const time = performance.now();
        const modelContext = this.modelContext;
        modelContext.updateTime = time;
        const roots = this.roots;
        for (let i = 0; i < roots.length; i += 1) {
          const root = roots[i];
          if ((root.flags & Model.RefreshMask) !== 0) {
            root.cascadeRefresh(0, modelContext);
          }
        }
        this.cancelRefreshPass();
        if ((this.flags & Model.AnalyzeMask) !== 0) {
          let analyzeDelay = this.updateDelay;
          if (immediate) {
            analyzeDelay = Math.max(RefreshService.MaxAnalyzeInterval, analyzeDelay);
          }
          this.scheduleAnalyzePass(analyzeDelay);
        } else if ((this.flags & Model.RefreshMask) !== 0) {
          this.cancelAnalyzePass();
          this.scheduleRefreshPass(RefreshService.MaxRefreshInterval);
        }
      } finally {
        this.setFlags(this.flags & ~Model.RefreshingFlag);
      }
    }
    get powerFlags() {
      return 0;
    }
    power() {
      const roots = this.roots;
      for (let i = 0, n = roots.length; i < n; i += 1) {
        const root = roots[i];
        root.requireUpdate(this.powerFlags);
      }
    }
    unpower() {
      this.cancelUpdate();
      this.updateDelay = RefreshService.MinUpdateDelay;
    }
    onAttachRoot(root) {
      super.onAttachRoot(root);
      this.requestUpdate(root, root.flags & Model.UpdateMask, false);
    }
    onAttach() {
      super.onAttach();
      this.attachEvents();
    }
    onDetach() {
      this.detachEvents();
      super.onDetach();
    }
    attachEvents() {
      if (typeof document !== "undefined") {
        document.addEventListener("visibilitychange", this.onVisibilityChange);
      }
    }
    detachEvents() {
      if (typeof document !== "undefined") {
        document.removeEventListener("visibilitychange", this.onVisibilityChange);
      }
    }
    onVisibilityChange() {
      if (document.visibilityState === "visible") {
        this.power();
      } else {
        this.unpower();
      }
    }
    static global() {
      return new RefreshService;
    }
  }
  RefreshService.MinUpdateDelay = 0;
  RefreshService.MaxUpdateDelay = 167;
  RefreshService.MinAnalyzeInterval = 12;
  RefreshService.MaxAnalyzeInterval = 33;
  RefreshService.MinRefreshInterval = 4;
  RefreshService.MaxRefreshInterval = 16;
  __decorate([ util.Lazy ], RefreshService, "global", null);
  const RefreshProvider = function(_super) {
    const RefreshProvider = _super.extend("RefreshProvider");
    Object.defineProperty(RefreshProvider.prototype, "modelContext", {
      get() {
        let service = this.service;
        if (service === void 0 || service === null) {
          service = RefreshService.global();
        }
        return service.modelContext;
      },
      configurable: true
    });
    RefreshProvider.prototype.updatedModelContext = function() {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = RefreshService.global();
      }
      return service.updatedModelContext();
    };
    RefreshProvider.prototype.requestUpdate = function(target, updateFlags, immediate) {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = RefreshService.global();
      }
      service.requestUpdate(target, updateFlags, immediate);
    };
    RefreshProvider.prototype.createService = function() {
      return RefreshService.global();
    };
    return RefreshProvider;
  }(component.Provider);
  class SelectionService extends component.Service {
    constructor() {
      super();
      this.selections = [];
    }
    isSelected(model) {
      return this.selections.indexOf(model) >= 0;
    }
    select(model, options, index) {
      const selections = this.selections;
      if (selections.indexOf(model) < 0) {
        if (options === void 0) {
          options = null;
        }
        if (options === null || !options.multi) {
          this.unselectAll();
        }
        if (index === void 0) {
          index = selections.length;
        } else {
          if (index < 0) {
            index = selections.length + 1 + index;
          }
          index = Math.min(Math.max(0, index, selections.length));
        }
        const selectableTrait = model.getTrait(SelectableTrait);
        this.willSelect(model, index, options);
        if (selectableTrait !== null) {
          selectableTrait.willSelect(options);
        }
        selections.splice(index, 0, model);
        this.onSelect(model, index, options);
        if (selectableTrait !== null) {
          selectableTrait.onSelect(options);
          selectableTrait.didSelect(options);
        }
        this.didSelect(model, index, options);
      }
    }
    willSelect(model, index, options) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceWillSelect !== void 0) {
          observer.serviceWillSelect(model, index, options, this);
        }
      }
    }
    onSelect(model, index, options) {}
    didSelect(model, index, options) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceDidSelect !== void 0) {
          observer.serviceDidSelect(model, index, options, this);
        }
      }
    }
    unselect(model) {
      const selections = this.selections;
      const index = selections.indexOf(model);
      if (index >= 0) {
        const selectableTrait = model.getTrait(SelectableTrait);
        this.willUnselect(model);
        if (selectableTrait !== null) {
          selectableTrait.willUnselect();
        }
        selections.splice(index, 1);
        this.onUnselect(model);
        if (selectableTrait !== null) {
          selectableTrait.onUnselect();
          selectableTrait.didUnselect();
        }
        this.didUnselect(model);
      }
    }
    willUnselect(model) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceWillUnselect !== void 0) {
          observer.serviceWillUnselect(model, this);
        }
      }
    }
    onUnselect(model) {}
    didUnselect(model) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceDidUnselect !== void 0) {
          observer.serviceDidUnselect(model, this);
        }
      }
    }
    unselectAll() {
      const selections = this.selections;
      while (selections.length !== 0) {
        this.unselect(selections[0]);
      }
    }
    toggle(model, options, index) {
      const selections = this.selections;
      const selectedIndex = selections.indexOf(model);
      if (selectedIndex < 0) {
        if (options === void 0) {
          options = null;
        }
        if (options === null || !options.multi) {
          this.unselectAll();
        }
        if (index === void 0) {
          index = selections.length;
        } else {
          if (index < 0) {
            index = selections.length + 1 + index;
          }
          index = Math.min(Math.max(0, index, selections.length));
        }
        const selectableTrait = model.getTrait(SelectableTrait);
        this.willSelect(model, index, options);
        if (selectableTrait !== null) {
          selectableTrait.willSelect(options);
        }
        selections.splice(index, 0, model);
        this.onSelect(model, index, options);
        if (selectableTrait !== null) {
          selectableTrait.onSelect(options);
          selectableTrait.didSelect(options);
        }
        this.didSelect(model, index, options);
      } else {
        const selectableTrait = model.getTrait(SelectableTrait);
        this.willUnselect(model);
        if (selectableTrait !== null) {
          selectableTrait.willUnselect();
        }
        selections.splice(selectedIndex, 1);
        this.onUnselect(model);
        if (selectableTrait !== null) {
          selectableTrait.onUnselect();
          selectableTrait.didUnselect();
        }
        this.didUnselect(model);
      }
    }
    static global() {
      return new SelectionService;
    }
  }
  __decorate([ util.Lazy ], SelectionService, "global", null);
  const SelectionProvider = function(_super) {
    const SelectionProvider = _super.extend("SelectionProvider");
    Object.defineProperty(SelectionProvider.prototype, "selections", {
      get() {
        let service = this.service;
        if (service === void 0 || service === null) {
          service = SelectionService.global();
        }
        return service.selections;
      },
      configurable: true
    });
    SelectionProvider.prototype.select = function(model, options, index) {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = SelectionService.global();
      }
      service.select(model, options, index);
    };
    SelectionProvider.prototype.unselect = function(model) {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = SelectionService.global();
      }
      service.unselect(model);
    };
    SelectionProvider.prototype.unselectAll = function() {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = SelectionService.global();
      }
      service.unselectAll();
    };
    SelectionProvider.prototype.createService = function() {
      return SelectionService.global();
    };
    return SelectionProvider;
  }(component.Provider);
  class Model extends component.Component {
    constructor() {
      super();
      this.consumers = util.Arrays.empty;
      this.firstTrait = null;
      this.lastTrait = null;
      this.traitMap = null;
    }
    get componentType() {
      return Model;
    }
    willAttachParent(parent) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelWillAttachParent !== void 0) {
          observer.modelWillAttachParent(parent, this);
        }
      }
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.willAttachParent(parent);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    onAttachParent(parent) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.onAttachParent(parent);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    didAttachParent(parent) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.didAttachParent(parent);
        trait = next !== null && next.model === this ? next : null;
      }
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelDidAttachParent !== void 0) {
          observer.modelDidAttachParent(parent, this);
        }
      }
    }
    willDetachParent(parent) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelWillDetachParent !== void 0) {
          observer.modelWillDetachParent(parent, this);
        }
      }
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.willDetachParent(parent);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    onDetachParent(parent) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.onDetachParent(parent);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    didDetachParent(parent) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.didDetachParent(parent);
        trait = next !== null && next.model === this ? next : null;
      }
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelDidDetachParent !== void 0) {
          observer.modelDidDetachParent(parent, this);
        }
      }
    }
    setChild(key, newChild) {
      if (newChild !== null) {
        newChild = Model.fromAny(newChild);
      }
      return super.setChild(key, newChild);
    }
    appendChild(child, key) {
      child = Model.fromAny(child);
      return super.appendChild(child, key);
    }
    prependChild(child, key) {
      child = Model.fromAny(child);
      return super.prependChild(child, key);
    }
    insertChild(child, target, key) {
      child = Model.fromAny(child);
      return super.insertChild(child, target, key);
    }
    replaceChild(newChild, oldChild) {
      newChild = Model.fromAny(newChild);
      return super.replaceChild(newChild, oldChild);
    }
    willInsertChild(child, target) {
      super.willInsertChild(child, target);
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelWillInsertChild !== void 0) {
          observer.modelWillInsertChild(child, target, this);
        }
      }
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.willInsertChild(child, target);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    onInsertChild(child, target) {
      super.onInsertChild(child, target);
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.onInsertChild(child, target);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    didInsertChild(child, target) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.didInsertChild(child, target);
        trait = next !== null && next.model === this ? next : null;
      }
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelDidInsertChild !== void 0) {
          observer.modelDidInsertChild(child, target, this);
        }
      }
      super.didInsertChild(child, target);
    }
    cascadeInsert(updateFlags, modelContext) {
      if ((this.flags & Model.MountedFlag) !== 0) {
        if (updateFlags === void 0) {
          updateFlags = 0;
        }
        updateFlags |= this.flags & Model.UpdateMask;
        if ((updateFlags & Model.AnalyzeMask) !== 0) {
          if (modelContext === void 0) {
            modelContext = this.superModelContext;
          }
          this.cascadeAnalyze(updateFlags, modelContext);
        }
      }
    }
    willRemoveChild(child) {
      super.willRemoveChild(child);
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelWillRemoveChild !== void 0) {
          observer.modelWillRemoveChild(child, this);
        }
      }
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.willRemoveChild(child);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    onRemoveChild(child) {
      super.onRemoveChild(child);
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.onRemoveChild(child);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    didRemoveChild(child) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.didRemoveChild(child);
        trait = next !== null && next.model === this ? next : null;
      }
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelDidRemoveChild !== void 0) {
          observer.modelDidRemoveChild(child, this);
        }
      }
      super.didRemoveChild(child);
    }
    cascadeMount() {
      if ((this.flags & Model.MountedFlag) === 0) {
        this.willMount();
        this.setFlags(this.flags | Model.MountedFlag);
        this.onMount();
        this.mountTraits();
        this.mountChildren();
        this.didMount();
      } else {
        throw new Error("already mounted");
      }
    }
    willMount() {
      super.willMount();
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelWillMount !== void 0) {
          observer.modelWillMount(this);
        }
      }
    }
    onMount() {
      this.requestUpdate(this, this.flags & Model.UpdateMask, false);
      this.requireUpdate(this.mountFlags);
      if (this.decoherent !== null && this.decoherent.length !== 0) {
        this.requireUpdate(Model.NeedsMutate);
      }
      this.mountFasteners();
      if (this.consumers.length !== 0) {
        this.startConsuming();
      }
    }
    didMount() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelDidMount !== void 0) {
          observer.modelDidMount(this);
        }
      }
      super.didMount();
    }
    cascadeUnmount() {
      if ((this.flags & Model.MountedFlag) !== 0) {
        this.willUnmount();
        this.setFlags(this.flags & ~Model.MountedFlag);
        this.unmountChildren();
        this.unmountTraits();
        this.onUnmount();
        this.didUnmount();
      } else {
        throw new Error("already unmounted");
      }
    }
    willUnmount() {
      super.willUnmount();
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelWillUnmount !== void 0) {
          observer.modelWillUnmount(this);
        }
      }
    }
    onUnmount() {
      this.stopConsuming();
      super.onUnmount();
    }
    didUnmount() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelDidUnmount !== void 0) {
          observer.modelDidUnmount(this);
        }
      }
      super.didUnmount();
    }
    requireUpdate(updateFlags, immediate = false) {
      const flags = this.flags;
      const deltaUpdateFlags = updateFlags & ~flags & Model.UpdateMask;
      if (deltaUpdateFlags !== 0) {
        this.setFlags(flags | deltaUpdateFlags);
        this.requestUpdate(this, deltaUpdateFlags, immediate);
      }
    }
    needsUpdate(updateFlags, immediate) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        updateFlags = trait.needsUpdate(updateFlags, immediate);
        trait = next !== null && next.model === this ? next : null;
      }
      return updateFlags;
    }
    requestUpdate(target, updateFlags, immediate) {
      updateFlags = this.needsUpdate(updateFlags, immediate);
      let deltaUpdateFlags = this.flags & ~updateFlags & Model.UpdateMask;
      if ((updateFlags & Model.AnalyzeMask) !== 0) {
        deltaUpdateFlags |= Model.NeedsAnalyze;
      }
      if ((updateFlags & Model.RefreshMask) !== 0) {
        deltaUpdateFlags |= Model.NeedsRefresh;
      }
      if (deltaUpdateFlags !== 0 || immediate) {
        this.setFlags(this.flags | deltaUpdateFlags);
        const parent = this.parent;
        if (parent !== null) {
          parent.requestUpdate(target, updateFlags, immediate);
        } else if (this.mounted) {
          const refreshProvider = this.refreshProvider.service;
          if (refreshProvider !== void 0 && refreshProvider !== null) {
            refreshProvider.requestUpdate(target, updateFlags, immediate);
          }
        }
      }
    }
    get updating() {
      return (this.flags & Model.UpdatingMask) !== 0;
    }
    get analyzing() {
      return (this.flags & Model.AnalyzingFlag) !== 0;
    }
    needsAnalyze(analyzeFlags, modelContext) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        analyzeFlags = trait.needsAnalyze(analyzeFlags, modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
      return analyzeFlags;
    }
    cascadeAnalyze(analyzeFlags, baesModelContext) {
      const modelContext = this.extendModelContext(baesModelContext);
      const outerModelContext = ModelContext.current;
      try {
        ModelContext.current = modelContext;
        analyzeFlags &= ~Model.NeedsAnalyze;
        analyzeFlags |= this.flags & Model.UpdateMask;
        analyzeFlags = this.needsAnalyze(analyzeFlags, modelContext);
        if ((analyzeFlags & Model.AnalyzeMask) !== 0) {
          let cascadeFlags = analyzeFlags;
          this.setFlags(this.flags & ~Model.NeedsAnalyze | (Model.AnalyzingFlag | Model.ContextualFlag));
          this.willAnalyze(cascadeFlags, modelContext);
          if (((this.flags | analyzeFlags) & Model.NeedsMutate) !== 0) {
            cascadeFlags |= Model.NeedsMutate;
            this.setFlags(this.flags & ~Model.NeedsMutate);
            this.willMutate(modelContext);
          }
          if (((this.flags | analyzeFlags) & Model.NeedsAggregate) !== 0) {
            cascadeFlags |= Model.NeedsAggregate;
            this.setFlags(this.flags & ~Model.NeedsAggregate);
            this.willAggregate(modelContext);
          }
          if (((this.flags | analyzeFlags) & Model.NeedsCorrelate) !== 0) {
            cascadeFlags |= Model.NeedsCorrelate;
            this.setFlags(this.flags & ~Model.NeedsCorrelate);
            this.willCorrelate(modelContext);
          }
          this.onAnalyze(cascadeFlags, modelContext);
          if ((cascadeFlags & Model.NeedsMutate) !== 0) {
            this.onMutate(modelContext);
          }
          if ((cascadeFlags & Model.NeedsAggregate) !== 0) {
            this.onAggregate(modelContext);
          }
          if ((cascadeFlags & Model.NeedsCorrelate) !== 0) {
            this.onCorrelate(modelContext);
          }
          if ((cascadeFlags & Model.AnalyzeMask) !== 0) {
            this.setFlags(this.flags & ~Model.ContextualFlag);
            this.analyzeChildren(cascadeFlags, modelContext, this.analyzeChild);
            this.setFlags(this.flags | Model.ContextualFlag);
          }
          if ((cascadeFlags & Model.NeedsCorrelate) !== 0) {
            this.didCorrelate(modelContext);
          }
          if ((cascadeFlags & Model.NeedsAggregate) !== 0) {
            this.didAggregate(modelContext);
          }
          if ((cascadeFlags & Model.NeedsMutate) !== 0) {
            this.didMutate(modelContext);
          }
          this.didAnalyze(cascadeFlags, modelContext);
        }
      } finally {
        this.setFlags(this.flags & ~(Model.AnalyzingFlag | Model.ContextualFlag));
        ModelContext.current = outerModelContext;
      }
    }
    willAnalyze(analyzeFlags, modelContext) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.willAnalyze(analyzeFlags, modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    onAnalyze(analyzeFlags, modelContext) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.onAnalyze(analyzeFlags, modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    didAnalyze(analyzeFlags, modelContext) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.didAnalyze(analyzeFlags, modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    willMutate(modelContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelWillMutate !== void 0) {
          observer.modelWillMutate(modelContext, this);
        }
      }
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.willMutate(modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    onMutate(modelContext) {
      this.recohereFasteners(modelContext.updateTime);
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.onMutate(modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    didMutate(modelContext) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.didMutate(modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelDidMutate !== void 0) {
          observer.modelDidMutate(modelContext, this);
        }
      }
    }
    willAggregate(modelContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelWillAggregate !== void 0) {
          observer.modelWillAggregate(modelContext, this);
        }
      }
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.willAggregate(modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    onAggregate(modelContext) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.onAggregate(modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    didAggregate(modelContext) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.didAggregate(modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelDidAggregate !== void 0) {
          observer.modelDidAggregate(modelContext, this);
        }
      }
    }
    willCorrelate(modelContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelWillCorrelate !== void 0) {
          observer.modelWillCorrelate(modelContext, this);
        }
      }
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.willCorrelate(modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    onCorrelate(modelContext) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.onCorrelate(modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    didCorrelate(modelContext) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.didCorrelate(modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelDidCorrelate !== void 0) {
          observer.modelDidCorrelate(modelContext, this);
        }
      }
    }
    analyzeChildren(analyzeFlags, modelContext, analyzeChild) {
      const trait = this.firstTrait;
      if (trait !== null) {
        this.analyzeTraitChildren(trait, analyzeFlags, modelContext, analyzeChild);
      } else {
        this.analyzeOwnChildren(analyzeFlags, modelContext, analyzeChild);
      }
    }
    analyzeTraitChildren(trait, analyzeFlags, modelContext, analyzeChild) {
      const next = trait.nextTrait;
      if (next !== null) {
        trait.analyzeChildren(analyzeFlags, modelContext, analyzeChild, this.analyzeTraitChildren.bind(this, next));
      } else {
        trait.analyzeChildren(analyzeFlags, modelContext, analyzeChild, this.analyzeOwnChildren);
      }
    }
    analyzeOwnChildren(analyzeFlags, modelContext, analyzeChild) {
      let child = this.firstChild;
      while (child !== null) {
        const next = child.nextSibling;
        analyzeChild.call(this, child, analyzeFlags, modelContext);
        if (next !== null && next.parent !== this) {
          throw new Error("inconsistent analyze pass");
        }
        child = next;
      }
    }
    analyzeChild(child, analyzeFlags, modelContext) {
      child.cascadeAnalyze(analyzeFlags, modelContext);
    }
    get refreshing() {
      return (this.flags & Model.RefreshingFlag) !== 0;
    }
    needsRefresh(refreshFlags, modelContext) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        refreshFlags = trait.needsRefresh(refreshFlags, modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
      return refreshFlags;
    }
    cascadeRefresh(refreshFlags, baseModelContext) {
      const modelContext = this.extendModelContext(baseModelContext);
      const outerModelContext = ModelContext.current;
      try {
        ModelContext.current = modelContext;
        refreshFlags &= ~Model.NeedsRefresh;
        refreshFlags |= this.flags & Model.UpdateMask;
        refreshFlags = this.needsRefresh(refreshFlags, modelContext);
        if ((refreshFlags & Model.RefreshMask) !== 0) {
          let cascadeFlags = refreshFlags;
          this.setFlags(this.flags & ~Model.NeedsRefresh | (Model.RefreshingFlag | Model.ContextualFlag));
          this.willRefresh(cascadeFlags, modelContext);
          if (((this.flags | refreshFlags) & Model.NeedsValidate) !== 0) {
            cascadeFlags |= Model.NeedsValidate;
            this.setFlags(this.flags & ~Model.NeedsValidate);
            this.willValidate(modelContext);
          }
          if (((this.flags | refreshFlags) & Model.NeedsReconcile) !== 0) {
            cascadeFlags |= Model.NeedsReconcile;
            this.setFlags(this.flags & ~Model.NeedsReconcile);
            this.willReconcile(modelContext);
          }
          this.onRefresh(cascadeFlags, modelContext);
          if ((cascadeFlags & Model.NeedsValidate) !== 0) {
            this.onValidate(modelContext);
          }
          if ((cascadeFlags & Model.NeedsReconcile) !== 0) {
            this.onReconcile(modelContext);
          }
          if (cascadeFlags & Model.RefreshMask) {
            this.setFlags(this.flags & ~Model.ContextualFlag);
            this.refreshChildren(cascadeFlags, modelContext, this.refreshChild);
            this.setFlags(this.flags | Model.ContextualFlag);
          }
          if ((cascadeFlags & Model.NeedsReconcile) !== 0) {
            this.didReconcile(modelContext);
          }
          if ((cascadeFlags & Model.NeedsValidate) !== 0) {
            this.didValidate(modelContext);
          }
          this.didRefresh(cascadeFlags, modelContext);
        }
      } finally {
        this.setFlags(this.flags & ~(Model.RefreshingFlag | Model.ContextualFlag));
        ModelContext.current = outerModelContext;
      }
    }
    willRefresh(refreshFlags, modelContext) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.willRefresh(refreshFlags, modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    onRefresh(refreshFlags, modelContext) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.onRefresh(refreshFlags, modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    didRefresh(refreshFlags, modelContext) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.didRefresh(refreshFlags, modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    willValidate(modelContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelWillValidate !== void 0) {
          observer.modelWillValidate(modelContext, this);
        }
      }
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.willValidate(modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    onValidate(modelContext) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.onValidate(modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    didValidate(modelContext) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.didValidate(modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelDidValidate !== void 0) {
          observer.modelDidValidate(modelContext, this);
        }
      }
    }
    willReconcile(modelContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelWillReconcile !== void 0) {
          observer.modelWillReconcile(modelContext, this);
        }
      }
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.willReconcile(modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    onReconcile(modelContext) {
      this.recohereDownlinks(modelContext.updateTime);
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.onReconcile(modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
    }
    didReconcile(modelContext) {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.didReconcile(modelContext);
        trait = next !== null && next.model === this ? next : null;
      }
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelDidReconcile !== void 0) {
          observer.modelDidReconcile(modelContext, this);
        }
      }
    }
    refreshChildren(refreshFlags, modelContext, refreshChild) {
      const trait = this.firstTrait;
      if (trait !== null) {
        this.refreshTraitChildren(trait, refreshFlags, modelContext, refreshChild);
      } else {
        this.refreshOwnChildren(refreshFlags, modelContext, refreshChild);
      }
    }
    refreshTraitChildren(trait, refreshFlags, modelContext, refreshChild) {
      const next = trait.nextTrait;
      if (next !== null) {
        trait.refreshChildren(refreshFlags, modelContext, refreshChild, this.refreshTraitChildren.bind(this, next));
      } else {
        trait.refreshChildren(refreshFlags, modelContext, refreshChild, this.refreshOwnChildren);
      }
    }
    refreshOwnChildren(refreshFlags, modelContext, refreshChild) {
      let child = this.firstChild;
      while (child !== null) {
        const next = child.nextSibling;
        refreshChild.call(this, child, refreshFlags, modelContext);
        if (next !== null && next.parent !== this) {
          throw new Error("inconsistent refresh pass");
        }
        child = next;
      }
    }
    refreshChild(child, refreshFlags, modelContext) {
      child.cascadeRefresh(refreshFlags, modelContext);
    }
    setFirstTrait(firstTrait) {
      this.firstTrait = firstTrait;
    }
    setLastTrait(lastTrait) {
      this.lastTrait = lastTrait;
    }
    forEachTrait(callback, thisArg) {
      let result;
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        const result = callback.call(thisArg, trait);
        if (result !== void 0) {
          break;
        }
        trait = next !== null && next.model === this ? next : null;
      }
      return result;
    }
    insertTraitMap(trait) {
      const key = trait.key;
      if (key !== void 0) {
        let traitMap = this.traitMap;
        if (traitMap === null) {
          traitMap = {};
          this.traitMap = traitMap;
        }
        traitMap[key] = trait;
      }
    }
    removeTraitMap(trait) {
      const key = trait.key;
      if (key !== void 0) {
        const traitMap = this.traitMap;
        if (traitMap !== null) {
          delete traitMap[key];
        }
      }
    }
    getTrait(key, traitBound) {
      if (typeof key === "string") {
        const traitMap = this.traitMap;
        if (traitMap !== null) {
          const trait = traitMap[key];
          if (trait !== void 0 && (traitBound === void 0 || trait instanceof traitBound)) {
            return trait;
          }
        }
      } else {
        let trait = this.firstTrait;
        while (trait !== null) {
          if (trait instanceof key) {
            return trait;
          }
          trait = trait.nextTrait;
        }
      }
      return null;
    }
    setTrait(key, newTrait) {
      if (newTrait !== null) {
        newTrait = Trait.fromAny(newTrait);
      }
      const oldTrait = this.getTrait(key);
      let target;
      if (oldTrait !== null && newTrait !== null && oldTrait !== newTrait) {
        newTrait.remove();
        target = oldTrait.nextTrait;
        this.willRemoveTrait(oldTrait);
        oldTrait.detachModel(this);
        this.removeTraitMap(oldTrait);
        this.onRemoveTrait(oldTrait);
        this.didRemoveTrait(oldTrait);
        oldTrait.setKey(void 0);
        newTrait.setKey(oldTrait.key);
        this.willInsertTrait(newTrait, target);
        this.insertTraitMap(newTrait);
        newTrait.attachModel(this, target);
        this.onInsertTrait(newTrait, target);
        this.didInsertTrait(newTrait, target);
      } else if (newTrait !== oldTrait || newTrait !== null && newTrait.key !== key) {
        if (oldTrait !== null) {
          target = oldTrait.nextTrait;
          this.willRemoveTrait(oldTrait);
          oldTrait.detachModel(this);
          this.removeTraitMap(oldTrait);
          this.onRemoveTrait(oldTrait);
          this.didRemoveTrait(oldTrait);
          oldTrait.setKey(void 0);
        } else {
          target = null;
        }
        if (newTrait !== null) {
          newTrait.remove();
          newTrait.setKey(key);
          this.willInsertTrait(newTrait, target);
          this.insertTraitMap(newTrait);
          newTrait.attachModel(this, target);
          this.onInsertTrait(newTrait, target);
          this.didInsertTrait(newTrait, target);
        }
      }
      return oldTrait;
    }
    appendTrait(trait, key) {
      trait = Trait.fromAny(trait);
      trait.remove();
      if (key !== void 0) {
        this.removeChild(key);
      }
      trait.setKey(key);
      this.willInsertTrait(trait, null);
      this.insertTraitMap(trait);
      trait.attachModel(this, null);
      this.onInsertTrait(trait, null);
      this.didInsertTrait(trait, null);
      return trait;
    }
    prependTrait(trait, key) {
      trait = Trait.fromAny(trait);
      trait.remove();
      if (key !== void 0) {
        this.removeChild(key);
      }
      const target = this.firstTrait;
      trait.setKey(key);
      this.willInsertTrait(trait, target);
      this.insertTraitMap(trait);
      trait.attachModel(this, target);
      this.onInsertTrait(trait, target);
      this.didInsertTrait(trait, target);
      return trait;
    }
    insertTrait(trait, target, key) {
      if (target !== null && target.model !== this) {
        throw new Error("insert target is not a member trait");
      }
      trait = Trait.fromAny(trait);
      trait.remove();
      if (key !== void 0) {
        this.removeChild(key);
      }
      trait.setKey(key);
      this.willInsertTrait(trait, target);
      this.insertTraitMap(trait);
      trait.attachModel(this, target);
      this.onInsertTrait(trait, target);
      this.didInsertTrait(trait, target);
      return trait;
    }
    replaceTrait(newTrait, oldTrait) {
      if (oldTrait.model !== this) {
        throw new Error("replacement target is not a member trait");
      }
      newTrait = Trait.fromAny(newTrait);
      if (newTrait !== oldTrait) {
        newTrait.remove();
        const target = oldTrait.nextTrait;
        this.willRemoveTrait(oldTrait);
        oldTrait.detachModel(this);
        this.removeTraitMap(oldTrait);
        this.onRemoveTrait(oldTrait);
        this.didRemoveTrait(oldTrait);
        oldTrait.setKey(void 0);
        newTrait.setKey(oldTrait.key);
        this.willInsertTrait(newTrait, target);
        this.insertTraitMap(newTrait);
        newTrait.attachModel(this, target);
        this.onInsertTrait(newTrait, target);
        this.didInsertTrait(newTrait, target);
      }
      return oldTrait;
    }
    get insertTraitFlags() {
      return this.constructor.InsertTraitFlags;
    }
    willInsertTrait(trait, target) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelWillInsertTrait !== void 0) {
          observer.modelWillInsertTrait(trait, target, this);
        }
      }
      let prev = this.firstTrait;
      while (prev !== null) {
        const next = prev.nextTrait;
        if (prev !== trait) {
          prev.willInsertTrait(trait, target);
        }
        prev = next !== null && next.model === this ? next : null;
      }
    }
    onInsertTrait(trait, target) {
      this.requireUpdate(this.insertTraitFlags);
      this.bindTraitFasteners(trait, target);
      let prev = this.firstTrait;
      while (prev !== null) {
        const next = prev.nextTrait;
        if (prev !== trait) {
          prev.onInsertTrait(trait, target);
        }
        prev = next !== null && next.model === this ? next : null;
      }
    }
    didInsertTrait(trait, target) {
      let prev = this.firstTrait;
      while (prev !== null) {
        const next = prev.nextTrait;
        if (prev !== trait) {
          prev.didInsertTrait(trait, target);
        }
        prev = next !== null && next.model === this ? next : null;
      }
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelDidInsertTrait !== void 0) {
          observer.modelDidInsertTrait(trait, target, this);
        }
      }
    }
    removeTrait(key) {
      let trait;
      if (typeof key === "string") {
        trait = this.getTrait(key);
        if (trait === null) {
          return null;
        }
      } else {
        trait = key;
        if (trait.model !== this) {
          throw new Error("not a member trait");
        }
      }
      this.willRemoveTrait(trait);
      trait.detachModel(this);
      this.removeTraitMap(trait);
      this.onRemoveTrait(trait);
      this.didRemoveTrait(trait);
      trait.setKey(void 0);
      return trait;
    }
    get removeTraitFlags() {
      return this.constructor.RemoveTraitFlags;
    }
    willRemoveTrait(trait) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelWillRemoveTrait !== void 0) {
          observer.modelWillRemoveTrait(trait, this);
        }
      }
      let prev = this.firstTrait;
      while (prev !== null) {
        const next = prev.nextTrait;
        if (prev !== trait) {
          prev.willRemoveTrait(trait);
        }
        prev = next !== null && next.model === this ? next : null;
      }
    }
    onRemoveTrait(trait) {
      this.requireUpdate(this.removeTraitFlags);
      let prev = this.firstTrait;
      while (prev !== null) {
        const next = prev.nextTrait;
        if (prev !== trait) {
          prev.onRemoveTrait(trait);
        }
        prev = next !== null && next.model === this ? next : null;
      }
      this.unbindTraitFasteners(trait);
    }
    didRemoveTrait(trait) {
      let prev = this.firstTrait;
      while (prev !== null) {
        const next = prev.nextTrait;
        if (prev !== trait) {
          prev.didRemoveTrait(trait);
        }
        prev = next !== null && next.model === this ? next : null;
      }
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelDidRemoveTrait !== void 0) {
          observer.modelDidRemoveTrait(trait, this);
        }
      }
    }
    sortTraits(comparator) {
      let trait = this.firstTrait;
      if (trait !== null) {
        const traits = [];
        do {
          traits.push(trait);
          trait = trait.nextTrait;
        } while (trait !== null);
        traits.sort(comparator);
        trait = traits[0];
        this.setFirstTrait(trait);
        trait.setPreviousTrait(null);
        for (let i = 1; i < traits.length; i += 1) {
          const next = traits[i];
          trait.setNextTrait(next);
          next.setPreviousTrait(trait);
          trait = next;
        }
        trait.setNextTrait(null);
        this.setLastTrait(trait);
      }
    }
    mountTraits() {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.mountTrait();
        if (next !== null && next.model !== this) {
          throw new Error("inconsistent mount");
        }
        trait = next;
      }
    }
    unmountTraits() {
      let trait = this.firstTrait;
      while (trait !== null) {
        const next = trait.nextTrait;
        trait.unmountTrait();
        if (next !== null && next.model !== this) {
          throw new Error("inconsistent unmount");
        }
        trait = next;
      }
    }
    getSuperTrait(superBound) {
      const parent = this.parent;
      if (parent === null) {
        return null;
      } else {
        const trait = parent.getTrait(superBound);
        if (trait !== null) {
          return trait;
        } else {
          return parent.getSuperTrait(superBound);
        }
      }
    }
    getBaseTrait(baseBound) {
      const parent = this.parent;
      if (parent === null) {
        return null;
      } else {
        const baseTrait = parent.getBaseTrait(baseBound);
        if (baseTrait !== null) {
          return baseTrait;
        } else {
          return parent.getTrait(baseBound);
        }
      }
    }
    bindFastener(fastener) {
      super.bindFastener(fastener);
      if (fastener instanceof TraitRelation && fastener.binds) {
        let trait = this.firstTrait;
        while (trait !== null) {
          const next = trait.nextTrait;
          fastener.bindTrait(trait, next);
          trait = next !== null && next.model === this ? next : null;
        }
      }
      if (fastener instanceof client.DownlinkFastener && fastener.consumed === true && this.consuming) {
        fastener.consume(this);
      }
    }
    bindChildFastener(fastener, child, target) {
      super.bindChildFastener(fastener, child, target);
      if (fastener instanceof ModelRelation || fastener instanceof TraitRelation) {
        fastener.bindModel(child, target);
      }
    }
    unbindChildFastener(fastener, child) {
      if (fastener instanceof ModelRelation || fastener instanceof TraitRelation) {
        fastener.unbindModel(child);
      }
      super.unbindChildFastener(fastener, child);
    }
    bindTraitFasteners(trait, target) {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        this.bindTraitFastener(fastener, trait, target);
      }
    }
    bindTraitFastener(fastener, trait, target) {
      if (fastener instanceof TraitRelation) {
        fastener.bindTrait(trait, target);
      }
    }
    unbindTraitFasteners(trait) {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        this.unbindTraitFastener(fastener, trait);
      }
    }
    unbindTraitFastener(fastener, trait) {
      if (fastener instanceof TraitRelation) {
        fastener.unbindTrait(trait);
      }
    }
    decohereFastener(fastener) {
      super.decohereFastener(fastener);
      if (fastener instanceof client.DownlinkFastener) {
        this.requireUpdate(Model.NeedsReconcile);
      } else {
        this.requireUpdate(Model.NeedsMutate);
      }
    }
    recohereFasteners(t) {
      const decoherent = this.decoherent;
      if (decoherent !== null) {
        const decoherentCount = decoherent.length;
        if (decoherentCount !== 0) {
          if (t === void 0) {
            t = performance.now();
          }
          this.decoherent = null;
          for (let i = 0; i < decoherentCount; i += 1) {
            const fastener = decoherent[i];
            if (!(fastener instanceof client.DownlinkFastener)) {
              fastener.recohere(t);
            } else {
              this.decohereFastener(fastener);
            }
          }
        }
      }
    }
    recohereDownlinks(t) {
      const decoherent = this.decoherent;
      if (decoherent !== null) {
        const decoherentCount = decoherent.length;
        if (decoherentCount !== 0) {
          this.decoherent = null;
          for (let i = 0; i < decoherentCount; i += 1) {
            const fastener = decoherent[i];
            if (fastener instanceof client.DownlinkFastener) {
              fastener.recohere(t);
            } else {
              this.decohereFastener(fastener);
            }
          }
        }
      }
    }
    consume(consumer) {
      const oldConsumers = this.consumers;
      const newConsumers = util.Arrays.inserted(consumer, oldConsumers);
      if (oldConsumers !== newConsumers) {
        this.willConsume(consumer);
        this.consumers = newConsumers;
        this.onConsume(consumer);
        this.didConsume(consumer);
        if (oldConsumers.length === 0 && this.mounted) {
          this.startConsuming();
        }
      }
    }
    willConsume(consumer) {}
    onConsume(consumer) {}
    didConsume(consumer) {}
    unconsume(consumer) {
      const oldConsumers = this.consumers;
      const newConsumers = util.Arrays.removed(consumer, oldConsumers);
      if (oldConsumers !== newConsumers) {
        this.willUnconsume(consumer);
        this.consumers = newConsumers;
        this.onUnconsume(consumer);
        this.didUnconsume(consumer);
        if (newConsumers.length === 0) {
          this.stopConsuming();
        }
      }
    }
    willUnconsume(consumer) {}
    onUnconsume(consumer) {}
    didUnconsume(consumer) {}
    get consuming() {
      return (this.flags & Model.ConsumingFlag) !== 0;
    }
    get startConsumingFlags() {
      return this.constructor.StartConsumingFlags;
    }
    startConsuming() {
      if ((this.flags & Model.ConsumingFlag) === 0) {
        this.willStartConsuming();
        this.setFlags(this.flags | Model.ConsumingFlag);
        this.onStartConsuming();
        this.didStartConsuming();
      }
    }
    willStartConsuming() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelWillStartConsuming !== void 0) {
          observer.modelWillStartConsuming(this);
        }
      }
    }
    onStartConsuming() {
      this.requireUpdate(this.startConsumingFlags);
      this.startConsumingFasteners();
    }
    didStartConsuming() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelDidStartConsuming !== void 0) {
          observer.modelDidStartConsuming(this);
        }
      }
    }
    get stopConsumingFlags() {
      return this.constructor.StopConsumingFlags;
    }
    stopConsuming() {
      if ((this.flags & Model.ConsumingFlag) !== 0) {
        this.willStopConsuming();
        this.setFlags(this.flags & ~Model.ConsumingFlag);
        this.onStopConsuming();
        this.didStopConsuming();
      }
    }
    willStopConsuming() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelWillStopConsuming !== void 0) {
          observer.modelWillStopConsuming(this);
        }
      }
    }
    onStopConsuming() {
      this.requireUpdate(this.stopConsumingFlags);
      this.stopConsumingFasteners();
    }
    didStopConsuming() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.modelDidStopConsuming !== void 0) {
          observer.modelDidStopConsuming(this);
        }
      }
    }
    startConsumingFasteners() {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        if (fastener instanceof client.DownlinkFastener && fastener.consumed === true) {
          fastener.consume(this);
        }
      }
    }
    stopConsumingFasteners() {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        if (fastener instanceof client.DownlinkFastener && fastener.consumed === true) {
          fastener.unconsume(this);
        }
      }
    }
    get superModelContext() {
      const parent = this.parent;
      if (parent !== null) {
        return parent.modelContext;
      } else {
        return this.refreshProvider.updatedModelContext();
      }
    }
    extendModelContext(modelContext) {
      return modelContext;
    }
    get modelContext() {
      if ((this.flags & Model.ContextualFlag) !== 0) {
        return ModelContext.current;
      } else {
        return this.extendModelContext(this.superModelContext);
      }
    }
    init(init) {}
    static create() {
      return new this;
    }
    static fromInit(init) {
      let type;
      if ((typeof init === "object" && init !== null || typeof init === "function") && util.Creatable.is(init.type)) {
        type = init.type;
      } else {
        type = this;
      }
      const view = type.create();
      view.init(init);
      return view;
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return value;
      } else if (value instanceof Model) {
        if (value instanceof this) {
          return value;
        } else {
          throw new TypeError(value + " not an instance of " + this);
        }
      } else if (util.Creatable.is(value)) {
        return value.create();
      } else {
        return this.fromInit(value);
      }
    }
  }
  Model.uid = function() {
    let nextId = 1;
    return function uid() {
      const id = ~~nextId;
      nextId += 1;
      return id;
    };
  }();
  Model.MountedFlag = component.Component.MountedFlag;
  Model.RemovingFlag = component.Component.RemovingFlag;
  Model.AnalyzingFlag = 1 << component.Component.FlagShift + 0;
  Model.RefreshingFlag = 1 << component.Component.FlagShift + 1;
  Model.ContextualFlag = 1 << component.Component.FlagShift + 2;
  Model.ConsumingFlag = 1 << component.Component.FlagShift + 3;
  Model.UpdatingMask = Model.AnalyzingFlag | Model.RefreshingFlag;
  Model.StatusMask = Model.MountedFlag | Model.RemovingFlag | Model.AnalyzingFlag | Model.RefreshingFlag | Model.ContextualFlag | Model.ConsumingFlag;
  Model.NeedsAnalyze = 1 << component.Component.FlagShift + 4;
  Model.NeedsMutate = 1 << component.Component.FlagShift + 5;
  Model.NeedsAggregate = 1 << component.Component.FlagShift + 6;
  Model.NeedsCorrelate = 1 << component.Component.FlagShift + 7;
  Model.AnalyzeMask = Model.NeedsAnalyze | Model.NeedsMutate | Model.NeedsAggregate | Model.NeedsCorrelate;
  Model.NeedsRefresh = 1 << component.Component.FlagShift + 8;
  Model.NeedsValidate = 1 << component.Component.FlagShift + 9;
  Model.NeedsReconcile = 1 << component.Component.FlagShift + 10;
  Model.RefreshMask = Model.NeedsRefresh | Model.NeedsValidate | Model.NeedsReconcile;
  Model.UpdateMask = Model.AnalyzeMask | Model.RefreshMask;
  Model.FlagShift = component.Component.FlagShift + 11;
  Model.FlagMask = (1 << Model.FlagShift) - 1;
  Model.MountFlags = 0;
  Model.InsertChildFlags = 0;
  Model.RemoveChildFlags = 0;
  Model.InsertTraitFlags = 0;
  Model.RemoveTraitFlags = 0;
  Model.StartConsumingFlags = 0;
  Model.StopConsumingFlags = 0;
  __decorate([ component.Provider({
    extends: RefreshProvider,
    type: RefreshService,
    observes: false,
    service: RefreshService.global()
  }) ], Model.prototype, "refreshProvider", void 0);
  __decorate([ component.Provider({
    extends: SelectionProvider,
    type: SelectionService,
    observes: false,
    service: SelectionService.global()
  }) ], Model.prototype, "selectionProvider", void 0);
  __decorate([ component.Provider({
    extends: client.WarpProvider,
    type: client.WarpService,
    observes: false,
    service: client.WarpService.global()
  }) ], Model.prototype, "warpProvider", void 0);
  __decorate([ component.Property({
    type: Object,
    inherits: true,
    value: null,
    updateFlags: Model.NeedsReconcile
  }) ], Model.prototype, "warpRef", void 0);
  const ModelRelation = function(_super) {
    const ModelRelation = _super.extend("ModelRelation");
    Object.defineProperty(ModelRelation.prototype, "fastenerType", {
      get: function() {
        return ModelRelation;
      },
      configurable: true
    });
    ModelRelation.prototype.initModel = function(model) {};
    ModelRelation.prototype.willAttachModel = function(model, target) {};
    ModelRelation.prototype.onAttachModel = function(model, target) {
      if (this.observes === true) {
        model.observe(this);
      }
    };
    ModelRelation.prototype.didAttachModel = function(model, target) {};
    ModelRelation.prototype.deinitModel = function(model) {};
    ModelRelation.prototype.willDetachModel = function(model) {};
    ModelRelation.prototype.onDetachModel = function(model) {
      if (this.observes === true) {
        model.unobserve(this);
      }
    };
    ModelRelation.prototype.didDetachModel = function(model) {};
    Object.defineProperty(ModelRelation.prototype, "parentModel", {
      get() {
        const owner = this.owner;
        if (owner instanceof Model) {
          return owner;
        } else if (owner instanceof Trait) {
          return owner.model;
        } else {
          return null;
        }
      },
      configurable: true
    });
    ModelRelation.prototype.insertChild = function(parent, child, target, key) {
      parent.insertChild(child, target, key);
    };
    ModelRelation.prototype.bindModel = function(model, target) {};
    ModelRelation.prototype.unbindModel = function(model) {};
    ModelRelation.prototype.detectModel = function(model) {
      return null;
    };
    ModelRelation.prototype.createModel = function() {
      let model;
      const type = this.type;
      if (type !== void 0) {
        model = type.create();
      }
      if (model === void 0 || model === null) {
        let message = "Unable to create ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "model";
        throw new Error(message);
      }
      return model;
    };
    ModelRelation.prototype.fromAny = function(value) {
      const type = this.type;
      if (type !== void 0) {
        return type.fromAny(value);
      } else {
        return Model.fromAny(value);
      }
    };
    Object.defineProperty(ModelRelation.prototype, "lazy", {
      get: function() {
        return false;
      },
      configurable: true
    });
    Object.defineProperty(ModelRelation.prototype, "static", {
      get: function() {
        return true;
      },
      configurable: true
    });
    ModelRelation.construct = function(fastenerClass, fastener, owner) {
      fastener = _super.construct(fastenerClass, fastener, owner);
      return fastener;
    };
    ModelRelation.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        return fastener;
      };
      return fastenerClass;
    };
    return ModelRelation;
  }(component.Fastener);
  const ModelRef = function(_super) {
    const ModelRef = _super.extend("ModelRef");
    Object.defineProperty(ModelRef.prototype, "fastenerType", {
      get: function() {
        return ModelRef;
      },
      configurable: true
    });
    ModelRef.prototype.onInherit = function(superFastener) {
      this.setModel(superFastener.model);
    };
    ModelRef.prototype.getModel = function() {
      const model = this.model;
      if (model === null) {
        let message = model + " ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "model";
        throw new TypeError(message);
      }
      return model;
    };
    ModelRef.prototype.setModel = function(newModel, target, key) {
      if (newModel !== null) {
        newModel = this.fromAny(newModel);
      }
      let oldModel = this.model;
      if (oldModel !== newModel) {
        if (target === void 0) {
          target = null;
        }
        let parent;
        if (this.binds && (parent = this.parentModel, parent !== null)) {
          if (oldModel !== null && oldModel.parent === parent) {
            if (target === null) {
              target = oldModel.nextSibling;
            }
            oldModel.remove();
          }
          if (newModel !== null) {
            if (key === void 0) {
              key = this.key;
            }
            this.insertChild(parent, newModel, target, key);
          }
          oldModel = this.model;
        }
        if (oldModel !== newModel) {
          if (oldModel !== null) {
            this.willDetachModel(oldModel);
            this.model = null;
            this.onDetachModel(oldModel);
            this.deinitModel(oldModel);
            this.didDetachModel(oldModel);
          }
          if (newModel !== null) {
            this.willAttachModel(newModel, target);
            this.model = newModel;
            this.onAttachModel(newModel, target);
            this.initModel(newModel);
            this.didAttachModel(newModel, target);
          }
        }
      }
      return oldModel;
    };
    ModelRef.prototype.attachModel = function(newModel, target) {
      const oldModel = this.model;
      if (newModel !== void 0 && newModel !== null) {
        newModel = this.fromAny(newModel);
      } else if (oldModel === null) {
        newModel = this.createModel();
      } else {
        newModel = oldModel;
      }
      if (newModel !== oldModel) {
        if (target === void 0) {
          target = null;
        }
        if (oldModel !== null) {
          this.willDetachModel(oldModel);
          this.model = null;
          this.onDetachModel(oldModel);
          this.deinitModel(oldModel);
          this.didDetachModel(oldModel);
        }
        this.willAttachModel(newModel, target);
        this.model = newModel;
        this.onAttachModel(newModel, target);
        this.initModel(newModel);
        this.didAttachModel(newModel, target);
      }
      return newModel;
    };
    ModelRef.prototype.detachModel = function() {
      const oldModel = this.model;
      if (oldModel !== null) {
        this.willDetachModel(oldModel);
        this.model = null;
        this.onDetachModel(oldModel);
        this.deinitModel(oldModel);
        this.didDetachModel(oldModel);
      }
      return oldModel;
    };
    ModelRef.prototype.insertModel = function(parent, newModel, target, key) {
      if (newModel !== void 0 && newModel !== null) {
        newModel = this.fromAny(newModel);
      } else {
        const oldModel = this.model;
        if (oldModel === null) {
          newModel = this.createModel();
        } else {
          newModel = oldModel;
        }
      }
      if (parent === void 0 || parent === null) {
        parent = this.parentModel;
      }
      if (target === void 0) {
        target = null;
      }
      if (key === void 0) {
        key = this.key;
      }
      if (parent !== null && (newModel.parent !== parent || newModel.key !== key)) {
        this.insertChild(parent, newModel, target, key);
      }
      const oldModel = this.model;
      if (newModel !== oldModel) {
        if (oldModel !== null) {
          this.willDetachModel(oldModel);
          this.model = null;
          this.onDetachModel(oldModel);
          this.deinitModel(oldModel);
          this.didDetachModel(oldModel);
          oldModel.remove();
        }
        this.willAttachModel(newModel, target);
        this.model = newModel;
        this.onAttachModel(newModel, target);
        this.initModel(newModel);
        this.didAttachModel(newModel, target);
      }
      return newModel;
    };
    ModelRef.prototype.removeModel = function() {
      const model = this.model;
      if (model !== null) {
        model.remove();
      }
      return model;
    };
    ModelRef.prototype.deleteModel = function() {
      const model = this.detachModel();
      if (model !== null) {
        model.remove();
      }
      return model;
    };
    ModelRef.prototype.bindModel = function(model, target) {
      if (this.binds && this.model === null) {
        const newModel = this.detectModel(model);
        if (newModel !== null) {
          this.willAttachModel(newModel, target);
          this.model = newModel;
          this.onAttachModel(newModel, target);
          this.initModel(newModel);
          this.didAttachModel(newModel, target);
        }
      }
    };
    ModelRef.prototype.unbindModel = function(model) {
      if (this.binds) {
        const oldModel = this.detectModel(model);
        if (oldModel !== null && this.model === oldModel) {
          this.willDetachModel(oldModel);
          this.model = null;
          this.onDetachModel(oldModel);
          this.deinitModel(oldModel);
          this.didDetachModel(oldModel);
        }
      }
    };
    ModelRef.prototype.detectModel = function(model) {
      const key = this.key;
      if (key !== void 0 && key === model.key) {
        return model;
      }
      return null;
    };
    ModelRef.construct = function(fastenerClass, fastener, owner) {
      if (fastener === null) {
        fastener = function(model, target, key) {
          if (model === void 0) {
            return fastener.model;
          } else {
            fastener.setModel(model, target, key);
            return fastener.owner;
          }
        };
        delete fastener.name;
        Object.setPrototypeOf(fastener, fastenerClass.prototype);
      }
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.model = null;
      return fastener;
    };
    ModelRef.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      if (descriptor.key === true) {
        Object.defineProperty(descriptor, "key", {
          value: className,
          configurable: true
        });
      } else if (descriptor.key === false) {
        Object.defineProperty(descriptor, "key", {
          value: void 0,
          configurable: true
        });
      }
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        return fastener;
      };
      return fastenerClass;
    };
    return ModelRef;
  }(ModelRelation);
  const ModelSet = function(_super) {
    const ModelSet = _super.extend("ModelSet");
    Object.defineProperty(ModelSet.prototype, "fastenerType", {
      get: function() {
        return ModelSet;
      },
      configurable: true
    });
    ModelSet.prototype.hasModel = function(model) {
      return this.models[model.uid] !== void 0;
    };
    ModelSet.prototype.addModel = function(newModel, target, key) {
      if (newModel !== void 0 && newModel !== null) {
        newModel = this.fromAny(newModel);
      } else {
        newModel = this.createModel();
      }
      if (target === void 0) {
        target = null;
      }
      let parent;
      if (this.binds && (parent = this.parentModel, parent !== null)) {
        if (key === void 0) {
          key = this.key(newModel);
        }
        this.insertChild(parent, newModel, target, key);
      }
      const models = this.models;
      if (models[newModel.uid] === void 0) {
        this.willAttachModel(newModel, target);
        models[newModel.uid] = newModel;
        this.modelCount += 1;
        this.onAttachModel(newModel, target);
        this.initModel(newModel);
        this.didAttachModel(newModel, target);
      }
      return newModel;
    };
    ModelSet.prototype.attachModel = function(newModel, target) {
      if (newModel !== void 0 && newModel !== null) {
        newModel = this.fromAny(newModel);
      } else {
        newModel = this.createModel();
      }
      const models = this.models;
      if (models[newModel.uid] === void 0) {
        if (target === void 0) {
          target = null;
        }
        this.willAttachModel(newModel, target);
        models[newModel.uid] = newModel;
        this.modelCount += 1;
        this.onAttachModel(newModel, target);
        this.initModel(newModel);
        this.didAttachModel(newModel, target);
      }
      return newModel;
    };
    ModelSet.prototype.detachModel = function(oldModel) {
      const models = this.models;
      if (models[oldModel.uid] !== void 0) {
        this.willDetachModel(oldModel);
        this.modelCount -= 1;
        delete models[oldModel.uid];
        this.onDetachModel(oldModel);
        this.deinitModel(oldModel);
        this.didDetachModel(oldModel);
        return oldModel;
      }
      return null;
    };
    ModelSet.prototype.insertModel = function(parent, newModel, target, key) {
      if (newModel !== void 0 && newModel !== null) {
        newModel = this.fromAny(newModel);
      } else {
        newModel = this.createModel();
      }
      if (parent === void 0 || parent === null) {
        parent = this.parentModel;
      }
      if (target === void 0) {
        target = null;
      }
      if (key === void 0) {
        key = this.key(newModel);
      }
      if (parent !== null && (newModel.parent !== parent || newModel.key !== key)) {
        this.insertChild(parent, newModel, target, key);
      }
      const models = this.models;
      if (models[newModel.uid] === void 0) {
        this.willAttachModel(newModel, target);
        models[newModel.uid] = newModel;
        this.modelCount += 1;
        this.onAttachModel(newModel, target);
        this.initModel(newModel);
        this.didAttachModel(newModel, target);
      }
      return newModel;
    };
    ModelSet.prototype.removeModel = function(model) {
      if (this.hasModel(model)) {
        model.remove();
        return model;
      }
      return null;
    };
    ModelSet.prototype.deleteModel = function(model) {
      const oldModel = this.detachModel(model);
      if (oldModel !== null) {
        oldModel.remove();
      }
      return oldModel;
    };
    ModelSet.prototype.bindModel = function(model, target) {
      if (this.binds) {
        const newModel = this.detectModel(model);
        const models = this.models;
        if (newModel !== null && models[newModel.uid] === void 0) {
          this.willAttachModel(newModel, target);
          models[newModel.uid] = newModel;
          this.modelCount += 1;
          this.onAttachModel(newModel, target);
          this.initModel(newModel);
          this.didAttachModel(newModel, target);
        }
      }
    };
    ModelSet.prototype.unbindModel = function(model) {
      if (this.binds) {
        const oldModel = this.detectModel(model);
        const models = this.models;
        if (oldModel !== null && models[oldModel.uid] !== void 0) {
          this.willDetachModel(oldModel);
          this.modelCount -= 1;
          delete models[oldModel.uid];
          this.onDetachModel(oldModel);
          this.deinitModel(oldModel);
          this.didDetachModel(oldModel);
        }
      }
    };
    ModelSet.prototype.detectModel = function(model) {
      if (typeof this.type === "function" && model instanceof this.type) {
        return model;
      }
      return null;
    };
    ModelSet.prototype.key = function(model) {
      return void 0;
    };
    Object.defineProperty(ModelSet.prototype, "sorted", {
      get() {
        return (this.flags & ModelSet.SortedFlag) !== 0;
      },
      configurable: true
    });
    ModelSet.prototype.initInherits = function(sorted) {
      if (sorted) {
        this.flags = this.flags | ModelSet.SortedFlag;
      } else {
        this.flags = this.flags & ~ModelSet.SortedFlag;
      }
    };
    ModelSet.prototype.sort = function(sorted) {
      if (sorted === void 0) {
        sorted = true;
      }
      const flags = this.flags;
      if (sorted && (flags & ModelSet.SortedFlag) === 0) {
        const parent = this.parentModel;
        this.willSort(parent);
        this.setFlags(flags | ModelSet.SortedFlag);
        this.onSort(parent);
        this.didSort(parent);
      } else if (!sorted && (flags & ModelSet.SortedFlag) !== 0) {
        this.setFlags(flags & ~ModelSet.SortedFlag);
      }
      return this;
    };
    ModelSet.prototype.willSort = function(parent) {};
    ModelSet.prototype.onSort = function(parent) {
      if (parent !== null) {
        this.sortChildren(parent);
      }
    };
    ModelSet.prototype.didSort = function(parent) {};
    ModelSet.prototype.sortChildren = function(parent) {
      parent.sortChildren(this.compareChildren.bind(this));
    };
    ModelSet.prototype.compareChildren = function(a, b) {
      const models = this.models;
      const x = models[a.uid];
      const y = models[b.uid];
      if (x !== void 0 && y !== void 0) {
        return this.compare(x, y);
      } else {
        return x !== void 0 ? 1 : y !== void 0 ? -1 : 0;
      }
    };
    ModelSet.prototype.compare = function(a, b) {
      return a.uid < b.uid ? -1 : a.uid > b.uid ? 1 : 0;
    };
    ModelSet.construct = function(fastenerClass, fastener, owner) {
      if (fastener === null) {
        fastener = function(newModel) {
          fastener.addModel(newModel);
          return fastener.owner;
        };
        delete fastener.name;
        Object.setPrototypeOf(fastener, fastenerClass.prototype);
      }
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.models = {};
      fastener.modelCount = 0;
      return fastener;
    };
    ModelSet.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const sorted = descriptor.sorted;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.sorted;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        if (sorted !== void 0) {
          fastener.initSorted(sorted);
        }
        return fastener;
      };
      return fastenerClass;
    };
    ModelSet.SortedFlag = 1 << _super.FlagShift + 0;
    ModelSet.FlagShift = _super.FlagShift + 1;
    ModelSet.FlagMask = (1 << ModelSet.FlagShift) - 1;
    return ModelSet;
  }(ModelRelation);
  class Trait {
    constructor() {
      this.uid = this.constructor.uid();
      this.key = void 0;
      this.flags = 0;
      this.model = null;
      this.nextTrait = null;
      this.previousTrait = null;
      this.fasteners = null;
      this.decoherent = null;
      this.observers = util.Arrays.empty;
      this.consumers = util.Arrays.empty;
      component.FastenerContext.init(this);
    }
    setKey(key) {
      this.key = key;
    }
    setFlags(flags) {
      this.flags = flags;
    }
    attachModel(model, nextTrait) {
      this.willAttachModel(model);
      this.model = model;
      let previousTrait;
      if (nextTrait !== null) {
        previousTrait = nextTrait.previousTrait;
        this.setNextTrait(nextTrait);
        nextTrait.setPreviousTrait(this);
      } else {
        previousTrait = model.lastTrait;
        model.setLastTrait(this);
      }
      if (previousTrait !== null) {
        previousTrait.setNextTrait(this);
        this.setPreviousTrait(previousTrait);
      } else {
        model.setFirstTrait(this);
      }
      if (model.mounted) {
        this.mountTrait();
      }
      this.onAttachModel(model);
      this.didAttachModel(model);
    }
    willAttachModel(model) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillAttachModel !== void 0) {
          observer.traitWillAttachModel(model, this);
        }
      }
    }
    onAttachModel(model) {
      this.bindModelFasteners(model);
    }
    didAttachModel(model) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidAttachModel !== void 0) {
          observer.traitDidAttachModel(model, this);
        }
      }
    }
    detachModel(model) {
      this.willDetachModel(model);
      if (this.mounted) {
        this.unmountTrait();
      }
      this.onDetachModel(model);
      const nextTrait = this.nextTrait;
      const previousTrait = this.previousTrait;
      if (nextTrait !== null) {
        this.setNextTrait(null);
        nextTrait.setPreviousTrait(previousTrait);
      } else {
        model.setLastTrait(previousTrait);
      }
      if (previousTrait !== null) {
        previousTrait.setNextTrait(nextTrait);
        this.setPreviousTrait(null);
      } else {
        model.setFirstTrait(nextTrait);
      }
      this.model = null;
      this.didDetachModel(model);
    }
    willDetachModel(model) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillDetachModel !== void 0) {
          observer.traitWillDetachModel(model, this);
        }
      }
    }
    onDetachModel(model) {
      this.unbindModelFasteners(model);
    }
    didDetachModel(model) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidDetachModel !== void 0) {
          observer.traitDidDetachModel(model, this);
        }
      }
    }
    get modelFlags() {
      const model = this.model;
      return model !== null ? model.flags : 0;
    }
    setModelFlags(modelFlags) {
      const model = this.model;
      if (model !== null) {
        model.setFlags(modelFlags);
      } else {
        throw new Error("no model");
      }
    }
    remove() {
      const model = this.model;
      if (model !== null) {
        model.removeTrait(this);
      }
    }
    get parent() {
      const model = this.model;
      return model !== null ? model.parent : null;
    }
    willAttachParent(parent) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillAttachParent !== void 0) {
          observer.traitWillAttachParent(parent, this);
        }
      }
    }
    onAttachParent(parent) {}
    didAttachParent(parent) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidAttachParent !== void 0) {
          observer.traitDidAttachParent(parent, this);
        }
      }
    }
    willDetachParent(parent) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillDetachParent !== void 0) {
          observer.traitWillDetachParent(parent, this);
        }
      }
    }
    onDetachParent(parent) {}
    didDetachParent(parent) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidDetachParent !== void 0) {
          observer.traitDidDetachParent(parent, this);
        }
      }
    }
    get nextSibling() {
      const model = this.model;
      return model !== null ? model.nextSibling : null;
    }
    get previousSibling() {
      const model = this.model;
      return model !== null ? model.previousSibling : null;
    }
    get firstChild() {
      const model = this.model;
      return model !== null ? model.firstChild : null;
    }
    get lastChild() {
      const model = this.model;
      return model !== null ? model.lastChild : null;
    }
    forEachChild(callback, thisArg) {
      const model = this.model;
      return model !== null ? model.forEachChild(callback, thisArg) : void 0;
    }
    getChild(key, childBound) {
      const model = this.model;
      return model !== null ? model.getChild(key, childBound) : null;
    }
    setChild(key, newChild) {
      const model = this.model;
      if (model !== null) {
        return model.setChild(key, newChild);
      } else {
        throw new Error("no model");
      }
    }
    appendChild(child, key) {
      const model = this.model;
      if (model !== null) {
        return model.appendChild(child, key);
      } else {
        throw new Error("no model");
      }
    }
    prependChild(child, key) {
      const model = this.model;
      if (model !== null) {
        return model.prependChild(child, key);
      } else {
        throw new Error("no model");
      }
    }
    insertChild(child, target, key) {
      const model = this.model;
      if (model !== null) {
        return model.insertChild(child, target, key);
      } else {
        throw new Error("no model");
      }
    }
    replaceChild(newChild, oldChild) {
      const model = this.model;
      if (model !== null) {
        return model.replaceChild(newChild, oldChild);
      } else {
        throw new Error("no model");
      }
    }
    get insertChildFlags() {
      return this.constructor.InsertChildFlags;
    }
    willInsertChild(child, target) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillInsertChild !== void 0) {
          observer.traitWillInsertChild(child, target, this);
        }
      }
    }
    onInsertChild(child, target) {
      this.requireUpdate(this.insertChildFlags);
      this.bindChildFasteners(child, target);
    }
    didInsertChild(child, target) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidInsertChild !== void 0) {
          observer.traitDidInsertChild(child, target, this);
        }
      }
    }
    removeChild(key) {
      const model = this.model;
      if (model !== null) {
        return model.removeChild(key);
      } else {
        return null;
      }
    }
    get removeChildFlags() {
      return this.constructor.RemoveChildFlags;
    }
    willRemoveChild(child) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillRemoveChild !== void 0) {
          observer.traitWillRemoveChild(child, this);
        }
      }
      this.requireUpdate(this.removeChildFlags);
    }
    onRemoveChild(child) {
      this.unbindChildFasteners(child);
    }
    didRemoveChild(child) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidRemoveChild !== void 0) {
          observer.traitDidRemoveChild(child, this);
        }
      }
    }
    removeChildren() {
      const model = this.model;
      if (model !== null) {
        return model.removeChildren();
      }
    }
    sortChildren(comparator) {
      const model = this.model;
      if (model !== null) {
        return model.sortChildren(comparator);
      }
    }
    getSuper(superBound) {
      const model = this.model;
      return model !== null ? model.getSuper(superBound) : null;
    }
    getBase(baseBound) {
      const model = this.model;
      return model !== null ? model.getBase(baseBound) : null;
    }
    setNextTrait(nextTrait) {
      this.nextTrait = nextTrait;
    }
    setPreviousTrait(previousTrait) {
      this.previousTrait = previousTrait;
    }
    get firstTrait() {
      const model = this.model;
      return model !== null ? model.firstTrait : null;
    }
    get lastTrait() {
      const model = this.model;
      return model !== null ? model.lastTrait : null;
    }
    forEachTrait(callback, thisArg) {
      const model = this.model;
      return model !== null ? model.forEachTrait(callback, thisArg) : void 0;
    }
    getTrait(key, traitBound) {
      const model = this.model;
      return model !== null ? model.getTrait(key, traitBound) : null;
    }
    setTrait(key, newTrait) {
      const model = this.model;
      if (model !== null) {
        return model.setTrait(key, newTrait);
      } else {
        throw new Error("no model");
      }
    }
    appendTrait(trait, key) {
      const model = this.model;
      if (model !== null) {
        return model.appendTrait(trait, key);
      } else {
        throw new Error("no model");
      }
    }
    prependTrait(trait, key) {
      const model = this.model;
      if (model !== null) {
        return model.prependTrait(trait, key);
      } else {
        throw new Error("no model");
      }
    }
    insertTrait(trait, target, key) {
      const model = this.model;
      if (model !== null) {
        return model.insertTrait(trait, target, key);
      } else {
        throw new Error("no model");
      }
    }
    replaceTraitt(newTrait, oldTrait) {
      const model = this.model;
      if (model !== null) {
        return model.replaceTrait(newTrait, oldTrait);
      } else {
        throw new Error("no model");
      }
    }
    get insertTraitFlags() {
      return this.constructor.InsertTraitFlags;
    }
    willInsertTrait(trait, target) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillInsertTrait !== void 0) {
          observer.traitWillInsertTrait(trait, target, this);
        }
      }
    }
    onInsertTrait(trait, target) {
      this.requireUpdate(this.insertTraitFlags);
      this.bindTraitFasteners(trait, target);
    }
    didInsertTrait(trait, target) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidInsertTrait !== void 0) {
          observer.traitDidInsertTrait(trait, target, this);
        }
      }
    }
    removeTrait(key) {
      const model = this.model;
      if (model !== null) {
        return model.removeTrait(key);
      } else {
        return null;
      }
    }
    get removeTraitFlags() {
      return this.constructor.RemoveTraitFlags;
    }
    willRemoveTrait(trait) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillRemoveTrait !== void 0) {
          observer.traitWillRemoveTrait(trait, this);
        }
      }
    }
    onRemoveTrait(trait) {
      this.requireUpdate(this.removeTraitFlags);
      this.unbindTraitFasteners(trait);
    }
    didRemoveTrait(trait) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidRemoveTrait !== void 0) {
          observer.traitDidRemoveTrait(trait, this);
        }
      }
    }
    sortTraits(comparator) {
      const model = this.model;
      if (model !== null) {
        model.sortTraits(comparator);
      }
    }
    getSuperTrait(superBound) {
      const model = this.model;
      return model !== null ? model.getSuperTrait(superBound) : null;
    }
    getBaseTrait(baseBound) {
      const model = this.model;
      return model !== null ? model.getBaseTrait(baseBound) : null;
    }
    get mounted() {
      return (this.flags & Trait.MountedFlag) !== 0;
    }
    get mountFlags() {
      return this.constructor.MountFlags;
    }
    mountTrait() {
      if ((this.flags & Trait.MountedFlag) === 0) {
        this.setFlags(this.flags | Trait.MountedFlag);
        this.willMount();
        this.onMount();
        this.didMount();
      } else {
        throw new Error("already mounted");
      }
    }
    willMount() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillMount !== void 0) {
          observer.traitWillMount(this);
        }
      }
    }
    onMount() {
      this.requireUpdate(this.mountFlags);
      if (this.decoherent !== null && this.decoherent.length !== 0) {
        this.requireUpdate(Model.NeedsMutate);
      }
      this.mountFasteners();
      if (this.consumers.length !== 0) {
        this.startConsuming();
      }
    }
    didMount() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidMount !== void 0) {
          observer.traitDidMount(this);
        }
      }
    }
    unmountTrait() {
      if ((this.flags & Trait.MountedFlag) !== 0) {
        this.setFlags(this.flags & ~Trait.MountedFlag);
        this.willUnmount();
        this.onUnmount();
        this.didUnmount();
      } else {
        throw new Error("already unmounted");
      }
    }
    willUnmount() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillUnmount !== void 0) {
          observer.traitWillUnmount(this);
        }
      }
    }
    onUnmount() {
      this.stopConsuming();
      this.unmountFasteners();
    }
    didUnmount() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidUnmount !== void 0) {
          observer.traitDidUnmount(this);
        }
      }
    }
    requireUpdate(updateFlags, immediate = false) {
      const model = this.model;
      if (model !== null) {
        model.requireUpdate(updateFlags, immediate);
      }
    }
    needsUpdate(updateFlags, immediate) {
      return updateFlags;
    }
    requestUpdate(target, updateFlags, immediate) {
      const model = this.model;
      if (model !== null) {
        model.requestUpdate(target, updateFlags, immediate);
      } else {
        throw new TypeError("no model");
      }
    }
    get updating() {
      const model = this.model;
      return model !== null && model.updating;
    }
    get analyzing() {
      const model = this.model;
      return model !== null && model.analyzing;
    }
    needsAnalyze(analyzeFlags, modelContext) {
      return analyzeFlags;
    }
    willAnalyze(analyzeFlags, modelContext) {}
    onAnalyze(analyzeFlags, modelContext) {}
    didAnalyze(analyzeFlags, modelContext) {}
    willMutate(modelContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillMutate !== void 0) {
          observer.traitWillMutate(modelContext, this);
        }
      }
    }
    onMutate(modelContext) {
      this.recohereFasteners(modelContext.updateTime);
    }
    didMutate(modelContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidMutate !== void 0) {
          observer.traitDidMutate(modelContext, this);
        }
      }
    }
    willAggregate(modelContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillAggregate !== void 0) {
          observer.traitWillAggregate(modelContext, this);
        }
      }
    }
    onAggregate(modelContext) {}
    didAggregate(modelContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidAggregate !== void 0) {
          observer.traitDidAggregate(modelContext, this);
        }
      }
    }
    willCorrelate(modelContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillCorrelate !== void 0) {
          observer.traitWillCorrelate(modelContext, this);
        }
      }
    }
    onCorrelate(modelContext) {}
    didCorrelate(modelContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidCorrelate !== void 0) {
          observer.traitDidCorrelate(modelContext, this);
        }
      }
    }
    analyzeChildren(analyzeFlags, modelContext, analyzeChild, analyzeChildren) {
      analyzeChildren.call(this.model, analyzeFlags, modelContext, analyzeChild);
    }
    get refreshing() {
      const model = this.model;
      return model !== null && model.refreshing;
    }
    needsRefresh(refreshFlags, modelContext) {
      return refreshFlags;
    }
    willRefresh(refreshFlags, modelContext) {}
    onRefresh(refreshFlags, modelContext) {}
    didRefresh(refreshFlags, modelContext) {}
    willValidate(modelContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillValidate !== void 0) {
          observer.traitWillValidate(modelContext, this);
        }
      }
    }
    onValidate(modelContext) {}
    didValidate(modelContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidValidate !== void 0) {
          observer.traitDidValidate(modelContext, this);
        }
      }
    }
    willReconcile(modelContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillReconcile !== void 0) {
          observer.traitWillReconcile(modelContext, this);
        }
      }
    }
    onReconcile(modelContext) {
      this.recohereDownlinks(modelContext.updateTime);
    }
    didReconcile(modelContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidReconcile !== void 0) {
          observer.traitDidReconcile(modelContext, this);
        }
      }
    }
    refreshChildren(refreshFlags, modelContext, refreshChild, refreshChildren) {
      refreshChildren.call(this.model, refreshFlags, modelContext, refreshChild);
    }
    hasFastener(fastenerName, fastenerBound) {
      const fasteners = this.fasteners;
      if (fasteners !== null) {
        const fastener = fasteners[fastenerName];
        if (fastener !== void 0 && (fastenerBound === void 0 || fastenerBound === null || fastener instanceof fastenerBound)) {
          return true;
        }
      }
      return false;
    }
    getFastener(fastenerName, fastenerBound) {
      const fasteners = this.fasteners;
      if (fasteners !== null) {
        const fastener = fasteners[fastenerName];
        if (fastener !== void 0 && (fastenerBound === void 0 || fastenerBound === null || fastener instanceof fastenerBound)) {
          return fastener;
        }
      }
      return null;
    }
    setFastener(fastenerName, newFastener) {
      var _a;
      const fasteners = this.fasteners;
      const oldFastener = fasteners !== null ? (_a = fasteners[fastenerName]) !== null && _a !== void 0 ? _a : null : null;
      if (oldFastener !== newFastener) {
        if (oldFastener !== null) {
          this.detachFastener(fastenerName, oldFastener);
        }
        if (newFastener !== null) {
          this.attachFastener(fastenerName, newFastener);
        }
      }
    }
    attachFastener(fastenerName, fastener) {
      let fasteners = this.fasteners;
      if (fasteners === null) {
        fasteners = {};
        this.fasteners = fasteners;
      }
      this.willAttachFastener(fastenerName, fastener);
      fasteners[fastenerName] = fastener;
      if (this.mounted) {
        fastener.mount();
      }
      this.onAttachFastener(fastenerName, fastener);
      this.didAttachFastener(fastenerName, fastener);
    }
    willAttachFastener(fastenerName, fastener) {}
    onAttachFastener(fastenerName, fastener) {
      this.bindFastener(fastener);
    }
    didAttachFastener(fastenerName, fastener) {}
    detachFastener(fastenerName, fastener) {
      const fasteners = this.fasteners;
      this.willDetachFastener(fastenerName, fastener);
      this.onDetachFastener(fastenerName, fastener);
      if (this.mounted) {
        fastener.unmount();
      }
      delete fasteners[fastenerName];
      this.didDetachFastener(fastenerName, fastener);
    }
    willDetachFastener(fastenerName, fastener) {}
    onDetachFastener(fastenerName, fastener) {}
    didDetachFastener(fastenerName, fastener) {}
    getLazyFastener(fastenerName, fastenerBound) {
      return component.FastenerContext.getLazyFastener(this, fastenerName, fastenerBound);
    }
    getSuperFastener(fastenerName, fastenerBound) {
      const model = this.model;
      if (model === null) {
        return null;
      } else {
        const modelFastener = model.getLazyFastener(fastenerName, fastenerBound);
        if (modelFastener !== null) {
          return modelFastener;
        } else {
          return model.getSuperFastener(fastenerName, fastenerBound);
        }
      }
    }
    mountFasteners() {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        fastener.mount();
      }
    }
    unmountFasteners() {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        fastener.unmount();
      }
    }
    bindFastener(fastener) {
      if ((fastener instanceof ModelRelation || fastener instanceof TraitRelation) && fastener.binds) {
        this.forEachChild((function(child) {
          fastener.bindModel(child, null);
        }), this);
      }
      if (fastener instanceof TraitRelation && fastener.binds) {
        this.forEachTrait((function(trait) {
          fastener.bindTrait(trait, null);
        }), this);
      }
      if (fastener instanceof client.DownlinkFastener && fastener.consumed === true && this.consuming) {
        fastener.consume(this);
      }
    }
    bindModelFasteners(model) {
      const fasteners = this.fasteners;
      model.forEachChild((function(child) {
        for (const fastenerName in fasteners) {
          const fastener = fasteners[fastenerName];
          this.bindChildFastener(fastener, child, null);
        }
      }), this);
      model.forEachTrait((function(trait) {
        for (const fastenerName in fasteners) {
          const fastener = fasteners[fastenerName];
          this.bindTraitFastener(fastener, trait, null);
        }
      }), this);
    }
    unbindModelFasteners(model) {
      const fasteners = this.fasteners;
      model.forEachTrait((function(trait) {
        for (const fastenerName in fasteners) {
          const fastener = fasteners[fastenerName];
          this.unbindTraitFastener(fastener, trait);
        }
      }), this);
      model.forEachChild((function(child) {
        for (const fastenerName in fasteners) {
          const fastener = fasteners[fastenerName];
          this.unbindChildFastener(fastener, child);
        }
      }), this);
    }
    bindChildFasteners(child, target) {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        this.bindChildFastener(fastener, child, target);
      }
    }
    bindChildFastener(fastener, child, target) {
      if (fastener instanceof ModelRelation || fastener instanceof TraitRelation) {
        fastener.bindModel(child, target);
      }
    }
    unbindChildFasteners(child) {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        this.unbindChildFastener(fastener, child);
      }
    }
    unbindChildFastener(fastener, child) {
      if (fastener instanceof ModelRelation || fastener instanceof TraitRelation) {
        fastener.unbindModel(child);
      }
    }
    bindTraitFasteners(trait, target) {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        this.bindTraitFastener(fastener, trait, target);
      }
    }
    bindTraitFastener(fastener, trait, target) {
      if (fastener instanceof TraitRelation) {
        fastener.bindTrait(trait, target);
      }
    }
    unbindTraitFasteners(trait) {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        this.unbindTraitFastener(fastener, trait);
      }
    }
    unbindTraitFastener(fastener, trait) {
      if (fastener instanceof TraitRelation) {
        fastener.unbindTrait(trait);
      }
    }
    decohereFastener(fastener) {
      let decoherent = this.decoherent;
      if (decoherent === null) {
        decoherent = [];
        this.decoherent = decoherent;
      }
      decoherent.push(fastener);
      if (fastener instanceof client.DownlinkFastener) {
        this.requireUpdate(Model.NeedsReconcile);
      } else {
        this.requireUpdate(Model.NeedsMutate);
      }
    }
    recohereFasteners(t) {
      const decoherent = this.decoherent;
      if (decoherent !== null) {
        const decoherentCount = decoherent.length;
        if (decoherentCount !== 0) {
          if (t === void 0) {
            t = performance.now();
          }
          this.decoherent = null;
          for (let i = 0; i < decoherentCount; i += 1) {
            const fastener = decoherent[i];
            if (!(fastener instanceof client.DownlinkFastener)) {
              fastener.recohere(t);
            } else {
              this.decohereFastener(fastener);
            }
          }
        }
      }
    }
    recohereDownlinks(t) {
      const decoherent = this.decoherent;
      if (decoherent !== null) {
        const decoherentCount = decoherent.length;
        if (decoherentCount !== 0) {
          this.decoherent = null;
          for (let i = 0; i < decoherentCount; i += 1) {
            const fastener = decoherent[i];
            if (fastener instanceof client.DownlinkFastener) {
              fastener.recohere(t);
            } else {
              this.decohereFastener(fastener);
            }
          }
        }
      }
    }
    observe(observer) {
      const oldObservers = this.observers;
      const newObservers = util.Arrays.inserted(observer, oldObservers);
      if (oldObservers !== newObservers) {
        this.willObserve(observer);
        this.observers = newObservers;
        this.onObserve(observer);
        this.didObserve(observer);
      }
    }
    willObserve(observer) {}
    onObserve(observer) {}
    didObserve(observer) {}
    unobserve(observer) {
      const oldObservers = this.observers;
      const newObservers = util.Arrays.removed(observer, oldObservers);
      if (oldObservers !== newObservers) {
        this.willUnobserve(observer);
        this.observers = newObservers;
        this.onUnobserve(observer);
        this.didUnobserve(observer);
      }
    }
    willUnobserve(observer) {}
    onUnobserve(observer) {}
    didUnobserve(observer) {}
    forEachObserver(callback) {
      let result;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        result = callback.call(this, observer);
        if (result !== void 0) {
          return result;
        }
      }
      return result;
    }
    callObservers(key, ...args) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        const method = observer[key];
        if (typeof method === "function") {
          method.call(observer, ...args);
        }
      }
    }
    consume(consumer) {
      const oldConsumers = this.consumers;
      const newConsumers = util.Arrays.inserted(consumer, oldConsumers);
      if (oldConsumers !== newConsumers) {
        this.willConsume(consumer);
        this.consumers = newConsumers;
        this.onConsume(consumer);
        this.didConsume(consumer);
        if (oldConsumers.length === 0 && this.mounted) {
          this.startConsuming();
        }
      }
    }
    willConsume(consumer) {}
    onConsume(consumer) {}
    didConsume(consumer) {}
    unconsume(consumer) {
      const oldConsumers = this.consumers;
      const newConsumers = util.Arrays.removed(consumer, oldConsumers);
      if (oldConsumers !== newConsumers) {
        this.willUnconsume(consumer);
        this.consumers = newConsumers;
        this.onUnconsume(consumer);
        this.didUnconsume(consumer);
        if (newConsumers.length === 0) {
          this.stopConsuming();
        }
      }
    }
    willUnconsume(consumer) {}
    onUnconsume(consumer) {}
    didUnconsume(consumer) {}
    get consuming() {
      return (this.flags & Trait.ConsumingFlag) !== 0;
    }
    get startConsumingFlags() {
      return this.constructor.StartConsumingFlags;
    }
    startConsuming() {
      if ((this.flags & Trait.ConsumingFlag) === 0) {
        this.willStartConsuming();
        this.setFlags(this.flags | Trait.ConsumingFlag);
        this.onStartConsuming();
        this.didStartConsuming();
      }
    }
    willStartConsuming() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillStartConsuming !== void 0) {
          observer.traitWillStartConsuming(this);
        }
      }
    }
    onStartConsuming() {
      this.requireUpdate(this.startConsumingFlags);
      this.startConsumingFasteners();
    }
    didStartConsuming() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidStartConsuming !== void 0) {
          observer.traitDidStartConsuming(this);
        }
      }
    }
    get stopConsumingFlags() {
      return this.constructor.StopConsumingFlags;
    }
    stopConsuming() {
      if ((this.flags & Trait.ConsumingFlag) !== 0) {
        this.willStopConsuming();
        this.setFlags(this.flags & ~Trait.ConsumingFlag);
        this.onStopConsuming();
        this.didStopConsuming();
      }
    }
    willStopConsuming() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillStopConsuming !== void 0) {
          observer.traitWillStopConsuming(this);
        }
      }
    }
    onStopConsuming() {
      this.requireUpdate(this.stopConsumingFlags);
      this.stopConsumingFasteners();
    }
    didStopConsuming() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidStopConsuming !== void 0) {
          observer.traitDidStopConsuming(this);
        }
      }
    }
    startConsumingFasteners() {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        if (fastener instanceof client.DownlinkFastener && fastener.consumed === true) {
          fastener.consume(this);
        }
      }
    }
    stopConsumingFasteners() {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        if (fastener instanceof client.DownlinkFastener && fastener.consumed === true) {
          fastener.unconsume(this);
        }
      }
    }
    get modelContext() {
      const model = this.model;
      return model !== null ? model.modelContext : null;
    }
    equals(that) {
      return this === that;
    }
    hashCode() {
      return this.uid;
    }
    init(init) {}
    static create() {
      return new this;
    }
    static fromInit(init) {
      let type;
      if ((typeof init === "object" && init !== null || typeof init === "function") && util.Creatable.is(init.type)) {
        type = init.type;
      } else {
        type = this;
      }
      const view = type.create();
      view.init(init);
      return view;
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return value;
      } else if (value instanceof Trait) {
        if (value instanceof this) {
          return value;
        } else {
          throw new TypeError(value + " not an instance of " + this);
        }
      } else if (util.Creatable.is(value)) {
        return value.create();
      } else {
        return this.fromInit(value);
      }
    }
  }
  Trait.uid = function() {
    let nextId = 1;
    return function uid() {
      const id = ~~nextId;
      nextId += 1;
      return id;
    };
  }();
  Trait.MountedFlag = 1 << 0;
  Trait.ConsumingFlag = 1 << 1;
  Trait.FlagShift = 2;
  Trait.FlagMask = (1 << Trait.FlagShift) - 1;
  Trait.MountFlags = 0;
  Trait.InsertChildFlags = 0;
  Trait.RemoveChildFlags = 0;
  Trait.InsertTraitFlags = 0;
  Trait.RemoveTraitFlags = 0;
  Trait.StartConsumingFlags = 0;
  Trait.StopConsumingFlags = 0;
  __decorate([ component.Provider({
    extends: client.WarpProvider,
    type: client.WarpService,
    observes: false,
    service: client.WarpService.global()
  }) ], Trait.prototype, "warpProvider", void 0);
  __decorate([ component.Property({
    type: Object,
    inherits: true,
    value: null,
    updateFlags: Model.NeedsReconcile
  }) ], Trait.prototype, "warpRef", void 0);
  const TraitRelation = function(_super) {
    const TraitRelation = _super.extend("TraitRelation");
    Object.defineProperty(TraitRelation.prototype, "fastenerType", {
      get: function() {
        return TraitRelation;
      },
      configurable: true
    });
    TraitRelation.prototype.initTrait = function(trait) {};
    TraitRelation.prototype.willAttachTrait = function(trait, target) {};
    TraitRelation.prototype.onAttachTrait = function(trait, target) {
      if (this.observes === true) {
        trait.observe(this);
      }
    };
    TraitRelation.prototype.didAttachTrait = function(trait, target) {};
    TraitRelation.prototype.deinitTrait = function(trait) {};
    TraitRelation.prototype.willDetachTrait = function(trait) {};
    TraitRelation.prototype.onDetachTrait = function(trait) {
      if (this.observes === true) {
        trait.unobserve(this);
      }
    };
    TraitRelation.prototype.didDetachTrait = function(trait) {};
    Object.defineProperty(TraitRelation.prototype, "parentModel", {
      get() {
        const owner = this.owner;
        if (owner instanceof Model) {
          return owner;
        } else if (owner instanceof Trait) {
          return owner.model;
        } else {
          return null;
        }
      },
      configurable: true
    });
    TraitRelation.prototype.insertChild = function(model, trait, target, key) {
      model.insertTrait(trait, target, key);
    };
    TraitRelation.prototype.bindModel = function(model, targetModel) {};
    TraitRelation.prototype.unbindModel = function(model) {};
    TraitRelation.prototype.detectModel = function(model) {
      return null;
    };
    TraitRelation.prototype.bindTrait = function(trait, target) {};
    TraitRelation.prototype.unbindTrait = function(trait) {};
    TraitRelation.prototype.detectTrait = function(trait) {
      return null;
    };
    TraitRelation.prototype.createTrait = function() {
      const type = this.type;
      if (type !== void 0) {
        return type.create();
      }
      {
        let message = "Unable to create ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "trait";
        throw new Error(message);
      }
    };
    TraitRelation.prototype.fromAny = function(value) {
      const type = this.type;
      if (type !== void 0) {
        return type.fromAny(value);
      } else {
        return Trait.fromAny(value);
      }
    };
    Object.defineProperty(TraitRelation.prototype, "lazy", {
      get: function() {
        return false;
      },
      configurable: true
    });
    Object.defineProperty(TraitRelation.prototype, "static", {
      get: function() {
        return true;
      },
      configurable: true
    });
    TraitRelation.construct = function(fastenerClass, fastener, owner) {
      fastener = _super.construct(fastenerClass, fastener, owner);
      return fastener;
    };
    TraitRelation.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        return fastener;
      };
      return fastenerClass;
    };
    return TraitRelation;
  }(component.Fastener);
  const TraitRef = function(_super) {
    const TraitRef = _super.extend("TraitRef");
    Object.defineProperty(TraitRef.prototype, "fastenerType", {
      get: function() {
        return TraitRef;
      },
      configurable: true
    });
    TraitRef.prototype.onInherit = function(superFastener) {
      this.setTrait(superFastener.trait);
    };
    TraitRef.prototype.getTrait = function() {
      const trait = this.trait;
      if (trait === null) {
        let message = trait + " ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "trait";
        throw new TypeError(message);
      }
      return trait;
    };
    TraitRef.prototype.setTrait = function(newTrait, target, key) {
      if (newTrait !== null) {
        newTrait = this.fromAny(newTrait);
      }
      let oldTrait = this.trait;
      if (oldTrait !== newTrait) {
        if (target === void 0) {
          target = null;
        }
        let model;
        if (this.binds && (model = this.parentModel, model !== null)) {
          if (oldTrait !== null && oldTrait.model === model) {
            if (target === null) {
              target = oldTrait.nextTrait;
            }
            oldTrait.remove();
          }
          if (newTrait !== null) {
            if (key === void 0) {
              key = this.key;
            }
            this.insertChild(model, newTrait, target, key);
          }
          oldTrait = this.trait;
        }
        if (oldTrait !== newTrait) {
          if (oldTrait !== null) {
            this.willDetachTrait(oldTrait);
            this.trait = null;
            this.onDetachTrait(oldTrait);
            this.deinitTrait(oldTrait);
            this.didDetachTrait(oldTrait);
          }
          if (newTrait !== null) {
            this.willAttachTrait(newTrait, target);
            this.trait = newTrait;
            this.onAttachTrait(newTrait, target);
            this.initTrait(newTrait);
            this.didAttachTrait(newTrait, target);
          }
        }
      }
      return oldTrait;
    };
    TraitRef.prototype.attachTrait = function(newTrait, target) {
      const oldTrait = this.trait;
      if (newTrait !== void 0 && newTrait !== null) {
        newTrait = this.fromAny(newTrait);
      } else if (oldTrait === null) {
        newTrait = this.createTrait();
      } else {
        newTrait = oldTrait;
      }
      if (newTrait !== oldTrait) {
        if (target === void 0) {
          target = null;
        }
        if (oldTrait !== null) {
          this.willDetachTrait(oldTrait);
          this.trait = null;
          this.onDetachTrait(oldTrait);
          this.deinitTrait(oldTrait);
          this.didDetachTrait(oldTrait);
        }
        this.willAttachTrait(newTrait, target);
        this.trait = newTrait;
        this.onAttachTrait(newTrait, target);
        this.initTrait(newTrait);
        this.didAttachTrait(newTrait, target);
      }
      return newTrait;
    };
    TraitRef.prototype.detachTrait = function() {
      const oldTrait = this.trait;
      if (oldTrait !== null) {
        this.willDetachTrait(oldTrait);
        this.trait = null;
        this.onDetachTrait(oldTrait);
        this.deinitTrait(oldTrait);
        this.didDetachTrait(oldTrait);
      }
      return oldTrait;
    };
    TraitRef.prototype.insertTrait = function(model, newTrait, target, key) {
      if (newTrait !== void 0 && newTrait !== null) {
        newTrait = this.fromAny(newTrait);
      } else {
        const oldTrait = this.trait;
        if (oldTrait === null) {
          newTrait = this.createTrait();
        } else {
          newTrait = oldTrait;
        }
      }
      if (model === void 0 || model === null) {
        model = this.parentModel;
      }
      if (target === void 0) {
        target = null;
      }
      if (key === void 0) {
        key = this.key;
      }
      if (model !== null && (newTrait.parent !== model || newTrait.key !== key)) {
        this.insertChild(model, newTrait, target, key);
      }
      const oldTrait = this.trait;
      if (newTrait !== oldTrait) {
        if (oldTrait !== null) {
          this.willDetachTrait(oldTrait);
          this.trait = null;
          this.onDetachTrait(oldTrait);
          this.deinitTrait(oldTrait);
          this.didDetachTrait(oldTrait);
          oldTrait.remove();
        }
        this.willAttachTrait(newTrait, target);
        this.trait = newTrait;
        this.onAttachTrait(newTrait, target);
        this.initTrait(newTrait);
        this.didAttachTrait(newTrait, target);
      }
      return newTrait;
    };
    TraitRef.prototype.removeTrait = function() {
      const trait = this.trait;
      if (trait !== null) {
        trait.remove();
      }
      return trait;
    };
    TraitRef.prototype.deleteTrait = function() {
      const trait = this.detachTrait();
      if (trait !== null) {
        trait.remove();
      }
      return trait;
    };
    TraitRef.prototype.bindModel = function(model, target) {
      if (this.binds && this.trait === null) {
        const newTrait = this.detectModel(model);
        if (newTrait !== null) {
          this.willAttachTrait(newTrait, null);
          this.trait = newTrait;
          this.onAttachTrait(newTrait, null);
          this.initTrait(newTrait);
          this.didAttachTrait(newTrait, null);
        }
      }
    };
    TraitRef.prototype.unbindModel = function(model) {
      if (this.binds) {
        const oldTrait = this.detectModel(model);
        if (oldTrait !== null && this.trait === oldTrait) {
          this.willDetachTrait(oldTrait);
          this.trait = null;
          this.onDetachTrait(oldTrait);
          this.deinitTrait(oldTrait);
          this.didDetachTrait(oldTrait);
        }
      }
    };
    TraitRef.prototype.detectModel = function(model) {
      return null;
    };
    TraitRef.prototype.bindTrait = function(trait, target) {
      if (this.binds && this.trait === null) {
        const newTrait = this.detectTrait(trait);
        if (newTrait !== null) {
          this.willAttachTrait(newTrait, target);
          this.trait = newTrait;
          this.onAttachTrait(newTrait, target);
          this.initTrait(newTrait);
          this.didAttachTrait(newTrait, target);
        }
      }
    };
    TraitRef.prototype.unbindTrait = function(trait) {
      if (this.binds) {
        const oldTrait = this.detectTrait(trait);
        if (oldTrait !== null && this.trait === oldTrait) {
          this.willDetachTrait(oldTrait);
          this.trait = null;
          this.onDetachTrait(oldTrait);
          this.deinitTrait(oldTrait);
          this.didDetachTrait(oldTrait);
        }
      }
    };
    TraitRef.prototype.detectTrait = function(trait) {
      const key = this.key;
      if (key !== void 0 && key === trait.key) {
        return trait;
      }
      return null;
    };
    TraitRef.construct = function(fastenerClass, fastener, owner) {
      if (fastener === null) {
        fastener = function(trait, target, key) {
          if (trait === void 0) {
            return fastener.trait;
          } else {
            fastener.setTrait(trait, target, key);
            return fastener.owner;
          }
        };
        delete fastener.name;
        Object.setPrototypeOf(fastener, fastenerClass.prototype);
      }
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.trait = null;
      return fastener;
    };
    TraitRef.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      if (descriptor.key === true) {
        Object.defineProperty(descriptor, "key", {
          value: className,
          configurable: true
        });
      } else if (descriptor.key === false) {
        Object.defineProperty(descriptor, "key", {
          value: void 0,
          configurable: true
        });
      }
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        return fastener;
      };
      return fastenerClass;
    };
    return TraitRef;
  }(TraitRelation);
  const TraitSet = function(_super) {
    const TraitSet = _super.extend("TraitSet");
    Object.defineProperty(TraitSet.prototype, "fastenerType", {
      get: function() {
        return TraitSet;
      },
      configurable: true
    });
    TraitSet.prototype.hasTrait = function(trait) {
      return this.traits[trait.uid] !== void 0;
    };
    TraitSet.prototype.addTrait = function(newTrait, target, key) {
      if (newTrait !== void 0 && newTrait !== null) {
        newTrait = this.fromAny(newTrait);
      } else {
        newTrait = this.createTrait();
      }
      if (target === void 0) {
        target = null;
      }
      let model;
      if (this.binds && (model = this.parentModel, model !== null)) {
        if (key === void 0) {
          key = this.key(newTrait);
        }
        this.insertChild(model, newTrait, target, key);
      }
      const traits = this.traits;
      if (traits[newTrait.uid] === void 0) {
        this.willAttachTrait(newTrait, target);
        traits[newTrait.uid] = newTrait;
        this.traitCount += 1;
        this.onAttachTrait(newTrait, target);
        this.initTrait(newTrait);
        this.didAttachTrait(newTrait, target);
      }
      return newTrait;
    };
    TraitSet.prototype.attachTrait = function(newTrait, target) {
      if (newTrait !== void 0 && newTrait !== null) {
        newTrait = this.fromAny(newTrait);
      } else {
        newTrait = this.createTrait();
      }
      const traits = this.traits;
      if (traits[newTrait.uid] === void 0) {
        if (target === void 0) {
          target = null;
        }
        this.willAttachTrait(newTrait, target);
        traits[newTrait.uid] = newTrait;
        this.traitCount += 1;
        this.onAttachTrait(newTrait, target);
        this.initTrait(newTrait);
        this.didAttachTrait(newTrait, target);
      }
      return newTrait;
    };
    TraitSet.prototype.detachTrait = function(oldTrait) {
      const traits = this.traits;
      if (traits[oldTrait.uid] !== void 0) {
        this.willDetachTrait(oldTrait);
        this.traitCount -= 1;
        delete traits[oldTrait.uid];
        this.onDetachTrait(oldTrait);
        this.deinitTrait(oldTrait);
        this.didDetachTrait(oldTrait);
        return oldTrait;
      }
      return null;
    };
    TraitSet.prototype.insertTrait = function(model, newTrait, target, key) {
      if (newTrait !== void 0 && newTrait !== null) {
        newTrait = this.fromAny(newTrait);
      } else {
        newTrait = this.createTrait();
      }
      if (model === void 0 || model === null) {
        model = this.parentModel;
      }
      if (target === void 0) {
        target = null;
      }
      if (key === void 0) {
        key = this.key(newTrait);
      }
      if (model !== null && (newTrait.model !== model || newTrait.key !== key)) {
        this.insertChild(model, newTrait, target, key);
      }
      const traits = this.traits;
      if (traits[newTrait.uid] === void 0) {
        this.willAttachTrait(newTrait, target);
        traits[newTrait.uid] = newTrait;
        this.traitCount += 1;
        this.onAttachTrait(newTrait, target);
        this.initTrait(newTrait);
        this.didAttachTrait(newTrait, target);
      }
      return newTrait;
    };
    TraitSet.prototype.removeTrait = function(trait) {
      if (this.hasTrait(trait)) {
        trait.remove();
        return trait;
      }
      return null;
    };
    TraitSet.prototype.deleteTrait = function(trait) {
      const oldTrait = this.detachTrait(trait);
      if (oldTrait !== null) {
        oldTrait.remove();
      }
      return oldTrait;
    };
    TraitSet.prototype.bindModel = function(model, target) {
      if (this.binds) {
        const newTrait = this.detectModel(model);
        const traits = this.traits;
        if (newTrait !== null && traits[newTrait.uid] === void 0) {
          this.willAttachTrait(newTrait, null);
          traits[newTrait.uid] = newTrait;
          this.traitCount += 1;
          this.onAttachTrait(newTrait, null);
          this.initTrait(newTrait);
          this.didAttachTrait(newTrait, null);
        }
      }
    };
    TraitSet.prototype.unbindModel = function(model) {
      if (this.binds) {
        const oldTrait = this.detectModel(model);
        const traits = this.traits;
        if (oldTrait !== null && traits[oldTrait.uid] !== void 0) {
          this.willDetachTrait(oldTrait);
          this.traitCount -= 1;
          delete traits[oldTrait.uid];
          this.onDetachTrait(oldTrait);
          this.deinitTrait(oldTrait);
          this.didDetachTrait(oldTrait);
        }
      }
    };
    TraitSet.prototype.detectModel = function(model) {
      return null;
    };
    TraitSet.prototype.bindTrait = function(trait, target) {
      if (this.binds) {
        const newTrait = this.detectTrait(trait);
        const traits = this.traits;
        if (newTrait !== null && traits[newTrait.uid] === void 0) {
          this.willAttachTrait(newTrait, target);
          traits[newTrait.uid] = newTrait;
          this.traitCount += 1;
          this.onAttachTrait(newTrait, target);
          this.initTrait(newTrait);
          this.didAttachTrait(newTrait, target);
        }
      }
    };
    TraitSet.prototype.unbindTrait = function(trait) {
      if (this.binds) {
        const oldTrait = this.detectTrait(trait);
        const traits = this.traits;
        if (oldTrait !== null && traits[oldTrait.uid] !== void 0) {
          this.willDetachTrait(oldTrait);
          this.traitCount -= 1;
          delete traits[oldTrait.uid];
          this.onDetachTrait(oldTrait);
          this.deinitTrait(oldTrait);
          this.didDetachTrait(oldTrait);
        }
      }
    };
    TraitSet.prototype.detectTrait = function(trait) {
      if (typeof this.type === "function" && trait instanceof this.type) {
        return trait;
      }
      return null;
    };
    TraitSet.prototype.key = function(trait) {
      return void 0;
    };
    Object.defineProperty(TraitSet.prototype, "sorted", {
      get() {
        return (this.flags & TraitSet.SortedFlag) !== 0;
      },
      configurable: true
    });
    TraitSet.prototype.initInherits = function(sorted) {
      if (sorted) {
        this.flags = this.flags | TraitSet.SortedFlag;
      } else {
        this.flags = this.flags & ~TraitSet.SortedFlag;
      }
    };
    TraitSet.prototype.sort = function(sorted) {
      if (sorted === void 0) {
        sorted = true;
      }
      const flags = this.flags;
      if (sorted && (flags & TraitSet.SortedFlag) === 0) {
        const parent = this.parentModel;
        this.willSort(parent);
        this.setFlags(flags | TraitSet.SortedFlag);
        this.onSort(parent);
        this.didSort(parent);
      } else if (!sorted && (flags & TraitSet.SortedFlag) !== 0) {
        this.setFlags(flags & ~TraitSet.SortedFlag);
      }
      return this;
    };
    TraitSet.prototype.willSort = function(parent) {};
    TraitSet.prototype.onSort = function(parent) {
      if (parent !== null) {
        this.sortChildren(parent);
      }
    };
    TraitSet.prototype.didSort = function(parent) {};
    TraitSet.prototype.sortChildren = function(parent) {
      parent.sortTraits(this.compareChildren.bind(this));
    };
    TraitSet.prototype.compareChildren = function(a, b) {
      const traits = this.traits;
      const x = traits[a.uid];
      const y = traits[b.uid];
      if (x !== void 0 && y !== void 0) {
        return this.compare(x, y);
      } else {
        return x !== void 0 ? 1 : y !== void 0 ? -1 : 0;
      }
    };
    TraitSet.prototype.compare = function(a, b) {
      return a.uid < b.uid ? -1 : a.uid > b.uid ? 1 : 0;
    };
    TraitSet.construct = function(fastenerClass, fastener, owner) {
      if (fastener === null) {
        fastener = function(newTrait) {
          fastener.addTrait(newTrait);
          return fastener.owner;
        };
        delete fastener.name;
        Object.setPrototypeOf(fastener, fastenerClass.prototype);
      }
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.traits = {};
      fastener.traitCount = 0;
      return fastener;
    };
    TraitSet.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const sorted = descriptor.sorted;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.sorted;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        if (sorted !== void 0) {
          fastener.initSorted(sorted);
        }
        return fastener;
      };
      return fastenerClass;
    };
    TraitSet.SortedFlag = 1 << _super.FlagShift + 0;
    TraitSet.FlagShift = _super.FlagShift + 1;
    TraitSet.FlagMask = (1 << TraitSet.FlagShift) - 1;
    return TraitSet;
  }(TraitRelation);
  class SelectableTrait extends Trait {
    constructor() {
      super();
      this.selected = false;
    }
    select(options) {
      if (!this.selected) {
        this.selected = true;
        if (this.mounted) {
          const selectionService = this.selectionProvider.service;
          if (selectionService !== void 0 && selectionService !== null) {
            selectionService.select(this.model, options);
          }
        }
      }
    }
    willSelect(options) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillSelect !== void 0) {
          observer.traitWillSelect(options, this);
        }
      }
    }
    onSelect(options) {
      this.selected = true;
    }
    didSelect(options) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidSelect !== void 0) {
          observer.traitDidSelect(options, this);
        }
      }
    }
    unselect() {
      if (this.selected) {
        this.selected = false;
        if (this.mounted) {
          const selectionService = this.selectionProvider.service;
          if (selectionService !== void 0 && selectionService !== null) {
            selectionService.unselect(this.model);
          }
        }
      }
    }
    willUnselect() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitWillUnselect !== void 0) {
          observer.traitWillUnselect(this);
        }
      }
    }
    onUnselect() {
      this.selected = false;
    }
    didUnselect() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.traitDidUnselect !== void 0) {
          observer.traitDidUnselect(this);
        }
      }
    }
    unselectAll() {
      const selectionService = this.selectionProvider.service;
      if (selectionService !== void 0 && selectionService !== null) {
        selectionService.unselectAll();
      }
    }
    toggle(options) {
      if (!this.selected) {
        this.select(options);
      } else {
        this.unselect();
      }
    }
    didMount() {
      if (this.selected) {
        const selectionService = this.selectionProvider.service;
        if (selectionService !== void 0 && selectionService !== null) {
          selectionService.select(this.model);
        }
      }
      super.didMount();
    }
    willUnmount() {
      super.willUnmount();
      const selectionService = this.selectionProvider.service;
      if (selectionService !== void 0 && selectionService !== null) {
        selectionService.unselect(this.model);
      }
    }
  }
  __decorate([ component.Provider({
    extends: SelectionProvider,
    type: SelectionService,
    observes: false,
    service: SelectionService.global()
  }) ], SelectableTrait.prototype, "selectionProvider", void 0);
  class DownlinkTrait extends Trait {}
  __decorate([ TraitRef({
    type: Trait,
    observes: true,
    didAttachTrait(driverTrait) {
      if (driverTrait.consuming) {
        this.owner.consume(driverTrait);
      }
    },
    willDetachTrait(driverTrait) {
      if (driverTrait.consuming) {
        this.owner.unconsume(driverTrait);
      }
    },
    traitDidStartConsuming(driverTrait) {
      this.owner.consume(driverTrait);
    },
    traitWillStopConsuming(driverTrait) {
      this.owner.unconsume(driverTrait);
    }
  }) ], DownlinkTrait.prototype, "driver", void 0);
  class ValueDownlinkTrait extends DownlinkTrait {
    downlinkDidSet(newValue, oldValue) {}
  }
  __decorate([ client.ValueDownlinkFastener({
    lazy: false,
    consumed: true,
    didSet(newValue, oldValue) {
      if (this.owner.consuming) {
        this.owner.downlinkDidSet(newValue, oldValue);
      }
    }
  }) ], ValueDownlinkTrait.prototype, "downlink", void 0);
  class MapDownlinkTrait extends DownlinkTrait {
    downlinkDidUpdate(key, newValue, oldValue) {}
    downlinkDidRemove(key, oldValue) {}
  }
  __decorate([ client.MapDownlinkFastener({
    lazy: false,
    consumed: true,
    didUpdate(key, newValue, oldValue) {
      if (this.owner.consuming) {
        this.owner.downlinkDidUpdate(key, newValue, oldValue);
      }
    },
    didRemove(key, oldValue) {
      if (this.owner.consuming) {
        this.owner.downlinkDidRemove(key, oldValue);
      }
    }
  }) ], MapDownlinkTrait.prototype, "downlink", void 0);
  const FontSize = function() {
    const FontSize = {};
    FontSize.fromAny = function(size) {
      if (typeof size === "string" && (size === "large" || size === "larger" || size === "medium" || size === "small" || size === "smaller" || size === "x-large" || size === "x-small" || size === "xx-large" || size === "xx-small")) {
        return size;
      } else {
        return math.Length.fromAny(size);
      }
    };
    FontSize.fromValue = function(value) {
      const string = value.stringValue(null);
      if (string !== null) {
        return FontSize.fromAny(string);
      } else {
        const size = math.Length.form().cast(value);
        return size !== void 0 ? size : null;
      }
    };
    return FontSize;
  }();
  const LineHeight = function() {
    const LineHeight = {};
    LineHeight.fromAny = function(height) {
      if (typeof height === "string" && height === "normal") {
        return height;
      } else {
        return math.Length.fromAny(height);
      }
    };
    LineHeight.fromValue = function(value) {
      const string = value.stringValue(null);
      if (string !== null) {
        return LineHeight.fromAny(string);
      } else {
        const height = math.Length.form().cast(value);
        return height !== void 0 ? height : null;
      }
    };
    return LineHeight;
  }();
  const FontFamily = function() {
    const FontFamily = {};
    FontFamily.fromValue = function(value) {
      let family = null;
      value.forEach((function(item) {
        if (item instanceof structure.Value) {
          const string = item.stringValue(void 0);
          if (string !== void 0) {
            if (family === null) {
              family = string;
            } else if (typeof family === "string") {
              family = [ family, string ];
            } else {
              family.push(string);
            }
          }
        }
      }));
      return family;
    };
    FontFamily.format = function(family) {
      const n = family.length;
      let isIdent;
      if (n > 0) {
        isIdent = codec.Unicode.isAlpha(family.charCodeAt(0));
        for (let i = util.Strings.offsetByCodePoints(family, 0, 1); isIdent && i < n; i = util.Strings.offsetByCodePoints(family, i, 1)) {
          const c = family.charCodeAt(i);
          isIdent = codec.Unicode.isAlpha(c) || c === 45;
        }
      } else {
        isIdent = false;
      }
      if (isIdent) {
        return family;
      } else {
        let output = codec.Unicode.stringOutput();
        output = output.write(34);
        for (let i = 0; i < n; i = util.Strings.offsetByCodePoints(family, i, 1)) {
          const c = family.charCodeAt(i);
          if (c === 10 || c === 34 || c === 39) {
            output = output.write(92).write(c);
          } else if (c >= 32) {
            output = output.write(c);
          } else {
            const base16 = codec.Base16.uppercase;
            output = output.write(92).write(base16.encodeDigit(c >>> 20 & 15)).write(base16.encodeDigit(c >>> 16 & 15)).write(base16.encodeDigit(c >>> 12 & 15)).write(base16.encodeDigit(c >>> 8 & 15)).write(base16.encodeDigit(c >>> 4 & 15)).write(base16.encodeDigit(c & 15));
          }
        }
        output = output.write(34);
        return output.toString();
      }
    };
    return FontFamily;
  }();
  class FontFamilyParser extends codec.Parser {
    constructor(output, quote, code, step) {
      super();
      this.output = output;
      this.quote = quote;
      this.code = code;
      this.step = step;
    }
    feed(input) {
      return FontFamilyParser.parse(input, this.output, this.quote, this.code, this.step);
    }
    static parse(input, output, quote = 0, code = 0, step = 1) {
      let c = 0;
      if (step === 1) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (codec.Unicode.isAlpha(c) || c === 45) {
            output = output || codec.Unicode.stringOutput();
            step = 2;
          } else if (c === 34 || c === 39 && (quote === c || quote === 0)) {
            input = input.step();
            output = output || codec.Unicode.stringOutput();
            quote = c;
            step = 3;
          } else {
            return codec.Parser.error(codec.Diagnostic.expected("font family", input));
          }
        } else if (input.isDone()) {
          return codec.Parser.error(codec.Diagnostic.expected("font family", input));
        }
      }
      if (step === 2) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isAlpha(c) || c === 45)) {
          input = input.step();
          output.write(c);
        }
        if (!input.isEmpty()) {
          return codec.Parser.done(output.bind());
        }
      }
      string: do {
        if (step === 3) {
          while (input.isCont()) {
            c = input.head();
            if (c >= 32 && c !== quote && c !== 92) {
              input = input.step();
              output.write(c);
            } else {
              break;
            }
          }
          if (input.isCont()) {
            if (c === quote) {
              input = input.step();
              return codec.Parser.done(output.bind());
            } else if (c === 92) {
              input = input.step();
              step = 4;
            } else {
              return codec.Parser.error(codec.Diagnostic.expected(quote, input));
            }
          } else if (input.isDone()) {
            return codec.Parser.error(codec.Diagnostic.expected(quote, input));
          }
        }
        if (step === 4) {
          if (input.isCont()) {
            c = input.head();
            if (codec.Base16.isDigit(c)) {
              step = 5;
            } else if (c === 10) {
              input.step();
              step = 3;
              continue;
            } else {
              input.step();
              output.write(c);
              step = 3;
              continue;
            }
          } else if (input.isDone()) {
            return codec.Parser.error(codec.Diagnostic.expected("escape character", input));
          }
        }
        if (step >= 5) {
          do {
            if (input.isCont() && (c = input.head(), codec.Base16.isDigit(c))) {
              input = input.step();
              code = 16 * code + codec.Base16.decodeDigit(c);
              if (step <= 11) {
                step += 1;
                continue;
              } else {
                if (code === 0) {
                  return codec.Parser.error(codec.Diagnostic.message("zero escape", input));
                }
                output.write(code);
                code = 0;
                step = 3;
                continue string;
              }
            } else if (!input.isEmpty()) {
              return codec.Parser.error(codec.Diagnostic.unexpected(input));
            }
            break;
          } while (true);
        }
        break;
      } while (true);
      return new FontFamilyParser(output, quote, code, step);
    }
  }
  class Font {
    constructor(style, variant, weight, stretch, size, height, family) {
      this.style = style;
      this.variant = variant;
      this.weight = weight;
      this.stretch = stretch;
      this.size = size;
      this.height = height;
      this.family = family;
      this.stringValue = void 0;
    }
    withStyle(style) {
      if (style === this.style) {
        return this;
      } else {
        return new Font(style, this.variant, this.weight, this.stretch, this.size, this.height, this.family);
      }
    }
    withVariant(variant) {
      if (variant === this.variant) {
        return this;
      } else {
        return new Font(this.style, variant, this.weight, this.stretch, this.size, this.height, this.family);
      }
    }
    withWeight(weight) {
      if (weight === this.weight) {
        return this;
      } else {
        return new Font(this.style, this.variant, weight, this.stretch, this.size, this.height, this.family);
      }
    }
    withStretch(stretch) {
      if (stretch === this.stretch) {
        return this;
      } else {
        return new Font(this.style, this.variant, this.weight, stretch, this.size, this.height, this.family);
      }
    }
    withSize(size) {
      if (size !== null) {
        size = FontSize.fromAny(size);
      }
      if (util.Values.equal(size, this.size)) {
        return this;
      } else {
        return new Font(this.style, this.variant, this.weight, this.stretch, size, this.height, this.family);
      }
    }
    withHeight(height) {
      if (height !== null) {
        height = LineHeight.fromAny(height);
      }
      if (util.Values.equal(height, this.height)) {
        return this;
      } else {
        return new Font(this.style, this.variant, this.weight, this.stretch, this.size, height, this.family);
      }
    }
    withFamily(family) {
      if (Array.isArray(family) && family.length === 1) {
        family = family[0];
      }
      if (util.Values.equal(family, this.family)) {
        return this;
      } else {
        return new Font(this.style, this.variant, this.weight, this.stretch, this.size, this.height, family);
      }
    }
    toAny() {
      return {
        style: this.style,
        variant: this.variant,
        weight: this.weight,
        stretch: this.stretch,
        size: this.size,
        height: this.height,
        family: Array.isArray(this.family) ? this.family.slice(0) : this.family
      };
    }
    interpolateTo(that) {
      if (that instanceof Font) {
        return FontInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof Font) {
        return this.style === that.style && this.variant === that.variant && this.weight === that.weight && this.stretch === that.stretch && util.Values.equivalent(this.size, that.size, epsilon) && util.Values.equivalent(this.height, that.height, epsilon) && util.Values.equivalent(this.family, that.family, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Font) {
        return this.style === that.style && this.variant === that.variant && this.weight === that.weight && this.stretch === that.stretch && util.Values.equal(this.size, that.size) && util.Values.equal(this.height, that.height) && util.Values.equal(this.family, that.family);
      }
      return false;
    }
    debug(output) {
      output = output.write("Font").write(46).write("family").write(40);
      if (typeof this.family === "string") {
        output = output.debug(this.family);
      } else if (Array.isArray(this.family) && this.family.length !== 0) {
        output = output.debug(this.family[0]);
        for (let i = 1; i < this.family.length; i += 1) {
          output = output.write(", ").debug(this.family[i]);
        }
      }
      output = output.write(41);
      if (this.style !== void 0) {
        output = output.write(46).write("style").write(40).debug(this.style).write(41);
      }
      if (this.variant !== void 0) {
        output = output.write(46).write("variant").write(40).debug(this.variant).write(41);
      }
      if (this.weight !== void 0) {
        output = output.write(46).write("weight").write(40).debug(this.weight).write(41);
      }
      if (this.stretch !== void 0) {
        output = output.write(46).write("stretch").write(40).debug(this.stretch).write(41);
      }
      if (this.size !== void 0) {
        output = output.write(46).write("size").write(40).debug(this.size).write(41);
      }
      if (this.height !== void 0) {
        output = output.write(46).write("height").write(40).debug(this.height).write(41);
      }
      return output;
    }
    toString() {
      var _a, _b, _c;
      let s = this.stringValue;
      if (s === void 0) {
        s = "";
        if (this.style !== void 0 || this.variant === "normal" || this.weight === "normal" || this.stretch === "normal") {
          s += (_a = this.style) !== null && _a !== void 0 ? _a : "normal";
        }
        if (this.variant !== void 0 || this.weight === "normal" || this.stretch === "normal") {
          if (s.length !== 0) {
            s += " ";
          }
          s += (_b = this.variant) !== null && _b !== void 0 ? _b : "normal";
        }
        if (this.weight !== void 0 || this.stretch === "normal") {
          if (s.length !== 0) {
            s += " ";
          }
          s += (_c = this.weight) !== null && _c !== void 0 ? _c : "normal";
        }
        if (this.stretch !== void 0) {
          if (s.length !== 0) {
            s += " ";
          }
          s += this.stretch;
        }
        if (this.size !== null) {
          if (s.length !== 0) {
            s += " ";
          }
          s += this.size.toString();
          if (this.height !== null) {
            s += "/";
            s += this.height.toString();
          }
        }
        if (typeof this.family === "string") {
          if (s.length !== 0) {
            s += " ";
          }
          s += FontFamily.format(this.family);
        } else if (Array.isArray(this.family) && this.family.length !== 0) {
          if (s.length !== 0) {
            s += " ";
          }
          s += FontFamily.format(this.family[0]);
          for (let i = 1; i < this.family.length; i += 1) {
            s += ", ";
            s += FontFamily.format(this.family[i]);
          }
        }
        this.stringValue = s;
      }
      return s;
    }
    static style(style, family) {
      if (Array.isArray(family) && family.length === 1) {
        family = family[0];
      }
      return new Font(style, void 0, void 0, void 0, null, null, family);
    }
    static variant(variant, family) {
      if (Array.isArray(family) && family.length === 1) {
        family = family[0];
      }
      return new Font(void 0, variant, void 0, void 0, null, null, family);
    }
    static weight(weight, family) {
      if (Array.isArray(family) && family.length === 1) {
        family = family[0];
      }
      return new Font(void 0, void 0, weight, void 0, null, null, family);
    }
    static stretch(stretch, family) {
      if (Array.isArray(family) && family.length === 1) {
        family = family[0];
      }
      return new Font(void 0, void 0, void 0, stretch, null, null, family);
    }
    static size(size, family) {
      size = size !== null ? FontSize.fromAny(size) : null;
      if (Array.isArray(family) && family.length === 1) {
        family = family[0];
      }
      return new Font(void 0, void 0, void 0, void 0, size, null, family);
    }
    static family(family) {
      if (Array.isArray(family) && family.length === 1) {
        family = family[0];
      }
      return new Font(void 0, void 0, void 0, void 0, null, null, family);
    }
    static create(style, variant, weight, stretch, size, height, family) {
      size = size !== void 0 && size !== null ? FontSize.fromAny(size) : null;
      height = height !== void 0 && height !== null ? LineHeight.fromAny(height) : null;
      if (Array.isArray(family) && family.length === 1) {
        family = family[0];
      }
      return new Font(style, variant, weight, stretch, size, height, family);
    }
    static fromInit(init) {
      return Font.create(init.style, init.variant, init.weight, init.stretch, init.size, init.height, init.family);
    }
    static fromValue(value) {
      const header = value.header("font");
      if (header.isDefined()) {
        const style = header.get("style").stringValue(void 0);
        const variant = header.get("variant").stringValue(void 0);
        const weight = header.get("weight").stringValue(void 0);
        const stretch = header.get("stretch").stringValue(void 0);
        const size = FontSize.fromValue(header.get("size"));
        const height = LineHeight.fromValue(header.get("height"));
        const family = FontFamily.fromValue(header.get("family"));
        if (family !== null) {
          return Font.create(style, variant, weight, stretch, size, height, family);
        }
      }
      return null;
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof Font) {
        return value;
      } else if (typeof value === "object" && value !== null) {
        return Font.fromInit(value);
      } else if (typeof value === "string") {
        return Font.parse(value);
      }
      throw new TypeError("" + value);
    }
    static parse(string) {
      let input = codec.Unicode.stringInput(string);
      while (input.isCont() && codec.Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = FontParser.parse(input);
      if (parser.isDone()) {
        while (input.isCont() && codec.Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = codec.Parser.error(codec.Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return init.family !== void 0;
      }
      return false;
    }
    static isAny(value) {
      return value instanceof Font || Font.isInit(value);
    }
    static form(unit) {
      return new FontForm(void 0);
    }
  }
  __decorate([ util.Lazy ], Font, "form", null);
  const FontInterpolator = function(_super) {
    const FontInterpolator = function(f0, f1) {
      const interpolator = function(u) {
        const style = interpolator.styleInterpolator(u);
        const variant = interpolator.variantInterpolator(u);
        const weight = interpolator.weightInterpolator(u);
        const stretch = interpolator.stretchInterpolator(u);
        const size = interpolator.sizeInterpolator(u);
        const height = interpolator.heightInterpolator(u);
        const family = interpolator.familyInterpolator(u);
        return new Font(style, variant, weight, stretch, size, height, family);
      };
      Object.setPrototypeOf(interpolator, FontInterpolator.prototype);
      interpolator.styleInterpolator = util.Interpolator(f0.style, f1.style);
      interpolator.variantInterpolator = util.Interpolator(f0.variant, f1.variant);
      interpolator.weightInterpolator = util.Interpolator(f0.weight, f1.weight);
      interpolator.stretchInterpolator = util.Interpolator(f0.stretch, f1.stretch);
      interpolator.sizeInterpolator = util.Interpolator(f0.size, f1.size);
      interpolator.heightInterpolator = util.Interpolator(f0.height, f1.height);
      interpolator.familyInterpolator = util.Interpolator(f0.family, f1.family);
      return interpolator;
    };
    FontInterpolator.prototype = Object.create(_super.prototype);
    FontInterpolator.prototype.constructor = FontInterpolator;
    Object.defineProperty(FontInterpolator.prototype, 0, {
      get() {
        const style = this.styleInterpolator[0];
        const variant = this.variantInterpolator[0];
        const weight = this.weightInterpolator[0];
        const stretch = this.stretchInterpolator[0];
        const size = this.sizeInterpolator[0];
        const height = this.heightInterpolator[0];
        const family = this.familyInterpolator[0];
        return new Font(style, variant, weight, stretch, size, height, family);
      },
      configurable: true
    });
    Object.defineProperty(FontInterpolator.prototype, 1, {
      get() {
        const style = this.styleInterpolator[1];
        const variant = this.variantInterpolator[1];
        const weight = this.weightInterpolator[1];
        const stretch = this.stretchInterpolator[1];
        const size = this.sizeInterpolator[1];
        const height = this.heightInterpolator[1];
        const family = this.familyInterpolator[1];
        return new Font(style, variant, weight, stretch, size, height, family);
      },
      configurable: true
    });
    FontInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof FontInterpolator) {
        return this.styleInterpolator.equals(that.styleInterpolator) && this.variantInterpolator.equals(that.variantInterpolator) && this.weightInterpolator.equals(that.weightInterpolator) && this.stretchInterpolator.equals(that.stretchInterpolator) && this.sizeInterpolator.equals(that.sizeInterpolator) && this.heightInterpolator.equals(that.heightInterpolator) && this.familyInterpolator.equals(that.familyInterpolator);
      }
      return false;
    };
    return FontInterpolator;
  }(util.Interpolator);
  class FontForm extends structure.Form {
    constructor(unit) {
      super();
      Object.defineProperty(this, "unit", {
        value: unit,
        enumerable: true
      });
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new FontForm(unit);
      } else {
        return this;
      }
    }
    mold(font) {
      font = Font.fromAny(font);
      const header = structure.Record.create(7);
      if (font.style !== void 0) {
        header.slot("style", font.style);
      }
      if (font.variant !== void 0) {
        header.slot("variant", font.variant);
      }
      if (font.weight !== void 0) {
        header.slot("weight", font.weight);
      }
      if (font.stretch !== void 0) {
        header.slot("stretch", font.stretch);
      }
      if (font.size instanceof math.Length) {
        header.slot("size", math.Length.form().mold(font.size));
      } else if (font.size !== void 0) {
        header.slot("size", font.size);
      }
      if (font.height instanceof math.Length) {
        header.slot("height", math.Length.form().mold(font.height));
      } else if (font.height !== void 0) {
        header.slot("height", font.height);
      }
      if (Array.isArray(font.family)) {
        const family = structure.Record.create(font.family.length);
        for (let i = 0; i < font.family.length; i += 1) {
          family.push(font.family[i]);
        }
        header.slot("family", family);
      } else {
        header.slot("family", font.family);
      }
      return structure.Record.of(structure.Attr.of("font", header));
    }
    cast(item) {
      const value = item.toValue();
      let font = null;
      try {
        font = Font.fromValue(value);
        if (font === null) {
          const string = value.stringValue();
          if (string !== void 0) {
            font = Font.parse(string);
          }
        }
      } catch (e) {}
      return font !== null ? font : void 0;
    }
  }
  class FontParser extends codec.Parser {
    constructor(style, variant, weight, stretch, size, height, family, identOutput, lengthParser, familyParser, step) {
      super();
      this.style = style;
      this.variant = variant;
      this.weight = weight;
      this.stretch = stretch;
      this.size = size;
      this.height = height;
      this.family = family;
      this.identOutput = identOutput;
      this.lengthParser = lengthParser;
      this.familyParser = familyParser;
      this.step = step;
    }
    feed(input) {
      return FontParser.parse(input, this.style, this.variant, this.weight, this.stretch, this.size, this.height, this.family, this.identOutput, this.lengthParser, this.familyParser, this.step);
    }
    static parse(input, style, variant, weight, stretch, size, height, family, identOutput, lengthParser, familyParser, step = 1) {
      let c = 0;
      do {
        if (step === 1) {
          while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
            input.step();
          }
          if (input.isCont()) {
            if (codec.Unicode.isAlpha(c)) {
              step = 2;
            } else if (c === 34 || c === 39) {
              step = 11;
            } else {
              step = 4;
            }
          } else if (!input.isEmpty()) {
            return codec.Parser.error(codec.Diagnostic.unexpected(input));
          }
        }
        if (step === 2) {
          identOutput = identOutput || codec.Unicode.stringOutput();
          while (input.isCont() && (c = input.head(), codec.Unicode.isAlpha(c) || c === 45)) {
            input = input.step();
            identOutput.write(c);
          }
          if (!input.isEmpty()) {
            const ident = identOutput.bind();
            identOutput = void 0;
            switch (ident) {
             case "italic":
             case "oblique":
              if (style === void 0) {
                style = ident;
              } else {
                return codec.Parser.error(codec.Diagnostic.message("reapeated font style: " + ident, input));
              }
              step = 3;
              break;

             case "small-caps":
              if (variant === void 0) {
                variant = ident;
              } else {
                return codec.Parser.error(codec.Diagnostic.message("reapeated font variant: " + ident, input));
              }
              step = 3;
              break;

             case "bold":
             case "bolder":
             case "lighter":
              if (weight === void 0) {
                weight = ident;
              } else {
                return codec.Parser.error(codec.Diagnostic.message("reapeated font weight: " + ident, input));
              }
              step = 3;
              break;

             case "ultra-condensed":
             case "extra-condensed":
             case "semi-condensed":
             case "condensed":
             case "expanded":
             case "semi-expanded":
             case "extra-expanded":
             case "ultra-expanded":
              if (stretch === void 0) {
                stretch = ident;
              } else {
                return codec.Parser.error(codec.Diagnostic.message("reapeated font stretch: " + ident, input));
              }
              step = 3;
              break;

             case "normal":
              if (style === void 0) {
                style = ident;
              } else if (variant === void 0) {
                variant = ident;
              } else if (weight === void 0) {
                weight = ident;
              } else if (stretch === void 0) {
                stretch = ident;
              } else {
                return codec.Parser.error(codec.Diagnostic.message("reapeated font property: " + ident, input));
              }
              step = 3;
              break;

             case "large":
             case "larger":
             case "medium":
             case "small":
             case "smaller":
             case "x-large":
             case "x-small":
             case "xx-large":
             case "xx-small":
              size = ident;
              step = 5;
              break;

             default:
              family = ident;
              step = 12;
            }
          }
        }
        if (step === 3) {
          if (input.isCont()) {
            c = input.head();
            if (codec.Unicode.isSpace(c)) {
              input.step();
              step = 1;
              continue;
            } else {
              return codec.Parser.error(codec.Diagnostic.expected("font property, size, or family", input));
            }
          } else if (!input.isEmpty()) {
            return codec.Parser.error(codec.Diagnostic.unexpected(input));
          }
        }
        if (step === 4) {
          if (lengthParser === void 0) {
            lengthParser = math.LengthParser.parse(input);
          } else {
            lengthParser = lengthParser.feed(input);
          }
          if (lengthParser.isDone()) {
            const length = lengthParser.bind();
            if (length.units === "") {
              const value = length.value;
              switch (value) {
               case 100:
               case 200:
               case 300:
               case 400:
               case 500:
               case 600:
               case 700:
               case 800:
               case 900:
                if (weight === void 0) {
                  weight = String(value);
                } else {
                  return codec.Parser.error(codec.Diagnostic.message("reapeated font weight: " + value, input));
                }
                break;

               default:
                return codec.Parser.error(codec.Diagnostic.message("unknown font property: " + value, input));
              }
              step = 3;
              continue;
            } else {
              size = length;
              lengthParser = void 0;
              step = 5;
            }
          } else if (lengthParser.isError()) {
            return lengthParser.asError();
          }
        }
        if (step === 5) {
          if (input.isCont()) {
            c = input.head();
            if (codec.Unicode.isSpace(c)) {
              input.step();
              step = 6;
            } else if (c === 47) {
              input.step();
              step = 7;
            } else {
              return codec.Parser.error(codec.Diagnostic.expected("font family", input));
            }
          } else if (!input.isEmpty()) {
            return codec.Parser.error(codec.Diagnostic.unexpected(input));
          }
        }
        if (step === 6) {
          while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
            input.step();
          }
          if (input.isCont()) {
            if (c === 47) {
              input.step();
              step = 7;
            } else {
              step = 11;
            }
          } else if (!input.isEmpty()) {
            return codec.Parser.error(codec.Diagnostic.unexpected(input));
          }
        }
        if (step === 7) {
          while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
            input.step();
          }
          if (input.isCont()) {
            if (codec.Unicode.isAlpha(c)) {
              step = 8;
            } else {
              step = 9;
            }
          } else if (!input.isEmpty()) {
            return codec.Parser.error(codec.Diagnostic.unexpected(input));
          }
        }
        if (step === 8) {
          identOutput = identOutput || codec.Unicode.stringOutput();
          while (input.isCont() && (c = input.head(), codec.Unicode.isAlpha(c))) {
            input = input.step();
            identOutput.write(c);
          }
          if (!input.isEmpty()) {
            const ident = identOutput.bind();
            identOutput = void 0;
            switch (ident) {
             case "normal":
              height = ident;
              step = 10;
              break;

             default:
              return codec.Parser.error(codec.Diagnostic.message("unknown line height: " + ident, input));
            }
          }
        }
        if (step === 9) {
          if (lengthParser === void 0) {
            lengthParser = math.LengthParser.parse(input);
          } else {
            lengthParser = lengthParser.feed(input);
          }
          if (lengthParser.isDone()) {
            height = lengthParser.bind();
            lengthParser = void 0;
            step = 10;
          } else if (lengthParser.isError()) {
            return lengthParser.asError();
          }
        }
        if (step === 10) {
          if (input.isCont()) {
            c = input.head();
            if (codec.Unicode.isSpace(c)) {
              input.step();
              step = 11;
            } else {
              return codec.Parser.error(codec.Diagnostic.expected("font family", input));
            }
          } else if (!input.isEmpty()) {
            return codec.Parser.error(codec.Diagnostic.unexpected(input));
          }
        }
        if (step === 11) {
          if (familyParser === void 0) {
            familyParser = FontFamilyParser.parse(input);
          } else {
            familyParser = familyParser.feed(input);
          }
          if (familyParser.isDone()) {
            if (Array.isArray(family)) {
              family.push(familyParser.bind());
            } else if (family !== void 0) {
              family = [ family, familyParser.bind() ];
            } else {
              family = familyParser.bind();
            }
            familyParser = void 0;
            step = 12;
          } else if (familyParser.isError()) {
            return familyParser.asError();
          }
        }
        if (step === 12) {
          while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
            input.step();
          }
          if (input.isCont() && c === 44) {
            input.step();
            step = 11;
            continue;
          } else if (!input.isEmpty()) {
            return codec.Parser.done(Font.create(style, variant, weight, stretch, size, height, family));
          }
        }
        break;
      } while (true);
      return new FontParser(style, variant, weight, stretch, size, height, family, identOutput, lengthParser, familyParser, step);
    }
    static parseRest(input, style, variant, weight, stretch, size, height, family) {
      const step = family !== void 0 ? 12 : size !== void 0 ? 5 : 3;
      return FontParser.parse(input, style, variant, weight, stretch, size, height, family, void 0, void 0, void 0, step);
    }
  }
  class Color {
    contrast(k) {
      return this.lightness < .67 ? this.lighter(k) : this.darker(k);
    }
    interpolateTo(that) {
      if (that instanceof Color) {
        return RgbColorInterpolator(this.rgb(), that.rgb());
      } else {
        return null;
      }
    }
    static transparent() {
      return RgbColor.transparent();
    }
    static black(alpha) {
      return RgbColor.black(alpha);
    }
    static white(alpha) {
      return RgbColor.white(alpha);
    }
    static rgb(r, g, b, a) {
      return new RgbColor(r, g, b, a);
    }
    static hsl(h, s, l, a) {
      if (typeof h !== "number") {
        h = math.Angle.fromAny(h).degValue();
      }
      return new HslColor(h, s, l, a);
    }
    static forName(name) {
      switch (name) {
       case "transparent":
        return Color.transparent();

       case "black":
        return Color.black();

       case "white":
        return Color.white();

       default:
        return null;
      }
    }
    static fromInit(value) {
      if (RgbColor.isInit(value)) {
        return RgbColor.fromInit(value);
      } else if (HslColor.isInit(value)) {
        return HslColor.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof Color) {
        return value;
      } else if (typeof value === "string") {
        return Color.parse(value);
      } else if (RgbColor.isInit(value)) {
        return RgbColor.fromInit(value);
      } else if (HslColor.isInit(value)) {
        return HslColor.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static fromValue(value) {
      let color;
      color = RgbColor.fromValue(value);
      if (color === void 0) {
        color = HslColor.fromValue(value);
      }
      return color;
    }
    static parse(string) {
      let input = codec.Unicode.stringInput(string);
      while (input.isCont() && codec.Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = ColorParser.parse(input);
      if (parser.isDone()) {
        while (input.isCont() && codec.Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = codec.Parser.error(codec.Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    static isInit(value) {
      return RgbColor.isInit(value) || HslColor.isInit(value);
    }
    static isAny(value) {
      return value instanceof Color || Color.isInit(value) || typeof value === "string";
    }
    static form() {
      return new ColorForm(Color.transparent());
    }
  }
  Color.Darker = .7;
  Color.Brighter = 1 / Color.Darker;
  __decorate([ util.Lazy ], Color, "form", null);
  class ColorForm extends structure.Form {
    constructor(unit) {
      super();
      Object.defineProperty(this, "unit", {
        value: unit,
        enumerable: true
      });
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new ColorForm(unit);
      } else {
        return this;
      }
    }
    mold(color) {
      color = Color.fromAny(color);
      return structure.Text.from(color.toString());
    }
    cast(item) {
      const value = item.toValue();
      let color = null;
      try {
        color = Color.fromValue(value);
        if (color === void 0) {
          const string = value.stringValue(void 0);
          if (string !== void 0) {
            color = Color.parse(string);
          }
        }
      } catch (e) {}
      return color !== null ? color : void 0;
    }
  }
  class ColorParser extends codec.Parser {
    constructor(identOutput, step) {
      super();
      this.identOutput = identOutput;
      this.step = step;
    }
    feed(input) {
      return ColorParser.parse(input, this.identOutput, this.step);
    }
    static parse(input, identOutput, step = 1) {
      let c = 0;
      if (step === 1) {
        if (input.isCont()) {
          if (input.head() === 35) {
            return HexColorParser.parse(input);
          } else {
            step = 2;
          }
        } else if (input.isDone()) {
          return codec.Parser.error(codec.Diagnostic.unexpected(input));
        }
      }
      if (step === 2) {
        identOutput = identOutput || codec.Unicode.stringOutput();
        while (input.isCont() && (c = input.head(), codec.Unicode.isAlpha(c))) {
          input = input.step();
          identOutput.write(c);
        }
        if (!input.isEmpty()) {
          const ident = identOutput.bind();
          switch (ident) {
           case "rgb":
           case "rgba":
            return RgbColorParser.parseRest(input);

           case "hsl":
           case "hsla":
            return HslColorParser.parseRest(input);

           default:
            {
              const color = Color.forName(ident);
              if (color !== null) {
                return codec.Parser.done(color);
              } else {
                return codec.Parser.error(codec.Diagnostic.message("unknown color: " + ident, input));
              }
            }
          }
        }
      }
      return new ColorParser(identOutput, step);
    }
  }
  class ColorChannel {
    constructor(value, units) {
      this.value = value;
      this.units = units !== void 0 ? units : "";
    }
    scale(k) {
      if (this.units === "%") {
        return this.value * k / 100;
      } else {
        return this.value;
      }
    }
  }
  class ColorChannelParser extends codec.Parser {
    constructor(valueParser, step) {
      super();
      this.valueParser = valueParser;
      this.step = step;
    }
    feed(input) {
      return ColorChannelParser.parse(input, this.valueParser, this.step);
    }
    static parse(input, valueParser, step = 1) {
      if (step === 1) {
        if (valueParser === void 0) {
          valueParser = codec.Base10.parseNumber(input);
        } else {
          valueParser = valueParser.feed(input);
        }
        if (valueParser.isDone()) {
          step = 2;
        } else if (valueParser.isError()) {
          return valueParser.asError();
        }
      }
      if (step === 2) {
        if (input.isCont() && input.head() === 37) {
          input = input.step();
          return codec.Parser.done(new ColorChannel(valueParser.bind(), "%"));
        } else if (!input.isEmpty()) {
          return codec.Parser.done(new ColorChannel(valueParser.bind()));
        }
      }
      return new ColorChannelParser(valueParser, step);
    }
  }
  class RgbColor extends Color {
    constructor(r, g, b, a = 1) {
      super();
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
      this.stringValue = void 0;
    }
    isDefined() {
      return isFinite(this.r) && isFinite(this.g) && isFinite(this.b) && isFinite(this.a);
    }
    alpha(a) {
      if (a === void 0) {
        return this.a;
      } else if (this.a !== a) {
        return new RgbColor(this.r, this.g, this.b, a);
      } else {
        return this;
      }
    }
    get lightness() {
      const r = this.r / 255;
      const g = this.g / 255;
      const b = this.b / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      return (max + min) / 2;
    }
    plus(that) {
      that = Color.fromAny(that).rgb();
      return new RgbColor(this.r + that.r, this.g + that.g, this.b + that.b, this.a + that.a);
    }
    times(scalar) {
      return new RgbColor(this.r * scalar, this.g * scalar, this.b * scalar, this.a * scalar);
    }
    combine(that, scalar = 1) {
      that = Color.fromAny(that).rgb();
      return new RgbColor(this.r + that.r * scalar, this.g + that.g * scalar, this.b + that.b * scalar, this.a + that.a * scalar);
    }
    lighter(k) {
      k = k === void 0 ? Color.Brighter : Math.pow(Color.Brighter, k);
      return k !== 1 ? new RgbColor(this.r * k, this.g * k, this.b * k, this.a) : this;
    }
    darker(k) {
      k = k === void 0 ? Color.Darker : Math.pow(Color.Darker, k);
      return k !== 1 ? new RgbColor(this.r * k, this.g * k, this.b * k, this.a) : this;
    }
    rgb() {
      return this;
    }
    hsl() {
      const r = this.r / 255;
      const g = this.g / 255;
      const b = this.b / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      let h = NaN;
      let s = max - min;
      const l = (max + min) / 2;
      if (s !== 0) {
        if (r === max) {
          h = (g - b) / s + +(g < b) * 6;
        } else if (g === max) {
          h = (b - r) / s + 2;
        } else {
          h = (r - g) / s + 4;
        }
        s /= l < .5 ? max + min : 2 - (max + min);
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new HslColor(h, s, l, this.a);
    }
    interpolateTo(that) {
      if (that instanceof RgbColor) {
        return RgbColorInterpolator(this, that);
      } else {
        return super.interpolateTo(that);
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof Color) {
        that = that.rgb();
        return util.Numbers.equivalent(this.r, that.r, epsilon) && util.Numbers.equivalent(this.g, that.g, epsilon) && util.Numbers.equivalent(this.b, that.b, epsilon) && util.Numbers.equivalent(this.a, that.a, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof RgbColor) {
        return this.r === that.r && this.g === that.g && this.b === that.b && this.a === that.a;
      }
      return false;
    }
    hashCode() {
      return util.Murmur3.mash(util.Murmur3.mix(util.Murmur3.mix(util.Murmur3.mix(util.Murmur3.mix(util.Constructors.hash(RgbColor), util.Numbers.hash(this.r)), util.Numbers.hash(this.g)), util.Numbers.hash(this.b)), util.Numbers.hash(this.a)));
    }
    debug(output) {
      output = output.write("Color").write(46).write("rgb").write(40).debug(this.r).write(", ").debug(this.g).write(", ").debug(this.b);
      if (this.a !== 1) {
        output = output.write(", ").debug(this.a);
      }
      output = output.write(41);
      return output;
    }
    toHexString() {
      const r = Math.min(Math.max(0, Math.round(this.r || 0)), 255);
      const g = Math.min(Math.max(0, Math.round(this.g || 0)), 255);
      const b = Math.min(Math.max(0, Math.round(this.b || 0)), 255);
      let s = "#";
      const base16Alphabet = codec.Base16.lowercase.alphabet;
      s += base16Alphabet.charAt(r >>> 4 & 15);
      s += base16Alphabet.charAt(r & 15);
      s += base16Alphabet.charAt(g >>> 4 & 15);
      s += base16Alphabet.charAt(g & 15);
      s += base16Alphabet.charAt(b >>> 4 & 15);
      s += base16Alphabet.charAt(b & 15);
      return s;
    }
    toRgbString() {
      let a = this.a;
      a = isNaN(a) ? 1 : Math.max(0, Math.min(this.a, 1));
      let s = a === 1 ? "rgb" : "rgba";
      s += "(";
      s += Math.max(0, Math.min(Math.round(this.r) || 0, 255));
      s += ",";
      s += Math.max(0, Math.min(Math.round(this.g) || 0, 255));
      s += ",";
      s += Math.max(0, Math.min(Math.round(this.b) || 0, 255));
      if (a !== 1) {
        s += ",";
        s += a;
      }
      s += ")";
      return s;
    }
    toHslString() {
      return this.hsl().toHslString();
    }
    toString() {
      let s = this.stringValue;
      if (s === void 0) {
        let a = this.a;
        a = isNaN(a) ? 1 : Math.max(0, Math.min(this.a, 1));
        if (a === 1) {
          s = this.toHexString();
        } else {
          s = this.toRgbString();
        }
        this.stringValue = s;
      }
      return s;
    }
    static transparent() {
      return new RgbColor(0, 0, 0, 0);
    }
    static black(alpha = 1) {
      return new RgbColor(0, 0, 0, alpha);
    }
    static white(alpha = 1) {
      return new RgbColor(255, 255, 255, alpha);
    }
    static fromInit(value) {
      return new RgbColor(value.r, value.g, value.b, value.a);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof RgbColor) {
        return value;
      } else if (typeof value === "string") {
        return RgbColor.parse(value);
      } else if (RgbColor.isInit(value)) {
        return RgbColor.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static fromValue(value) {
      const tag = value.tag;
      let positional;
      if (tag === "rgb" || tag === "rgba") {
        value = value.header(tag);
        positional = true;
      } else {
        positional = false;
      }
      let r;
      let g;
      let b;
      let a;
      value.forEach((function(member, index) {
        const key = member.key.stringValue();
        if (key !== void 0) {
          if (key === "r") {
            r = member.toValue().numberValue(r);
          } else if (key === "g") {
            g = member.toValue().numberValue(g);
          } else if (key === "b") {
            b = member.toValue().numberValue(b);
          } else if (key === "a") {
            a = member.toValue().numberValue(a);
          }
        } else if (member instanceof structure.Value && positional) {
          if (index === 0) {
            r = member.numberValue(r);
          } else if (index === 1) {
            g = member.numberValue(g);
          } else if (index === 2) {
            b = member.numberValue(b);
          } else if (index === 3) {
            a = member.numberValue(a);
          }
        }
      }));
      if (r !== void 0 && g !== void 0 && b !== void 0) {
        return new RgbColor(r, g, b, a);
      }
      return null;
    }
    static parse(str) {
      return Color.parse(str).rgb();
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return typeof init.r === "number" && typeof init.g === "number" && typeof init.b === "number" && (typeof init.a === "number" || typeof init.a === "undefined");
      }
      return false;
    }
    static isAny(value) {
      return value instanceof RgbColor || RgbColor.isInit(value) || typeof value === "string";
    }
  }
  __decorate([ util.Lazy ], RgbColor, "transparent", null);
  const RgbColorInterpolator = function(_super) {
    const RgbColorInterpolator = function(c0, c1) {
      const interpolator = function(u) {
        const c0 = interpolator[0];
        const c1 = interpolator[1];
        const r = c0.r + u * (c1.r - c0.r);
        const g = c0.g + u * (c1.g - c0.g);
        const b = c0.b + u * (c1.b - c0.b);
        const a = c0.a + u * (c1.a - c0.a);
        return new RgbColor(r, g, b, a);
      };
      Object.setPrototypeOf(interpolator, RgbColorInterpolator.prototype);
      interpolator[0] = c0;
      interpolator[1] = c1;
      return interpolator;
    };
    RgbColorInterpolator.prototype = Object.create(_super.prototype);
    RgbColorInterpolator.prototype.constructor = RgbColorInterpolator;
    return RgbColorInterpolator;
  }(util.Interpolator);
  class HexColorParser extends codec.Parser {
    constructor(value, step) {
      super();
      this.value = value;
      this.step = step;
    }
    feed(input) {
      return HexColorParser.parse(input, this.value, this.step);
    }
    static parse(input, value = 0, step = 1) {
      let c = 0;
      if (step === 1) {
        if (input.isCont() && input.head() === 35) {
          input = input.step();
          step = 2;
        } else if (!input.isEmpty()) {
          return codec.Parser.error(codec.Diagnostic.expected("#", input));
        }
      }
      if (step >= 2) {
        while (step <= 9 && input.isCont()) {
          c = input.head();
          if (codec.Base16.isDigit(c)) {
            input = input.step();
            value = value << 4 | codec.Base16.decodeDigit(c);
            step += 1;
          } else {
            break;
          }
        }
        if (!input.isEmpty()) {
          if (step === 5) {
            return codec.Parser.done(new RgbColor(value >> 8 & 15 | value >> 4 & 240, value >> 4 & 15 | value & 240, value << 4 & 240 | value & 15));
          } else if (step === 6) {
            return codec.Parser.done(new RgbColor(value >> 12 & 15 | value >> 8 & 240, value >> 8 & 15 | value >> 4 & 240, value >> 4 & 15 | value & 240, (value << 4 & 240 | value & 15) / 255));
          } else if (step === 8) {
            return codec.Parser.done(new RgbColor(value >> 16 & 255, value >> 8 & 255, value & 255));
          } else if (step === 10) {
            return codec.Parser.done(new RgbColor(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, (value & 255) / 255));
          } else {
            return codec.Parser.error(codec.Diagnostic.unexpected(input));
          }
        }
      }
      return new HexColorParser(value, step);
    }
  }
  class RgbColorParser extends codec.Parser {
    constructor(rParser, gParser, bParser, aParser, step) {
      super();
      this.rParser = rParser;
      this.gParser = gParser;
      this.bParser = bParser;
      this.aParser = aParser;
      this.step = step;
    }
    feed(input) {
      return RgbColorParser.parse(input, this.rParser, this.gParser, this.bParser, this.aParser, this.step);
    }
    static parse(input, rParser, gParser, bParser, aParser, step) {
      let c = 0;
      if (step === 1) {
        if (input.isCont() && input.head() === 114) {
          input = input.step();
          step = 2;
        } else if (!input.isEmpty()) {
          return codec.Parser.error(codec.Diagnostic.expected("r", input));
        }
      }
      if (step === 2) {
        if (input.isCont() && input.head() === 103) {
          input = input.step();
          step = 3;
        } else if (!input.isEmpty()) {
          return codec.Parser.error(codec.Diagnostic.expected("g", input));
        }
      }
      if (step === 3) {
        if (input.isCont() && input.head() === 98) {
          input = input.step();
          step = 4;
        } else if (!input.isEmpty()) {
          return codec.Parser.error(codec.Diagnostic.expected("b", input));
        }
      }
      if (step === 4) {
        if (input.isCont() && input.head() === 97) {
          input = input.step();
          step = 5;
        } else if (!input.isEmpty()) {
          step = 5;
        }
      }
      if (step === 5) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont() && c === 40) {
          input = input.step();
          step = 6;
        } else if (!input.isEmpty()) {
          return codec.Parser.error(codec.Diagnostic.expected("(", input));
        }
      }
      if (step === 6) {
        if (rParser === void 0) {
          while (input.isCont() && codec.Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            rParser = ColorChannelParser.parse(input);
          }
        } else {
          rParser = rParser.feed(input);
        }
        if (rParser !== void 0) {
          if (rParser.isDone()) {
            step = 7;
          } else if (rParser.isError()) {
            return rParser.asError();
          }
        }
      }
      if (step === 7) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 8;
        } else if (input.isDone()) {
          return codec.Parser.error(codec.Diagnostic.unexpected(input));
        }
      }
      if (step === 8) {
        if (gParser === void 0) {
          while (input.isCont() && codec.Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            gParser = ColorChannelParser.parse(input);
          }
        } else {
          gParser = gParser.feed(input);
        }
        if (gParser !== void 0) {
          if (gParser.isDone()) {
            step = 9;
          } else if (gParser.isError()) {
            return gParser.asError();
          }
        }
      }
      if (step === 9) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 10;
        } else if (input.isDone()) {
          return codec.Parser.error(codec.Diagnostic.unexpected(input));
        }
      }
      if (step === 10) {
        if (bParser === void 0) {
          while (input.isCont() && codec.Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            bParser = ColorChannelParser.parse(input);
          }
        } else {
          bParser = bParser.feed(input);
        }
        if (bParser !== void 0) {
          if (bParser.isDone()) {
            step = 11;
          } else if (bParser.isError()) {
            return bParser.asError();
          }
        }
      }
      if (step === 11) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 41) {
            input = input.step();
            return codec.Parser.done(new RgbColor(rParser.bind().scale(255), gParser.bind().scale(255), bParser.bind().scale(255)));
          } else if (c === 44 || c === 47) {
            input = input.step();
          }
          step = 12;
        } else if (input.isDone()) {
          return codec.Parser.error(codec.Diagnostic.unexpected(input));
        }
      }
      if (step === 12) {
        if (aParser === void 0) {
          while (input.isCont() && codec.Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            aParser = ColorChannelParser.parse(input);
          }
        } else {
          aParser = aParser.feed(input);
        }
        if (aParser !== void 0) {
          if (aParser.isDone()) {
            step = 13;
          } else if (aParser.isError()) {
            return aParser.asError();
          }
        }
      }
      if (step === 13) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont() && c === 41) {
          input = input.step();
          return codec.Parser.done(new RgbColor(rParser.bind().scale(255), gParser.bind().scale(255), bParser.bind().scale(255), aParser.bind().scale(1)));
        } else if (!input.isEmpty()) {
          return codec.Parser.error(codec.Diagnostic.expected(")", input));
        }
      }
      return new RgbColorParser(rParser, gParser, bParser, aParser, step);
    }
    static parseRest(input) {
      return RgbColorParser.parse(input, void 0, void 0, void 0, void 0, 5);
    }
  }
  class HslColor extends Color {
    constructor(h, s, l, a = 1) {
      super();
      this.h = h;
      this.s = s;
      this.l = l;
      this.a = a;
      this.stringValue = void 0;
    }
    isDefined() {
      return isFinite(this.h) && isFinite(this.s) && isFinite(this.l) && isFinite(this.a);
    }
    alpha(a) {
      if (a === void 0) {
        return this.a;
      } else if (this.a !== a) {
        return new HslColor(this.h, this.s, this.l, a);
      } else {
        return this;
      }
    }
    get lightness() {
      return this.l;
    }
    plus(that) {
      that = Color.fromAny(that).hsl();
      return new HslColor(this.h + that.h, this.s + that.s, this.l + that.l, this.a + that.a);
    }
    times(scalar) {
      return new HslColor(this.h * scalar, this.s * scalar, this.l * scalar, this.a * scalar);
    }
    combine(that, scalar = 1) {
      that = Color.fromAny(that).hsl();
      return new HslColor(this.h + that.h * scalar, this.s + that.s * scalar, this.l + that.l * scalar, this.a + that.a * scalar);
    }
    lighter(k) {
      k = k === void 0 ? Color.Brighter : Math.pow(Color.Brighter, k);
      return k !== 1 ? new HslColor(this.h, this.s, this.l * k, this.a) : this;
    }
    darker(k) {
      k = k === void 0 ? Color.Darker : Math.pow(Color.Darker, k);
      return k !== 1 ? new HslColor(this.h, this.s, this.l * k, this.a) : this;
    }
    static toRgb(h, m1, m2) {
      return 255 * (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1);
    }
    rgb() {
      const h = this.h % 360 + +(this.h < 0) * 360;
      const s = isNaN(h) || isNaN(this.s) ? 0 : this.s;
      const l = this.l;
      const m2 = l + (l < .5 ? l : 1 - l) * s;
      const m1 = 2 * l - m2;
      return new RgbColor(HslColor.toRgb(h >= 240 ? h - 240 : h + 120, m1, m2), HslColor.toRgb(h, m1, m2), HslColor.toRgb(h < 120 ? h + 240 : h - 120, m1, m2), this.a);
    }
    hsl() {
      return this;
    }
    interpolateTo(that) {
      if (that instanceof HslColor) {
        return HslColorInterpolator(this, that);
      } else {
        return super.interpolateTo(that);
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof Color) {
        that = that.hsl();
        return util.Numbers.equivalent(this.h, that.h, epsilon) && util.Numbers.equivalent(this.s, that.s, epsilon) && util.Numbers.equivalent(this.l, that.l, epsilon) && util.Numbers.equivalent(this.a, that.a, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof HslColor) {
        return this.h === that.h && this.s === that.s && this.l === that.l && this.a === that.a;
      }
      return false;
    }
    hashCode() {
      return util.Murmur3.mash(util.Murmur3.mix(util.Murmur3.mix(util.Murmur3.mix(util.Murmur3.mix(util.Constructors.hash(HslColor), util.Numbers.hash(this.h)), util.Numbers.hash(this.s)), util.Numbers.hash(this.l)), util.Numbers.hash(this.a)));
    }
    debug(output) {
      output = output.write("Color").write(46).write("hsl").write(40).debug(this.h).write(", ").debug(this.s).write(", ").debug(this.l);
      if (this.a !== 1) {
        output = output.write(", ").debug(this.a);
      }
      output = output.write(41);
      return output;
    }
    toHexString() {
      return this.rgb().toHexString();
    }
    toRgbString() {
      return this.rgb().toRgbString();
    }
    toHslString() {
      let a = this.a;
      a = isNaN(a) ? 1 : Math.max(0, Math.min(this.a, 1));
      let s = a === 1 ? "hsl" : "hsla";
      s += "(";
      s += Math.max(0, Math.min(Math.round(this.h) || 0, 360));
      s += ",";
      s += Math.max(0, Math.min(100 * Math.round(this.s) || 0, 100)) + "%";
      s += ",";
      s += Math.max(0, Math.min(100 * Math.round(this.l) || 0, 100)) + "%";
      if (a !== 1) {
        s += ",";
        s += a;
      }
      s += ")";
      return s;
    }
    toString() {
      let s = this.stringValue;
      if (s === void 0) {
        s = this.toHslString();
        this.stringValue = s;
      }
      return s;
    }
    static transparent() {
      return new HslColor(0, 0, 0, 0);
    }
    static black(alpha = 1) {
      return new HslColor(0, 0, 0, alpha);
    }
    static white(alpha = 1) {
      return new HslColor(0, 1, 1, alpha);
    }
    static fromInit(value) {
      const h = typeof value.h === "number" ? value.h : math.Angle.fromAny(value.h).degValue();
      return new HslColor(h, value.s, value.l, value.a);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof HslColor) {
        return value;
      } else if (typeof value === "string") {
        return HslColor.parse(value);
      } else if (HslColor.isInit(value)) {
        return HslColor.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static fromValue(value) {
      const tag = value.tag;
      let positional;
      if (tag === "hsl" || tag === "hsla") {
        value = value.header(tag);
        positional = true;
      } else {
        positional = false;
      }
      let h;
      let s;
      let l;
      let a;
      value.forEach((function(member, index) {
        const key = member.key.stringValue();
        if (key !== void 0) {
          if (key === "h") {
            h = member.toValue().cast(math.Angle.form(), h);
          } else if (key === "s") {
            s = member.toValue().numberValue(s);
          } else if (key === "l") {
            l = member.toValue().numberValue(l);
          } else if (key === "a") {
            a = member.toValue().numberValue(a);
          }
        } else if (member instanceof structure.Value && positional) {
          if (index === 0) {
            h = member.cast(math.Angle.form(), h);
          } else if (index === 1) {
            s = member.numberValue(s);
          } else if (index === 2) {
            l = member.numberValue(l);
          } else if (index === 3) {
            a = member.numberValue(a);
          }
        }
      }));
      if (h !== void 0 && s !== void 0 && l !== void 0) {
        return new HslColor(h.degValue(), s, l, a);
      }
      return null;
    }
    static parse(str) {
      return Color.parse(str).hsl();
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return math.Angle.isAny(init.h) && typeof init.s === "number" && typeof init.l === "number" && (typeof init.a === "number" || typeof init.a === "undefined");
      }
      return false;
    }
    static isAny(value) {
      return value instanceof HslColor || HslColor.isInit(value) || typeof value === "string";
    }
  }
  __decorate([ util.Lazy ], HslColor, "transparent", null);
  const HslColorInterpolator = function(_super) {
    const HslColorInterpolator = function(c0, c1) {
      const interpolator = function(u) {
        const c0 = interpolator[0];
        const c1 = interpolator[1];
        const h = c0.h + u * (c1.h - c0.h);
        const s = c0.s + u * (c1.s - c0.s);
        const l = c0.l + u * (c1.l - c0.l);
        const a = c0.a + u * (c1.a - c0.a);
        return new HslColor(h, s, l, a);
      };
      Object.setPrototypeOf(interpolator, HslColorInterpolator.prototype);
      interpolator[0] = c0;
      interpolator[1] = c1;
      return interpolator;
    };
    HslColorInterpolator.prototype = Object.create(_super.prototype);
    HslColorInterpolator.prototype.constructor = HslColorInterpolator;
    return HslColorInterpolator;
  }(util.Interpolator);
  class HslColorParser extends codec.Parser {
    constructor(hParser, sParser, lParser, aParser, step) {
      super();
      this.hParser = hParser;
      this.sParser = sParser;
      this.lParser = lParser;
      this.aParser = aParser;
      this.step = step;
    }
    feed(input) {
      return HslColorParser.parse(input, this.hParser, this.sParser, this.lParser, this.aParser, this.step);
    }
    static parse(input, hParser, sParser, lParser, aParser, step) {
      let c = 0;
      if (step === 1) {
        if (input.isCont() && input.head() === 104) {
          input = input.step();
          step = 2;
        } else if (!input.isEmpty()) {
          return codec.Parser.error(codec.Diagnostic.expected("h", input));
        }
      }
      if (step === 2) {
        if (input.isCont() && input.head() === 115) {
          input = input.step();
          step = 3;
        } else if (!input.isEmpty()) {
          return codec.Parser.error(codec.Diagnostic.expected("s", input));
        }
      }
      if (step === 3) {
        if (input.isCont() && input.head() === 108) {
          input = input.step();
          step = 4;
        } else if (!input.isEmpty()) {
          return codec.Parser.error(codec.Diagnostic.expected("l", input));
        }
      }
      if (step === 4) {
        if (input.isCont() && input.head() === 97) {
          input = input.step();
          step = 5;
        } else if (!input.isEmpty()) {
          step = 5;
        }
      }
      if (step === 5) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont() && c === 40) {
          input = input.step();
          step = 6;
        } else if (!input.isEmpty()) {
          return codec.Parser.error(codec.Diagnostic.expected("(", input));
        }
      }
      if (step === 6) {
        if (hParser === void 0) {
          while (input.isCont() && codec.Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            hParser = math.AngleParser.parse(input, "deg");
          }
        } else {
          hParser = hParser.feed(input);
        }
        if (hParser !== void 0) {
          if (hParser.isDone()) {
            step = 7;
          } else if (hParser.isError()) {
            return hParser.asError();
          }
        }
      }
      if (step === 7) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 8;
        } else if (input.isDone()) {
          return codec.Parser.error(codec.Diagnostic.unexpected(input));
        }
      }
      if (step === 8) {
        if (sParser === void 0) {
          while (input.isCont() && codec.Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            sParser = ColorChannelParser.parse(input);
          }
        } else {
          sParser = sParser.feed(input);
        }
        if (sParser !== void 0) {
          if (sParser.isDone()) {
            if (sParser.bind().units === "%") {
              step = 9;
            } else {
              return codec.Parser.error(codec.Diagnostic.expected("%", input));
            }
          } else if (sParser.isError()) {
            return sParser.asError();
          }
        }
      }
      if (step === 9) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 10;
        } else if (input.isDone()) {
          return codec.Parser.error(codec.Diagnostic.unexpected(input));
        }
      }
      if (step === 10) {
        if (lParser === void 0) {
          while (input.isCont() && codec.Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (input.isCont()) {
            lParser = ColorChannelParser.parse(input);
          }
        } else {
          lParser = lParser.feed(input);
        }
        if (lParser !== void 0) {
          if (lParser.isDone()) {
            if (lParser.bind().units === "%") {
              step = 11;
            } else {
              return codec.Parser.error(codec.Diagnostic.expected("%", input));
            }
          } else if (lParser.isError()) {
            return lParser.asError();
          }
        }
      }
      if (step === 11) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 41) {
            input = input.step();
            return codec.Parser.done(new HslColor(hParser.bind().degValue(), sParser.bind().scale(1), lParser.bind().scale(1)));
          } else if (c === 44 || c === 47) {
            input = input.step();
          }
          step = 12;
        } else if (input.isDone()) {
          return codec.Parser.error(codec.Diagnostic.unexpected(input));
        }
      }
      if (step === 12) {
        if (aParser === void 0) {
          while (input.isCont() && codec.Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            aParser = ColorChannelParser.parse(input);
          }
        } else {
          aParser = aParser.feed(input);
        }
        if (aParser !== void 0) {
          if (aParser.isDone()) {
            step = 13;
          } else if (aParser.isError()) {
            return aParser.asError();
          }
        }
      }
      if (step === 13) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont() && c === 41) {
          input = input.step();
          return codec.Parser.done(new HslColor(hParser.bind().degValue(), sParser.bind().scale(1), lParser.bind().scale(1), aParser.bind().scale(1)));
        } else if (!input.isEmpty()) {
          return codec.Parser.error(codec.Diagnostic.expected(")", input));
        }
      }
      return new HslColorParser(hParser, sParser, lParser, aParser, step);
    }
    static parseRest(input) {
      return HslColorParser.parse(input, void 0, void 0, void 0, void 0, 5);
    }
  }
  class ColorStop {
    constructor(color, stop, hint) {
      this.color = color;
      this.stop = stop;
      this.hint = hint;
    }
    withColor(color) {
      color = Color.fromAny(color);
      return new ColorStop(color, this.stop, this.hint);
    }
    withStop(stop) {
      if (stop !== null) {
        stop = math.Length.fromAny(stop, "%");
      }
      return new ColorStop(this.color, stop, this.hint);
    }
    withHint(hint) {
      if (hint !== null) {
        hint = math.Length.fromAny(hint, "%");
      }
      return new ColorStop(this.color, this.stop, hint);
    }
    interpolateTo(that) {
      if (that instanceof ColorStop) {
        return ColorStopInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof ColorStop) {
        return util.Equivalent(this.color, that.color, epsilon) && util.Equivalent(this.stop, that.stop, epsilon) && util.Equivalent(this.hint, that.hint, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof ColorStop) {
        return this.color.equals(that.color) && util.Equals(this.stop, that.stop) && util.Equals(this.hint, that.hint);
      }
      return false;
    }
    toString() {
      let s = "";
      if (this.hint !== null) {
        s += this.hint.toString();
        s += ", ";
      }
      s += this.color.toString();
      if (this.stop !== null) {
        s += " ";
        s += this.stop.toString();
      }
      return s;
    }
    static create(color, stop = null, hint = null) {
      color = Color.fromAny(color);
      if (stop !== null) {
        stop = math.Length.fromAny(stop, "%");
      }
      if (hint !== null) {
        hint = math.Length.fromAny(hint, "%");
      }
      return new ColorStop(color, stop, hint);
    }
    static fromInit(init) {
      const color = Color.fromAny(init.color);
      const stop = init.stop !== void 0 ? math.Length.fromAny(init.stop, "%") : null;
      const hint = init.hint !== void 0 ? math.Length.fromAny(init.hint, "%") : null;
      return new ColorStop(color, stop, hint);
    }
    static fromTuple(value) {
      const color = Color.fromAny(value[0]);
      const stop = value[1] !== null ? math.Length.fromAny(value[1], "%") : null;
      return new ColorStop(color, stop, null);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof ColorStop) {
        return value;
      } else if (typeof value === "string") {
        return ColorStop.parse(value);
      } else if (ColorStop.isInit(value)) {
        return ColorStop.fromInit(value);
      } else if (ColorStop.isTuple(value)) {
        return ColorStop.fromTuple(value);
      }
      throw new TypeError("" + value);
    }
    static parse(string) {
      let input = codec.Unicode.stringInput(string);
      while (input.isCont() && codec.Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = ColorStopParser.parse(input);
      if (parser.isDone()) {
        while (input.isCont() && codec.Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = codec.Parser.error(codec.Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    static parseHint(string) {
      let input = codec.Unicode.stringInput(string);
      while (input.isCont() && codec.Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = ColorStopParser.parseHint(input);
      if (parser.isDone()) {
        while (input.isCont() && codec.Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = codec.Parser.error(codec.Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    static parseList(string) {
      let input = codec.Unicode.stringInput(string);
      while (input.isCont() && codec.Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = ColorStopListParser.parse(input);
      if (parser.isDone()) {
        while (input.isCont() && codec.Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = codec.Parser.error(codec.Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return init.color !== void 0;
      }
      return false;
    }
    static isTuple(value) {
      return Array.isArray(value) && value.length === 2 && Color.isAny(value[0]) && (value[1] === null || math.Length.isAny(value[1]));
    }
    static isAny(value) {
      return value instanceof ColorStop || ColorStop.isInit(value) || ColorStop.isTuple(value) || typeof value === "string";
    }
  }
  const ColorStopInterpolator = function(_super) {
    const ColorStopInterpolator = function(y0, y1) {
      const interpolator = function(u) {
        const color = interpolator.colorInterpolator(u);
        const stop = interpolator.stopInterpolator(u);
        const hint = interpolator.hintInterpolator(u);
        return new ColorStop(color, stop, hint);
      };
      Object.setPrototypeOf(interpolator, ColorStopInterpolator.prototype);
      interpolator.colorInterpolator = y0.color.interpolateTo(y1.color);
      interpolator.stopInterpolator = util.Interpolator(y0.stop, y1.stop);
      interpolator.hintInterpolator = util.Interpolator(y0.hint, y1.hint);
      return interpolator;
    };
    ColorStopInterpolator.prototype = Object.create(_super.prototype);
    ColorStopInterpolator.prototype.constructor = ColorStopInterpolator;
    Object.defineProperty(ColorStopInterpolator.prototype, 0, {
      get() {
        const color = this.colorInterpolator[0];
        const stop = this.stopInterpolator[0];
        const hint = this.hintInterpolator[0];
        return new ColorStop(color, stop, hint);
      },
      configurable: true
    });
    Object.defineProperty(ColorStopInterpolator.prototype, 1, {
      get() {
        const color = this.colorInterpolator[1];
        const stop = this.stopInterpolator[1];
        const hint = this.hintInterpolator[1];
        return new ColorStop(color, stop, hint);
      },
      configurable: true
    });
    ColorStopInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof ColorStopInterpolator) {
        return this.colorInterpolator.equals(that.colorInterpolator) && this.stopInterpolator.equals(that.stopInterpolator) && this.hintInterpolator.equals(that.hintInterpolator);
      }
      return false;
    };
    return ColorStopInterpolator;
  }(util.Interpolator);
  class ColorStopParser extends codec.Parser {
    constructor(colorParser, stopParser, hintParser, step) {
      super();
      this.colorParser = colorParser;
      this.stopParser = stopParser;
      this.hintParser = hintParser;
      this.step = step;
    }
    feed(input) {
      return ColorStopParser.parse(input, this.colorParser, this.stopParser, this.hintParser, this.step);
    }
    static parse(input, colorParser, stopParser, hintParser, step = 4) {
      let c = 0;
      if (step === 1) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
          input.step();
        }
        if (input.isCont()) {
          if (c === 45 || c === 46 || c >= 48 && c <= 57) {
            step = 2;
          } else {
            step = 7;
          }
        } else if (!input.isEmpty()) {
          return codec.Parser.error(codec.Diagnostic.unexpected(input));
        }
      }
      if (step === 2) {
        if (hintParser === void 0) {
          hintParser = math.LengthParser.parse(input);
        } else {
          hintParser = hintParser.feed(input);
        }
        if (hintParser !== void 0) {
          if (hintParser.isDone()) {
            step = 3;
          } else if (hintParser.isError()) {
            return hintParser.asError();
          }
        }
      }
      if (step === 3) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
          input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input.step();
            step = 4;
          } else {
            stopParser = hintParser;
            hintParser = void 0;
            step = 7;
          }
        } else if (input.isDone()) {
          return codec.Parser.error(codec.Diagnostic.unexpected(input));
        }
      }
      if (step === 4) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
          input.step();
        }
        if (input.isCont()) {
          if (c === 45 || c === 46 || c >= 48 && c <= 57) {
            step = 5;
          } else {
            step = 7;
          }
        } else if (!input.isEmpty()) {
          return codec.Parser.error(codec.Diagnostic.unexpected(input));
        }
      }
      if (step === 5) {
        if (stopParser === void 0) {
          stopParser = math.LengthParser.parse(input);
        } else {
          stopParser = stopParser.feed(input);
        }
        if (stopParser !== void 0) {
          if (stopParser.isDone()) {
            step = 6;
          } else if (stopParser.isError()) {
            return stopParser.asError();
          }
        }
      }
      if (step === 6) {
        if (input.isCont()) {
          if (codec.Unicode.isSpace(input.head())) {
            input.step();
            step = 7;
          } else {
            return codec.Parser.error(codec.Diagnostic.expected("color", input));
          }
        } else if (input.isDone()) {
          return codec.Parser.error(codec.Diagnostic.unexpected(input));
        }
      }
      if (step === 7) {
        if (colorParser === void 0) {
          colorParser = ColorParser.parse(input);
        } else {
          colorParser = colorParser.feed(input);
        }
        if (colorParser !== void 0) {
          if (colorParser.isDone()) {
            if (stopParser !== void 0) {
              const hint = hintParser !== void 0 ? hintParser.bind() : null;
              return codec.Parser.done(new ColorStop(colorParser.bind(), stopParser.bind(), hint));
            } else {
              step = 8;
            }
          } else if (colorParser.isError()) {
            return colorParser.asError();
          }
        }
      }
      if (step === 8) {
        if (input.isCont() && codec.Unicode.isSpace(input.head())) {
          input.step();
          step = 9;
        } else if (!input.isEmpty()) {
          const hint = hintParser !== void 0 ? hintParser.bind() : null;
          return codec.Parser.done(new ColorStop(colorParser.bind(), null, hint));
        }
      }
      if (step === 9) {
        if (stopParser === void 0) {
          stopParser = math.LengthParser.parse(input);
        } else {
          stopParser = stopParser.feed(input);
        }
        if (stopParser !== void 0) {
          if (stopParser.isDone()) {
            const hint = hintParser !== void 0 ? hintParser.bind() : null;
            return codec.Parser.done(new ColorStop(colorParser.bind(), stopParser.bind(), hint));
          } else if (stopParser.isError()) {
            return stopParser.asError();
          }
        }
      }
      return new ColorStopParser(colorParser, stopParser, hintParser, step);
    }
    static parseHint(input) {
      return ColorStopParser.parse(input, void 0, void 0, void 0, 1);
    }
  }
  class ColorStopListParser extends codec.Parser {
    constructor(stops, stopParser, step) {
      super();
      this.stops = stops;
      this.stopParser = stopParser;
      this.step = step;
    }
    feed(input) {
      return ColorStopListParser.parse(input, this.stops !== void 0 ? this.stops.slice(0) : void 0, this.stopParser, this.step);
    }
    static parse(input, stops, stopParser, step = 1) {
      let c = 0;
      if (step === 1) {
        if (stopParser === void 0) {
          while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
            input.step();
          }
          if (!input.isEmpty()) {
            stopParser = ColorStopParser.parse(input);
          }
        } else {
          stopParser = stopParser.feed(input);
        }
        if (stopParser !== void 0) {
          if (stopParser.isDone()) {
            if (stops === void 0) {
              stops = [];
            }
            stops.push(stopParser.bind());
            stopParser = void 0;
            step = 2;
          } else if (stopParser.isError()) {
            return stopParser.asError();
          }
        }
      }
      do {
        if (step === 2) {
          while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
            input = input.step();
          }
          if (input.isCont() && c === 44) {
            input = input.step();
            step = 3;
          } else {
            return codec.Parser.done(stops);
          }
        }
        if (step === 3) {
          if (stopParser === void 0) {
            while (input.isCont() && codec.Unicode.isSpace(input.head())) {
              input.step();
            }
            if (!input.isEmpty()) {
              stopParser = ColorStopParser.parseHint(input);
            }
          } else {
            stopParser = stopParser.feed(input);
          }
          if (stopParser !== void 0) {
            if (stopParser.isDone()) {
              stops.push(stopParser.bind());
              stopParser = void 0;
              step = 2;
              continue;
            } else if (stopParser.isError()) {
              return stopParser.asError();
            }
          }
        }
        break;
      } while (true);
      return new ColorStopListParser(stops, stopParser, step);
    }
  }
  class LinearGradient {
    constructor(angle, stops) {
      this.angle = angle;
      this.stops = stops;
      this.stringValue = void 0;
    }
    withAngle(angle) {
      if (angle instanceof math.Angle || typeof angle === "number") {
        angle = math.Angle.fromAny(angle, "deg");
      }
      return new LinearGradient(angle, this.stops);
    }
    withStops(stops) {
      const n = stops.length;
      const array = new Array(n);
      for (let i = 0; i < n; i += 1) {
        array[i] = ColorStop.fromAny(stops[i]);
      }
      return new LinearGradient(this.angle, array);
    }
    interpolateTo(that) {
      if (that instanceof LinearGradient) {
        return LinearGradientInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof LinearGradient) {
        return util.Values.equivalent(this.angle, that.angle, epsilon) && util.Arrays.equivalent(this.stops, that.stops, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof LinearGradient) {
        return util.Values.equal(this.angle, that.angle) && util.Arrays.equal(this.stops, that.stops);
      }
      return false;
    }
    toString() {
      let s = this.stringValue;
      if (s === void 0) {
        s = "linear-gradient(";
        if (this.angle instanceof math.Angle) {
          s += this.angle.toString();
        } else {
          s += "to";
          if (typeof this.angle === "string") {
            s += " ";
            s += this.angle;
          } else {
            for (let i = 0, n = this.angle.length; i < n; i += 1) {
              s += " ";
              s += this.angle[i];
            }
          }
        }
        for (let i = 0, n = this.stops.length; i < n; i += 1) {
          s += ", ";
          s += this.stops[i].toString();
        }
        s += ")";
        this.stringValue = s;
      }
      return s;
    }
    static create(angle, ...stops) {
      if (angle instanceof math.Angle || typeof angle === "number") {
        angle = math.Angle.fromAny(angle, "deg");
      }
      const n = stops.length;
      const array = new Array(n);
      for (let i = 0; i < n; i += 1) {
        const stop = stops[i];
        if (typeof stop === "string") {
          if (i === 0) {
            array[i] = ColorStop.parse(stop);
          } else {
            array[i] = ColorStop.parseHint(stop);
          }
        } else {
          array[i] = ColorStop.fromAny(stops[i]);
        }
      }
      return new LinearGradient(angle, array);
    }
    static fromInit(init) {
      let angle = init.angle;
      if (angle instanceof math.Angle || typeof angle === "number") {
        angle = math.Angle.fromAny(angle, "deg");
      }
      const n = init.stops.length;
      const array = new Array(n);
      for (let i = 0; i < n; i += 1) {
        array[i] = ColorStop.fromAny(init.stops[i]);
      }
      return new LinearGradient(angle, array);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof LinearGradient) {
        return value;
      } else if (typeof value === "string") {
        return LinearGradient.parse(value);
      } else if (typeof value === "object" && value !== null) {
        return LinearGradient.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static parse(string) {
      let input = codec.Unicode.stringInput(string);
      while (input.isCont() && codec.Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = LinearGradientParser.parse(input);
      if (parser.isDone()) {
        while (input.isCont() && codec.Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = codec.Parser.error(codec.Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    static parseAngle(string) {
      let input = codec.Unicode.stringInput(string);
      while (input.isCont() && codec.Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = LinearGradientAngleParser.parse(input);
      if (parser.isDone()) {
        while (input.isCont() && codec.Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = codec.Parser.error(codec.Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return init.angle !== void 0 && init.stops !== void 0;
      }
      return false;
    }
    static isAny(value) {
      return value instanceof LinearGradient || LinearGradient.isInit(value) || typeof value === "string";
    }
  }
  const LinearGradientInterpolator = function(_super) {
    const LinearGradientInterpolator = function(g0, g1) {
      const interpolator = function(u) {
        const angle = interpolator.angleInterpolator(u);
        const stopInterpolators = interpolator.stopInterpolators;
        const stopCount = stopInterpolators.length;
        const stops = new Array(stopCount);
        for (let i = 0; i < stopCount; i += 1) {
          stops[i] = stopInterpolators[i](u);
        }
        return new LinearGradient(angle, stops);
      };
      Object.setPrototypeOf(interpolator, LinearGradientInterpolator.prototype);
      interpolator.angleInterpolator = util.Interpolator(g0.angle, g1.angle);
      const stops0 = g0.stops;
      const stops1 = g1.stops;
      const stopCount = Math.min(stops0.length, stops1.length);
      const stopInterpolators = new Array(stopCount);
      for (let i = 0; i < stopCount; i += 1) {
        stopInterpolators[i] = stops0[i].interpolateTo(stops1[i]);
      }
      interpolator.stopInterpolators = stopInterpolators;
      return interpolator;
    };
    LinearGradientInterpolator.prototype = Object.create(_super.prototype);
    LinearGradientInterpolator.prototype.constructor = LinearGradientInterpolator;
    Object.defineProperty(LinearGradientInterpolator.prototype, 0, {
      get() {
        const angle = this.angleInterpolator[0];
        const stopInterpolators = this.stopInterpolators;
        const stopCount = stopInterpolators.length;
        const stops = new Array(stopCount);
        for (let i = 0; i < stopCount; i += 1) {
          stops[i] = stopInterpolators[i][0];
        }
        return new LinearGradient(angle, stops);
      },
      configurable: true
    });
    Object.defineProperty(LinearGradientInterpolator.prototype, 1, {
      get() {
        const angle = this.angleInterpolator[1];
        const stopInterpolators = this.stopInterpolators;
        const stopCount = stopInterpolators.length;
        const stops = new Array(stopCount);
        for (let i = 0; i < stopCount; i += 1) {
          stops[i] = stopInterpolators[i][1];
        }
        return new LinearGradient(angle, stops);
      },
      configurable: true
    });
    LinearGradientInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof LinearGradientInterpolator) {
        if (this.angleInterpolator.equals(that.angleInterpolator)) {
          const n = this.stopInterpolators.length;
          if (n === that.stopInterpolators.length) {
            for (let i = 0; i < n; i += 1) {
              if (!this.stopInterpolators[i].equals(that.stopInterpolators[i])) {
                return false;
              }
            }
            return true;
          }
        }
      }
      return false;
    };
    return LinearGradientInterpolator;
  }(util.Interpolator);
  class LinearGradientAngleParser extends codec.Parser {
    constructor(identOutput, angleParser, side, step) {
      super();
      this.identOutput = identOutput;
      this.angleParser = angleParser;
      this.side = side;
      this.step = step;
    }
    feed(input) {
      return LinearGradientAngleParser.parse(input, this.identOutput, this.angleParser, this.side, this.step);
    }
    static parse(input, identOutput, angleParser, side, step = 1) {
      let c = 0;
      if (step === 1) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
          input.step();
        }
        if (input.isCont()) {
          if (c === 45 || c === 46 || c >= 48 && c <= 57) {
            step = 2;
          } else {
            step = 3;
          }
        } else if (!input.isEmpty()) {
          return codec.Parser.error(codec.Diagnostic.unexpected(input));
        }
      }
      if (step === 2) {
        if (angleParser === void 0) {
          angleParser = math.AngleParser.parse(input, "deg");
        } else {
          angleParser = angleParser.feed(input);
        }
        if (angleParser !== void 0) {
          if (angleParser.isDone()) {
            return angleParser;
          } else if (angleParser.isError()) {
            return angleParser.asError();
          }
        }
      }
      if (step === 3) {
        if (identOutput === void 0) {
          identOutput = codec.Unicode.stringOutput();
        }
        while (input.isCont() && (c = input.head(), codec.Unicode.isAlpha(c))) {
          input = input.step();
          identOutput.write(c);
        }
        if (!input.isEmpty()) {
          const ident = identOutput.bind();
          if (ident === "to") {
            identOutput = void 0;
            step = 4;
          } else {
            return codec.Parser.error(codec.Diagnostic.message("unexpected " + ident, input));
          }
        }
      }
      if (step === 4) {
        if (input.isCont()) {
          if (codec.Unicode.isSpace(input.head())) {
            input.step();
            step = 5;
          } else {
            return codec.Parser.error(codec.Diagnostic.expected("side or corner", input));
          }
        } else if (input.isDone()) {
          return codec.Parser.error(codec.Diagnostic.unexpected(input));
        }
      }
      if (step === 5) {
        if (identOutput === void 0) {
          identOutput = codec.Unicode.stringOutput();
        }
        while (input.isCont() && (c = input.head(), codec.Unicode.isAlpha(c))) {
          input = input.step();
          identOutput.write(c);
        }
        if (!input.isEmpty()) {
          const ident = identOutput.bind();
          identOutput = void 0;
          switch (ident) {
           case "left":
           case "right":
            side = ident;
            step = 6;
            break;

           case "top":
           case "bottom":
            side = ident;
            step = 7;
            break;

           default:
            return codec.Parser.error(codec.Diagnostic.message("unknown side: " + ident, input));
          }
        }
      }
      if (step === 6) {
        if (identOutput === void 0) {
          while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
            input = input.step();
          }
          if (input.isCont() && codec.Unicode.isAlpha(c)) {
            identOutput = codec.Unicode.stringOutput();
          } else if (!input.isEmpty()) {
            return codec.Parser.done(side);
          }
        }
        if (identOutput !== void 0) {
          while (input.isCont() && (c = input.head(), codec.Unicode.isAlpha(c))) {
            input = input.step();
            identOutput.write(c);
          }
          if (!input.isEmpty()) {
            const ident = identOutput.bind();
            identOutput = void 0;
            switch (ident) {
             case "top":
             case "bottom":
              return codec.Parser.done([ side, ident ]);

             default:
              return codec.Parser.error(codec.Diagnostic.message("unknown side: " + ident, input));
            }
          }
        }
      }
      if (step === 7) {
        if (identOutput === void 0) {
          while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
            input = input.step();
          }
          if (input.isCont() && codec.Unicode.isAlpha(c)) {
            identOutput = codec.Unicode.stringOutput();
          } else if (!input.isEmpty()) {
            return codec.Parser.done(side);
          }
        }
        if (identOutput !== void 0) {
          while (input.isCont() && (c = input.head(), codec.Unicode.isAlpha(c))) {
            input = input.step();
            identOutput.write(c);
          }
          if (!input.isEmpty()) {
            const ident = identOutput.bind();
            identOutput = void 0;
            switch (ident) {
             case "left":
             case "right":
              return codec.Parser.done([ side, ident ]);

             default:
              return codec.Parser.error(codec.Diagnostic.message("unknown side: " + ident, input));
            }
          }
        }
      }
      return new LinearGradientAngleParser(identOutput, angleParser, side, step);
    }
  }
  class LinearGradientParser extends codec.Parser {
    constructor(identOutput, angleParser, stopsParser, step) {
      super();
      this.identOutput = identOutput;
      this.angleParser = angleParser;
      this.stopsParser = stopsParser;
      this.step = step;
    }
    feed(input) {
      return LinearGradientParser.parse(input, this.identOutput, this.angleParser, this.stopsParser, this.step);
    }
    static parse(input, identOutput, angleParser, stopsParser, step = 1) {
      let c = 0;
      if (step === 1) {
        if (identOutput === void 0) {
          identOutput = codec.Unicode.stringOutput();
        }
        while (input.isCont() && (c = input.head(), codec.Unicode.isAlpha(c) || c === 45)) {
          input = input.step();
          identOutput.write(c);
        }
        if (!input.isEmpty()) {
          const ident = identOutput.bind();
          if (ident === "linear-gradient") {
            identOutput = void 0;
            step = 2;
          } else {
            return codec.Parser.error(codec.Diagnostic.message("unexpected " + ident, input));
          }
        }
      }
      if (step === 2) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont() && c === 40) {
          input.step();
          step = 3;
        } else if (!input.isEmpty()) {
          return codec.Parser.error(codec.Diagnostic.expected("(", input));
        }
      }
      if (step === 3) {
        if (angleParser === void 0) {
          angleParser = LinearGradientAngleParser.parse(input);
        } else {
          angleParser = angleParser.feed(input);
        }
        if (angleParser !== void 0) {
          if (angleParser.isDone()) {
            step = 4;
          } else if (angleParser.isError()) {
            return angleParser.asError();
          }
        }
      }
      if (step === 4) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont() && c === 44) {
          input = input.step();
          step = 5;
        } else {
          return codec.Parser.error(codec.Diagnostic.expected("color stops", input));
        }
      }
      if (step === 5) {
        if (stopsParser === void 0) {
          stopsParser = ColorStopListParser.parse(input);
        } else {
          stopsParser = stopsParser.feed(input);
        }
        if (stopsParser !== void 0) {
          if (stopsParser.isDone()) {
            step = 6;
          } else if (stopsParser.isError()) {
            return stopsParser.asError();
          }
        }
      }
      if (step === 6) {
        while (input.isCont() && codec.Unicode.isSpace(input.head())) {
          input.step();
        }
        if (input.isCont() && input.head() === 41) {
          input.step();
          return codec.Parser.done(new LinearGradient(angleParser.bind(), stopsParser.bind()));
        } else if (!input.isEmpty()) {
          return codec.Parser.error(codec.Diagnostic.expected(")", input));
        }
      }
      return new LinearGradientParser(identOutput, angleParser, stopsParser, step);
    }
    static parseRest(input, identOutput) {
      return LinearGradientParser.parse(input, identOutput, void 0, void 0, 2);
    }
  }
  class BoxShadow {
    constructor(inset, offsetX, offsetY, blurRadius, spreadRadius, color, next) {
      this.inset = inset;
      this.offsetX = offsetX;
      this.offsetY = offsetY;
      this.blurRadius = blurRadius;
      this.spreadRadius = spreadRadius;
      this.color = color;
      this.next = next;
      this.stringValue = void 0;
    }
    withInset(inset) {
      if (inset === this.inset) {
        return this;
      } else {
        return new BoxShadow(inset, this.offsetX, this.offsetY, this.blurRadius, this.spreadRadius, this.color, this.next);
      }
    }
    withOffsetX(offsetX) {
      offsetX = math.Length.fromAny(offsetX);
      if (offsetX.equals(this.offsetX)) {
        return this;
      } else {
        return new BoxShadow(this.inset, offsetX, this.offsetY, this.blurRadius, this.spreadRadius, this.color, this.next);
      }
    }
    withOffsetY(offsetY) {
      offsetY = math.Length.fromAny(offsetY);
      if (offsetY.equals(this.offsetY)) {
        return this;
      } else {
        return new BoxShadow(this.inset, this.offsetX, offsetY, this.blurRadius, this.spreadRadius, this.color, this.next);
      }
    }
    withBlurRadius(blurRadius) {
      blurRadius = math.Length.fromAny(blurRadius);
      if (blurRadius.equals(this.blurRadius)) {
        return this;
      } else {
        return new BoxShadow(this.inset, this.offsetX, this.offsetY, blurRadius, this.spreadRadius, this.color, this.next);
      }
    }
    withSpreadRadius(spreadRadius) {
      spreadRadius = math.Length.fromAny(spreadRadius);
      if (spreadRadius.equals(this.spreadRadius)) {
        return this;
      } else {
        return new BoxShadow(this.inset, this.offsetX, this.offsetY, this.blurRadius, spreadRadius, this.color, this.next);
      }
    }
    withColor(color) {
      color = Color.fromAny(color);
      if (color.equals(this.color)) {
        return this;
      } else {
        return new BoxShadow(this.inset, this.offsetX, this.offsetY, this.blurRadius, this.spreadRadius, color, this.next);
      }
    }
    and(inset, offsetX, offsetY, blurRadius, spreadRadius, color) {
      let next;
      if (this.next !== null) {
        next = this.next.and.apply(this.next, arguments);
      } else {
        next = BoxShadow.create.apply(BoxShadow, arguments);
      }
      return new BoxShadow(this.inset, this.offsetX, this.offsetY, this.blurRadius, this.spreadRadius, this.color, next);
    }
    interpolateTo(that) {
      if (that instanceof BoxShadow) {
        return BoxShadowInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof BoxShadow) {
        return this.inset === that.inset && this.offsetX.equivalentTo(that.offsetX, epsilon) && this.offsetY.equivalentTo(that.offsetY, epsilon) && this.blurRadius.equivalentTo(that.blurRadius, epsilon) && this.spreadRadius.equivalentTo(that.spreadRadius, epsilon) && this.color.equivalentTo(that.color, epsilon) && util.Equivalent(this.next, that.next, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof BoxShadow) {
        return this.inset === that.inset && this.offsetX.equals(that.offsetX) && this.offsetY.equals(that.offsetY) && this.blurRadius.equals(that.blurRadius) && this.spreadRadius.equals(that.spreadRadius) && this.color.equals(that.color) && util.Equals(this.next, that.next);
      }
      return false;
    }
    toString() {
      let s = this.stringValue;
      if (s === void 0) {
        s = "";
        if (this.inset) {
          s += "inset";
          s += " ";
        }
        s += this.offsetX.toString();
        s += " ";
        s += this.offsetY.toString();
        s += " ";
        s += this.blurRadius.toString();
        s += " ";
        s += this.spreadRadius.toString();
        s += " ";
        s += this.color.toString();
        if (this.next !== null) {
          s += ", ";
          s += this.next.toString();
        }
        this.stringValue = s;
      }
      return s;
    }
    static create(inset, offsetX, offsetY, blurRadius, spreadRadius, color) {
      if (arguments.length === 1) {
        return BoxShadow.fromAny(inset);
      } else if (typeof inset !== "boolean") {
        if (arguments.length === 3) {
          color = Color.fromAny(offsetY);
          spreadRadius = math.Length.zero();
          blurRadius = math.Length.zero();
          offsetY = math.Length.fromAny(offsetX);
          offsetX = math.Length.fromAny(inset);
        } else if (arguments.length === 4) {
          color = Color.fromAny(blurRadius);
          spreadRadius = math.Length.zero();
          blurRadius = math.Length.fromAny(offsetY);
          offsetY = math.Length.fromAny(offsetX);
          offsetX = math.Length.fromAny(inset);
        } else if (arguments.length === 5) {
          color = Color.fromAny(spreadRadius);
          spreadRadius = math.Length.fromAny(blurRadius);
          blurRadius = math.Length.fromAny(offsetY);
          offsetY = math.Length.fromAny(offsetX);
          offsetX = math.Length.fromAny(inset);
        } else {
          throw new Error(inset + ", " + offsetX + ", " + offsetY + ", " + blurRadius + ", " + spreadRadius + ", " + color);
        }
        inset = false;
      } else {
        if (arguments.length === 4) {
          color = Color.fromAny(blurRadius);
          spreadRadius = math.Length.zero();
          blurRadius = math.Length.zero();
          offsetY = math.Length.fromAny(offsetY);
          offsetX = math.Length.fromAny(offsetX);
        } else if (arguments.length === 5) {
          color = Color.fromAny(spreadRadius);
          spreadRadius = math.Length.zero();
          blurRadius = math.Length.fromAny(blurRadius);
          offsetY = math.Length.fromAny(offsetY);
          offsetX = math.Length.fromAny(offsetX);
        } else if (arguments.length === 6) {
          color = Color.fromAny(color);
          spreadRadius = math.Length.fromAny(spreadRadius);
          blurRadius = math.Length.fromAny(blurRadius);
          offsetY = math.Length.fromAny(offsetY);
          offsetX = math.Length.fromAny(offsetX);
        } else {
          throw new Error(inset + ", " + offsetX + ", " + offsetY + ", " + blurRadius + ", " + spreadRadius + ", " + color);
        }
      }
      return new BoxShadow(inset, offsetX, offsetY, blurRadius, spreadRadius, color, null);
    }
    static fromInit(init) {
      const inset = init.inset || false;
      const offsetX = init.offsetX !== void 0 ? math.Length.fromAny(init.offsetX) : math.Length.zero();
      const offsetY = init.offsetY !== void 0 ? math.Length.fromAny(init.offsetY) : math.Length.zero();
      const blurRadius = init.blurRadius !== void 0 ? math.Length.fromAny(init.blurRadius) : math.Length.zero();
      const spreadRadius = init.spreadRadius !== void 0 ? math.Length.fromAny(init.spreadRadius) : math.Length.zero();
      const color = init.color !== void 0 ? Color.fromAny(init.color) : Color.black();
      return new BoxShadow(inset, offsetX, offsetY, blurRadius, spreadRadius, color, null);
    }
    static fromArray(array) {
      let boxShadow = BoxShadow.fromAny(array[0]);
      for (let i = 1; i < array.length; i += 1) {
        boxShadow = boxShadow.and(array[i]);
      }
      return boxShadow;
    }
    static fromAny(...values) {
      let value;
      if (arguments.length === 0) {
        return null;
      } else if (arguments.length === 1) {
        value = values[0];
      } else {
        value = values;
      }
      if (value === void 0 || value === null || value instanceof BoxShadow) {
        return value;
      } else if (typeof value === "string") {
        return BoxShadow.parse(value);
      } else if (typeof value === "object" && value !== null && value.length === void 0) {
        return BoxShadow.fromInit(value);
      } else if (typeof value === "object" && value !== null && value.length > 0) {
        return BoxShadow.fromArray(value);
      }
      throw new TypeError("" + value);
    }
    static fromValue(value) {
      let boxShadow = null;
      value.forEach((function(item, index) {
        const header = item.header("boxShadow");
        if (header.isDefined()) {
          let inset;
          let offsetX;
          let offsetY;
          let blurRadius;
          let spreadRadius;
          let color;
          header.forEach((function(item, index) {
            const key = item.key.stringValue();
            if (key !== void 0) {
              if (key === "inset") {
                inset = item.toValue().booleanValue(inset);
              } else if (key === "offsetX") {
                offsetX = item.toValue().cast(math.Length.form(), offsetX);
              } else if (key === "offsetY") {
                offsetY = item.toValue().cast(math.Length.form(), offsetY);
              } else if (key === "blurRadius") {
                blurRadius = item.toValue().cast(math.Length.form(), blurRadius);
              } else if (key === "spreadRadius") {
                spreadRadius = item.toValue().cast(math.Length.form(), spreadRadius);
              } else if (key === "color") {
                color = item.toValue().cast(Color.form(), color);
              }
            } else if (item instanceof structure.Value) {
              if (index === 0 && item instanceof structure.Text && item.value === "inset") {
                inset = true;
              } else if (index === 0 || index === 1 && inset !== void 0) {
                offsetX = item.cast(math.Length.form(), offsetX);
              } else if (index === 1 || index === 2 && inset !== void 0) {
                offsetY = item.cast(math.Length.form(), offsetY);
              } else if (index === 2 || index === 3 && inset !== void 0) {
                blurRadius = item.cast(math.Length.form(), blurRadius);
                if (blurRadius === void 0) {
                  color = item.cast(Color.form(), color);
                }
              } else if ((index === 3 || index === 4 && inset === void 0) && color === void 0) {
                spreadRadius = item.cast(math.Length.form(), spreadRadius);
                if (spreadRadius === void 0) {
                  color = item.cast(Color.form(), color);
                }
              } else if ((index === 4 || index === 5 && inset === void 0) && color === void 0) {
                color = item.cast(Color.form(), color);
              }
            }
          }));
          inset = inset !== void 0 ? inset : false;
          offsetX = offsetX !== void 0 ? offsetX : math.Length.zero();
          offsetY = offsetY !== void 0 ? offsetY : math.Length.zero();
          blurRadius = blurRadius !== void 0 ? blurRadius : math.Length.zero();
          spreadRadius = spreadRadius !== void 0 ? spreadRadius : math.Length.zero();
          color = color !== void 0 ? color : Color.black();
          const next = new BoxShadow(inset || false, offsetX, offsetY, blurRadius, spreadRadius, color, null);
          if (boxShadow !== null) {
            boxShadow = boxShadow.and(next);
          } else {
            boxShadow = next;
          }
        }
      }));
      return boxShadow;
    }
    static parse(string) {
      let input = codec.Unicode.stringInput(string);
      while (input.isCont() && codec.Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = BoxShadowParser.parse(input);
      if (parser.isDone()) {
        while (input.isCont() && codec.Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = codec.Parser.error(codec.Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return init.offsetX !== void 0 && init.offsetY !== void 0 && init.color !== void 0;
      }
      return false;
    }
    static isArray(value) {
      if (Array.isArray(value)) {
        const n = value.length;
        if (n !== 0) {
          for (let i = 0; i < n; i += 1) {
            if (!BoxShadow.isAny(value)) {
              return false;
            }
          }
          return true;
        }
      }
      return false;
    }
    static isAny(value) {
      return value instanceof BoxShadow || BoxShadow.isArray(value) || BoxShadow.isInit(value) || typeof value === "string";
    }
    static form() {
      return new BoxShadowForm(null);
    }
  }
  __decorate([ util.Lazy ], BoxShadow, "form", null);
  const BoxShadowInterpolator = function(_super) {
    const BoxShadowInterpolator = function(b0, b1) {
      const interpolator = function(u) {
        const inset = interpolator.insetInterpolator(u);
        const offsetX = interpolator.offsetXInterpolator(u);
        const offsetY = interpolator.offsetYInterpolator(u);
        const blurRadius = interpolator.blurRadiusInterpolator(u);
        const spreadRadius = interpolator.spreadRadiusInterpolator(u);
        const color = interpolator.colorInterpolator(u);
        const next = interpolator.nextInterpolator(u);
        return new BoxShadow(inset, offsetX, offsetY, blurRadius, spreadRadius, color, next);
      };
      Object.setPrototypeOf(interpolator, BoxShadowInterpolator.prototype);
      interpolator.insetInterpolator = util.Interpolator(b0.inset, b1.inset);
      interpolator.offsetXInterpolator = b0.offsetX.interpolateTo(b1.offsetX);
      interpolator.offsetYInterpolator = b0.offsetY.interpolateTo(b1.offsetY);
      interpolator.blurRadiusInterpolator = b0.blurRadius.interpolateTo(b1.blurRadius);
      interpolator.spreadRadiusInterpolator = b0.spreadRadius.interpolateTo(b1.spreadRadius);
      interpolator.colorInterpolator = b0.color.interpolateTo(b1.color);
      interpolator.nextInterpolator = util.Interpolator(b0.next, b1.next);
      return interpolator;
    };
    BoxShadowInterpolator.prototype = Object.create(_super.prototype);
    BoxShadowInterpolator.prototype.constructor = BoxShadowInterpolator;
    Object.defineProperty(BoxShadowInterpolator.prototype, 0, {
      get() {
        const inset = this.insetInterpolator[0];
        const offsetX = this.offsetXInterpolator[0];
        const offsetY = this.offsetYInterpolator[0];
        const blurRadius = this.blurRadiusInterpolator[0];
        const spreadRadius = this.spreadRadiusInterpolator[0];
        const color = this.colorInterpolator[0];
        const next = this.nextInterpolator[0];
        return new BoxShadow(inset, offsetX, offsetY, blurRadius, spreadRadius, color, next);
      },
      configurable: true
    });
    Object.defineProperty(BoxShadowInterpolator.prototype, 1, {
      get() {
        const inset = this.insetInterpolator[1];
        const offsetX = this.offsetXInterpolator[1];
        const offsetY = this.offsetYInterpolator[1];
        const blurRadius = this.blurRadiusInterpolator[1];
        const spreadRadius = this.spreadRadiusInterpolator[1];
        const color = this.colorInterpolator[1];
        const next = this.nextInterpolator[1];
        return new BoxShadow(inset, offsetX, offsetY, blurRadius, spreadRadius, color, next);
      },
      configurable: true
    });
    BoxShadowInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof BoxShadowInterpolator) {
        return this.insetInterpolator.equals(that.insetInterpolator) && this.offsetXInterpolator.equals(that.offsetXInterpolator) && this.offsetYInterpolator.equals(that.offsetYInterpolator) && this.blurRadiusInterpolator.equals(that.blurRadiusInterpolator) && this.spreadRadiusInterpolator.equals(that.spreadRadiusInterpolator) && this.colorInterpolator.equals(that.colorInterpolator) && this.nextInterpolator.equals(that.nextInterpolator);
      }
      return false;
    };
    return BoxShadowInterpolator;
  }(util.Interpolator);
  class BoxShadowForm extends structure.Form {
    constructor(unit) {
      super();
      Object.defineProperty(this, "unit", {
        value: unit,
        enumerable: true
      });
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new BoxShadowForm(unit);
      } else {
        return this;
      }
    }
    mold(boxShadow) {
      let shadow = BoxShadow.fromAny(boxShadow);
      const record = structure.Record.create();
      do {
        const header = structure.Record.create(5);
        if (shadow.inset) {
          header.push("inset");
        }
        header.push(math.Length.form().mold(shadow.offsetX));
        header.push(math.Length.form().mold(shadow.offsetY));
        header.push(math.Length.form().mold(shadow.blurRadius));
        header.push(math.Length.form().mold(shadow.spreadRadius));
        header.push(Color.form().mold(shadow.color));
        record.attr("boxShadow", header);
        if (shadow.next !== null) {
          shadow = shadow.next;
          continue;
        }
        break;
      } while (true);
      return record;
    }
    cast(item) {
      const value = item.toValue();
      let boxShadow;
      try {
        boxShadow = BoxShadow.fromValue(value);
        if (boxShadow === void 0) {
          const string = value.stringValue();
          if (string !== void 0) {
            boxShadow = BoxShadow.parse(string);
          }
        }
      } catch (e) {}
      return boxShadow;
    }
  }
  class BoxShadowParser extends codec.Parser {
    constructor(boxShadow, identOutput, offsetXParser, offsetYParser, blurRadiusParser, spreadRadiusParser, colorParser, step) {
      super();
      this.boxShadow = boxShadow;
      this.identOutput = identOutput;
      this.offsetXParser = offsetXParser;
      this.offsetYParser = offsetYParser;
      this.blurRadiusParser = blurRadiusParser;
      this.spreadRadiusParser = spreadRadiusParser;
      this.colorParser = colorParser;
      this.step = step;
    }
    feed(input) {
      return BoxShadowParser.parse(input, this.boxShadow, this.identOutput, this.offsetXParser, this.offsetYParser, this.blurRadiusParser, this.spreadRadiusParser, this.colorParser, this.step);
    }
    static parse(input, boxShadow, identOutput, offsetXParser, offsetYParser, blurRadiusParser, spreadRadiusParser, colorParser, step = 1) {
      let c = 0;
      do {
        if (step === 1) {
          while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
            input.step();
          }
          if (input.isCont()) {
            if (codec.Unicode.isAlpha(c)) {
              step = 2;
            } else {
              step = 4;
            }
          } else if (!input.isEmpty()) {
            return codec.Parser.error(codec.Diagnostic.unexpected(input));
          }
        }
        if (step === 2) {
          identOutput = identOutput || codec.Unicode.stringOutput();
          while (input.isCont() && (c = input.head(), codec.Unicode.isAlpha(c))) {
            input = input.step();
            identOutput.write(c);
          }
          if (!input.isEmpty()) {
            const ident = identOutput.bind();
            switch (ident) {
             case "inset":
              step = 3;
              break;

             case "none":
              return codec.Parser.done(null);

             default:
              return codec.Parser.error(codec.Diagnostic.message("unknown box-shadow: " + ident, input));
            }
          }
        }
        if (step === 3) {
          if (input.isCont()) {
            if (codec.Unicode.isSpace(input.head())) {
              input.step();
              step = 4;
            } else {
              return codec.Parser.error(codec.Diagnostic.expected("space", input));
            }
          } else if (input.isDone()) {
            return codec.Parser.error(codec.Diagnostic.unexpected(input));
          }
        }
        if (step === 4) {
          if (offsetXParser === void 0) {
            while (input.isCont() && codec.Unicode.isSpace(input.head())) {
              input.step();
            }
            if (!input.isEmpty()) {
              offsetXParser = math.LengthParser.parse(input);
            }
          } else {
            offsetXParser = offsetXParser.feed(input);
          }
          if (offsetXParser !== void 0) {
            if (offsetXParser.isDone()) {
              step = 5;
            } else if (offsetXParser.isError()) {
              return offsetXParser.asError();
            }
          }
        }
        if (step === 5) {
          if (input.isCont()) {
            if (codec.Unicode.isSpace(input.head())) {
              input.step();
              step = 6;
            } else {
              return codec.Parser.error(codec.Diagnostic.expected("space", input));
            }
          } else if (!input.isEmpty()) {
            return codec.Parser.error(codec.Diagnostic.unexpected(input));
          }
        }
        if (step === 6) {
          if (offsetYParser === void 0) {
            while (input.isCont() && codec.Unicode.isSpace(input.head())) {
              input.step();
            }
            if (!input.isEmpty()) {
              offsetYParser = math.LengthParser.parse(input);
            }
          } else {
            offsetYParser = offsetYParser.feed(input);
          }
          if (offsetYParser !== void 0) {
            if (offsetYParser.isDone()) {
              step = 7;
            } else if (offsetYParser.isError()) {
              return offsetYParser.asError();
            }
          }
        }
        if (step === 7) {
          if (input.isCont()) {
            if (codec.Unicode.isSpace(input.head())) {
              input.step();
              step = 8;
            } else {
              return codec.Parser.error(codec.Diagnostic.expected("space", input));
            }
          } else if (!input.isEmpty()) {
            return codec.Parser.error(codec.Diagnostic.unexpected(input));
          }
        }
        if (step === 8) {
          if (blurRadiusParser === void 0) {
            while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
              input.step();
            }
            if (input.isCont() && (c === 45 || c >= 48 && c <= 57)) {
              blurRadiusParser = math.LengthParser.parse(input);
            } else if (!input.isEmpty()) {
              step = 12;
            }
          } else {
            blurRadiusParser = blurRadiusParser.feed(input);
          }
          if (blurRadiusParser !== void 0) {
            if (blurRadiusParser.isDone()) {
              step = 9;
            } else if (blurRadiusParser.isError()) {
              return blurRadiusParser.asError();
            }
          }
        }
        if (step === 9) {
          if (input.isCont()) {
            if (codec.Unicode.isSpace(input.head())) {
              input.step();
              step = 10;
            } else {
              return codec.Parser.error(codec.Diagnostic.expected("space", input));
            }
          } else if (!input.isEmpty()) {
            return codec.Parser.error(codec.Diagnostic.unexpected(input));
          }
        }
        if (step === 10) {
          if (spreadRadiusParser === void 0) {
            while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
              input.step();
            }
            if (input.isCont() && (c === 45 || c >= 48 && c <= 57)) {
              spreadRadiusParser = math.LengthParser.parse(input);
            } else if (!input.isEmpty()) {
              step = 12;
            }
          } else {
            spreadRadiusParser = spreadRadiusParser.feed(input);
          }
          if (spreadRadiusParser !== void 0) {
            if (spreadRadiusParser.isDone()) {
              step = 11;
            } else if (spreadRadiusParser.isError()) {
              return spreadRadiusParser.asError();
            }
          }
        }
        if (step === 11) {
          if (input.isCont()) {
            if (codec.Unicode.isSpace(input.head())) {
              input.step();
              step = 12;
            } else {
              return codec.Parser.error(codec.Diagnostic.expected("space", input));
            }
          } else if (!input.isEmpty()) {
            return codec.Parser.error(codec.Diagnostic.unexpected(input));
          }
        }
        if (step === 12) {
          if (colorParser === void 0) {
            while (input.isCont() && codec.Unicode.isSpace(input.head())) {
              input.step();
            }
            if (!input.isEmpty()) {
              colorParser = ColorParser.parse(input);
            }
          } else {
            colorParser = colorParser.feed(input);
          }
          if (colorParser !== void 0) {
            if (colorParser.isDone()) {
              const inset = identOutput !== void 0 ? identOutput.bind() === "inset" : false;
              const offsetX = offsetXParser.bind();
              const offsetY = offsetYParser.bind();
              const blurRadius = blurRadiusParser !== void 0 ? blurRadiusParser.bind() : math.Length.zero();
              const spreadRadius = spreadRadiusParser !== void 0 ? spreadRadiusParser.bind() : math.Length.zero();
              const color = colorParser.bind();
              const next = new BoxShadow(inset, offsetX, offsetY, blurRadius, spreadRadius, color, null);
              if (boxShadow === void 0) {
                boxShadow = next;
              } else {
                boxShadow = boxShadow.and(next);
              }
              identOutput = void 0;
              offsetXParser = void 0;
              offsetYParser = void 0;
              blurRadiusParser = void 0;
              spreadRadiusParser = void 0;
              colorParser = void 0;
              step = 13;
            } else if (colorParser.isError()) {
              return colorParser.asError();
            }
          }
        }
        if (step === 13) {
          while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
            input.step();
          }
          if (input.isCont() && c === 44) {
            input.step();
            step = 1;
            continue;
          } else if (!input.isEmpty()) {
            return codec.Parser.done(boxShadow);
          }
        }
        break;
      } while (true);
      return new BoxShadowParser(boxShadow, identOutput, offsetXParser, offsetYParser, blurRadiusParser, spreadRadiusParser, colorParser, step);
    }
  }
  const FocusInterpolator = function(_super) {
    const FocusInterpolator = function(f0, f1) {
      const interpolator = function(u) {
        const f0 = interpolator[0];
        const f1 = interpolator[1];
        const phase = f0.phase + u * (f1.phase - f0.phase);
        const direction = u !== 1 ? f0.direction : 0;
        return Focus.create(phase, direction);
      };
      Object.setPrototypeOf(interpolator, FocusInterpolator.prototype);
      interpolator[0] = f0;
      interpolator[1] = f1;
      return interpolator;
    };
    FocusInterpolator.prototype = Object.create(_super.prototype);
    FocusInterpolator.prototype.constructor = FocusInterpolator;
    return FocusInterpolator;
  }(util.Interpolator);
  class Focus {
    constructor(phase, direction) {
      this.phase = phase;
      this.direction = direction;
    }
    withPhase(phase) {
      if (phase !== this.phase) {
        return Focus.create(phase, this.direction);
      } else {
        return this;
      }
    }
    withDirection(direction) {
      if (direction !== this.direction) {
        return Focus.create(this.phase, direction);
      } else {
        return this;
      }
    }
    get unfocused() {
      return this.phase === 0 && this.direction === 0;
    }
    get focused() {
      return this.phase === 1 && this.direction === 0;
    }
    get focusing() {
      return this.direction > 0;
    }
    get unfocusing() {
      return this.direction < 0;
    }
    asFocusing() {
      if (!this.focusing) {
        return Focus.focusing(this.phase);
      } else {
        return this;
      }
    }
    asUnfocusing() {
      if (!this.unfocusing) {
        return Focus.unfocusing(this.phase);
      } else {
        return this;
      }
    }
    asToggling() {
      if (this.direction > 0 || this.phase >= .5) {
        return Focus.unfocusing(this.phase);
      } else if (this.direction < 0 || this.phase < .5) {
        return Focus.focusing(this.phase);
      } else {
        return this;
      }
    }
    asToggled() {
      if (this.direction > 0 || this.phase >= .5) {
        return Focus.unfocused();
      } else if (this.direction < 0 || this.phase < .5) {
        return Focus.focused();
      } else {
        return this;
      }
    }
    interpolateTo(that) {
      if (that instanceof Focus) {
        return FocusInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof Focus) {
        return util.Numbers.equivalent(this.phase, that.phase, epsilon) && util.Numbers.equivalent(this.direction, that.direction, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Focus) {
        return this.phase === that.phase && this.direction === that.direction;
      }
      return false;
    }
    hashCode() {
      return util.Murmur3.mash(util.Murmur3.mix(util.Murmur3.mix(util.Constructors.hash(Focus), util.Numbers.hash(this.phase)), util.Numbers.hash(this.direction)));
    }
    debug(output) {
      output = output.write("Focus").write(46);
      if (this.phase === 0 && this.direction === 0) {
        output = output.write("unfocused").write(40);
      } else if (this.phase === 1 && this.direction === 0) {
        output = output.write("focused").write(40);
      } else if (this.direction === 1) {
        output = output.write("focusing").write(40);
        if (this.phase !== 0) {
          output = output.debug(this.phase);
        }
      } else if (this.direction === -1) {
        output = output.write("unfocusing").write(40);
        if (this.phase !== 1) {
          output = output.debug(this.phase);
        }
      } else {
        output = output.write("create").write(40).debug(this.phase);
        if (this.direction !== 0) {
          output = output.write(", ").debug(this.direction);
        }
      }
      output = output.write(41);
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static unfocused() {
      return new Focus(0, 0);
    }
    static focused() {
      return new Focus(1, 0);
    }
    static focusing(phase) {
      if (phase === void 0) {
        phase = 0;
      }
      return new Focus(phase, 1);
    }
    static unfocusing(phase) {
      if (phase === void 0) {
        phase = 1;
      }
      return new Focus(phase, -1);
    }
    static create(phase, direction) {
      if (direction === void 0) {
        direction = 0;
      }
      if (phase === 0 && direction === 0) {
        return Focus.unfocused();
      } else if (phase === 1 && direction === 0) {
        return Focus.focused();
      } else {
        return new Focus(phase, direction);
      }
    }
    static fromInit(value) {
      return new Focus(value.phase, value.direction);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof Focus) {
        return value;
      } else if (Focus.isInit(value)) {
        return Focus.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return typeof init.phase === "number" && typeof init.direction === "number";
      }
      return false;
    }
    static isAny(value) {
      return value instanceof Focus || Focus.isInit(value);
    }
  }
  __decorate([ util.Lazy ], Focus, "unfocused", null);
  __decorate([ util.Lazy ], Focus, "focused", null);
  const PresenceInterpolator = function(_super) {
    const PresenceInterpolator = function(p0, p1) {
      const interpolator = function(u) {
        const p0 = interpolator[0];
        const p1 = interpolator[1];
        const phase = p0.phase + u * (p1.phase - p0.phase);
        const direction = u !== 1 ? p0.direction : 0;
        return Presence.create(phase, direction);
      };
      Object.setPrototypeOf(interpolator, PresenceInterpolator.prototype);
      interpolator[0] = p0;
      interpolator[1] = p1;
      return interpolator;
    };
    PresenceInterpolator.prototype = Object.create(_super.prototype);
    PresenceInterpolator.prototype.constructor = PresenceInterpolator;
    return PresenceInterpolator;
  }(util.Interpolator);
  class Presence {
    constructor(phase, direction) {
      this.phase = phase;
      this.direction = direction;
    }
    withPhase(phase) {
      if (phase !== this.phase) {
        return Presence.create(phase, this.direction);
      } else {
        return this;
      }
    }
    withDirection(direction) {
      if (direction !== this.direction) {
        return Presence.create(this.phase, direction);
      } else {
        return this;
      }
    }
    get modalState() {
      if (this.phase === 0 && this.direction === 0) {
        return "hidden";
      } else if (this.phase === 1 && this.direction === 0) {
        return "shown";
      } else if (this.direction > 0) {
        return "showing";
      } else if (this.direction < 0) {
        return "hiding";
      } else {
        return void 0;
      }
    }
    get dismissed() {
      return this.phase === 0 && this.direction === 0;
    }
    get presented() {
      return this.phase === 1 && this.direction === 0;
    }
    get presenting() {
      return this.direction > 0;
    }
    get dismissing() {
      return this.direction < 0;
    }
    asPresenting() {
      if (!this.presenting) {
        return Presence.presenting(this.phase);
      } else {
        return this;
      }
    }
    asDismissing() {
      if (!this.dismissing) {
        return Presence.dismissing(this.phase);
      } else {
        return this;
      }
    }
    asToggling() {
      if (this.direction > 0 || this.phase >= .5) {
        return Presence.dismissing(this.phase);
      } else if (this.direction < 0 || this.phase < .5) {
        return Presence.presenting(this.phase);
      } else {
        return this;
      }
    }
    asToggled() {
      if (this.direction > 0 || this.phase >= .5) {
        return Presence.dismissed();
      } else if (this.direction < 0 || this.phase < .5) {
        return Presence.presented();
      } else {
        return this;
      }
    }
    interpolateTo(that) {
      if (that instanceof Presence) {
        return PresenceInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof Presence) {
        return util.Numbers.equivalent(this.phase, that.phase, epsilon) && util.Numbers.equivalent(this.direction, that.direction, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Presence) {
        return this.phase === that.phase && this.direction === that.direction;
      }
      return false;
    }
    hashCode() {
      return util.Murmur3.mash(util.Murmur3.mix(util.Murmur3.mix(util.Constructors.hash(Presence), util.Numbers.hash(this.phase)), util.Numbers.hash(this.direction)));
    }
    debug(output) {
      output = output.write("Presence").write(46);
      if (this.phase === 0 && this.direction === 0) {
        output = output.write("dismissed").write(40);
      } else if (this.phase === 1 && this.direction === 0) {
        output = output.write("presented").write(40);
      } else if (this.direction === 1) {
        output = output.write("presenting").write(40);
        if (this.phase !== 0) {
          output = output.debug(this.phase);
        }
      } else if (this.direction === -1) {
        output = output.write("dismissing").write(40);
        if (this.phase !== 1) {
          output = output.debug(this.phase);
        }
      } else {
        output = output.write("create").write(40).debug(this.phase);
        if (this.direction !== 0) {
          output = output.write(", ").debug(this.direction);
        }
      }
      output = output.write(41);
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static dismissed() {
      return new Presence(0, 0);
    }
    static presented() {
      return new Presence(1, 0);
    }
    static presenting(phase) {
      if (phase === void 0) {
        phase = 0;
      }
      return new Presence(phase, 1);
    }
    static dismissing(phase) {
      if (phase === void 0) {
        phase = 1;
      }
      return new Presence(phase, -1);
    }
    static create(phase, direction) {
      if (direction === void 0) {
        direction = 0;
      }
      if (phase === 0 && direction === 0) {
        return Presence.dismissed();
      } else if (phase === 1 && direction === 0) {
        return Presence.presented();
      } else {
        return new Presence(phase, direction);
      }
    }
    static fromInit(value) {
      return new Presence(value.phase, value.direction);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof Presence) {
        return value;
      } else if (Presence.isInit(value)) {
        return Presence.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return typeof init.phase === "number" && typeof init.direction === "number";
      }
      return false;
    }
    static isAny(value) {
      return value instanceof Presence || Presence.isInit(value);
    }
  }
  __decorate([ util.Lazy ], Presence, "dismissed", null);
  __decorate([ util.Lazy ], Presence, "presented", null);
  const ExpansionInterpolator = function(_super) {
    const ExpansionInterpolator = function(e0, e1) {
      const interpolator = function(u) {
        const e0 = interpolator[0];
        const e1 = interpolator[1];
        const phase = e0.phase + u * (e1.phase - e0.phase);
        const direction = u !== 1 ? e0.direction : 0;
        return Expansion.create(phase, direction);
      };
      Object.setPrototypeOf(interpolator, ExpansionInterpolator.prototype);
      interpolator[0] = e0;
      interpolator[1] = e1;
      return interpolator;
    };
    ExpansionInterpolator.prototype = Object.create(_super.prototype);
    ExpansionInterpolator.prototype.constructor = ExpansionInterpolator;
    return ExpansionInterpolator;
  }(util.Interpolator);
  class Expansion {
    constructor(phase, direction) {
      this.phase = phase;
      this.direction = direction;
    }
    withPhase(phase) {
      if (phase !== this.phase) {
        return Expansion.create(phase, this.direction);
      } else {
        return this;
      }
    }
    withDirection(direction) {
      if (direction !== this.direction) {
        return Expansion.create(this.phase, direction);
      } else {
        return this;
      }
    }
    get modalState() {
      if (this.phase === 0 && this.direction === 0) {
        return "hidden";
      } else if (this.phase === 1 && this.direction === 0) {
        return "shown";
      } else if (this.direction > 0) {
        return "showing";
      } else if (this.direction < 0) {
        return "hiding";
      } else {
        return void 0;
      }
    }
    get collapsed() {
      return this.phase === 0 && this.direction === 0;
    }
    get expanded() {
      return this.phase === 1 && this.direction === 0;
    }
    get expanding() {
      return this.direction > 0;
    }
    get collapsing() {
      return this.direction < 0;
    }
    asExpanding() {
      if (!this.expanding) {
        return Expansion.expanding(this.phase);
      } else {
        return this;
      }
    }
    asCollapsing() {
      if (!this.collapsing) {
        return Expansion.collapsing(this.phase);
      } else {
        return this;
      }
    }
    asToggling() {
      if (this.direction > 0 || this.phase >= .5) {
        return Expansion.collapsing(this.phase);
      } else if (this.direction < 0 || this.phase < .5) {
        return Expansion.expanding(this.phase);
      } else {
        return this;
      }
    }
    asToggled() {
      if (this.direction > 0 || this.phase >= .5) {
        return Expansion.collapsed();
      } else if (this.direction < 0 || this.phase < .5) {
        return Expansion.expanded();
      } else {
        return this;
      }
    }
    interpolateTo(that) {
      if (that instanceof Expansion) {
        return ExpansionInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof Expansion) {
        return util.Numbers.equivalent(this.phase, that.phase, epsilon) && util.Numbers.equivalent(this.direction, that.direction, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Expansion) {
        return this.phase === that.phase && this.direction === that.direction;
      }
      return false;
    }
    hashCode() {
      return util.Murmur3.mash(util.Murmur3.mix(util.Murmur3.mix(util.Constructors.hash(Expansion), util.Numbers.hash(this.phase)), util.Numbers.hash(this.direction)));
    }
    debug(output) {
      output = output.write("Expansion").write(46);
      if (this.phase === 0 && this.direction === 0) {
        output = output.write("collapsed").write(40);
      } else if (this.phase === 1 && this.direction === 0) {
        output = output.write("expanded").write(40);
      } else if (this.direction === 1) {
        output = output.write("expanding").write(40);
        if (this.phase !== 0) {
          output = output.debug(this.phase);
        }
      } else if (this.direction === -1) {
        output = output.write("collapsing").write(40);
        if (this.phase !== 1) {
          output = output.debug(this.phase);
        }
      } else {
        output = output.write("create").write(40).debug(this.phase);
        if (this.direction !== 0) {
          output = output.write(", ").debug(this.direction);
        }
      }
      output = output.write(41);
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static collapsed() {
      return new Expansion(0, 0);
    }
    static expanded() {
      return new Expansion(1, 0);
    }
    static expanding(phase) {
      if (phase === void 0) {
        phase = 0;
      }
      return new Expansion(phase, 1);
    }
    static collapsing(phase) {
      if (phase === void 0) {
        phase = 1;
      }
      return new Expansion(phase, -1);
    }
    static create(phase, direction) {
      if (direction === void 0) {
        direction = 0;
      }
      if (phase === 0 && direction === 0) {
        return Expansion.collapsed();
      } else if (phase === 1 && direction === 0) {
        return Expansion.expanded();
      } else {
        return new Expansion(phase, direction);
      }
    }
    static fromInit(value) {
      return new Expansion(value.phase, value.direction);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof Expansion) {
        return value;
      } else if (Expansion.isInit(value)) {
        return Expansion.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return typeof init.phase === "number" && typeof init.direction === "number";
      }
      return false;
    }
    static isAny(value) {
      return value instanceof Expansion || Expansion.isInit(value);
    }
  }
  __decorate([ util.Lazy ], Expansion, "collapsed", null);
  __decorate([ util.Lazy ], Expansion, "expanded", null);
  const StyleValue = function() {
    const StyleValue = {};
    StyleValue.fromAny = function(value) {
      if (value instanceof time.DateTime || value instanceof math.Angle || value instanceof math.Length || value instanceof Color || value instanceof Font || value instanceof BoxShadow || value instanceof LinearGradient || value instanceof math.Transform || value instanceof util.Interpolator || typeof value === "number" || typeof value === "boolean") {
        return value;
      } else if (value instanceof Date || time.DateTime.isInit(value)) {
        return time.DateTime.fromAny(value);
      } else if (Font.isInit(value)) {
        return Font.fromAny(value);
      } else if (Color.isInit(value)) {
        return Color.fromAny(value);
      } else if (BoxShadow.isInit(value)) {
        return BoxShadow.fromAny(value);
      } else if (typeof value === "string") {
        return StyleValue.parse(value);
      }
      throw new TypeError("" + value);
    };
    StyleValue.parse = function(input) {
      if (typeof input === "string") {
        input = codec.Unicode.stringInput(input);
      }
      while (input.isCont() && codec.Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = StyleValueParser.parse(input);
      if (parser.isDone()) {
        while (input.isCont() && codec.Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = codec.Parser.error(codec.Diagnostic.unexpected(input));
      }
      return parser.bind();
    };
    Object.defineProperty(StyleValue, "form", {
      value: function() {
        const form = new StyleValueForm(void 0);
        Object.defineProperty(StyleValue, "form", {
          value: function() {
            return form;
          },
          enumerable: true,
          configurable: true
        });
        return form;
      },
      enumerable: true,
      configurable: true
    });
    return StyleValue;
  }();
  class StyleValueForm extends structure.Form {
    constructor(unit) {
      super();
      Object.defineProperty(this, "unit", {
        value: unit,
        enumerable: true
      });
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new StyleValueForm(unit);
      } else {
        return this;
      }
    }
    mold(value) {
      if (value !== void 0) {
        value = StyleValue.fromAny(value);
        if (value instanceof time.DateTime) {
          return time.DateTime.form().mold(value);
        } else if (value instanceof math.Angle) {
          return math.Angle.form().mold(value);
        } else if (value instanceof math.Length) {
          return math.Length.form().mold(value);
        } else if (value instanceof Font) {
          return Font.form().mold(value);
        } else if (value instanceof Color) {
          return Color.form().mold(value);
        } else if (value instanceof BoxShadow) {
          return BoxShadow.form().mold(value);
        } else if (value instanceof math.Transform) {
          return math.Transform.form().mold(value);
        } else if (typeof value === "number") {
          return structure.Num.from(value);
        }
        throw new TypeError("" + value);
      } else {
        return structure.Item.extant();
      }
    }
    cast(item) {
      const value = item.toValue();
      if (value instanceof structure.Num) {
        return value.numberValue();
      }
      if (value instanceof structure.Bool) {
        return value.booleanValue();
      }
      const string = value.stringValue(void 0);
      if (string !== void 0) {
        try {
          return StyleValue.parse(string);
        } catch (e) {}
      }
      if (value instanceof structure.Record) {
        const date = time.DateTime.fromValue(value);
        if (date !== null) {
          return date;
        }
        const angle = math.Angle.fromValue(value);
        if (angle !== null) {
          return angle;
        }
        const length = math.Length.fromValue(value);
        if (length !== null) {
          return length;
        }
        const font = Font.fromValue(value);
        if (font !== null) {
          return font;
        }
        const color = Color.fromValue(value);
        if (color !== null) {
          return color;
        }
        const boxShadow = BoxShadow.fromValue(value);
        if (boxShadow !== null) {
          return boxShadow;
        }
        const transform = math.Transform.fromValue(value);
        if (transform !== null) {
          return transform;
        }
      }
      return void 0;
    }
  }
  class StyleValueParser extends codec.Parser {
    constructor(identOutput, valueParser, unitsOutput, step) {
      super();
      this.identOutput = identOutput;
      this.valueParser = valueParser;
      this.unitsOutput = unitsOutput;
      this.step = step;
    }
    feed(input) {
      return StyleValueParser.parse(input, this.identOutput, this.valueParser, this.unitsOutput, this.step);
    }
    static parse(input, identOutput, valueParser, unitsOutput, step = 1) {
      let c = 0;
      if (step === 1) {
        while (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c))) {
          input.step();
        }
        if (input.isCont()) {
          if (c === 35) {
            return HexColorParser.parse(input);
          } else if (codec.Unicode.isAlpha(c)) {
            step = 2;
          } else {
            step = 3;
          }
        } else if (!input.isEmpty()) {
          return codec.Parser.error(codec.Diagnostic.unexpected(input));
        }
      }
      if (step === 2) {
        identOutput = identOutput || codec.Unicode.stringOutput();
        while (input.isCont() && (c = input.head(), codec.Unicode.isAlpha(c) || codec.Unicode.isDigit(c) || c === 45)) {
          input = input.step();
          identOutput.write(c);
        }
        if (!input.isEmpty()) {
          const ident = identOutput.bind();
          switch (ident) {
           case "rgb":
           case "rgba":
            return RgbColorParser.parseRest(input);

           case "hsl":
           case "hsla":
            return HslColorParser.parseRest(input);

           case "linear-gradient":
            return LinearGradientParser.parseRest(input, identOutput);

           case "normal":
           case "italic":
           case "oblique":
            return FontParser.parseRest(input, ident);

           case "small-caps":
            return FontParser.parseRest(input, void 0, ident);

           case "bold":
           case "bolder":
           case "lighter":
            return FontParser.parseRest(input, void 0, void 0, ident);

           case "ultra-condensed":
           case "extra-condensed":
           case "semi-condensed":
           case "condensed":
           case "expanded":
           case "semi-expanded":
           case "extra-expanded":
           case "ultra-expanded":
            return FontParser.parseRest(input, void 0, void 0, void 0, ident);

           case "large":
           case "larger":
           case "medium":
           case "small":
           case "smaller":
           case "x-large":
           case "x-small":
           case "xx-large":
           case "xx-small":
            return FontParser.parseRest(input, void 0, void 0, void 0, void 0, ident);

           case "translate3d":
           case "translateX":
           case "translateY":
           case "translate":
            return math.TranslateTransformParser.parseRest(input, identOutput);

           case "scaleX":
           case "scaleY":
           case "scale":
            return math.ScaleTransformParser.parseRest(input, identOutput);

           case "rotate":
            return math.RotateTransformParser.parseRest(input, identOutput);

           case "skewX":
           case "skewY":
           case "skew":
            return math.SkewTransformParser.parseRest(input, identOutput);

           case "matrix":
            return math.AffineTransformParser.parseRest(input, identOutput);

           case "none":
            return codec.Parser.done(math.Transform.identity());

           case "true":
            return codec.Parser.done(true);

           case "false":
            return codec.Parser.done(false);

           default:
            {
              const color = Color.forName(ident);
              if (color !== null) {
                return codec.Parser.done(color);
              }
              return codec.Parser.error(codec.Diagnostic.message("unknown style value: " + ident, input));
            }
          }
        }
      }
      if (step === 3) {
        if (valueParser === void 0) {
          valueParser = codec.Base10.parseDecimal(input);
        } else {
          valueParser = valueParser.feed(input);
        }
        if (valueParser.isDone()) {
          step = 4;
        } else if (valueParser.isError()) {
          return valueParser.asError();
        }
      }
      if (step === 4) {
        if (input.isCont() && (c = input.head(), c === 45)) {
          input.step();
          const date = {};
          date.year = valueParser.bind();
          return time.DateTimeFormat.pattern("%m-%dT%H:%M:%S.%LZ").parseDate(input, date);
        } else if (!input.isEmpty()) {
          step = 5;
        }
      }
      if (step === 5) {
        unitsOutput = unitsOutput || codec.Unicode.stringOutput();
        while (input.isCont() && (c = input.head(), codec.Unicode.isAlpha(c) || c === 37)) {
          input.step();
          unitsOutput.push(c);
        }
        if (!input.isEmpty()) {
          step = 6;
        }
      }
      if (step === 6) {
        if (!input.isEmpty()) {
          const value = valueParser.bind();
          const units = unitsOutput.bind();
          let styleValue;
          switch (units) {
           case "deg":
            styleValue = math.Angle.deg(value);
            break;

           case "rad":
            styleValue = math.Angle.rad(value);
            break;

           case "grad":
            styleValue = math.Angle.grad(value);
            break;

           case "turn":
            styleValue = math.Angle.turn(value);
            break;

           case "px":
            styleValue = math.Length.px(value);
            break;

           case "em":
            styleValue = math.Length.em(value);
            break;

           case "rem":
            styleValue = math.Length.rem(value);
            break;

           case "%":
            styleValue = math.Length.pct(value);
            break;

           case "":
            styleValue = value;
            break;

           default:
            return codec.Parser.error(codec.Diagnostic.message("unknown style units: " + units, input));
          }
          if (input.isCont() && (c = input.head(), codec.Unicode.isSpace(c) || c === 47)) {
            if (styleValue instanceof math.Length) {
              return FontParser.parseRest(input, void 0, void 0, void 0, void 0, styleValue);
            } else if (typeof styleValue === "number") {
              switch (value) {
               case 100:
               case 200:
               case 300:
               case 400:
               case 500:
               case 600:
               case 700:
               case 800:
               case 900:
                return FontParser.parseRest(input, void 0, void 0, String(value));
              }
            }
          }
          return codec.Parser.done(styleValue);
        }
      }
      return new StyleValueParser(identOutput, valueParser, unitsOutput, step);
    }
  }
  function ToAttributeString(value) {
    if (typeof value === "object" && value !== null) {
      if (typeof value.toAttributeString === "function") {
        return value.toAttributeString();
      } else {
        return value.toString();
      }
    } else {
      return "" + value;
    }
  }
  function ToStyleString(value) {
    if (typeof value === "object" && value !== null) {
      if (typeof value.toStyleString === "function") {
        return value.toStyleString();
      } else {
        return value.toString();
      }
    } else {
      return "" + value;
    }
  }
  const ToCssValue = function() {
    let ToCssValue;
    if (typeof CSSStyleValue !== "undefined") {
      ToCssValue = function(value) {
        if (typeof value === "object" && value !== null && typeof value.toCssValue === "function") {
          return value.toCssValue();
        } else if (typeof value === "number") {
          return new CSSUnitValue(value, "number");
        } else {
          return null;
        }
      };
    } else {
      ToCssValue = ToStyleString;
    }
    return ToCssValue;
  }();
  class LookVector {
    constructor(array, index) {
      this.array = array;
      this.index = index;
    }
    get size() {
      return this.array.length;
    }
    isEmpty() {
      return this.array.length === 0;
    }
    has(feel) {
      if (typeof feel === "object" && feel !== null || typeof feel === "function") {
        feel = feel.name;
      }
      return this.index[feel] !== void 0;
    }
    get(feel) {
      if (typeof feel === "object" && feel !== null || typeof feel === "function") {
        feel = feel.name;
      }
      if (typeof feel === "string") {
        feel = this.index[feel];
      }
      const entry = typeof feel === "number" ? this.array[feel] : void 0;
      return entry !== void 0 ? entry[1] : void 0;
    }
    getOr(feel, elseValue) {
      if (typeof feel === "object" && feel !== null || typeof feel === "function") {
        feel = feel.name;
      }
      if (typeof feel === "string") {
        feel = this.index[feel];
      }
      const entry = typeof feel === "number" ? this.array[feel] : void 0;
      return entry !== void 0 ? entry[1] : elseValue;
    }
    updated(updates, value) {
      let feel;
      let oldArray = this.array;
      let oldIndex = this.index;
      const updateCount = Array.isArray(updates) ? updates.length : 1;
      for (let updateIndex = 0; updateIndex < updateCount; updateIndex += 1) {
        if (updateIndex === 0 && !Array.isArray(updates)) {
          feel = updates;
        } else {
          [feel, value] = updates[updateIndex];
        }
        const i = oldIndex[feel.name];
        if (value !== void 0 && i !== void 0) {
          const newArray = oldArray.slice(0);
          newArray[i] = [ feel, value ];
          oldArray = newArray;
        } else if (value !== void 0) {
          const newArray = oldArray.slice(0);
          const newIndex = {};
          for (const name in oldIndex) {
            newIndex[name] = oldIndex[name];
          }
          newIndex[feel.name] = newArray.length;
          newArray.push([ feel, value ]);
          oldArray = newArray;
          oldIndex = newIndex;
        } else if (i !== void 0) {
          const newArray = new Array;
          const newIndex = {};
          let k = 0;
          for (let j = 0, n = oldArray.length; j < n; j += 1) {
            const entry = oldArray[j];
            if (entry[0] !== feel) {
              newArray[k] = entry;
              newIndex[entry[0].name] = k;
              k += 1;
            }
          }
          oldArray = newArray;
          oldIndex = newIndex;
        }
      }
      {
        return this;
      }
    }
    copy(array, index) {
      return LookVector.fromArray(array, index);
    }
    forEach(callback, thisArg) {
      const array = this.array;
      for (let i = 0, n = array.length; i < n; i += 1) {
        const entry = array[i];
        const result = callback.call(thisArg, entry[1], entry[0]);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof LookVector) {
        return util.Arrays.equal(this.array, that.array);
      }
      return false;
    }
    debug(output) {
      const array = this.array;
      const n = array.length;
      output = output.write("LookVector").write(46).write(n !== 0 ? "of" : "empty").write(40);
      for (let i = 0; i < n; i += 1) {
        const [feel, value] = array[i];
        if (i !== 0) {
          output = output.write(", ");
        }
        output = output.write(91).debug(feel).write(", ").debug(value).write(93);
      }
      output = output.write(41);
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static empty() {
      return new LookVector(util.Arrays.empty, {});
    }
    static of(...feels) {
      return new LookVector(feels, LookVector.index(feels));
    }
    static fromArray(array, index) {
      if (index === void 0) {
        index = LookVector.index(array);
      }
      return new LookVector(array, index);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof LookVector) {
        return value;
      } else if (Array.isArray(value)) {
        return LookVector.fromArray(value);
      }
      throw new TypeError("" + value);
    }
    static index(array) {
      const index = {};
      for (let i = 0, n = array.length; i < n; i += 1) {
        const entry = array[i];
        index[entry[0].name] = i;
      }
      return index;
    }
  }
  __decorate([ util.Lazy ], LookVector, "empty", null);
  class Look {
    constructor(name) {
      this.name = name;
    }
    add(a, b) {
      const aArray = a.array;
      const bArray = b.array;
      const newArray = new Array;
      const newIndex = {};
      for (let i = 0, n = aArray.length; i < n; i += 1) {
        const entry = aArray[i];
        const feel = entry[0];
        const y = b.get(feel);
        newIndex[feel.name] = newArray.length;
        newArray.push(y === void 0 ? entry : [ feel, feel.combine(this, entry[1], y) ]);
      }
      for (let i = 0, n = bArray.length; i < n; i += 1) {
        const entry = bArray[i];
        const feel = entry[0];
        if (newIndex[feel.name] === void 0) {
          newIndex[feel.name] = newArray.length;
          newArray.push(entry);
        }
      }
      return this.fromArray(newArray, newIndex);
    }
    negate(a) {
      const oldArray = a.array;
      const n = oldArray.length;
      const newArray = new Array(n);
      for (let i = 0; i < n; i += 1) {
        const [feel, x] = oldArray[i];
        newArray[i] = [ feel, feel.combine(this, void 0, x, -1) ];
      }
      return this.fromArray(newArray, a.index);
    }
    subtract(a, b) {
      const aArray = a.array;
      const bArray = b.array;
      const newArray = new Array;
      const newIndex = {};
      for (let i = 0, n = aArray.length; i < n; i += 1) {
        const entry = aArray[i];
        const feel = entry[0];
        const y = b.get(feel);
        newIndex[feel.name] = newArray.length;
        newArray.push(y === void 0 ? entry : [ feel, feel.combine(this, entry[1], y, -1) ]);
      }
      for (let i = 0, n = bArray.length; i < n; i += 1) {
        const [feel, y] = bArray[i];
        if (newIndex[feel.name] === void 0) {
          newIndex[feel.name] = newArray.length;
          newArray.push([ feel, feel.combine(this, void 0, y, -1) ]);
        }
      }
      return this.fromArray(newArray, newIndex);
    }
    multiply(a, scalar) {
      const oldArray = a.array;
      const n = oldArray.length;
      const newArray = new Array(n);
      for (let i = 0; i < n; i += 1) {
        const [feel, x] = oldArray[i];
        newArray[i] = [ feel, feel.combine(this, void 0, x, scalar) ];
      }
      return this.fromArray(newArray, a.index);
    }
    dot(a, b) {
      const array = a.array;
      let combination;
      for (let i = 0, n = array.length; i < n; i += 1) {
        const [feel, value] = array[i];
        const weight = b.get(feel);
        if (weight !== void 0 && weight !== 0) {
          combination = feel.combine(this, combination, value, weight);
        }
      }
      return combination;
    }
    dotOr(a, b, elseValue) {
      const array = a.array;
      const n = array.length;
      if (n !== 0) {
        let combination;
        for (let i = 0, n = array.length; i < n; i += 1) {
          const [feel, value] = array[i];
          const weight = b.get(feel);
          if (weight !== void 0 && weight !== 0) {
            combination = feel.combine(this, combination, value, weight);
          }
        }
        return combination;
      } else {
        return elseValue;
      }
    }
    empty() {
      return LookVector.empty();
    }
    of(...feels) {
      const n = feels.length;
      const array = new Array(n);
      const index = {};
      for (let i = 0; i < n; i += 1) {
        const [feel, value] = feels[i];
        array[i] = [ feel, this.coerce(value) ];
        index[feel.name] = i;
      }
      return this.fromArray(array, index);
    }
    fromArray(array, index) {
      return LookVector.fromArray(array, index);
    }
    toString() {
      return "Look" + "." + this.name;
    }
  }
  class NumberLook extends Look {
    combine(combination, value, weight) {
      if (combination !== void 0) {
        if (weight === void 0 || weight === 1) {
          return value;
        } else if (weight === 0) {
          return combination;
        } else {
          return (1 - weight) * combination + weight * value;
        }
      } else if (weight !== void 0 && weight !== 1) {
        return value * weight;
      } else {
        return value;
      }
    }
    between(a, b) {
      return util.NumberInterpolator(a, b);
    }
    coerce(value) {
      return value;
    }
  }
  class LengthLook extends Look {
    combine(combination, value, weight) {
      if (combination !== void 0) {
        if (weight === void 0 || weight === 1) {
          return value;
        } else if (weight === 0) {
          return combination;
        } else {
          return math.LengthInterpolator(combination, value)(weight);
        }
      } else if (weight !== void 0 && weight !== 1) {
        return value.times(weight);
      } else {
        return value;
      }
    }
    between(a, b) {
      return math.LengthInterpolator(a, b);
    }
    coerce(value) {
      return math.Length.fromAny(value);
    }
  }
  class ColorLook extends Look {
    combine(combination, value, weight) {
      if (combination !== void 0) {
        if (weight === void 0 || weight === 1) {
          return value;
        } else if (weight === 0) {
          return combination;
        } else {
          return combination.interpolateTo(value)(weight);
        }
      } else if (weight !== void 0 && weight !== 1) {
        return value.times(weight);
      } else {
        return value;
      }
    }
    between(a, b) {
      return a.interpolateTo(b);
    }
    coerce(value) {
      return Color.fromAny(value);
    }
  }
  class FontLook extends Look {
    combine(combination, value, weight) {
      if (weight === void 0 || weight !== 0) {
        return value;
      } else if (combination !== void 0) {
        return combination;
      } else {
        return Font.family(value.family);
      }
    }
    between(a, b) {
      return FontInterpolator(a, b);
    }
    coerce(value) {
      return Font.fromAny(value);
    }
  }
  class ShadowLook extends Look {
    combine(combination, value, weight) {
      if (weight === void 0 || weight !== 0) {
        return value;
      } else if (combination !== void 0) {
        return combination;
      } else {
        return value;
      }
    }
    between(a, b) {
      return BoxShadowInterpolator(a, b);
    }
    coerce(value) {
      return BoxShadow.fromAny(value);
    }
  }
  class TimingLook extends Look {
    combine(combination, value, weight) {
      if (weight === void 0 || weight !== 0) {
        return value;
      } else if (combination !== void 0) {
        return combination;
      } else {
        return value;
      }
    }
    between(a, b) {
      return util.Interpolator(a, b);
    }
    coerce(value) {
      return util.Timing.fromAny(value);
    }
  }
  class FeelVector {
    constructor(array, index) {
      this.array = array;
      this.index = index;
    }
    get size() {
      return this.array.length;
    }
    isEmpty() {
      return this.array.length === 0;
    }
    has(look) {
      if (typeof look === "object" && look !== null || typeof look === "function") {
        look = look.name;
      }
      return this.index[look] !== void 0;
    }
    get(look) {
      if (typeof look === "object" && look !== null || typeof look === "function") {
        look = look.name;
      }
      if (typeof look === "string") {
        look = this.index[look];
      }
      const entry = typeof look === "number" ? this.array[look] : void 0;
      return entry !== void 0 ? entry[1] : void 0;
    }
    getOr(look, elseValue) {
      if (typeof look === "object" && look !== null || typeof look === "function") {
        look = look.name;
      }
      if (typeof look === "string") {
        look = this.index[look];
      }
      const entry = typeof look === "number" ? this.array[look] : void 0;
      return entry !== void 0 ? entry[1] : elseValue;
    }
    updated(updates, value) {
      let look;
      let oldArray = this.array;
      let oldIndex = this.index;
      const updateCount = Array.isArray(updates) ? updates.length : 1;
      for (let updateIndex = 0; updateIndex < updateCount; updateIndex += 1) {
        if (updateIndex === 0 && !Array.isArray(updates)) {
          look = updates;
        } else {
          [look, value] = updates[updateIndex];
        }
        const i = oldIndex[look.name];
        if (value !== void 0 && i !== void 0) {
          const newArray = oldArray.slice(0);
          newArray[i] = [ look, value ];
          oldArray = newArray;
        } else if (value !== void 0) {
          const newArray = oldArray.slice(0);
          const newIndex = {};
          for (const name in oldIndex) {
            newIndex[name] = oldIndex[name];
          }
          newIndex[look.name] = newArray.length;
          newArray.push([ look, value ]);
          oldArray = newArray;
          oldIndex = newIndex;
        } else if (i !== void 0) {
          const newArray = new Array;
          const newIndex = {};
          let k = 0;
          for (let j = 0, n = oldArray.length; j < n; j += 1) {
            const entry = oldArray[j];
            if (entry[0] !== look) {
              newArray[k] = entry;
              newIndex[entry[0].name] = k;
              k += 1;
            }
          }
          oldArray = newArray;
          oldIndex = newIndex;
        }
      }
      {
        return this;
      }
    }
    plus(that) {
      const thisArray = this.array;
      const thatArray = that.array;
      const newArray = new Array;
      const newIndex = {};
      for (let i = 0, n = thisArray.length; i < n; i += 1) {
        const entry = thisArray[i];
        const look = entry[0];
        const y = that.get(look);
        newIndex[look.name] = newArray.length;
        newArray.push(y === void 0 ? entry : [ look, look.combine(entry[1], y) ]);
      }
      for (let i = 0, n = thatArray.length; i < n; i += 1) {
        const entry = thatArray[i];
        const look = entry[0];
        if (newIndex[look.name] === void 0) {
          newIndex[look.name] = newArray.length;
          newArray.push(entry);
        }
      }
      return this.copy(newArray, newIndex);
    }
    negative() {
      const oldArray = this.array;
      const n = oldArray.length;
      const newArray = new Array(n);
      for (let i = 0; i < n; i += 1) {
        const [look, x] = oldArray[i];
        newArray[i] = [ look, look.combine(void 0, x, -1) ];
      }
      return this.copy(newArray, this.index);
    }
    minus(that) {
      const thisArray = this.array;
      const thatArray = that.array;
      const newArray = new Array;
      const newIndex = {};
      for (let i = 0, n = thisArray.length; i < n; i += 1) {
        const entry = thisArray[i];
        const look = entry[0];
        const y = that.get(look);
        newIndex[look.name] = newArray.length;
        newArray.push(y === void 0 ? entry : [ look, look.combine(entry[1], y, -1) ]);
      }
      for (let i = 0, n = thatArray.length; i < n; i += 1) {
        const [look, y] = thatArray[i];
        if (newIndex[look.name] === void 0) {
          newIndex[look.name] = newArray.length;
          newArray.push([ look, look.combine(void 0, y, -1) ]);
        }
      }
      return this.copy(newArray, newIndex);
    }
    times(scalar) {
      const oldArray = this.array;
      const n = oldArray.length;
      const newArray = new Array(n);
      for (let i = 0; i < n; i += 1) {
        const [look, x] = oldArray[i];
        newArray[i] = [ look, look.combine(void 0, x, scalar) ];
      }
      return this.copy(newArray, this.index);
    }
    copy(array, index) {
      return FeelVector.fromArray(array, index);
    }
    forEach(callback, thisArg) {
      const array = this.array;
      for (let i = 0, n = array.length; i < n; i += 1) {
        const entry = array[i];
        const result = callback.call(thisArg, entry[1], entry[0]);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
    interpolateTo(that) {
      if (that instanceof FeelVector) {
        return FeelVectorInterpolator(this, that);
      } else {
        return null;
      }
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof FeelVector) {
        return util.Arrays.equal(this.array, that.array);
      }
      return false;
    }
    debug(output) {
      const array = this.array;
      const n = array.length;
      output = output.write("FeelVector").write(46).write(n !== 0 ? "of" : "empty").write(40);
      for (let i = 0; i < n; i += 1) {
        const [look, value] = array[i];
        if (i !== 0) {
          output = output.write(", ");
        }
        output = output.write(91).debug(look).write(", ").debug(value).write(93);
      }
      output = output.write(41);
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static empty() {
      return new FeelVector([], {});
    }
    static of(...looks) {
      const n = looks.length;
      const array = new Array(n);
      const index = {};
      for (let i = 0; i < n; i += 1) {
        const [look, value] = looks[i];
        array[i] = [ look, look.coerce(value) ];
        index[look.name] = i;
      }
      return new FeelVector(array, index);
    }
    static fromArray(array, index) {
      if (index === void 0) {
        index = FeelVector.index(array);
      }
      return new FeelVector(array, index);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof FeelVector) {
        return value;
      } else if (Array.isArray(value)) {
        return FeelVector.of(...value);
      }
      throw new TypeError("" + value);
    }
    static index(array) {
      const index = {};
      for (let i = 0, n = array.length; i < n; i += 1) {
        const entry = array[i];
        index[entry[0].name] = i;
      }
      return index;
    }
  }
  __decorate([ util.Lazy ], FeelVector, "empty", null);
  class Feel {
    constructor(name) {
      this.name = name;
    }
    empty() {
      return FeelVector.empty();
    }
    of(...looks) {
      return FeelVector.of(...looks);
    }
    from(array, index) {
      return FeelVector.fromArray(array, index);
    }
    toString() {
      return "Feel" + "." + this.name;
    }
  }
  const FeelVectorInterpolator = function(_super) {
    const FeelVectorInterpolator = function(v0, v1) {
      const interpolator = function(u) {
        const interpolators = interpolator.interpolators;
        const interpolatorCount = interpolators.length;
        const array = new Array(interpolatorCount);
        const index = interpolator.index;
        for (let i = 0; i < interpolatorCount; i += 1) {
          const [look, interpolator] = interpolators[i];
          const value = interpolator(u);
          array[i] = [ look, value ];
        }
        return FeelVector.fromArray(array, index);
      };
      Object.setPrototypeOf(interpolator, FeelVectorInterpolator.prototype);
      const interpolators = new Array;
      const index = {};
      v0.forEach((function(a, look) {
        const b = v1.get(look);
        if (b !== void 0) {
          const interpolator = look.between(a, b);
          index[look.name] = interpolators.length;
          interpolators.push([ look, interpolator ]);
        }
      }));
      interpolator.interpolators = interpolators;
      interpolator.index = index;
      return interpolator;
    };
    FeelVectorInterpolator.prototype = Object.create(_super.prototype);
    FeelVectorInterpolator.prototype.constructor = FeelVectorInterpolator;
    Object.defineProperty(FeelVectorInterpolator.prototype, 0, {
      get() {
        const interpolators = this.interpolators;
        const interpolatorCount = interpolators.length;
        const array = new Array(interpolatorCount);
        const index = this.index;
        for (let i = 0; i < interpolatorCount; i += 1) {
          const [look, interpolator] = interpolators[i];
          const value = interpolator[0];
          array[i] = [ look, value ];
        }
        return FeelVector.fromArray(array, index);
      },
      configurable: true
    });
    Object.defineProperty(FeelVectorInterpolator.prototype, 1, {
      get() {
        const interpolators = this.interpolators;
        const interpolatorCount = interpolators.length;
        const array = new Array(interpolatorCount);
        const index = this.index;
        for (let i = 0; i < interpolatorCount; i += 1) {
          const [look, interpolator] = interpolators[i];
          const value = interpolator[1];
          array[i] = [ look, value ];
        }
        return FeelVector.fromArray(array, index);
      },
      configurable: true
    });
    FeelVectorInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof FeelVectorInterpolator) {
        const n = this.interpolators.length;
        if (n === that.interpolators.length) {
          for (let i = 0; i < n; i += 1) {
            if (!util.Arrays.equal(this.interpolators[i], that.interpolators[i])) {
              return false;
            }
          }
          return true;
        }
      }
      return false;
    };
    return FeelVectorInterpolator;
  }(util.Interpolator);
  class InterpolatedFeel extends Feel {
    combine(look, combination, value, weight) {
      return look.combine(combination, value, weight);
    }
  }
  class BrightnessFeel extends Feel {
    combine(look, combination, value, weight) {
      if (combination instanceof Color && value instanceof Color) {
        const amount = weight === void 0 ? value.alpha() : value.alpha() * weight;
        if (amount >= 0) {
          return combination.darker(amount);
        } else {
          return combination.lighter(-amount);
        }
      } else {
        return look.combine(combination, value, weight);
      }
    }
  }
  class OpacityFeel extends Feel {
    combine(look, combination, value, weight) {
      if (combination instanceof Color && value instanceof Color) {
        if (weight === void 0 || weight === 1) {
          return combination.alpha(value.alpha());
        } else if (weight === 0) {
          return combination;
        } else {
          const alpha = (1 - weight) * combination.alpha() + weight * value.alpha();
          return combination.alpha(alpha);
        }
      } else {
        return look.combine(combination, value, weight);
      }
    }
  }
  const Mood = {};
  class MoodVector {
    constructor(array, index) {
      this.array = array;
      this.index = index;
    }
    get size() {
      return this.array.length;
    }
    isEmpty() {
      return this.array.length === 0;
    }
    has(key) {
      if (typeof key === "object" && key !== null || typeof key === "function") {
        key = key.name;
      }
      return this.index[key] !== void 0;
    }
    get(key) {
      if (typeof key === "object" && key !== null || typeof key === "function") {
        key = key.name;
      }
      if (typeof key === "string") {
        key = this.index[key];
      }
      const entry = typeof key === "number" ? this.array[key] : void 0;
      return entry !== void 0 ? entry[1] : void 0;
    }
    getOr(key, elseValue) {
      if (typeof key === "object" && key !== null || typeof key === "function") {
        key = key.name;
      }
      if (typeof key === "string") {
        key = this.index[key];
      }
      const entry = typeof key === "number" ? this.array[key] : void 0;
      return entry !== void 0 ? entry[1] : elseValue;
    }
    updated(updates, value) {
      let key;
      let oldArray = this.array;
      let oldIndex = this.index;
      let newArray;
      let newIndex;
      const updateCount = Array.isArray(updates) ? updates.length : 1;
      for (let updateIndex = 0; updateIndex < updateCount; updateIndex += 1) {
        if (updateIndex === 0 && !Array.isArray(updates)) {
          key = updates;
        } else {
          [key, value] = updates[updateIndex];
        }
        const i = oldIndex[key.name];
        if (value !== void 0 && i !== void 0) {
          newArray = oldArray.slice(0);
          newIndex = oldIndex;
          newArray[i] = [ key, value ];
          oldArray = newArray;
        } else if (value !== void 0) {
          newArray = oldArray.slice(0);
          newIndex = {};
          for (const name in oldIndex) {
            newIndex[name] = oldIndex[name];
          }
          newIndex[key.name] = newArray.length;
          newArray.push([ key, value ]);
          oldArray = newArray;
          oldIndex = newIndex;
        } else if (i !== void 0) {
          newArray = new Array;
          newIndex = {};
          let k = 0;
          for (let j = 0, n = oldArray.length; j < n; j += 1) {
            const entry = oldArray[j];
            if (entry[0] !== key) {
              newArray[k] = entry;
              newIndex[entry[0].name] = k;
              k += 1;
            }
          }
          oldArray = newArray;
          oldIndex = newIndex;
        }
      }
      if (newArray !== void 0 && newIndex !== void 0) {
        return this.copy(newArray, newIndex);
      } else {
        return this;
      }
    }
    plus(that) {
      const thisArray = this.array;
      const thatArray = that.array;
      const newArray = new Array;
      const newIndex = {};
      for (let i = 0, n = thisArray.length; i < n; i += 1) {
        const entry = thisArray[i];
        const key = entry[0];
        const y = that.get(key);
        newIndex[key.name] = newArray.length;
        newArray.push(y === void 0 ? entry : [ key, entry[1] + y ]);
      }
      for (let i = 0, n = thatArray.length; i < n; i += 1) {
        const entry = thatArray[i];
        const key = entry[0];
        if (newIndex[key.name] === void 0) {
          newIndex[key.name] = newArray.length;
          newArray.push(entry);
        }
      }
      return this.copy(newArray, newIndex);
    }
    negative() {
      const oldArray = this.array;
      const n = oldArray.length;
      const newArray = new Array(n);
      for (let i = 0; i < n; i += 1) {
        const [key, x] = oldArray[i];
        newArray[i] = [ key, -x ];
      }
      return this.copy(newArray, this.index);
    }
    minus(that) {
      const thisArray = this.array;
      const thatArray = that.array;
      const newArray = new Array;
      const newIndex = {};
      for (let i = 0, n = thisArray.length; i < n; i += 1) {
        const entry = thisArray[i];
        const key = entry[0];
        const y = that.get(key);
        newIndex[key.name] = newArray.length;
        newArray.push(y === void 0 ? entry : [ key, entry[1] - y ]);
      }
      for (let i = 0, n = thatArray.length; i < n; i += 1) {
        const [key, y] = thatArray[i];
        if (newIndex[key.name] === void 0) {
          newIndex[key.name] = newArray.length;
          newArray.push([ key, -y ]);
        }
      }
      return this.copy(newArray, newIndex);
    }
    times(scalar) {
      const oldArray = this.array;
      const n = oldArray.length;
      const newArray = new Array(n);
      for (let i = 0; i < n; i += 1) {
        const [key, x] = oldArray[i];
        newArray[i] = [ key, x * scalar ];
      }
      return this.copy(newArray, this.index);
    }
    dot(that) {
      const array = this.array;
      let combination;
      for (let i = 0, n = array.length; i < n; i += 1) {
        const [key, x] = array[i];
        const y = that.get(key);
        if (y !== void 0) {
          if (combination === void 0) {
            combination = x * y;
          } else {
            combination += x * y;
          }
        }
      }
      return combination;
    }
    copy(array, index) {
      return MoodVector.fromArray(array, index);
    }
    forEach(callback, thisArg) {
      const array = this.array;
      for (let i = 0, n = array.length; i < n; i += 1) {
        const entry = array[i];
        const result = callback.call(thisArg, entry[1], entry[0]);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof MoodVector) {
        return util.Arrays.equal(this.array, that.array);
      }
      return false;
    }
    debug(output) {
      const array = this.array;
      const n = array.length;
      output = output.write("MoodVector").write(46).write(n !== 0 ? "of" : "empty").write(40);
      for (let i = 0; i < n; i += 1) {
        const [key, value] = array[i];
        if (i !== 0) {
          output = output.write(", ");
        }
        output = output.write(91).debug(key).write(", ").debug(value).write(93);
      }
      output = output.write(41);
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static empty() {
      return new MoodVector([], {});
    }
    static of(...keys) {
      return new MoodVector(keys, MoodVector.index(keys));
    }
    static fromArray(array, index) {
      if (index === void 0) {
        index = MoodVector.index(array);
      }
      return new MoodVector(array, index);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof MoodVector) {
        return value;
      } else if (Array.isArray(value)) {
        return MoodVector.fromArray(value);
      }
      throw new TypeError("" + value);
    }
    static index(array) {
      const index = {};
      for (let i = 0, n = array.length; i < n; i += 1) {
        const entry = array[i];
        index[entry[0].name] = i;
      }
      return index;
    }
  }
  __decorate([ util.Lazy ], MoodVector, "empty", null);
  class MoodMatrix {
    constructor(rowArray, rowIndex, colArray, colIndex) {
      this.rowArray = rowArray;
      this.rowIndex = rowIndex;
      this.colArray = colArray;
      this.colIndex = colIndex;
    }
    get rowCount() {
      return this.rowArray.length;
    }
    get colCount() {
      return this.colArray.length;
    }
    hasRow(rowKey) {
      if (typeof rowKey === "object" && rowKey !== null || typeof rowKey === "function") {
        rowKey = rowKey.name;
      }
      return this.rowIndex[rowKey] !== void 0;
    }
    hasCol(colKey) {
      if (typeof colKey === "object" && colKey !== null || typeof colKey === "function") {
        colKey = colKey.name;
      }
      return this.colIndex[colKey] !== void 0;
    }
    getRow(rowKey) {
      if (typeof rowKey === "object" && rowKey !== null || typeof rowKey === "function") {
        rowKey = rowKey.name;
      }
      if (typeof rowKey === "string") {
        rowKey = this.rowIndex[rowKey];
      }
      const entry = typeof rowKey === "number" ? this.rowArray[rowKey] : void 0;
      return entry !== void 0 ? entry[1] : void 0;
    }
    getCol(colKey) {
      if (typeof colKey === "object" && colKey !== null || typeof colKey === "function") {
        colKey = colKey.name;
      }
      if (typeof colKey === "string") {
        colKey = this.colIndex[colKey];
      }
      const entry = typeof colKey === "number" ? this.colArray[colKey] : void 0;
      return entry !== void 0 ? entry[1] : void 0;
    }
    plus(that) {
      const thisColArray = this.colArray;
      const thatColArray = that.colArray;
      const newColArray = new Array;
      const newColIndex = {};
      for (let j = 0, n = thisColArray.length; j < n; j += 1) {
        const entry = thisColArray[j];
        const colKey = entry[0];
        const b = that.getCol(colKey);
        newColIndex[colKey.name] = newColArray.length;
        newColArray.push(b === void 0 ? entry : [ colKey, entry[1].plus(b) ]);
      }
      for (let j = 0, n = thatColArray.length; j < n; j += 1) {
        const entry = thatColArray[j];
        const colKey = entry[0];
        if (newColIndex[colKey.name] === void 0) {
          newColIndex[colKey.name] = newColArray.length;
          newColArray.push(entry);
        }
      }
      return MoodMatrix.fromColArray(newColArray, newColIndex);
    }
    negative() {
      const oldColArray = this.colArray;
      const n = oldColArray.length;
      const newColArray = new Array(n);
      for (let j = 0; j < n; j += 1) {
        const [colKey, a] = oldColArray[j];
        newColArray[j] = [ colKey, a.negative() ];
      }
      return MoodMatrix.fromColArray(newColArray, this.colIndex);
    }
    minus(that) {
      const thisColArray = this.colArray;
      const thatColArray = that.colArray;
      const newColArray = new Array;
      const newColIndex = {};
      for (let j = 0, n = thisColArray.length; j < n; j += 1) {
        const entry = thisColArray[j];
        const colKey = entry[0];
        const b = that.getCol(colKey);
        newColIndex[colKey.name] = newColArray.length;
        newColArray.push(b === void 0 ? entry : [ colKey, entry[1].minus(b) ]);
      }
      for (let j = 0, n = thatColArray.length; j < n; j += 1) {
        const [colKey, b] = thatColArray[j];
        if (newColIndex[colKey.name] === void 0) {
          newColIndex[colKey.name] = newColArray.length;
          newColArray.push([ colKey, b.negative() ]);
        }
      }
      return MoodMatrix.fromColArray(newColArray, newColIndex);
    }
    times(scalar) {
      const oldColArray = this.colArray;
      const n = oldColArray.length;
      const newColArray = new Array(n);
      for (let j = 0; j < n; j += 1) {
        const [colKey, a] = oldColArray[j];
        newColArray[j] = [ colKey, a.times(scalar) ];
      }
      return MoodMatrix.fromColArray(newColArray, this.colIndex);
    }
    dot(rowKey, col) {
      if (typeof rowKey === "object" && rowKey !== null || typeof rowKey === "function") {
        rowKey = rowKey.name;
      }
      if (typeof rowKey === "string") {
        rowKey = this.rowIndex[rowKey];
      }
      const entry = typeof rowKey === "number" ? this.rowArray[rowKey] : void 0;
      if (entry !== void 0) {
        rowKey = entry[0];
        const row = entry[1];
        return row.dot(col);
      }
      return void 0;
    }
    timesCol(col, implicitIdentity = false) {
      const rowArray = this.rowArray;
      const newArray = new Array;
      const newIndex = {};
      for (let i = 0, m = rowArray.length; i < m; i += 1) {
        const [rowKey, row] = rowArray[i];
        const value = row.dot(col);
        if (value !== void 0) {
          newIndex[rowKey.name] = newArray.length;
          newArray.push([ rowKey, value ]);
        }
      }
      if (implicitIdentity) {
        const thatArray = col.array;
        for (let i = 0, m = thatArray.length; i < m; i += 1) {
          const rowKey = thatArray[i][0];
          if (!this.hasRow(rowKey)) {
            newIndex[rowKey.name] = newArray.length;
            newArray.push(thatArray[i]);
          }
        }
      }
      return MoodVector.fromArray(newArray, newIndex);
    }
    timesRow(row, implicitIdentity = false) {
      const colArray = this.colArray;
      const newArray = new Array;
      const newIndex = {};
      for (let i = 0, n = colArray.length; i < n; i += 1) {
        const [colKey, col] = colArray[i];
        const value = row.dot(col);
        if (value !== void 0) {
          newIndex[colKey.name] = newArray.length;
          newArray.push([ colKey, value ]);
        }
      }
      if (implicitIdentity) {
        const thatArray = row.array;
        for (let i = 0, n = thatArray.length; i < n; i += 1) {
          const colKey = thatArray[i][0];
          if (!this.hasCol(colKey)) {
            newIndex[colKey.name] = newArray.length;
            newArray.push(thatArray[i]);
          }
        }
      }
      return MoodVector.fromArray(newArray, newIndex);
    }
    transform(that, implicitIdentity = true) {
      const thisRowArray = this.rowArray;
      const thisColArray = this.colArray;
      const newRowArray = new Array;
      const newRowIndex = {};
      const newColArray = new Array;
      const newColIndex = {};
      for (let j = 0, n = thisColArray.length; j < n; j += 1) {
        const colKey = thisColArray[j][0];
        let col = that.getCol(colKey);
        if (col === void 0 && implicitIdentity) {
          col = MoodVector.of([ colKey, 1 ]);
        }
        if (col !== void 0) {
          for (let i = 0, m = thisRowArray.length; i < m; i += 1) {
            const [rowKey, row] = thisRowArray[i];
            const value = row.dot(col);
            if (value !== void 0) {
              const i2 = newRowIndex[rowKey.name];
              if (i2 !== void 0) {
                const newRow = newRowArray[i2][1];
                newRow.index[rowKey.name] = newRow.array.length;
                newRow.array.push([ colKey, value ]);
              } else {
                newRowIndex[rowKey.name] = newRowArray.length;
                newRowArray.push([ rowKey, MoodVector.of([ colKey, value ]) ]);
              }
              const j2 = newColIndex[colKey.name];
              if (j2 !== void 0) {
                const newCol = newColArray[j2][1];
                newCol.index[colKey.name] = newCol.array.length;
                newCol.array.push([ rowKey, value ]);
              } else {
                newColIndex[colKey.name] = newColArray.length;
                newColArray.push([ colKey, MoodVector.of([ rowKey, value ]) ]);
              }
            }
          }
        }
      }
      return new MoodMatrix(newRowArray, newRowIndex, newColArray, newColIndex);
    }
    identityFor(that) {
      const thisRowArray = this.rowArray;
      const thatColArray = that.colArray;
      let newRowArray;
      let newRowIndex;
      for (let j = 0, n = thatColArray.length; j < n; j += 1) {
        const colKey = thatColArray[j][0];
        if (!this.hasRow(colKey)) {
          if (newRowArray === void 0) {
            newRowArray = thisRowArray.slice(0);
          }
          if (newRowIndex === void 0) {
            newRowIndex = {};
            for (const name in this.rowIndex) {
              newRowIndex[name] = this.rowIndex[name];
            }
          }
          newRowIndex[colKey.name] = newRowArray.length;
          newRowArray.push([ colKey, MoodVector.of([ colKey, 1 ]) ]);
        }
      }
      if (newRowArray !== void 0 && newRowIndex !== void 0) {
        return MoodMatrix.fromRowArray(newRowArray, newRowIndex);
      } else {
        return this;
      }
    }
    row(rowKey, row) {
      if (row !== void 0) {
        row = MoodVector.fromAny(row);
      }
      const oldRowArray = this.rowArray;
      const oldRowIndex = this.rowIndex;
      const i = oldRowIndex[rowKey.name];
      if (row !== void 0 && i !== void 0) {
        const newRowArray = oldRowArray.slice(0);
        newRowArray[i] = [ rowKey, row ];
        return MoodMatrix.fromRowArray(newRowArray, oldRowIndex);
      } else if (row !== void 0) {
        const newRowArray = oldRowArray.slice(0);
        const newRowIndex = {};
        for (const name in oldRowIndex) {
          newRowIndex[name] = oldRowIndex[name];
        }
        newRowIndex[rowKey.name] = newRowArray.length;
        newRowArray.push([ rowKey, row ]);
        return MoodMatrix.fromRowArray(newRowArray, newRowIndex);
      } else if (i !== void 0) {
        const newRowArray = new Array;
        const newRowIndex = {};
        let k = 0;
        for (let j = 0, n = oldRowArray.length; j < n; j += 1) {
          const entry = oldRowArray[j];
          if (entry[0] !== rowKey) {
            newRowArray[k] = entry;
            newRowIndex[entry[0].name] = k;
            k += 1;
          }
        }
        return MoodMatrix.fromRowArray(newRowArray, newRowIndex);
      } else {
        return this;
      }
    }
    col(colKey, col) {
      if (col !== void 0) {
        col = MoodVector.fromAny(col);
      }
      const oldColArray = this.colArray;
      const oldColIndex = this.colIndex;
      const i = oldColIndex[colKey.name];
      if (col !== void 0 && i !== void 0) {
        const newColArray = oldColArray.slice(0);
        newColArray[i] = [ colKey, col ];
        return MoodMatrix.fromColArray(newColArray, oldColIndex);
      } else if (col !== void 0) {
        const newColArray = oldColArray.slice(0);
        const newColIndex = {};
        for (const name in oldColIndex) {
          newColIndex[name] = oldColIndex[name];
        }
        newColIndex[colKey.name] = newColArray.length;
        newColArray.push([ colKey, col ]);
        return MoodMatrix.fromColArray(newColArray, newColIndex);
      } else if (i !== void 0) {
        const newColArray = new Array;
        const newColIndex = {};
        let k = 0;
        for (let j = 0, n = oldColArray.length; j < n; j += 1) {
          const entry = oldColArray[j];
          if (entry[0] !== colKey) {
            newColArray[k] = entry;
            newColIndex[entry[0].name] = k;
            k += 1;
          }
        }
        return MoodMatrix.fromColArray(newColArray, newColIndex);
      } else {
        return this;
      }
    }
    updatedRow(rowKey, updates, defaultRow) {
      const oldRow = this.getRow(rowKey);
      let newRow = oldRow;
      if (newRow === void 0) {
        if (defaultRow === true) {
          defaultRow = MoodVector.of([ rowKey, 1 ]);
        } else if (defaultRow === false) {
          defaultRow = void 0;
        }
        if (defaultRow !== void 0) {
          defaultRow = MoodVector.fromAny(defaultRow);
        } else {
          defaultRow = MoodVector.empty();
        }
        newRow = defaultRow;
      }
      newRow = newRow.updated(updates);
      if (!newRow.equals(oldRow)) {
        return this.row(rowKey, newRow);
      } else {
        return this;
      }
    }
    updatedCol(colKey, updates, defaultCol) {
      const oldCol = this.getCol(colKey);
      let newCol = oldCol;
      if (newCol === void 0) {
        if (defaultCol === true) {
          defaultCol = MoodVector.of([ colKey, 1 ]);
        } else if (defaultCol === false) {
          defaultCol = void 0;
        }
        if (defaultCol !== void 0) {
          defaultCol = MoodVector.fromAny(defaultCol);
        } else {
          defaultCol = MoodVector.empty();
        }
        newCol = defaultCol;
      }
      newCol = newCol.updated(updates);
      if (!newCol.equals(oldCol)) {
        return this.col(colKey, newCol);
      } else {
        return this;
      }
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof MoodMatrix) {
        const equal = util.Arrays.equal(this.colArray, that.colArray);
        return equal;
      }
      return false;
    }
    debug(output) {
      const cols = this.colArray;
      const n = cols.length;
      output = output.write("MoodMatrix").write(46).write(n !== 0 ? "forCols" : "empty").write(40);
      for (let j = 0; j < n; j += 1) {
        const [colKey, col] = cols[j];
        if (j !== 0) {
          output = output.write(", ");
        }
        output = output.write(91).debug(colKey).write(", ").debug(col).write(93);
      }
      output = output.write(41);
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static empty() {
      return new MoodMatrix([], {}, [], {});
    }
    static forRows(...rows) {
      const m = rows.length;
      const rowArray = new Array(m);
      for (let i = 0; i < m; i += 1) {
        const [rowKey, row] = rows[i];
        rowArray[i] = [ rowKey, MoodVector.fromAny(row) ];
      }
      return this.fromRowArray(rowArray);
    }
    static forCols(...cols) {
      const m = cols.length;
      const colArray = new Array(m);
      for (let j = 0; j < m; j += 1) {
        const [colKey, col] = cols[j];
        colArray[j] = [ colKey, MoodVector.fromAny(col) ];
      }
      return this.fromColArray(colArray);
    }
    static fromRowArray(rowArray, rowIndex) {
      if (rowIndex === void 0) {
        rowIndex = MoodVector.index(rowArray);
      }
      const colArray = new Array;
      const colIndex = {};
      for (let i = 0, m = rowArray.length; i < m; i += 1) {
        const row = rowArray[i][1];
        row.forEach((function(value, colKey) {
          if (colIndex[colKey.name] === void 0) {
            colIndex[colKey.name] = colArray.length;
            colArray.push([ colKey, void 0 ]);
          }
        }), this);
      }
      for (let j = 0, n = colArray.length; j < n; j += 1) {
        const entry = colArray[j];
        const colKey = entry[0];
        const array = new Array;
        const index = {};
        for (let i = 0, m = rowArray.length; i < m; i += 1) {
          const [rowKey, row] = rowArray[i];
          const value = row.get(colKey);
          if (value !== void 0) {
            index[rowKey.name] = array.length;
            array.push([ rowKey, value ]);
          }
        }
        const col = MoodVector.fromArray(array, index);
        entry[1] = col;
      }
      return new MoodMatrix(rowArray, rowIndex, colArray, colIndex);
    }
    static fromColArray(colArray, colIndex) {
      if (colIndex === void 0) {
        colIndex = MoodVector.index(colArray);
      }
      const rowArray = new Array;
      const rowIndex = {};
      for (let i = 0, n = colArray.length; i < n; i += 1) {
        const col = colArray[i][1];
        col.forEach((function(value, rowKey) {
          if (rowIndex[rowKey.name] === void 0) {
            rowIndex[rowKey.name] = rowArray.length;
            rowArray.push([ rowKey, void 0 ]);
          }
        }), this);
      }
      for (let i = 0, m = rowArray.length; i < m; i += 1) {
        const entry = rowArray[i];
        const rowKey = entry[0];
        const array = new Array;
        const index = {};
        for (let j = 0, n = colArray.length; j < n; j += 1) {
          const [colKey, col] = colArray[j];
          const value = col.get(rowKey);
          if (value !== void 0) {
            index[colKey.name] = array.length;
            array.push([ colKey, value ]);
          }
        }
        const row = MoodVector.fromArray(array, index);
        entry[1] = row;
      }
      return new MoodMatrix(rowArray, rowIndex, colArray, colIndex);
    }
  }
  __decorate([ util.Lazy ], MoodMatrix, "empty", null);
  const Theme = {};
  class ThemeMatrix {
    constructor(rowArray, rowIndex, colArray, colIndex) {
      this.rowArray = rowArray;
      this.rowIndex = rowIndex;
      this.colArray = colArray;
      this.colIndex = colIndex;
    }
    get rowCount() {
      return this.rowArray.length;
    }
    get colCount() {
      return this.colArray.length;
    }
    hasRow(look) {
      if (typeof look === "object" && look !== null || typeof look === "function") {
        look = look.name;
      }
      return this.rowIndex[look] !== void 0;
    }
    hasCol(feel) {
      if (typeof feel === "object" && feel !== null || typeof feel === "function") {
        feel = feel.name;
      }
      return this.colIndex[feel] !== void 0;
    }
    getRow(look) {
      if (typeof look === "object" && look !== null || typeof look === "function") {
        look = look.name;
      }
      if (typeof look === "string") {
        look = this.rowIndex[look];
      }
      const entry = typeof look === "number" ? this.rowArray[look] : void 0;
      return entry !== void 0 ? entry[1] : void 0;
    }
    getCol(feel) {
      if (typeof feel === "object" && feel !== null || typeof feel === "function") {
        feel = feel.name;
      }
      if (typeof feel === "string") {
        feel = this.colIndex[feel];
      }
      const entry = typeof feel === "number" ? this.colArray[feel] : void 0;
      return entry !== void 0 ? entry[1] : void 0;
    }
    get(look, mood) {
      return this.dot(look, mood);
    }
    getOr(look, mood, elseValue) {
      return this.dotOr(look, mood, elseValue);
    }
    plus(that) {
      const thisColArray = this.colArray;
      const thatColArray = that.colArray;
      const newColArray = new Array;
      const newColIndex = {};
      for (let j = 0, n = thisColArray.length; j < n; j += 1) {
        const entry = thisColArray[j];
        const feel = entry[0];
        const b = that.getCol(feel);
        newColIndex[feel.name] = newColArray.length;
        newColArray.push(b === void 0 ? entry : [ feel, entry[1].plus(b) ]);
      }
      for (let j = 0, n = thatColArray.length; j < n; j += 1) {
        const entry = thatColArray[j];
        const feel = entry[0];
        if (newColIndex[feel.name] === void 0) {
          newColIndex[feel.name] = newColArray.length;
          newColArray.push(entry);
        }
      }
      return ThemeMatrix.fromColArray(newColArray, newColIndex);
    }
    negative() {
      const oldColArray = this.colArray;
      const n = oldColArray.length;
      const newColArray = new Array(n);
      for (let j = 0; j < n; j += 1) {
        const [feel, a] = oldColArray[j];
        newColArray[j] = [ feel, a.negative() ];
      }
      return ThemeMatrix.fromColArray(newColArray, this.colIndex);
    }
    minus(that) {
      const thisColArray = this.colArray;
      const thatColArray = that.colArray;
      const newColArray = new Array;
      const newColIndex = {};
      for (let j = 0, n = thisColArray.length; j < n; j += 1) {
        const entry = thisColArray[j];
        const feel = entry[0];
        const b = that.getCol(feel);
        newColIndex[feel.name] = newColArray.length;
        newColArray.push(b === void 0 ? entry : [ feel, entry[1].minus(b) ]);
      }
      for (let j = 0, n = thatColArray.length; j < n; j += 1) {
        const [feel, b] = thatColArray[j];
        if (newColIndex[feel.name] === void 0) {
          newColIndex[feel.name] = newColArray.length;
          newColArray.push([ feel, b.negative() ]);
        }
      }
      return ThemeMatrix.fromColArray(newColArray, newColIndex);
    }
    times(scalar) {
      const oldColArray = this.colArray;
      const n = oldColArray.length;
      const newColArray = new Array(n);
      for (let j = 0; j < n; j += 1) {
        const [feel, a] = oldColArray[j];
        newColArray[j] = [ feel, a.times(scalar) ];
      }
      return ThemeMatrix.fromColArray(newColArray, this.colIndex);
    }
    dot(look, col) {
      if (typeof look === "object" && look !== null || typeof look === "function") {
        look = look.name;
      }
      if (typeof look === "string") {
        look = this.rowIndex[look];
      }
      const entry = typeof look === "number" ? this.rowArray[look] : void 0;
      if (entry !== void 0) {
        look = entry[0];
        const row = entry[1];
        return look.dot(row, col);
      }
      return void 0;
    }
    dotOr(look, col, elseValue) {
      if (typeof look === "object" && look !== null || typeof look === "function") {
        look = look.name;
      }
      if (typeof look === "string") {
        look = this.rowIndex[look];
      }
      const entry = typeof look === "number" ? this.rowArray[look] : void 0;
      if (entry !== void 0) {
        look = entry[0];
        const row = entry[1];
        return look.dotOr(row, col, elseValue);
      }
      return elseValue;
    }
    timesCol(col) {
      const rowArray = this.rowArray;
      const newArray = new Array;
      const newIndex = {};
      for (let i = 0, m = rowArray.length; i < m; i += 1) {
        const [look, row] = rowArray[i];
        const value = look.dot(row, col);
        if (value !== void 0) {
          newIndex[look.name] = newArray.length;
          newArray.push([ look, value ]);
        }
      }
      return FeelVector.fromArray(newArray, newIndex);
    }
    transform(that, implicitIdentity = true) {
      const thisRowArray = this.rowArray;
      const thisColArray = this.colArray;
      const newRowArray = new Array;
      const newRowIndex = {};
      const newColArray = new Array;
      const newColIndex = {};
      for (let j = 0, n = thisColArray.length; j < n; j += 1) {
        const feel = thisColArray[j][0];
        let col = that.getCol(feel);
        if (col === void 0 && implicitIdentity) {
          col = MoodVector.of([ feel, 1 ]);
        }
        if (col !== void 0) {
          for (let i = 0, m = thisRowArray.length; i < m; i += 1) {
            const [look, row] = thisRowArray[i];
            const value = look.dot(row, col);
            if (value !== void 0) {
              const i2 = newRowIndex[look.name];
              if (i2 !== void 0) {
                const newRow = newRowArray[i2][1];
                newRow.index[look.name] = newRow.array.length;
                newRow.array.push([ feel, value ]);
              } else {
                newRowIndex[look.name] = newRowArray.length;
                newRowArray.push([ look, LookVector.of([ feel, value ]) ]);
              }
              const j2 = newColIndex[feel.name];
              if (j2 !== void 0) {
                const newCol = newColArray[j2][1];
                newCol.index[feel.name] = newCol.array.length;
                newCol.array.push([ look, value ]);
              } else {
                newColIndex[feel.name] = newColArray.length;
                newColArray.push([ feel, FeelVector.of([ look, value ]) ]);
              }
            }
          }
        }
      }
      return new ThemeMatrix(newRowArray, newRowIndex, newColArray, newColIndex);
    }
    row(look, row) {
      if (row !== void 0) {
        row = LookVector.fromAny(row);
      }
      const oldRowArray = this.rowArray;
      const oldRowIndex = this.rowIndex;
      const i = oldRowIndex[look.name];
      if (row !== void 0 && i !== void 0) {
        const newRowArray = oldRowArray.slice(0);
        newRowArray[i] = [ look, row ];
        return ThemeMatrix.fromRowArray(newRowArray, oldRowIndex);
      } else if (row !== void 0) {
        const newRowArray = oldRowArray.slice(0);
        const newRowIndex = {};
        for (const name in oldRowIndex) {
          newRowIndex[name] = oldRowIndex[name];
        }
        newRowIndex[look.name] = newRowArray.length;
        newRowArray.push([ look, row ]);
        return ThemeMatrix.fromRowArray(newRowArray, newRowIndex);
      } else if (i !== void 0) {
        const newRowArray = new Array;
        const newRowIndex = {};
        let k = 0;
        for (let j = 0, n = oldRowArray.length; j < n; j += 1) {
          const entry = oldRowArray[j];
          if (entry[0] !== look) {
            newRowArray[k] = entry;
            newRowIndex[entry[0].name] = k;
            k += 1;
          }
        }
        return ThemeMatrix.fromRowArray(newRowArray, newRowIndex);
      } else {
        return this;
      }
    }
    col(feel, col) {
      if (col !== void 0) {
        col = FeelVector.fromAny(col);
      }
      const oldColArray = this.colArray;
      const oldColIndex = this.colIndex;
      const i = oldColIndex[feel.name];
      if (col !== void 0 && i !== void 0) {
        const newColArray = oldColArray.slice(0);
        newColArray[i] = [ feel, col ];
        return ThemeMatrix.fromColArray(newColArray, oldColIndex);
      } else if (col !== void 0) {
        const newColArray = oldColArray.slice(0);
        const newColIndex = {};
        for (const name in oldColIndex) {
          newColIndex[name] = oldColIndex[name];
        }
        newColIndex[feel.name] = newColArray.length;
        newColArray.push([ feel, col ]);
        return ThemeMatrix.fromColArray(newColArray, newColIndex);
      } else if (i !== void 0) {
        const newColArray = new Array;
        const newColIndex = {};
        let k = 0;
        for (let j = 0, n = oldColArray.length; j < n; j += 1) {
          const entry = oldColArray[j];
          if (entry[0] !== feel) {
            newColArray[k] = entry;
            newColIndex[entry[0].name] = k;
            k += 1;
          }
        }
        return ThemeMatrix.fromColArray(newColArray, newColIndex);
      } else {
        return this;
      }
    }
    updatedRow(look, updates, defaultRow) {
      const oldRow = this.getRow(look);
      let newRow = oldRow;
      if (newRow === void 0) {
        if (defaultRow !== void 0) {
          defaultRow = LookVector.fromAny(defaultRow);
        } else {
          defaultRow = LookVector.empty();
        }
        newRow = defaultRow;
      }
      newRow = newRow.updated(updates);
      if (!newRow.equals(oldRow)) {
        return this.row(look, newRow);
      } else {
        return this;
      }
    }
    updatedCol(feel, updates, defaultCol) {
      const oldCol = this.getCol(feel);
      let newCol = oldCol;
      if (newCol === void 0) {
        if (defaultCol !== void 0) {
          defaultCol = FeelVector.fromAny(defaultCol);
        } else {
          defaultCol = FeelVector.empty();
        }
        newCol = defaultCol;
      }
      newCol = newCol.updated(updates);
      if (!newCol.equals(oldCol)) {
        return this.col(feel, newCol);
      } else {
        return this;
      }
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof ThemeMatrix) {
        return util.Arrays.equal(this.colArray, that.colArray);
      }
      return false;
    }
    debug(output) {
      const cols = this.colArray;
      const n = cols.length;
      output = output.write("ThemeMatrix").write(46).write(n !== 0 ? "forCols" : "empty").write(40);
      for (let j = 0; j < n; j += 1) {
        const [feel, col] = cols[j];
        if (j !== 0) {
          output = output.write(", ");
        }
        output = output.write(91).debug(feel).write(", ").debug(col).write(93);
      }
      output = output.write(41);
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static empty() {
      return new ThemeMatrix([], {}, [], {});
    }
    static forRows(...rows) {
      const m = rows.length;
      const rowArray = new Array(m);
      for (let i = 0; i < m; i += 1) {
        const [look, row] = rows[i];
        rowArray[i] = [ look, LookVector.fromAny(row) ];
      }
      return this.fromRowArray(rowArray);
    }
    static forCols(...cols) {
      const m = cols.length;
      const colArray = new Array(m);
      for (let j = 0; j < m; j += 1) {
        const [feel, col] = cols[j];
        colArray[j] = [ feel, FeelVector.fromAny(col) ];
      }
      return this.fromColArray(colArray);
    }
    static fromRowArray(rowArray, rowIndex) {
      if (rowIndex === void 0) {
        rowIndex = FeelVector.index(rowArray);
      }
      const colArray = new Array;
      const colIndex = {};
      for (let i = 0, m = rowArray.length; i < m; i += 1) {
        const row = rowArray[i][1];
        row.forEach((function(value, feel) {
          if (colIndex[feel.name] === void 0) {
            colIndex[feel.name] = colArray.length;
            colArray.push([ feel, void 0 ]);
          }
        }), this);
      }
      for (let j = 0, n = colArray.length; j < n; j += 1) {
        const entry = colArray[j];
        const feel = entry[0];
        const array = new Array;
        const index = {};
        for (let i = 0, m = rowArray.length; i < m; i += 1) {
          const [look, row] = rowArray[i];
          const value = row.get(feel);
          if (value !== void 0) {
            index[look.name] = array.length;
            array.push([ look, value ]);
          }
        }
        const col = FeelVector.fromArray(array, index);
        entry[1] = col;
      }
      return new ThemeMatrix(rowArray, rowIndex, colArray, colIndex);
    }
    static fromColArray(colArray, colIndex) {
      if (colIndex === void 0) {
        colIndex = LookVector.index(colArray);
      }
      const rowArray = new Array;
      const rowIndex = {};
      for (let i = 0, n = colArray.length; i < n; i += 1) {
        const col = colArray[i][1];
        col.forEach((function(value, look) {
          if (rowIndex[look.name] === void 0) {
            rowIndex[look.name] = rowArray.length;
            rowArray.push([ look, void 0 ]);
          }
        }), this);
      }
      for (let i = 0, m = rowArray.length; i < m; i += 1) {
        const entry = rowArray[i];
        const look = entry[0];
        const array = new Array;
        const index = {};
        for (let j = 0, n = colArray.length; j < n; j += 1) {
          const [feel, col] = colArray[j];
          const value = col.get(look);
          if (value !== void 0) {
            index[feel.name] = array.length;
            array.push([ feel, value ]);
          }
        }
        const row = LookVector.fromArray(array, index);
        entry[1] = row;
      }
      return new ThemeMatrix(rowArray, rowIndex, colArray, colIndex);
    }
  }
  __decorate([ util.Lazy ], ThemeMatrix, "empty", null);
  const ThemeContext = function() {
    const ThemeContext = {};
    ThemeContext.is = function(object) {
      if (typeof object === "object" && object !== null || typeof object === "function") {
        const themeContext = object;
        return "getLook" in themeContext;
      }
      return false;
    };
    return ThemeContext;
  }();
  const ThemeAnimator = function(_super) {
    const ThemeAnimator = _super.extend("ThemeAnimator");
    ThemeAnimator.prototype.onSetAffinity = function(newAffinity, oldAffinity) {
      if (newAffinity > component.Affinity.Intrinsic) {
        this.setLook(null, newAffinity);
      }
      _super.prototype.onSetAffinity.call(this, newAffinity, oldAffinity);
    };
    ThemeAnimator.prototype.onInherit = function(superFastener) {
      if (superFastener instanceof ThemeAnimator) {
        this.setLook(superFastener.look, superFastener.timing, component.Affinity.Reflexive);
      } else {
        this.setLook(null, component.Affinity.Reflexive);
      }
      if (this.look === null) {
        _super.prototype.onInherit.call(this, superFastener);
      }
    };
    Object.defineProperty(ThemeAnimator.prototype, "superLook", {
      get: function() {
        const superFastener = this.superFastener;
        return superFastener instanceof ThemeAnimator ? superFastener.look : null;
      },
      configurable: true
    });
    ThemeAnimator.prototype.getSuperLook = function() {
      const superLook = this.superLook;
      if (superLook === null) {
        throw new TypeError(superLook + " " + this.name + " super look");
      }
      return superLook;
    };
    ThemeAnimator.prototype.getSuperLookOr = function(elseLook) {
      let superLook = this.superLook;
      if (superLook === null) {
        superLook = elseLook;
      }
      return superLook;
    };
    ThemeAnimator.prototype.getLook = function() {
      const look = this.look;
      if (look === null) {
        throw new TypeError(look + " " + this.name + " look");
      }
      return look;
    };
    ThemeAnimator.prototype.getLookOr = function(elseLook) {
      let look = this.look;
      if (look === null) {
        look = elseLook;
      }
      return look;
    };
    ThemeAnimator.prototype.setLook = function(newLook, timing, affinity) {
      if (typeof timing === "number") {
        affinity = timing;
        timing = void 0;
      }
      if (affinity === void 0) {
        affinity = component.Affinity.Extrinsic;
      }
      if (this.minAffinity(affinity)) {
        const oldLook = this.look;
        if (newLook !== oldLook) {
          if (timing === void 0 || timing === null) {
            timing = false;
          } else {
            timing = util.Timing.fromAny(timing);
          }
          this.willSetLook(newLook, oldLook, timing);
          this.look = newLook;
          this.onSetLook(newLook, oldLook, timing);
          this.didSetLook(newLook, oldLook, timing);
        }
      }
    };
    ThemeAnimator.prototype.willSetLook = function(newLook, oldLook, timing) {};
    ThemeAnimator.prototype.onSetLook = function(newLook, oldLook, timing) {
      if (newLook !== null) {
        this.applyLook(newLook, timing);
      }
    };
    ThemeAnimator.prototype.didSetLook = function(newLook, oldLook, timing) {};
    ThemeAnimator.prototype.applyLook = function(look, timing) {
      const themeContext = this.owner;
      if (this.mounted && ThemeContext.is(themeContext)) {
        const state = themeContext.getLook(look);
        if (state !== void 0) {
          if (timing === true) {
            timing = themeContext.getLookOr(Look.timing, true);
          }
          this.setState(state, timing, component.Affinity.Reflexive);
        }
      }
    };
    ThemeAnimator.prototype.applyTheme = function(theme, mood, timing) {
      const look = this.look;
      if (look !== null) {
        const state = theme.get(look, mood);
        if (state !== void 0) {
          if (timing === true) {
            timing = theme.get(Look.timing, mood);
            if (timing === void 0) {
              timing = true;
            }
          }
          this.setState(state, timing, component.Affinity.Reflexive);
        }
      }
    };
    ThemeAnimator.prototype.tweenInherited = function(t) {
      const superFastener = this.superFastener;
      if (superFastener instanceof ThemeAnimator) {
        this.setLook(superFastener.look, superFastener.timing, component.Affinity.Reflexive);
      } else {
        this.setLook(null, component.Affinity.Reflexive);
      }
      if (this.look !== null) {
        _super.prototype.tween.call(this, t);
      } else {
        _super.prototype.tweenInherited.call(this, t);
      }
    };
    ThemeAnimator.prototype.onMount = function() {
      _super.prototype.onMount.call(this);
      const look = this.look;
      if (look !== null) {
        this.applyLook(look, false);
      }
    };
    ThemeAnimator.construct = function(animatorClass, animator, owner) {
      animator = _super.construct(animatorClass, animator, owner);
      animator.look = null;
      return animator;
    };
    ThemeAnimator.specialize = function(type) {
      if (type === String) {
        return StringThemeAnimator;
      } else if (type === Number) {
        return NumberThemeAnimator;
      } else if (type === Boolean) {
        return BooleanThemeAnimator;
      } else if (type === math.Angle) {
        return AngleThemeAnimator;
      } else if (type === math.Length) {
        return LengthThemeAnimator;
      } else if (type === math.Transform) {
        return TransformThemeAnimator;
      } else if (type === Color) {
        return ColorThemeAnimator;
      } else if (type === Font) {
        return FontThemeAnimator;
      } else if (type === Focus) {
        return FocusThemeAnimator;
      } else if (type === Presence) {
        return PresenceThemeAnimator;
      } else if (type === Expansion) {
        return ExpansionThemeAnimator;
      }
      return null;
    };
    ThemeAnimator.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const look = descriptor.look;
      const value = descriptor.value;
      const initValue = descriptor.initValue;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.look;
      delete descriptor.value;
      delete descriptor.initValue;
      if (superClass === void 0 || superClass === null) {
        superClass = this.specialize(descriptor.type);
      }
      if (superClass === null) {
        superClass = this;
        if (descriptor.fromAny === void 0 && util.FromAny.is(descriptor.type)) {
          descriptor.fromAny = descriptor.type.fromAny;
        }
      }
      const animatorClass = superClass.extend(className, descriptor);
      animatorClass.construct = function(animatorClass, animator, owner) {
        animator = superClass.construct(animatorClass, animator, owner);
        if (affinity !== void 0) {
          animator.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          animator.initInherits(inherits);
        }
        if (look !== void 0) {
          animator.look = look;
        }
        if (initValue !== void 0) {
          animator.value = animator.fromAny(initValue());
          animator.state = animator.value;
        } else if (value !== void 0) {
          animator.value = animator.fromAny(value);
          animator.state = animator.value;
        }
        return animator;
      };
      return animatorClass;
    };
    return ThemeAnimator;
  }(component.Animator);
  const StringThemeAnimator = function(_super) {
    const StringThemeAnimator = _super.extend("StringThemeAnimator");
    StringThemeAnimator.prototype.fromAny = function(value) {
      return value;
    };
    StringThemeAnimator.prototype.equalValues = function(newValue, oldValue) {
      return newValue === oldValue;
    };
    return StringThemeAnimator;
  }(ThemeAnimator);
  const NumberThemeAnimator = function(_super) {
    const NumberThemeAnimator = _super.extend("NumberThemeAnimator");
    NumberThemeAnimator.prototype.fromAny = function(value) {
      if (typeof value === "string") {
        const number = +value;
        if (isFinite(number)) {
          return number;
        } else {
          throw new Error(value);
        }
      } else {
        return value;
      }
    };
    NumberThemeAnimator.prototype.equalValues = function(newValue, oldValue) {
      return newValue === oldValue;
    };
    return NumberThemeAnimator;
  }(ThemeAnimator);
  const BooleanThemeAnimator = function(_super) {
    const BooleanThemeAnimator = _super.extend("BooleanThemeAnimator");
    BooleanThemeAnimator.prototype.fromAny = function(value) {
      return !!value;
    };
    BooleanThemeAnimator.prototype.equalValues = function(newValue, oldValue) {
      return newValue === oldValue;
    };
    return BooleanThemeAnimator;
  }(ThemeAnimator);
  const AngleThemeAnimator = function(_super) {
    const AngleThemeAnimator = _super.extend("AngleThemeAnimator");
    AngleThemeAnimator.prototype.fromAny = function(value) {
      return value !== void 0 && value !== null ? math.Angle.fromAny(value) : value;
    };
    AngleThemeAnimator.prototype.equalValues = function(newValue, oldValue) {
      if (newValue !== void 0 && newValue !== null) {
        return newValue.equals(oldValue);
      } else {
        return newValue === oldValue;
      }
    };
    return AngleThemeAnimator;
  }(ThemeAnimator);
  const LengthThemeAnimator = function(_super) {
    const LengthThemeAnimator = _super.extend("LengthThemeAnimator");
    LengthThemeAnimator.prototype.fromAny = function(value) {
      return value !== void 0 && value !== null ? math.Length.fromAny(value) : null;
    };
    LengthThemeAnimator.prototype.equalValues = function(newValue, oldValue) {
      if (newValue !== void 0 && newValue !== null) {
        return newValue.equals(oldValue);
      } else {
        return newValue === oldValue;
      }
    };
    return LengthThemeAnimator;
  }(ThemeAnimator);
  const TransformThemeAnimator = function(_super) {
    const TransformThemeAnimator = _super.extend("TransformThemeAnimator");
    TransformThemeAnimator.prototype.fromAny = function(value) {
      return value !== void 0 && value !== null ? math.Transform.fromAny(value) : null;
    };
    TransformThemeAnimator.prototype.equalValues = function(newValue, oldValue) {
      if (newValue !== void 0 && newValue !== null) {
        return newValue.equals(oldValue);
      } else {
        return newValue === oldValue;
      }
    };
    return TransformThemeAnimator;
  }(ThemeAnimator);
  const ColorThemeAnimator = function(_super) {
    const ColorThemeAnimator = _super.extend("ColorThemeAnimator");
    ColorThemeAnimator.prototype.fromAny = function(value) {
      return value !== void 0 && value !== null ? Color.fromAny(value) : value;
    };
    ColorThemeAnimator.prototype.equalValues = function(newValue, oldValue) {
      if (newValue !== void 0 && newValue !== null) {
        return newValue.equals(oldValue);
      } else {
        return newValue === oldValue;
      }
    };
    return ColorThemeAnimator;
  }(ThemeAnimator);
  const FontThemeAnimator = function(_super) {
    const FontThemeAnimator = _super.extend("FontThemeAnimator");
    FontThemeAnimator.prototype.fromAny = function(value) {
      return value !== void 0 && value !== null ? Font.fromAny(value) : value;
    };
    FontThemeAnimator.prototype.equalValues = function(newValue, oldValue) {
      if (newValue !== void 0 && newValue !== null) {
        return newValue.equals(oldValue);
      } else {
        return newValue === oldValue;
      }
    };
    return FontThemeAnimator;
  }(ThemeAnimator);
  const FocusThemeAnimator = function(_super) {
    const FocusThemeAnimator = _super.extend("FocusThemeAnimator");
    Object.defineProperty(FocusThemeAnimator.prototype, "phase", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null ? value.phase : void 0;
      },
      configurable: true
    });
    FocusThemeAnimator.prototype.getPhase = function() {
      return this.getValue().phase;
    };
    FocusThemeAnimator.prototype.getPhaseOr = function(elsePhase) {
      const value = this.value;
      if (value !== void 0 && value !== null) {
        return value.phase;
      } else {
        return elsePhase;
      }
    };
    FocusThemeAnimator.prototype.setPhase = function(newPhase, timing, affinity) {
      const oldValue = this.value;
      if (oldValue !== void 0 && oldValue !== null) {
        if (typeof timing === "number") {
          affinity = timing;
          timing = void 0;
        }
        this.setState(oldValue.withPhase(newPhase), timing, affinity);
      }
    };
    Object.defineProperty(FocusThemeAnimator.prototype, "direction", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null ? value.direction : 0;
      },
      configurable: true
    });
    FocusThemeAnimator.prototype.setDirection = function(newDirection, timing, affinity) {
      const oldValue = this.value;
      if (oldValue !== void 0 && oldValue !== null) {
        if (typeof timing === "number") {
          affinity = timing;
          timing = void 0;
        }
        this.setState(oldValue.withDirection(newDirection), timing, affinity);
      }
    };
    Object.defineProperty(FocusThemeAnimator.prototype, "unfocused", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null && value.unfocused;
      },
      configurable: true
    });
    Object.defineProperty(FocusThemeAnimator.prototype, "focused", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null && value.focused;
      },
      configurable: true
    });
    Object.defineProperty(FocusThemeAnimator.prototype, "focusing", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null && value.focusing;
      },
      configurable: true
    });
    Object.defineProperty(FocusThemeAnimator.prototype, "unfocusing", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null && value.unfocusing;
      },
      configurable: true
    });
    FocusThemeAnimator.prototype.focus = function(timing, affinity) {
      const oldValue = this.value;
      if (oldValue === void 0 || oldValue === null || !oldValue.focused) {
        if (typeof timing === "number") {
          affinity = timing;
          timing = void 0;
        }
        if (timing === void 0 || timing === true) {
          const themeContext = this.owner;
          if (this.mounted && ThemeContext.is(themeContext)) {
            timing = themeContext.getLook(Look.timing);
          }
        }
        if (oldValue !== void 0 && oldValue !== null) {
          this.setValue(oldValue.asFocusing(), component.Affinity.Reflexive);
        }
        this.setState(Focus.focused(), timing, affinity);
      }
    };
    FocusThemeAnimator.prototype.unfocus = function(timing, affinity) {
      const oldValue = this.value;
      if (oldValue === void 0 || oldValue === null || !oldValue.unfocused) {
        if (typeof timing === "number") {
          affinity = timing;
          timing = void 0;
        }
        if (timing === void 0 || timing === true) {
          const themeContext = this.owner;
          if (this.mounted && ThemeContext.is(themeContext)) {
            timing = themeContext.getLook(Look.timing);
          }
        }
        if (oldValue !== void 0 && oldValue !== null) {
          this.setValue(oldValue.asUnfocusing(), component.Affinity.Reflexive);
        }
        this.setState(Focus.unfocused(), timing, affinity);
      }
    };
    FocusThemeAnimator.prototype.toggle = function(timing, affinity) {
      const oldValue = this.value;
      if (oldValue !== void 0 && oldValue !== null) {
        if (typeof timing === "number") {
          affinity = timing;
          timing = void 0;
        }
        if (timing === void 0 || timing === true) {
          const themeContext = this.owner;
          if (this.mounted && ThemeContext.is(themeContext)) {
            timing = themeContext.getLook(Look.timing);
          }
        }
        this.setValue(oldValue.asToggling(), component.Affinity.Reflexive);
        this.setState(oldValue.asToggled(), timing, affinity);
      }
    };
    FocusThemeAnimator.prototype.onSetValue = function(newValue, oldValue) {
      _super.prototype.onSetValue.call(this, newValue, oldValue);
      if (newValue !== void 0 && newValue !== null && oldValue !== void 0 && oldValue !== null) {
        if (newValue.focusing && !oldValue.focusing) {
          this.willFocus();
        } else if (newValue.focused && !oldValue.focused) {
          this.didFocus();
        } else if (newValue.unfocusing && !oldValue.unfocusing) {
          this.willUnfocus();
        } else if (newValue.unfocused && !oldValue.unfocused) {
          this.didUnfocus();
        }
      }
    };
    FocusThemeAnimator.prototype.willFocus = function() {};
    FocusThemeAnimator.prototype.didFocus = function() {};
    FocusThemeAnimator.prototype.willUnfocus = function() {};
    FocusThemeAnimator.prototype.didUnfocus = function() {};
    FocusThemeAnimator.prototype.fromAny = function(value) {
      return value !== void 0 && value !== null ? Focus.fromAny(value) : null;
    };
    FocusThemeAnimator.prototype.equalValues = function(newState, oldState) {
      if (newState !== void 0 && newState !== null) {
        return newState.equals(oldState);
      } else {
        return newState === oldState;
      }
    };
    return FocusThemeAnimator;
  }(ThemeAnimator);
  const PresenceThemeAnimator = function(_super) {
    const PresenceThemeAnimator = _super.extend("PresenceThemeAnimator");
    Object.defineProperty(PresenceThemeAnimator.prototype, "phase", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null ? value.phase : void 0;
      },
      configurable: true
    });
    PresenceThemeAnimator.prototype.getPhase = function() {
      return this.getValue().phase;
    };
    PresenceThemeAnimator.prototype.getPhaseOr = function(elsePhase) {
      const value = this.value;
      if (value !== void 0 && value !== null) {
        return value.phase;
      } else {
        return elsePhase;
      }
    };
    PresenceThemeAnimator.prototype.setPhase = function(newPhase, timing, affinity) {
      const oldValue = this.value;
      if (oldValue !== void 0 && oldValue !== null) {
        if (typeof timing === "number") {
          affinity = timing;
          timing = void 0;
        }
        this.setState(oldValue.withPhase(newPhase), timing, affinity);
      }
    };
    Object.defineProperty(PresenceThemeAnimator.prototype, "direction", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null ? value.direction : 0;
      },
      configurable: true
    });
    PresenceThemeAnimator.prototype.setDirection = function(newDirection, timing, affinity) {
      const oldValue = this.value;
      if (oldValue !== void 0 && oldValue !== null) {
        if (typeof timing === "number") {
          affinity = timing;
          timing = void 0;
        }
        this.setState(oldValue.withDirection(newDirection), timing, affinity);
      }
    };
    Object.defineProperty(PresenceThemeAnimator.prototype, "modalState", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null ? value.modalState : void 0;
      },
      configurable: true
    });
    Object.defineProperty(PresenceThemeAnimator.prototype, "dismissed", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null && value.dismissed;
      },
      configurable: true
    });
    Object.defineProperty(PresenceThemeAnimator.prototype, "presented", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null && value.presented;
      },
      configurable: true
    });
    Object.defineProperty(PresenceThemeAnimator.prototype, "presenting", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null && value.presenting;
      },
      configurable: true
    });
    Object.defineProperty(PresenceThemeAnimator.prototype, "dismissing", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null && value.dismissing;
      },
      configurable: true
    });
    PresenceThemeAnimator.prototype.present = function(timing, affinity) {
      const oldValue = this.value;
      if (oldValue === void 0 || oldValue === null || !oldValue.presented) {
        if (typeof timing === "number") {
          affinity = timing;
          timing = void 0;
        }
        if (timing === void 0 || timing === true) {
          const themeContext = this.owner;
          if (this.mounted && ThemeContext.is(themeContext)) {
            timing = themeContext.getLook(Look.timing);
          }
        }
        if (oldValue !== void 0 && oldValue !== null) {
          this.setValue(oldValue.asPresenting(), component.Affinity.Reflexive);
        }
        this.setState(Presence.presented(), timing, affinity);
      }
    };
    PresenceThemeAnimator.prototype.dismiss = function(timing, affinity) {
      const oldValue = this.value;
      if (oldValue === void 0 || oldValue === null || !oldValue.dismissed) {
        if (typeof timing === "number") {
          affinity = timing;
          timing = void 0;
        }
        if (timing === void 0 || timing === true) {
          const themeContext = this.owner;
          if (this.mounted && ThemeContext.is(themeContext)) {
            timing = themeContext.getLook(Look.timing);
          }
        }
        if (oldValue !== void 0 && oldValue !== null) {
          this.setValue(oldValue.asDismissing(), component.Affinity.Reflexive);
        }
        this.setState(Presence.dismissed(), timing, affinity);
      }
    };
    PresenceThemeAnimator.prototype.toggle = function(timing, affinity) {
      const oldValue = this.value;
      if (oldValue !== void 0 && oldValue !== null) {
        if (typeof timing === "number") {
          affinity = timing;
          timing = void 0;
        }
        if (timing === void 0 || timing === true) {
          const themeContext = this.owner;
          if (this.mounted && ThemeContext.is(themeContext)) {
            timing = themeContext.getLook(Look.timing);
          }
        }
        this.setValue(oldValue.asToggling(), component.Affinity.Reflexive);
        this.setState(oldValue.asToggled(), timing, affinity);
      }
    };
    PresenceThemeAnimator.prototype.onSetValue = function(newValue, oldValue) {
      _super.prototype.onSetValue.call(this, newValue, oldValue);
      if (newValue !== void 0 && newValue !== null && oldValue !== void 0 && oldValue !== null) {
        if (newValue.presenting && !oldValue.presenting) {
          this.willPresent();
        } else if (newValue.presented && !oldValue.presented) {
          this.didPresent();
        } else if (newValue.dismissing && !oldValue.dismissing) {
          this.willDismiss();
        } else if (newValue.dismissed && !oldValue.dismissed) {
          this.didDismiss();
        }
      }
    };
    PresenceThemeAnimator.prototype.willPresent = function() {};
    PresenceThemeAnimator.prototype.didPresent = function() {};
    PresenceThemeAnimator.prototype.willDismiss = function() {};
    PresenceThemeAnimator.prototype.didDismiss = function() {};
    PresenceThemeAnimator.prototype.fromAny = function(value) {
      return value !== void 0 && value !== null ? Presence.fromAny(value) : null;
    };
    PresenceThemeAnimator.prototype.equalValues = function(newValue, oldState) {
      if (newValue !== void 0 && newValue !== null) {
        return newValue.equals(oldState);
      } else {
        return newValue === oldState;
      }
    };
    return PresenceThemeAnimator;
  }(ThemeAnimator);
  const ExpansionThemeAnimator = function(_super) {
    const ExpansionThemeAnimator = _super.extend("ExpansionThemeAnimator");
    Object.defineProperty(ExpansionThemeAnimator.prototype, "phase", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null ? value.phase : void 0;
      },
      configurable: true
    });
    ExpansionThemeAnimator.prototype.getPhase = function() {
      return this.getValue().phase;
    };
    ExpansionThemeAnimator.prototype.getPhaseOr = function(elsePhase) {
      const value = this.value;
      if (value !== void 0 && value !== null) {
        return value.phase;
      } else {
        return elsePhase;
      }
    };
    ExpansionThemeAnimator.prototype.setPhase = function(newPhase, timing, affinity) {
      const oldValue = this.value;
      if (oldValue !== void 0 && oldValue !== null) {
        if (typeof timing === "number") {
          affinity = timing;
          timing = void 0;
        }
        this.setState(oldValue.withPhase(newPhase), timing, affinity);
      }
    };
    Object.defineProperty(ExpansionThemeAnimator.prototype, "direction", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null ? value.direction : 0;
      },
      configurable: true
    });
    ExpansionThemeAnimator.prototype.setDirection = function(newDirection, timing, affinity) {
      const oldValue = this.value;
      if (oldValue !== void 0 && oldValue !== null) {
        if (typeof timing === "number") {
          affinity = timing;
          timing = void 0;
        }
        this.setState(oldValue.withDirection(newDirection), timing, affinity);
      }
    };
    Object.defineProperty(ExpansionThemeAnimator.prototype, "modalState", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null ? value.modalState : void 0;
      },
      configurable: true
    });
    Object.defineProperty(ExpansionThemeAnimator.prototype, "collapsed", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null && value.collapsed;
      },
      configurable: true
    });
    Object.defineProperty(ExpansionThemeAnimator.prototype, "expanded", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null && value.expanded;
      },
      configurable: true
    });
    Object.defineProperty(ExpansionThemeAnimator.prototype, "expanding", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null && value.expanding;
      },
      configurable: true
    });
    Object.defineProperty(ExpansionThemeAnimator.prototype, "collapsing", {
      get() {
        const value = this.value;
        return value !== void 0 && value !== null && value.collapsing;
      },
      configurable: true
    });
    ExpansionThemeAnimator.prototype.expand = function(timing, affinity) {
      const oldValue = this.value;
      if (oldValue === void 0 || oldValue === null || !oldValue.expanded) {
        if (typeof timing === "number") {
          affinity = timing;
          timing = void 0;
        }
        if (timing === void 0 || timing === true) {
          const themeContext = this.owner;
          if (this.mounted && ThemeContext.is(themeContext)) {
            timing = themeContext.getLook(Look.timing);
          }
        }
        if (oldValue !== void 0 && oldValue !== null) {
          this.setValue(oldValue.asExpanding(), component.Affinity.Reflexive);
        }
        this.setState(Expansion.expanded(), timing, affinity);
      }
    };
    ExpansionThemeAnimator.prototype.collapse = function(timing, affinity) {
      const oldValue = this.value;
      if (oldValue === void 0 || oldValue === null || !oldValue.collapsed) {
        if (typeof timing === "number") {
          affinity = timing;
          timing = void 0;
        }
        if (timing === void 0 || timing === true) {
          const themeContext = this.owner;
          if (this.mounted && ThemeContext.is(themeContext)) {
            timing = themeContext.getLook(Look.timing);
          }
        }
        if (oldValue !== void 0 && oldValue !== null) {
          this.setValue(oldValue.asCollapsing(), component.Affinity.Reflexive);
        }
        this.setState(Expansion.collapsed(), timing, affinity);
      }
    };
    ExpansionThemeAnimator.prototype.toggle = function(timing, affinity) {
      const oldValue = this.value;
      if (oldValue !== void 0 && oldValue !== null) {
        if (typeof timing === "number") {
          affinity = timing;
          timing = void 0;
        }
        if (timing === void 0 || timing === true) {
          const themeContext = this.owner;
          if (this.mounted && ThemeContext.is(themeContext)) {
            timing = themeContext.getLook(Look.timing);
          }
        }
        this.setValue(oldValue.asToggling(), component.Affinity.Reflexive);
        this.setState(oldValue.asToggled(), timing, affinity);
      }
    };
    ExpansionThemeAnimator.prototype.onSetValue = function(newValue, oldValue) {
      _super.prototype.onSetValue.call(this, newValue, oldValue);
      if (newValue !== void 0 && newValue !== null && oldValue !== void 0 && oldValue !== null) {
        if (newValue.expanding && !oldValue.expanding) {
          this.willExpand();
        } else if (newValue.expanded && !oldValue.expanded) {
          this.didExpand();
        } else if (newValue.collapsing && !oldValue.collapsing) {
          this.willCollapse();
        } else if (newValue.collapsed && !oldValue.collapsed) {
          this.didCollapse();
        }
      }
    };
    ExpansionThemeAnimator.prototype.willExpand = function() {};
    ExpansionThemeAnimator.prototype.didExpand = function() {};
    ExpansionThemeAnimator.prototype.willCollapse = function() {};
    ExpansionThemeAnimator.prototype.didCollapse = function() {};
    ExpansionThemeAnimator.prototype.fromAny = function(value) {
      return value !== void 0 && value !== null ? Expansion.fromAny(value) : null;
    };
    ExpansionThemeAnimator.prototype.equalValues = function(newValue, oldValue) {
      if (newValue !== void 0 && newValue !== null) {
        return newValue.equals(oldValue);
      } else {
        return newValue === oldValue;
      }
    };
    return ExpansionThemeAnimator;
  }(ThemeAnimator);
  const ThemeConstraintAnimator = function(_super) {
    const ThemeConstraintAnimator = _super.extend("ThemeConstraintAnimator");
    ThemeConstraintAnimator.prototype.isExternal = function() {
      return true;
    };
    ThemeConstraintAnimator.prototype.isDummy = function() {
      return false;
    };
    ThemeConstraintAnimator.prototype.isInvalid = function() {
      return false;
    };
    ThemeConstraintAnimator.prototype.isConstant = function() {
      return false;
    };
    ThemeConstraintAnimator.prototype.evaluateConstraintVariable = function() {};
    ThemeConstraintAnimator.prototype.updateConstraintSolution = function(state) {
      if (this.constrained && this.toNumber(this.state) !== state) {
        this.setState(state, component.Affinity.Reflexive);
      }
    };
    ThemeConstraintAnimator.prototype.setStrength = function(strength) {
      this.strength = constraint.ConstraintStrength.fromAny(strength);
    };
    Object.defineProperty(ThemeConstraintAnimator.prototype, "coefficient", {
      get() {
        return 1;
      },
      configurable: true
    });
    Object.defineProperty(ThemeConstraintAnimator.prototype, "variable", {
      get() {
        return this;
      },
      configurable: true
    });
    Object.defineProperty(ThemeConstraintAnimator.prototype, "terms", {
      get() {
        const terms = new constraint.ConstraintMap;
        terms.set(this, 1);
        return terms;
      },
      configurable: true
    });
    Object.defineProperty(ThemeConstraintAnimator.prototype, "constant", {
      get() {
        return 0;
      },
      configurable: true
    });
    ThemeConstraintAnimator.prototype.plus = function(that) {
      that = constraint.ConstraintExpression.fromAny(that);
      if (this === that) {
        return constraint.ConstraintExpression.product(2, this);
      } else {
        return constraint.ConstraintExpression.sum(this, that);
      }
    };
    ThemeConstraintAnimator.prototype.negative = function() {
      return constraint.ConstraintExpression.product(-1, this);
    };
    ThemeConstraintAnimator.prototype.minus = function(that) {
      that = constraint.ConstraintExpression.fromAny(that);
      if (this === that) {
        return constraint.ConstraintExpression.zero;
      } else {
        return constraint.ConstraintExpression.sum(this, that.negative());
      }
    };
    ThemeConstraintAnimator.prototype.times = function(scalar) {
      return constraint.ConstraintExpression.product(scalar, this);
    };
    ThemeConstraintAnimator.prototype.divide = function(scalar) {
      return constraint.ConstraintExpression.product(1 / scalar, this);
    };
    Object.defineProperty(ThemeConstraintAnimator.prototype, "constrained", {
      get() {
        return (this.flags & ThemeConstraintAnimator.ConstrainedFlag) !== 0;
      },
      configurable: true
    });
    ThemeConstraintAnimator.prototype.constrain = function(constrained) {
      if (constrained === void 0) {
        constrained = true;
      }
      const flags = this.flags;
      if (constrained && (flags & ThemeConstraintAnimator.ConstrainedFlag) === 0) {
        this.setFlags(flags | ThemeConstraintAnimator.ConstrainedFlag);
        if (this.conditionCount !== 0 && this.mounted) {
          this.stopConstraining();
        }
      } else if (!constrained && (flags & ThemeConstraintAnimator.ConstrainedFlag) !== 0) {
        this.setFlags(flags & ~ThemeConstraintAnimator.ConstrainedFlag);
        if (this.conditionCount !== 0 && this.mounted) {
          this.startConstraining();
          this.updateConstraintVariable();
        }
      }
      return this;
    };
    ThemeConstraintAnimator.prototype.addConstraintCondition = function(constraint, solver) {
      this.conditionCount += 1;
      if (!this.constrained && this.conditionCount === 1 && this.mounted) {
        this.startConstraining();
        this.updateConstraintVariable();
      }
    };
    ThemeConstraintAnimator.prototype.removeConstraintCondition = function(constraint, solver) {
      this.conditionCount -= 1;
      if (!this.constrained && this.conditionCount === 0 && this.mounted) {
        this.stopConstraining();
      }
    };
    Object.defineProperty(ThemeConstraintAnimator.prototype, "constraining", {
      get() {
        return (this.flags & ThemeConstraintAnimator.ConstrainingFlag) !== 0;
      },
      configurable: true
    });
    ThemeConstraintAnimator.prototype.startConstraining = function() {
      if ((this.flags & ThemeConstraintAnimator.ConstrainingFlag) === 0) {
        this.willStartConstraining();
        this.setFlags(this.flags | ThemeConstraintAnimator.ConstrainingFlag);
        this.onStartConstraining();
        this.didStartConstraining();
      }
    };
    ThemeConstraintAnimator.prototype.willStartConstraining = function() {};
    ThemeConstraintAnimator.prototype.onStartConstraining = function() {
      const constraintScope = this.owner;
      if (constraint.ConstraintScope.is(constraintScope)) {
        constraintScope.addConstraintVariable(this);
      }
    };
    ThemeConstraintAnimator.prototype.didStartConstraining = function() {};
    ThemeConstraintAnimator.prototype.stopConstraining = function() {
      if ((this.flags & ThemeConstraintAnimator.ConstrainingFlag) !== 0) {
        this.willStopConstraining();
        this.setFlags(this.flags & ~ThemeConstraintAnimator.ConstrainingFlag);
        this.onStopConstraining();
        this.didStopConstraining();
      }
    };
    ThemeConstraintAnimator.prototype.willStopConstraining = function() {};
    ThemeConstraintAnimator.prototype.onStopConstraining = function() {
      const constraintScope = this.owner;
      if (constraint.ConstraintScope.is(constraintScope)) {
        constraintScope.removeConstraintVariable(this);
      }
    };
    ThemeConstraintAnimator.prototype.didStopConstraining = function() {};
    ThemeConstraintAnimator.prototype.updateConstraintVariable = function() {
      const constraintScope = this.owner;
      const value = this.value;
      if (value !== void 0 && constraint.ConstraintScope.is(constraintScope)) {
        constraintScope.setConstraintVariable(this, this.toNumber(value));
      }
    };
    ThemeConstraintAnimator.prototype.onSetValue = function(newValue, oldValue) {
      _super.prototype.onSetValue.call(this, newValue, oldValue);
      const constraintScope = this.owner;
      if (this.constraining && constraint.ConstraintScope.is(constraintScope)) {
        constraintScope.setConstraintVariable(this, newValue !== void 0 && newValue !== null ? this.toNumber(newValue) : 0);
      }
    };
    ThemeConstraintAnimator.prototype.onMount = function() {
      _super.prototype.onMount.call(this);
      if (!this.constrained && this.conditionCount !== 0) {
        this.startConstraining();
      }
    };
    ThemeConstraintAnimator.prototype.onUnmount = function() {
      if (!this.constrained && this.conditionCount !== 0) {
        this.stopConstraining();
      }
      _super.prototype.onUnmount.call(this);
    };
    ThemeConstraintAnimator.prototype.fromAny = function(value) {
      if (typeof value === "string") {
        const number = +value;
        if (isFinite(number)) {
          return number;
        }
      }
      return value;
    };
    ThemeConstraintAnimator.prototype.toNumber = function(value) {
      return value !== void 0 && value !== null ? +value : 0;
    };
    ThemeConstraintAnimator.construct = function(animatorClass, animator, owner) {
      animator = _super.construct(animatorClass, animator, owner);
      animator.id = constraint.ConstraintId.next();
      animator.strength = constraint.ConstraintStrength.Strong;
      animator.conditionCount = 0;
      return animator;
    };
    ThemeConstraintAnimator.specialize = function(type) {
      if (type === Number) {
        return NumberThemeConstraintAnimator;
      } else if (type === math.Length) {
        return LengthThemeConstraintAnimator;
      }
      return null;
    };
    ThemeConstraintAnimator.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const strength = descriptor.strength !== void 0 ? constraint.ConstraintStrength.fromAny(descriptor.strength) : void 0;
      const constrain = descriptor.constrain;
      const look = descriptor.look;
      const value = descriptor.value;
      const initValue = descriptor.initValue;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.strength;
      delete descriptor.constrain;
      delete descriptor.look;
      delete descriptor.value;
      delete descriptor.initValue;
      if (superClass === void 0 || superClass === null) {
        superClass = this.specialize(descriptor.type);
      }
      if (superClass === null) {
        superClass = this;
        if (descriptor.fromAny === void 0 && util.FromAny.is(descriptor.type)) {
          descriptor.fromAny = descriptor.type.fromAny;
        }
      }
      const animatorClass = superClass.extend(className, descriptor);
      animatorClass.construct = function(animatorClass, animator, owner) {
        animator = superClass.construct(animatorClass, animator, owner);
        if (affinity !== void 0) {
          animator.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          animator.initInherits(inherits);
        }
        if (strength !== void 0) {
          animator.strength = strength;
        }
        if (look !== void 0) {
          animator.look = look;
        }
        if (initValue !== void 0) {
          animator.value = animator.fromAny(initValue());
          animator.state = animator.value;
        } else if (value !== void 0) {
          animator.value = animator.fromAny(value);
          animator.state = animator.value;
        }
        if (constrain === true) {
          animator.constrain();
        }
        return animator;
      };
      return animatorClass;
    };
    ThemeConstraintAnimator.ConstrainedFlag = 1 << _super.FlagShift + 0;
    ThemeConstraintAnimator.ConstrainingFlag = 1 << _super.FlagShift + 1;
    ThemeConstraintAnimator.FlagShift = _super.FlagShift + 2;
    ThemeConstraintAnimator.FlagMask = (1 << ThemeConstraintAnimator.FlagShift) - 1;
    return ThemeConstraintAnimator;
  }(ThemeAnimator);
  const NumberThemeConstraintAnimator = function(_super) {
    const NumberThemeConstraintAnimator = _super.extend("NumberThemeConstraintAnimator");
    NumberThemeConstraintAnimator.prototype.toNumber = function(value) {
      return typeof value === "number" ? value : 0;
    };
    NumberThemeConstraintAnimator.prototype.fromAny = function(value) {
      if (typeof value === "string") {
        const number = +value;
        if (isFinite(number)) {
          return number;
        } else {
          throw new Error(value);
        }
      } else {
        return value;
      }
    };
    NumberThemeConstraintAnimator.prototype.equalValues = function(newValue, oldValue) {
      return newValue === oldValue;
    };
    return NumberThemeConstraintAnimator;
  }(ThemeConstraintAnimator);
  const LengthThemeConstraintAnimator = function(_super) {
    const LengthThemeConstraintAnimator = _super.extend("LengthThemeConstraintAnimator");
    LengthThemeConstraintAnimator.prototype.toNumber = function(value) {
      try {
        return value !== void 0 && value !== null ? value.pxValue() : 0;
      } catch (swallow) {
        return 0;
      }
    };
    LengthThemeConstraintAnimator.prototype.fromAny = function(value) {
      return value !== void 0 && value !== null ? math.Length.fromAny(value) : null;
    };
    LengthThemeConstraintAnimator.prototype.equalValues = function(newValue, oldValue) {
      if (newValue !== void 0 && newValue !== null) {
        return newValue.equals(oldValue);
      } else {
        return newValue === oldValue;
      }
    };
    return LengthThemeConstraintAnimator;
  }(ThemeConstraintAnimator);
  Look.font = new FontLook("font");
  Look.color = new ColorLook("color");
  Look.iconColor = new ColorLook("iconColor");
  Look.statusColor = new ColorLook("statusColor");
  Look.accentColor = new ColorLook("accentColor");
  Look.mutedColor = new ColorLook("mutedColor");
  Look.neutralColor = new ColorLook("neutralColor");
  Look.subduedColor = new ColorLook("subduedColor");
  Look.faintColor = new ColorLook("faintColor");
  Look.highlightColor = new ColorLook("highlightColor");
  Look.backgroundColor = new ColorLook("backgroundColor");
  Look.borderColor = new ColorLook("borderColor");
  Look.opacity = new NumberLook("opacity");
  Look.shadow = new ShadowLook("shadow");
  Look.spacing = new LengthLook("spacing");
  Look.timing = new TimingLook("timing");
  Feel.ambient = new InterpolatedFeel("ambient");
  Feel.default = new InterpolatedFeel("default");
  Feel.primary = new InterpolatedFeel("primary");
  Feel.secondary = new InterpolatedFeel("secondary");
  Feel.unselected = new InterpolatedFeel("unselected");
  Feel.selected = new InterpolatedFeel("selected");
  Feel.disabled = new InterpolatedFeel("disabled");
  Feel.inactive = new InterpolatedFeel("inactive");
  Feel.warning = new InterpolatedFeel("warning");
  Feel.alert = new InterpolatedFeel("alert");
  Feel.darker = new BrightnessFeel("darker");
  Feel.lighter = new BrightnessFeel("lighter");
  Feel.contrasted = new BrightnessFeel("contrasted");
  Feel.raised = new InterpolatedFeel("raised");
  Feel.covered = new InterpolatedFeel("covered");
  Feel.opaque = new InterpolatedFeel("opaque");
  Feel.floating = new InterpolatedFeel("floating");
  Feel.transparent = new InterpolatedFeel("transparent");
  Feel.translucent = new OpacityFeel("translucent");
  Feel.embossed = new BrightnessFeel("embossed");
  Feel.nested = new BrightnessFeel("nested");
  Feel.hovering = new BrightnessFeel("hovering");
  Feel.navigating = new InterpolatedFeel("navigating");
  Mood.ambient = MoodVector.of([ Feel.ambient, 1 ]);
  Mood.default = MoodVector.of([ Feel.default, 1 ]);
  Mood.primary = MoodVector.of([ Feel.primary, 1 ]);
  Mood.secondary = MoodVector.of([ Feel.secondary, 1 ]);
  Mood.selected = MoodVector.of([ Feel.selected, 1 ]);
  Mood.disabled = MoodVector.of([ Feel.disabled, 1 ]);
  Mood.inactive = MoodVector.of([ Feel.inactive, 1 ]);
  Mood.warning = MoodVector.of([ Feel.warning, 1 ]);
  Mood.alert = MoodVector.of([ Feel.alert, 1 ]);
  Mood.darker = MoodVector.of([ Feel.darker, 1 ]);
  Mood.lighter = MoodVector.of([ Feel.lighter, 1 ]);
  Mood.contrasted = MoodVector.of([ Feel.contrasted, 1 ]);
  Mood.raised = MoodVector.of([ Feel.raised, 1 ]);
  Mood.covered = MoodVector.of([ Feel.covered, 1 ]);
  Mood.opaque = MoodVector.of([ Feel.opaque, 1 ]);
  Mood.floating = MoodVector.of([ Feel.floating, 1 ]);
  Mood.transparent = MoodVector.of([ Feel.transparent, 1 ]);
  Mood.translucent = MoodVector.of([ Feel.translucent, 1 ]);
  Mood.embossed = MoodVector.of([ Feel.embossed, 1 ]);
  Mood.nested = MoodVector.of([ Feel.nested, 1 ]);
  Mood.hovering = MoodVector.of([ Feel.hovering, 1 ]);
  Mood.navigating = MoodVector.of([ Feel.navigating, 1 ]);
  const DarkFont = Font.parse("14px -apple-system, system-ui, sans-serif");
  const DarkColor = Color.parse("#d8d8d8");
  const DarkIconColor = Color.parse("#d8d8d8");
  const DarkAccentColor = Color.parse("#6c6d6e");
  const DarkMutedColor = Color.parse("#989898");
  const DarkNeutralColor = Color.parse("#808080");
  const DarkSubduedColor = Color.parse("#28292a");
  const DarkFaintColor = Color.parse("#1f2123");
  const DarkHighlightColor = Color.white(.1);
  const DarkBackgroundColor = Color.parse("#161719");
  const DarkBorderColor = DarkBackgroundColor.lighter(2 / 3);
  const DarkRaisedColor = Color.parse("#18191b");
  const DarkCoveredColor = Color.parse("#1e2022");
  const DarkPrimaryColor = Color.parse("#66ffdd");
  const DarkSecondaryColor = Color.parse("#32c5ff");
  const DarkDisabledColor = Color.parse("#7b7c7d");
  const DarkInactiveColor = Color.parse("#7b7c7d");
  const DarkWarningColor = Color.parse("#f9f070");
  const DarkAlertColor = Color.parse("#f6511d");
  const DarkSpacing = math.Length.px(10);
  const DarkAmbient = FeelVector.of([ Look.font, DarkFont ], [ Look.color, DarkColor ], [ Look.iconColor, DarkIconColor ], [ Look.statusColor, DarkColor ], [ Look.accentColor, DarkAccentColor ], [ Look.mutedColor, DarkMutedColor ], [ Look.neutralColor, DarkNeutralColor ], [ Look.subduedColor, DarkSubduedColor ], [ Look.faintColor, DarkFaintColor ], [ Look.highlightColor, DarkHighlightColor ], [ Look.backgroundColor, DarkBackgroundColor ], [ Look.borderColor, DarkBorderColor ], [ Look.spacing, DarkSpacing ], [ Look.timing, util.Easing.linear.withDuration(1e3) ]);
  const DarkDefault = FeelVector.of([ Look.font, DarkFont ], [ Look.color, DarkColor ], [ Look.iconColor, DarkIconColor ], [ Look.statusColor, DarkColor ], [ Look.accentColor, DarkAccentColor ], [ Look.mutedColor, DarkMutedColor ], [ Look.neutralColor, DarkNeutralColor ], [ Look.subduedColor, DarkSubduedColor ], [ Look.faintColor, DarkFaintColor ], [ Look.highlightColor, DarkHighlightColor ], [ Look.backgroundColor, DarkBackgroundColor ], [ Look.borderColor, DarkBorderColor ], [ Look.spacing, DarkSpacing ], [ Look.timing, util.Easing.cubicOut.withDuration(250) ]);
  const DarkPrimary = FeelVector.of([ Look.accentColor, DarkPrimaryColor ]);
  const DarkSecondary = FeelVector.of([ Look.accentColor, DarkSecondaryColor ]);
  const DarkUnselected = FeelVector.of([ Look.color, DarkMutedColor ], [ Look.iconColor, DarkMutedColor ], [ Look.backgroundColor, DarkBackgroundColor.darker(1) ]);
  const DarkSelected = FeelVector.of([ Look.color, DarkColor ], [ Look.iconColor, DarkIconColor ], [ Look.backgroundColor, DarkBackgroundColor.darker(1) ]);
  const DarkDisabled = FeelVector.of([ Look.color, DarkDisabledColor ], [ Look.iconColor, DarkDisabledColor ], [ Look.statusColor, DarkDisabledColor ], [ Look.accentColor, DarkDisabledColor ]);
  const DarkInactive = FeelVector.of([ Look.statusColor, DarkInactiveColor ], [ Look.accentColor, DarkInactiveColor ]);
  const DarkWarning = FeelVector.of([ Look.statusColor, DarkWarningColor ], [ Look.accentColor, DarkWarningColor ]);
  const DarkAlert = FeelVector.of([ Look.statusColor, DarkAlertColor ], [ Look.accentColor, DarkAlertColor ]);
  const DarkRaised = FeelVector.of([ Look.mutedColor, DarkMutedColor.darker(1 / 3) ], [ Look.neutralColor, DarkNeutralColor.darker(1 / 3) ], [ Look.backgroundColor, DarkRaisedColor ]);
  const DarkCovered = FeelVector.of([ Look.mutedColor, DarkMutedColor.darker(1 / 3) ], [ Look.neutralColor, DarkNeutralColor.darker(1 / 3) ], [ Look.backgroundColor, DarkCoveredColor ]);
  const DarkOpaque = FeelVector.of([ Look.backgroundColor, DarkBackgroundColor ], [ Look.borderColor, DarkBorderColor ]);
  const DarkFloating = FeelVector.of([ Look.shadow, BoxShadow.create(0, 2, 4, 0, Color.black(.5)) ]);
  const DarkTransparent = FeelVector.of([ Look.backgroundColor, DarkBackgroundColor.alpha(0) ], [ Look.borderColor, DarkBorderColor.alpha(0) ]);
  const DarkTranslucent = FeelVector.of([ Look.iconColor, Color.black(.8) ], [ Look.statusColor, Color.black(.8) ], [ Look.accentColor, Color.black(.8) ], [ Look.backgroundColor, Color.black(.8) ], [ Look.borderColor, Color.black(.8) ]);
  const DarkDarker = FeelVector.of([ Look.iconColor, Color.black(1) ], [ Look.statusColor, Color.black(1) ], [ Look.accentColor, Color.black(1) ]);
  const DarkLighter = FeelVector.of([ Look.iconColor, Color.black(-1) ], [ Look.statusColor, Color.black(-1) ], [ Look.accentColor, Color.black(-1) ]);
  const DarkContrasted = FeelVector.of([ Look.iconColor, Color.black(-1) ], [ Look.statusColor, Color.black(-1) ], [ Look.accentColor, Color.black(-1) ]);
  const DarkEmbossed = FeelVector.of([ Look.iconColor, Color.black(2) ], [ Look.statusColor, Color.black(2) ], [ Look.accentColor, Color.black(2) ]);
  const DarkNested = FeelVector.of([ Look.backgroundColor, Color.black(1 / 3) ], [ Look.borderColor, Color.black(1 / 3) ]);
  const DarkHovering = FeelVector.of([ Look.statusColor, Color.black(1) ], [ Look.accentColor, Color.black(1) ], [ Look.backgroundColor, Color.black(-2) ]);
  const DarkNavigating = FeelVector.of([ Look.timing, util.Easing.cubicOut.withDuration(350) ]);
  const DarkTheme = ThemeMatrix.forCols([ Feel.ambient, DarkAmbient ], [ Feel.default, DarkDefault ], [ Feel.primary, DarkPrimary ], [ Feel.secondary, DarkSecondary ], [ Feel.unselected, DarkUnselected ], [ Feel.selected, DarkSelected ], [ Feel.disabled, DarkDisabled ], [ Feel.inactive, DarkInactive ], [ Feel.warning, DarkWarning ], [ Feel.alert, DarkAlert ], [ Feel.darker, DarkDarker ], [ Feel.lighter, DarkLighter ], [ Feel.contrasted, DarkContrasted ], [ Feel.raised, DarkRaised ], [ Feel.covered, DarkCovered ], [ Feel.opaque, DarkOpaque ], [ Feel.floating, DarkFloating ], [ Feel.transparent, DarkTransparent ], [ Feel.translucent, DarkTranslucent ], [ Feel.embossed, DarkEmbossed ], [ Feel.nested, DarkNested ], [ Feel.hovering, DarkHovering ], [ Feel.navigating, DarkNavigating ]);
  Theme.dark = DarkTheme;
  const LightFont = Font.parse("14px -apple-system, system-ui, sans-serif");
  const LightColor = Color.parse("#4a4a4a");
  const LightIconColor = Color.parse("#4a4a4a");
  const LightAccentColor = Color.parse("#5c5d5e");
  const LightMutedColor = Color.parse("#989898");
  const LightNeutralColor = Color.parse("#808080");
  const LightSubduedColor = Color.parse("#d7d6d5");
  const LightFaintColor = Color.parse("#e0dedc");
  const LightHighlightColor = Color.black(.05);
  const LightBackgroundColor = Color.parse("#f9f8f6");
  const LightBorderColor = LightBackgroundColor.darker(1 / 2);
  const LightRaisedColor = Color.parse("#f7f6f4");
  const LightCoveredColor = Color.parse("#f1efed");
  const LightPrimaryColor = Color.parse("#4fcfb3");
  const LightSecondaryColor = Color.parse("#008cc7");
  const LightDisabledColor = Color.parse("#7b7c7d");
  const LightInactiveColor = Color.parse("#7b7c7d");
  const LightWarningColor = Color.parse("#e6de65");
  const LightAlertColor = Color.parse("#df4616");
  const LightSpacing = math.Length.px(10);
  const LightAmbient = FeelVector.of([ Look.font, LightFont ], [ Look.color, LightColor ], [ Look.iconColor, LightIconColor ], [ Look.statusColor, LightColor ], [ Look.accentColor, LightAccentColor ], [ Look.mutedColor, LightMutedColor ], [ Look.neutralColor, LightNeutralColor ], [ Look.subduedColor, LightSubduedColor ], [ Look.faintColor, LightFaintColor ], [ Look.highlightColor, LightHighlightColor ], [ Look.backgroundColor, LightBackgroundColor ], [ Look.borderColor, LightBorderColor ], [ Look.spacing, LightSpacing ], [ Look.timing, util.Easing.linear.withDuration(1e3) ]);
  const LightDefault = FeelVector.of([ Look.font, LightFont ], [ Look.color, LightColor ], [ Look.iconColor, LightIconColor ], [ Look.statusColor, LightColor ], [ Look.accentColor, LightAccentColor ], [ Look.mutedColor, LightMutedColor ], [ Look.neutralColor, LightNeutralColor ], [ Look.subduedColor, LightSubduedColor ], [ Look.faintColor, LightFaintColor ], [ Look.highlightColor, LightHighlightColor ], [ Look.backgroundColor, LightBackgroundColor ], [ Look.borderColor, LightBorderColor ], [ Look.spacing, LightSpacing ], [ Look.timing, util.Easing.cubicOut.withDuration(250) ]);
  const LightPrimary = FeelVector.of([ Look.accentColor, LightPrimaryColor ]);
  const LightSecondary = FeelVector.of([ Look.accentColor, LightSecondaryColor ]);
  const LightUnselected = FeelVector.of([ Look.color, LightMutedColor ], [ Look.iconColor, LightMutedColor ], [ Look.backgroundColor, LightBackgroundColor.darker(1 / 2) ]);
  const LightSelected = FeelVector.of([ Look.color, LightColor ], [ Look.iconColor, LightIconColor ], [ Look.backgroundColor, LightBackgroundColor.darker(1 / 2) ]);
  const LightDisabled = FeelVector.of([ Look.color, LightDisabledColor ], [ Look.iconColor, LightDisabledColor ], [ Look.statusColor, LightDisabledColor ], [ Look.accentColor, LightDisabledColor ]);
  const LightInactive = FeelVector.of([ Look.statusColor, LightInactiveColor ], [ Look.accentColor, LightInactiveColor ]);
  const LightWarning = FeelVector.of([ Look.statusColor, LightWarningColor ], [ Look.accentColor, LightWarningColor ]);
  const LightAlert = FeelVector.of([ Look.statusColor, LightAlertColor ], [ Look.accentColor, LightAlertColor ]);
  const LightRaised = FeelVector.of([ Look.mutedColor, LightMutedColor.darker(1 / 3) ], [ Look.neutralColor, LightNeutralColor.darker(1 / 3) ], [ Look.backgroundColor, LightRaisedColor ]);
  const LightCovered = FeelVector.of([ Look.mutedColor, LightMutedColor.darker(1 / 3) ], [ Look.neutralColor, LightNeutralColor.darker(1 / 3) ], [ Look.backgroundColor, LightCoveredColor ]);
  const LightOpaque = FeelVector.of([ Look.backgroundColor, LightBackgroundColor ], [ Look.borderColor, LightBorderColor ]);
  const LightFloating = FeelVector.of([ Look.shadow, BoxShadow.create(0, 2, 4, 0, Color.black(.5)) ]);
  const LightTransparent = FeelVector.of([ Look.backgroundColor, LightBackgroundColor.alpha(0) ], [ Look.borderColor, LightBorderColor.alpha(0) ]);
  const LightTranslucent = FeelVector.of([ Look.iconColor, Color.black(.8) ], [ Look.statusColor, Color.black(.8) ], [ Look.accentColor, Color.black(.8) ], [ Look.backgroundColor, Color.black(.8) ], [ Look.borderColor, Color.black(.8) ]);
  const LightDarker = FeelVector.of([ Look.iconColor, Color.black(1) ], [ Look.statusColor, Color.black(1) ], [ Look.accentColor, Color.black(1) ]);
  const LightLighter = FeelVector.of([ Look.iconColor, Color.black(-1) ], [ Look.statusColor, Color.black(-1) ], [ Look.accentColor, Color.black(-1) ]);
  const LightContrasted = FeelVector.of([ Look.iconColor, Color.black(1) ], [ Look.statusColor, Color.black(1) ], [ Look.accentColor, Color.black(1) ]);
  const LightEmbossed = FeelVector.of([ Look.iconColor, Color.black(1) ], [ Look.statusColor, Color.black(1) ], [ Look.accentColor, Color.black(1) ]);
  const LightNested = FeelVector.of([ Look.backgroundColor, Color.black(1 / 24) ], [ Look.borderColor, Color.black(1 / 24) ]);
  const LightHovering = FeelVector.of([ Look.statusColor, Color.black(1 / 4) ], [ Look.accentColor, Color.black(1 / 4) ], [ Look.backgroundColor, Color.black(1 / 4) ]);
  const LightNavigating = FeelVector.of([ Look.timing, util.Easing.cubicOut.withDuration(350) ]);
  const LightTheme = ThemeMatrix.forCols([ Feel.ambient, LightAmbient ], [ Feel.default, LightDefault ], [ Feel.primary, LightPrimary ], [ Feel.secondary, LightSecondary ], [ Feel.unselected, LightUnselected ], [ Feel.selected, LightSelected ], [ Feel.disabled, LightDisabled ], [ Feel.inactive, LightInactive ], [ Feel.warning, LightWarning ], [ Feel.alert, LightAlert ], [ Feel.darker, LightDarker ], [ Feel.lighter, LightLighter ], [ Feel.contrasted, LightContrasted ], [ Feel.raised, LightRaised ], [ Feel.covered, LightCovered ], [ Feel.opaque, LightOpaque ], [ Feel.floating, LightFloating ], [ Feel.transparent, LightTransparent ], [ Feel.translucent, LightTranslucent ], [ Feel.embossed, LightEmbossed ], [ Feel.nested, LightNested ], [ Feel.hovering, LightHovering ], [ Feel.navigating, LightNavigating ]);
  Theme.light = LightTheme;
  const Viewport = function() {
    const Viewport = {};
    Viewport.detect = function() {
      let insetTop = 0;
      let insetRight = 0;
      let insetBottom = 0;
      let insetLeft = 0;
      const documentWidth = document.documentElement.style.width;
      const documentHeight = document.documentElement.style.height;
      document.documentElement.style.width = "100%";
      document.documentElement.style.height = "100%";
      const div = document.createElement("div");
      div.style.setProperty("position", "fixed");
      div.style.setProperty("top", "0");
      div.style.setProperty("right", "0");
      div.style.setProperty("width", window.innerWidth === document.documentElement.offsetWidth ? "100%" : "100vw");
      div.style.setProperty("height", window.innerHeight === document.documentElement.offsetHeight ? "100%" : "100vh");
      div.style.setProperty("box-sizing", "border-box");
      div.style.setProperty("padding-top", "env(safe-area-inset-top)");
      div.style.setProperty("padding-right", "env(safe-area-inset-right)");
      div.style.setProperty("padding-bottom", "env(safe-area-inset-bottom)");
      div.style.setProperty("padding-left", "env(safe-area-inset-left)");
      div.style.setProperty("overflow", "hidden");
      div.style.setProperty("visibility", "hidden");
      document.body.appendChild(div);
      const style = window.getComputedStyle(div);
      const width = parseFloat(style.getPropertyValue("width"));
      const height = parseFloat(style.getPropertyValue("height"));
      let visualWidth = width;
      let visualHeight = height;
      let visualOffsetLeft = 0;
      let visualOffsetTop = 0;
      let visualPageLeft = 0;
      let visualPageTop = 0;
      let visualScale = 1;
      if (window.visualViewport !== void 0) {
        visualWidth = window.visualViewport.width;
        visualHeight = window.visualViewport.height;
        visualOffsetLeft = window.visualViewport.offsetLeft;
        visualOffsetTop = window.visualViewport.offsetTop;
        visualPageLeft = window.visualViewport.pageLeft;
        visualPageTop = window.visualViewport.pageTop;
        visualScale = window.visualViewport.scale;
      }
      const visual = {
        width: visualWidth,
        height: visualHeight,
        offsetLeft: visualOffsetLeft,
        offsetTop: visualOffsetTop,
        pageLeft: visualPageLeft,
        pageTop: visualPageTop,
        scale: visualScale
      };
      if (typeof CSS !== "undefined" && typeof CSS.supports === "function" && CSS.supports("padding-top: env(safe-area-inset-top)")) {
        insetTop = parseFloat(style.getPropertyValue("padding-top"));
        insetRight = parseFloat(style.getPropertyValue("padding-right"));
        insetBottom = parseFloat(style.getPropertyValue("padding-bottom"));
        insetLeft = parseFloat(style.getPropertyValue("padding-left"));
      }
      document.body.removeChild(div);
      document.documentElement.style.width = documentWidth;
      document.documentElement.style.height = documentHeight;
      const safeArea = {
        insetTop: insetTop,
        insetRight: insetRight,
        insetBottom: insetBottom,
        insetLeft: insetLeft
      };
      let orientation = screen.msOrientation || screen.mozOrientation || (screen.orientation || {}).type;
      if (orientation === void 0) {
        switch (window.orientation) {
         case 0:
          orientation = "portrait-primary";
          break;

         case 180:
          orientation = "portrait-secondary";
          break;

         case -90:
          orientation = "landscape-primary";
          break;

         case 90:
          orientation = "landscape-secondary";
          break;

         default:
          orientation = "landscape-primary";
        }
      }
      let colorScheme;
      if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
        colorScheme = "dark";
      } else if (window.matchMedia("(prefers-color-scheme: light)").matches) {
        colorScheme = "light";
      } else {
        colorScheme = "no-preference";
      }
      return {
        width: width,
        height: height,
        visual: visual,
        safeArea: safeArea,
        orientation: orientation,
        colorScheme: colorScheme
      };
    };
    return Viewport;
  }();
  const ViewContext = function() {
    const ViewContext = {};
    ViewContext.current = null;
    ViewContext.create = function() {
      const viewport = Viewport.detect();
      const viewFrame = new math.R2Box(0, 0, viewport.width, viewport.height);
      return {
        updateTime: performance.now(),
        viewportIdiom: "unspecified",
        viewport: viewport,
        viewFrame: viewFrame
      };
    };
    return ViewContext;
  }();
  class ViewportService extends component.Service {
    constructor() {
      super();
      this.viewContext = ViewContext.create();
      this.viewportResizeTimer = 0;
      this.reorientationTimer = 0;
      this.throttleScroll = this.throttleScroll.bind(this);
      this.throttleResize = this.throttleResize.bind(this);
      this.debounceViewportResize = this.debounceViewportResize.bind(this);
      this.throttleViewportResize = this.throttleViewportResize.bind(this);
      this.debounceReorientation = this.debounceReorientation.bind(this);
      this.throttleReorientation = this.throttleReorientation.bind(this);
    }
    get viewport() {
      return this.viewContext.viewport;
    }
    get viewportIdiom() {
      return this.viewContext.viewportIdiom;
    }
    detectViewportIdiom(viewport) {
      if (viewport.width < 960 || viewport.height < 480) {
        return "mobile";
      } else {
        return "desktop";
      }
    }
    updateViewportIdiom(viewport) {
      let viewportIdiom;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.detectViewportIdiom !== void 0) {
          viewportIdiom = observer.detectViewportIdiom(viewport, this);
          if (viewportIdiom !== void 0) {
            break;
          }
        }
      }
      if (viewportIdiom === void 0) {
        viewportIdiom = this.detectViewportIdiom(viewport);
      }
      if (viewportIdiom !== void 0) {
        this.setViewportIdiom(viewportIdiom);
      }
    }
    setViewportIdiom(newViewportIdiom) {
      const viewContext = this.viewContext;
      const oldViewportIdiom = viewContext.viewportIdiom;
      if (oldViewportIdiom !== newViewportIdiom) {
        this.willSetViewportIdiom(newViewportIdiom, oldViewportIdiom);
        viewContext.viewportIdiom = newViewportIdiom;
        this.onSetViewportIdiom(newViewportIdiom, oldViewportIdiom);
        this.didSetViewportIdiom(newViewportIdiom, oldViewportIdiom);
      }
    }
    willSetViewportIdiom(newViewportIdiom, oldViewportIdiom) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceWillSetViewportIdiom !== void 0) {
          observer.serviceWillSetViewportIdiom(newViewportIdiom, oldViewportIdiom, this);
        }
      }
    }
    onSetViewportIdiom(newViewportIdiom, oldViewportIdiom) {
      const roots = this.roots;
      for (let i = 0, n = roots.length; i < n; i += 1) {
        roots[i].requireUpdate(View.NeedsLayout);
      }
    }
    didSetViewportIdiom(newViewportIdiom, oldViewportIdiom) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceDidSetViewportIdiom !== void 0) {
          observer.serviceDidSetViewportIdiom(newViewportIdiom, oldViewportIdiom, this);
        }
      }
    }
    willReorient(orientation) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceWillReorient !== void 0) {
          observer.serviceWillReorient(orientation, this);
        }
      }
    }
    onReorient(orientation) {}
    didReorient(orientation) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceDidReorient !== void 0) {
          observer.serviceDidReorient(orientation, this);
        }
      }
    }
    onObserve(observer) {
      super.onObserve(observer);
      if (this.attached) {
        this.updateViewportIdiom(this.viewport);
      }
    }
    onAttach() {
      super.onAttach();
      this.attachEvents();
      this.updateViewportIdiom(this.viewport);
    }
    onDetach() {
      this.detachEvents();
      super.onDetach();
    }
    attachEvents() {
      if (typeof window !== "undefined") {
        window.addEventListener("scroll", this.throttleScroll, {
          passive: true
        });
        window.addEventListener("resize", this.throttleResize);
        window.addEventListener("orientationchange", this.debounceReorientation);
        if (window.visualViewport !== void 0) {
          window.visualViewport.addEventListener("resize", this.debounceViewportResize);
        }
      }
    }
    detachEvents() {
      if (typeof window !== "undefined") {
        window.removeEventListener("scroll", this.throttleScroll);
        window.removeEventListener("resize", this.throttleResize);
        window.removeEventListener("orientationchange", this.debounceReorientation);
        if (window.visualViewport !== void 0) {
          window.visualViewport.removeEventListener("resize", this.debounceViewportResize);
        }
      }
    }
    throttleScroll() {
      const roots = this.roots;
      for (let i = 0, n = roots.length; i < n; i += 1) {
        roots[i].requireUpdate(View.NeedsScroll);
      }
    }
    throttleResize() {
      const viewport = Viewport.detect();
      const viewFrame = new math.R2Box(0, 0, viewport.width, viewport.height);
      this.viewContext.viewport = viewport;
      this.viewContext.viewFrame = viewFrame;
      this.updateViewportIdiom(viewport);
      const roots = this.roots;
      for (let i = 0, n = roots.length; i < n; i += 1) {
        roots[i].requireUpdate(View.NeedsResize | View.NeedsLayout);
      }
    }
    debounceViewportResize() {
      if (this.viewportResizeTimer !== 0) {
        clearTimeout(this.viewportResizeTimer);
        this.viewportResizeTimer = 0;
      }
      this.viewportResizeTimer = setTimeout(this.throttleViewportResize, ViewportService.ViewportResizeDelay);
    }
    throttleViewportResize() {
      if (this.viewportResizeTimer !== 0) {
        clearTimeout(this.viewportResizeTimer);
        this.viewportResizeTimer = 0;
      }
      const viewport = Viewport.detect();
      const viewFrame = new math.R2Box(0, 0, viewport.width, viewport.height);
      this.viewContext.viewport = viewport;
      this.viewContext.viewFrame = viewFrame;
      this.updateViewportIdiom(viewport);
      const roots = this.roots;
      for (let i = 0, n = roots.length; i < n; i += 1) {
        roots[i].requireUpdate(View.NeedsResize | View.NeedsScroll | View.NeedsLayout);
      }
    }
    debounceReorientation() {
      if (this.reorientationTimer !== 0) {
        clearTimeout(this.reorientationTimer);
        this.reorientationTimer = 0;
      }
      this.reorientationTimer = setTimeout(this.throttleReorientation, ViewportService.ReorientationDelay);
    }
    throttleReorientation() {
      if (this.reorientationTimer !== 0) {
        clearTimeout(this.reorientationTimer);
        this.reorientationTimer = 0;
      }
      const viewport = Viewport.detect();
      const viewFrame = new math.R2Box(0, 0, viewport.width, viewport.height);
      this.viewContext.viewport = viewport;
      this.viewContext.viewFrame = viewFrame;
      this.willReorient(viewport.orientation);
      this.updateViewportIdiom(viewport);
      this.onReorient(viewport.orientation);
      this.didReorient(viewport.orientation);
      const roots = this.roots;
      for (let i = 0, n = roots.length; i < n; i += 1) {
        roots[i].requireUpdate(View.NeedsResize | View.NeedsScroll | View.NeedsLayout);
      }
    }
    static global() {
      return new ViewportService;
    }
  }
  ViewportService.ViewportResizeDelay = 200;
  ViewportService.ReorientationDelay = 100;
  __decorate([ util.Lazy ], ViewportService, "global", null);
  const ViewportProvider = function(_super) {
    const ViewportProvider = _super.extend("ViewportProvider");
    Object.defineProperty(ViewportProvider.prototype, "viewContext", {
      get() {
        let service = this.service;
        if (service === void 0 || service === null) {
          service = ViewportService.global();
        }
        return service.viewContext;
      },
      configurable: true
    });
    Object.defineProperty(ViewportProvider.prototype, "viewport", {
      get() {
        let service = this.service;
        if (service === void 0 || service === null) {
          service = ViewportService.global();
        }
        return service.viewport;
      },
      configurable: true
    });
    Object.defineProperty(ViewportProvider.prototype, "viewportIdiom", {
      get() {
        let service = this.service;
        if (service === void 0 || service === null) {
          service = ViewportService.global();
        }
        return service.viewportIdiom;
      },
      configurable: true
    });
    ViewportProvider.prototype.setViewportIdiom = function(viewportIdiom) {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = ViewportService.global();
      }
      service.setViewportIdiom(viewportIdiom);
    };
    ViewportProvider.prototype.createService = function() {
      return ViewportService.global();
    };
    return ViewportProvider;
  }(component.Provider);
  class DisplayService extends component.Service {
    constructor() {
      super();
      this.flags = 0;
      this.updateDelay = DisplayService.MinUpdateDelay;
      this.processTimer = 0;
      this.displayFrame = 0;
      this.runProcessPass = this.runProcessPass.bind(this);
      this.runDisplayPass = this.runDisplayPass.bind(this);
      this.onVisibilityChange = this.onVisibilityChange.bind(this);
    }
    setFlags(flags) {
      this.flags = flags;
    }
    updatedViewContext(viewContext) {
      viewContext.updateTime = performance.now();
      return viewContext;
    }
    needsUpdate(updateFlags, immediate) {
      return updateFlags;
    }
    requestUpdate(targetView, updateFlags, immediate) {
      updateFlags = this.needsUpdate(updateFlags, immediate);
      let deltaUpdateFlags = this.flags & ~updateFlags & View.UpdateMask;
      if ((updateFlags & View.ProcessMask) !== 0) {
        deltaUpdateFlags |= View.NeedsProcess;
      }
      if ((updateFlags & View.DisplayMask) !== 0) {
        deltaUpdateFlags |= View.NeedsDisplay;
      }
      this.setFlags(this.flags | deltaUpdateFlags);
      if (immediate && (this.flags & (View.ProcessingFlag | View.DisplayingFlag)) === 0 && this.updateDelay <= DisplayService.MaxProcessInterval) {
        this.runImmediatePass();
      } else {
        this.scheduleUpdate();
      }
    }
    scheduleUpdate() {
      const flags = this.flags;
      if ((flags & View.ProcessingFlag) === 0 && (flags & View.ProcessMask) !== 0) {
        this.scheduleProcessPass(this.updateDelay);
      } else if ((flags & View.DisplayingFlag) === 0 && (flags & View.DisplayMask) !== 0) {
        this.scheduleDisplayPass();
      }
    }
    cancelUpdate() {
      this.cancelProcessPass();
      this.cancelDisplayPass();
    }
    runImmediatePass() {
      if ((this.flags & View.ProcessMask) !== 0) {
        this.cancelUpdate();
        this.runProcessPass(true);
      }
      if ((this.flags & View.DisplayMask) !== 0 && this.updateDelay <= DisplayService.MaxProcessInterval) {
        this.cancelUpdate();
        this.runDisplayPass(void 0, true);
      }
    }
    scheduleProcessPass(updateDelay) {
      if (this.processTimer === 0) {
        this.processTimer = setTimeout(this.runProcessPass, updateDelay);
      }
    }
    cancelProcessPass() {
      if (this.processTimer !== 0) {
        clearTimeout(this.processTimer);
        this.processTimer = 0;
      }
    }
    runProcessPass(immediate = false) {
      this.setFlags(this.flags & ~View.ProcessMask | View.ProcessingFlag);
      try {
        const t0 = performance.now();
        const roots = this.roots;
        for (let i = 0; i < roots.length; i += 1) {
          const root = roots[i];
          if ((root.flags & View.ProcessMask) !== 0) {
            const viewContext = root.viewportProvider.viewContext;
            viewContext.updateTime = t0;
            root.cascadeProcess(0, viewContext);
          }
        }
        const t1 = performance.now();
        let processDelay = Math.max(DisplayService.MinProcessInterval, this.updateDelay);
        if (t1 - t0 > processDelay) {
          this.updateDelay = Math.min(Math.max(2, this.updateDelay * 2), DisplayService.MaxUpdateDelay);
        } else {
          this.updateDelay = Math.min(DisplayService.MinUpdateDelay, this.updateDelay / 2);
        }
        this.cancelProcessPass();
        if ((this.flags & View.DisplayMask) !== 0) {
          this.scheduleDisplayPass();
        } else if ((this.flags & View.ProcessMask) !== 0) {
          if (immediate) {
            processDelay = Math.max(DisplayService.MaxProcessInterval, processDelay);
          }
          this.cancelDisplayPass();
          this.scheduleProcessPass(processDelay);
        }
      } finally {
        this.setFlags(this.flags & ~View.ProcessingFlag);
      }
    }
    scheduleDisplayPass() {
      if (this.displayFrame === 0) {
        this.displayFrame = requestAnimationFrame(this.runDisplayPass);
      }
    }
    cancelDisplayPass() {
      if (this.displayFrame !== 0) {
        cancelAnimationFrame(this.displayFrame);
        this.displayFrame = 0;
      }
    }
    runDisplayPass(time, immediate = false) {
      this.setFlags(this.flags & ~View.DisplayMask | View.DisplayingFlag);
      try {
        if (time === void 0) {
          time = performance.now();
        }
        const roots = this.roots;
        for (let i = 0; i < roots.length; i += 1) {
          const root = roots[i];
          if ((root.flags & View.DisplayMask) !== 0) {
            const viewContext = root.viewportProvider.viewContext;
            viewContext.updateTime = time;
            root.cascadeDisplay(0, viewContext);
          }
        }
        this.cancelDisplayPass();
        if ((this.flags & View.ProcessMask) !== 0) {
          let processDelay = this.updateDelay;
          if (immediate) {
            processDelay = Math.max(DisplayService.MaxProcessInterval, processDelay);
          }
          this.scheduleProcessPass(processDelay);
        } else if ((this.flags & View.DisplayMask) !== 0) {
          this.cancelProcessPass();
          this.scheduleDisplayPass();
        }
      } finally {
        this.setFlags(this.flags & ~View.DisplayingFlag);
      }
    }
    get powerFlags() {
      return View.NeedsResize | View.NeedsScroll;
    }
    power() {
      const roots = this.roots;
      for (let i = 0, n = roots.length; i < n; i += 1) {
        const root = roots[i];
        root.requireUpdate(this.powerFlags);
      }
    }
    unpower() {
      this.cancelUpdate();
      this.updateDelay = DisplayService.MinUpdateDelay;
    }
    onAttachRoot(root) {
      super.onAttachRoot(root);
      this.requestUpdate(root, root.flags & View.UpdateMask, false);
    }
    onAttach() {
      super.onAttach();
      this.attachEvents();
    }
    onDetach() {
      this.detachEvents();
      super.onDetach();
    }
    attachEvents() {
      if (typeof document !== "undefined") {
        document.addEventListener("visibilitychange", this.onVisibilityChange);
      }
    }
    detachEvents() {
      if (typeof document !== "undefined") {
        document.removeEventListener("visibilitychange", this.onVisibilityChange);
      }
    }
    onVisibilityChange() {
      if (document.visibilityState === "visible") {
        this.power();
      } else {
        this.unpower();
      }
    }
    static global() {
      return new DisplayService;
    }
  }
  DisplayService.MinUpdateDelay = 0;
  DisplayService.MaxUpdateDelay = 167;
  DisplayService.MinProcessInterval = 12;
  DisplayService.MaxProcessInterval = 33;
  __decorate([ util.Lazy ], DisplayService, "global", null);
  const DisplayProvider = function(_super) {
    const DisplayProvider = _super.extend("DisplayProvider");
    DisplayProvider.prototype.updatedViewContext = function(viewContext) {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = DisplayService.global();
      }
      return service.updatedViewContext(viewContext);
    };
    DisplayProvider.prototype.requestUpdate = function(target, updateFlags, immediate) {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = DisplayService.global();
      }
      service.requestUpdate(target, updateFlags, immediate);
    };
    DisplayProvider.prototype.createService = function() {
      return DisplayService.global();
    };
    return DisplayProvider;
  }(component.Provider);
  class LayoutService extends component.Service {
    constructor() {
      super();
      this.solver = this.createSolver();
    }
    createSolver() {
      return new constraint.ConstraintSolver;
    }
    activateConstraint(constraint) {
      this.solver.addConstraint(constraint);
    }
    deactivateConstraint(constraint) {
      this.solver.removeConstraint(constraint);
    }
    activateConstraintVariable(variable) {
      this.solver.addConstraintVariable(variable);
    }
    deactivateConstraintVariable(variable) {
      this.solver.removeConstraintVariable(variable);
    }
    setConstraintVariable(variable, value) {
      this.solver.setConstraintVariable(variable, value);
    }
    static global() {
      return new LayoutService;
    }
  }
  __decorate([ util.Lazy ], LayoutService, "global", null);
  const LayoutProvider = function(_super) {
    const LayoutProvider = _super.extend("LayoutProvider");
    LayoutProvider.prototype.createService = function() {
      return LayoutService.global();
    };
    return LayoutProvider;
  }(component.Provider);
  class ThemeService extends component.Service {
    constructor() {
      super();
      this.mood = this.initMood();
      this.theme = this.initTheme();
    }
    initMood() {
      return Mood.default;
    }
    setMood(mood) {
      this.mood = mood;
      this.applyTheme(this.theme, mood);
      const roots = this.roots;
      for (let i = 0, n = roots.length; i < n; i += 1) {
        const root = roots[i];
        if (root.mood.hasAffinity(component.Affinity.Intrinsic)) {
          root.mood.setValue(mood, component.Affinity.Intrinsic);
          root.requireUpdate(View.NeedsChange);
        }
      }
    }
    initTheme() {
      const viewport = Viewport.detect();
      const colorScheme = viewport.colorScheme;
      if (colorScheme === "dark") {
        return Theme.dark;
      } else {
        return Theme.light;
      }
    }
    setTheme(theme) {
      this.theme = theme;
      this.applyTheme(theme, this.mood);
      const roots = this.roots;
      for (let i = 0, n = roots.length; i < n; i += 1) {
        const root = roots[i];
        if (root.theme.hasAffinity(component.Affinity.Intrinsic)) {
          root.theme.setValue(theme, component.Affinity.Intrinsic);
          root.requireUpdate(View.NeedsChange);
        }
      }
    }
    applyTheme(theme, mood, timing) {
      if (timing === void 0 || timing === true) {
        timing = theme.getOr(Look.timing, Mood.ambient, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      this.willApplyTheme(theme, mood, timing);
      this.onApplyTheme(theme, mood, timing);
      this.didApplyTheme(theme, mood, timing);
    }
    willApplyTheme(theme, mood, timing) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceWillApplyTheme !== void 0) {
          observer.serviceWillApplyTheme(theme, mood, timing, this);
        }
      }
    }
    onApplyTheme(theme, mood, timing) {}
    didApplyTheme(theme, mood, timing) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceDidApplyTheme !== void 0) {
          observer.serviceDidApplyTheme(theme, mood, timing, this);
        }
      }
    }
    static global() {
      return new ThemeService;
    }
  }
  __decorate([ util.Lazy ], ThemeService, "global", null);
  const ThemeProvider = function(_super) {
    const ThemeProvider = _super.extend("ThemeProvider");
    Object.defineProperty(ThemeProvider.prototype, "mood", {
      get() {
        let service = this.service;
        if (service === void 0 || service === null) {
          service = ThemeService.global();
        }
        return service.mood;
      },
      configurable: true
    });
    ThemeProvider.prototype.setMood = function(mood) {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = ThemeService.global();
      }
      service.setMood(mood);
    };
    Object.defineProperty(ThemeProvider.prototype, "theme", {
      get() {
        let service = this.service;
        if (service === void 0 || service === null) {
          service = ThemeService.global();
        }
        return service.theme;
      },
      configurable: true
    });
    ThemeProvider.prototype.setTheme = function(theme) {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = ThemeService.global();
      }
      service.setTheme(theme);
    };
    ThemeProvider.prototype.createService = function() {
      return ThemeService.global();
    };
    return ThemeProvider;
  }(component.Provider);
  const Modal = function() {
    const Modal = {};
    Modal.is = function(object) {
      if (typeof object === "object" && object !== null) {
        const modal = object;
        return "modalView" in modal && "modalState" in modal && "modality" in modal && typeof modal.showModal === "function" && typeof modal.hideModal === "function";
      }
      return false;
    };
    return Modal;
  }();
  class ModalService extends component.Service {
    constructor() {
      super();
      this.modals = util.Arrays.empty;
      this.modality = 0;
      this.matteView = null;
      this.onClick = this.onClick.bind(this);
    }
    isModal() {
      return this.modality !== 0;
    }
    setMatteView(matteView) {
      this.matteView = matteView;
    }
    insertModalView(modalView) {
      const matteView = this.matteView;
      if (matteView !== null) {
        matteView.appendChild(modalView);
      } else {
        const serviceClass = this.constructor;
        serviceClass.insertModalView(modalView);
      }
    }
    presentModal(modal, options = {}) {
      const oldModals = this.modals;
      const newModals = util.Arrays.inserted(modal, oldModals);
      if (oldModals !== newModals) {
        if (!options.multi) {
          this.dismissModals();
        }
        this.willPresentModal(modal, options);
        this.modals = newModals;
        const modalView = modal.modalView;
        if (modalView !== null && !modalView.mounted) {
          this.insertModalView(modalView);
        }
        modal.showModal(options, true);
        this.onPresentModal(modal, options);
        this.updateModality();
        this.didPresentModal(modal, options);
      }
    }
    willPresentModal(modal, options) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceWillPresentModal !== void 0) {
          observer.serviceWillPresentModal(modal, options, this);
        }
      }
    }
    onPresentModal(modal, options) {}
    didPresentModal(modal, options) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceDidPresentModal !== void 0) {
          observer.serviceDidPresentModal(modal, options, this);
        }
      }
    }
    dismissModal(modal) {
      const oldModals = this.modals;
      const newModals = util.Arrays.removed(modal, oldModals);
      if (oldModals !== newModals) {
        this.willDismissModal(modal);
        this.modals = newModals;
        modal.hideModal(true);
        this.onDismissModal(modal);
        this.updateModality();
        this.didDismissModal(modal);
      }
    }
    willDismissModal(modal) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceWillDismissModal !== void 0) {
          observer.serviceWillDismissModal(modal, this);
        }
      }
    }
    onDismissModal(modal) {}
    didDismissModal(modal) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceDidDismissModal !== void 0) {
          observer.serviceDidDismissModal(modal, this);
        }
      }
    }
    dismissModals() {
      const modals = this.modals;
      for (let i = 0, n = modals.length; i < n; i += 1) {
        this.dismissModal(this.modals[i]);
      }
    }
    toggleModal(modal, options) {
      const modalState = modal.modalState;
      if (modalState === "hidden" || modalState === "hiding") {
        this.presentModal(modal, options);
      } else if (modalState === "shown" || modalState === "showing") {
        this.dismissModal(modal);
      }
    }
    updateModality() {
      const oldModality = this.modality;
      let newModality = 0;
      const modals = this.modals;
      for (let i = 0, n = modals.length; i < n; i += 1) {
        const modal = modals[i];
        const modality = +modal.modality;
        newModality = Math.min(Math.max(newModality, modality), 1);
      }
      if (oldModality !== newModality) {
        this.willUpdateModality(newModality, oldModality);
        this.modality = newModality;
        this.onUpdateModality(newModality, oldModality);
        this.didUpdateModality(newModality, oldModality);
      }
    }
    willUpdateModality(newModality, oldModality) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceWillUpdateModality !== void 0) {
          observer.serviceWillUpdateModality(newModality, oldModality, this);
        }
      }
    }
    onUpdateModality(newModality, oldModality) {}
    didUpdateModality(newModality, oldModality) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceDidUpdateModality !== void 0) {
          observer.serviceDidUpdateModality(newModality, oldModality, this);
        }
      }
    }
    displaceModals(event) {
      const handled = this.willDisplaceModals(event);
      if (!handled) {
        this.onDisplaceModals(event);
        this.didDisplaceModals(event);
      }
    }
    willDisplaceModals(event) {
      let handled;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceWillDisplaceModals !== void 0) {
          handled = observer.serviceWillDisplaceModals(event, this);
        }
      }
      return handled !== void 0 ? handled : false;
    }
    onDisplaceModals(event) {
      const modals = this.modals;
      let i = 0;
      while (i < modals.length) {
        const modal = modals[i];
        if (modal.modalState === "shown") {
          this.dismissModal(modal);
        } else {
          i += 1;
        }
      }
    }
    didDisplaceModals(event) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceDidDisplaceModals !== void 0) {
          observer.serviceDidDisplaceModals(event, this);
        }
      }
    }
    onAttachRoot(root) {
      super.onAttachRoot(root);
      this.attachEvents(root);
    }
    onDetachRoot(root) {
      super.onDetachRoot(root);
      this.detachEvents(root);
    }
    attachEvents(view) {
      view.on("click", this.onClick);
    }
    detachEvents(view) {
      view.off("click", this.onClick);
    }
    onClick(event) {
      this.displaceModals(event);
    }
    static insertModalView(modalView) {
      throw new TypeError("" + modalView);
    }
    static global() {
      return new ModalService;
    }
  }
  __decorate([ util.Lazy ], ModalService, "global", null);
  const ModalProvider = function(_super) {
    const ModalProvider = _super.extend("ModalProvider");
    ModalProvider.prototype.presentModal = function(modal, options) {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = ModalService.global();
      }
      service.presentModal(modal, options);
    };
    ModalProvider.prototype.dismissModal = function(modal) {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = ModalService.global();
      }
      service.dismissModal(modal);
    };
    ModalProvider.prototype.dismissModals = function() {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = ModalService.global();
      }
      service.dismissModals();
    };
    ModalProvider.prototype.toggleModal = function(modal, options) {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = ModalService.global();
      }
      service.toggleModal(modal, options);
    };
    ModalProvider.prototype.updateModality = function() {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = ModalService.global();
      }
      service.updateModality();
    };
    ModalProvider.prototype.displaceModals = function(event) {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = ModalService.global();
      }
      service.displaceModals(event);
    };
    ModalProvider.prototype.createService = function() {
      return ModalService.global();
    };
    return ModalProvider;
  }(component.Provider);
  class GestureInput {
    constructor(inputId, inputType, isPrimary, x, y, t) {
      this.inputId = inputId;
      this.inputType = inputType;
      this.isPrimary = isPrimary;
      this.target = null;
      this.button = 0;
      this.buttons = 0;
      this.altKey = false;
      this.ctrlKey = false;
      this.metaKey = false;
      this.shiftKey = false;
      this.width = 0;
      this.height = 0;
      this.tiltX = 0;
      this.tiltY = 0;
      this.twist = 0;
      this.pressure = 0;
      this.tangentialPressure = 0;
      this.x0 = x;
      this.y0 = y;
      this.t0 = t;
      this.dx = 0;
      this.dy = 0;
      this.dt = 0;
      this.x = x;
      this.y = y;
      this.t = t;
      this.detail = void 0;
      this.defaultPrevented = false;
    }
    preventDefault() {
      this.defaultPrevented = true;
    }
    static pointerInputType(inputType) {
      if (inputType === "mouse" || inputType === "touch" || inputType === "pen") {
        return inputType;
      } else {
        return "unknown";
      }
    }
  }
  const Gesture = function(_super) {
    const Gesture = _super.extend("Gesture");
    Object.defineProperty(Gesture.prototype, "fastenerType", {
      get: function() {
        return Gesture;
      },
      configurable: true
    });
    Gesture.prototype.getView = function() {
      const view = this.view;
      if (view === null) {
        throw new TypeError("null " + this.name + " view");
      }
      return view;
    };
    Gesture.prototype.setView = function(newView, target) {
      const oldView = this.view;
      if (oldView !== newView) {
        if (oldView !== null) {
          this.willDetachView(oldView);
          this.view = null;
          this.onDetachView(oldView);
          this.didDetachView(oldView);
        }
        if (newView !== null) {
          if (target === void 0) {
            target = null;
          }
          this.willAttachView(newView, target);
          this.view = newView;
          this.onAttachView(newView, target);
          this.didAttachView(newView, target);
        }
      }
      return oldView;
    };
    Gesture.prototype.willAttachView = function(view, target) {};
    Gesture.prototype.onAttachView = function(view, target) {
      this.attachEvents(view);
      if (this.observes === true) {
        view.observe(this);
      }
    };
    Gesture.prototype.didAttachView = function(view, target) {};
    Gesture.prototype.willDetachView = function(view) {};
    Gesture.prototype.onDetachView = function(view) {
      this.clearInputs();
      if (this.observes === true) {
        view.unobserve(this);
      }
      this.detachEvents(view);
    };
    Gesture.prototype.didDetachView = function(view) {};
    Gesture.prototype.attachEvents = function(view) {};
    Gesture.prototype.detachEvents = function(view) {};
    Gesture.prototype.getInput = function(inputId) {
      if (typeof inputId === "number") {
        inputId = "" + inputId;
      }
      const input = this.inputs[inputId];
      return input !== void 0 ? input : null;
    };
    Gesture.prototype.createInput = function(inputId, inputType, isPrimary, x, y, t) {
      return new GestureInput(inputId, inputType, isPrimary, x, y, t);
    };
    Gesture.prototype.getOrCreateInput = function(inputId, inputType, isPrimary, x, y, t) {
      if (typeof inputId === "number") {
        inputId = "" + inputId;
      }
      const inputs = this.inputs;
      let input = inputs[inputId];
      if (input === void 0) {
        input = this.createInput(inputId, inputType, isPrimary, x, y, t);
        inputs[inputId] = input;
        this.inputCount += 1;
      }
      return input;
    };
    Gesture.prototype.clearInput = function(input) {
      const inputs = this.inputs;
      delete inputs[input.inputId];
      this.inputCount -= 1;
    };
    Gesture.prototype.clearInputs = function() {
      this.inputs = {};
      this.inputCount = 0;
    };
    Gesture.prototype.bindView = function(view, target) {
      if (this.binds && this.view === null) {
        const newView = this.detectView(view);
        if (newView !== null) {
          this.setView(newView, target);
        }
      }
    };
    Gesture.prototype.unbindView = function(view) {
      if (this.binds && this.view === view) {
        this.setView(null);
      }
    };
    Gesture.prototype.detectView = function(view) {
      if (this.key !== void 0 && this.key === view.key) {
        return view;
      }
      return null;
    };
    Gesture.prototype.viewWillUnmount = function(view) {
      this.clearInputs();
    };
    Gesture.prototype.onMount = function() {
      _super.prototype.onMount.call(this);
      if (this.self === true && this.owner instanceof View) {
        this.setView(this.owner);
      }
    };
    Object.defineProperty(Gesture.prototype, "lazy", {
      get: function() {
        return false;
      },
      configurable: true
    });
    Object.defineProperty(Gesture.prototype, "static", {
      get: function() {
        return true;
      },
      configurable: true
    });
    Gesture.construct = function(gestureClass, gesture, owner) {
      if (gesture === null) {
        gesture = function(view, targetView) {
          if (view === void 0) {
            return gesture.view;
          } else {
            gesture.setView(view, targetView);
            return gesture.owner;
          }
        };
        delete gesture.name;
        Object.setPrototypeOf(gesture, gestureClass.prototype);
      }
      gesture = _super.construct(gestureClass, gesture, owner);
      gesture.view = null;
      gesture.inputs = {};
      gesture.inputCount = 0;
      return gesture;
    };
    Gesture.specialize = function(method) {
      return null;
    };
    Gesture.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      let method = descriptor.method;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.method;
      if (descriptor.key === true) {
        Object.defineProperty(descriptor, "key", {
          value: className,
          configurable: true
        });
      } else if (descriptor.key === false) {
        Object.defineProperty(descriptor, "key", {
          value: void 0,
          configurable: true
        });
      }
      if (method === void 0) {
        method = "auto";
      }
      if (superClass === void 0 || superClass === null) {
        superClass = Gesture.specialize(method);
      }
      if (superClass === null) {
        superClass = this;
      }
      const gestureClass = superClass.extend(className, descriptor);
      gestureClass.construct = function(gestureClass, gesture, owner) {
        gesture = superClass.construct(gestureClass, gesture, owner);
        if (affinity !== void 0) {
          gesture.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          gesture.initInherits(inherits);
        }
        return gesture;
      };
      return gestureClass;
    };
    return Gesture;
  }(component.Fastener);
  class PositionGestureInput extends GestureInput {
    constructor(inputId, inputType, isPrimary, x, y, t) {
      super(inputId, inputType, isPrimary, x, y, t);
      this.hovering = false;
      this.pressing = false;
      this.holdTimer = 0;
      this.holdDelay = 400;
    }
    isRunaway() {
      const dx = this.x - this.x0;
      const dy = this.y - this.y0;
      const dt = this.t - this.t0;
      return this.inputType !== "mouse" && dt < 100 && dx * dx + dy * dy > 10 * 10;
    }
    setHoldTimer(f) {
      if (this.holdDelay !== 0) {
        this.clearHoldTimer();
        this.holdTimer = setTimeout(f, this.holdDelay);
      }
    }
    clearHoldTimer() {
      if (this.holdTimer !== 0) {
        clearTimeout(this.holdTimer);
        this.holdTimer = 0;
      }
    }
  }
  const PositionGesture = function(_super) {
    const PositionGesture = _super.extend("PositionGesture");
    PositionGesture.prototype.attachEvents = function(view) {
      Gesture.prototype.attachEvents.call(this, view);
      this.attachHoverEvents(view);
    };
    PositionGesture.prototype.detachEvents = function(view) {
      this.detachPressEvents(view);
      this.detachHoverEvents(view);
      Gesture.prototype.detachEvents.call(this, view);
    };
    PositionGesture.prototype.attachHoverEvents = function(view) {};
    PositionGesture.prototype.detachHoverEvents = function(view) {};
    PositionGesture.prototype.attachPressEvents = function(view) {};
    PositionGesture.prototype.detachPressEvents = function(view) {};
    PositionGesture.prototype.createInput = function(inputId, inputType, isPrimary, x, y, t) {
      return new PositionGestureInput(inputId, inputType, isPrimary, x, y, t);
    };
    PositionGesture.prototype.clearInput = function(input) {
      if (!input.hovering && !input.pressing) {
        Gesture.prototype.clearInput.call(this, input);
      }
    };
    PositionGesture.prototype.clearInputs = function() {
      Gesture.prototype.clearInputs.call(this);
      this.hoverCount = 0;
      this.pressCount = 0;
    };
    Object.defineProperty(PositionGesture.prototype, "hovering", {
      get() {
        return this.hoverCount !== 0;
      },
      configurable: true
    });
    PositionGesture.prototype.startHovering = function() {
      this.willStartHovering();
      this.onStartHovering();
      this.didStartHovering();
    };
    PositionGesture.prototype.willStartHovering = function() {};
    PositionGesture.prototype.onStartHovering = function() {};
    PositionGesture.prototype.didStartHovering = function() {};
    PositionGesture.prototype.stopHovering = function() {
      this.willStopHovering();
      this.onStopHovering();
      this.didStopHovering();
    };
    PositionGesture.prototype.willStopHovering = function() {};
    PositionGesture.prototype.onStopHovering = function() {};
    PositionGesture.prototype.didStopHovering = function() {};
    PositionGesture.prototype.beginHover = function(input, event) {
      if (!input.hovering) {
        this.willBeginHover(input, event);
        input.hovering = true;
        this.hoverCount += 1;
        this.onBeginHover(input, event);
        this.didBeginHover(input, event);
        if (this.hoverCount === 1) {
          this.startHovering();
        }
      }
    };
    PositionGesture.prototype.willBeginHover = function(input, event) {};
    PositionGesture.prototype.onBeginHover = function(input, event) {};
    PositionGesture.prototype.didBeginHover = function(input, event) {};
    PositionGesture.prototype.endHover = function(input, event) {
      if (input.hovering) {
        this.willEndHover(input, event);
        input.hovering = false;
        this.hoverCount -= 1;
        this.onEndHover(input, event);
        this.didEndHover(input, event);
        if (this.hoverCount === 0) {
          this.stopHovering();
        }
        this.clearInput(input);
      }
    };
    PositionGesture.prototype.willEndHover = function(input, event) {};
    PositionGesture.prototype.onEndHover = function(input, event) {};
    PositionGesture.prototype.didEndHover = function(input, event) {};
    Object.defineProperty(PositionGesture.prototype, "pressing", {
      get() {
        return this.pressCount !== 0;
      },
      configurable: true
    });
    PositionGesture.prototype.startPressing = function() {
      this.willStartPressing();
      this.onStartPressing();
      this.didStartPressing();
    };
    PositionGesture.prototype.willStartPressing = function() {};
    PositionGesture.prototype.onStartPressing = function() {
      this.attachPressEvents(this.view);
    };
    PositionGesture.prototype.didStartPressing = function() {};
    PositionGesture.prototype.stopPressing = function() {
      this.willStopPressing();
      this.onStopPressing();
      this.didStopPressing();
    };
    PositionGesture.prototype.willStopPressing = function() {};
    PositionGesture.prototype.onStopPressing = function() {
      this.detachPressEvents(this.view);
    };
    PositionGesture.prototype.didStopPressing = function() {};
    PositionGesture.prototype.beginPress = function(input, event) {
      if (!input.pressing) {
        let allowPress = this.willBeginPress(input, event);
        if (allowPress === void 0) {
          allowPress = true;
        }
        if (allowPress) {
          input.pressing = true;
          input.defaultPrevented = false;
          this.pressCount += 1;
          this.onBeginPress(input, event);
          input.setHoldTimer(this.longPress.bind(this, input));
          this.didBeginPress(input, event);
          if (this.pressCount === 1) {
            this.startPressing();
          }
        }
      }
    };
    PositionGesture.prototype.willBeginPress = function(input, event) {};
    PositionGesture.prototype.onBeginPress = function(input, event) {
      input.x0 = input.x;
      input.y0 = input.y;
      input.t0 = input.t;
      input.dx = 0;
      input.dy = 0;
      input.dt = 0;
    };
    PositionGesture.prototype.didBeginPress = function(input, event) {};
    PositionGesture.prototype.movePress = function(input, event) {
      if (input.pressing) {
        this.willMovePress(input, event);
        this.onMovePress(input, event);
        this.didMovePress(input, event);
      }
    };
    PositionGesture.prototype.willMovePress = function(input, event) {};
    PositionGesture.prototype.onMovePress = function(input, event) {};
    PositionGesture.prototype.didMovePress = function(input, event) {};
    PositionGesture.prototype.endPress = function(input, event) {
      input.clearHoldTimer();
      if (input.pressing) {
        this.willEndPress(input, event);
        input.pressing = false;
        this.pressCount -= 1;
        this.onEndPress(input, event);
        this.didEndPress(input, event);
        if (this.pressCount === 0) {
          this.stopPressing();
        }
        this.clearInput(input);
      }
    };
    PositionGesture.prototype.willEndPress = function(input, event) {};
    PositionGesture.prototype.onEndPress = function(input, event) {};
    PositionGesture.prototype.didEndPress = function(input, event) {};
    PositionGesture.prototype.cancelPress = function(input, event) {
      input.clearHoldTimer();
      if (input.pressing) {
        this.willCancelPress(input, event);
        input.pressing = false;
        this.pressCount -= 1;
        this.onCancelPress(input, event);
        this.didCancelPress(input, event);
        if (this.pressCount === 0) {
          this.stopPressing();
        }
        this.clearInput(input);
      }
    };
    PositionGesture.prototype.willCancelPress = function(input, event) {};
    PositionGesture.prototype.onCancelPress = function(input, event) {};
    PositionGesture.prototype.didCancelPress = function(input, event) {};
    PositionGesture.prototype.press = function(input, event) {
      this.willPress(input, event);
      this.onPress(input, event);
      this.didPress(input, event);
    };
    PositionGesture.prototype.willPress = function(input, event) {};
    PositionGesture.prototype.onPress = function(input, event) {};
    PositionGesture.prototype.didPress = function(input, event) {};
    PositionGesture.prototype.longPress = function(input) {
      input.clearHoldTimer();
      const dt = performance.now() - input.t0;
      if (dt < 1.5 * input.holdDelay && input.pressing) {
        this.willLongPress(input);
        this.onLongPress(input);
        this.didLongPress(input);
      }
    };
    PositionGesture.prototype.willLongPress = function(input) {};
    PositionGesture.prototype.onLongPress = function(input) {
      const t = performance.now();
      input.dt = t - input.t;
      input.t = t;
    };
    PositionGesture.prototype.didLongPress = function(input) {};
    PositionGesture.construct = function(gestureClass, gesture, owner) {
      gesture = _super.construct(gestureClass, gesture, owner);
      gesture.hoverCount = 0;
      gesture.pressCount = 0;
      return gesture;
    };
    PositionGesture.specialize = function(method) {
      if (method === "pointer") {
        return PointerPositionGesture;
      } else if (method === "touch") {
        return TouchPositionGesture;
      } else if (method === "mouse") {
        return MousePositionGesture;
      } else if (typeof PointerEvent !== "undefined") {
        return PointerPositionGesture;
      } else if (typeof TouchEvent !== "undefined") {
        return TouchPositionGesture;
      } else {
        return MousePositionGesture;
      }
    };
    PositionGesture.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      let method = descriptor.method;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.method;
      if (descriptor.key === true) {
        Object.defineProperty(descriptor, "key", {
          value: className,
          configurable: true
        });
      } else if (descriptor.key === false) {
        Object.defineProperty(descriptor, "key", {
          value: void 0,
          configurable: true
        });
      }
      if (method === void 0) {
        method = "auto";
      }
      if (superClass === void 0 || superClass === null) {
        superClass = PositionGesture.specialize(method);
      }
      if (superClass === null) {
        superClass = this;
      }
      const gestureClass = superClass.extend(className, descriptor);
      gestureClass.construct = function(gestureClass, gesture, owner) {
        gesture = superClass.construct(gestureClass, gesture, owner);
        if (affinity !== void 0) {
          gesture.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          gesture.initInherits(inherits);
        }
        return gesture;
      };
      return gestureClass;
    };
    return PositionGesture;
  }(Gesture);
  const PointerPositionGesture = function(_super) {
    const PointerPositionGesture = _super.extend("PointerPositionGesture");
    PointerPositionGesture.prototype.attachHoverEvents = function(view) {
      view.on("pointerenter", this.onPointerEnter);
      view.on("pointerleave", this.onPointerLeave);
      view.on("pointerdown", this.onPointerDown);
    };
    PointerPositionGesture.prototype.detachHoverEvents = function(view) {
      view.off("pointerenter", this.onPointerEnter);
      view.off("pointerleave", this.onPointerLeave);
      view.off("pointerdown", this.onPointerDown);
    };
    PointerPositionGesture.prototype.attachPressEvents = function(view) {
      document.body.addEventListener("pointermove", this.onPointerMove);
      document.body.addEventListener("pointerup", this.onPointerUp);
      document.body.addEventListener("pointercancel", this.onPointerCancel);
      document.body.addEventListener("pointerleave", this.onPointerLeaveDocument);
    };
    PointerPositionGesture.prototype.detachPressEvents = function(view) {
      document.body.removeEventListener("pointermove", this.onPointerMove);
      document.body.removeEventListener("pointerup", this.onPointerUp);
      document.body.removeEventListener("pointercancel", this.onPointerCancel);
      document.body.removeEventListener("pointerleave", this.onPointerLeaveDocument);
    };
    PointerPositionGesture.prototype.updateInput = function(input, event) {
      input.target = event.target;
      input.button = event.button;
      input.buttons = event.buttons;
      input.altKey = event.altKey;
      input.ctrlKey = event.ctrlKey;
      input.metaKey = event.metaKey;
      input.shiftKey = event.shiftKey;
      input.dx = event.clientX - input.x;
      input.dy = event.clientY - input.y;
      input.dt = event.timeStamp - input.t;
      input.x = event.clientX;
      input.y = event.clientY;
      input.t = event.timeStamp;
      input.width = event.width;
      input.height = event.height;
      input.tiltX = event.tiltX;
      input.tiltY = event.tiltY;
      input.twist = event.twist;
      input.pressure = event.pressure;
      input.tangentialPressure = event.tangentialPressure;
    };
    PointerPositionGesture.prototype.onPointerEnter = function(event) {
      if (event.pointerType === "mouse" && event.buttons === 0) {
        const input = this.getOrCreateInput(event.pointerId, GestureInput.pointerInputType(event.pointerType), event.isPrimary, event.clientX, event.clientY, event.timeStamp);
        this.updateInput(input, event);
        if (!input.hovering) {
          this.beginHover(input, event);
        }
      }
    };
    PointerPositionGesture.prototype.onPointerLeave = function(event) {
      if (event.pointerType === "mouse") {
        const input = this.getInput(event.pointerId);
        if (input !== null) {
          this.updateInput(input, event);
          this.endHover(input, event);
        }
      }
    };
    PointerPositionGesture.prototype.onPointerDown = function(event) {
      const input = this.getOrCreateInput(event.pointerId, GestureInput.pointerInputType(event.pointerType), event.isPrimary, event.clientX, event.clientY, event.timeStamp);
      this.updateInput(input, event);
      if (!input.pressing) {
        this.beginPress(input, event);
      }
      if (event.pointerType === "mouse" && event.button !== 0) {
        this.cancelPress(input, event);
      }
    };
    PointerPositionGesture.prototype.onPointerMove = function(event) {
      const input = this.getInput(event.pointerId);
      if (input !== null) {
        this.updateInput(input, event);
        this.movePress(input, event);
      }
    };
    PointerPositionGesture.prototype.onPointerUp = function(event) {
      const input = this.getInput(event.pointerId);
      if (input !== null) {
        this.updateInput(input, event);
        this.endPress(input, event);
        if (!input.defaultPrevented && event.button === 0) {
          this.press(input, event);
        }
      }
    };
    PointerPositionGesture.prototype.onPointerCancel = function(event) {
      const input = this.getInput(event.pointerId);
      if (input !== null) {
        this.updateInput(input, event);
        this.cancelPress(input, event);
      }
    };
    PointerPositionGesture.prototype.onPointerLeaveDocument = function(event) {
      const input = this.getInput(event.pointerId);
      if (input !== null) {
        this.updateInput(input, event);
        this.cancelPress(input, event);
        this.endHover(input, event);
      }
    };
    PointerPositionGesture.construct = function(gestureClass, gesture, owner) {
      gesture = _super.construct(gestureClass, gesture, owner);
      gesture.onPointerEnter = gesture.onPointerEnter.bind(gesture);
      gesture.onPointerLeave = gesture.onPointerLeave.bind(gesture);
      gesture.onPointerDown = gesture.onPointerDown.bind(gesture);
      gesture.onPointerMove = gesture.onPointerMove.bind(gesture);
      gesture.onPointerUp = gesture.onPointerUp.bind(gesture);
      gesture.onPointerCancel = gesture.onPointerCancel.bind(gesture);
      gesture.onPointerLeaveDocument = gesture.onPointerLeaveDocument.bind(gesture);
      return gesture;
    };
    return PointerPositionGesture;
  }(PositionGesture);
  const TouchPositionGesture = function(_super) {
    const TouchPositionGesture = _super.extend("TouchPositionGesture");
    TouchPositionGesture.prototype.attachHoverEvents = function(view) {
      view.on("touchstart", this.onTouchStart);
    };
    TouchPositionGesture.prototype.detachHoverEvents = function(view) {
      view.off("touchstart", this.onTouchStart);
    };
    TouchPositionGesture.prototype.attachPressEvents = function(view) {
      view.on("touchmove", this.onTouchMove);
      view.on("touchend", this.onTouchEnd);
      view.on("touchcancel", this.onTouchCancel);
    };
    TouchPositionGesture.prototype.detachPressEvents = function(view) {
      view.off("touchmove", this.onTouchMove);
      view.off("touchend", this.onTouchEnd);
      view.off("touchcancel", this.onTouchCancel);
    };
    TouchPositionGesture.prototype.updateInput = function(input, event, touch) {
      input.target = touch.target;
      input.altKey = event.altKey;
      input.ctrlKey = event.ctrlKey;
      input.metaKey = event.metaKey;
      input.shiftKey = event.shiftKey;
      input.dx = touch.clientX - input.x;
      input.dy = touch.clientY - input.y;
      input.dt = event.timeStamp - input.t;
      input.x = touch.clientX;
      input.y = touch.clientY;
      input.t = event.timeStamp;
    };
    TouchPositionGesture.prototype.onTouchStart = function(event) {
      const touches = event.targetTouches;
      for (let i = 0; i < touches.length; i += 1) {
        const touch = touches[i];
        const input = this.getOrCreateInput(touch.identifier, "touch", false, touch.clientX, touch.clientY, event.timeStamp);
        this.updateInput(input, event, touch);
        if (!input.pressing) {
          this.beginPress(input, event);
        }
      }
    };
    TouchPositionGesture.prototype.onTouchMove = function(event) {
      const touches = event.changedTouches;
      for (let i = 0; i < touches.length; i += 1) {
        const touch = touches[i];
        const input = this.getInput(touch.identifier);
        if (input !== null) {
          this.updateInput(input, event, touch);
          this.movePress(input, event);
        }
      }
    };
    TouchPositionGesture.prototype.onTouchEnd = function(event) {
      const touches = event.changedTouches;
      for (let i = 0; i < touches.length; i += 1) {
        const touch = touches[i];
        const input = this.getInput(touch.identifier);
        if (input !== null) {
          this.updateInput(input, event, touch);
          this.endPress(input, event);
          if (!input.defaultPrevented) {
            this.press(input, event);
          }
          this.endHover(input, event);
        }
      }
    };
    TouchPositionGesture.prototype.onTouchCancel = function(event) {
      const touches = event.changedTouches;
      for (let i = 0; i < touches.length; i += 1) {
        const touch = touches[i];
        const input = this.getInput(touch.identifier);
        if (input !== null) {
          this.updateInput(input, event, touch);
          this.cancelPress(input, event);
          this.endHover(input, event);
        }
      }
    };
    TouchPositionGesture.construct = function(gestureClass, gesture, owner) {
      gesture = _super.construct(gestureClass, gesture, owner);
      gesture.onTouchStart = gesture.onTouchStart.bind(gesture);
      gesture.onTouchMove = gesture.onTouchMove.bind(gesture);
      gesture.onTouchEnd = gesture.onTouchEnd.bind(gesture);
      gesture.onTouchCancel = gesture.onTouchCancel.bind(gesture);
      return gesture;
    };
    return TouchPositionGesture;
  }(PositionGesture);
  const MousePositionGesture = function(_super) {
    const MousePositionGesture = _super.extend("MousePositionGesture");
    MousePositionGesture.prototype.attachHoverEvents = function(view) {
      view.on("mouseenter", this.onMouseEnter);
      view.on("mouseleave", this.onMouseLeave);
      view.on("mousedown", this.onMouseDown);
    };
    MousePositionGesture.prototype.detachHoverEvents = function(view) {
      view.off("mouseenter", this.onMouseEnter);
      view.off("mouseleave", this.onMouseLeave);
      view.off("mousedown", this.onMouseDown);
    };
    MousePositionGesture.prototype.attachPressEvents = function(view) {
      document.body.addEventListener("mousemove", this.onMouseMove);
      document.body.addEventListener("mouseup", this.onMouseUp);
      document.body.addEventListener("mouseleave", this.onMouseLeaveDocument);
    };
    MousePositionGesture.prototype.detachPressEvents = function(view) {
      document.body.removeEventListener("mousemove", this.onMouseMove);
      document.body.removeEventListener("mouseup", this.onMouseUp);
      document.body.removeEventListener("mouseleave", this.onMouseLeaveDocument);
    };
    MousePositionGesture.prototype.updateInput = function(input, event) {
      input.target = event.target;
      input.button = event.button;
      input.buttons = event.buttons;
      input.altKey = event.altKey;
      input.ctrlKey = event.ctrlKey;
      input.metaKey = event.metaKey;
      input.shiftKey = event.shiftKey;
      input.dx = event.clientX - input.x;
      input.dy = event.clientY - input.y;
      input.dt = event.timeStamp - input.y;
      input.x = event.clientX;
      input.y = event.clientY;
      input.t = event.timeStamp;
    };
    MousePositionGesture.prototype.onMouseEnter = function(event) {
      if (event.buttons === 0) {
        const input = this.getOrCreateInput("mouse", "mouse", true, event.clientX, event.clientY, event.timeStamp);
        this.updateInput(input, event);
        if (!input.hovering) {
          this.beginHover(input, event);
        }
      }
    };
    MousePositionGesture.prototype.onMouseLeave = function(event) {
      const input = this.getInput("mouse");
      if (input !== null) {
        this.updateInput(input, event);
        this.endHover(input, event);
      }
    };
    MousePositionGesture.prototype.onMouseDown = function(event) {
      const input = this.getOrCreateInput("mouse", "mouse", true, event.clientX, event.clientY, event.timeStamp);
      this.updateInput(input, event);
      if (!input.pressing) {
        this.beginPress(input, event);
      }
      if (event.button !== 0) {
        this.cancelPress(input, event);
      }
    };
    MousePositionGesture.prototype.onMouseMove = function(event) {
      const input = this.getInput("mouse");
      if (input !== null) {
        this.updateInput(input, event);
        this.movePress(input, event);
      }
    };
    MousePositionGesture.prototype.onMouseUp = function(event) {
      const input = this.getInput("mouse");
      if (input !== null) {
        this.updateInput(input, event);
        this.endPress(input, event);
        if (!input.defaultPrevented && event.button === 0) {
          this.press(input, event);
        }
      }
    };
    MousePositionGesture.prototype.onMouseLeaveDocument = function(event) {
      const input = this.getInput("mouse");
      if (input !== null) {
        this.updateInput(input, event);
        this.cancelPress(input, event);
        this.endHover(input, event);
      }
    };
    MousePositionGesture.construct = function(gestureClass, gesture, owner) {
      gesture = _super.construct(gestureClass, gesture, owner);
      gesture.onMouseEnter = gesture.onMouseEnter.bind(gesture);
      gesture.onMouseLeave = gesture.onMouseLeave.bind(gesture);
      gesture.onMouseDown = gesture.onMouseDown.bind(gesture);
      gesture.onMouseMove = gesture.onMouseMove.bind(gesture);
      gesture.onMouseUp = gesture.onMouseUp.bind(gesture);
      gesture.onMouseLeaveDocument = gesture.onMouseLeaveDocument.bind(gesture);
      return gesture;
    };
    return MousePositionGesture;
  }(PositionGesture);
  class MomentumGestureInput extends PositionGestureInput {
    constructor(inputId, inputType, isPrimary, x, y, t) {
      super(inputId, inputType, isPrimary, x, y, t);
      this.vx = 0;
      this.vy = 0;
      this.ax = 0;
      this.ay = 0;
      this.path = [];
      this.coasting = false;
    }
    updatePosition(hysteresis) {
      const path = this.path;
      const x = this.x;
      const y = this.y;
      const t = this.t;
      path.push({
        x: x,
        y: y,
        t: t
      });
      while (path.length > 1 && t - path[0].t > hysteresis) {
        path.shift();
      }
    }
    deriveVelocity(vMax) {
      const p0 = this.path[0];
      const p1 = this.path[this.path.length - 1];
      if (p1 !== void 0 && p1 !== p0) {
        const dt = p1.t - p0.t;
        let vx;
        let vy;
        if (dt !== 0) {
          vx = (p1.x - p0.x) / dt;
          vy = (p1.y - p0.y) / dt;
          const v2 = vx * vx + vy * vy;
          const vMax2 = vMax * vMax;
          if (vMax2 < v2) {
            const v = Math.sqrt(v2);
            vx = vx * vMax / v;
            vy = vy * vMax / v;
          }
        } else {
          vx = 0;
          vy = 0;
        }
        this.vx = vx;
        this.vy = vy;
      } else if (p0 !== void 0) {
        this.vx = 0;
        this.vy = 0;
      }
    }
    integrateVelocity(t) {
      const dt = t - this.t;
      if (dt !== 0) {
        let vx = this.vx + this.ax * dt;
        let x;
        if (vx < 0 === this.vx < 0) {
          x = this.x + this.vx * dt + .5 * (this.ax * dt * dt);
        } else {
          x = this.x - this.vx * this.vx / (2 * this.ax);
          vx = 0;
          this.ax = 0;
        }
        let vy = this.vy + this.ay * dt;
        let y;
        if (vy < 0 === this.vy < 0) {
          y = this.y + this.vy * dt + .5 * (this.ay * dt * dt);
        } else {
          y = this.y - this.vy * this.vy / (2 * this.ay);
          vy = 0;
          this.ay = 0;
        }
        this.dx = x - this.x;
        this.dy = y - this.y;
        this.dt = dt;
        this.x = x;
        this.y = y;
        this.t = t;
        this.vx = vx;
        this.vy = vy;
      }
    }
  }
  const MomentumGesture = function(_super) {
    const MomentumGesture = _super.extend("MomentumGesture");
    Object.defineProperty(MomentumGesture.prototype, "observes", {
      value: true,
      enumerable: true,
      configurable: true
    });
    MomentumGesture.prototype.createInput = function(inputId, inputType, isPrimary, x, y, t) {
      return new MomentumGestureInput(inputId, inputType, isPrimary, x, y, t);
    };
    MomentumGesture.prototype.clearInput = function(input) {
      if (!input.coasting) {
        PositionGesture.prototype.clearInput.call(this, input);
      }
    };
    MomentumGesture.prototype.clearInputs = function() {
      PositionGesture.prototype.clearInputs.call(this);
      this.coastCount = 0;
    };
    MomentumGesture.prototype.viewWillAnimate = function(viewContext) {
      this.doCoast(viewContext.updateTime);
    };
    MomentumGesture.prototype.interrupt = function(event) {
      const inputs = this.inputs;
      for (const inputId in inputs) {
        const input = inputs[inputId];
        this.endCoast(input, event);
      }
    };
    MomentumGesture.prototype.cancel = function(event) {
      const inputs = this.inputs;
      for (const inputId in inputs) {
        const input = inputs[inputId];
        this.endPress(input, event);
        this.endCoast(input, event);
      }
    };
    MomentumGesture.prototype.startInteracting = function() {
      this.willStartInteracting();
      this.onStartInteracting();
      this.didStartInteracting();
    };
    MomentumGesture.prototype.willStartInteracting = function() {};
    MomentumGesture.prototype.onStartInteracting = function() {};
    MomentumGesture.prototype.didStartInteracting = function() {};
    MomentumGesture.prototype.stopInteracting = function() {
      this.willStopInteracting();
      this.onStopInteracting();
      this.didStopInteracting();
    };
    MomentumGesture.prototype.willStopInteracting = function() {};
    MomentumGesture.prototype.onStopInteracting = function() {};
    MomentumGesture.prototype.didStopInteracting = function() {};
    MomentumGesture.prototype.onStartPressing = function() {
      PositionGesture.prototype.onStartPressing.call(this);
      if (this.coastCount === 0) {
        this.startInteracting();
      }
    };
    MomentumGesture.prototype.onStopPressing = function() {
      PositionGesture.prototype.onStopPressing.call(this);
      if (this.coastCount === 0) {
        this.stopInteracting();
      }
    };
    MomentumGesture.prototype.beginPress = function(input, event) {
      PositionGesture.prototype.beginPress.call(this, input, event);
      this.interrupt(event);
    };
    MomentumGesture.prototype.onBeginPress = function(input, event) {
      PositionGesture.prototype.onBeginPress.call(this, input, event);
      input.updatePosition(this.hysteresis);
      input.deriveVelocity(this.velocityMax);
    };
    MomentumGesture.prototype.onMovePress = function(input, event) {
      PositionGesture.prototype.onMovePress.call(this, input, event);
      input.updatePosition(this.hysteresis);
      input.deriveVelocity(this.velocityMax);
    };
    MomentumGesture.prototype.willEndPress = function(input, event) {
      PositionGesture.prototype.willEndPress.call(this, input, event);
      this.beginCoast(input, event);
    };
    MomentumGesture.prototype.onEndPress = function(input, event) {
      PositionGesture.prototype.onEndPress.call(this, input, event);
      input.updatePosition(this.hysteresis);
      input.deriveVelocity(this.velocityMax);
    };
    MomentumGesture.prototype.onCancelPress = function(input, event) {
      PositionGesture.prototype.onCancelPress.call(this, input, event);
      input.updatePosition(this.hysteresis);
      input.deriveVelocity(this.velocityMax);
    };
    Object.defineProperty(MomentumGesture.prototype, "coasting", {
      get() {
        return this.coastCount !== 0;
      },
      configurable: true
    });
    MomentumGesture.prototype.startCoasting = function() {
      this.willStartCoasting();
      this.onStartCoasting();
      this.didStartCoasting();
    };
    MomentumGesture.prototype.willStartCoasting = function() {};
    MomentumGesture.prototype.onStartCoasting = function() {
      if (this.pressCount === 0) {
        this.startInteracting();
      }
      if (this.view !== null) {
        this.view.requireUpdate(View.NeedsAnimate);
      }
    };
    MomentumGesture.prototype.didStartCoasting = function() {};
    MomentumGesture.prototype.stopCoasting = function() {
      this.willStopCoasting();
      this.onStopCoasting();
      this.didStopCoasting();
    };
    MomentumGesture.prototype.willStopCoasting = function() {};
    MomentumGesture.prototype.onStopCoasting = function() {
      if (this.pressCount === 0) {
        this.stopInteracting();
      }
    };
    MomentumGesture.prototype.didStopCoasting = function() {};
    MomentumGesture.prototype.beginCoast = function(input, event) {
      if (!input.coasting && (input.vx !== 0 || input.vy !== 0)) {
        const angle = Math.atan2(Math.abs(input.vy), Math.abs(input.vx));
        const a = this.acceleration;
        const ax = (input.vx < 0 ? a : input.vx > 0 ? -a : 0) * Math.cos(angle);
        const ay = (input.vy < 0 ? a : input.vy > 0 ? -a : 0) * Math.sin(angle);
        if (ax !== 0 || ay !== 0) {
          input.ax = ax;
          input.ay = ay;
          let allowCoast = this.willBeginCoast(input, event);
          if (allowCoast === void 0) {
            allowCoast = true;
          }
          if (allowCoast) {
            input.coasting = true;
            this.coastCount += 1;
            this.onBeginCoast(input, event);
            this.didBeginCoast(input, event);
            if (this.coastCount === 1) {
              this.startCoasting();
            }
          }
        }
      }
    };
    MomentumGesture.prototype.willBeginCoast = function(input, event) {};
    MomentumGesture.prototype.onBeginCoast = function(input, event) {
      input.x0 = input.x;
      input.y0 = input.y;
      input.t0 = input.t;
      input.dx = 0;
      input.dy = 0;
      input.dt = 0;
    };
    MomentumGesture.prototype.didBeginCoast = function(input, event) {};
    MomentumGesture.prototype.endCoast = function(input, event) {
      if (input.coasting) {
        this.willEndCoast(input, event);
        input.coasting = false;
        this.coastCount -= 1;
        this.onEndCoast(input, event);
        this.didEndCoast(input, event);
        if (this.coastCount === 0) {
          this.stopCoasting();
        }
        this.clearInput(input);
      }
    };
    MomentumGesture.prototype.willEndCoast = function(input, event) {};
    MomentumGesture.prototype.onEndCoast = function(input, event) {};
    MomentumGesture.prototype.didEndCoast = function(input, event) {};
    MomentumGesture.prototype.doCoast = function(t) {
      if (this.coastCount !== 0) {
        this.willCoast();
        this.integrate(t);
        this.onCoast();
        const inputs = this.inputs;
        for (const inputId in inputs) {
          const input = inputs[inputId];
          if (input.coasting && input.ax === 0 && input.ay === 0) {
            this.endCoast(input, null);
          }
        }
        this.didCoast();
        if (this.coastCount !== 0 && this.view !== null) {
          this.view.requireUpdate(View.NeedsAnimate);
        }
      }
    };
    MomentumGesture.prototype.willCoast = function() {};
    MomentumGesture.prototype.onCoast = function() {};
    MomentumGesture.prototype.didCoast = function() {};
    MomentumGesture.prototype.integrate = function(t) {
      const inputs = this.inputs;
      for (const inputId in inputs) {
        const input = inputs[inputId];
        if (input.coasting) {
          input.integrateVelocity(t);
        }
      }
    };
    MomentumGesture.construct = function(gestureClass, gesture, owner) {
      gesture = _super.construct(gestureClass, gesture, owner);
      gesture.coastCount = 0;
      gesture.hysteresis = MomentumGesture.Hysteresis;
      gesture.acceleration = MomentumGesture.Acceleration;
      gesture.velocityMax = MomentumGesture.VelocityMax;
      return gesture;
    };
    MomentumGesture.specialize = function(method) {
      if (method === "pointer") {
        return PointerMomentumGesture;
      } else if (method === "touch") {
        return TouchMomentumGesture;
      } else if (method === "mouse") {
        return MouseMomentumGesture;
      } else if (typeof PointerEvent !== "undefined") {
        return PointerMomentumGesture;
      } else if (typeof TouchEvent !== "undefined") {
        return TouchMomentumGesture;
      } else {
        return MouseMomentumGesture;
      }
    };
    MomentumGesture.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      let method = descriptor.method;
      const hysteresis = descriptor.hysteresis;
      const acceleration = descriptor.hysteresis;
      const velocityMax = descriptor.hysteresis;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.method;
      delete descriptor.hysteresis;
      delete descriptor.acceleration;
      delete descriptor.velocityMax;
      if (descriptor.key === true) {
        Object.defineProperty(descriptor, "key", {
          value: className,
          configurable: true
        });
      } else if (descriptor.key === false) {
        Object.defineProperty(descriptor, "key", {
          value: void 0,
          configurable: true
        });
      }
      if (method === void 0) {
        method = "auto";
      }
      if (superClass === void 0 || superClass === null) {
        superClass = MomentumGesture.specialize(method);
      }
      if (superClass === null) {
        superClass = this;
      }
      const gestureClass = superClass.extend(className, descriptor);
      gestureClass.construct = function(gestureClass, gesture, owner) {
        gesture = superClass.construct(gestureClass, gesture, owner);
        if (affinity !== void 0) {
          gesture.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          gesture.initInherits(inherits);
        }
        if (hysteresis !== void 0) {
          gesture.hysteresis = hysteresis;
        }
        if (acceleration !== void 0) {
          gesture.acceleration = acceleration;
        }
        if (velocityMax !== void 0) {
          gesture.velocityMax = velocityMax;
        }
        return gesture;
      };
      return gestureClass;
    };
    MomentumGesture.Hysteresis = 67;
    MomentumGesture.Acceleration = .00175;
    MomentumGesture.VelocityMax = 1.75;
    return MomentumGesture;
  }(PositionGesture);
  const PointerMomentumGesture = function(_super) {
    const PointerMomentumGesture = _super.extend("PointerMomentumGesture");
    PointerMomentumGesture.prototype.attachHoverEvents = function(view) {
      view.on("pointerenter", this.onPointerEnter);
      view.on("pointerleave", this.onPointerLeave);
      view.on("pointerdown", this.onPointerDown);
    };
    PointerMomentumGesture.prototype.detachHoverEvents = function(view) {
      view.off("pointerenter", this.onPointerEnter);
      view.off("pointerleave", this.onPointerLeave);
      view.off("pointerdown", this.onPointerDown);
    };
    PointerMomentumGesture.prototype.attachPressEvents = function(view) {
      document.body.addEventListener("pointermove", this.onPointerMove);
      document.body.addEventListener("pointerup", this.onPointerUp);
      document.body.addEventListener("pointercancel", this.onPointerCancel);
      document.body.addEventListener("pointerleave", this.onPointerLeaveDocument);
    };
    PointerMomentumGesture.prototype.detachPressEvents = function(view) {
      document.body.removeEventListener("pointermove", this.onPointerMove);
      document.body.removeEventListener("pointerup", this.onPointerUp);
      document.body.removeEventListener("pointercancel", this.onPointerCancel);
      document.body.removeEventListener("pointerleave", this.onPointerLeaveDocument);
    };
    PointerMomentumGesture.prototype.updateInput = function(input, event) {
      input.target = event.target;
      input.button = event.button;
      input.buttons = event.buttons;
      input.altKey = event.altKey;
      input.ctrlKey = event.ctrlKey;
      input.metaKey = event.metaKey;
      input.shiftKey = event.shiftKey;
      input.dx = event.clientX - input.x;
      input.dy = event.clientY - input.y;
      input.dt = event.timeStamp - input.t;
      input.x = event.clientX;
      input.y = event.clientY;
      input.t = event.timeStamp;
      input.width = event.width;
      input.height = event.height;
      input.tiltX = event.tiltX;
      input.tiltY = event.tiltY;
      input.twist = event.twist;
      input.pressure = event.pressure;
      input.tangentialPressure = event.tangentialPressure;
    };
    PointerMomentumGesture.prototype.onPointerEnter = function(event) {
      if (event.pointerType === "mouse" && event.buttons === 0) {
        const input = this.getOrCreateInput(event.pointerId, GestureInput.pointerInputType(event.pointerType), event.isPrimary, event.clientX, event.clientY, event.timeStamp);
        this.updateInput(input, event);
        if (!input.hovering) {
          this.beginHover(input, event);
        }
      }
    };
    PointerMomentumGesture.prototype.onPointerLeave = function(event) {
      if (event.pointerType === "mouse") {
        const input = this.getInput(event.pointerId);
        if (input !== null) {
          this.updateInput(input, event);
          this.endHover(input, event);
        }
      }
    };
    PointerMomentumGesture.prototype.onPointerDown = function(event) {
      const input = this.getOrCreateInput(event.pointerId, GestureInput.pointerInputType(event.pointerType), event.isPrimary, event.clientX, event.clientY, event.timeStamp);
      this.updateInput(input, event);
      if (!input.pressing) {
        this.beginPress(input, event);
      }
      if (event.pointerType === "mouse" && event.button !== 0) {
        this.cancelPress(input, event);
      }
    };
    PointerMomentumGesture.prototype.onPointerMove = function(event) {
      const input = this.getInput(event.pointerId);
      if (input !== null) {
        this.updateInput(input, event);
        this.movePress(input, event);
      }
    };
    PointerMomentumGesture.prototype.onPointerUp = function(event) {
      const input = this.getInput(event.pointerId);
      if (input !== null) {
        this.updateInput(input, event);
        this.endPress(input, event);
        if (!input.defaultPrevented && event.button === 0) {
          this.press(input, event);
        }
      }
    };
    PointerMomentumGesture.prototype.onPointerCancel = function(event) {
      const input = this.getInput(event.pointerId);
      if (input !== null) {
        this.updateInput(input, event);
        this.cancelPress(input, event);
      }
    };
    PointerMomentumGesture.prototype.onPointerLeaveDocument = function(event) {
      const input = this.getInput(event.pointerId);
      if (input !== null) {
        this.updateInput(input, event);
        this.cancelPress(input, event);
        this.endHover(input, event);
      }
    };
    PointerMomentumGesture.construct = function(gestureClass, gesture, owner) {
      gesture = _super.construct(gestureClass, gesture, owner);
      gesture.onPointerEnter = gesture.onPointerEnter.bind(gesture);
      gesture.onPointerLeave = gesture.onPointerLeave.bind(gesture);
      gesture.onPointerDown = gesture.onPointerDown.bind(gesture);
      gesture.onPointerMove = gesture.onPointerMove.bind(gesture);
      gesture.onPointerUp = gesture.onPointerUp.bind(gesture);
      gesture.onPointerCancel = gesture.onPointerCancel.bind(gesture);
      gesture.onPointerLeaveDocument = gesture.onPointerLeaveDocument.bind(gesture);
      return gesture;
    };
    return PointerMomentumGesture;
  }(MomentumGesture);
  const TouchMomentumGesture = function(_super) {
    const TouchMomentumGesture = _super.extend("TouchMomentumGesture");
    TouchMomentumGesture.prototype.attachHoverEvents = function(view) {
      view.on("touchstart", this.onTouchStart);
    };
    TouchMomentumGesture.prototype.detachHoverEvents = function(view) {
      view.off("touchstart", this.onTouchStart);
    };
    TouchMomentumGesture.prototype.attachPressEvents = function(view) {
      view.on("touchmove", this.onTouchMove);
      view.on("touchend", this.onTouchEnd);
      view.on("touchcancel", this.onTouchCancel);
    };
    TouchMomentumGesture.prototype.detachPressEvents = function(view) {
      view.off("touchmove", this.onTouchMove);
      view.off("touchend", this.onTouchEnd);
      view.off("touchcancel", this.onTouchCancel);
    };
    TouchMomentumGesture.prototype.updateInput = function(input, event, touch) {
      input.target = touch.target;
      input.altKey = event.altKey;
      input.ctrlKey = event.ctrlKey;
      input.metaKey = event.metaKey;
      input.shiftKey = event.shiftKey;
      input.dx = touch.clientX - input.x;
      input.dy = touch.clientY - input.y;
      input.dt = event.timeStamp - input.t;
      input.x = touch.clientX;
      input.y = touch.clientY;
      input.t = event.timeStamp;
    };
    TouchMomentumGesture.prototype.onTouchStart = function(event) {
      const touches = event.targetTouches;
      for (let i = 0; i < touches.length; i += 1) {
        const touch = touches[i];
        const input = this.getOrCreateInput(touch.identifier, "touch", false, touch.clientX, touch.clientY, event.timeStamp);
        this.updateInput(input, event, touch);
        if (!input.pressing) {
          this.beginPress(input, event);
        }
      }
    };
    TouchMomentumGesture.prototype.onTouchMove = function(event) {
      const touches = event.changedTouches;
      for (let i = 0; i < touches.length; i += 1) {
        const touch = touches[i];
        const input = this.getInput(touch.identifier);
        if (input !== null) {
          this.updateInput(input, event, touch);
          this.movePress(input, event);
        }
      }
    };
    TouchMomentumGesture.prototype.onTouchEnd = function(event) {
      const touches = event.changedTouches;
      for (let i = 0; i < touches.length; i += 1) {
        const touch = touches[i];
        const input = this.getInput(touch.identifier);
        if (input !== null) {
          this.updateInput(input, event, touch);
          this.endPress(input, event);
          if (!input.defaultPrevented) {
            this.press(input, event);
          }
          this.endHover(input, event);
        }
      }
    };
    TouchMomentumGesture.prototype.onTouchCancel = function(event) {
      const touches = event.changedTouches;
      for (let i = 0; i < touches.length; i += 1) {
        const touch = touches[i];
        const input = this.getInput(touch.identifier);
        if (input !== null) {
          this.updateInput(input, event, touch);
          this.cancelPress(input, event);
          this.endHover(input, event);
        }
      }
    };
    TouchMomentumGesture.construct = function(gestureClass, gesture, owner) {
      gesture = _super.construct(gestureClass, gesture, owner);
      gesture.onTouchStart = gesture.onTouchStart.bind(gesture);
      gesture.onTouchMove = gesture.onTouchMove.bind(gesture);
      gesture.onTouchEnd = gesture.onTouchEnd.bind(gesture);
      gesture.onTouchCancel = gesture.onTouchCancel.bind(gesture);
      return gesture;
    };
    return TouchMomentumGesture;
  }(MomentumGesture);
  const MouseMomentumGesture = function(_super) {
    const MouseMomentumGesture = _super.extend("MouseMomentumGesture");
    MouseMomentumGesture.prototype.attachHoverEvents = function(view) {
      view.on("mouseenter", this.onMouseEnter);
      view.on("mouseleave", this.onMouseLeave);
      view.on("mousedown", this.onMouseDown);
    };
    MouseMomentumGesture.prototype.detachHoverEvents = function(view) {
      view.off("mouseenter", this.onMouseEnter);
      view.off("mouseleave", this.onMouseLeave);
      view.off("mousedown", this.onMouseDown);
    };
    MouseMomentumGesture.prototype.attachPressEvents = function(view) {
      document.body.addEventListener("mousemove", this.onMouseMove);
      document.body.addEventListener("mouseup", this.onMouseUp);
      document.body.addEventListener("mouseleave", this.onMouseLeaveDocument);
    };
    MouseMomentumGesture.prototype.detachPressEvents = function(view) {
      document.body.removeEventListener("mousemove", this.onMouseMove);
      document.body.removeEventListener("mouseup", this.onMouseUp);
      document.body.removeEventListener("mouseleave", this.onMouseLeaveDocument);
    };
    MouseMomentumGesture.prototype.updateInput = function(input, event) {
      input.target = event.target;
      input.button = event.button;
      input.buttons = event.buttons;
      input.altKey = event.altKey;
      input.ctrlKey = event.ctrlKey;
      input.metaKey = event.metaKey;
      input.shiftKey = event.shiftKey;
      input.dx = event.clientX - input.x;
      input.dy = event.clientY - input.y;
      input.dt = event.timeStamp - input.t;
      input.x = event.clientX;
      input.y = event.clientY;
      input.t = event.timeStamp;
    };
    MouseMomentumGesture.prototype.onMouseEnter = function(event) {
      if (event.buttons === 0) {
        const input = this.getOrCreateInput("mouse", "mouse", true, event.clientX, event.clientY, event.timeStamp);
        this.updateInput(input, event);
        if (!input.hovering) {
          this.beginHover(input, event);
        }
      }
    };
    MouseMomentumGesture.prototype.onMouseLeave = function(event) {
      const input = this.getInput("mouse");
      if (input !== null) {
        this.updateInput(input, event);
        this.endHover(input, event);
      }
    };
    MouseMomentumGesture.prototype.onMouseDown = function(event) {
      const input = this.getOrCreateInput("mouse", "mouse", true, event.clientX, event.clientY, event.timeStamp);
      this.updateInput(input, event);
      if (!input.pressing) {
        this.beginPress(input, event);
      }
      if (event.button !== 0) {
        this.cancelPress(input, event);
      }
    };
    MouseMomentumGesture.prototype.onMouseMove = function(event) {
      const input = this.getInput("mouse");
      if (input !== null) {
        this.updateInput(input, event);
        this.movePress(input, event);
      }
    };
    MouseMomentumGesture.prototype.onMouseUp = function(event) {
      const input = this.getInput("mouse");
      if (input !== null) {
        this.updateInput(input, event);
        this.endPress(input, event);
        if (!input.defaultPrevented && event.button === 0) {
          this.press(input, event);
        }
      }
    };
    MouseMomentumGesture.prototype.onMouseLeaveDocument = function(event) {
      const input = this.getInput("mouse");
      if (input !== null) {
        this.updateInput(input, event);
        this.cancelPress(input, event);
        this.endHover(input, event);
      }
    };
    MouseMomentumGesture.construct = function(gestureClass, gesture, owner) {
      gesture = _super.construct(gestureClass, gesture, owner);
      gesture.onMouseEnter = gesture.onMouseEnter.bind(gesture);
      gesture.onMouseLeave = gesture.onMouseLeave.bind(gesture);
      gesture.onMouseDown = gesture.onMouseDown.bind(gesture);
      gesture.onMouseMove = gesture.onMouseMove.bind(gesture);
      gesture.onMouseUp = gesture.onMouseUp.bind(gesture);
      gesture.onMouseLeaveDocument = gesture.onMouseLeaveDocument.bind(gesture);
      return gesture;
    };
    return MouseMomentumGesture;
  }(MomentumGesture);
  class ScaleGestureInput extends MomentumGestureInput {
    constructor(inputId, inputType, isPrimary, x, y, t) {
      super(inputId, inputType, isPrimary, x, y, t);
      this.xCoord = void 0;
      this.yCoord = void 0;
      this.disableX = false;
      this.disableY = false;
    }
  }
  const ScaleGesture = function(_super) {
    const ScaleGesture = _super.extend("ScaleGesture");
    ScaleGesture.prototype.createInput = function(inputId, inputType, isPrimary, x, y, t) {
      return new ScaleGestureInput(inputId, inputType, isPrimary, x, y, t);
    };
    ScaleGesture.prototype.clearInputs = function() {
      MomentumGesture.prototype.clearInputs.call(this);
      this.setFlags(this.flags & ~ScaleGesture.NeedsRescale);
    };
    Object.defineProperty(ScaleGesture.prototype, "preserveAspectRatio", {
      get() {
        return (this.flags & ScaleGesture.PreserveAspectRatioFlag) !== 0;
      },
      set(preserveAspectRatio) {
        if (preserveAspectRatio) {
          this.setFlags(this.flags | ScaleGesture.PreserveAspectRatioFlag);
        } else {
          this.setFlags(this.flags & ~ScaleGesture.PreserveAspectRatioFlag);
        }
      },
      configurable: true
    });
    Object.defineProperty(ScaleGesture.prototype, "wheel", {
      get() {
        return (this.flags & ScaleGesture.WheelFlag) !== 0;
      },
      set(wheel) {
        if (wheel) {
          this.setFlags(this.flags | ScaleGesture.WheelFlag);
        } else {
          this.setFlags(this.flags & ~ScaleGesture.WheelFlag);
        }
      },
      configurable: true
    });
    ScaleGesture.prototype.getXScale = function() {
      return null;
    };
    ScaleGesture.prototype.setXScale = function(xScale, timing) {};
    ScaleGesture.prototype.getYScale = function() {
      return null;
    };
    ScaleGesture.prototype.setYScale = function(yScale, timing) {};
    ScaleGesture.prototype.clientToRangeX = function(clientX, xScale, bounds) {
      const viewX = clientX - bounds.xMin;
      const xRange = xScale.range;
      if (xRange[0] <= xRange[1]) {
        return xRange[0] + viewX;
      } else {
        return bounds.xMax + viewX - xRange[0];
      }
    };
    ScaleGesture.prototype.clientToRangeY = function(clientY, yScale, bounds) {
      const viewY = clientY - bounds.yMin;
      const yRange = yScale.range;
      if (yRange[0] <= yRange[1]) {
        return yRange[0] + viewY;
      } else {
        return bounds.yMax + viewY - yRange[0];
      }
    };
    ScaleGesture.prototype.unscaleX = function(clientX, xScale, bounds) {
      return xScale.inverse(this.clientToRangeX(clientX, xScale, bounds));
    };
    ScaleGesture.prototype.unscaleY = function(clientY, yScale, bounds) {
      return yScale.inverse(this.clientToRangeY(clientY, yScale, bounds));
    };
    ScaleGesture.prototype.viewWillAnimate = function(viewContext) {
      MomentumGesture.prototype.viewWillAnimate.call(this, viewContext);
      if ((this.flags & ScaleGesture.NeedsRescale) !== 0) {
        this.rescale();
      }
    };
    ScaleGesture.prototype.onBeginPress = function(input, event) {
      MomentumGesture.prototype.onBeginPress.call(this, input, event);
      this.updateInputDomain(input);
      this.view.requireUpdate(View.NeedsAnimate);
      this.setFlags(this.flags | ScaleGesture.NeedsRescale);
    };
    ScaleGesture.prototype.onMovePress = function(input, event) {
      MomentumGesture.prototype.onMovePress.call(this, input, event);
      this.view.requireUpdate(View.NeedsAnimate);
      this.setFlags(this.flags | ScaleGesture.NeedsRescale);
    };
    ScaleGesture.prototype.onEndPress = function(input, event) {
      MomentumGesture.prototype.onEndPress.call(this, input, event);
      this.updateInputDomain(input);
      this.view.requireUpdate(View.NeedsAnimate);
      this.setFlags(this.flags | ScaleGesture.NeedsRescale);
    };
    ScaleGesture.prototype.onCancelPress = function(input, event) {
      MomentumGesture.prototype.onCancelPress.call(this, input, event);
      this.updateInputDomain(input);
      this.view.requireUpdate(View.NeedsAnimate);
      this.setFlags(this.flags | ScaleGesture.NeedsRescale);
    };
    ScaleGesture.prototype.beginCoast = function(input, event) {
      if (this.coastCount < 2) {
        MomentumGesture.prototype.beginCoast.call(this, input, event);
      }
    };
    ScaleGesture.prototype.onBeginCoast = function(input, event) {
      MomentumGesture.prototype.onBeginCoast.call(this, input, event);
      this.updateInputDomain(input);
      this.conserveMomentum(input);
      this.view.requireUpdate(View.NeedsAnimate);
      this.setFlags(this.flags | ScaleGesture.NeedsRescale);
    };
    ScaleGesture.prototype.onEndCoast = function(input, event) {
      MomentumGesture.prototype.onEndCoast.call(this, input, event);
      input.disableX = false;
      input.disableY = false;
      this.view.requireUpdate(View.NeedsAnimate);
      this.setFlags(this.flags | ScaleGesture.NeedsRescale);
    };
    ScaleGesture.prototype.onCoast = function() {
      MomentumGesture.prototype.onCoast.call(this);
      this.view.requireUpdate(View.NeedsAnimate);
      this.setFlags(this.flags | ScaleGesture.NeedsRescale);
    };
    ScaleGesture.prototype.updateInputDomain = function(input, xScale, yScale, bounds) {
      if (xScale === void 0) {
        xScale = this.getXScale();
      }
      if (xScale !== null) {
        if (bounds === void 0) {
          bounds = this.view.clientBounds;
        }
        input.xCoord = this.unscaleX(input.x0, xScale, bounds);
      }
      if (yScale === void 0) {
        yScale = this.getYScale();
      }
      if (yScale !== null) {
        if (bounds === void 0) {
          bounds = this.view.clientBounds;
        }
        input.yCoord = this.unscaleY(input.y0, yScale, bounds);
      }
    };
    ScaleGesture.prototype.neutralizeX = function() {
      const inputs = this.inputs;
      for (const inputId in inputs) {
        const input = inputs[inputId];
        if (input.coasting) {
          input.disableX = true;
          input.vx = 0;
          input.ax = 0;
        }
      }
    };
    ScaleGesture.prototype.neutralizeY = function() {
      const inputs = this.inputs;
      for (const inputId in inputs) {
        const input = inputs[inputId];
        if (input.coasting) {
          input.disableY = true;
          input.vy = 0;
          input.ay = 0;
        }
      }
    };
    ScaleGesture.prototype.rescale = function() {
      let input0;
      let input1;
      const inputs = this.inputs;
      for (const inputId in inputs) {
        const input = inputs[inputId];
        if (input.pressing || input.coasting) {
          if (input0 === void 0) {
            input0 = input;
          } else if (input1 === void 0) {
            input1 = input;
          } else if (input.t0 < input0.t0) {
            input0 = input;
          } else if (input.t0 < input1.t0) {
            input1 = input;
          }
        }
      }
      if (input0 !== void 0) {
        const bounds = this.view.clientBounds;
        const xScale = this.getXScale();
        const yScale = this.getYScale();
        if (xScale !== null && yScale !== null) {
          if (input1 !== void 0 && this.preserveAspectRatio) {
            this.rescaleRadial(xScale, yScale, input0, input1, bounds);
          } else {
            this.rescaleXY(xScale, yScale, input0, input1, bounds);
          }
        } else if (xScale !== null) {
          this.rescaleX(xScale, input0, input1, bounds);
        } else if (yScale !== null) {
          this.rescaleY(yScale, input0, input1, bounds);
        }
      }
      this.setFlags(this.flags & ~ScaleGesture.NeedsRescale);
    };
    ScaleGesture.prototype.rescaleRadial = function(oldXScale, oldYScale, input0, input1, bounds) {
      const x0 = input0.xCoord;
      const y0 = input0.yCoord;
      const px0 = this.clientToRangeX(input0.x0, oldXScale, bounds);
      const py0 = this.clientToRangeY(input0.y0, oldYScale, bounds);
      const qx0 = this.clientToRangeX(input0.x, oldXScale, bounds);
      const qy0 = this.clientToRangeY(input0.y, oldYScale, bounds);
      const vx0 = input0.vx;
      const vy0 = input0.vy;
      const ax0 = input0.ax;
      const ay0 = input0.ay;
      const x1 = input1.xCoord;
      const y1 = input1.yCoord;
      const px1 = this.clientToRangeX(input1.x0, oldXScale, bounds);
      const py1 = this.clientToRangeY(input1.y0, oldYScale, bounds);
      const qx1 = this.clientToRangeX(input1.x, oldXScale, bounds);
      const qy1 = this.clientToRangeY(input1.y, oldYScale, bounds);
      const vx1 = input1.vx;
      const vy1 = input1.vy;
      const ax1 = input1.ax;
      const ay1 = input1.ay;
      const dpx = px1 - px0;
      const dpy = py1 - py0;
      const dp = Math.max(this.distanceMin, Math.sqrt(dpx * dpx + dpy * dpy));
      const upx = dpx / dp;
      const upy = dpy / dp;
      const dpqx0 = qx0 - px0;
      const dpqy0 = qy0 - py0;
      const dpqx1 = qx1 - px1;
      const dpqy1 = qy1 - py1;
      const ip0 = dpqx0 * upx + dpqy0 * upy;
      const ip1 = dpqx1 * upx + dpqy1 * upy;
      const ix0 = ip0 * upx;
      const iy0 = ip0 * upy;
      const ix1 = ip1 * upx;
      const iy1 = ip1 * upy;
      const jp0 = dpqx0 * upy + dpqy0 * -upx;
      const jp1 = dpqx1 * upy + dpqy1 * -upx;
      const jx0 = jp0 * upy;
      const jy0 = jp0 * -upx;
      const jx1 = jp1 * upy;
      const jy1 = jp1 * -upx;
      const jpx = (jx0 + jx1) / 2;
      const jpy = (jy0 + jy1) / 2;
      const rx0 = px0 + ix0 + jpx;
      const ry0 = py0 + iy0 + jpy;
      const rx1 = px1 + ix1 + jpx;
      const ry1 = py1 + iy1 + jpy;
      const iv0 = vx0 * upx + vy0 * upy;
      const iv1 = vx1 * upx + vy1 * upy;
      const ivx0 = iv0 * upx;
      const ivy0 = iv0 * upy;
      const ivx1 = iv1 * upx;
      const ivy1 = iv1 * upy;
      const jv0 = vx0 * upy + vy0 * -upx;
      const jv1 = vx1 * upy + vy1 * -upx;
      const jvx0 = jv0 * upy;
      const jvy0 = jv0 * -upx;
      const jvx1 = jv1 * upy;
      const jvy1 = jv1 * -upx;
      const jvx = (jvx0 + jvx1) / 2;
      const jvy = (jvy0 + jvy1) / 2;
      let rvx0 = ivx0 + jvx;
      let rvy0 = ivy0 + jvy;
      let rvx1 = ivx1 + jvx;
      let rvy1 = ivy1 + jvy;
      const v0 = Math.sqrt(rvx0 * rvx0 + rvy0 * rvy0);
      const v1 = Math.sqrt(rvx1 * rvx1 + rvy1 * rvy1);
      const uvx0 = v0 !== 0 ? rvx0 / v0 : 0;
      const uvy0 = v0 !== 0 ? rvy0 / v0 : 0;
      const uvx1 = v1 !== 0 ? rvx1 / v1 : 0;
      const uvy1 = v1 !== 0 ? rvy1 / v1 : 0;
      rvx0 = uvx0 * v0;
      rvy0 = uvy0 * v0;
      rvx1 = uvx1 * v1;
      rvy1 = uvy1 * v1;
      const a0 = Math.sqrt(ax0 * ax0 + ay0 * ay0);
      const a1 = Math.sqrt(ax1 * ax1 + ay1 * ay1);
      const rax0 = a0 * -uvx0;
      const ray0 = a0 * -uvy0;
      const rax1 = a1 * -uvx1;
      const ray1 = a1 * -uvy1;
      let newXScale = null;
      const solvedXScale = oldXScale.solveDomain(x0, rx0, x1, rx1);
      if (!solvedXScale.equals(oldXScale)) {
        newXScale = solvedXScale;
        this.setXScale(newXScale);
      }
      let newYScale = null;
      const solvedYScale = oldYScale.solveDomain(y0, ry0, y1, ry1);
      if (!solvedYScale.equals(oldYScale)) {
        newYScale = solvedYScale;
        this.setYScale(newYScale);
      }
      if (newXScale !== null || newYScale !== null) {
        if (newXScale !== null) {
          input0.x0 = input0.x;
          input0.dx = 0;
          input0.vx = rvx0;
          input0.ax = rax0;
          input0.xCoord = this.unscaleX(input0.x0, newXScale, bounds);
          input1.x0 = input1.x;
          input1.dx = 0;
          input1.vx = rvx1;
          input1.ax = rax1;
          input1.xCoord = this.unscaleX(input1.x0, newXScale, bounds);
        }
        if (newYScale !== null) {
          input0.y0 = input0.y;
          input0.dy = 0;
          input0.vy = rvy0;
          input0.ay = ray0;
          input0.yCoord = this.unscaleY(input0.y0, newYScale, bounds);
          input1.y0 = input1.y;
          input1.dy = 0;
          input1.vy = rvy1;
          input1.ay = ray1;
          input1.yCoord = this.unscaleY(input1.y0, newYScale, bounds);
        }
        if (this.inputCount > 2) {
          const inputs = this.inputs;
          for (const inputId in inputs) {
            const input = inputs[inputId];
            if (input !== input0 && input !== input1) {
              if (newXScale !== null) {
                input.x0 = input.x;
                input.dx = 0;
                input.xCoord = this.unscaleX(input.x0, newXScale, bounds);
              }
              if (newYScale !== null) {
                input.y0 = input.y;
                input.dy = 0;
                input.yCoord = this.unscaleY(input.y0, newYScale, bounds);
              }
            }
          }
        }
      }
    };
    ScaleGesture.prototype.rescaleXY = function(oldXScale, oldYScale, input0, input1, bounds) {
      const x0 = input0.xCoord;
      const y0 = input0.yCoord;
      let sx0 = this.clientToRangeX(input0.x, oldXScale, bounds);
      let sy0 = this.clientToRangeY(input0.y, oldYScale, bounds);
      let disableX = input0.disableX;
      let disableY = input0.disableY;
      let x1;
      let y1;
      let sx1;
      let sy1;
      if (input1 !== void 0) {
        x1 = input1.xCoord;
        y1 = input1.yCoord;
        sx1 = this.clientToRangeX(input1.x, oldXScale, bounds);
        sy1 = this.clientToRangeY(input1.y, oldYScale, bounds);
        disableX = disableX || input1.disableX;
        disableY = disableY || input1.disableY;
        const dsx = Math.abs(sx1 - sx0);
        const dsy = Math.abs(sy1 - sy0);
        const distanceMin = this.distanceMin;
        if (dsx < distanceMin) {
          const esx = (distanceMin - dsx) / 2;
          if (sx0 <= sx1) {
            sx0 -= esx;
            sx1 += esx;
          } else {
            sx0 += esx;
            sx1 -= esx;
          }
        }
        if (dsy < distanceMin) {
          const esy = (distanceMin - dsy) / 2;
          if (sy0 <= sy1) {
            sy0 -= esy;
            sy1 += esy;
          } else {
            sy0 += esy;
            sy1 -= esy;
          }
        }
      }
      let newXScale = null;
      if (!disableX) {
        newXScale = oldXScale.solveDomain(x0, sx0, x1, sx1);
        if (!newXScale.equals(oldXScale)) {
          this.setXScale(newXScale);
        }
      }
      let newYScale = null;
      if (!disableY) {
        newYScale = oldYScale.solveDomain(y0, sy0, y1, sy1);
        if (!newYScale.equals(oldYScale)) {
          this.setYScale(newYScale);
        }
      }
      if ((newXScale !== null || newYScale !== null) && this.preserveAspectRatio) {
        const inputs = this.inputs;
        for (const inputId in inputs) {
          const input = inputs[inputId];
          if (newXScale !== null) {
            input.x0 = input.x;
            input.dx = 0;
            input.xCoord = this.unscaleX(input.x0, newXScale, bounds);
          }
          if (newYScale !== null) {
            input.y0 = input.y;
            input.dy = 0;
            input.yCoord = this.unscaleY(input.y0, newYScale, bounds);
          }
        }
      }
    };
    ScaleGesture.prototype.rescaleX = function(oldXScale, input0, input1, bounds) {
      const x0 = input0.xCoord;
      let sx0 = this.clientToRangeX(input0.x, oldXScale, bounds);
      let sx1;
      let x1;
      let disableX = input0.disableX;
      if (input1 !== void 0) {
        x1 = input1.xCoord;
        sx1 = this.clientToRangeX(input1.x, oldXScale, bounds);
        disableX = disableX || input1.disableX;
        const dsx = Math.abs(sx1 - sx0);
        const distanceMin = this.distanceMin;
        if (dsx < distanceMin) {
          const esx = (distanceMin - dsx) / 2;
          if (sx0 <= sx1) {
            sx0 -= esx;
            sx1 += esx;
          } else {
            sx0 += esx;
            sx1 -= esx;
          }
        }
      }
      if (!disableX) {
        const newXScale = oldXScale.solveDomain(x0, sx0, x1, sx1);
        if (!newXScale.equals(oldXScale)) {
          this.setXScale(newXScale);
        }
      }
    };
    ScaleGesture.prototype.rescaleY = function(oldYScale, input0, input1, bounds) {
      const y0 = input0.yCoord;
      let sy0 = this.clientToRangeY(input0.y, oldYScale, bounds);
      let sy1;
      let y1;
      let disableY = input0.disableY;
      if (input1 !== void 0) {
        y1 = input1.yCoord;
        sy1 = this.clientToRangeY(input1.y, oldYScale, bounds);
        disableY = disableY || input1.disableY;
        const dsy = Math.abs(sy1 - sy0);
        const distanceMin = this.distanceMin;
        if (dsy < distanceMin) {
          const esy = (distanceMin - dsy) / 2;
          if (sy0 <= sy1) {
            sy0 -= esy;
            sy1 += esy;
          } else {
            sy0 += esy;
            sy1 -= esy;
          }
        }
      }
      if (!disableY) {
        const newYScale = oldYScale.solveDomain(y0, sy0, y1, sy1);
        if (!newYScale.equals(oldYScale)) {
          this.setYScale(newYScale);
        }
      }
    };
    ScaleGesture.prototype.conserveMomentum = function(input0) {
      let input1;
      const inputs = this.inputs;
      for (const inputId in inputs) {
        const input = inputs[inputId];
        if (input.coasting) {
          if (input1 === void 0) {
            input1 = input;
          } else if (input.t0 < input1.t0) {
            input1 = input;
          }
        }
      }
      if (input1 !== void 0) {
        const xScale = this.getXScale();
        const yScale = this.getYScale();
        if (xScale !== null && yScale !== null) {
          this.distributeXYMomentum(input0, input1);
        } else if (xScale !== null) {
          this.distributeXMomentum(input0, input1);
        } else if (yScale !== null) {
          this.distributeYMomentum(input0, input1);
        }
      }
    };
    ScaleGesture.prototype.distributeXYMomentum = function(input0, input1) {
      const vx0 = input0.vx;
      const vy0 = input0.vy;
      const vx1 = input1.vx;
      const vy1 = input1.vy;
      const v0 = Math.sqrt(vx0 * vx0 + vy0 * vy0);
      const v1 = Math.sqrt(vx1 * vx1 + vy1 * vy1);
      const uvx0 = v0 !== 0 ? vx0 / v0 : 0;
      const uvy0 = v0 !== 0 ? vy0 / v0 : 0;
      const uvx1 = v1 !== 0 ? vx1 / v1 : 0;
      const uvy1 = v1 !== 0 ? vy1 / v1 : 0;
      const v = (v0 + v1) / 2;
      input0.vx = uvx0 * v;
      input0.vy = uvy0 * v;
      input1.vx = uvx1 * v;
      input1.vy = uvy1 * v;
      const ax0 = input0.ax;
      const ay0 = input0.ay;
      const ax1 = input1.ax;
      const ay1 = input1.ay;
      const a0 = Math.sqrt(ax0 * ax0 + ay0 * ay0);
      const a1 = Math.sqrt(ax1 * ax1 + ay1 * ay1);
      const uax0 = a0 !== 0 ? ax0 / a0 : 0;
      const uay0 = a0 !== 0 ? ay0 / a0 : 0;
      const uax1 = a1 !== 0 ? ax1 / a1 : 0;
      const uay1 = a1 !== 0 ? ay1 / a1 : 0;
      const a = (a0 + a1) / 2;
      input0.ax = uax0 * a;
      input0.ay = uay0 * a;
      input1.ax = uax1 * a;
      input1.ay = uay1 * a;
    };
    ScaleGesture.prototype.distributeXMomentum = function(input0, input1) {
      const vx0 = input0.vx;
      const vx1 = input1.vx;
      const v0 = Math.abs(vx0);
      const v1 = Math.abs(vx1);
      const uvx0 = v0 !== 0 ? vx0 / v0 : 0;
      const uvx1 = v1 !== 0 ? vx1 / v1 : 0;
      const v = (v0 + v1) / 2;
      input0.vx = uvx0 * v;
      input1.vx = uvx1 * v;
      const ax0 = input0.ax;
      const ax1 = input1.ax;
      const a0 = Math.abs(ax0);
      const a1 = Math.abs(ax1);
      const uax0 = a0 !== 0 ? ax0 / a0 : 0;
      const uax1 = a1 !== 0 ? ax1 / a1 : 0;
      const a = (a0 + a1) / 2;
      input0.ax = uax0 * a;
      input1.ax = uax1 * a;
    };
    ScaleGesture.prototype.distributeYMomentum = function(input0, input1) {
      const vy0 = input0.vy;
      const vy1 = input1.vy;
      const v0 = Math.sqrt(vy0);
      const v1 = Math.sqrt(vy1);
      const uvy0 = v0 !== 0 ? vy0 / v0 : 0;
      const uvy1 = v1 !== 0 ? vy1 / v1 : 0;
      const v = (v0 + v1) / 2;
      input0.vy = uvy0 * v;
      input1.vy = uvy1 * v;
      const ay0 = input0.ay;
      const ay1 = input1.ay;
      const a0 = Math.sqrt(ay0);
      const a1 = Math.sqrt(ay1);
      const uay0 = a0 !== 0 ? ay0 / a0 : 0;
      const uay1 = a1 !== 0 ? ay1 / a1 : 0;
      const a = (a0 + a1) / 2;
      input0.ay = uay0 * a;
      input1.ay = uay1 * a;
    };
    ScaleGesture.prototype.integrate = function(t) {
      let coast0;
      let coast1;
      const inputs = this.inputs;
      for (const inputId in inputs) {
        const input = inputs[inputId];
        if (input.coasting) {
          if (coast0 === void 0) {
            coast0 = input;
          } else if (coast1 === void 0) {
            coast1 = input;
            const dx0 = coast1.x - coast0.x;
            const dy0 = coast1.y - coast0.y;
            const d0 = Math.sqrt(dx0 * dx0 + dy0 * dy0);
            coast0.integrateVelocity(t);
            coast1.integrateVelocity(t);
            const dx1 = coast1.x - coast0.x;
            const dy1 = coast1.y - coast0.y;
            const d1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            const s = d1 / d0;
            coast0.vx *= s;
            coast0.vy *= s;
            coast0.ax *= s;
            coast0.ay *= s;
            coast1.vx *= s;
            coast1.vy *= s;
            coast1.ax *= s;
            coast1.ay *= s;
          } else {
            input.integrateVelocity(t);
          }
        }
      }
      if (coast0 !== void 0 && coast1 === void 0) {
        coast0.integrateVelocity(t);
      }
    };
    ScaleGesture.prototype.zoom = function(x, y, dz, event) {
      if (dz === 0) {
        return;
      }
      const t = event !== null ? event.timeStamp : performance.now();
      const a = this.acceleration;
      let ax = a * Math.cos(Math.PI / 4);
      let ay = a * Math.sin(Math.PI / 4);
      const vMax = this.velocityMax;
      const vx = .5 * vMax * Math.cos(Math.PI / 4);
      const vy = .5 * vMax * Math.sin(Math.PI / 4);
      const dx = 4 * vx * vx / ax;
      const dy = 4 * vy * vy / ay;
      const inputs = this.inputs;
      let zoom0 = inputs.zoom0;
      let zoom1 = inputs.zoom1;
      if (zoom0 !== void 0 && zoom1 !== void 0) {
        const dt = t - zoom0.t;
        if (dt > 0) {
          const dzx = Math.abs(zoom1.x - zoom0.x) / 2;
          const dzy = Math.abs(zoom1.y - zoom0.y) / 2;
          dz = Math.min(Math.max(-vMax * dt, dz), vMax * dt);
          const zx = dz * dzx * Math.cos(Math.PI / 4) / dx;
          const zy = dz * dzy * Math.sin(Math.PI / 4) / dy;
          ax = ax * dzx / dx;
          ay = ay * dzy / dy;
          zoom0.x += zx;
          zoom0.y += zy;
          zoom0.t = t;
          zoom0.dx = zx;
          zoom0.dy = zy;
          zoom0.dt = dt;
          zoom0.vx = zx / dt;
          zoom0.vy = zy / dt;
          zoom0.ax = zoom0.vx < 0 ? ax : zoom0.vx > 0 ? -ax : 0;
          zoom0.ay = zoom0.vy < 0 ? ay : zoom0.vy > 0 ? -ay : 0;
          zoom1.x -= zx;
          zoom1.y -= zy;
          zoom1.t = t;
          zoom0.dx = -zx;
          zoom0.dy = -zy;
          zoom0.dt = dt;
          zoom1.vx = -zx / dt;
          zoom1.vy = -zy / dt;
          zoom1.ax = zoom1.vx < 0 ? ax : zoom1.vx > 0 ? -ax : 0;
          zoom1.ay = zoom1.vy < 0 ? ay : zoom1.vy > 0 ? -ay : 0;
        }
      } else {
        this.interrupt(event);
        if (dz < 0) {
          zoom0 = this.createInput("zoom0", "unknown", false, x - dx, y - dy, t);
          zoom0.vx = -vx;
          zoom0.vy = -vy;
          zoom0.ax = ax;
          zoom0.ay = ay;
          zoom1 = this.createInput("zoom1", "unknown", false, x + dx, y + dy, t);
          zoom1.vx = vx;
          zoom1.vy = vy;
          zoom1.ax = -ax;
          zoom1.ay = -ay;
        } else {
          zoom0 = this.createInput("zoom0", "unknown", false, x - dx, y - dy, t);
          zoom0.vx = vx;
          zoom0.vy = vy;
          zoom0.ax = -ax;
          zoom0.ay = -ay;
          zoom1 = this.createInput("zoom1", "unknown", false, x + dx, y + dy, t);
          zoom1.vx = -vx;
          zoom1.vy = -vy;
          zoom1.ax = ax;
          zoom1.ay = ay;
        }
        inputs.zoom0 = zoom0;
        inputs.zoom1 = zoom1;
        this.inputCount += 2;
        this.beginCoast(zoom0, event);
        this.beginCoast(zoom1, event);
      }
    };
    Object.defineProperty(ScaleGesture.prototype, "observes", {
      value: true,
      enumerable: true,
      configurable: true
    });
    ScaleGesture.construct = function(gestureClass, gesture, owner) {
      gesture = _super.construct(gestureClass, gesture, owner);
      gesture.distanceMin = ScaleGesture.DistanceMin;
      gesture.setFlags(gesture.flags | ScaleGesture.WheelFlag);
      return gesture;
    };
    ScaleGesture.specialize = function(method) {
      if (method === "pointer") {
        return PointerScaleGesture;
      } else if (method === "touch") {
        return TouchScaleGesture;
      } else if (method === "mouse") {
        return MouseScaleGesture;
      } else if (typeof PointerEvent !== "undefined") {
        return PointerScaleGesture;
      } else if (typeof TouchEvent !== "undefined") {
        return TouchScaleGesture;
      } else {
        return MouseScaleGesture;
      }
    };
    ScaleGesture.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      let method = descriptor.method;
      const hysteresis = descriptor.hysteresis;
      const acceleration = descriptor.hysteresis;
      const velocityMax = descriptor.hysteresis;
      const distanceMin = descriptor.distanceMin;
      const preserveAspectRatio = descriptor.preserveAspectRatio;
      const wheel = descriptor.wheel;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.method;
      delete descriptor.hysteresis;
      delete descriptor.acceleration;
      delete descriptor.velocityMax;
      delete descriptor.distanceMin;
      delete descriptor.preserveAspectRatio;
      delete descriptor.wheel;
      if (descriptor.key === true) {
        Object.defineProperty(descriptor, "key", {
          value: className,
          configurable: true
        });
      } else if (descriptor.key === false) {
        Object.defineProperty(descriptor, "key", {
          value: void 0,
          configurable: true
        });
      }
      if (method === void 0) {
        method = "auto";
      }
      if (superClass === void 0 || superClass === null) {
        superClass = ScaleGesture.specialize(method);
      }
      if (superClass === null) {
        superClass = this;
      }
      const gestureClass = superClass.extend(className, descriptor);
      gestureClass.construct = function(gestureClass, gesture, owner) {
        gesture = superClass.construct(gestureClass, gesture, owner);
        if (affinity !== void 0) {
          gesture.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          gesture.initInherits(inherits);
        }
        if (hysteresis !== void 0) {
          gesture.hysteresis = hysteresis;
        }
        if (acceleration !== void 0) {
          gesture.acceleration = acceleration;
        }
        if (velocityMax !== void 0) {
          gesture.velocityMax = velocityMax;
        }
        if (distanceMin !== void 0) {
          gesture.distanceMin = distanceMin;
        }
        if (preserveAspectRatio !== void 0) {
          gesture.preserveAspectRatio = preserveAspectRatio;
        }
        if (wheel !== void 0) {
          gesture.wheel = wheel;
        }
        return gesture;
      };
      return gestureClass;
    };
    ScaleGesture.DistanceMin = 10;
    ScaleGesture.PreserveAspectRatioFlag = 1 << _super.FlagShift + 0;
    ScaleGesture.WheelFlag = 1 << _super.FlagShift + 1;
    ScaleGesture.NeedsRescale = 1 << _super.FlagShift + 2;
    ScaleGesture.FlagShift = _super.FlagShift + 3;
    ScaleGesture.FlagMask = (1 << ScaleGesture.FlagShift) - 1;
    return ScaleGesture;
  }(MomentumGesture);
  const PointerScaleGesture = function(_super) {
    const PointerScaleGesture = _super.extend("PointerScaleGesture");
    PointerScaleGesture.prototype.attachHoverEvents = function(view) {
      view.on("pointerenter", this.onPointerEnter);
      view.on("pointerleave", this.onPointerLeave);
      view.on("pointerdown", this.onPointerDown);
      view.on("wheel", this.onWheel);
    };
    PointerScaleGesture.prototype.detachHoverEvents = function(view) {
      view.off("pointerenter", this.onPointerEnter);
      view.off("pointerleave", this.onPointerLeave);
      view.off("pointerdown", this.onPointerDown);
      view.off("wheel", this.onWheel);
    };
    PointerScaleGesture.prototype.attachPressEvents = function(view) {
      document.body.addEventListener("pointermove", this.onPointerMove);
      document.body.addEventListener("pointerup", this.onPointerUp);
      document.body.addEventListener("pointercancel", this.onPointerCancel);
      document.body.addEventListener("pointerleave", this.onPointerLeaveDocument);
    };
    PointerScaleGesture.prototype.detachPressEvents = function(view) {
      document.body.removeEventListener("pointermove", this.onPointerMove);
      document.body.removeEventListener("pointerup", this.onPointerUp);
      document.body.removeEventListener("pointercancel", this.onPointerCancel);
      document.body.removeEventListener("pointerleave", this.onPointerLeaveDocument);
    };
    PointerScaleGesture.prototype.updateInput = function(input, event) {
      input.target = event.target;
      input.button = event.button;
      input.buttons = event.buttons;
      input.altKey = event.altKey;
      input.ctrlKey = event.ctrlKey;
      input.metaKey = event.metaKey;
      input.shiftKey = event.shiftKey;
      input.dx = event.clientX - input.x;
      input.dy = event.clientY - input.y;
      input.dt = event.timeStamp - input.t;
      input.x = event.clientX;
      input.y = event.clientY;
      input.t = event.timeStamp;
      input.width = event.width;
      input.height = event.height;
      input.tiltX = event.tiltX;
      input.tiltY = event.tiltY;
      input.twist = event.twist;
      input.pressure = event.pressure;
      input.tangentialPressure = event.tangentialPressure;
    };
    PointerScaleGesture.prototype.onPointerEnter = function(event) {
      if (event.pointerType === "mouse" && event.buttons === 0) {
        const input = this.getOrCreateInput(event.pointerId, GestureInput.pointerInputType(event.pointerType), event.isPrimary, event.clientX, event.clientY, event.timeStamp);
        if (!input.coasting) {
          this.updateInput(input, event);
        }
        if (!input.hovering) {
          this.beginHover(input, event);
        }
      }
    };
    PointerScaleGesture.prototype.onPointerLeave = function(event) {
      if (event.pointerType === "mouse") {
        const input = this.getInput(event.pointerId);
        if (input !== null) {
          if (!input.coasting) {
            this.updateInput(input, event);
          }
          this.endHover(input, event);
        }
      }
    };
    PointerScaleGesture.prototype.onPointerDown = function(event) {
      const input = this.getOrCreateInput(event.pointerId, GestureInput.pointerInputType(event.pointerType), event.isPrimary, event.clientX, event.clientY, event.timeStamp);
      this.updateInput(input, event);
      if (!input.pressing) {
        this.beginPress(input, event);
      }
      if (event.pointerType === "mouse" && event.button !== 0) {
        this.cancelPress(input, event);
      }
    };
    PointerScaleGesture.prototype.onPointerMove = function(event) {
      const input = this.getInput(event.pointerId);
      if (input !== null) {
        this.updateInput(input, event);
        this.movePress(input, event);
      }
    };
    PointerScaleGesture.prototype.onPointerUp = function(event) {
      const input = this.getInput(event.pointerId);
      if (input !== null) {
        this.updateInput(input, event);
        this.endPress(input, event);
        if (!input.defaultPrevented && event.button === 0) {
          this.press(input, event);
        }
      }
    };
    PointerScaleGesture.prototype.onPointerCancel = function(event) {
      const input = this.getInput(event.pointerId);
      if (input !== null) {
        this.updateInput(input, event);
        this.cancelPress(input, event);
      }
    };
    PointerScaleGesture.prototype.onPointerLeaveDocument = function(event) {
      const input = this.getInput(event.pointerId);
      if (input !== null) {
        this.updateInput(input, event);
        this.cancelPress(input, event);
        this.endHover(input, event);
      }
    };
    PointerScaleGesture.prototype.onWheel = function(event) {
      if (this.wheel) {
        event.preventDefault();
        this.zoom(event.clientX, event.clientY, event.deltaY, event);
      }
    };
    PointerScaleGesture.construct = function(gestureClass, gesture, owner) {
      gesture = _super.construct(gestureClass, gesture, owner);
      gesture.onPointerEnter = gesture.onPointerEnter.bind(gesture);
      gesture.onPointerLeave = gesture.onPointerLeave.bind(gesture);
      gesture.onPointerDown = gesture.onPointerDown.bind(gesture);
      gesture.onPointerMove = gesture.onPointerMove.bind(gesture);
      gesture.onPointerUp = gesture.onPointerUp.bind(gesture);
      gesture.onPointerCancel = gesture.onPointerCancel.bind(gesture);
      gesture.onPointerLeaveDocument = gesture.onPointerLeaveDocument.bind(gesture);
      gesture.onWheel = gesture.onWheel.bind(gesture);
      return gesture;
    };
    return PointerScaleGesture;
  }(ScaleGesture);
  const TouchScaleGesture = function(_super) {
    const TouchScaleGesture = _super.extend("TouchScaleGesture");
    TouchScaleGesture.prototype.attachHoverEvents = function(view) {
      view.on("touchstart", this.onTouchStart);
    };
    TouchScaleGesture.prototype.detachHoverEvents = function(view) {
      view.off("touchstart", this.onTouchStart);
    };
    TouchScaleGesture.prototype.attachPressEvents = function(view) {
      view.on("touchmove", this.onTouchMove);
      view.on("touchend", this.onTouchEnd);
      view.on("touchcancel", this.onTouchCancel);
    };
    TouchScaleGesture.prototype.detachPressEvents = function(view) {
      view.off("touchmove", this.onTouchMove);
      view.off("touchend", this.onTouchEnd);
      view.off("touchcancel", this.onTouchCancel);
    };
    TouchScaleGesture.prototype.updateInput = function(input, event, touch) {
      input.target = touch.target;
      input.altKey = event.altKey;
      input.ctrlKey = event.ctrlKey;
      input.metaKey = event.metaKey;
      input.shiftKey = event.shiftKey;
      input.dx = touch.clientX - input.x;
      input.dy = touch.clientY - input.y;
      input.dt = event.timeStamp - input.t;
      input.x = touch.clientX;
      input.y = touch.clientY;
      input.t = event.timeStamp;
    };
    TouchScaleGesture.prototype.onTouchStart = function(event) {
      const touches = event.targetTouches;
      for (let i = 0; i < touches.length; i += 1) {
        const touch = touches[i];
        const input = this.getOrCreateInput(touch.identifier, "touch", false, touch.clientX, touch.clientY, event.timeStamp);
        this.updateInput(input, event, touch);
        if (!input.pressing) {
          this.beginPress(input, event);
        }
      }
    };
    TouchScaleGesture.prototype.onTouchMove = function(event) {
      const touches = event.changedTouches;
      for (let i = 0; i < touches.length; i += 1) {
        const touch = touches[i];
        const input = this.getInput(touch.identifier);
        if (input !== null) {
          this.updateInput(input, event, touch);
          this.movePress(input, event);
        }
      }
    };
    TouchScaleGesture.prototype.onTouchEnd = function(event) {
      const touches = event.changedTouches;
      for (let i = 0; i < touches.length; i += 1) {
        const touch = touches[i];
        const input = this.getInput(touch.identifier);
        if (input !== null) {
          this.updateInput(input, event, touch);
          this.endPress(input, event);
          if (!input.defaultPrevented) {
            this.press(input, event);
          }
          this.endHover(input, event);
        }
      }
    };
    TouchScaleGesture.prototype.onTouchCancel = function(event) {
      const touches = event.changedTouches;
      for (let i = 0; i < touches.length; i += 1) {
        const touch = touches[i];
        const input = this.getInput(touch.identifier);
        if (input !== null) {
          this.updateInput(input, event, touch);
          this.cancelPress(input, event);
          this.endHover(input, event);
        }
      }
    };
    TouchScaleGesture.construct = function(gestureClass, gesture, owner) {
      gesture = _super.construct(gestureClass, gesture, owner);
      gesture.onTouchStart = gesture.onTouchStart.bind(gesture);
      gesture.onTouchMove = gesture.onTouchMove.bind(gesture);
      gesture.onTouchEnd = gesture.onTouchEnd.bind(gesture);
      gesture.onTouchCancel = gesture.onTouchCancel.bind(gesture);
      return gesture;
    };
    return TouchScaleGesture;
  }(ScaleGesture);
  const MouseScaleGesture = function(_super) {
    const MouseScaleGesture = _super.extend("MouseScaleGesture");
    MouseScaleGesture.prototype.attachHoverEvents = function(view) {
      view.on("mouseenter", this.onMouseEnter);
      view.on("mouseleave", this.onMouseLeave);
      view.on("mousedown", this.onMouseDown);
      view.on("wheel", this.onWheel);
    };
    MouseScaleGesture.prototype.detachHoverEvents = function(view) {
      view.off("mouseenter", this.onMouseEnter);
      view.off("mouseleave", this.onMouseLeave);
      view.off("mousedown", this.onMouseDown);
      view.off("wheel", this.onWheel);
    };
    MouseScaleGesture.prototype.attachPressEvents = function(view) {
      document.body.addEventListener("mousemove", this.onMouseMove);
      document.body.addEventListener("mouseup", this.onMouseUp);
      document.body.addEventListener("mouseleave", this.onMouseLeaveDocument);
    };
    MouseScaleGesture.prototype.detachPressEvents = function(view) {
      document.body.removeEventListener("mousemove", this.onMouseMove);
      document.body.removeEventListener("mouseup", this.onMouseUp);
      document.body.removeEventListener("mouseleave", this.onMouseLeaveDocument);
    };
    MouseScaleGesture.prototype.updateInput = function(input, event) {
      input.target = event.target;
      input.button = event.button;
      input.buttons = event.buttons;
      input.altKey = event.altKey;
      input.ctrlKey = event.ctrlKey;
      input.metaKey = event.metaKey;
      input.shiftKey = event.shiftKey;
      input.dx = event.clientX - input.x;
      input.dy = event.clientY - input.y;
      input.dt = event.timeStamp - input.t;
      input.x = event.clientX;
      input.y = event.clientY;
      input.t = event.timeStamp;
    };
    MouseScaleGesture.prototype.onMouseEnter = function(event) {
      if (event.buttons === 0) {
        const input = this.getOrCreateInput("mouse", "mouse", true, event.clientX, event.clientY, event.timeStamp);
        if (!input.coasting) {
          this.updateInput(input, event);
        }
        if (!input.hovering) {
          this.beginHover(input, event);
        }
      }
    };
    MouseScaleGesture.prototype.onMouseLeave = function(event) {
      const input = this.getInput("mouse");
      if (input !== null) {
        if (!input.coasting) {
          this.updateInput(input, event);
        }
        this.endHover(input, event);
      }
    };
    MouseScaleGesture.prototype.onMouseDown = function(event) {
      const input = this.getOrCreateInput("mouse", "mouse", true, event.clientX, event.clientY, event.timeStamp);
      this.updateInput(input, event);
      if (!input.pressing) {
        this.beginPress(input, event);
      }
      if (event.button !== 0) {
        this.cancelPress(input, event);
      }
    };
    MouseScaleGesture.prototype.onMouseMove = function(event) {
      const input = this.getInput("mouse");
      if (input !== null) {
        this.updateInput(input, event);
        this.movePress(input, event);
      }
    };
    MouseScaleGesture.prototype.onMouseUp = function(event) {
      const input = this.getInput("mouse");
      if (input !== null) {
        this.updateInput(input, event);
        this.endPress(input, event);
        if (!input.defaultPrevented && event.button === 0) {
          this.press(input, event);
        }
      }
    };
    MouseScaleGesture.prototype.onMouseLeaveDocument = function(event) {
      const input = this.getInput("mouse");
      if (input !== null) {
        this.updateInput(input, event);
        this.cancelPress(input, event);
        this.endHover(input, event);
      }
    };
    MouseScaleGesture.prototype.onWheel = function(event) {
      if (this.wheel) {
        event.preventDefault();
        this.zoom(event.clientX, event.clientY, event.deltaY, event);
      }
    };
    MouseScaleGesture.construct = function(gestureClass, gesture, owner) {
      gesture = _super.construct(gestureClass, gesture, owner);
      gesture.onMouseEnter = gesture.onMouseEnter.bind(gesture);
      gesture.onMouseLeave = gesture.onMouseLeave.bind(gesture);
      gesture.onMouseDown = gesture.onMouseDown.bind(gesture);
      gesture.onMouseMove = gesture.onMouseMove.bind(gesture);
      gesture.onMouseUp = gesture.onMouseUp.bind(gesture);
      gesture.onMouseLeaveDocument = gesture.onMouseLeaveDocument.bind(gesture);
      gesture.onWheel = gesture.onWheel.bind(gesture);
      return gesture;
    };
    return MouseScaleGesture;
  }(ScaleGesture);
  class View extends component.Component {
    constructor() {
      super();
      this.observerCache = {};
      this.constraints = util.Arrays.empty;
      this.constraintVariables = util.Arrays.empty;
    }
    get componentType() {
      return View;
    }
    attachParent(parent, nextSibling) {
      this.willAttachParent(parent);
      this.parent = parent;
      let previousSibling;
      if (nextSibling !== null) {
        previousSibling = nextSibling.previousSibling;
        this.setNextSibling(nextSibling);
        nextSibling.setPreviousSibling(this);
      } else {
        previousSibling = parent.lastChild;
        parent.setLastChild(this);
      }
      if (previousSibling !== null) {
        previousSibling.setNextSibling(this);
        this.setPreviousSibling(previousSibling);
      } else {
        parent.setFirstChild(this);
      }
      if (parent.mounted) {
        if (parent.culled) {
          this.cascadeCull();
        }
        this.cascadeMount();
      }
      this.onAttachParent(parent);
      this.didAttachParent(parent);
    }
    willAttachParent(parent) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewWillAttachParent !== void 0) {
          observer.viewWillAttachParent(parent, this);
        }
      }
    }
    onAttachParent(parent) {}
    didAttachParent(parent) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewDidAttachParent !== void 0) {
          observer.viewDidAttachParent(parent, this);
        }
      }
    }
    willDetachParent(parent) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewWillDetachParent !== void 0) {
          observer.viewWillDetachParent(parent, this);
        }
      }
    }
    onDetachParent(parent) {}
    didDetachParent(parent) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewDidDetachParent !== void 0) {
          observer.viewDidDetachParent(parent, this);
        }
      }
    }
    setChild(key, newChild) {
      if (newChild !== null) {
        newChild = View.fromAny(newChild);
      }
      return super.setChild(key, newChild);
    }
    appendChild(child, key) {
      child = View.fromAny(child);
      return super.appendChild(child, key);
    }
    prependChild(child, key) {
      child = View.fromAny(child);
      return super.prependChild(child, key);
    }
    insertChild(child, target, key) {
      child = View.fromAny(child);
      return super.insertChild(child, target, key);
    }
    replaceChild(newChild, oldChild) {
      newChild = View.fromAny(newChild);
      return super.replaceChild(newChild, oldChild);
    }
    willInsertChild(child, target) {
      super.willInsertChild(child, target);
      const observers = this.observerCache.viewWillInsertChildObservers;
      if (observers !== void 0) {
        for (let i = 0, n = observers.length; i < n; i += 1) {
          const observer = observers[i];
          observer.viewWillInsertChild(child, target, this);
        }
      }
    }
    onInsertChild(child, target) {
      super.onInsertChild(child, target);
    }
    didInsertChild(child, target) {
      const observers = this.observerCache.viewDidInsertChildObservers;
      if (observers !== void 0) {
        for (let i = 0, n = observers.length; i < n; i += 1) {
          const observer = observers[i];
          observer.viewDidInsertChild(child, target, this);
        }
      }
      super.didInsertChild(child, target);
    }
    cascadeInsert(updateFlags, viewContext) {
      if ((this.flags & View.MountedFlag) !== 0) {
        if (updateFlags === void 0) {
          updateFlags = 0;
        }
        updateFlags |= this.flags & View.UpdateMask;
        if ((updateFlags & View.ProcessMask) !== 0) {
          if (viewContext === void 0) {
            viewContext = this.superViewContext;
          }
          this.cascadeProcess(updateFlags, viewContext);
        }
      }
    }
    willRemoveChild(child) {
      super.willRemoveChild(child);
      const observers = this.observerCache.viewWillRemoveChildObservers;
      if (observers !== void 0) {
        for (let i = 0, n = observers.length; i < n; i += 1) {
          const observer = observers[i];
          observer.viewWillRemoveChild(child, this);
        }
      }
    }
    onRemoveChild(child) {
      super.onRemoveChild(child);
    }
    didRemoveChild(child) {
      const observers = this.observerCache.viewDidRemoveChildObservers;
      if (observers !== void 0) {
        for (let i = 0, n = observers.length; i < n; i += 1) {
          const observer = observers[i];
          observer.viewDidRemoveChild(child, this);
        }
      }
      super.didRemoveChild(child);
    }
    mount() {
      throw new Error;
    }
    willMount() {
      super.willMount();
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewWillMount !== void 0) {
          observer.viewWillMount(this);
        }
      }
    }
    onMount() {
      this.requestUpdate(this, this.flags & View.UpdateMask, false);
      this.requireUpdate(this.mountFlags);
      if (!this.culled && this.decoherent !== null && this.decoherent.length !== 0) {
        this.requireUpdate(View.NeedsChange | View.NeedsAnimate);
      }
      this.mountFasteners();
      this.mountTheme();
      this.updateTheme(false);
    }
    didMount() {
      this.activateLayout();
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewDidMount !== void 0) {
          observer.viewDidMount(this);
        }
      }
      super.didMount();
    }
    unmount() {
      throw new Error;
    }
    willUnmount() {
      super.willUnmount();
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewWillUnmount !== void 0) {
          observer.viewWillUnmount(this);
        }
      }
      this.deactivateLayout();
    }
    didUnmount() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewDidUnmount !== void 0) {
          observer.viewDidUnmount(this);
        }
      }
      super.didUnmount();
    }
    get culled() {
      return (this.flags & View.CulledMask) !== 0;
    }
    setCulled(culled) {
      const flags = this.flags;
      if (culled && (flags & View.CulledFlag) === 0) {
        if ((flags & View.CullFlag) === 0) {
          this.willCull();
          this.setFlags(flags | View.CulledFlag);
          this.onCull();
          this.cullChildren();
          this.didCull();
        } else {
          this.setFlags(flags | View.CulledFlag);
        }
      } else if (!culled && (flags & View.CulledFlag) !== 0) {
        if ((flags & View.CullFlag) === 0) {
          this.willUncull();
          this.setFlags(flags & ~View.CulledFlag);
          this.uncullChildren();
          this.onUncull();
          this.didUncull();
        } else {
          this.setFlags(flags & ~View.CulledFlag);
        }
      }
    }
    cascadeCull() {
      if ((this.flags & View.CullFlag) === 0) {
        if ((this.flags & View.CulledFlag) === 0) {
          this.willCull();
          this.setFlags(this.flags | View.CullFlag);
          this.onCull();
          this.cullChildren();
          this.didCull();
        } else {
          this.setFlags(this.flags | View.CullFlag);
        }
      }
    }
    willCull() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewWillCull !== void 0) {
          observer.viewWillCull(this);
        }
      }
    }
    onCull() {}
    didCull() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewDidCull !== void 0) {
          observer.viewDidCull(this);
        }
      }
    }
    cullChildren() {
      let child = this.firstChild;
      while (child !== null) {
        const next = child.nextSibling;
        child.cascadeCull();
        if (next !== null && next.parent !== this) {
          throw new Error("inconsistent cull");
        }
        child = next;
      }
    }
    cascadeUncull() {
      if ((this.flags & View.CullFlag) !== 0) {
        if ((this.flags & View.CulledFlag) === 0) {
          this.willUncull();
          this.setFlags(this.flags & ~View.CullFlag);
          this.uncullChildren();
          this.onUncull();
          this.didUncull();
        } else {
          this.setFlags(this.flags & ~View.CullFlag);
        }
      }
    }
    get uncullFlags() {
      return this.constructor.UncullFlags;
    }
    willUncull() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewWillUncull !== void 0) {
          observer.viewWillUncull(this);
        }
      }
    }
    onUncull() {
      this.requestUpdate(this, this.flags & View.UpdateMask, false);
      this.requireUpdate(this.uncullFlags);
      if (this.decoherent !== null && this.decoherent.length !== 0) {
        this.requireUpdate(View.NeedsChange | View.NeedsAnimate);
      }
      if (this.mood.inherited) {
        this.mood.decohere();
      }
      if (this.theme.inherited) {
        this.theme.decohere();
      }
    }
    didUncull() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewDidUncull !== void 0) {
          observer.viewDidUncull(this);
        }
      }
    }
    uncullChildren() {
      let child = this.firstChild;
      while (child !== null) {
        const next = child.nextSibling;
        child.cascadeUncull();
        if (next !== null && next.parent !== this) {
          throw new Error("inconsistent uncull");
        }
        child = next;
      }
    }
    get hidden() {
      return (this.flags & View.HiddenMask) !== 0;
    }
    setHidden(hidden) {
      const flags = this.flags;
      if (hidden && (flags & View.HiddenFlag) === 0) {
        this.setFlags(flags | View.HiddenFlag);
        if ((flags & View.HideFlag) === 0) {
          this.willHide();
          this.onHide();
          this.hideChildren();
          this.didHide();
        }
      } else if (!hidden && (flags & View.HiddenFlag) !== 0) {
        this.setFlags(flags & ~View.HiddenFlag);
        if ((flags & View.HideFlag) === 0) {
          this.willUnhide();
          this.unhideChildren();
          this.onUnhide();
          this.didUnhide();
        }
      }
    }
    cascadeHide() {
      if ((this.flags & View.HideFlag) === 0) {
        if ((this.flags & View.HiddenFlag) === 0) {
          this.willHide();
          this.setFlags(this.flags | View.HideFlag);
          this.onHide();
          this.hideChildren();
          this.didHide();
        } else {
          this.setFlags(this.flags | View.HideFlag);
        }
      }
    }
    willHide() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewWillHide !== void 0) {
          observer.viewWillHide(this);
        }
      }
    }
    onHide() {}
    didHide() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewDidHide !== void 0) {
          observer.viewDidHide(this);
        }
      }
    }
    hideChildren() {
      let child = this.firstChild;
      while (child !== null) {
        const next = child.nextSibling;
        child.cascadeHide();
        if (next !== null && next.parent !== this) {
          throw new Error("inconsistent hide");
        }
        child = next;
      }
    }
    cascadeUnhide() {
      if ((this.flags & View.HideFlag) !== 0) {
        if ((this.flags & View.HiddenFlag) === 0) {
          this.willUnhide();
          this.setFlags(this.flags & ~View.HideFlag);
          this.unhideChildren();
          this.onUnhide();
          this.didUnhide();
        } else {
          this.setFlags(this.flags & ~View.HideFlag);
        }
      }
    }
    get unhideFlags() {
      return this.constructor.UnhideFlags;
    }
    willUnhide() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewWillUnhide !== void 0) {
          observer.viewWillUnhide(this);
        }
      }
    }
    onUnhide() {
      this.requestUpdate(this, this.flags & View.UpdateMask, false);
      this.requireUpdate(this.uncullFlags);
    }
    didUnhide() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewDidUnhide !== void 0) {
          observer.viewDidUnhide(this);
        }
      }
    }
    unhideChildren() {
      let child = this.firstChild;
      while (child !== null) {
        const next = child.nextSibling;
        child.cascadeUnhide();
        if (next !== null && next.parent !== this) {
          throw new Error("inconsistent unhide");
        }
        child = next;
      }
    }
    get unbounded() {
      return (this.flags & View.UnboundedFlag) !== 0;
    }
    setUnbounded(unboundedFlag) {
      if (unboundedFlag !== ((this.flags & View.UnboundedFlag) !== 0)) {
        this.willSetUnbounded(unboundedFlag);
        if (unboundedFlag) {
          this.setFlags(this.flags | View.UnboundedFlag);
        } else {
          this.setFlags(this.flags & ~View.UnboundedFlag);
        }
        this.onSetUnbounded(unboundedFlag);
        this.didSetUnbounded(unboundedFlag);
      }
    }
    willSetUnbounded(unboundedFlag) {}
    onSetUnbounded(unboundedFlag) {}
    didSetUnbounded(unboundedFlag) {}
    get intangible() {
      return (this.flags & View.IntangibleFlag) !== 0;
    }
    setIntangible(intangible) {
      if (intangible !== ((this.flags & View.IntangibleFlag) !== 0)) {
        this.willSetIntangible(intangible);
        if (intangible) {
          this.setFlags(this.flags | View.IntangibleFlag);
        } else {
          this.setFlags(this.flags & ~View.IntangibleFlag);
        }
        this.onSetIntangible(intangible);
        this.didSetIntangible(intangible);
      }
    }
    willSetIntangible(intangible) {}
    onSetIntangible(intangible) {}
    didSetIntangible(intangible) {}
    requireUpdate(updateFlags, immediate = false) {
      const flags = this.flags;
      const deltaUpdateFlags = updateFlags & ~flags & View.UpdateMask;
      if (deltaUpdateFlags !== 0) {
        this.setFlags(flags | deltaUpdateFlags);
        this.requestUpdate(this, deltaUpdateFlags, immediate);
      }
    }
    needsUpdate(updateFlags, immediate) {
      return updateFlags;
    }
    requestUpdate(target, updateFlags, immediate) {
      if ((this.flags & View.CulledMask) !== View.CulledFlag) {
        updateFlags = this.needsUpdate(updateFlags, immediate);
        let deltaUpdateFlags = this.flags & ~updateFlags & View.UpdateMask;
        if ((updateFlags & View.ProcessMask) !== 0) {
          deltaUpdateFlags |= View.NeedsProcess;
        }
        if ((updateFlags & View.DisplayMask) !== 0) {
          deltaUpdateFlags |= View.NeedsDisplay;
        }
        if (deltaUpdateFlags !== 0 || immediate) {
          this.setFlags(this.flags | deltaUpdateFlags);
          const parent = this.parent;
          if (parent !== null) {
            parent.requestUpdate(target, updateFlags, immediate);
          } else if (this.mounted) {
            const displayService = this.displayProvider.service;
            if (displayService !== void 0 && displayService !== null) {
              displayService.requestUpdate(target, updateFlags, immediate);
            }
          }
        }
      }
    }
    get updating() {
      return (this.flags & View.UpdatingMask) !== 0;
    }
    get processing() {
      return (this.flags & View.ProcessingFlag) !== 0;
    }
    needsProcess(processFlags, viewContext) {
      return processFlags;
    }
    cascadeProcess(processFlags, baseViewContext) {
      const viewContext = this.extendViewContext(baseViewContext);
      const outerViewContext = ViewContext.current;
      try {
        ViewContext.current = viewContext;
        processFlags &= ~View.NeedsProcess;
        processFlags |= this.flags & View.UpdateMask;
        processFlags = this.needsProcess(processFlags, viewContext);
        if ((processFlags & View.ProcessMask) !== 0) {
          let cascadeFlags = processFlags;
          this.setFlags(this.flags & ~View.NeedsProcess | (View.ProcessingFlag | View.ContextualFlag));
          this.willProcess(cascadeFlags, viewContext);
          if (((this.flags | processFlags) & View.NeedsResize) !== 0) {
            cascadeFlags |= View.NeedsResize;
            this.setFlags(this.flags & ~View.NeedsResize);
            this.willResize(viewContext);
          }
          if (((this.flags | processFlags) & View.NeedsScroll) !== 0) {
            cascadeFlags |= View.NeedsScroll;
            this.setFlags(this.flags & ~View.NeedsScroll);
            this.willScroll(viewContext);
          }
          if (((this.flags | processFlags) & View.NeedsChange) !== 0) {
            cascadeFlags |= View.NeedsChange;
            this.setFlags(this.flags & ~View.NeedsChange);
            this.willChange(viewContext);
          }
          if (((this.flags | processFlags) & View.NeedsAnimate) !== 0) {
            cascadeFlags |= View.NeedsAnimate;
            this.setFlags(this.flags & ~View.NeedsAnimate);
            this.willAnimate(viewContext);
          }
          if (((this.flags | processFlags) & View.NeedsProject) !== 0) {
            cascadeFlags |= View.NeedsProject;
            this.setFlags(this.flags & ~View.NeedsProject);
            this.willProject(viewContext);
          }
          this.onProcess(cascadeFlags, viewContext);
          if ((cascadeFlags & View.NeedsResize) !== 0) {
            this.onResize(viewContext);
          }
          if ((cascadeFlags & View.NeedsScroll) !== 0) {
            this.onScroll(viewContext);
          }
          if ((cascadeFlags & View.NeedsChange) !== 0) {
            this.onChange(viewContext);
          }
          if ((cascadeFlags & View.NeedsAnimate) !== 0) {
            this.onAnimate(viewContext);
          }
          if ((cascadeFlags & View.NeedsProject) !== 0) {
            this.onProject(viewContext);
          }
          if ((cascadeFlags & View.ProcessMask) !== 0) {
            this.setFlags(this.flags & ~View.ContextualFlag);
            this.processChildren(cascadeFlags, viewContext, this.processChild);
            this.setFlags(this.flags | View.ContextualFlag);
          }
          if ((cascadeFlags & View.NeedsProject) !== 0) {
            this.didProject(viewContext);
          }
          if ((cascadeFlags & View.NeedsAnimate) !== 0) {
            this.didAnimate(viewContext);
          }
          if ((cascadeFlags & View.NeedsChange) !== 0) {
            this.didChange(viewContext);
          }
          if ((cascadeFlags & View.NeedsScroll) !== 0) {
            this.didScroll(viewContext);
          }
          if ((cascadeFlags & View.NeedsResize) !== 0) {
            this.didResize(viewContext);
          }
          this.didProcess(cascadeFlags, viewContext);
        }
      } finally {
        this.setFlags(this.flags & ~(View.ProcessingFlag | View.ContextualFlag));
        ViewContext.current = outerViewContext;
      }
    }
    willProcess(processFlags, viewContext) {}
    onProcess(processFlags, viewContext) {}
    didProcess(processFlags, viewContext) {}
    willResize(viewContext) {
      const observers = this.observerCache.viewWillResizeObservers;
      if (observers !== void 0) {
        for (let i = 0, n = observers.length; i < n; i += 1) {
          const observer = observers[i];
          observer.viewWillResize(viewContext, this);
        }
      }
      this.evaluateConstraintVariables();
    }
    onResize(viewContext) {}
    didResize(viewContext) {
      const observers = this.observerCache.viewDidResizeObservers;
      if (observers !== void 0) {
        for (let i = 0, n = observers.length; i < n; i += 1) {
          const observer = observers[i];
          observer.viewDidResize(viewContext, this);
        }
      }
    }
    willScroll(viewContext) {
      const observers = this.observerCache.viewWillScrollObservers;
      if (observers !== void 0) {
        for (let i = 0, n = observers.length; i < n; i += 1) {
          const observer = observers[i];
          observer.viewWillScroll(viewContext, this);
        }
      }
    }
    onScroll(viewContext) {}
    didScroll(viewContext) {
      const observers = this.observerCache.viewDidScrollObservers;
      if (observers !== void 0) {
        for (let i = 0, n = observers.length; i < n; i += 1) {
          const observer = observers[i];
          observer.viewDidScroll(viewContext, this);
        }
      }
    }
    willChange(viewContext) {
      const observers = this.observerCache.viewWillChangeObservers;
      if (observers !== void 0) {
        for (let i = 0, n = observers.length; i < n; i += 1) {
          const observer = observers[i];
          observer.viewWillChange(viewContext, this);
        }
      }
    }
    onChange(viewContext) {
      this.updateTheme();
      this.recohereFasteners(viewContext.updateTime);
    }
    didChange(viewContext) {
      const observers = this.observerCache.viewDidChangeObservers;
      if (observers !== void 0) {
        for (let i = 0, n = observers.length; i < n; i += 1) {
          const observer = observers[i];
          observer.viewDidChange(viewContext, this);
        }
      }
    }
    willAnimate(viewContext) {
      const observers = this.observerCache.viewWillAnimateObservers;
      if (observers !== void 0) {
        for (let i = 0, n = observers.length; i < n; i += 1) {
          const observer = observers[i];
          observer.viewWillAnimate(viewContext, this);
        }
      }
    }
    onAnimate(viewContext) {
      this.recohereAnimators(viewContext.updateTime);
    }
    didAnimate(viewContext) {
      const observers = this.observerCache.viewDidAnimateObservers;
      if (observers !== void 0) {
        for (let i = 0, n = observers.length; i < n; i += 1) {
          const observer = observers[i];
          observer.viewDidAnimate(viewContext, this);
        }
      }
    }
    willProject(viewContext) {
      const observers = this.observerCache.viewWillProjectObservers;
      if (observers !== void 0) {
        for (let i = 0; i < observers.length; i += 1) {
          const observer = observers[i];
          observer.viewWillProject(viewContext, this);
        }
      }
    }
    onProject(viewContext) {}
    didProject(viewContext) {
      const observers = this.observerCache.viewDidProjectObservers;
      if (observers !== void 0) {
        for (let i = 0; i < observers.length; i += 1) {
          const observer = observers[i];
          observer.viewDidProject(viewContext, this);
        }
      }
    }
    processChildren(processFlags, viewContext, processChild) {
      let child = this.firstChild;
      while (child !== null) {
        const next = child.nextSibling;
        processChild.call(this, child, processFlags, viewContext);
        if (next !== null && next.parent !== this) {
          throw new Error("inconsistent process pass");
        }
        child = next;
      }
    }
    processChild(child, processFlags, viewContext) {
      child.cascadeProcess(processFlags, viewContext);
    }
    get displaying() {
      return (this.flags & View.DisplayingFlag) !== 0;
    }
    needsDisplay(displayFlags, viewContext) {
      return displayFlags;
    }
    cascadeDisplay(displayFlags, baseViewContext) {
      const viewContext = this.extendViewContext(baseViewContext);
      const outerViewContext = ViewContext.current;
      try {
        ViewContext.current = viewContext;
        displayFlags &= ~View.NeedsDisplay;
        displayFlags |= this.flags & View.UpdateMask;
        displayFlags = this.needsDisplay(displayFlags, viewContext);
        if ((displayFlags & View.DisplayMask) !== 0) {
          let cascadeFlags = displayFlags;
          this.setFlags(this.flags & ~View.NeedsDisplay | (View.DisplayingFlag | View.ContextualFlag));
          this.willDisplay(cascadeFlags, viewContext);
          if (((this.flags | displayFlags) & View.NeedsLayout) !== 0) {
            cascadeFlags |= View.NeedsLayout;
            this.setFlags(this.flags & ~View.NeedsLayout);
            this.willLayout(viewContext);
          }
          if (((this.flags | displayFlags) & View.NeedsRender) !== 0) {
            cascadeFlags |= View.NeedsRender;
            this.setFlags(this.flags & ~View.NeedsRender);
            this.willRender(viewContext);
          }
          if (((this.flags | displayFlags) & View.NeedsRasterize) !== 0) {
            cascadeFlags |= View.NeedsRasterize;
            this.setFlags(this.flags & ~View.NeedsRasterize);
            this.willRasterize(viewContext);
          }
          if (((this.flags | displayFlags) & View.NeedsComposite) !== 0) {
            cascadeFlags |= View.NeedsComposite;
            this.setFlags(this.flags & ~View.NeedsComposite);
            this.willComposite(viewContext);
          }
          this.onDisplay(cascadeFlags, viewContext);
          if ((cascadeFlags & View.NeedsLayout) !== 0) {
            this.onLayout(viewContext);
          }
          if ((cascadeFlags & View.NeedsRender) !== 0) {
            this.onRender(viewContext);
          }
          if ((cascadeFlags & View.NeedsRasterize) !== 0) {
            this.onRasterize(viewContext);
          }
          if ((cascadeFlags & View.NeedsComposite) !== 0) {
            this.onComposite(viewContext);
          }
          if ((cascadeFlags & View.DisplayMask) !== 0 && !this.hidden && !this.culled) {
            this.setFlags(this.flags & ~View.ContextualFlag);
            this.displayChildren(cascadeFlags, viewContext, this.displayChild);
            this.setFlags(this.flags | View.ContextualFlag);
          }
          if ((cascadeFlags & View.NeedsComposite) !== 0) {
            this.didComposite(viewContext);
          }
          if ((cascadeFlags & View.NeedsRasterize) !== 0) {
            this.didRasterize(viewContext);
          }
          if ((cascadeFlags & View.NeedsRender) !== 0) {
            this.didRender(viewContext);
          }
          if ((cascadeFlags & View.NeedsLayout) !== 0) {
            this.didLayout(viewContext);
          }
          this.didDisplay(cascadeFlags, viewContext);
        }
      } finally {
        this.setFlags(this.flags & ~(View.DisplayingFlag | View.ContextualFlag));
        ViewContext.current = outerViewContext;
      }
    }
    willDisplay(displayFlags, viewContext) {}
    onDisplay(displayFlags, viewContext) {}
    didDisplay(displayFlags, viewContext) {}
    willLayout(viewContext) {
      const observers = this.observerCache.viewWillLayoutObservers;
      if (observers !== void 0) {
        for (let i = 0, n = observers.length; i < n; i += 1) {
          const observer = observers[i];
          observer.viewWillLayout(viewContext, this);
        }
      }
    }
    onLayout(viewContext) {}
    didLayout(viewContext) {
      const observers = this.observerCache.viewDidLayoutObservers;
      if (observers !== void 0) {
        for (let i = 0, n = observers.length; i < n; i += 1) {
          const observer = observers[i];
          observer.viewDidLayout(viewContext, this);
        }
      }
    }
    willRender(viewContext) {
      const observers = this.observerCache.viewWillRenderObservers;
      if (observers !== void 0) {
        for (let i = 0; i < observers.length; i += 1) {
          const observer = observers[i];
          observer.viewWillRender(viewContext, this);
        }
      }
    }
    onRender(viewContext) {}
    didRender(viewContext) {
      const observers = this.observerCache.viewDidRenderObservers;
      if (observers !== void 0) {
        for (let i = 0; i < observers.length; i += 1) {
          const observer = observers[i];
          observer.viewDidRender(viewContext, this);
        }
      }
    }
    willRasterize(viewContext) {
      const observers = this.observerCache.viewWillRasterizeObservers;
      if (observers !== void 0) {
        for (let i = 0; i < observers.length; i += 1) {
          const observer = observers[i];
          observer.viewWillRasterize(viewContext, this);
        }
      }
    }
    onRasterize(viewContext) {}
    didRasterize(viewContext) {
      const observers = this.observerCache.viewDidRasterizeObservers;
      if (observers !== void 0) {
        for (let i = 0; i < observers.length; i += 1) {
          const observer = observers[i];
          observer.viewDidRasterize(viewContext, this);
        }
      }
    }
    willComposite(viewContext) {
      const observers = this.observerCache.viewWillCompositeObservers;
      if (observers !== void 0) {
        for (let i = 0; i < observers.length; i += 1) {
          const observer = observers[i];
          observer.viewWillComposite(viewContext, this);
        }
      }
    }
    onComposite(viewContext) {}
    didComposite(viewContext) {
      const observers = this.observerCache.viewDidCompositeObservers;
      if (observers !== void 0) {
        for (let i = 0; i < observers.length; i += 1) {
          const observer = observers[i];
          observer.viewDidComposite(viewContext, this);
        }
      }
    }
    displayChildren(displayFlags, viewContext, displayChild) {
      let child = this.firstChild;
      while (child !== null) {
        const next = child.nextSibling;
        displayChild.call(this, child, displayFlags, viewContext);
        if (next !== null && next.parent !== this) {
          throw new Error("inconsistent display pass");
        }
        child = next;
      }
    }
    displayChild(child, displayFlags, viewContext) {
      child.cascadeDisplay(displayFlags, viewContext);
    }
    getLook(look, mood) {
      const theme = this.theme.value;
      let value;
      if (theme !== null) {
        if (mood === void 0 || mood === null) {
          mood = this.mood.value;
        }
        if (mood !== null) {
          value = theme.get(look, mood);
        }
      }
      return value;
    }
    getLookOr(look, mood, elseValue) {
      if (arguments.length === 2) {
        elseValue = mood;
        mood = null;
      }
      const theme = this.theme.value;
      let value;
      if (theme !== null) {
        if (mood === void 0 || mood === null) {
          mood = this.mood.value;
        }
        if (mood !== null) {
          value = theme.getOr(look, mood, elseValue);
        } else {
          value = elseValue;
        }
      } else {
        value = elseValue;
      }
      return value;
    }
    applyTheme(theme, mood, timing) {
      if (timing === void 0 || timing === true) {
        timing = theme.getOr(Look.timing, Mood.ambient, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      this.willApplyTheme(theme, mood, timing);
      this.onApplyTheme(theme, mood, timing);
      this.didApplyTheme(theme, mood, timing);
    }
    willApplyTheme(theme, mood, timing) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewWillApplyTheme !== void 0) {
          observer.viewWillApplyTheme(theme, mood, timing, this);
        }
      }
    }
    onApplyTheme(theme, mood, timing) {
      this.themeAnimators(theme, mood, timing);
    }
    didApplyTheme(theme, mood, timing) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewDidApplyTheme !== void 0) {
          observer.viewDidApplyTheme(theme, mood, timing, this);
        }
      }
    }
    themeAnimators(theme, mood, timing) {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        if (fastener instanceof ThemeAnimator) {
          fastener.applyTheme(theme, mood, timing);
        }
      }
    }
    modifyMood(feel, updates, timing) {
      if (this.moodModifier.hasAffinity(component.Affinity.Intrinsic)) {
        const oldMoodModifier = this.moodModifier.getValueOr(MoodMatrix.empty());
        const newMoodModifier = oldMoodModifier.updatedCol(feel, updates, true);
        if (!newMoodModifier.equals(oldMoodModifier)) {
          this.moodModifier.setValue(newMoodModifier, component.Affinity.Intrinsic);
          this.changeMood();
          if (timing !== void 0) {
            const theme = this.theme.value;
            const mood = this.mood.value;
            if (theme !== null && mood !== null) {
              if (timing === true) {
                timing = theme.getOr(Look.timing, mood, false);
              } else {
                timing = util.Timing.fromAny(timing);
              }
              this.applyTheme(theme, mood, timing);
            }
          } else {
            this.requireUpdate(View.NeedsChange);
          }
        }
      }
    }
    modifyTheme(feel, updates, timing) {
      if (this.themeModifier.hasAffinity(component.Affinity.Intrinsic)) {
        const oldThemeModifier = this.themeModifier.getValueOr(MoodMatrix.empty());
        const newThemeModifier = oldThemeModifier.updatedCol(feel, updates, true);
        if (!newThemeModifier.equals(oldThemeModifier)) {
          this.themeModifier.setValue(newThemeModifier, component.Affinity.Intrinsic);
          this.changeTheme();
          if (timing !== void 0) {
            const theme = this.theme.value;
            const mood = this.mood.value;
            if (theme !== null && mood !== null) {
              if (timing === true) {
                timing = theme.getOr(Look.timing, mood, false);
              } else {
                timing = util.Timing.fromAny(timing);
              }
              this.applyTheme(theme, mood, timing);
            }
          } else {
            this.requireUpdate(View.NeedsChange);
          }
        }
      }
    }
    changeMood() {
      const moodModifierProperty = this.getFastener("moodModifier", component.Property);
      if (moodModifierProperty !== null && this.mood.hasAffinity(component.Affinity.Intrinsic)) {
        const moodModifier = moodModifierProperty.value;
        if (moodModifier !== null) {
          let superMood = this.mood.superValue;
          if (superMood === void 0 || superMood === null) {
            const themeService = this.themeProvider.service;
            if (themeService !== void 0 && themeService !== null) {
              superMood = themeService.mood;
            }
          }
          if (superMood !== void 0 && superMood !== null) {
            const mood = moodModifier.timesCol(superMood, true);
            this.mood.setValue(mood, component.Affinity.Intrinsic);
          }
        } else {
          this.mood.setAffinity(component.Affinity.Inherited);
        }
      }
    }
    changeTheme() {
      const themeModifierProperty = this.getFastener("themeModifier", component.Property);
      if (themeModifierProperty !== null && this.theme.hasAffinity(component.Affinity.Intrinsic)) {
        const themeModifier = themeModifierProperty.value;
        if (themeModifier !== null) {
          let superTheme = this.theme.superValue;
          if (superTheme === void 0 || superTheme === null) {
            const themeService = this.themeProvider.service;
            if (themeService !== void 0 && themeService !== null) {
              superTheme = themeService.theme;
            }
          }
          if (superTheme !== void 0 && superTheme !== null) {
            const theme = superTheme.transform(themeModifier, true);
            this.theme.setValue(theme, component.Affinity.Intrinsic);
          }
        } else {
          this.theme.setAffinity(component.Affinity.Inherited);
        }
      }
    }
    updateTheme(timing) {
      this.changeMood();
      this.changeTheme();
      const theme = this.theme.value;
      const mood = this.mood.value;
      if (theme !== null && mood !== null) {
        this.applyTheme(theme, mood, timing);
      }
    }
    mountTheme() {}
    bindChildFastener(fastener, child, target) {
      super.bindChildFastener(fastener, child, target);
      if (fastener instanceof ViewRelation || fastener instanceof Gesture) {
        fastener.bindView(child, target);
      }
    }
    unbindChildFastener(fastener, child) {
      if (fastener instanceof ViewRelation || fastener instanceof Gesture) {
        fastener.unbindView(child);
      }
      super.unbindChildFastener(fastener, child);
    }
    decohereFastener(fastener) {
      super.decohereFastener(fastener);
      if (fastener instanceof component.Animator) {
        this.requireUpdate(View.NeedsAnimate);
      } else {
        this.requireUpdate(View.NeedsChange);
      }
    }
    recohereFasteners(t) {
      const decoherent = this.decoherent;
      if (decoherent !== null) {
        const decoherentCount = decoherent.length;
        if (decoherentCount !== 0) {
          if (t === void 0) {
            t = performance.now();
          }
          this.decoherent = null;
          for (let i = 0; i < decoherentCount; i += 1) {
            const fastener = decoherent[i];
            if (!(fastener instanceof component.Animator)) {
              fastener.recohere(t);
            } else {
              this.decohereFastener(fastener);
            }
          }
        }
      }
    }
    recohereAnimators(t) {
      const decoherent = this.decoherent;
      if (decoherent !== null) {
        const decoherentCount = decoherent.length;
        if (decoherentCount !== 0) {
          this.decoherent = null;
          for (let i = 0; i < decoherentCount; i += 1) {
            const fastener = decoherent[i];
            if (fastener instanceof component.Animator) {
              fastener.recohere(t);
            } else {
              this.decohereFastener(fastener);
            }
          }
        }
      }
    }
    constraint(lhs, relation, rhs, strength) {
      lhs = constraint.ConstraintExpression.fromAny(lhs);
      if (rhs !== void 0) {
        rhs = constraint.ConstraintExpression.fromAny(rhs);
      }
      const expression = rhs !== void 0 ? lhs.minus(rhs) : lhs;
      if (strength === void 0) {
        strength = constraint.ConstraintStrength.Required;
      } else {
        strength = constraint.ConstraintStrength.fromAny(strength);
      }
      const constraint$1 = new constraint.Constraint(this, expression, relation, strength);
      this.addConstraint(constraint$1);
      return constraint$1;
    }
    hasConstraint(constraint) {
      return this.constraints.indexOf(constraint) >= 0;
    }
    addConstraint(constraint) {
      const oldConstraints = this.constraints;
      const newConstraints = util.Arrays.inserted(constraint, oldConstraints);
      if (oldConstraints !== newConstraints) {
        this.constraints = newConstraints;
        this.activateConstraint(constraint);
      }
    }
    removeConstraint(constraint) {
      const oldConstraints = this.constraints;
      const newConstraints = util.Arrays.removed(constraint, oldConstraints);
      if (oldConstraints !== newConstraints) {
        this.deactivateConstraint(constraint);
        this.constraints = newConstraints;
      }
    }
    activateConstraint(constraint) {
      const layoutService = this.layoutProvider.service;
      if (layoutService !== void 0 && layoutService !== null) {
        layoutService.activateConstraint(constraint);
        this.requireUpdate(View.NeedsLayout);
      }
    }
    deactivateConstraint(constraint) {
      const layoutService = this.layoutProvider.service;
      if (layoutService !== void 0 && layoutService !== null) {
        layoutService.deactivateConstraint(constraint);
        this.requireUpdate(View.NeedsLayout);
      }
    }
    constraintVariable(name, value, strength) {
      if (value === void 0) {
        value = 0;
      }
      if (strength !== void 0) {
        strength = constraint.ConstraintStrength.fromAny(strength);
      } else {
        strength = constraint.ConstraintStrength.Strong;
      }
      const property = constraint.ConstraintProperty.create(this);
      Object.defineProperty(property, "name", {
        value: name,
        configurable: true
      });
      if (value !== void 0) {
        property.setValue(value);
      }
      property.setStrength(strength);
      property.mount();
      return property;
    }
    hasConstraintVariable(constraintVariable) {
      return this.constraintVariables.indexOf(constraintVariable) >= 0;
    }
    addConstraintVariable(constraintVariable) {
      const oldConstraintVariables = this.constraintVariables;
      const newConstraintVariables = util.Arrays.inserted(constraintVariable, oldConstraintVariables);
      if (oldConstraintVariables !== newConstraintVariables) {
        this.constraintVariables = newConstraintVariables;
        this.activateConstraintVariable(constraintVariable);
      }
    }
    removeConstraintVariable(constraintVariable) {
      const oldConstraintVariables = this.constraintVariables;
      const newConstraintVariables = util.Arrays.removed(constraintVariable, oldConstraintVariables);
      if (oldConstraintVariables !== newConstraintVariables) {
        this.deactivateConstraintVariable(constraintVariable);
        this.constraintVariables = newConstraintVariables;
      }
    }
    activateConstraintVariable(constraintVariable) {
      const layoutService = this.layoutProvider.service;
      if (layoutService !== void 0 && layoutService !== null) {
        layoutService.activateConstraintVariable(constraintVariable);
        this.requireUpdate(View.NeedsLayout);
      }
    }
    deactivateConstraintVariable(constraintVariable) {
      const layoutService = this.layoutProvider.service;
      if (layoutService !== void 0 && layoutService !== null) {
        layoutService.deactivateConstraintVariable(constraintVariable);
        this.requireUpdate(View.NeedsLayout);
      }
    }
    setConstraintVariable(constraintVariable, value) {
      const layoutService = this.layoutProvider.service;
      if (layoutService !== void 0 && layoutService !== null) {
        layoutService.setConstraintVariable(constraintVariable, value);
      }
    }
    evaluateConstraintVariables() {
      const constraintVariables = this.constraintVariables;
      for (let i = 0, n = constraintVariables.length; i < n; i += 1) {
        const constraintVariable = constraintVariables[i];
        constraintVariable.evaluateConstraintVariable();
      }
    }
    activateLayout() {
      const layoutService = this.layoutProvider.service;
      if (layoutService !== void 0 && layoutService !== null) {
        const constraints = this.constraints;
        for (let i = 0, n = constraints.length; i < n; i += 1) {
          layoutService.activateConstraint(constraints[i]);
        }
      }
    }
    deactivateLayout() {
      const layoutService = this.layoutProvider.service;
      if (layoutService !== void 0 && layoutService !== null) {
        const constraints = this.constraints;
        for (let i = 0, n = constraints.length; i < n; i += 1) {
          layoutService.deactivateConstraint(constraints[i]);
        }
      }
    }
    setProperty(key, value, timing, affinity) {
      const property = this.getLazyFastener(key, component.Property);
      if (property !== null) {
        if (property instanceof component.Animator) {
          property.setState(value, timing, affinity);
        } else {
          property.setValue(value, affinity);
        }
      }
    }
    setProperties(properties, timing, affinity) {
      if (typeof timing === "number") {
        affinity = timing;
        timing = void 0;
      }
      for (const key in properties) {
        const value = properties[key];
        this.setProperty(key, value, timing, affinity);
      }
    }
    get superViewContext() {
      const parent = this.parent;
      if (parent !== null) {
        return parent.viewContext;
      } else {
        const viewContext = this.viewportProvider.viewContext;
        return this.displayProvider.updatedViewContext(viewContext);
      }
    }
    extendViewContext(viewContext) {
      return viewContext;
    }
    get viewContext() {
      if ((this.flags & View.ContextualFlag) !== 0) {
        return ViewContext.current;
      } else {
        return this.extendViewContext(this.superViewContext);
      }
    }
    get viewportIdiom() {
      return this.viewContext.viewportIdiom;
    }
    get viewport() {
      return this.viewContext.viewport;
    }
    get parentTransform() {
      return math.Transform.identity();
    }
    get pageTransform() {
      const parent = this.parent;
      if (parent !== null) {
        return parent.pageTransform.transform(this.parentTransform);
      } else {
        return math.Transform.identity();
      }
    }
    get pageBounds() {
      const clientBounds = this.clientBounds;
      const clientTransform = this.clientTransform;
      return clientBounds.transform(clientTransform);
    }
    get popoverFrame() {
      return this.pageBounds;
    }
    get clientTransform() {
      let clientTransform;
      const scrollX = window.pageXOffset;
      const scrollY = window.pageYOffset;
      if (scrollX !== 0 || scrollY !== 0) {
        clientTransform = math.Transform.translate(scrollX, scrollY);
      } else {
        clientTransform = math.Transform.identity();
      }
      const pageTransform = this.pageTransform;
      return clientTransform.transform(pageTransform);
    }
    get clientBounds() {
      const viewport = this.viewport;
      return new math.R2Box(0, 0, viewport.width, viewport.height);
    }
    intersectsViewport() {
      const bounds = this.clientBounds;
      const viewportWidth = document.documentElement.clientWidth;
      const viewportHeight = document.documentElement.clientHeight;
      return (bounds.top <= 0 && 0 < bounds.bottom || 0 <= bounds.top && bounds.top < viewportHeight) && (bounds.left <= 0 && 0 < bounds.right || 0 <= bounds.left && bounds.left < viewportWidth);
    }
    dispatchEvent(event) {
      return true;
    }
    on(type, listener, options) {
      return this;
    }
    off(type, listener, options) {
      return this;
    }
    onObserve(observer) {
      super.onObserve(observer);
      if (observer.viewWillInsertChild !== void 0) {
        this.observerCache.viewWillInsertChildObservers = util.Arrays.inserted(observer, this.observerCache.viewWillInsertChildObservers);
      }
      if (observer.viewDidInsertChild !== void 0) {
        this.observerCache.viewDidInsertChildObservers = util.Arrays.inserted(observer, this.observerCache.viewDidInsertChildObservers);
      }
      if (observer.viewWillRemoveChild !== void 0) {
        this.observerCache.viewWillRemoveChildObservers = util.Arrays.inserted(observer, this.observerCache.viewWillRemoveChildObservers);
      }
      if (observer.viewDidRemoveChild !== void 0) {
        this.observerCache.viewDidRemoveChildObservers = util.Arrays.inserted(observer, this.observerCache.viewDidRemoveChildObservers);
      }
      if (observer.viewWillResize !== void 0) {
        this.observerCache.viewWillResizeObservers = util.Arrays.inserted(observer, this.observerCache.viewWillResizeObservers);
      }
      if (observer.viewDidResize !== void 0) {
        this.observerCache.viewDidResizeObservers = util.Arrays.inserted(observer, this.observerCache.viewDidResizeObservers);
      }
      if (observer.viewWillScroll !== void 0) {
        this.observerCache.viewWillScrollObservers = util.Arrays.inserted(observer, this.observerCache.viewWillScrollObservers);
      }
      if (observer.viewDidScroll !== void 0) {
        this.observerCache.viewDidScrollObservers = util.Arrays.inserted(observer, this.observerCache.viewDidScrollObservers);
      }
      if (observer.viewWillChange !== void 0) {
        this.observerCache.viewWillChangeObservers = util.Arrays.inserted(observer, this.observerCache.viewWillChangeObservers);
      }
      if (observer.viewDidChange !== void 0) {
        this.observerCache.viewDidChangeObservers = util.Arrays.inserted(observer, this.observerCache.viewDidChangeObservers);
      }
      if (observer.viewWillAnimate !== void 0) {
        this.observerCache.viewWillAnimateObservers = util.Arrays.inserted(observer, this.observerCache.viewWillAnimateObservers);
      }
      if (observer.viewDidAnimate !== void 0) {
        this.observerCache.viewDidAnimateObservers = util.Arrays.inserted(observer, this.observerCache.viewDidAnimateObservers);
      }
      if (observer.viewWillProject !== void 0) {
        this.observerCache.viewWillProjectObservers = util.Arrays.inserted(observer, this.observerCache.viewWillProjectObservers);
      }
      if (observer.viewDidProject !== void 0) {
        this.observerCache.viewDidProjectObservers = util.Arrays.inserted(observer, this.observerCache.viewDidProjectObservers);
      }
      if (observer.viewWillLayout !== void 0) {
        this.observerCache.viewWillLayoutObservers = util.Arrays.inserted(observer, this.observerCache.viewWillLayoutObservers);
      }
      if (observer.viewDidLayout !== void 0) {
        this.observerCache.viewDidLayoutObservers = util.Arrays.inserted(observer, this.observerCache.viewDidLayoutObservers);
      }
      if (observer.viewWillRender !== void 0) {
        this.observerCache.viewWillRenderObservers = util.Arrays.inserted(observer, this.observerCache.viewWillRenderObservers);
      }
      if (observer.viewDidRender !== void 0) {
        this.observerCache.viewDidRenderObservers = util.Arrays.inserted(observer, this.observerCache.viewDidRenderObservers);
      }
      if (observer.viewWillRasterize !== void 0) {
        this.observerCache.viewWillRasterizeObservers = util.Arrays.inserted(observer, this.observerCache.viewWillRasterizeObservers);
      }
      if (observer.viewDidRasterize !== void 0) {
        this.observerCache.viewDidRasterizeObservers = util.Arrays.inserted(observer, this.observerCache.viewDidRasterizeObservers);
      }
      if (observer.viewWillComposite !== void 0) {
        this.observerCache.viewWillCompositeObservers = util.Arrays.inserted(observer, this.observerCache.viewWillCompositeObservers);
      }
      if (observer.viewDidComposite !== void 0) {
        this.observerCache.viewDidCompositeObservers = util.Arrays.inserted(observer, this.observerCache.viewDidCompositeObservers);
      }
    }
    onUnobserve(observer) {
      super.onUnobserve(observer);
      if (observer.viewWillInsertChild !== void 0) {
        this.observerCache.viewWillInsertChildObservers = util.Arrays.removed(observer, this.observerCache.viewWillInsertChildObservers);
      }
      if (observer.viewDidInsertChild !== void 0) {
        this.observerCache.viewDidInsertChildObservers = util.Arrays.removed(observer, this.observerCache.viewDidInsertChildObservers);
      }
      if (observer.viewWillRemoveChild !== void 0) {
        this.observerCache.viewWillRemoveChildObservers = util.Arrays.removed(observer, this.observerCache.viewWillRemoveChildObservers);
      }
      if (observer.viewDidRemoveChild !== void 0) {
        this.observerCache.viewDidRemoveChildObservers = util.Arrays.removed(observer, this.observerCache.viewDidRemoveChildObservers);
      }
      if (observer.viewWillResize !== void 0) {
        this.observerCache.viewWillResizeObservers = util.Arrays.removed(observer, this.observerCache.viewWillResizeObservers);
      }
      if (observer.viewDidResize !== void 0) {
        this.observerCache.viewDidResizeObservers = util.Arrays.removed(observer, this.observerCache.viewDidResizeObservers);
      }
      if (observer.viewWillScroll !== void 0) {
        this.observerCache.viewWillScrollObservers = util.Arrays.removed(observer, this.observerCache.viewWillScrollObservers);
      }
      if (observer.viewDidScroll !== void 0) {
        this.observerCache.viewDidScrollObservers = util.Arrays.removed(observer, this.observerCache.viewDidScrollObservers);
      }
      if (observer.viewWillChange !== void 0) {
        this.observerCache.viewWillChangeObservers = util.Arrays.removed(observer, this.observerCache.viewWillChangeObservers);
      }
      if (observer.viewDidChange !== void 0) {
        this.observerCache.viewDidChangeObservers = util.Arrays.removed(observer, this.observerCache.viewDidChangeObservers);
      }
      if (observer.viewWillAnimate !== void 0) {
        this.observerCache.viewWillAnimateObservers = util.Arrays.removed(observer, this.observerCache.viewWillAnimateObservers);
      }
      if (observer.viewDidAnimate !== void 0) {
        this.observerCache.viewDidAnimateObservers = util.Arrays.removed(observer, this.observerCache.viewDidAnimateObservers);
      }
      if (observer.viewWillProject !== void 0) {
        this.observerCache.viewWillProjectObservers = util.Arrays.removed(observer, this.observerCache.viewWillProjectObservers);
      }
      if (observer.viewDidProject !== void 0) {
        this.observerCache.viewDidProjectObservers = util.Arrays.removed(observer, this.observerCache.viewDidProjectObservers);
      }
      if (observer.viewWillLayout !== void 0) {
        this.observerCache.viewWillLayoutObservers = util.Arrays.removed(observer, this.observerCache.viewWillLayoutObservers);
      }
      if (observer.viewDidLayout !== void 0) {
        this.observerCache.viewDidLayoutObservers = util.Arrays.removed(observer, this.observerCache.viewDidLayoutObservers);
      }
      if (observer.viewWillRender !== void 0) {
        this.observerCache.viewWillRenderObservers = util.Arrays.removed(observer, this.observerCache.viewWillRenderObservers);
      }
      if (observer.viewDidRender !== void 0) {
        this.observerCache.viewDidRenderObservers = util.Arrays.removed(observer, this.observerCache.viewDidRenderObservers);
      }
      if (observer.viewWillRasterize !== void 0) {
        this.observerCache.viewWillRasterizeObservers = util.Arrays.removed(observer, this.observerCache.viewWillRasterizeObservers);
      }
      if (observer.viewDidRasterize !== void 0) {
        this.observerCache.viewDidRasterizeObservers = util.Arrays.removed(observer, this.observerCache.viewDidRasterizeObservers);
      }
      if (observer.viewWillComposite !== void 0) {
        this.observerCache.viewWillCompositeObservers = util.Arrays.removed(observer, this.observerCache.viewWillCompositeObservers);
      }
      if (observer.viewDidComposite !== void 0) {
        this.observerCache.viewDidCompositeObservers = util.Arrays.removed(observer, this.observerCache.viewDidCompositeObservers);
      }
    }
    init(init) {
      if (init.mood !== void 0) {
        this.mood(init.mood);
      }
      if (init.moodModifier !== void 0) {
        this.moodModifier(init.moodModifier);
      }
      if (init.theme !== void 0) {
        this.theme(init.theme);
      }
      if (init.themeModifier !== void 0) {
        this.themeModifier(init.themeModifier);
      }
    }
    static create() {
      return new this;
    }
    static fromInit(init) {
      let type;
      if ((typeof init === "object" && init !== null || typeof init === "function") && util.Creatable.is(init.type)) {
        type = init.type;
      } else {
        type = this;
      }
      const view = type.create();
      view.init(init);
      return view;
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return value;
      } else if (value instanceof View) {
        if (value instanceof this) {
          return value;
        } else {
          throw new TypeError(value + " not an instance of " + this);
        }
      } else if (util.Creatable.is(value)) {
        return value.create();
      } else {
        return this.fromInit(value);
      }
    }
  }
  View.uid = function() {
    let nextId = 1;
    return function uid() {
      const id = ~~nextId;
      nextId += 1;
      return id;
    };
  }();
  View.MountedFlag = component.Component.MountedFlag;
  View.RemovingFlag = component.Component.RemovingFlag;
  View.ProcessingFlag = 1 << component.Component.FlagShift + 0;
  View.DisplayingFlag = 1 << component.Component.FlagShift + 1;
  View.ContextualFlag = 1 << component.Component.FlagShift + 2;
  View.CullFlag = 1 << component.Component.FlagShift + 3;
  View.CulledFlag = 1 << component.Component.FlagShift + 4;
  View.HideFlag = 1 << component.Component.FlagShift + 5;
  View.HiddenFlag = 1 << component.Component.FlagShift + 6;
  View.UnboundedFlag = 1 << component.Component.FlagShift + 7;
  View.IntangibleFlag = 1 << component.Component.FlagShift + 8;
  View.CulledMask = View.CullFlag | View.CulledFlag;
  View.HiddenMask = View.HideFlag | View.HiddenFlag;
  View.UpdatingMask = View.ProcessingFlag | View.DisplayingFlag;
  View.StatusMask = View.MountedFlag | View.RemovingFlag | View.ProcessingFlag | View.DisplayingFlag | View.ContextualFlag | View.CullFlag | View.CulledFlag | View.HiddenFlag | View.UnboundedFlag | View.IntangibleFlag;
  View.NeedsProcess = 1 << component.Component.FlagShift + 9;
  View.NeedsResize = 1 << component.Component.FlagShift + 10;
  View.NeedsScroll = 1 << component.Component.FlagShift + 11;
  View.NeedsChange = 1 << component.Component.FlagShift + 12;
  View.NeedsAnimate = 1 << component.Component.FlagShift + 13;
  View.NeedsProject = 1 << component.Component.FlagShift + 14;
  View.ProcessMask = View.NeedsProcess | View.NeedsResize | View.NeedsScroll | View.NeedsChange | View.NeedsAnimate | View.NeedsProject;
  View.NeedsDisplay = 1 << component.Component.FlagShift + 15;
  View.NeedsLayout = 1 << component.Component.FlagShift + 16;
  View.NeedsRender = 1 << component.Component.FlagShift + 17;
  View.NeedsRasterize = 1 << component.Component.FlagShift + 18;
  View.NeedsComposite = 1 << component.Component.FlagShift + 19;
  View.DisplayMask = View.NeedsDisplay | View.NeedsLayout | View.NeedsRender | View.NeedsRasterize | View.NeedsComposite;
  View.UpdateMask = View.ProcessMask | View.DisplayMask;
  View.FlagShift = component.Component.FlagShift + 20;
  View.FlagMask = (1 << View.FlagShift) - 1;
  View.MountFlags = component.Component.MountFlags | View.NeedsResize | View.NeedsChange | View.NeedsLayout;
  View.UncullFlags = View.NeedsResize | View.NeedsChange | View.NeedsLayout;
  View.UnhideFlags = View.NeedsLayout;
  View.InsertChildFlags = component.Component.InsertChildFlags | View.NeedsLayout;
  View.RemoveChildFlags = component.Component.RemoveChildFlags | View.NeedsLayout;
  __decorate([ component.Provider({
    extends: ViewportProvider,
    type: ViewportService,
    observes: false,
    service: ViewportService.global()
  }) ], View.prototype, "viewportProvider", void 0);
  __decorate([ component.Provider({
    extends: DisplayProvider,
    type: DisplayService,
    observes: false,
    service: DisplayService.global()
  }) ], View.prototype, "displayProvider", void 0);
  __decorate([ component.Provider({
    extends: LayoutProvider,
    type: LayoutService,
    observes: false,
    service: LayoutService.global()
  }) ], View.prototype, "layoutProvider", void 0);
  __decorate([ component.Provider({
    extends: ThemeProvider,
    type: ThemeService,
    observes: false,
    service: ThemeService.global()
  }) ], View.prototype, "themeProvider", void 0);
  __decorate([ component.Provider({
    extends: ModalProvider,
    type: ModalService,
    observes: false,
    service: ModalService.global()
  }) ], View.prototype, "modalProvider", void 0);
  __decorate([ component.Property({
    type: MoodVector,
    value: null,
    inherits: true
  }) ], View.prototype, "mood", void 0);
  __decorate([ component.Property({
    type: ThemeMatrix,
    value: null,
    inherits: true
  }) ], View.prototype, "theme", void 0);
  __decorate([ component.Property({
    type: MoodMatrix,
    value: null
  }) ], View.prototype, "moodModifier", void 0);
  __decorate([ component.Property({
    type: MoodMatrix,
    value: null
  }) ], View.prototype, "themeModifier", void 0);
  const ViewRelation = function(_super) {
    const ViewRelation = _super.extend("ViewRelation");
    Object.defineProperty(ViewRelation.prototype, "fastenerType", {
      get: function() {
        return ViewRelation;
      },
      configurable: true
    });
    ViewRelation.prototype.initView = function(view) {};
    ViewRelation.prototype.willAttachView = function(view, target) {};
    ViewRelation.prototype.onAttachView = function(view, target) {
      if (this.observes === true) {
        view.observe(this);
      }
    };
    ViewRelation.prototype.didAttachView = function(view, target) {};
    ViewRelation.prototype.deinitView = function(view) {};
    ViewRelation.prototype.willDetachView = function(view) {};
    ViewRelation.prototype.onDetachView = function(view) {
      if (this.observes === true) {
        view.unobserve(this);
      }
    };
    ViewRelation.prototype.didDetachView = function(view) {};
    Object.defineProperty(ViewRelation.prototype, "parentView", {
      get() {
        const owner = this.owner;
        return owner instanceof View ? owner : null;
      },
      configurable: true
    });
    ViewRelation.prototype.insertChild = function(parent, child, target, key) {
      parent.insertChild(child, target, key);
    };
    ViewRelation.prototype.bindView = function(view, target) {};
    ViewRelation.prototype.unbindView = function(view) {};
    ViewRelation.prototype.detectView = function(view) {
      return null;
    };
    ViewRelation.prototype.createView = function() {
      let view;
      const type = this.type;
      if (type !== void 0) {
        view = type.create();
      }
      if (view === void 0 || view === null) {
        let message = "Unable to create ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "view";
        throw new Error(message);
      }
      return view;
    };
    ViewRelation.prototype.fromAny = function(value) {
      const type = this.type;
      if (type !== void 0) {
        return type.fromAny(value);
      } else {
        return View.fromAny(value);
      }
    };
    Object.defineProperty(ViewRelation.prototype, "lazy", {
      get: function() {
        return false;
      },
      configurable: true
    });
    Object.defineProperty(ViewRelation.prototype, "static", {
      get: function() {
        return true;
      },
      configurable: true
    });
    ViewRelation.construct = function(fastenerClass, fastener, owner) {
      fastener = _super.construct(fastenerClass, fastener, owner);
      return fastener;
    };
    ViewRelation.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        return fastener;
      };
      return fastenerClass;
    };
    return ViewRelation;
  }(component.Fastener);
  const ViewRef = function(_super) {
    const ViewRef = _super.extend("ViewRef");
    Object.defineProperty(ViewRef.prototype, "fastenerType", {
      get: function() {
        return ViewRef;
      },
      configurable: true
    });
    ViewRef.prototype.onInherit = function(superFastener) {
      this.setView(superFastener.view);
    };
    ViewRef.prototype.getView = function() {
      const view = this.view;
      if (view === null) {
        let message = view + " ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "view";
        throw new TypeError(message);
      }
      return view;
    };
    ViewRef.prototype.setView = function(newView, target, key) {
      if (newView !== null) {
        newView = this.fromAny(newView);
      }
      let oldView = this.view;
      if (oldView !== newView) {
        if (target === void 0) {
          target = null;
        }
        let parent;
        if (this.binds && (parent = this.parentView, parent !== null)) {
          if (oldView !== null && oldView.parent === parent) {
            if (target === null) {
              target = oldView.nextSibling;
            }
            oldView.remove();
          }
          if (newView !== null) {
            if (key === void 0) {
              key = this.key;
            }
            this.insertChild(parent, newView, target, key);
          }
          oldView = this.view;
        }
        if (oldView !== newView) {
          if (oldView !== null) {
            this.deactivateLayout();
            this.willDetachView(oldView);
            this.view = null;
            this.onDetachView(oldView);
            this.deinitView(oldView);
            this.didDetachView(oldView);
          }
          if (newView !== null) {
            this.willAttachView(newView, target);
            this.view = newView;
            this.onAttachView(newView, target);
            this.initView(newView);
            this.didAttachView(newView, target);
          }
        }
      }
      return oldView;
    };
    ViewRef.prototype.attachView = function(newView, target) {
      const oldView = this.view;
      if (newView !== void 0 && newView !== null) {
        newView = this.fromAny(newView);
      } else if (oldView === null) {
        newView = this.createView();
      } else {
        newView = oldView;
      }
      if (newView !== oldView) {
        if (target === void 0) {
          target = null;
        }
        if (oldView !== null) {
          this.deactivateLayout();
          this.willDetachView(oldView);
          this.view = null;
          this.onDetachView(oldView);
          this.deinitView(oldView);
          this.didDetachView(oldView);
        }
        this.willAttachView(newView, target);
        this.view = newView;
        this.onAttachView(newView, target);
        this.initView(newView);
        this.didAttachView(newView, target);
      }
      return newView;
    };
    ViewRef.prototype.detachView = function() {
      const oldView = this.view;
      if (oldView !== null) {
        this.deactivateLayout();
        this.willDetachView(oldView);
        this.view = null;
        this.onDetachView(oldView);
        this.deinitView(oldView);
        this.didDetachView(oldView);
      }
      return oldView;
    };
    ViewRef.prototype.insertView = function(parent, newView, target, key) {
      if (newView !== void 0 && newView !== null) {
        newView = this.fromAny(newView);
      } else {
        const oldView = this.view;
        if (oldView === null) {
          newView = this.createView();
        } else {
          newView = oldView;
        }
      }
      if (parent === void 0 || parent === null) {
        parent = this.parentView;
      }
      if (target === void 0) {
        target = null;
      }
      if (key === void 0) {
        key = this.key;
      }
      if (parent !== null && (newView.parent !== parent || newView.key !== key)) {
        this.insertChild(parent, newView, target, key);
      }
      const oldView = this.view;
      if (newView !== oldView) {
        if (oldView !== null) {
          this.deactivateLayout();
          this.willDetachView(oldView);
          this.view = null;
          this.onDetachView(oldView);
          this.deinitView(oldView);
          this.didDetachView(oldView);
          oldView.remove();
        }
        this.willAttachView(newView, target);
        this.view = newView;
        this.onAttachView(newView, target);
        this.initView(newView);
        this.didAttachView(newView, target);
      }
      return newView;
    };
    ViewRef.prototype.removeView = function() {
      const view = this.view;
      if (view !== null) {
        view.remove();
      }
      return view;
    };
    ViewRef.prototype.deleteView = function() {
      const view = this.detachView();
      if (view !== null) {
        view.remove();
      }
      return view;
    };
    ViewRef.prototype.bindView = function(view, target) {
      if (this.binds && this.view === null) {
        const newView = this.detectView(view);
        if (newView !== null) {
          this.willAttachView(newView, target);
          this.view = newView;
          this.onAttachView(newView, target);
          this.initView(newView);
          this.didAttachView(newView, target);
        }
      }
    };
    ViewRef.prototype.unbindView = function(view) {
      if (this.binds) {
        const oldView = this.detectView(view);
        if (oldView !== null && this.view === oldView) {
          this.deactivateLayout();
          this.willDetachView(oldView);
          this.view = null;
          this.onDetachView(oldView);
          this.deinitView(oldView);
          this.didDetachView(oldView);
        }
      }
    };
    ViewRef.prototype.detectView = function(view) {
      const key = this.key;
      if (key !== void 0 && key === view.key) {
        return view;
      }
      return null;
    };
    ViewRef.prototype.constraint = function(lhs, relation, rhs, strength) {
      lhs = constraint.ConstraintExpression.fromAny(lhs);
      if (rhs !== void 0) {
        rhs = constraint.ConstraintExpression.fromAny(rhs);
      }
      const expression = rhs !== void 0 ? lhs.minus(rhs) : lhs;
      if (strength === void 0) {
        strength = constraint.ConstraintStrength.Required;
      } else {
        strength = constraint.ConstraintStrength.fromAny(strength);
      }
      const constraint$1 = new constraint.Constraint(this.owner, expression, relation, strength);
      this.addConstraint(constraint$1);
      return constraint$1;
    };
    ViewRef.prototype.hasConstraint = function(constraint) {
      return this.constraints.indexOf(constraint) >= 0;
    };
    ViewRef.prototype.addConstraint = function(constraint) {
      const oldConstraints = this.constraints;
      const newConstraints = util.Arrays.inserted(constraint, oldConstraints);
      if (oldConstraints !== newConstraints) {
        this.constraints = newConstraints;
        this.activateConstraint(constraint);
      }
    };
    ViewRef.prototype.removeConstraint = function(constraint) {
      const oldConstraints = this.constraints;
      const newConstraints = util.Arrays.removed(constraint, oldConstraints);
      if (oldConstraints !== newConstraints) {
        this.deactivateConstraint(constraint);
        this.constraints = newConstraints;
      }
    };
    ViewRef.prototype.activateConstraint = function(constraint) {
      this.owner.activateConstraint(constraint);
    };
    ViewRef.prototype.deactivateConstraint = function(constraint) {
      this.owner.deactivateConstraint(constraint);
    };
    ViewRef.prototype.constraintVariable = function(name, value, strength) {
      if (value === void 0) {
        value = 0;
      }
      if (strength !== void 0) {
        strength = constraint.ConstraintStrength.fromAny(strength);
      } else {
        strength = constraint.ConstraintStrength.Strong;
      }
      const property = constraint.ConstraintProperty.create(this);
      Object.defineProperty(property, "name", {
        value: name,
        configurable: true
      });
      if (value !== void 0) {
        property.setValue(value);
      }
      property.setStrength(strength);
      property.mount();
      return property;
    };
    ViewRef.prototype.hasConstraintVariable = function(constraintVariable) {
      return this.constraintVariables.indexOf(constraintVariable) >= 0;
    };
    ViewRef.prototype.addConstraintVariable = function(constraintVariable) {
      const oldConstraintVariables = this.constraintVariables;
      const newConstraintVariables = util.Arrays.inserted(constraintVariable, oldConstraintVariables);
      if (oldConstraintVariables !== newConstraintVariables) {
        this.constraintVariables = newConstraintVariables;
        this.activateConstraintVariable(constraintVariable);
      }
    };
    ViewRef.prototype.removeConstraintVariable = function(constraintVariable) {
      const oldConstraintVariables = this.constraintVariables;
      const newConstraintVariables = util.Arrays.removed(constraintVariable, oldConstraintVariables);
      if (oldConstraintVariables !== newConstraintVariables) {
        this.deactivateConstraintVariable(constraintVariable);
        this.constraintVariables = newConstraintVariables;
      }
    };
    ViewRef.prototype.activateConstraintVariable = function(constraintVariable) {
      this.owner.activateConstraintVariable(constraintVariable);
    };
    ViewRef.prototype.deactivateConstraintVariable = function(constraintVariable) {
      this.owner.deactivateConstraintVariable(constraintVariable);
    };
    ViewRef.prototype.setConstraintVariable = function(constraintVariable, state) {
      this.owner.setConstraintVariable(constraintVariable, state);
    };
    ViewRef.prototype.activateLayout = function() {
      const constraintVariables = this.constraintVariables;
      for (let i = 0, n = constraintVariables.length; i < n; i += 1) {
        this.owner.activateConstraintVariable(constraintVariables[i]);
      }
      const constraints = this.constraints;
      for (let i = 0, n = constraints.length; i < n; i += 1) {
        this.owner.activateConstraint(constraints[i]);
      }
    };
    ViewRef.prototype.deactivateLayout = function() {
      const constraints = this.constraints;
      for (let i = 0, n = constraints.length; i < n; i += 1) {
        this.owner.deactivateConstraint(constraints[i]);
      }
      const constraintVariables = this.constraintVariables;
      for (let i = 0, n = constraintVariables.length; i < n; i += 1) {
        this.owner.deactivateConstraintVariable(constraintVariables[i]);
      }
    };
    ViewRef.prototype.onMount = function() {
      _super.prototype.onMount.call(this);
      this.activateLayout();
    };
    ViewRef.prototype.onUnmount = function() {
      this.deactivateLayout();
      _super.prototype.onUnmount.call(this);
    };
    ViewRef.construct = function(fastenerClass, fastener, owner) {
      if (fastener === null) {
        fastener = function(view, target, key) {
          if (view === void 0) {
            return fastener.view;
          } else {
            fastener.setView(view, target, key);
            return fastener.owner;
          }
        };
        delete fastener.name;
        Object.setPrototypeOf(fastener, fastenerClass.prototype);
      }
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.view = null;
      fastener.constraints = util.Arrays.empty;
      fastener.constraintVariables = util.Arrays.empty;
      return fastener;
    };
    ViewRef.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      if (descriptor.key === true) {
        Object.defineProperty(descriptor, "key", {
          value: className,
          configurable: true
        });
      } else if (descriptor.key === false) {
        Object.defineProperty(descriptor, "key", {
          value: void 0,
          configurable: true
        });
      }
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        return fastener;
      };
      return fastenerClass;
    };
    return ViewRef;
  }(ViewRelation);
  const ViewSet = function(_super) {
    const ViewSet = _super.extend("ViewSet");
    Object.defineProperty(ViewSet.prototype, "fastenerType", {
      get: function() {
        return ViewSet;
      },
      configurable: true
    });
    ViewSet.prototype.hasView = function(view) {
      return this.views[view.uid] !== void 0;
    };
    ViewSet.prototype.addView = function(newView, target, key) {
      if (newView !== void 0 && newView !== null) {
        newView = this.fromAny(newView);
      } else {
        newView = this.createView();
      }
      if (target === void 0) {
        target = null;
      }
      let parent;
      if (this.binds && (parent = this.parentView, parent !== null)) {
        if (key === void 0) {
          key = this.key(newView);
        }
        this.insertChild(parent, newView, target, key);
      }
      const views = this.views;
      if (views[newView.uid] === void 0) {
        this.willAttachView(newView, target);
        views[newView.uid] = newView;
        this.viewCount += 1;
        this.onAttachView(newView, target);
        this.initView(newView);
        this.didAttachView(newView, target);
      }
      return newView;
    };
    ViewSet.prototype.attachView = function(newView, target) {
      if (newView !== void 0 && newView !== null) {
        newView = this.fromAny(newView);
      } else {
        newView = this.createView();
      }
      const views = this.views;
      if (views[newView.uid] === void 0) {
        if (target === void 0) {
          target = null;
        }
        this.willAttachView(newView, target);
        views[newView.uid] = newView;
        this.viewCount += 1;
        this.onAttachView(newView, target);
        this.initView(newView);
        this.didAttachView(newView, target);
      }
      return newView;
    };
    ViewSet.prototype.detachView = function(oldView) {
      const views = this.views;
      if (views[oldView.uid] !== void 0) {
        this.willDetachView(oldView);
        this.viewCount -= 1;
        delete views[oldView.uid];
        this.onDetachView(oldView);
        this.deinitView(oldView);
        this.didDetachView(oldView);
        return oldView;
      }
      return null;
    };
    ViewSet.prototype.insertView = function(parent, newView, target, key) {
      if (newView !== void 0 && newView !== null) {
        newView = this.fromAny(newView);
      } else {
        newView = this.createView();
      }
      if (parent === void 0 || parent === null) {
        parent = this.parentView;
      }
      if (target === void 0) {
        target = null;
      }
      if (key === void 0) {
        key = this.key(newView);
      }
      if (parent !== null && (newView.parent !== parent || newView.key !== key)) {
        this.insertChild(parent, newView, target, key);
      }
      const views = this.views;
      if (views[newView.uid] === void 0) {
        this.willAttachView(newView, target);
        views[newView.uid] = newView;
        this.viewCount += 1;
        this.onAttachView(newView, target);
        this.initView(newView);
        this.didAttachView(newView, target);
      }
      return newView;
    };
    ViewSet.prototype.removeView = function(view) {
      if (this.hasView(view)) {
        view.remove();
        return view;
      }
      return null;
    };
    ViewSet.prototype.deleteView = function(view) {
      const oldView = this.detachView(view);
      if (oldView !== null) {
        oldView.remove();
      }
      return oldView;
    };
    ViewSet.prototype.bindView = function(view, target) {
      if (this.binds) {
        const newView = this.detectView(view);
        const views = this.views;
        if (newView !== null && views[newView.uid] === void 0) {
          this.willAttachView(newView, target);
          views[newView.uid] = newView;
          this.viewCount += 1;
          this.onAttachView(newView, target);
          this.initView(newView);
          this.didAttachView(newView, target);
        }
      }
    };
    ViewSet.prototype.unbindView = function(view) {
      if (this.binds) {
        const oldView = this.detectView(view);
        const views = this.views;
        if (oldView !== null && views[oldView.uid] !== void 0) {
          this.willDetachView(oldView);
          this.viewCount -= 1;
          delete views[oldView.uid];
          this.onDetachView(oldView);
          this.deinitView(oldView);
          this.didDetachView(oldView);
        }
      }
    };
    ViewSet.prototype.detectView = function(view) {
      if (typeof this.type === "function" && view instanceof this.type) {
        return view;
      }
      return null;
    };
    ViewSet.prototype.key = function(view) {
      return void 0;
    };
    Object.defineProperty(ViewSet.prototype, "sorted", {
      get() {
        return (this.flags & ViewSet.SortedFlag) !== 0;
      },
      configurable: true
    });
    ViewSet.prototype.initInherits = function(sorted) {
      if (sorted) {
        this.flags = this.flags | ViewSet.SortedFlag;
      } else {
        this.flags = this.flags & ~ViewSet.SortedFlag;
      }
    };
    ViewSet.prototype.sort = function(sorted) {
      if (sorted === void 0) {
        sorted = true;
      }
      const flags = this.flags;
      if (sorted && (flags & ViewSet.SortedFlag) === 0) {
        const parent = this.parentView;
        this.willSort(parent);
        this.setFlags(flags | ViewSet.SortedFlag);
        this.onSort(parent);
        this.didSort(parent);
      } else if (!sorted && (flags & ViewSet.SortedFlag) !== 0) {
        this.setFlags(flags & ~ViewSet.SortedFlag);
      }
      return this;
    };
    ViewSet.prototype.willSort = function(parent) {};
    ViewSet.prototype.onSort = function(parent) {
      if (parent !== null) {
        this.sortChildren(parent);
      }
    };
    ViewSet.prototype.didSort = function(parent) {};
    ViewSet.prototype.sortChildren = function(parent) {
      parent.sortChildren(this.compareChildren.bind(this));
    };
    ViewSet.prototype.compareChildren = function(a, b) {
      const views = this.views;
      const x = views[a.uid];
      const y = views[b.uid];
      if (x !== void 0 && y !== void 0) {
        return this.compare(x, y);
      } else {
        return x !== void 0 ? 1 : y !== void 0 ? -1 : 0;
      }
    };
    ViewSet.prototype.compare = function(a, b) {
      return a.uid < b.uid ? -1 : a.uid > b.uid ? 1 : 0;
    };
    ViewSet.construct = function(fastenerClass, fastener, owner) {
      if (fastener === null) {
        fastener = function(newView) {
          fastener.addView(newView);
          return fastener.owner;
        };
        delete fastener.name;
        Object.setPrototypeOf(fastener, fastenerClass.prototype);
      }
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.views = {};
      fastener.viewCount = 0;
      return fastener;
    };
    ViewSet.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const sorted = descriptor.sorted;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.sorted;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        if (sorted !== void 0) {
          fastener.initSorted(sorted);
        }
        return fastener;
      };
      return fastenerClass;
    };
    ViewSet.SortedFlag = 1 << _super.FlagShift + 0;
    ViewSet.FlagShift = _super.FlagShift + 1;
    ViewSet.FlagMask = (1 << ViewSet.FlagShift) - 1;
    return ViewSet;
  }(ViewRelation);
  class DomService extends component.Service {
    onAttachRoot(root) {
      super.onAttachRoot(root);
      if (root instanceof ElementView && root.node.hasAttribute("swim-app")) {
        this.materializeView(root);
      }
    }
    materializeView(parentView) {
      const childNodes = parentView.node.childNodes;
      for (let i = 0; i < childNodes.length; i += 1) {
        const childNode = childNodes[i];
        const childView = this.materializeNode(parentView, childNode);
        if (childView !== null) {
          this.materializeView(childView);
        }
      }
    }
    materializeNode(parentView, childNode) {
      if (childNode.view !== void 0) {
        return childNode.view;
      } else if (childNode instanceof Element) {
        return this.materializeElement(parentView, childNode);
      } else if (childNode instanceof Text) {
        return this.materializeText(parentView, childNode);
      } else {
        return null;
      }
    }
    materializeElement(parentView, childNode) {
      let viewClass;
      const viewClassName = childNode.getAttribute("swim-view");
      if (viewClassName !== null) {
        viewClass = DomService.eval(viewClassName);
        if (typeof viewClass !== "function") {
          throw new TypeError(viewClassName);
        }
      }
      if (viewClass === void 0) {
        if (childNode instanceof HTMLElement) {
          viewClass = HtmlView;
        } else if (childNode instanceof SVGElement) {
          viewClass = SvgView;
        } else {
          viewClass = ElementView;
        }
      }
      const childView = new viewClass(childNode);
      const key = childNode.getAttribute("key");
      parentView.injectChild(childView, null, key !== null ? key : void 0);
      return childView;
    }
    materializeText(parentView, childNode) {
      return null;
    }
    static global() {
      return new DomService;
    }
    static boot() {
      const views = [];
      const nodes = document.querySelectorAll("[swim-app]");
      for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        if (node instanceof HTMLElement) {
          const view = DomService.bootElement(node);
          views.push(view);
        }
      }
      return views;
    }
    static bootElement(node) {
      let view = node.view;
      if (view === void 0) {
        let viewClass;
        const viewClassName = node.getAttribute("swim-app");
        if (viewClassName !== null && viewClassName !== "") {
          viewClass = DomService.eval(viewClassName);
          if (typeof viewClass !== "function") {
            throw new TypeError(viewClassName);
          }
        }
        if (viewClass === void 0) {
          if (node instanceof HTMLElement) {
            viewClass = HtmlView;
          } else if (node instanceof SVGElement) {
            viewClass = SvgView;
          } else {
            viewClass = ElementView;
          }
        }
        view = new viewClass(node);
        viewClass.mount(view);
        if (view.domProvider === void 0) {
          throw new Error("dom service not available");
        }
      }
      return view;
    }
    static eval(qname) {
      let value = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : void 0;
      const idents = qname.split(".");
      for (let i = 0, n = idents.length; typeof value === "object" && value !== null && i < n; i += 1) {
        const ident = idents[i];
        value = value[ident];
      }
      return value;
    }
  }
  __decorate([ util.Lazy ], DomService, "global", null);
  const DomProvider = function(_super) {
    const DomProvider = _super.extend("DomProvider");
    DomProvider.prototype.createService = function() {
      return DomService.global();
    };
    return DomProvider;
  }(component.Provider);
  const AttributeAnimator = function(_super) {
    const AttributeAnimator = _super.extend("AttributeAnimator");
    Object.defineProperty(AttributeAnimator.prototype, "attributeName", {
      get() {
        throw new Error("no attribute name");
      },
      configurable: true
    });
    Object.defineProperty(AttributeAnimator.prototype, "attributeValue", {
      get: function() {
        const view = this.owner;
        if (view instanceof ElementView) {
          const value = view.getAttribute(this.attributeName);
          if (value !== null) {
            try {
              return this.parse(value);
            } catch (e) {}
          }
        }
        return void 0;
      },
      configurable: true
    });
    Object.defineProperty(AttributeAnimator.prototype, "value", {
      get() {
        let value = this.ownValue;
        if (!this.definedValue(value)) {
          const attributeValue = this.attributeValue;
          if (attributeValue !== void 0) {
            value = attributeValue;
            this.setAffinity(component.Affinity.Extrinsic);
          }
        }
        return value;
      },
      set(value) {
        this.ownValue = value;
      },
      configurable: true
    });
    AttributeAnimator.prototype.onSetValue = function(newValue, oldValue) {
      const view = this.owner;
      if (view instanceof ElementView) {
        view.setAttribute(this.attributeName, newValue);
      }
      _super.prototype.onSetValue.call(this, newValue, oldValue);
    };
    AttributeAnimator.prototype.parse = function() {
      throw new Error;
    };
    AttributeAnimator.construct = function(animatorClass, animator, owner) {
      animator = _super.construct(animatorClass, animator, owner);
      return animator;
    };
    AttributeAnimator.specialize = function(type) {
      if (type === String) {
        return StringAttributeAnimator;
      } else if (type === Number) {
        return NumberAttributeAnimator;
      } else if (type === Boolean) {
        return BooleanAttributeAnimator;
      } else if (type === math.Length) {
        return LengthAttributeAnimator;
      } else if (type === Color) {
        return ColorAttributeAnimator;
      } else if (type === math.Transform) {
        return TransformAttributeAnimator;
      }
      return null;
    };
    AttributeAnimator.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const look = descriptor.look;
      const value = descriptor.value;
      const initValue = descriptor.initValue;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.look;
      delete descriptor.value;
      delete descriptor.initValue;
      if (superClass === void 0 || superClass === null) {
        superClass = this.specialize(descriptor.type);
      }
      if (superClass === null) {
        superClass = this;
        if (descriptor.fromAny === void 0 && util.FromAny.is(descriptor.type)) {
          descriptor.fromAny = descriptor.type.fromAny;
        }
      }
      const animatorClass = superClass.extend(className, descriptor);
      animatorClass.construct = function(animatorClass, animator, owner) {
        animator = superClass.construct(animatorClass, animator, owner);
        if (affinity !== void 0) {
          animator.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          animator.initInherits(inherits);
        }
        if (look !== void 0) {
          animator.look = look;
        }
        if (initValue !== void 0) {
          animator.value = animator.fromAny(initValue());
          animator.state = animator.value;
        } else if (value !== void 0) {
          animator.value = animator.fromAny(value);
          animator.state = animator.value;
        }
        return animator;
      };
      return animatorClass;
    };
    return AttributeAnimator;
  }(ThemeAnimator);
  const StringAttributeAnimator = function(_super) {
    const StringAttributeAnimator = _super.extend("StringAttributeAnimator");
    StringAttributeAnimator.prototype.parse = function(value) {
      return value;
    };
    StringAttributeAnimator.prototype.fromAny = function(value) {
      return value;
    };
    StringAttributeAnimator.prototype.equalValues = function(newValue, oldValue) {
      return newValue === oldValue;
    };
    return StringAttributeAnimator;
  }(AttributeAnimator);
  const NumberAttributeAnimator = function(_super) {
    const NumberAttributeAnimator = _super.extend("NumberAttributeAnimator");
    NumberAttributeAnimator.prototype.parse = function(value) {
      const number = +value;
      return isFinite(number) ? number : void 0;
    };
    NumberAttributeAnimator.prototype.fromAny = function(value) {
      if (typeof value === "number") {
        return value;
      } else {
        const number = +value;
        return isFinite(number) ? number : void 0;
      }
    };
    NumberAttributeAnimator.prototype.equalValues = function(newValue, oldValue) {
      return newValue === oldValue;
    };
    return NumberAttributeAnimator;
  }(AttributeAnimator);
  const BooleanAttributeAnimator = function(_super) {
    const BooleanAttributeAnimator = _super.extend("BooleanAttributeAnimator");
    BooleanAttributeAnimator.prototype.parse = function(value) {
      return !!value;
    };
    BooleanAttributeAnimator.prototype.fromAny = function(value) {
      return !!value;
    };
    BooleanAttributeAnimator.prototype.equalValues = function(newValue, oldValue) {
      return newValue === oldValue;
    };
    return BooleanAttributeAnimator;
  }(AttributeAnimator);
  const LengthAttributeAnimator = function(_super) {
    const LengthAttributeAnimator = _super.extend("LengthAttributeAnimator");
    LengthAttributeAnimator.prototype.parse = function(value) {
      return math.Length.parse(value);
    };
    LengthAttributeAnimator.prototype.fromAny = function(value) {
      try {
        return math.Length.fromAny(value);
      } catch (swallow) {
        return null;
      }
    };
    LengthAttributeAnimator.prototype.equalValues = function(newValue, oldValue) {
      if (newValue !== void 0 && newValue !== null) {
        return newValue.equals(oldValue);
      } else {
        return newValue === oldValue;
      }
    };
    return LengthAttributeAnimator;
  }(AttributeAnimator);
  const ColorAttributeAnimator = function(_super) {
    const ColorAttributeAnimator = _super.extend("ColorAttributeAnimator");
    ColorAttributeAnimator.prototype.parse = function(value) {
      return Color.parse(value);
    };
    ColorAttributeAnimator.prototype.fromAny = function(value) {
      try {
        return Color.fromAny(value);
      } catch (swallow) {
        return null;
      }
    };
    ColorAttributeAnimator.prototype.equalValues = function(newValue, oldValue) {
      if (newValue !== void 0 && newValue !== null) {
        return newValue.equals(oldValue);
      } else {
        return newValue === oldValue;
      }
    };
    return ColorAttributeAnimator;
  }(AttributeAnimator);
  const TransformAttributeAnimator = function(_super) {
    const TransformAttributeAnimator = _super.extend("TransformAttributeAnimator");
    TransformAttributeAnimator.prototype.parse = function(value) {
      return math.Transform.parse(value);
    };
    TransformAttributeAnimator.prototype.fromAny = function(value) {
      try {
        return math.Transform.fromAny(value);
      } catch (swallow) {
        return null;
      }
    };
    TransformAttributeAnimator.prototype.equalValues = function(newValue, oldValue) {
      if (newValue !== void 0 && newValue !== null) {
        return newValue.equals(oldValue);
      } else {
        return newValue === oldValue;
      }
    };
    return TransformAttributeAnimator;
  }(AttributeAnimator);
  const StyleAnimator = function(_super) {
    const StyleAnimator = _super.extend("StyleAnimator");
    Object.defineProperty(StyleAnimator.prototype, "propertyNames", {
      get() {
        throw new Error("no property names");
      },
      configurable: true
    });
    Object.defineProperty(StyleAnimator.prototype, "propertyValue", {
      get: function() {
        let propertyValue;
        const styleContext = this.owner;
        if (StyleContext.is(styleContext)) {
          let value = styleContext.getStyle(this.propertyNames);
          if (typeof CSSStyleValue !== "undefined" && value instanceof CSSStyleValue) {
            try {
              propertyValue = this.fromCssValue(value);
            } catch (e) {}
            if (propertyValue === void 0) {
              value = value.toString();
            }
          }
          if (typeof value === "string" && value.length !== 0) {
            try {
              propertyValue = this.parse(value);
            } catch (e) {}
          }
        }
        return propertyValue;
      },
      configurable: true
    });
    Object.defineProperty(StyleAnimator.prototype, "computedValue", {
      get: function() {
        let computedValue;
        const styleContext = this.owner;
        let node;
        if (StyleContext.is(styleContext) && (node = styleContext.node, node instanceof Element)) {
          const styles = getComputedStyle(node);
          const propertyNames = this.propertyNames;
          let propertyValue = "";
          if (typeof propertyNames === "string") {
            propertyValue = styles.getPropertyValue(propertyNames);
          } else {
            for (let i = 0, n = propertyNames.length; i < n && propertyValue.length === 0; i += 1) {
              propertyValue = styles.getPropertyValue(propertyNames[i]);
            }
          }
          if (propertyValue.length !== 0) {
            try {
              computedValue = this.parse(propertyValue);
            } catch (e) {}
          }
        }
        return computedValue;
      },
      configurable: true
    });
    Object.defineProperty(StyleAnimator.prototype, "value", {
      get() {
        let value = this.ownValue;
        if (!this.definedValue(value)) {
          const propertyValue = this.propertyValue;
          if (propertyValue !== void 0) {
            value = propertyValue;
            this.setAffinity(component.Affinity.Extrinsic);
          }
        }
        return value;
      },
      set(value) {
        this.ownValue = value;
      },
      configurable: true
    });
    StyleAnimator.prototype.onSetValue = function(newValue, oldValue) {
      const styleContext = this.owner;
      if (StyleContext.is(styleContext)) {
        const propertyNames = this.propertyNames;
        if (typeof propertyNames === "string") {
          styleContext.setStyle(propertyNames, newValue, this.priority);
        } else {
          for (let i = 0, n = propertyNames.length; i < n; i += 1) {
            styleContext.setStyle(propertyNames[i], newValue, this.priority);
          }
        }
      }
      _super.prototype.onSetValue.call(this, newValue, oldValue);
    };
    StyleAnimator.prototype.setPriority = function(priority) {
      this.priority = priority;
      const styleContext = this.owner;
      const value = this.value;
      if (StyleContext.is(styleContext) && this.definedValue(value)) {
        const propertyNames = this.propertyNames;
        if (typeof propertyNames === "string") {
          styleContext.setStyle(propertyNames, value, priority);
        } else {
          for (let i = 0, n = propertyNames.length; i < n; i += 1) {
            styleContext.setStyle(propertyNames[i], value, priority);
          }
        }
      }
    };
    StyleAnimator.prototype.parse = function() {
      throw new Error;
    };
    StyleAnimator.prototype.fromCssValue = function(value) {
      throw new Error;
    };
    StyleAnimator.construct = function(animatorClass, animator, owner) {
      animator = _super.construct(animatorClass, animator, owner);
      animator.priority = void 0;
      return animator;
    };
    StyleAnimator.specialize = function(type) {
      if (type === String) {
        return StringStyleAnimator;
      } else if (type === Number) {
        return NumberStyleAnimator;
      } else if (type === math.Length) {
        return LengthStyleAnimator;
      } else if (type === Color) {
        return ColorStyleAnimator;
      } else if (type === FontFamily) {
        return FontFamilyStyleAnimator;
      } else if (type === BoxShadow) {
        return BoxShadowStyleAnimator;
      } else if (type === math.Transform) {
        return TransformStyleAnimator;
      }
      return null;
    };
    StyleAnimator.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const look = descriptor.look;
      const value = descriptor.value;
      const initValue = descriptor.initValue;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.look;
      delete descriptor.value;
      delete descriptor.initValue;
      if (superClass === void 0 || superClass === null) {
        superClass = this.specialize(descriptor.type);
      }
      if (superClass === null) {
        superClass = this;
        if (descriptor.fromAny === void 0 && util.FromAny.is(descriptor.type)) {
          descriptor.fromAny = descriptor.type.fromAny;
        }
      }
      const animatorClass = superClass.extend(className, descriptor);
      animatorClass.construct = function(animatorClass, animator, owner) {
        animator = superClass.construct(animatorClass, animator, owner);
        if (affinity !== void 0) {
          animator.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          animator.initInherits(inherits);
        }
        if (look !== void 0) {
          animator.look = look;
        }
        if (initValue !== void 0) {
          animator.value = animator.fromAny(initValue());
          animator.state = animator.value;
        } else if (value !== void 0) {
          animator.value = animator.fromAny(value);
          animator.state = animator.value;
        }
        return animator;
      };
      return animatorClass;
    };
    return StyleAnimator;
  }(ThemeAnimator);
  const StringStyleAnimator = function(_super) {
    const StringStyleAnimator = _super.extend("StringStyleAnimator");
    StringStyleAnimator.prototype.parse = function(value) {
      return value;
    };
    StringStyleAnimator.prototype.fromCssValue = function(value) {
      return value.toString();
    };
    StringStyleAnimator.prototype.fromAny = function(value) {
      return value;
    };
    StringStyleAnimator.prototype.equalValues = function(newValue, oldValue) {
      return newValue === oldValue;
    };
    return StringStyleAnimator;
  }(StyleAnimator);
  const NumberStyleAnimator = function(_super) {
    const NumberStyleAnimator = _super.extend("NumberStyleAnimator");
    NumberStyleAnimator.prototype.parse = function(value) {
      const number = +value;
      return isFinite(number) ? number : void 0;
    };
    NumberStyleAnimator.prototype.fromCssValue = function(value) {
      if (value instanceof CSSNumericValue) {
        return value.to("number").value;
      } else {
        return void 0;
      }
    };
    NumberStyleAnimator.prototype.fromAny = function(value) {
      if (typeof value === "number") {
        return value;
      } else {
        const number = +value;
        return isFinite(number) ? number : void 0;
      }
    };
    NumberStyleAnimator.prototype.equalValues = function(newValue, oldValue) {
      return newValue === oldValue;
    };
    return NumberStyleAnimator;
  }(StyleAnimator);
  const LengthStyleAnimator = function(_super) {
    const LengthStyleAnimator = _super.extend("LengthStyleAnimator");
    LengthStyleAnimator.prototype.parse = function(value) {
      return math.Length.parse(value);
    };
    LengthStyleAnimator.prototype.fromCssValue = function(value) {
      return math.Length.fromCssValue(value);
    };
    LengthStyleAnimator.prototype.fromAny = function(value) {
      try {
        return math.Length.fromAny(value);
      } catch (swallow) {
        return null;
      }
    };
    LengthStyleAnimator.prototype.equalValues = function(newValue, oldValue) {
      if (newValue !== void 0 && newValue !== null) {
        return newValue.equals(oldValue);
      } else {
        return newValue === oldValue;
      }
    };
    return LengthStyleAnimator;
  }(StyleAnimator);
  const ColorStyleAnimator = function(_super) {
    const ColorStyleAnimator = _super.extend("ColorStyleAnimator");
    ColorStyleAnimator.prototype.parse = function(value) {
      return Color.parse(value);
    };
    ColorStyleAnimator.prototype.fromAny = function(value) {
      try {
        return Color.fromAny(value);
      } catch (swallow) {
        return null;
      }
    };
    ColorStyleAnimator.prototype.equalValues = function(newValue, oldValue) {
      if (newValue !== void 0 && newValue !== null) {
        return newValue.equals(oldValue);
      } else {
        return newValue === oldValue;
      }
    };
    return ColorStyleAnimator;
  }(StyleAnimator);
  const FontFamilyStyleAnimator = function(_super) {
    const FontFamilyStyleAnimator = _super.extend("FontFamilyStyleAnimator");
    FontFamilyStyleAnimator.prototype.parse = function(value) {
      return Font.parse(value).family;
    };
    FontFamilyStyleAnimator.prototype.fromAny = function(value) {
      return Font.family(value).family;
    };
    return FontFamilyStyleAnimator;
  }(StyleAnimator);
  const BoxShadowStyleAnimator = function(_super) {
    const BoxShadowStyleAnimator = _super.extend("BoxShadowStyleAnimator");
    BoxShadowStyleAnimator.prototype.parse = function(value) {
      return BoxShadow.parse(value);
    };
    BoxShadowStyleAnimator.prototype.fromAny = function(value) {
      return BoxShadow.fromAny(value);
    };
    BoxShadowStyleAnimator.prototype.equalValues = function(newValue, oldValue) {
      if (newValue !== void 0 && newValue !== null) {
        return newValue.equals(oldValue);
      } else {
        return newValue === oldValue;
      }
    };
    return BoxShadowStyleAnimator;
  }(StyleAnimator);
  const TransformStyleAnimator = function(_super) {
    const TransformStyleAnimator = _super.extend("TransformStyleAnimator");
    TransformStyleAnimator.prototype.parse = function(value) {
      return math.Transform.parse(value);
    };
    TransformStyleAnimator.prototype.fromCssValue = function(value) {
      return math.Transform.fromCssValue(value);
    };
    TransformStyleAnimator.prototype.fromAny = function(value) {
      try {
        return math.Transform.fromAny(value);
      } catch (swallow) {
        return null;
      }
    };
    TransformStyleAnimator.prototype.equalValues = function(newValue, oldValue) {
      if (newValue !== void 0 && newValue !== null) {
        return newValue.equals(oldValue);
      } else {
        return newValue === oldValue;
      }
    };
    return TransformStyleAnimator;
  }(StyleAnimator);
  const StyleConstraintAnimator = function(_super) {
    const StyleConstraintAnimator = _super.extend("StyleConstraintAnimator");
    StyleConstraintAnimator.prototype.isExternal = function() {
      return true;
    };
    StyleConstraintAnimator.prototype.isDummy = function() {
      return false;
    };
    StyleConstraintAnimator.prototype.isInvalid = function() {
      return false;
    };
    StyleConstraintAnimator.prototype.isConstant = function() {
      return false;
    };
    StyleConstraintAnimator.prototype.evaluateConstraintVariable = function() {
      const constraintScope = this.owner;
      if (constraint.ConstraintScope.is(constraintScope) && !this.constrained && this.constraining) {
        const value = this.constraintValue;
        if (value !== void 0 && this.definedValue(value)) {
          constraintScope.setConstraintVariable(this, this.toNumber(value));
        }
      }
    };
    StyleConstraintAnimator.prototype.updateConstraintSolution = function(state) {
      if (this.constrained && this.toNumber(this.state) !== state) {
        this.setState(state, component.Affinity.Reflexive);
      }
    };
    StyleConstraintAnimator.prototype.setStrength = function(strength) {
      this.strength = constraint.ConstraintStrength.fromAny(strength);
    };
    Object.defineProperty(StyleConstraintAnimator.prototype, "coefficient", {
      get() {
        return 1;
      },
      configurable: true
    });
    Object.defineProperty(StyleConstraintAnimator.prototype, "variable", {
      get() {
        return this;
      },
      configurable: true
    });
    Object.defineProperty(StyleConstraintAnimator.prototype, "terms", {
      get() {
        const terms = new constraint.ConstraintMap;
        terms.set(this, 1);
        return terms;
      },
      configurable: true
    });
    Object.defineProperty(StyleConstraintAnimator.prototype, "constant", {
      get() {
        return 0;
      },
      configurable: true
    });
    StyleConstraintAnimator.prototype.plus = function(that) {
      that = constraint.ConstraintExpression.fromAny(that);
      if (this === that) {
        return constraint.ConstraintExpression.product(2, this);
      } else {
        return constraint.ConstraintExpression.sum(this, that);
      }
    };
    StyleConstraintAnimator.prototype.negative = function() {
      return constraint.ConstraintExpression.product(-1, this);
    };
    StyleConstraintAnimator.prototype.minus = function(that) {
      that = constraint.ConstraintExpression.fromAny(that);
      if (this === that) {
        return constraint.ConstraintExpression.zero;
      } else {
        return constraint.ConstraintExpression.sum(this, that.negative());
      }
    };
    StyleConstraintAnimator.prototype.times = function(scalar) {
      return constraint.ConstraintExpression.product(scalar, this);
    };
    StyleConstraintAnimator.prototype.divide = function(scalar) {
      return constraint.ConstraintExpression.product(1 / scalar, this);
    };
    Object.defineProperty(StyleConstraintAnimator.prototype, "constrained", {
      get() {
        return (this.flags & StyleConstraintAnimator.ConstrainedFlag) !== 0;
      },
      configurable: true
    });
    StyleConstraintAnimator.prototype.constrain = function(constrained) {
      if (constrained === void 0) {
        constrained = true;
      }
      const flags = this.flags;
      if (constrained && (flags & StyleConstraintAnimator.ConstrainedFlag) === 0) {
        this.setFlags(flags | StyleConstraintAnimator.ConstrainedFlag);
        if (this.conditionCount !== 0 && this.mounted) {
          this.stopConstraining();
        }
      } else if (!constrained && (flags & StyleConstraintAnimator.ConstrainedFlag) !== 0) {
        this.setFlags(flags & ~StyleConstraintAnimator.ConstrainedFlag);
        if (this.conditionCount !== 0 && this.mounted) {
          this.startConstraining();
          this.updateConstraintVariable();
        }
      }
      return this;
    };
    StyleConstraintAnimator.prototype.addConstraintCondition = function(constraint, solver) {
      this.conditionCount += 1;
      if (!this.constrained && this.conditionCount === 1 && this.mounted) {
        this.startConstraining();
        this.updateConstraintVariable();
      }
    };
    StyleConstraintAnimator.prototype.removeConstraintCondition = function(constraint, solver) {
      this.conditionCount -= 1;
      if (!this.constrained && this.conditionCount === 0 && this.mounted) {
        this.stopConstraining();
      }
    };
    Object.defineProperty(StyleConstraintAnimator.prototype, "constraining", {
      get() {
        return (this.flags & StyleConstraintAnimator.ConstrainingFlag) !== 0;
      },
      configurable: true
    });
    StyleConstraintAnimator.prototype.startConstraining = function() {
      if ((this.flags & StyleConstraintAnimator.ConstrainingFlag) === 0) {
        this.willStartConstraining();
        this.setFlags(this.flags | StyleConstraintAnimator.ConstrainingFlag);
        this.onStartConstraining();
        this.didStartConstraining();
      }
    };
    StyleConstraintAnimator.prototype.willStartConstraining = function() {};
    StyleConstraintAnimator.prototype.onStartConstraining = function() {
      const constraintScope = this.owner;
      if (constraint.ConstraintScope.is(constraintScope)) {
        constraintScope.addConstraintVariable(this);
      }
    };
    StyleConstraintAnimator.prototype.didStartConstraining = function() {};
    StyleConstraintAnimator.prototype.stopConstraining = function() {
      if ((this.flags & StyleConstraintAnimator.ConstrainingFlag) !== 0) {
        this.willStopConstraining();
        this.setFlags(this.flags & ~StyleConstraintAnimator.ConstrainingFlag);
        this.onStopConstraining();
        this.didStopConstraining();
      }
    };
    StyleConstraintAnimator.prototype.willStopConstraining = function() {};
    StyleConstraintAnimator.prototype.onStopConstraining = function() {
      const constraintScope = this.owner;
      if (constraint.ConstraintScope.is(constraintScope)) {
        constraintScope.removeConstraintVariable(this);
      }
    };
    StyleConstraintAnimator.prototype.didStopConstraining = function() {};
    StyleConstraintAnimator.prototype.updateConstraintVariable = function() {
      const constraintScope = this.owner;
      if (constraint.ConstraintScope.is(constraintScope)) {
        let value = this.value;
        if (!this.definedValue(value)) {
          value = this.constraintValue;
        }
        constraintScope.setConstraintVariable(this, this.toNumber(value));
      }
    };
    StyleConstraintAnimator.prototype.onSetValue = function(newValue, oldValue) {
      _super.prototype.onSetValue.call(this, newValue, oldValue);
      const constraintScope = this.owner;
      if (this.constraining && constraint.ConstraintScope.is(constraintScope)) {
        constraintScope.setConstraintVariable(this, newValue !== void 0 && newValue !== null ? this.toNumber(newValue) : 0);
      }
    };
    StyleConstraintAnimator.prototype.onMount = function() {
      _super.prototype.onMount.call(this);
      if (!this.constrained && this.conditionCount !== 0) {
        this.startConstraining();
      }
    };
    StyleConstraintAnimator.prototype.onUnmount = function() {
      if (!this.constrained && this.conditionCount !== 0) {
        this.stopConstraining();
      }
      _super.prototype.onUnmount.call(this);
    };
    StyleConstraintAnimator.prototype.fromAny = function(value) {
      if (typeof value === "string") {
        const number = +value;
        if (isFinite(number)) {
          return number;
        }
      }
      return value;
    };
    StyleConstraintAnimator.prototype.toNumber = function(value) {
      return value !== void 0 && value !== null ? +value : 0;
    };
    StyleConstraintAnimator.construct = function(animatorClass, animator, owner) {
      animator = _super.construct(animatorClass, animator, owner);
      animator.id = constraint.ConstraintId.next();
      animator.strength = constraint.ConstraintStrength.Strong;
      animator.conditionCount = 0;
      return animator;
    };
    StyleConstraintAnimator.specialize = function(type) {
      if (type === Number) {
        return NumberStyleConstraintAnimator;
      } else if (type === math.Length) {
        return LengthStyleConstraintAnimator;
      }
      return null;
    };
    StyleConstraintAnimator.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const strength = descriptor.strength !== void 0 ? constraint.ConstraintStrength.fromAny(descriptor.strength) : void 0;
      const constrain = descriptor.constrain;
      const look = descriptor.look;
      const value = descriptor.value;
      const initValue = descriptor.initValue;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.strength;
      delete descriptor.constrain;
      delete descriptor.look;
      delete descriptor.value;
      delete descriptor.initValue;
      if (superClass === void 0 || superClass === null) {
        superClass = this.specialize(descriptor.type);
      }
      if (superClass === null) {
        superClass = this;
        if (descriptor.fromAny === void 0 && util.FromAny.is(descriptor.type)) {
          descriptor.fromAny = descriptor.type.fromAny;
        }
      }
      const animatorClass = superClass.extend(className, descriptor);
      animatorClass.construct = function(animatorClass, animator, owner) {
        animator = superClass.construct(animatorClass, animator, owner);
        if (affinity !== void 0) {
          animator.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          animator.initInherits(inherits);
        }
        if (strength !== void 0) {
          animator.strength = strength;
        }
        if (look !== void 0) {
          animator.look = look;
        }
        if (initValue !== void 0) {
          animator.value = animator.fromAny(initValue());
          animator.state = animator.value;
        } else if (value !== void 0) {
          animator.value = animator.fromAny(value);
          animator.state = animator.value;
        }
        if (constrain === true) {
          animator.constrain();
        }
        return animator;
      };
      return animatorClass;
    };
    StyleConstraintAnimator.ConstrainedFlag = 1 << _super.FlagShift + 0;
    StyleConstraintAnimator.ConstrainingFlag = 1 << _super.FlagShift + 1;
    StyleConstraintAnimator.FlagShift = _super.FlagShift + 2;
    StyleConstraintAnimator.FlagMask = (1 << StyleConstraintAnimator.FlagShift) - 1;
    return StyleConstraintAnimator;
  }(StyleAnimator);
  const NumberStyleConstraintAnimator = function(_super) {
    const NumberStyleConstraintAnimator = _super.extend("NumberStyleConstraintAnimator");
    NumberStyleConstraintAnimator.prototype.toNumber = function(value) {
      return typeof value === "number" ? value : 0;
    };
    NumberStyleConstraintAnimator.prototype.parse = function(value) {
      const number = +value;
      return isFinite(number) ? number : void 0;
    };
    NumberStyleConstraintAnimator.prototype.fromCssValue = function(value) {
      if (value instanceof CSSNumericValue) {
        return value.to("number").value;
      } else {
        return void 0;
      }
    };
    NumberStyleConstraintAnimator.prototype.fromAny = function(value) {
      if (typeof value === "number") {
        return value;
      } else {
        const number = +value;
        return isFinite(number) ? number : void 0;
      }
    };
    NumberStyleConstraintAnimator.prototype.equalValues = function(newValue, oldValue) {
      return newValue === oldValue;
    };
    return NumberStyleConstraintAnimator;
  }(StyleConstraintAnimator);
  const LengthStyleConstraintAnimator = function(_super) {
    const LengthStyleConstraintAnimator = _super.extend("LengthStyleConstraintAnimator");
    LengthStyleConstraintAnimator.prototype.toNumber = function(value) {
      if (!(value instanceof math.PxLength)) {
        const computedValue = this.computedValue;
        if (computedValue !== void 0 && computedValue !== null) {
          value = computedValue;
        }
      }
      if (value instanceof math.PxLength) {
        return value.value;
      } else {
        return 0;
      }
    };
    LengthStyleConstraintAnimator.prototype.parse = function(value) {
      return math.Length.parse(value);
    };
    LengthStyleConstraintAnimator.prototype.fromCssValue = function(value) {
      return math.Length.fromCssValue(value);
    };
    LengthStyleConstraintAnimator.prototype.fromAny = function(value) {
      try {
        return math.Length.fromAny(value);
      } catch (swallow) {
        return null;
      }
    };
    LengthStyleConstraintAnimator.prototype.equalValues = function(newValue, oldValue) {
      if (newValue !== void 0 && newValue !== null) {
        return newValue.equals(oldValue);
      } else {
        return newValue === oldValue;
      }
    };
    return LengthStyleConstraintAnimator;
  }(StyleConstraintAnimator);
  const StyleContext = function() {
    const StyleContext = {};
    StyleContext.is = function(object) {
      if (typeof object === "object" && object !== null || typeof object === "function") {
        const styleContext = object;
        return "getStyle" in styleContext;
      }
      return false;
    };
    return StyleContext;
  }();
  const StyleMap = function() {
    const StyleMap = {};
    StyleMap.init = function(map, init) {
      if (init.alignContent !== void 0) {
        init.alignContent;
        map.alignContent(init.alignContent);
      }
      if (init.alignItems !== void 0) {
        map.alignItems(init.alignItems);
      }
      if (init.alignSelf !== void 0) {
        map.alignSelf(init.alignSelf);
      }
      if (init.appearance !== void 0) {
        map.appearance(init.appearance);
      }
      if (init.backdropFilter !== void 0) {
        map.backdropFilter(init.backdropFilter);
      }
      if (init.backgroundClip !== void 0) {
        map.backgroundClip(init.backgroundClip);
      }
      if (init.backgroundColor !== void 0) {
        map.backgroundColor(init.backgroundColor);
      }
      if (init.backgroundImage !== void 0) {
        map.backgroundImage(init.backgroundImage);
      }
      if (init.borderCollapse !== void 0) {
        map.borderCollapse(init.borderCollapse);
      }
      if (init.borderColor !== void 0) {
        map.borderColor(init.borderColor);
      }
      if (init.borderTopColor !== void 0) {
        map.borderTopColor(init.borderTopColor);
      }
      if (init.borderRightColor !== void 0) {
        map.borderRightColor(init.borderRightColor);
      }
      if (init.borderBottomColor !== void 0) {
        map.borderBottomColor(init.borderBottomColor);
      }
      if (init.borderLeftColor !== void 0) {
        map.borderLeftColor(init.borderLeftColor);
      }
      if (init.borderRadius !== void 0) {
        map.borderRadius(init.borderRadius);
      }
      if (init.borderTopLeftRadius !== void 0) {
        map.borderTopLeftRadius(init.borderTopLeftRadius);
      }
      if (init.borderTopRightRadius !== void 0) {
        map.borderTopRightRadius(init.borderTopRightRadius);
      }
      if (init.borderBottomRightRadius !== void 0) {
        map.borderBottomRightRadius(init.borderBottomRightRadius);
      }
      if (init.borderBottomLeftRadius !== void 0) {
        map.borderBottomLeftRadius(init.borderBottomLeftRadius);
      }
      if (init.borderSpacing !== void 0) {
        map.borderSpacing(init.borderSpacing);
      }
      if (init.borderStyle !== void 0) {
        map.borderStyle(init.borderStyle);
      }
      if (init.borderTopStyle !== void 0) {
        map.borderTopStyle(init.borderTopStyle);
      }
      if (init.borderRightStyle !== void 0) {
        map.borderRightStyle(init.borderRightStyle);
      }
      if (init.borderBottomStyle !== void 0) {
        map.borderBottomStyle(init.borderBottomStyle);
      }
      if (init.borderLeftStyle !== void 0) {
        map.borderLeftStyle(init.borderLeftStyle);
      }
      if (init.borderWidth !== void 0) {
        map.borderWidth(init.borderWidth);
      }
      if (init.borderTopWidth !== void 0) {
        map.borderTopWidth(init.borderTopWidth);
      }
      if (init.borderRightWidth !== void 0) {
        map.borderRightWidth(init.borderRightWidth);
      }
      if (init.borderBottomWidth !== void 0) {
        map.borderBottomWidth(init.borderBottomWidth);
      }
      if (init.borderLeftWidth !== void 0) {
        map.borderLeftWidth(init.borderLeftWidth);
      }
      if (init.bottom !== void 0) {
        map.bottom(init.bottom);
      }
      if (init.boxShadow !== void 0) {
        map.boxShadow(init.boxShadow);
      }
      if (init.boxSizing !== void 0) {
        map.boxSizing(init.boxSizing);
      }
      if (init.color !== void 0) {
        map.color(init.color);
      }
      if (init.cursor !== void 0) {
        map.cursor(init.cursor);
      }
      if (init.display !== void 0) {
        map.display(init.display);
      }
      if (init.filter !== void 0) {
        map.filter(init.filter);
      }
      if (init.flexBasis !== void 0) {
        map.flexBasis(init.flexBasis);
      }
      if (init.flexDirection !== void 0) {
        map.flexDirection(init.flexDirection);
      }
      if (init.flexGrow !== void 0) {
        map.flexGrow(init.flexGrow);
      }
      if (init.flexShrink !== void 0) {
        map.flexShrink(init.flexShrink);
      }
      if (init.flexWrap !== void 0) {
        map.flexWrap(init.flexWrap);
      }
      if (init.font !== void 0) {
        map.font(init.font);
      }
      if (init.fontFamily !== void 0) {
        map.fontFamily(init.fontFamily);
      }
      if (init.fontSize !== void 0) {
        map.fontSize(init.fontSize);
      }
      if (init.fontStretch !== void 0) {
        map.fontStretch(init.fontStretch);
      }
      if (init.fontStyle !== void 0) {
        map.fontStyle(init.fontStyle);
      }
      if (init.fontVariant !== void 0) {
        map.fontVariant(init.fontVariant);
      }
      if (init.fontWeight !== void 0) {
        map.fontWeight(init.fontWeight);
      }
      if (init.height !== void 0) {
        map.height(init.height);
      }
      if (init.justifyContent !== void 0) {
        map.justifyContent(init.justifyContent);
      }
      if (init.left !== void 0) {
        map.left(init.left);
      }
      if (init.lineHeight !== void 0) {
        map.lineHeight(init.lineHeight);
      }
      if (init.margin !== void 0) {
        map.margin(init.margin);
      }
      if (init.marginTop !== void 0) {
        map.marginTop(init.marginTop);
      }
      if (init.marginRight !== void 0) {
        map.marginRight(init.marginRight);
      }
      if (init.marginBottom !== void 0) {
        map.marginBottom(init.marginBottom);
      }
      if (init.marginLeft !== void 0) {
        map.marginLeft(init.marginLeft);
      }
      if (init.maxHeight !== void 0) {
        map.maxHeight(init.maxHeight);
      }
      if (init.maxWidth !== void 0) {
        map.maxWidth(init.maxWidth);
      }
      if (init.minHeight !== void 0) {
        map.minHeight(init.minHeight);
      }
      if (init.minWidth !== void 0) {
        map.minWidth(init.minWidth);
      }
      if (init.opacity !== void 0) {
        map.opacity(init.opacity);
      }
      if (init.order !== void 0) {
        map.order(init.order);
      }
      if (init.outlineColor !== void 0) {
        map.outlineColor(init.outlineColor);
      }
      if (init.outlineStyle !== void 0) {
        map.outlineStyle(init.outlineStyle);
      }
      if (init.outlineWidth !== void 0) {
        map.outlineWidth(init.outlineWidth);
      }
      if (init.overflow !== void 0) {
        map.overflow(init.overflow);
      }
      if (init.overflowX !== void 0) {
        map.overflowX(init.overflowX);
      }
      if (init.overflowY !== void 0) {
        map.overflowY(init.overflowY);
      }
      if (init.overflowScrolling !== void 0) {
        map.overflowScrolling(init.overflowScrolling);
      }
      if (init.overscrollBehavior !== void 0) {
        map.overscrollBehavior(init.overscrollBehavior);
      }
      if (init.overscrollBehaviorX !== void 0) {
        map.overscrollBehaviorX(init.overscrollBehaviorX);
      }
      if (init.overscrollBehaviorY !== void 0) {
        map.overscrollBehaviorY(init.overscrollBehaviorY);
      }
      if (init.padding !== void 0) {
        map.padding(init.padding);
      }
      if (init.paddingTop !== void 0) {
        map.paddingTop(init.paddingTop);
      }
      if (init.paddingRight !== void 0) {
        map.paddingRight(init.paddingRight);
      }
      if (init.paddingBottom !== void 0) {
        map.paddingBottom(init.paddingBottom);
      }
      if (init.paddingLeft !== void 0) {
        map.paddingLeft(init.paddingLeft);
      }
      if (init.pointerEvents !== void 0) {
        map.pointerEvents(init.pointerEvents);
      }
      if (init.position !== void 0) {
        map.position(init.position);
      }
      if (init.right !== void 0) {
        map.right(init.right);
      }
      if (init.textAlign !== void 0) {
        map.textAlign(init.textAlign);
      }
      if (init.textDecorationColor !== void 0) {
        map.textDecorationColor(init.textDecorationColor);
      }
      if (init.textDecorationLine !== void 0) {
        map.textDecorationLine(init.textDecorationLine);
      }
      if (init.textDecorationStyle !== void 0) {
        map.textDecorationStyle(init.textDecorationStyle);
      }
      if (init.textOverflow !== void 0) {
        map.textOverflow(init.textOverflow);
      }
      if (init.textTransform !== void 0) {
        map.textTransform(init.textTransform);
      }
      if (init.top !== void 0) {
        map.top(init.top);
      }
      if (init.touchAction !== void 0) {
        map.touchAction(init.touchAction);
      }
      if (init.transform !== void 0) {
        map.transform(init.transform);
      }
      if (init.userSelect !== void 0) {
        map.userSelect(init.userSelect);
      }
      if (init.verticalAlign !== void 0) {
        map.verticalAlign(init.verticalAlign);
      }
      if (init.visibility !== void 0) {
        map.visibility(init.visibility);
      }
      if (init.whiteSpace !== void 0) {
        map.whiteSpace(init.whiteSpace);
      }
      if (init.width !== void 0) {
        map.width(init.width);
      }
      if (init.zIndex !== void 0) {
        map.zIndex(init.zIndex);
      }
    };
    StyleMap.define = function(prototype) {
      StyleAnimator({
        propertyNames: "align-content",
        type: String
      })(prototype, "alignContent");
      StyleAnimator({
        propertyNames: "align-items",
        type: String
      })(prototype, "alignItems");
      StyleAnimator({
        propertyNames: "align-self",
        type: String
      })(prototype, "alignSelf");
      StyleAnimator({
        propertyNames: [ "appearance", "-webkit-appearance" ],
        type: String
      })(prototype, "appearance");
      StyleAnimator({
        propertyNames: [ "backdrop-filter", "-webkit-backdrop-filter" ],
        type: String
      })(prototype, "backdropFilter");
      StyleAnimator({
        propertyNames: [ "background-clip", "-webkit-background-clip" ],
        type: String
      })(prototype, "backgroundClip");
      StyleAnimator({
        propertyNames: "background-color",
        type: Color,
        value: null
      })(prototype, "backgroundColor");
      StyleAnimator({
        propertyNames: "background-image",
        type: Color,
        value: null,
        parse(value) {
          try {
            return LinearGradient.parse(value);
          } catch (swallow) {
            return value;
          }
        },
        fromAny(value) {
          if (typeof value === "string") {
            try {
              return LinearGradient.parse(value);
            } catch (swallow) {
              return value;
            }
          } else {
            return LinearGradient.fromAny(value);
          }
        }
      })(prototype, "backgroundImage");
      StyleAnimator({
        propertyNames: "border-collapse",
        type: String
      })(prototype, "borderCollapse");
      prototype.borderColor = borderColor;
      StyleAnimator({
        propertyNames: "border-top-color",
        type: Color,
        value: null
      })(prototype, "borderTopColor");
      StyleAnimator({
        propertyNames: "border-right-color",
        type: Color,
        value: null
      })(prototype, "borderRightColor");
      StyleAnimator({
        propertyNames: "border-bottom-color",
        type: Color,
        value: null
      })(prototype, "borderBottomColor");
      StyleAnimator({
        propertyNames: "border-left-color",
        type: Color,
        value: null
      })(prototype, "borderLeftColor");
      prototype.borderRadius = borderRadius;
      StyleAnimator({
        propertyNames: "border-top-left-radius",
        type: math.Length,
        value: null
      })(prototype, "borderTopLeftRadius");
      StyleAnimator({
        propertyNames: "border-top-right-radius",
        type: math.Length,
        value: null
      })(prototype, "borderTopRightRadius");
      StyleAnimator({
        propertyNames: "border-bottom-right-radius",
        type: math.Length,
        value: null
      })(prototype, "borderBottomRightRadius");
      StyleAnimator({
        propertyNames: "border-bottom-left-radius",
        type: math.Length,
        value: null
      })(prototype, "borderBottomLeftRadius");
      StyleAnimator({
        propertyNames: "border-spacing",
        type: String
      })(prototype, "borderSpacing");
      prototype.borderStyle = borderStyle;
      StyleAnimator({
        propertyNames: "border-top-style",
        type: String
      })(prototype, "borderTopStyle");
      StyleAnimator({
        propertyNames: "border-right-style",
        type: String
      })(prototype, "borderRightStyle");
      StyleAnimator({
        propertyNames: "border-bottom-style",
        type: String
      })(prototype, "borderBottomStyle");
      StyleAnimator({
        propertyNames: "border-left-style",
        type: String
      })(prototype, "borderLeftStyle");
      prototype.borderWidth = borderWidth;
      StyleAnimator({
        propertyNames: "border-top-width",
        type: math.Length,
        value: null
      })(prototype, "borderTopWidth");
      StyleAnimator({
        propertyNames: "border-right-width",
        type: math.Length,
        value: null
      })(prototype, "borderRightWidth");
      StyleAnimator({
        propertyNames: "border-bottom-width",
        type: math.Length,
        value: null
      })(prototype, "borderBottomWidth");
      StyleAnimator({
        propertyNames: "border-left-width",
        type: math.Length,
        value: null
      })(prototype, "borderLeftWidth");
      StyleConstraintAnimator({
        propertyNames: "bottom",
        type: math.Length,
        value: null,
        get constraintValue() {
          const node = this.owner.node;
          if (node instanceof HTMLElement) {
            const offsetParent = node.offsetParent;
            const offsetBounds = offsetParent !== null ? offsetParent.getBoundingClientRect() : node === document.body ? node.getBoundingClientRect() : null;
            if (offsetBounds !== null) {
              const bounds = node.getBoundingClientRect();
              return math.Length.px(bounds.bottom - offsetBounds.bottom);
            }
          }
          return null;
        }
      })(prototype, "bottom");
      StyleAnimator({
        propertyNames: "box-shadow",
        type: BoxShadow,
        value: null
      })(prototype, "boxShadow");
      StyleAnimator({
        propertyNames: "box-sizing",
        type: String
      })(prototype, "boxSizing");
      StyleAnimator({
        propertyNames: "color",
        type: Color,
        value: null
      })(prototype, "color");
      StyleAnimator({
        propertyNames: "cursor",
        type: String
      })(prototype, "cursor");
      StyleAnimator({
        propertyNames: "display",
        type: String
      })(prototype, "display");
      StyleAnimator({
        propertyNames: "filter",
        type: String
      })(prototype, "filter");
      StyleAnimator({
        propertyNames: "flex-basis",
        type: math.Length,
        value: null
      })(prototype, "flexBasis");
      StyleAnimator({
        propertyNames: "flex-direction",
        type: String
      })(prototype, "flexDirection");
      StyleAnimator({
        propertyNames: "flex-grow",
        type: Number
      })(prototype, "flexGrow");
      StyleAnimator({
        propertyNames: "flex-shrink",
        type: Number
      })(prototype, "flexShrink");
      StyleAnimator({
        propertyNames: "flex-wrap",
        type: String
      })(prototype, "flexWrap");
      prototype.font = font;
      StyleAnimator({
        propertyNames: "font-family",
        type: FontFamily
      })(prototype, "fontFamily");
      StyleAnimator({
        propertyNames: "font-size",
        type: math.Length,
        value: null
      })(prototype, "fontSize");
      StyleAnimator({
        propertyNames: "font-stretch",
        type: String
      })(prototype, "fontStretch");
      StyleAnimator({
        propertyNames: "font-style",
        type: String
      })(prototype, "fontStyle");
      StyleAnimator({
        propertyNames: "font-variant",
        type: String
      })(prototype, "fontVariant");
      StyleAnimator({
        propertyNames: "font-weight",
        type: String
      })(prototype, "fontWeight");
      StyleConstraintAnimator({
        propertyNames: "height",
        type: math.Length,
        value: null,
        get constraintValue() {
          const node = this.owner.node;
          return node instanceof HTMLElement ? math.Length.px(node.offsetHeight) : null;
        }
      })(prototype, "height");
      StyleAnimator({
        propertyNames: "justify-content",
        type: String
      })(prototype, "justifyContent");
      StyleConstraintAnimator({
        propertyNames: "left",
        type: math.Length,
        value: null,
        get constraintValue() {
          const node = this.owner.node;
          return node instanceof HTMLElement ? math.Length.px(node.offsetLeft) : null;
        }
      })(prototype, "left");
      StyleAnimator({
        propertyNames: "line-height",
        type: math.Length,
        value: null
      })(prototype, "lineHeight");
      prototype.margin = margin;
      StyleConstraintAnimator({
        propertyNames: "margin-top",
        type: math.Length,
        value: null
      })(prototype, "marginTop");
      StyleConstraintAnimator({
        propertyNames: "margin-right",
        type: math.Length,
        value: null
      })(prototype, "marginRight");
      StyleConstraintAnimator({
        propertyNames: "margin-bottom",
        type: math.Length,
        value: null
      })(prototype, "marginBottom");
      StyleConstraintAnimator({
        propertyNames: "margin-left",
        type: math.Length,
        value: null
      })(prototype, "marginLeft");
      StyleAnimator({
        propertyNames: "max-height",
        type: math.Length,
        value: null
      })(prototype, "maxHeight");
      StyleAnimator({
        propertyNames: "max-width",
        type: math.Length,
        value: null
      })(prototype, "maxWidth");
      StyleAnimator({
        propertyNames: "min-height",
        type: math.Length,
        value: null
      })(prototype, "minHeight");
      StyleAnimator({
        propertyNames: "min-width",
        type: math.Length,
        value: null
      })(prototype, "minWidth");
      StyleAnimator({
        propertyNames: "opacity",
        type: Number
      })(prototype, "opacity");
      StyleAnimator({
        propertyNames: "order",
        type: Number
      })(prototype, "order");
      StyleAnimator({
        propertyNames: "outline-color",
        type: Color,
        value: null
      })(prototype, "outlineColor");
      StyleAnimator({
        propertyNames: "outline-style",
        type: String
      })(prototype, "outlineStyle");
      StyleAnimator({
        propertyNames: "outline-width",
        type: math.Length,
        value: null
      })(prototype, "outlineWidth");
      prototype.overflow = overflow;
      StyleAnimator({
        propertyNames: "overflow-x",
        type: String
      })(prototype, "overflowX");
      StyleAnimator({
        propertyNames: "overflow-y",
        type: String
      })(prototype, "overflowY");
      StyleAnimator({
        propertyNames: "-webkit-overflow-scrolling",
        type: String
      })(prototype, "overflowScrolling");
      prototype.overscrollBehavior = overscrollBehavior;
      StyleAnimator({
        propertyNames: "overscroll-behavior-x",
        type: String
      })(prototype, "overscrollBehaviorX");
      StyleAnimator({
        propertyNames: "overscroll-behavior-y",
        type: String
      })(prototype, "overscrollBehaviorY");
      prototype.padding = padding;
      StyleConstraintAnimator({
        propertyNames: "padding-top",
        type: math.Length,
        value: null
      })(prototype, "paddingTop");
      StyleConstraintAnimator({
        propertyNames: "padding-right",
        type: math.Length,
        value: null
      })(prototype, "paddingRight");
      StyleConstraintAnimator({
        propertyNames: "padding-bottom",
        type: math.Length,
        value: null
      })(prototype, "paddingBottom");
      StyleConstraintAnimator({
        propertyNames: "padding-left",
        type: math.Length,
        value: null
      })(prototype, "paddingLeft");
      StyleAnimator({
        propertyNames: "pointer-events",
        type: String
      })(prototype, "pointerEvents");
      StyleAnimator({
        propertyNames: "position",
        type: String
      })(prototype, "position");
      StyleConstraintAnimator({
        propertyNames: "right",
        type: math.Length,
        value: null,
        get constraintValue() {
          const node = this.owner.node;
          if (node instanceof HTMLElement) {
            const offsetParent = node.offsetParent;
            const offsetBounds = offsetParent !== null ? offsetParent.getBoundingClientRect() : node === document.body ? node.getBoundingClientRect() : null;
            if (offsetBounds !== null) {
              const bounds = node.getBoundingClientRect();
              return math.Length.px(bounds.right - offsetBounds.right);
            }
          }
          return null;
        }
      })(prototype, "right");
      StyleAnimator({
        propertyNames: "text-align",
        type: String
      })(prototype, "textAlign");
      StyleAnimator({
        propertyNames: "text-decoration-color",
        type: Color,
        value: null
      })(prototype, "textDecorationColor");
      StyleAnimator({
        propertyNames: "text-decoration-line",
        type: String
      })(prototype, "textDecorationLine");
      StyleAnimator({
        propertyNames: "text-decoration-style",
        type: String
      })(prototype, "textDecorationStyle");
      StyleAnimator({
        propertyNames: "text-overflow",
        type: String
      })(prototype, "textOverflow");
      StyleAnimator({
        propertyNames: "text-transform",
        type: String
      })(prototype, "textTransform");
      StyleConstraintAnimator({
        propertyNames: "top",
        type: math.Length,
        value: null,
        get constraintValue() {
          const node = this.owner.node;
          return node instanceof HTMLElement ? math.Length.px(node.offsetTop) : null;
        }
      })(prototype, "top");
      StyleAnimator({
        propertyNames: "touch-action",
        type: String
      })(prototype, "touchAction");
      StyleAnimator({
        propertyNames: "transform",
        type: math.Transform,
        value: null
      })(prototype, "transform");
      StyleAnimator({
        propertyNames: [ "user-select", "-webkit-user-select", "-moz-user-select", "-ms-user-select" ],
        type: String
      })(prototype, "userSelect");
      StyleAnimator({
        propertyNames: "vertical-align",
        type: String
      })(prototype, "verticalAlign");
      StyleAnimator({
        propertyNames: "visibility",
        type: String
      })(prototype, "visibility");
      StyleAnimator({
        propertyNames: "white-space",
        type: String
      })(prototype, "whiteSpace");
      StyleConstraintAnimator({
        propertyNames: "width",
        type: math.Length,
        value: null,
        get constraintValue() {
          const node = this.owner.node;
          return node instanceof HTMLElement ? math.Length.px(node.offsetWidth) : null;
        }
      })(prototype, "width");
      StyleAnimator({
        propertyNames: "z-index",
        type: Number
      })(prototype, "zIndex");
    };
    function borderColor(value, timing, precedence) {
      if (value === void 0) {
        const borderTopColor = this.borderTopColor.value;
        const borderRightColor = this.borderRightColor.value;
        const borderBottomColor = this.borderBottomColor.value;
        const borderLeftColor = this.borderLeftColor.value;
        if (util.Values.equal(borderTopColor, borderRightColor) && util.Values.equal(borderRightColor, borderBottomColor) && util.Values.equal(borderBottomColor, borderLeftColor)) {
          return borderTopColor;
        } else {
          return [ borderTopColor, borderRightColor, borderBottomColor, borderLeftColor ];
        }
      } else {
        if (Array.isArray(value)) {
          if (value.length >= 1) {
            this.borderTopColor.setState(value[0], timing, precedence);
          }
          if (value.length >= 2) {
            this.borderRightColor.setState(value[1], timing, precedence);
          }
          if (value.length >= 3) {
            this.borderBottomColor.setState(value[2], timing, precedence);
          }
          if (value.length >= 4) {
            this.borderLeftColor.setState(value[3], timing, precedence);
          }
        } else {
          this.borderTopColor.setState(value, timing, precedence);
          this.borderRightColor.setState(value, timing, precedence);
          this.borderBottomColor.setState(value, timing, precedence);
          this.borderLeftColor.setState(value, timing, precedence);
        }
        return this;
      }
    }
    function borderRadius(value, timing, precedence) {
      if (value === void 0) {
        const borderTopLeftRadius = this.borderTopLeftRadius.value;
        const borderTopRightRadius = this.borderTopRightRadius.value;
        const borderBottomRightRadius = this.borderBottomRightRadius.value;
        const borderBottomLeftRadius = this.borderBottomLeftRadius.value;
        if (util.Equals(borderTopLeftRadius, borderTopRightRadius) && util.Equals(borderTopRightRadius, borderBottomRightRadius) && util.Equals(borderBottomRightRadius, borderBottomLeftRadius)) {
          return borderTopLeftRadius;
        } else {
          return [ borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius ];
        }
      } else {
        if (Array.isArray(value)) {
          if (value.length >= 1) {
            this.borderTopLeftRadius.setState(value[0], timing, precedence);
          }
          if (value.length >= 2) {
            this.borderTopRightRadius.setState(value[1], timing, precedence);
          }
          if (value.length >= 3) {
            this.borderBottomRightRadius.setState(value[2], timing, precedence);
          }
          if (value.length >= 4) {
            this.borderBottomLeftRadius.setState(value[3], timing, precedence);
          }
        } else {
          this.borderTopLeftRadius.setState(value, timing, precedence);
          this.borderTopRightRadius.setState(value, timing, precedence);
          this.borderBottomRightRadius.setState(value, timing, precedence);
          this.borderBottomLeftRadius.setState(value, timing, precedence);
        }
        return this;
      }
    }
    function borderStyle(value, timing, precedence) {
      if (value === void 0) {
        const borderTopStyle = this.borderTopStyle.value;
        const borderRightStyle = this.borderRightStyle.value;
        const borderBottomStyle = this.borderBottomStyle.value;
        const borderLeftStyle = this.borderLeftStyle.value;
        if (borderTopStyle === borderRightStyle && borderRightStyle === borderBottomStyle && borderBottomStyle === borderLeftStyle) {
          return borderTopStyle;
        } else {
          return [ borderTopStyle, borderRightStyle, borderBottomStyle, borderLeftStyle ];
        }
      } else {
        if (Array.isArray(value)) {
          if (value.length >= 1) {
            this.borderTopStyle.setState(value[0], timing, precedence);
          }
          if (value.length >= 2) {
            this.borderRightStyle.setState(value[1], timing, precedence);
          }
          if (value.length >= 3) {
            this.borderBottomStyle.setState(value[2], timing, precedence);
          }
          if (value.length >= 4) {
            this.borderLeftStyle.setState(value[3], timing, precedence);
          }
        } else {
          this.borderTopStyle.setState(value, timing, precedence);
          this.borderRightStyle.setState(value, timing, precedence);
          this.borderBottomStyle.setState(value, timing, precedence);
          this.borderLeftStyle.setState(value, timing, precedence);
        }
        return this;
      }
    }
    function borderWidth(value, timing, precedence) {
      if (value === void 0) {
        const borderTopWidth = this.borderTopWidth.value;
        const borderRightWidth = this.borderRightWidth.value;
        const borderBottomWidth = this.borderBottomWidth.value;
        const borderLeftWidth = this.borderLeftWidth.value;
        if (util.Values.equal(borderTopWidth, borderRightWidth) && util.Values.equal(borderRightWidth, borderBottomWidth) && util.Values.equal(borderBottomWidth, borderLeftWidth)) {
          return borderTopWidth;
        } else {
          return [ borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth ];
        }
      } else {
        if (Array.isArray(value)) {
          if (value.length >= 1) {
            this.borderTopWidth.setState(value[0], timing, precedence);
          }
          if (value.length >= 2) {
            this.borderRightWidth.setState(value[1], timing, precedence);
          }
          if (value.length >= 3) {
            this.borderBottomWidth.setState(value[2], timing, precedence);
          }
          if (value.length >= 4) {
            this.borderLeftWidth.setState(value[3], timing, precedence);
          }
        } else {
          this.borderTopWidth.setState(value, timing, precedence);
          this.borderRightWidth.setState(value, timing, precedence);
          this.borderBottomWidth.setState(value, timing, precedence);
          this.borderLeftWidth.setState(value, timing, precedence);
        }
        return this;
      }
    }
    function font(value, timing, precedence) {
      if (value === void 0) {
        const style = this.fontStyle.value;
        const variant = this.fontVariant.value;
        const weight = this.fontWeight.value;
        const stretch = this.fontStretch.value;
        const size = this.fontSize.value;
        const height = this.lineHeight.value;
        const family = this.fontFamily.value;
        if (family !== void 0) {
          return Font.create(style, variant, weight, stretch, size, height, family);
        } else {
          return null;
        }
      } else {
        if (value !== null) {
          value = Font.fromAny(value);
          if (value.style !== void 0) {
            this.fontStyle.setState(value.style, timing, precedence);
          }
          if (value.variant !== void 0) {
            this.fontVariant.setState(value.variant, timing, precedence);
          }
          if (value.weight !== void 0) {
            this.fontWeight.setState(value.weight, timing, precedence);
          }
          if (value.stretch !== void 0) {
            this.fontStretch.setState(value.stretch, timing, precedence);
          }
          if (value.size !== void 0) {
            this.fontSize.setState(value.size, timing, precedence);
          }
          if (value.height !== void 0) {
            this.lineHeight.setState(value.height, timing, precedence);
          }
          this.fontFamily.setState(value.family, timing, precedence);
        } else {
          this.fontStyle.setState(void 0, timing, precedence);
          this.fontVariant.setState(void 0, timing, precedence);
          this.fontWeight.setState(void 0, timing, precedence);
          this.fontStretch.setState(void 0, timing, precedence);
          this.fontSize.setState(null, timing, precedence);
          this.lineHeight.setState(null, timing, precedence);
          this.fontFamily.setState(void 0, timing, precedence);
        }
        return this;
      }
    }
    function margin(value, timing, precedence) {
      if (value === void 0) {
        const marginTop = this.marginTop.value;
        const marginRight = this.marginRight.value;
        const marginBottom = this.marginBottom.value;
        const marginLeft = this.marginLeft.value;
        if (util.Values.equal(marginTop, marginRight) && util.Values.equal(marginRight, marginBottom) && util.Values.equal(marginBottom, marginLeft)) {
          return marginTop;
        } else {
          return [ marginTop, marginRight, marginBottom, marginLeft ];
        }
      } else {
        if (Array.isArray(value)) {
          if (value.length >= 1) {
            this.marginTop.setState(value[0], timing, precedence);
          }
          if (value.length >= 2) {
            this.marginRight.setState(value[1], timing, precedence);
          }
          if (value.length >= 3) {
            this.marginBottom.setState(value[2], timing, precedence);
          }
          if (value.length >= 4) {
            this.marginLeft.setState(value[3], timing, precedence);
          }
        } else {
          this.marginTop.setState(value, timing, precedence);
          this.marginRight.setState(value, timing, precedence);
          this.marginBottom.setState(value, timing, precedence);
          this.marginLeft.setState(value, timing, precedence);
        }
        return this;
      }
    }
    function overflow(value, timing, precedence) {
      if (value === void 0) {
        const overflowX = this.overflowX.value;
        const overflowY = this.overflowY.value;
        if (overflowX === overflowY) {
          return overflowX;
        } else {
          return [ overflowX, overflowY ];
        }
      } else {
        if (Array.isArray(value)) {
          if (value.length >= 1) {
            this.overflowX.setState(value[0], timing, precedence);
          }
          if (value.length >= 2) {
            this.overflowY.setState(value[1], timing, precedence);
          }
        } else {
          this.overflowX.setState(value, timing, precedence);
          this.overflowY.setState(value, timing, precedence);
        }
        return this;
      }
    }
    function overscrollBehavior(value, timing, precedence) {
      if (value === void 0) {
        const overscrollBehaviorX = this.overscrollBehaviorX.value;
        const overscrollBehaviorY = this.overscrollBehaviorY.value;
        if (overscrollBehaviorX === overscrollBehaviorY) {
          return overscrollBehaviorX;
        } else {
          return [ overscrollBehaviorX, overscrollBehaviorY ];
        }
      } else {
        if (Array.isArray(value)) {
          if (value.length >= 1) {
            this.overscrollBehaviorX.setState(value[0], timing, precedence);
          }
          if (value.length >= 2) {
            this.overscrollBehaviorY.setState(value[1], timing, precedence);
          }
        } else {
          this.overscrollBehaviorX.setState(value, timing, precedence);
          this.overscrollBehaviorY.setState(value, timing, precedence);
        }
        return this;
      }
    }
    function padding(value, timing, precedence) {
      if (value === void 0) {
        const paddingTop = this.paddingTop.value;
        const paddingRight = this.paddingRight.value;
        const paddingBottom = this.paddingBottom.value;
        const paddingLeft = this.paddingLeft.value;
        if (util.Equals(paddingTop, paddingRight) && util.Equals(paddingRight, paddingBottom) && util.Equals(paddingBottom, paddingLeft)) {
          return paddingTop;
        } else {
          return [ paddingTop, paddingRight, paddingBottom, paddingLeft ];
        }
      } else {
        if (Array.isArray(value)) {
          if (value.length >= 1) {
            this.paddingTop.setState(value[0], timing, precedence);
          }
          if (value.length >= 2) {
            this.paddingRight.setState(value[1], timing, precedence);
          }
          if (value.length >= 3) {
            this.paddingBottom.setState(value[2], timing, precedence);
          }
          if (value.length >= 4) {
            this.paddingLeft.setState(value[3], timing, precedence);
          }
        } else {
          this.paddingTop.setState(value, timing, precedence);
          this.paddingRight.setState(value, timing, precedence);
          this.paddingBottom.setState(value, timing, precedence);
          this.paddingLeft.setState(value, timing, precedence);
        }
        return this;
      }
    }
    return StyleMap;
  }();
  const CssContext = function() {
    const CssContext = {};
    CssContext.is = function(object) {
      if (typeof object === "object" && object !== null || typeof object === "function") {
        const cssContext = object;
        return "getRule" in cssContext;
      }
      return false;
    };
    return CssContext;
  }();
  const CssRule = function(_super) {
    const CssRule = _super.extend("CssRule");
    Object.defineProperty(CssRule.prototype, "fastenerType", {
      get: function() {
        return CssRule;
      },
      configurable: true
    });
    CssRule.prototype.hasFastener = function(fastenerName, fastenerBound) {
      const fasteners = this.fasteners;
      if (fasteners !== null) {
        const fastener = fasteners[fastenerName];
        if (fastener !== void 0 && (fastenerBound === void 0 || fastenerBound === null || fastener instanceof fastenerBound)) {
          return true;
        }
      }
      return false;
    };
    CssRule.prototype.getFastener = function(fastenerName, fastenerBound) {
      const fasteners = this.fasteners;
      if (fasteners !== null) {
        const fastener = fasteners[fastenerName];
        if (fastener !== void 0 && (fastenerBound === void 0 || fastenerBound === null || fastener instanceof fastenerBound)) {
          return fastener;
        }
      }
      return null;
    };
    CssRule.prototype.setFastener = function(fastenerName, newFastener) {
      let fasteners = this.fasteners;
      if (fasteners === null) {
        fasteners = {};
        this.fasteners = fasteners;
      }
      const oldFastener = fasteners[fastenerName];
      if (oldFastener !== void 0 && this.mounted) {
        oldFastener.unmount();
      }
      if (newFastener !== null) {
        fasteners[fastenerName] = newFastener;
        if (this.mounted) {
          newFastener.mount();
        }
      } else {
        delete fasteners[fastenerName];
      }
    };
    CssRule.prototype.getLazyFastener = function(fastenerName, fastenerBound) {
      return component.FastenerContext.getLazyFastener(this, fastenerName, fastenerBound);
    };
    CssRule.prototype.getSuperFastener = function(fastenerName, fastenerBound) {
      if (arguments.length === 0) {
        return _super.prototype.getSuperFastener.call(this);
      } else {
        return null;
      }
    };
    CssRule.prototype.mountFasteners = function() {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        fastener.mount();
      }
    };
    CssRule.prototype.unmountFasteners = function() {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        fastener.unmount();
      }
    };
    CssRule.prototype.requireUpdate = function(updateFlags) {
      const propertyContext = this.owner;
      if (component.FastenerContext.has(propertyContext, "requireUpdate")) {
        propertyContext.requireUpdate(updateFlags);
      }
    };
    CssRule.prototype.decohereFastener = function(fastener) {
      let decoherent = this.decoherent;
      if (decoherent === null) {
        decoherent = [];
        this.decoherent = decoherent;
      }
      decoherent.push(fastener);
      if ((this.flags & component.Fastener.DecoherentFlag) === 0) {
        this.setCoherent(false);
        this.decohere();
      }
    };
    CssRule.prototype.recohereFasteners = function(t) {
      const decoherent = this.decoherent;
      if (decoherent !== null) {
        const decoherentCount = decoherent.length;
        if (decoherentCount !== 0) {
          this.decoherent = null;
          for (let i = 0; i < decoherentCount; i += 1) {
            const fastener = decoherent[i];
            fastener.recohere(t);
          }
        }
      }
    };
    CssRule.prototype.recohere = function(t) {
      this.recohereFasteners(t);
      if (this.decoherent === null || this.decoherent.length === 0) {
        this.setCoherent(true);
      } else {
        this.setCoherent(false);
        this.decohere();
      }
    };
    CssRule.prototype.constraint = function(lhs, relation, rhs, strength) {
      return this.owner.constraint(lhs, relation, rhs, strength);
    };
    CssRule.prototype.hasConstraint = function(constraint) {
      return this.owner.hasConstraint(constraint);
    };
    CssRule.prototype.addConstraint = function(constraint) {
      this.owner.addConstraint(constraint);
    };
    CssRule.prototype.removeConstraint = function(constraint) {
      this.owner.removeConstraint(constraint);
    };
    CssRule.prototype.constraintVariable = function(name, value, strength) {
      return this.owner.constraintVariable(name, value, strength);
    };
    CssRule.prototype.hasConstraintVariable = function(constraintVariable) {
      return this.owner.hasConstraintVariable(constraintVariable);
    };
    CssRule.prototype.addConstraintVariable = function(constraintVariable) {
      this.owner.addConstraintVariable(constraintVariable);
    };
    CssRule.prototype.removeConstraintVariable = function(constraintVariable) {
      this.owner.removeConstraintVariable(constraintVariable);
    };
    CssRule.prototype.setConstraintVariable = function(constraintVariable, state) {
      this.owner.setConstraintVariable(constraintVariable, state);
    };
    CssRule.prototype.getLook = function(look, mood) {
      const themeContext = this.owner;
      if (ThemeContext.is(themeContext)) {
        return themeContext.getLook(look, mood);
      } else {
        return void 0;
      }
    };
    CssRule.prototype.getLookOr = function(look, mood, elseValue) {
      const themeContext = this.owner;
      if (ThemeContext.is(themeContext)) {
        if (arguments.length === 2) {
          return themeContext.getLookOr(look, mood);
        } else {
          return themeContext.getLookOr(look, mood, elseValue);
        }
      } else if (arguments.length === 2) {
        return mood;
      } else {
        return elseValue;
      }
    };
    CssRule.prototype.applyTheme = function(theme, mood, timing) {};
    CssRule.prototype.onMount = function() {
      _super.prototype.onMount.call(this);
      this.mountFasteners();
    };
    CssRule.prototype.onUnmount = function() {
      this.unmountFasteners();
      _super.prototype.onUnmount.call(this);
    };
    CssRule.prototype.createRule = function(cssText) {
      const cssContext = this.owner;
      if (CssContext.is(cssContext)) {
        const index = cssContext.insertRule(cssText);
        const rule = cssContext.getRule(index);
        if (rule instanceof CSSRule) {
          return rule;
        } else {
          throw new TypeError("" + rule);
        }
      } else {
        throw new Error("no css context");
      }
    };
    CssRule.construct = function(ruleClass, rule, owner) {
      rule = _super.construct(ruleClass, rule, owner);
      rule.fasteners = null;
      rule.decoherent = null;
      rule.rule = null;
      component.FastenerContext.init(rule);
      return rule;
    };
    CssRule.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      let css = descriptor.css;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.css;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const ruleClass = superClass.extend(className, descriptor);
      if (typeof css === "function") {
        ruleClass.prototype.initCss = css;
        css = void 0;
      }
      ruleClass.construct = function(ruleClass, rule, owner) {
        rule = superClass.construct(ruleClass, rule, owner);
        if (affinity !== void 0) {
          rule.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          rule.initInherits(inherits);
        }
        let cssText;
        if (css !== void 0) {
          cssText = css;
        } else if (rule.initCss !== void 0) {
          cssText = rule.initCss();
        } else {
          throw new Error("undefined css");
        }
        rule.rule = rule.createRule(cssText);
        if (rule.initRule !== void 0) {
          rule.initRule(rule.rule);
        }
        return rule;
      };
      return ruleClass;
    };
    return CssRule;
  }(component.Fastener);
  const StyleRule = function(_super) {
    const StyleRule = _super.extend("StyleRule");
    Object.defineProperty(StyleRule.prototype, "selector", {
      get: function() {
        return this.rule.selectorText;
      },
      configurable: true
    });
    StyleRule.prototype.setSelector = function(selector) {
      this.rule.selectorText = selector;
    };
    StyleRule.prototype.getStyle = function(propertyNames) {
      if (typeof CSSStyleValue !== "undefined") {
        const style = this.rule.styleMap;
        if (typeof propertyNames === "string") {
          return style.get(propertyNames);
        } else {
          for (let i = 0, n = propertyNames.length; i < n; i += 1) {
            const value = style.get(propertyNames[i]);
            if (value !== void 0) {
              return value;
            }
          }
          return "";
        }
      } else {
        const style = this.rule.style;
        if (typeof propertyNames === "string") {
          return style.getPropertyValue(propertyNames);
        } else {
          for (let i = 0, n = propertyNames.length; i < n; i += 1) {
            const value = style.getPropertyValue(propertyNames[i]);
            if (value.length !== 0) {
              return value;
            }
          }
          return "";
        }
      }
    };
    StyleRule.prototype.setStyle = function(propertyName, value, priority) {
      this.willSetStyle(propertyName, value, priority);
      if (typeof CSSStyleValue !== "undefined") {
        if (value !== void 0 && value !== null) {
          const cssValue = ToCssValue(value);
          if (cssValue !== null) {
            try {
              this.rule.styleMap.set(propertyName, cssValue);
            } catch (e) {}
          } else {
            this.rule.style.setProperty(propertyName, ToStyleString(value), priority);
          }
        } else {
          this.rule.styleMap.delete(propertyName);
        }
      } else {
        if (value !== void 0 && value !== null) {
          this.rule.style.setProperty(propertyName, ToStyleString(value), priority);
        } else {
          this.rule.style.removeProperty(propertyName);
        }
      }
      this.onSetStyle(propertyName, value, priority);
      this.didSetStyle(propertyName, value, priority);
      return this;
    };
    StyleRule.prototype.willSetStyle = function(propertyName, value, priority) {};
    StyleRule.prototype.onSetStyle = function(propertyName, value, priority) {};
    StyleRule.prototype.didSetStyle = function(propertyName, value, priority) {};
    StyleRule.prototype.applyTheme = function(theme, mood, timing) {
      if (timing === void 0 || timing === true) {
        timing = theme.getOr(Look.timing, Mood.ambient, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        if (fastener instanceof ThemeAnimator) {
          fastener.applyTheme(theme, mood, timing);
        }
      }
    };
    StyleRule.prototype.createRule = function(cssText) {
      const cssContext = this.owner;
      if (CssContext.is(cssContext)) {
        const index = cssContext.insertRule(cssText);
        const rule = cssContext.getRule(index);
        if (rule instanceof CSSStyleRule) {
          return rule;
        } else {
          throw new TypeError("" + rule);
        }
      } else {
        throw new Error("no css context");
      }
    };
    StyleMap.define(StyleRule.prototype);
    StyleRule.construct = function(ruleClass, rule, owner) {
      if (rule === null) {
        rule = function(property, value) {
          if (value === void 0) {
            return rule.getStyle(property);
          } else {
            rule.setStyle(property, value);
            return rule.owner;
          }
        };
        delete rule.name;
        Object.setPrototypeOf(rule, ruleClass.prototype);
      }
      rule = _super.construct(ruleClass, rule, owner);
      return rule;
    };
    StyleRule.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      let css = descriptor.css;
      const style = descriptor.style;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.css;
      delete descriptor.style;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const ruleClass = superClass.extend(className, descriptor);
      if (typeof css === "function") {
        ruleClass.prototype.initCss = css;
        css = void 0;
      }
      ruleClass.construct = function(ruleClass, rule, owner) {
        rule = superClass.construct(ruleClass, rule, owner);
        if (affinity !== void 0) {
          rule.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          rule.initInherits(inherits);
        }
        let cssText;
        if (css !== void 0) {
          cssText = css;
        } else if (rule.initCss !== void 0) {
          cssText = rule.initCss();
        } else {
          throw new Error("undefined css");
        }
        rule.rule = rule.createRule(cssText);
        if (rule.initRule !== void 0) {
          rule.initRule(rule.rule);
        }
        if (style !== void 0) {
          StyleMap.init(rule, style);
        }
        return rule;
      };
      return ruleClass;
    };
    return StyleRule;
  }(CssRule);
  const MediaRule = function(_super) {
    const MediaRule = _super.extend("MediaRule");
    MediaRule.prototype.getRule = function(index) {
      return this.rule.cssRules.item(index);
    };
    MediaRule.prototype.insertRule = function(cssText, index) {
      return this.rule.insertRule(cssText, index);
    };
    MediaRule.prototype.removeRule = function(index) {
      this.rule.deleteRule(index);
    };
    MediaRule.prototype.applyTheme = function(theme, mood, timing) {
      if (timing === void 0 || timing === true) {
        timing = theme.getOr(Look.timing, Mood.ambient, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        if (fastener instanceof CssRule) {
          fastener.applyTheme(theme, mood, timing);
        }
      }
    };
    MediaRule.prototype.createRule = function(cssText) {
      const cssContext = this.owner;
      if (CssContext.is(cssContext)) {
        const index = cssContext.insertRule(cssText);
        const rule = cssContext.getRule(index);
        if (rule instanceof CSSMediaRule) {
          return rule;
        } else {
          throw new TypeError("" + rule);
        }
      } else {
        throw new Error("no css context");
      }
    };
    MediaRule.construct = function(ruleClass, rule, owner) {
      rule = _super.construct(ruleClass, rule, owner);
      return rule;
    };
    MediaRule.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      let css = descriptor.css;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.css;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const ruleClass = superClass.extend(className, descriptor);
      if (typeof css === "function") {
        ruleClass.prototype.initCss = css;
        css = void 0;
      }
      ruleClass.construct = function(ruleClass, rule, owner) {
        rule = superClass.construct(ruleClass, rule, owner);
        if (affinity !== void 0) {
          rule.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          rule.initInherits(inherits);
        }
        let cssText;
        if (css !== void 0) {
          cssText = css;
        } else if (rule.initCss !== void 0) {
          cssText = rule.initCss();
        } else {
          throw new Error("undefined css");
        }
        rule.rule = rule.createRule(cssText);
        if (rule.initRule !== void 0) {
          rule.initRule(rule.rule);
        }
        return rule;
      };
      return ruleClass;
    };
    return MediaRule;
  }(CssRule);
  const StyleSheet = function(_super) {
    const StyleSheet = _super.extend("StyleSheet");
    Object.defineProperty(StyleSheet.prototype, "fastenerType", {
      get: function() {
        return StyleSheet;
      },
      configurable: true
    });
    StyleSheet.prototype.getRule = function(index) {
      return this.stylesheet.cssRules.item(index);
    };
    StyleSheet.prototype.insertRule = function(cssText, index) {
      return this.stylesheet.insertRule(cssText, index);
    };
    StyleSheet.prototype.removeRule = function(index) {
      this.stylesheet.deleteRule(index);
    };
    StyleSheet.prototype.hasFastener = function(fastenerName, fastenerBound) {
      const fasteners = this.fasteners;
      if (fasteners !== null) {
        const fastener = fasteners[fastenerName];
        if (fastener !== void 0 && (fastenerBound === void 0 || fastenerBound === null || fastener instanceof fastenerBound)) {
          return true;
        }
      }
      return false;
    };
    StyleSheet.prototype.getFastener = function(fastenerName, fastenerBound) {
      const fasteners = this.fasteners;
      if (fasteners !== null) {
        const fastener = fasteners[fastenerName];
        if (fastener !== void 0 && (fastenerBound === void 0 || fastenerBound === null || fastener instanceof fastenerBound)) {
          return fastener;
        }
      }
      return null;
    };
    StyleSheet.prototype.setFastener = function(fastenerName, newFastener) {
      let fasteners = this.fasteners;
      if (fasteners === null) {
        fasteners = {};
        this.fasteners = fasteners;
      }
      const oldFastener = fasteners[fastenerName];
      if (oldFastener !== void 0 && this.mounted) {
        oldFastener.unmount();
      }
      if (newFastener !== null) {
        fasteners[fastenerName] = newFastener;
        if (this.mounted) {
          newFastener.mount();
        }
      } else {
        delete fasteners[fastenerName];
      }
    };
    StyleSheet.prototype.getLazyFastener = function(fastenerName, fastenerBound) {
      return component.FastenerContext.getLazyFastener(this, fastenerName, fastenerBound);
    };
    StyleSheet.prototype.getSuperFastener = function(fastenerName, fastenerBound) {
      if (arguments.length === 0) {
        return _super.prototype.getSuperFastener.call(this);
      } else {
        return null;
      }
    };
    StyleSheet.prototype.mountFasteners = function() {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        fastener.mount();
      }
    };
    StyleSheet.prototype.unmountFasteners = function() {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        fastener.unmount();
      }
    };
    StyleSheet.prototype.requireUpdate = function(updateFlags) {
      const fastenerContext = this.owner;
      if (component.FastenerContext.has(fastenerContext, "requireUpdate")) {
        fastenerContext.requireUpdate(updateFlags);
      }
    };
    StyleSheet.prototype.decohereFastener = function(fastener) {
      let decoherent = this.decoherent;
      if (decoherent === null) {
        decoherent = [];
        this.decoherent = decoherent;
      }
      decoherent.push(fastener);
      if ((this.flags & component.Fastener.DecoherentFlag) === 0) {
        this.setCoherent(false);
        this.decohere();
      }
    };
    StyleSheet.prototype.recohereFasteners = function(t) {
      const decoherent = this.decoherent;
      if (decoherent !== null) {
        const decoherentCount = decoherent.length;
        if (decoherentCount !== 0) {
          this.decoherent = null;
          for (let i = 0; i < decoherentCount; i += 1) {
            const fastener = decoherent[i];
            fastener.recohere(t);
          }
        }
      }
    };
    StyleSheet.prototype.recohere = function(t) {
      this.recohereFasteners(t);
      if (this.decoherent === null || this.decoherent.length === 0) {
        this.setCoherent(true);
      } else {
        this.setCoherent(false);
        this.decohere();
      }
    };
    StyleSheet.prototype.constraint = function(lhs, relation, rhs, strength) {
      return this.owner.constraint(lhs, relation, rhs, strength);
    };
    StyleSheet.prototype.hasConstraint = function(constraint) {
      return this.owner.hasConstraint(constraint);
    };
    StyleSheet.prototype.addConstraint = function(constraint) {
      this.owner.addConstraint(constraint);
    };
    StyleSheet.prototype.removeConstraint = function(constraint) {
      this.owner.removeConstraint(constraint);
    };
    StyleSheet.prototype.constraintVariable = function(name, value, strength) {
      return this.owner.constraintVariable(name, value, strength);
    };
    StyleSheet.prototype.hasConstraintVariable = function(constraintVariable) {
      return this.owner.hasConstraintVariable(constraintVariable);
    };
    StyleSheet.prototype.addConstraintVariable = function(constraintVariable) {
      this.owner.addConstraintVariable(constraintVariable);
    };
    StyleSheet.prototype.removeConstraintVariable = function(constraintVariable) {
      this.owner.removeConstraintVariable(constraintVariable);
    };
    StyleSheet.prototype.setConstraintVariable = function(constraintVariable, state) {
      this.owner.setConstraintVariable(constraintVariable, state);
    };
    StyleSheet.prototype.getLook = function(look, mood) {
      const themeContext = this.owner;
      if (ThemeContext.is(themeContext)) {
        return themeContext.getLook(look, mood);
      } else {
        return void 0;
      }
    };
    StyleSheet.prototype.getLookOr = function(look, mood, elseValue) {
      const themeContext = this.owner;
      if (ThemeContext.is(themeContext)) {
        if (arguments.length === 2) {
          return themeContext.getLookOr(look, mood);
        } else {
          return themeContext.getLookOr(look, mood, elseValue);
        }
      } else if (arguments.length === 2) {
        return mood;
      } else {
        return elseValue;
      }
    };
    StyleSheet.prototype.applyTheme = function(theme, mood, timing) {
      if (timing === void 0 || timing === true) {
        timing = theme.getOr(Look.timing, Mood.ambient, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        if (fastener instanceof CssRule) {
          fastener.applyTheme(theme, mood, timing);
        }
      }
    };
    StyleSheet.prototype.onMount = function() {
      _super.prototype.onMount.call(this);
      this.mountFasteners();
    };
    StyleSheet.prototype.onUnmount = function() {
      this.unmountFasteners();
      _super.prototype.onUnmount.call(this);
    };
    StyleSheet.prototype.createStylesheet = function() {
      return new CSSStyleSheet;
    };
    StyleSheet.construct = function(sheetClass, sheet, owner) {
      sheet = _super.construct(sheetClass, sheet, owner);
      sheet.fasteners = null;
      sheet.decoherent = null;
      sheet.stylesheet = null;
      component.FastenerContext.init(sheet);
      return sheet;
    };
    StyleSheet.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      let css = descriptor.css;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.css;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const sheetClass = superClass.extend(className, descriptor);
      if (typeof css === "function") {
        sheetClass.prototype.initCss = css;
        css = void 0;
      }
      sheetClass.construct = function(sheetClass, sheet, owner) {
        sheet = superClass.construct(sheetClass, sheet, owner);
        if (affinity !== void 0) {
          sheet.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          sheet.initInherits(inherits);
        }
        sheet.stylesheet = sheet.createStylesheet();
        if (sheet.initStylesheet !== void 0) {
          sheet.initStylesheet(sheet.stylesheet);
        }
        return sheet;
      };
      return sheetClass;
    };
    return StyleSheet;
  }(component.Fastener);
  class NodeView extends View {
    constructor(node) {
      super();
      this.node = node;
      node.view = this;
    }
    setChild(key, newChild) {
      const oldChild = this.getChild(key);
      let target;
      if (newChild instanceof Node) {
        newChild = NodeView.fromNode(newChild);
      } else if (newChild !== null) {
        newChild = View.fromAny(newChild);
      }
      if (oldChild !== null && newChild !== null && oldChild !== newChild) {
        newChild.remove();
        target = oldChild.nextSibling;
        if ((oldChild.flags & View.RemovingFlag) === 0) {
          oldChild.setFlags(oldChild.flags | View.RemovingFlag);
          this.willRemoveChild(oldChild);
          oldChild.detachParent(this);
          this.removeChildMap(oldChild);
          this.onRemoveChild(oldChild);
          this.didRemoveChild(oldChild);
          oldChild.setKey(void 0);
          oldChild.setFlags(oldChild.flags & ~View.RemovingFlag);
        }
        newChild.setKey(oldChild.key);
        this.willInsertChild(newChild, target);
        if (newChild instanceof NodeView) {
          if (oldChild instanceof NodeView) {
            this.node.replaceChild(newChild.node, oldChild.node);
          } else if (target !== null) {
            let targetNode = null;
            let next = target;
            do {
              if (next instanceof NodeView) {
                targetNode = next.node;
                break;
              }
              next = next.nextSibling;
            } while (next !== null);
            this.node.insertBefore(newChild.node, targetNode);
          } else {
            this.node.appendChild(newChild.node);
          }
        } else if (oldChild instanceof NodeView) {
          this.node.removeChild(oldChild.node);
        }
        this.insertChildMap(newChild);
        newChild.attachParent(this, target);
        this.onInsertChild(newChild, target);
        this.didInsertChild(newChild, target);
        newChild.cascadeInsert();
      } else if (newChild !== oldChild || newChild !== null && newChild.key !== key) {
        if (oldChild !== null) {
          target = oldChild.nextSibling;
          if ((oldChild.flags & View.RemovingFlag) === 0) {
            oldChild.setFlags(oldChild.flags | View.RemovingFlag);
            this.willRemoveChild(oldChild);
            oldChild.detachParent(this);
            this.removeChildMap(oldChild);
            if (oldChild instanceof NodeView) {
              this.node.removeChild(oldChild.node);
            }
            this.onRemoveChild(oldChild);
            this.didRemoveChild(oldChild);
            oldChild.setKey(void 0);
            oldChild.setFlags(oldChild.flags & ~View.RemovingFlag);
          }
        } else {
          target = null;
        }
        if (newChild !== null) {
          newChild.remove();
          newChild.setKey(key);
          this.willInsertChild(newChild, target);
          if (newChild instanceof NodeView) {
            let targetNode = null;
            if (target !== null) {
              let next = target;
              do {
                if (next instanceof NodeView) {
                  targetNode = next.node;
                  break;
                }
                next = next.nextSibling;
              } while (next !== null);
            }
            this.node.insertBefore(newChild.node, targetNode);
          }
          this.insertChildMap(newChild);
          newChild.attachParent(this, target);
          this.onInsertChild(newChild, target);
          this.didInsertChild(newChild, target);
          newChild.cascadeInsert();
        }
      }
      return oldChild;
    }
    appendChild(child, key) {
      if (child instanceof Node) {
        child = NodeView.fromNode(child);
      } else {
        child = View.fromAny(child);
      }
      child.remove();
      if (key !== void 0) {
        this.removeChild(key);
      }
      child.setKey(key);
      this.willInsertChild(child, null);
      if (child instanceof NodeView) {
        this.node.appendChild(child.node);
      }
      this.insertChildMap(child);
      child.attachParent(this, null);
      this.onInsertChild(child, null);
      this.didInsertChild(child, null);
      child.cascadeInsert();
      return child;
    }
    prependChild(child, key) {
      if (child instanceof Node) {
        child = NodeView.fromNode(child);
      } else {
        child = View.fromAny(child);
      }
      child.remove();
      if (key !== void 0) {
        this.removeChild(key);
      }
      const target = this.firstChild;
      child.setKey(key);
      this.willInsertChild(child, target);
      if (child instanceof NodeView) {
        this.node.insertBefore(child.node, this.node.firstChild);
      }
      this.insertChildMap(child);
      child.attachParent(this, target);
      this.onInsertChild(child, target);
      this.didInsertChild(child, target);
      child.cascadeInsert();
      return child;
    }
    insertChild(child, target, key) {
      if (target instanceof View && target.parent !== this || target instanceof Node && target.parentNode !== this.node) {
        throw new TypeError("" + target);
      }
      if (child instanceof Node) {
        child = NodeView.fromNode(child);
      } else {
        child = View.fromAny(child);
      }
      child.remove();
      if (key !== void 0) {
        this.removeChild(key);
      }
      let targetView;
      let targetNode;
      if (target instanceof Node) {
        targetView = null;
        targetNode = target;
        let next = target;
        do {
          if (next.view !== void 0) {
            targetView = next.view;
            break;
          }
          next = next.nextSibling;
        } while (next !== null);
      } else {
        targetView = target;
        targetNode = null;
      }
      child.setKey(key);
      this.willInsertChild(child, targetView);
      if (child instanceof NodeView) {
        if (targetNode === null && targetView !== null) {
          let next = targetView;
          do {
            if (next instanceof NodeView) {
              targetNode = next.node;
              break;
            }
            next = next.nextSibling;
          } while (next !== null);
        }
        this.node.insertBefore(child.node, targetNode);
      }
      this.insertChildMap(child);
      child.attachParent(this, targetView);
      this.onInsertChild(child, targetView);
      this.didInsertChild(child, targetView);
      child.cascadeInsert();
      return child;
    }
    injectChild(child, target, key) {
      if (target instanceof View && target.parent !== this || target instanceof Node && target.parentNode !== this.node) {
        throw new TypeError("" + target);
      }
      child = NodeView.fromAny(child);
      if (key !== void 0) {
        this.removeChild(key);
      }
      if (target instanceof Node) {
        let next = target;
        target = null;
        do {
          if (next.view !== void 0) {
            target = next.view;
            break;
          }
          next = next.nextSibling;
        } while (next !== null);
      }
      child.setKey(key);
      this.willInsertChild(child, target);
      this.insertChildMap(child);
      child.attachParent(this, target);
      this.onInsertChild(child, target);
      this.didInsertChild(child, target);
      child.cascadeInsert();
      return child;
    }
    replaceChild(newChild, oldChild) {
      if (oldChild.parent !== this) {
        throw new TypeError("" + oldChild);
      }
      if (newChild instanceof Node) {
        newChild = NodeView.fromNode(newChild);
      } else {
        newChild = View.fromAny(newChild);
      }
      if (newChild !== oldChild) {
        newChild.remove();
        const target = oldChild.nextSibling;
        if ((oldChild.flags & View.RemovingFlag) === 0) {
          oldChild.setFlags(oldChild.flags | View.RemovingFlag);
          this.willRemoveChild(oldChild);
          oldChild.detachParent(this);
          this.removeChildMap(oldChild);
          this.onRemoveChild(oldChild);
          this.didRemoveChild(oldChild);
          oldChild.setKey(void 0);
          oldChild.setFlags(oldChild.flags & ~View.RemovingFlag);
        }
        newChild.setKey(oldChild.key);
        this.willInsertChild(newChild, target);
        if (newChild instanceof NodeView) {
          if (oldChild instanceof NodeView) {
            this.node.replaceChild(newChild.node, oldChild.node);
          } else if (target !== null) {
            let targetNode = null;
            let next = target;
            do {
              if (next instanceof NodeView) {
                targetNode = next.node;
                break;
              }
              next = next.nextSibling;
            } while (next !== null);
            this.node.insertBefore(newChild.node, targetNode);
          } else {
            this.node.appendChild(newChild.node);
          }
        } else if (oldChild instanceof NodeView) {
          this.node.removeChild(oldChild.node);
        }
        this.insertChildMap(newChild);
        newChild.attachParent(this, target);
        this.onInsertChild(newChild, target);
        this.didInsertChild(newChild, target);
        newChild.cascadeInsert();
      }
      return oldChild;
    }
    removeChild(key) {
      let child;
      if (typeof key === "string") {
        child = this.getChild(key);
        if (child === null) {
          return null;
        }
      } else if (key instanceof Node) {
        if (key.parentNode !== this.node) {
          throw new Error("not a child node");
        }
        if (key.view !== void 0) {
          child = key.view;
        } else {
          this.node.removeChild(key);
          return key;
        }
      } else {
        child = key;
        if (child.parent !== this) {
          throw new Error("not a child");
        }
      }
      if ((child.flags & View.RemovingFlag) === 0) {
        child.setFlags(child.flags | View.RemovingFlag);
        this.willRemoveChild(child);
        child.detachParent(this);
        this.removeChildMap(child);
        if (child instanceof NodeView) {
          this.node.removeChild(child.node);
        }
        this.onRemoveChild(child);
        this.didRemoveChild(child);
        child.setKey(void 0);
        child.setFlags(child.flags & ~View.RemovingFlag);
      }
      return child;
    }
    removeChildren() {
      let child;
      while (child = this.lastChild, child !== null) {
        if ((child.flags & View.RemovingFlag) !== 0) {
          throw new Error("inconsistent removeChildren");
        }
        this.willRemoveChild(child);
        child.detachParent(this);
        this.removeChildMap(child);
        if (child instanceof NodeView) {
          this.node.removeChild(child.node);
        }
        this.onRemoveChild(child);
        this.didRemoveChild(child);
        child.setKey(void 0);
        child.setFlags(child.flags & ~View.RemovingFlag);
      }
    }
    static isRootView(node) {
      do {
        const parentNode = node.parentNode;
        if (parentNode !== null) {
          const parentView = parentNode.view;
          if (parentView !== void 0) {
            return false;
          }
          node = parentNode;
          continue;
        }
        break;
      } while (true);
      return true;
    }
    static isNodeMounted(node) {
      let isConnected = node.isConnected;
      if (typeof isConnected !== "boolean") {
        const ownerDocument = node.ownerDocument;
        if (ownerDocument !== null) {
          const position = ownerDocument.compareDocumentPosition(node);
          isConnected = (position & node.DOCUMENT_POSITION_DISCONNECTED) === 0;
        } else {
          isConnected = false;
        }
      }
      return isConnected;
    }
    static mount(view) {
      if (view.parent === null) {
        const parentNode = view.node.parentNode;
        const parentView = parentNode !== null && parentNode.view !== void 0 ? parentNode.view : null;
        if (parentView !== null) {
          let targetView = null;
          let targetNode = view.node.nextSibling;
          while (targetNode !== null) {
            if (targetNode.view !== void 0) {
              targetView = targetNode.view;
              break;
            }
            targetNode = targetNode.nextSibling;
          }
          view.attachParent(parentView, targetView);
          view.cascadeInsert();
        } else {
          view.mount();
        }
      }
    }
    mount() {
      if (!this.mounted && NodeView.isNodeMounted(this.node) && NodeView.isRootView(this.node)) {
        this.cascadeMount();
        this.cascadeInsert();
      }
    }
    text(value) {
      if (arguments.length === 0) {
        value = this.node.textContent;
        if (value === null) {
          value = void 0;
        }
        return value;
      } else {
        if (value === void 0) {
          value = null;
        }
        this.node.textContent = value;
        return this;
      }
    }
    get parentTransform() {
      return math.Transform.identity();
    }
    get clientBounds() {
      const range = document.createRange();
      range.selectNode(this.node);
      const bounds = range.getBoundingClientRect();
      range.detach();
      return new math.R2Box(bounds.left, bounds.top, bounds.right, bounds.bottom);
    }
    get pageBounds() {
      const range = document.createRange();
      range.selectNode(this.node);
      const bounds = range.getBoundingClientRect();
      range.detach();
      const scrollX = window.pageXOffset;
      const scrollY = window.pageYOffset;
      return new math.R2Box(bounds.left + scrollX, bounds.top + scrollY, bounds.right + scrollX, bounds.bottom + scrollY);
    }
    dispatchEvent(event) {
      return this.node.dispatchEvent(event);
    }
    on(type, listener, options) {
      this.node.addEventListener(type, listener, options);
      return this;
    }
    off(type, listener, options) {
      this.node.removeEventListener(type, listener, options);
      return this;
    }
    init(init) {
      super.init(init);
      if (init.text !== void 0) {
        this.text(init.text);
      }
    }
    static fromNode(node) {
      let view = node.view;
      if (view === void 0) {
        if (node instanceof Element) {
          view = ElementView.fromNode(node);
        } else if (node instanceof Text) {
          view = TextView.fromNode(node);
        } else {
          view = new this(node);
          this.mount(view);
        }
      } else if (!(view instanceof this)) {
        throw new TypeError(view + " not an instance of " + this);
      }
      return view;
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return value;
      } else if (value instanceof View) {
        if (value instanceof this) {
          return value;
        } else {
          throw new TypeError(value + " not an instance of " + this);
        }
      } else if (value instanceof Node) {
        return this.fromNode(value);
      } else if (util.Creatable.is(value)) {
        return value.create();
      } else {
        return this.fromInit(value);
      }
    }
  }
  __decorate([ component.Provider({
    extends: DomProvider,
    type: DomService,
    observes: false,
    service: DomService.global()
  }) ], NodeView.prototype, "domProvider", void 0);
  ModalService.insertModalView = function(modalView) {
    const matteNode = document.body;
    const matteView = matteNode.view;
    if (matteView !== void 0) {
      matteView.appendChild(modalView);
    } else if (modalView instanceof NodeView) {
      matteNode.appendChild(modalView.node);
      modalView.mount();
    } else {
      throw new TypeError("" + modalView);
    }
  };
  class TextView extends NodeView {
    constructor(node) {
      super(node);
    }
    init(init) {
      super.init(init);
    }
    static create(text) {
      if (text === void 0) {
        text = "";
      }
      const node = document.createTextNode(text);
      return new this(node);
    }
    static fromNode(node) {
      let view = node.view;
      if (view === void 0) {
        view = new this(node);
      } else if (!(view instanceof this)) {
        throw new TypeError(view + " not an instance of " + this);
      }
      return view;
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return value;
      } else if (value instanceof View) {
        if (value instanceof this) {
          return value;
        } else {
          throw new TypeError(value + " not an instance of " + this);
        }
      } else if (value instanceof Node) {
        return this.fromNode(value);
      } else if (typeof value === "string") {
        return this.create(value);
      } else if (util.Creatable.is(value)) {
        return value.create();
      } else {
        return this.fromInit(value);
      }
    }
  }
  class ElementView extends NodeView {
    constructor(node) {
      super(node);
      this.initElement(node);
    }
    initElement(node) {
      const themeName = node.getAttribute("swim-theme");
      if (themeName !== null && themeName !== "") {
        let theme;
        if (themeName === "auto") {
          const viewport = Viewport.detect();
          const colorScheme = viewport.colorScheme;
          if (colorScheme === "dark") {
            theme = Theme.dark;
          } else {
            theme = Theme.light;
          }
        } else if (themeName.indexOf(".") < 0) {
          theme = Theme[themeName];
        } else {
          theme = DomService.eval(themeName);
        }
        if (theme instanceof ThemeMatrix) {
          this.theme.setValue(theme, component.Affinity.Extrinsic);
        } else {
          throw new TypeError("unknown swim-theme: " + themeName);
        }
      }
    }
    mountTheme() {
      super.mountTheme();
      if (NodeView.isRootView(this.node)) {
        const themeService = this.themeProvider.service;
        if (themeService !== void 0 && themeService !== null) {
          if (this.mood.hasAffinity(component.Affinity.Intrinsic) && this.mood.value === null) {
            this.mood.setValue(themeService.mood, component.Affinity.Intrinsic);
          }
          if (this.theme.hasAffinity(component.Affinity.Intrinsic) && this.theme.value === null) {
            this.theme.setValue(themeService.theme, component.Affinity.Intrinsic);
          }
        }
      }
    }
    getAttribute(attributeName) {
      return this.node.getAttribute(attributeName);
    }
    setAttribute(attributeName, value) {
      this.willSetAttribute(attributeName, value);
      if (value !== void 0 && value !== null) {
        this.node.setAttribute(attributeName, ToAttributeString(value));
      } else {
        this.node.removeAttribute(attributeName);
      }
      this.onSetAttribute(attributeName, value);
      this.didSetAttribute(attributeName, value);
      return this;
    }
    willSetAttribute(attributeName, value) {
      const observers = this.observerCache.viewWillSetAttributeObservers;
      if (observers !== void 0) {
        for (let i = 0, n = observers.length; i < n; i += 1) {
          const observer = observers[i];
          observer.viewWillSetAttribute(attributeName, value, this);
        }
      }
    }
    onSetAttribute(attributeName, value) {}
    didSetAttribute(attributeName, value) {
      const observers = this.observerCache.viewDidSetAttributeObservers;
      if (observers !== void 0) {
        for (let i = 0, n = observers.length; i < n; i += 1) {
          const observer = observers[i];
          observer.viewDidSetAttribute(attributeName, value, this);
        }
      }
    }
    getStyle(propertyNames) {
      if (typeof CSSStyleValue !== "undefined") {
        const style = this.node.attributeStyleMap;
        if (typeof propertyNames === "string") {
          try {
            return style.get(propertyNames);
          } catch (e) {
            return void 0;
          }
        } else {
          for (let i = 0, n = propertyNames.length; i < n; i += 1) {
            const value = style.get(propertyNames[i]);
            if (value !== void 0) {
              return value;
            }
          }
          return "";
        }
      } else {
        const style = this.node.style;
        if (typeof propertyNames === "string") {
          return style.getPropertyValue(propertyNames);
        } else {
          for (let i = 0, n = propertyNames.length; i < n; i += 1) {
            const value = style.getPropertyValue(propertyNames[i]);
            if (value.length !== 0) {
              return value;
            }
          }
          return "";
        }
      }
    }
    setStyle(propertyName, value, priority) {
      this.willSetStyle(propertyName, value, priority);
      if (typeof CSSStyleValue !== "undefined") {
        if (value !== void 0 && value !== null) {
          const cssValue = ToCssValue(value);
          if (cssValue !== null) {
            try {
              this.node.attributeStyleMap.set(propertyName, cssValue);
            } catch (e) {}
          } else {
            this.node.style.setProperty(propertyName, ToStyleString(value), priority);
          }
        } else {
          this.node.attributeStyleMap.delete(propertyName);
        }
      } else {
        if (value !== void 0 && value !== null) {
          this.node.style.setProperty(propertyName, ToStyleString(value), priority);
        } else {
          this.node.style.removeProperty(propertyName);
        }
      }
      this.onSetStyle(propertyName, value, priority);
      this.didSetStyle(propertyName, value, priority);
      return this;
    }
    willSetStyle(propertyName, value, priority) {
      const observers = this.observerCache.viewWillSetStyleObservers;
      if (observers !== void 0) {
        for (let i = 0, n = observers.length; i < n; i += 1) {
          const observer = observers[i];
          observer.viewWillSetStyle(propertyName, value, priority, this);
        }
      }
    }
    onSetStyle(propertyName, value, priority) {}
    didSetStyle(propertyName, value, priority) {
      const observers = this.observerCache.viewDidSetStyleObservers;
      if (observers !== void 0) {
        for (let i = 0, n = observers.length; i < n; i += 1) {
          const observer = observers[i];
          observer.viewDidSetStyle(propertyName, value, priority, this);
        }
      }
    }
    id(value) {
      if (arguments.length == 0) {
        const id = this.getAttribute("id");
        return id !== null ? id : void 0;
      } else {
        this.setAttribute("id", value);
        return this;
      }
    }
    className(value) {
      if (arguments.length === 0) {
        const className = this.getAttribute("class");
        return className !== null ? className : void 0;
      } else {
        this.setAttribute("class", value);
        return this;
      }
    }
    get classList() {
      return this.node.classList;
    }
    hasClass(className) {
      return this.node.classList.contains(className);
    }
    addClass(...classNames) {
      const classList = this.node.classList;
      for (let i = 0, n = classNames.length; i < n; i += 1) {
        classList.add(classNames[i]);
      }
      return this;
    }
    removeClass(...classNames) {
      const classList = this.node.classList;
      for (let i = 0, n = classNames.length; i < n; i += 1) {
        classList.remove(classNames[i]);
      }
      return this;
    }
    toggleClass(className, state) {
      const classList = this.node.classList;
      if (state === void 0) {
        classList.toggle(className);
      } else if (state === true) {
        classList.add(className);
      } else if (state === false) {
        classList.remove(className);
      }
      return this;
    }
    get clientBounds() {
      const bounds = this.node.getBoundingClientRect();
      return new math.R2Box(bounds.left, bounds.top, bounds.right, bounds.bottom);
    }
    get pageBounds() {
      const bounds = this.node.getBoundingClientRect();
      const scrollX = window.pageXOffset;
      const scrollY = window.pageYOffset;
      return new math.R2Box(bounds.left + scrollX, bounds.top + scrollY, bounds.right + scrollX, bounds.bottom + scrollY);
    }
    on(type, listener, options) {
      this.node.addEventListener(type, listener, options);
      return this;
    }
    off(type, listener, options) {
      this.node.removeEventListener(type, listener, options);
      return this;
    }
    onObserve(observer) {
      super.onObserve(observer);
      if (observer.viewWillSetAttribute !== void 0) {
        this.observerCache.viewWillSetAttributeObservers = util.Arrays.inserted(observer, this.observerCache.viewWillSetAttributeObservers);
      }
      if (observer.viewDidSetAttribute !== void 0) {
        this.observerCache.viewDidSetAttributeObservers = util.Arrays.inserted(observer, this.observerCache.viewDidSetAttributeObservers);
      }
      if (observer.viewWillSetStyle !== void 0) {
        this.observerCache.viewWillSetStyleObservers = util.Arrays.inserted(observer, this.observerCache.viewWillSetStyleObservers);
      }
      if (observer.viewDidSetStyle !== void 0) {
        this.observerCache.viewDidSetStyleObservers = util.Arrays.inserted(observer, this.observerCache.viewDidSetStyleObservers);
      }
    }
    onUnobserve(observer) {
      super.onUnobserve(observer);
      if (observer.viewWillSetAttribute !== void 0) {
        this.observerCache.viewWillSetAttributeObservers = util.Arrays.removed(observer, this.observerCache.viewWillSetAttributeObservers);
      }
      if (observer.viewDidSetAttribute !== void 0) {
        this.observerCache.viewDidSetAttributeObservers = util.Arrays.removed(observer, this.observerCache.viewDidSetAttributeObservers);
      }
      if (observer.viewWillSetStyle !== void 0) {
        this.observerCache.viewWillSetStyleObservers = util.Arrays.removed(observer, this.observerCache.viewWillSetStyleObservers);
      }
      if (observer.viewDidSetStyle !== void 0) {
        this.observerCache.viewDidSetStyleObservers = util.Arrays.removed(observer, this.observerCache.viewDidSetStyleObservers);
      }
    }
    init(init) {
      super.init(init);
      if (init.id !== void 0) {
        this.id(init.id);
      }
      if (init.classList !== void 0) {
        this.addClass(...init.classList);
      }
    }
    static create() {
      let tag = this.tag;
      if (tag === void 0) {
        tag = "div";
      }
      return this.fromTag(tag);
    }
    static fromTag(tag, namespace) {
      if (namespace === void 0) {
        if (tag === "svg") {
          namespace = SvgView.namespace;
        }
      }
      let node;
      if (namespace !== void 0) {
        node = document.createElementNS(namespace, tag);
      } else {
        node = document.createElement(tag);
      }
      return this.fromNode(node);
    }
    static fromNode(node) {
      let view = node.view;
      if (view === void 0) {
        if (node instanceof HTMLElement) {
          view = HtmlView.fromNode(node);
        } else if (node instanceof SVGElement) {
          view = SvgView.fromNode(node);
        } else {
          view = new this(node);
          this.mount(view);
        }
      } else if (!(view instanceof this)) {
        throw new TypeError(view + " not an instance of " + this);
      }
      return view;
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return value;
      } else if (value instanceof View) {
        if (value instanceof this) {
          return value;
        } else {
          throw new TypeError(value + " not an instance of " + this);
        }
      } else if (value instanceof Node) {
        return this.fromNode(value);
      } else if (typeof value === "string") {
        return this.fromTag(value);
      } else if (util.Creatable.is(value)) {
        return value.create();
      } else {
        return this.fromInit(value);
      }
    }
  }
  class HtmlView extends ElementView {
    constructor(node) {
      super(node);
    }
    setChild(key, newChild) {
      if (typeof newChild === "string") {
        newChild = HtmlView.fromTag(newChild);
      }
      return super.setChild(key, newChild);
    }
    appendChild(child, key) {
      if (typeof child === "string") {
        child = HtmlView.fromTag(child);
      }
      return super.appendChild(child, key);
    }
    prependChild(child, key) {
      if (typeof child === "string") {
        child = HtmlView.fromTag(child);
      }
      return super.prependChild(child, key);
    }
    insertChild(child, target, key) {
      if (typeof child === "string") {
        child = HtmlView.fromTag(child);
      }
      return super.insertChild(child, target, key);
    }
    replaceChild(newChild, oldChild) {
      if (typeof newChild === "string") {
        newChild = HtmlView.fromTag(newChild);
      }
      return super.replaceChild(newChild, oldChild);
    }
    onApplyTheme(theme, mood, timing) {
      super.onApplyTheme(theme, mood, timing);
      if (this.node.hasAttribute("swim-theme")) {
        this.applyRootTheme(theme, mood, timing);
      }
    }
    applyRootTheme(theme, mood, timing) {
      const font = theme.getOr(Look.font, Mood.ambient, null);
      if (font !== null) {
        if (font.style !== void 0) {
          this.fontStyle.setState(font.style, void 0, 0);
        }
        if (font.variant !== void 0) {
          this.fontVariant.setState(font.variant, void 0, 0);
        }
        if (font.weight !== void 0) {
          this.fontWeight.setState(font.weight, void 0, 0);
        }
        if (font.stretch !== void 0) {
          this.fontStretch.setState(font.stretch, void 0, 0);
        }
        if (font.size !== null) {
          this.fontSize.setState(font.size, void 0, 0);
        }
        if (font.height !== null) {
          this.lineHeight.setState(font.height, void 0, 0);
        }
        this.fontFamily.setState(font.family, void 0, 0);
      }
      this.backgroundColor.setState(theme.getOr(Look.backgroundColor, Mood.ambient, null), timing, component.Affinity.Intrinsic);
      this.color.setState(theme.getOr(Look.color, Mood.ambient, null), timing, component.Affinity.Intrinsic);
    }
    static isPositioned(element) {
      const style = window.getComputedStyle(element);
      return style.position === "relative" || style.position === "absolute";
    }
    isPositioned() {
      return HtmlView.isPositioned(this.node);
    }
    static parentTransform(element) {
      if (HtmlView.isPositioned(element)) {
        const dx = element.offsetLeft;
        const dy = element.offsetTop;
        if (dx !== 0 || dy !== 0) {
          return math.Transform.translate(-dx, -dy);
        }
      }
      return math.Transform.identity();
    }
    static pageTransform(element) {
      const parentNode = element.parentNode;
      if (parentNode instanceof HTMLElement) {
        return HtmlView.pageTransform(parentNode).transform(HtmlView.parentTransform(element));
      } else {
        return math.Transform.identity();
      }
    }
    get parentTransform() {
      const transform = this.transform.value;
      if (transform !== null) {
        return transform;
      } else if (this.isPositioned()) {
        const dx = this.node.offsetLeft;
        const dy = this.node.offsetTop;
        if (dx !== 0 || dy !== 0) {
          return math.Transform.translate(-dx, -dy);
        }
      }
      return math.Transform.identity();
    }
    get pageTransform() {
      const parentView = this.parent;
      if (parentView !== null) {
        return parentView.pageTransform.transform(this.parentTransform);
      } else {
        const parentNode = this.node.parentNode;
        if (parentNode instanceof HTMLElement) {
          return HtmlView.pageTransform(parentNode).transform(this.parentTransform);
        } else {
          return math.Transform.identity();
        }
      }
    }
    on(type, listener, options) {
      this.node.addEventListener(type, listener, options);
      return this;
    }
    off(type, listener, options) {
      this.node.removeEventListener(type, listener, options);
      return this;
    }
    initAttributes(init) {
      if (init.autocomplete !== void 0) {
        this.autocomplete(init.autocomplete);
      }
      if (init.checked !== void 0) {
        this.checked(init.checked);
      }
      if (init.colspan !== void 0) {
        this.colspan(init.colspan);
      }
      if (init.disabled !== void 0) {
        this.disabled(init.disabled);
      }
      if (init.placeholder !== void 0) {
        this.placeholder(init.placeholder);
      }
      if (init.rowspan !== void 0) {
        this.rowspan(init.rowspan);
      }
      if (init.selected !== void 0) {
        this.selected(init.selected);
      }
      if (init.title !== void 0) {
        this.title(init.title);
      }
      if (init.type !== void 0) {
        this.type(init.type);
      }
      if (init.value !== void 0) {
        this.value(init.value);
      }
    }
    initStyle(init) {
      StyleMap.init(this, init);
    }
    init(init) {
      super.init(init);
      if (init.attributes !== void 0) {
        this.initAttributes(init.attributes);
      }
      if (init.style !== void 0) {
        this.initStyle(init.style);
      }
    }
    static create() {
      return this.fromTag(this.tag);
    }
    static fromTag(tag) {
      if (tag === "style" && this !== StyleView) {
        return StyleView.create();
      } else if (tag === "svg") {
        return SvgView.create();
      } else {
        const node = document.createElement(tag);
        return this.fromNode(node);
      }
    }
    static fromNode(node) {
      let view = node.view;
      if (view === void 0) {
        view = new this(node);
        this.mount(view);
      } else if (!(view instanceof this)) {
        throw new TypeError(view + " not an instance of " + this);
      }
      return view;
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return value;
      } else if (value instanceof View) {
        if (value instanceof this) {
          return value;
        } else {
          throw new TypeError(value + " not an instance of " + this);
        }
      } else if (value instanceof Node) {
        return this.fromNode(value);
      } else if (typeof value === "string") {
        return this.fromTag(value);
      } else if (util.Creatable.is(value)) {
        return value.create();
      } else {
        return this.fromInit(value);
      }
    }
    static forTag(tag) {
      if (tag === this.tag) {
        return this;
      } else {
        return new HtmlViewTagFactory(this, tag);
      }
    }
  }
  HtmlView.tag = "div";
  __decorate([ AttributeAnimator({
    attributeName: "autocomplete",
    type: String
  }) ], HtmlView.prototype, "autocomplete", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "checked",
    type: Boolean
  }) ], HtmlView.prototype, "checked", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "colspan",
    type: Number
  }) ], HtmlView.prototype, "colspan", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "disabled",
    type: Boolean
  }) ], HtmlView.prototype, "disabled", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "placeholder",
    type: String
  }) ], HtmlView.prototype, "placeholder", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "rowspan",
    type: Number
  }) ], HtmlView.prototype, "rowspan", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "selected",
    type: Boolean
  }) ], HtmlView.prototype, "selected", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "title",
    type: String
  }) ], HtmlView.prototype, "title", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "type",
    type: String
  }) ], HtmlView.prototype, "type", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "value",
    type: String
  }) ], HtmlView.prototype, "value", void 0);
  StyleMap.define(HtmlView.prototype);
  class HtmlViewTagFactory {
    constructor(factory, tag) {
      this.factory = factory;
      this.tag = tag;
    }
    create() {
      return this.fromTag(this.tag);
    }
    fromTag(tag) {
      const node = document.createElement(tag);
      return this.fromNode(node);
    }
    fromNode(node) {
      return this.factory.fromNode(node);
    }
    fromInit(init) {
      let type = init.type;
      if (type === void 0) {
        type = this;
      }
      const view = type.create();
      view.init(init);
      return view;
    }
    fromAny(value) {
      return this.factory.fromAny(value);
    }
  }
  class StyleView extends HtmlView {
    constructor(node) {
      super(node);
    }
    onApplyTheme(theme, mood, timing) {
      super.onApplyTheme(theme, mood, timing);
      this.sheet.applyTheme(theme, mood, timing);
    }
    init(init) {
      super.init(init);
    }
  }
  StyleView.tag = "style";
  __decorate([ StyleSheet({
    createStylesheet() {
      return this.owner.node.sheet;
    }
  }) ], StyleView.prototype, "sheet", void 0);
  class SvgView extends ElementView {
    constructor(node) {
      super(node);
    }
    setChild(key, newChild) {
      if (typeof newChild === "string") {
        newChild = SvgView.fromTag(newChild);
      }
      return super.setChild(key, newChild);
    }
    appendChild(child, key) {
      if (typeof child === "string") {
        child = SvgView.fromTag(child);
      }
      return super.appendChild(child, key);
    }
    prependChild(child, key) {
      if (typeof child === "string") {
        child = SvgView.fromTag(child);
      }
      return super.prependChild(child, key);
    }
    insertChild(child, target, key) {
      if (typeof child === "string") {
        child = SvgView.fromTag(child);
      }
      return super.insertChild(child, target, key);
    }
    replaceChild(newChild, oldChild) {
      if (typeof newChild === "string") {
        newChild = SvgView.fromTag(newChild);
      }
      return super.replaceChild(newChild, oldChild);
    }
    font(value, timing) {
      if (value === void 0) {
        const style = this.fontStyle.value;
        const variant = this.fontVariant.value;
        const weight = this.fontWeight.value;
        const stretch = this.fontStretch.value;
        const size = this.fontSize.value;
        const height = this.lineHeight.value;
        const family = this.fontFamily.value;
        if (family !== void 0) {
          return Font.create(style, variant, weight, stretch, size, height, family);
        } else {
          return null;
        }
      } else {
        if (value !== null) {
          value = Font.fromAny(value);
          if (value.style !== void 0) {
            this.fontStyle.setState(value.style, timing);
          }
          if (value.variant !== void 0) {
            this.fontVariant.setState(value.variant, timing);
          }
          if (value.weight !== void 0) {
            this.fontWeight.setState(value.weight, timing);
          }
          if (value.stretch !== void 0) {
            this.fontStretch.setState(value.stretch, timing);
          }
          if (value.size !== void 0) {
            this.fontSize.setState(value.size, timing);
          }
          if (value.height !== void 0) {
            this.lineHeight.setState(value.height, timing);
          }
          this.fontFamily.setState(value.family, timing);
        } else {
          this.fontStyle.setState(void 0, timing);
          this.fontVariant.setState(void 0, timing);
          this.fontWeight.setState(void 0, timing);
          this.fontStretch.setState(void 0, timing);
          this.fontSize.setState(null, timing);
          this.lineHeight.setState(null, timing);
          this.fontFamily.setState(void 0, timing);
        }
        return this;
      }
    }
    get parentTransform() {
      const transform = this.transform.value;
      return transform !== null ? transform : math.Transform.identity();
    }
    on(type, listener, options) {
      this.node.addEventListener(type, listener, options);
      return this;
    }
    off(type, listener, options) {
      this.node.removeEventListener(type, listener, options);
      return this;
    }
    initAttributes(init) {
      if (init.alignmentBaseline !== void 0) {
        this.alignmentBaseline(init.alignmentBaseline);
      }
      if (init.clipPath !== void 0) {
        this.clipPath(init.clipPath);
      }
      if (init.cursor !== void 0) {
        this.cursor(init.cursor);
      }
      if (init.cx !== void 0) {
        this.cx(init.cx);
      }
      if (init.cy !== void 0) {
        this.cy(init.cy);
      }
      if (init.cy !== void 0) {
        this.cy(init.cy);
      }
      if (init.d !== void 0) {
        this.d(init.d);
      }
      if (init.dx !== void 0) {
        this.dx(init.dx);
      }
      if (init.dy !== void 0) {
        this.dy(init.dy);
      }
      if (init.edgeMode !== void 0) {
        this.edgeMode(init.edgeMode);
      }
      if (init.fill !== void 0) {
        this.fill(init.fill);
      }
      if (init.fillRule !== void 0) {
        this.fillRule(init.fillRule);
      }
      if (init.floodColor !== void 0) {
        this.floodColor(init.floodColor);
      }
      if (init.floodOpacity !== void 0) {
        this.floodOpacity(init.floodOpacity);
      }
      if (init.height !== void 0) {
        this.height(init.height);
      }
      if (init.in !== void 0) {
        this.in(init.in);
      }
      if (init.in2 !== void 0) {
        this.in2(init.in2);
      }
      if (init.lengthAdjust !== void 0) {
        this.lengthAdjust(init.lengthAdjust);
      }
      if (init.mode !== void 0) {
        this.mode(init.mode);
      }
      if (init.opacity !== void 0) {
        this.opacity(init.opacity);
      }
      if (init.pointerEvents !== void 0) {
        this.pointerEvents(init.pointerEvents);
      }
      if (init.points !== void 0) {
        this.points(init.points);
      }
      if (init.preserveAspectRatio !== void 0) {
        this.preserveAspectRatio(init.preserveAspectRatio);
      }
      if (init.r !== void 0) {
        this.r(init.r);
      }
      if (init.result !== void 0) {
        this.result(init.result);
      }
      if (init.stdDeviation !== void 0) {
        this.stdDeviation(init.stdDeviation);
      }
      if (init.stroke !== void 0) {
        this.stroke(init.stroke);
      }
      if (init.strokeDasharray !== void 0) {
        this.strokeDasharray(init.strokeDasharray);
      }
      if (init.strokeDashoffset !== void 0) {
        this.strokeDashoffset(init.strokeDashoffset);
      }
      if (init.strokeLinecap !== void 0) {
        this.strokeLinecap(init.strokeLinecap);
      }
      if (init.strokeLinejoin !== void 0) {
        this.strokeLinejoin(init.strokeLinejoin);
      }
      if (init.strokeMiterlimit !== void 0) {
        this.strokeMiterlimit(init.strokeMiterlimit);
      }
      if (init.strokeWidth !== void 0) {
        this.strokeWidth(init.strokeWidth);
      }
      if (init.textAnchor !== void 0) {
        this.textAnchor(init.textAnchor);
      }
      if (init.textLength !== void 0) {
        this.textLength(init.textLength);
      }
      if (init.transform !== void 0) {
        this.transform(init.transform);
      }
      if (init.type !== void 0) {
        this.type(init.type);
      }
      if (init.values !== void 0) {
        this.values(init.values);
      }
      if (init.viewBox !== void 0) {
        this.viewBox(init.viewBox);
      }
      if (init.width !== void 0) {
        this.width(init.width);
      }
      if (init.x !== void 0) {
        this.x(init.x);
      }
      if (init.x1 !== void 0) {
        this.x1(init.x1);
      }
      if (init.x2 !== void 0) {
        this.x2(init.x2);
      }
      if (init.y !== void 0) {
        this.y(init.y);
      }
      if (init.y1 !== void 0) {
        this.y1(init.y1);
      }
      if (init.y2 !== void 0) {
        this.y2(init.y2);
      }
    }
    initStyle(init) {
      if (init.cssTransform !== void 0) {
        this.cssTransform(init.cssTransform);
      }
      if (init.filter !== void 0) {
        this.filter(init.filter);
      }
      if (init.fontFamily !== void 0) {
        this.fontFamily(init.fontFamily);
      }
      if (init.fontSize !== void 0) {
        this.fontSize(init.fontSize);
      }
      if (init.fontStretch !== void 0) {
        this.fontStretch(init.fontStretch);
      }
      if (init.fontStyle !== void 0) {
        this.fontStyle(init.fontStyle);
      }
      if (init.fontVariant !== void 0) {
        this.fontVariant(init.fontVariant);
      }
      if (init.fontWeight !== void 0) {
        this.fontWeight(init.fontWeight);
      }
      if (init.lineHeight !== void 0) {
        this.lineHeight(init.lineHeight);
      }
      if (init.touchAction !== void 0) {
        this.touchAction(init.touchAction);
      }
    }
    init(init) {
      super.init(init);
      if (init.attributes !== void 0) {
        this.initAttributes(init.attributes);
      }
      if (init.style !== void 0) {
        this.initStyle(init.style);
      }
    }
    static create() {
      return this.fromTag(this.tag);
    }
    static fromTag(tag) {
      const node = document.createElementNS(this.namespace, tag);
      return this.fromNode(node);
    }
    static fromNode(node) {
      let view = node.view;
      if (view === void 0) {
        view = new this(node);
        this.mount(view);
      } else if (!(view instanceof this)) {
        throw new TypeError(view + " not an instance of " + this);
      }
      return view;
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return value;
      } else if (value instanceof View) {
        if (value instanceof this) {
          return value;
        } else {
          throw new TypeError(value + " not an instance of " + this);
        }
      } else if (value instanceof Node) {
        return this.fromNode(value);
      } else if (typeof value === "string") {
        return this.fromTag(value);
      } else if (util.Creatable.is(value)) {
        return value.create();
      } else {
        return this.fromInit(value);
      }
    }
    static forTag(tag) {
      if (tag === this.tag) {
        return this;
      } else {
        return new SvgViewTagFactory(this, tag);
      }
    }
  }
  SvgView.tag = "svg";
  SvgView.namespace = "http://www.w3.org/2000/svg";
  __decorate([ AttributeAnimator({
    attributeName: "alignment-baseline",
    type: String
  }) ], SvgView.prototype, "alignmentBaseline", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "clip-path",
    type: String
  }) ], SvgView.prototype, "clipPath", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "cursor",
    type: String
  }) ], SvgView.prototype, "cursor", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "cx",
    type: Number
  }) ], SvgView.prototype, "cx", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "cy",
    type: Number
  }) ], SvgView.prototype, "cy", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "d",
    type: String
  }) ], SvgView.prototype, "d", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "dx",
    type: math.Length,
    value: null
  }) ], SvgView.prototype, "dx", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "dy",
    type: math.Length,
    value: null
  }) ], SvgView.prototype, "dy", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "edgeMode",
    type: String
  }) ], SvgView.prototype, "edgeMode", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "fill",
    type: Color,
    value: null
  }) ], SvgView.prototype, "fill", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "fill-rule",
    type: String
  }) ], SvgView.prototype, "fillRule", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "flood-color",
    type: Color,
    value: null
  }) ], SvgView.prototype, "floodColor", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "flood-opacity",
    type: Number
  }) ], SvgView.prototype, "floodOpacity", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "height",
    type: math.Length,
    value: null
  }) ], SvgView.prototype, "height", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "in",
    type: String
  }) ], SvgView.prototype, "in", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "in2",
    type: String
  }) ], SvgView.prototype, "in2", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "lengthAdjust",
    type: String
  }) ], SvgView.prototype, "lengthAdjust", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "mode",
    type: String
  }) ], SvgView.prototype, "mode", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "opacity",
    type: Number
  }) ], SvgView.prototype, "opacity", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "pointer-events",
    type: String
  }) ], SvgView.prototype, "pointerEvents", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "points",
    type: String
  }) ], SvgView.prototype, "points", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "preserveAspectRatio",
    type: Boolean
  }) ], SvgView.prototype, "preserveAspectRatio", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "r",
    type: Number
  }) ], SvgView.prototype, "r", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "result",
    type: String
  }) ], SvgView.prototype, "result", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "stdDeviation",
    type: Number
  }) ], SvgView.prototype, "stdDeviation", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "stroke",
    type: Color,
    value: null
  }) ], SvgView.prototype, "stroke", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "stroke-dasharray",
    type: String
  }) ], SvgView.prototype, "strokeDasharray", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "stroke-dashoffset",
    type: Number
  }) ], SvgView.prototype, "strokeDashoffset", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "stroke-linecap",
    type: String
  }) ], SvgView.prototype, "strokeLinecap", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "stroke-linejoin",
    type: String
  }) ], SvgView.prototype, "strokeLinejoin", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "stroke-miterlimit",
    type: Number
  }) ], SvgView.prototype, "strokeMiterlimit", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "stroke-width",
    type: Number
  }) ], SvgView.prototype, "strokeWidth", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "text-anchor",
    type: String
  }) ], SvgView.prototype, "textAnchor", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "textLength",
    type: math.Length,
    value: null
  }) ], SvgView.prototype, "textLength", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "transform",
    type: math.Transform,
    value: null
  }) ], SvgView.prototype, "transform", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "type",
    type: String
  }) ], SvgView.prototype, "type", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "values",
    type: String
  }) ], SvgView.prototype, "values", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "viewBox",
    type: String
  }) ], SvgView.prototype, "viewBox", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "width",
    type: math.Length,
    value: null
  }) ], SvgView.prototype, "width", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "x",
    type: Number
  }) ], SvgView.prototype, "x", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "x1",
    type: Number
  }) ], SvgView.prototype, "x1", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "x2",
    type: Number
  }) ], SvgView.prototype, "x2", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "y",
    type: Number
  }) ], SvgView.prototype, "y", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "y1",
    type: Number
  }) ], SvgView.prototype, "y1", void 0);
  __decorate([ AttributeAnimator({
    attributeName: "y2",
    type: Number
  }) ], SvgView.prototype, "y2", void 0);
  __decorate([ StyleAnimator({
    propertyNames: "transform",
    type: math.Transform,
    value: null
  }) ], SvgView.prototype, "cssTransform", void 0);
  __decorate([ StyleAnimator({
    propertyNames: "filter",
    type: String
  }) ], SvgView.prototype, "filter", void 0);
  __decorate([ StyleAnimator({
    propertyNames: "font-family",
    type: FontFamily
  }) ], SvgView.prototype, "fontFamily", void 0);
  __decorate([ StyleAnimator({
    propertyNames: "font-size",
    type: math.Length,
    value: null
  }) ], SvgView.prototype, "fontSize", void 0);
  __decorate([ StyleAnimator({
    propertyNames: "font-stretch",
    type: String
  }) ], SvgView.prototype, "fontStretch", void 0);
  __decorate([ StyleAnimator({
    propertyNames: "font-style",
    type: String
  }) ], SvgView.prototype, "fontStyle", void 0);
  __decorate([ StyleAnimator({
    propertyNames: "font-variant",
    type: String
  }) ], SvgView.prototype, "fontVariant", void 0);
  __decorate([ StyleAnimator({
    propertyNames: "font-weight",
    type: String
  }) ], SvgView.prototype, "fontWeight", void 0);
  __decorate([ StyleAnimator({
    propertyNames: "line-height",
    type: math.Length,
    value: null
  }) ], SvgView.prototype, "lineHeight", void 0);
  __decorate([ StyleAnimator({
    propertyNames: "touch-action",
    type: String
  }) ], SvgView.prototype, "touchAction", void 0);
  class SvgViewTagFactory {
    constructor(factory, tag) {
      this.factory = factory;
      this.tag = tag;
    }
    get namespace() {
      return SvgView.namespace;
    }
    create() {
      return this.fromTag(this.tag);
    }
    fromTag(tag) {
      const node = document.createElementNS(this.namespace, tag);
      return this.fromNode(node);
    }
    fromNode(node) {
      return this.factory.fromNode(node);
    }
    fromInit(init) {
      let type = init.type;
      if (type === void 0) {
        type = this;
      }
      const view = type.create();
      view.init(init);
      return view;
    }
    fromAny(value) {
      return this.factory.fromAny(value);
    }
  }
  class Sprite {
    constructor(sheet, rowIndex, colIndex) {
      this.sheet = sheet;
      this.rowIndex = rowIndex;
      this.colIndex = colIndex;
    }
    get width() {
      return this.sheet.spriteWidth;
    }
    get height() {
      return this.sheet.spriteHeight;
    }
    get pixelRatio() {
      return this.sheet.pixelRatio;
    }
    getRenderer() {
      return this.sheet.getSpriteRenderer(this.rowIndex, this.colIndex);
    }
    clear() {
      return this.sheet.clearSprite(this.rowIndex, this.colIndex);
    }
    draw(context, frame) {
      this.sheet.drawSprite(context, frame, this.rowIndex, this.colIndex);
    }
    release() {
      this.sheet.releaseSprite(this);
    }
  }
  class SpriteSheet {
    constructor(spriteWidth, spriteHeight, canvasWidth, canvasHeight, pixelRatio) {
      const rowCount = Math.floor(canvasHeight / spriteHeight);
      const colCount = Math.floor(canvasWidth / spriteWidth);
      const spriteCount = rowCount * colCount;
      const sprites = new Array(spriteCount);
      const freeSprites = new Array(spriteCount);
      const canvas = document.createElement("canvas");
      canvas.width = canvasWidth * pixelRatio;
      canvas.height = canvasHeight * pixelRatio;
      canvas.style.width = canvasWidth + "px";
      canvas.style.height = canvasHeight + "px";
      const context = canvas.getContext("2d");
      const renderer = new CanvasRenderer(context, math.Transform.identity(), pixelRatio);
      this.spriteWidth = spriteWidth;
      this.spriteHeight = spriteHeight;
      this.sprites = sprites;
      this.freeSprites = freeSprites;
      this.canvas = canvas;
      this.renderer = renderer;
      this.nextSheet = null;
      this.createSprites(sprites, rowCount, colCount);
      for (let k = 0; k < spriteCount; k += 1) {
        freeSprites[k] = sprites[spriteCount - k - 1];
      }
    }
    createSprites(sprites, rowCount, colCount) {
      let k = 0;
      for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
        for (let colIndex = 0; colIndex < colCount; colIndex += 1) {
          const sprite = this.createSprite(rowIndex, colIndex);
          sprites[k] = sprite;
          k += 1;
        }
      }
    }
    createSprite(rowIndex, colIndex) {
      return new Sprite(this, rowIndex, colIndex);
    }
    get pixelRatio() {
      return this.renderer.pixelRatio;
    }
    get canvasWidth() {
      return this.canvas.width / this.pixelRatio;
    }
    get canvasHeight() {
      return this.canvas.height / this.pixelRatio;
    }
    get rowCount() {
      return Math.floor(this.canvasHeight / this.spriteHeight);
    }
    get colCount() {
      return Math.floor(this.canvasWidth / this.spriteWidth);
    }
    get spriteCount() {
      return this.rowCount * this.colCount;
    }
    get freeCount() {
      return this.freeSprites.length;
    }
    static acquireNextFreeSheet(sheet) {
      do {
        const nextSheet = sheet.nextSheet;
        if (nextSheet === null) {
          return null;
        } else if (nextSheet.freeCount !== 0) {
          sheet.nextSheet = nextSheet.nextSheet;
          nextSheet.nextSheet = null;
          return nextSheet;
        } else {
          sheet = nextSheet;
        }
      } while (true);
    }
    acquireSprite() {
      const sprite = this.freeSprites.pop();
      return sprite !== void 0 ? sprite : null;
    }
    releaseSprite(sprite) {
      this.clearSprite(sprite.rowIndex, sprite.colIndex);
      this.freeSprites.push(sprite);
    }
    clearSprite(rowIndex, colIndex) {
      const renderer = this.getSpriteRenderer(rowIndex, colIndex);
      renderer.context.clearRect(0, 0, this.spriteWidth, this.spriteHeight);
    }
    getSpriteRenderer(rowIndex, colIndex) {
      const renderer = this.renderer;
      const context = renderer.context;
      const pixelRatio = renderer.pixelRatio;
      const dx = rowIndex * this.spriteWidth * pixelRatio;
      const dy = colIndex * this.spriteHeight * pixelRatio;
      context.setTransform(pixelRatio, 0, 0, pixelRatio, dx, dy);
      renderer.setTransform(math.Transform.affine(pixelRatio, 0, 0, pixelRatio, dx, dy));
      return renderer;
    }
    drawSprite(context, frame, rowIndex, colIndex) {
      const spritePixelRatio = this.renderer.pixelRatio;
      const spriteWidth = this.spriteWidth * spritePixelRatio;
      const spriteHeight = this.spriteHeight * spritePixelRatio;
      const spriteX = rowIndex * spriteWidth;
      const spriteY = colIndex * spriteHeight;
      context.drawImage(this.canvas, spriteX, spriteY, spriteWidth, spriteHeight, frame.x, frame.y, this.spriteWidth, this.spriteHeight);
    }
  }
  class SpriteService {
    constructor(canvasWidth, canvasHeight, pixelRatio, minSizeClass, maxSizeClass) {
      if (pixelRatio === void 0) {
        pixelRatio = window.devicePixelRatio || 1;
      }
      if (canvasWidth === void 0) {
        canvasWidth = Math.floor(SpriteService.TextureWidth / pixelRatio);
      }
      if (canvasHeight === void 0) {
        canvasHeight = Math.floor(SpriteService.TextureHeight / pixelRatio);
      }
      if (maxSizeClass === void 0) {
        maxSizeClass = Math.floor(Math.log2(Math.min(canvasWidth, canvasHeight) / 4));
      }
      if (minSizeClass === void 0) {
        minSizeClass = Math.min(4, maxSizeClass);
      }
      this.canvasWidth = canvasWidth;
      this.canvasHeight = canvasHeight;
      this.minSizeClass = minSizeClass;
      this.maxSizeClass = maxSizeClass;
      this.pixelRatio = pixelRatio;
      const slabCount = maxSizeClass - minSizeClass + 1;
      const slabs = new Array(slabCount);
      for (let i = 0; i < slabCount; i += 1) {
        slabs[i] = null;
      }
      this.slabs = slabs;
    }
    createSlab(sizeClass) {
      const spriteSize = 1 << sizeClass;
      return new SpriteSheet(spriteSize, spriteSize, this.canvasWidth, this.canvasHeight, this.pixelRatio);
    }
    getFreeSlab(sizeClass) {
      sizeClass = Math.max(this.minSizeClass, sizeClass);
      if (sizeClass <= this.maxSizeClass) {
        const index = sizeClass - this.minSizeClass;
        const slabs = this.slabs;
        let slab = slabs[index];
        if (slab === null) {
          slab = this.createSlab(sizeClass);
          slabs[index] = slab;
        } else if (slab.freeCount === 0) {
          let freeSlab = SpriteSheet.acquireNextFreeSheet(slab);
          if (freeSlab === null) {
            freeSlab = this.createSlab(sizeClass);
          }
          freeSlab.nextSheet = slab;
          slab = freeSlab;
          slabs[index] = slab;
        }
        return slab;
      }
      return null;
    }
    createSheet(width, height) {
      return new SpriteSheet(width, height, width, height, this.pixelRatio);
    }
    getFreeSheet(width, height) {
      const widthClass = Math.ceil(Math.log2(width));
      const heightClass = Math.ceil(Math.log2(height));
      const sizeClass = Math.max(widthClass, heightClass);
      let sheet = this.getFreeSlab(sizeClass);
      if (sheet === null) {
        sheet = this.createSheet(width, height);
      }
      return sheet;
    }
    acquireSprite(width, height) {
      const sheet = this.getFreeSheet(width, height);
      const sprite = sheet.acquireSprite();
      return sprite;
    }
    static global() {
      return new SpriteService;
    }
  }
  SpriteService.TextureWidth = 512;
  SpriteService.TextureHeight = 512;
  __decorate([ util.Lazy ], SpriteService, "global", null);
  class GraphicsRenderer {}
  class GraphicsView extends View {
    constructor() {
      super();
      this.ownViewFrame = null;
      this.eventHandlers = null;
      this.hoverSet = null;
    }
    needsProcess(processFlags, viewContext) {
      if ((this.flags & View.NeedsAnimate) === 0) {
        processFlags &= ~View.NeedsAnimate;
      }
      return processFlags;
    }
    renderViewOutline(viewBox, context, outlineColor, outlineWidth) {
      if (viewBox.isDefined()) {
        const contextLineWidth = context.lineWidth;
        const contextStrokeStyle = context.strokeStyle;
        context.beginPath();
        context.moveTo(viewBox.xMin, viewBox.yMin);
        context.lineTo(viewBox.xMin, viewBox.yMax);
        context.lineTo(viewBox.xMax, viewBox.yMax);
        context.lineTo(viewBox.xMax, viewBox.yMin);
        context.closePath();
        context.lineWidth = outlineWidth;
        context.strokeStyle = outlineColor.toString();
        context.stroke();
        context.lineWidth = contextLineWidth;
        context.strokeStyle = contextStrokeStyle;
      }
    }
    get viewFrame() {
      let viewFrame = this.ownViewFrame;
      if (viewFrame === null) {
        viewFrame = this.deriveViewFrame();
      }
      return viewFrame;
    }
    setViewFrame(viewFrame) {
      this.ownViewFrame = viewFrame;
    }
    deriveViewFrame() {
      const parent = this.parent;
      if (parent instanceof GraphicsView || parent instanceof CanvasView) {
        return parent.viewFrame;
      } else {
        return math.R2Box.undefined();
      }
    }
    cullViewFrame(viewFrame = this.viewFrame) {
      this.setCulled(!viewFrame.intersects(this.viewBounds));
    }
    get ownViewBounds() {
      return null;
    }
    deriveViewBounds() {
      let viewBounds;
      let child = this.firstChild;
      while (child !== null) {
        if (child instanceof GraphicsView && !child.hidden && !child.unbounded) {
          const childViewBounds = child.viewBounds;
          if (childViewBounds.isDefined()) {
            if (viewBounds !== void 0) {
              viewBounds = viewBounds.union(childViewBounds);
            } else {
              viewBounds = childViewBounds;
            }
          }
        }
        child = child.nextSibling;
      }
      if (viewBounds === void 0) {
        viewBounds = this.viewFrame;
      }
      return viewBounds;
    }
    get hitBounds() {
      return this.viewBounds;
    }
    deriveHitBounds() {
      let hitBounds;
      let child = this.firstChild;
      while (child !== null) {
        if (child instanceof GraphicsView && !child.hidden && !child.intangible) {
          const childHitBounds = child.hitBounds;
          if (hitBounds === void 0) {
            hitBounds = childHitBounds;
          } else {
            hitBounds = hitBounds.union(childHitBounds);
          }
        }
        child = child.nextSibling;
      }
      if (hitBounds === void 0) {
        hitBounds = this.viewBounds;
      }
      return hitBounds;
    }
    cascadeHitTest(x, y, baseViewContext) {
      if (!this.hidden && !this.culled && !this.intangible) {
        const hitBounds = this.hitBounds;
        if (hitBounds.contains(x, y)) {
          const viewContext = this.extendViewContext(baseViewContext);
          let hit = this.hitTestChildren(x, y, viewContext);
          if (hit === null) {
            const outerViewContext = ViewContext.current;
            try {
              ViewContext.current = viewContext;
              this.setFlags(this.flags | View.ContextualFlag);
              hit = this.hitTest(x, y, viewContext);
            } finally {
              this.setFlags(this.flags & ~View.ContextualFlag);
              ViewContext.current = outerViewContext;
            }
          }
          return hit;
        }
      }
      return null;
    }
    hitTest(x, y, viewContext) {
      return null;
    }
    hitTestChildren(x, y, viewContext) {
      let child = this.firstChild;
      while (child !== null) {
        if (child instanceof GraphicsView) {
          const hit = this.hitTestChild(child, x, y, viewContext);
          if (hit !== null) {
            return hit;
          }
        }
        child = child.nextSibling;
      }
      return null;
    }
    hitTestChild(child, x, y, viewContext) {
      return child.cascadeHitTest(x, y, viewContext);
    }
    get parentTransform() {
      return math.Transform.identity();
    }
    get clientBounds() {
      const inverseClientTransform = this.clientTransform.inverse();
      return this.viewBounds.transform(inverseClientTransform);
    }
    get popoverFrame() {
      const inversePageTransform = this.pageTransform.inverse();
      return this.viewBounds.transform(inversePageTransform);
    }
    on(type, listener, options) {
      let eventHandlers = this.eventHandlers;
      if (eventHandlers === null) {
        eventHandlers = {};
        this.eventHandlers = eventHandlers;
      }
      let handlers = eventHandlers[type];
      const capture = typeof options === "boolean" ? options : typeof options === "object" && options !== null && options.capture || false;
      const passive = options && typeof options === "object" && options.passive || false;
      const once = options && typeof options === "object" && options.once || false;
      let handler;
      if (handlers === void 0) {
        handler = {
          listener: listener,
          capture: capture,
          passive: passive,
          once: once
        };
        handlers = [ handler ];
        eventHandlers[type] = handlers;
      } else {
        const n = handlers.length;
        let i = 0;
        while (i < n) {
          handler = handlers[i];
          if (handler.listener === listener && handler.capture === capture) {
            break;
          }
          i += 1;
        }
        if (i < n) {
          handler.passive = passive;
          handler.once = once;
        } else {
          handler = {
            listener: listener,
            capture: capture,
            passive: passive,
            once: once
          };
          handlers.push(handler);
        }
      }
      return this;
    }
    off(type, listener, options) {
      const eventHandlers = this.eventHandlers;
      if (eventHandlers !== null) {
        const handlers = eventHandlers[type];
        if (handlers !== void 0) {
          const capture = typeof options === "boolean" ? options : typeof options === "object" && options !== null && options.capture || false;
          const n = handlers.length;
          let i = 0;
          while (i < n) {
            const handler = handlers[i];
            if (handler.listener === listener && handler.capture === capture) {
              handlers.splice(i, 1);
              if (handlers.length === 0) {
                delete eventHandlers[type];
              }
              break;
            }
            i += 1;
          }
        }
      }
      return this;
    }
    handleEvent(event) {
      const type = event.type;
      const eventHandlers = this.eventHandlers;
      if (eventHandlers !== null) {
        const handlers = eventHandlers[type];
        if (handlers !== void 0) {
          let i = 0;
          while (i < handlers.length) {
            const handler = handlers[i];
            if (!handler.capture) {
              const listener = handler.listener;
              if (typeof listener === "function") {
                listener.call(this, event);
              } else if (typeof listener === "object" && listener !== null) {
                listener.handleEvent(event);
              }
              if (handler.once) {
                handlers.splice(i, 1);
                continue;
              }
            }
            i += 1;
          }
          if (handlers.length === 0) {
            delete eventHandlers[type];
          }
        }
      }
      if (type === "mouseover") {
        this.onMouseOver(event);
      } else if (type === "mouseout") {
        this.onMouseOut(event);
      } else if (type === "pointerover") {
        this.onPointerOver(event);
      } else if (type === "pointerout") {
        this.onPointerOut(event);
      }
    }
    bubbleEvent(event) {
      this.handleEvent(event);
      let next;
      if (event.bubbles && !event.cancelBubble) {
        const parent = this.parent;
        if (parent instanceof GraphicsView || parent instanceof CanvasView) {
          next = parent.bubbleEvent(event);
        } else {
          next = parent;
        }
      } else {
        next = null;
      }
      return next;
    }
    dispatchEvent(event) {
      event.targetView = this;
      const next = this.bubbleEvent(event);
      if (next !== null) {
        return next.dispatchEvent(event);
      } else {
        return !event.cancelBubble;
      }
    }
    isHovering() {
      const hoverSet = this.hoverSet;
      return hoverSet !== null && Object.keys(hoverSet).length !== 0;
    }
    onMouseOver(event) {
      let hoverSet = this.hoverSet;
      if (hoverSet === null) {
        hoverSet = {};
        this.hoverSet = hoverSet;
      }
      if (hoverSet.mouse === void 0) {
        hoverSet.mouse = null;
        const eventHandlers = this.eventHandlers;
        if (eventHandlers !== null && eventHandlers.mouseenter !== void 0) {
          const enterEvent = new MouseEvent("mouseenter", {
            bubbles: false,
            button: event.button,
            buttons: event.buttons,
            altKey: event.altKey,
            ctrlKey: event.ctrlKey,
            metaKey: event.metaKey,
            shiftKey: event.shiftKey,
            clientX: event.clientX,
            clientY: event.clientY,
            screenX: event.screenX,
            screenY: event.screenY,
            movementX: event.movementX,
            movementY: event.movementY,
            view: event.view,
            detail: event.detail,
            relatedTarget: event.relatedTarget
          });
          enterEvent.targetView = this;
          enterEvent.relatedTargetView = event.relatedTargetView;
          this.handleEvent(enterEvent);
        }
      }
    }
    onMouseOut(event) {
      const hoverSet = this.hoverSet;
      if (hoverSet !== null && hoverSet.mouse !== void 0) {
        delete hoverSet.mouse;
        const eventHandlers = this.eventHandlers;
        if (eventHandlers !== null && eventHandlers.mouseleave !== void 0) {
          const leaveEvent = new MouseEvent("mouseleave", {
            bubbles: false,
            button: event.button,
            buttons: event.buttons,
            altKey: event.altKey,
            ctrlKey: event.ctrlKey,
            metaKey: event.metaKey,
            shiftKey: event.shiftKey,
            clientX: event.clientX,
            clientY: event.clientY,
            screenX: event.screenX,
            screenY: event.screenY,
            movementX: event.movementX,
            movementY: event.movementY,
            view: event.view,
            detail: event.detail,
            relatedTarget: event.relatedTarget
          });
          leaveEvent.targetView = this;
          leaveEvent.relatedTargetView = event.relatedTargetView;
          this.handleEvent(leaveEvent);
        }
      }
    }
    onPointerOver(event) {
      let hoverSet = this.hoverSet;
      if (hoverSet === null) {
        hoverSet = {};
        this.hoverSet = hoverSet;
      }
      const id = "" + event.pointerId;
      if (hoverSet[id] === void 0) {
        hoverSet[id] = null;
        const eventHandlers = this.eventHandlers;
        if (eventHandlers !== null && eventHandlers.pointerenter !== void 0) {
          const enterEvent = new PointerEvent("pointerenter", {
            bubbles: false,
            pointerId: event.pointerId,
            pointerType: event.pointerType,
            isPrimary: event.isPrimary,
            button: event.button,
            buttons: event.buttons,
            altKey: event.altKey,
            ctrlKey: event.ctrlKey,
            metaKey: event.metaKey,
            shiftKey: event.shiftKey,
            clientX: event.clientX,
            clientY: event.clientY,
            screenX: event.screenX,
            screenY: event.screenY,
            movementX: event.movementX,
            movementY: event.movementY,
            tiltX: event.tiltX,
            tiltY: event.tiltY,
            twist: event.twist,
            width: event.width,
            height: event.height,
            pressure: event.pressure,
            tangentialPressure: event.tangentialPressure,
            view: event.view,
            detail: event.detail,
            relatedTarget: event.relatedTarget
          });
          enterEvent.targetView = this;
          enterEvent.relatedTargetView = event.relatedTargetView;
          this.handleEvent(enterEvent);
        }
      }
    }
    onPointerOut(event) {
      const hoverSet = this.hoverSet;
      if (hoverSet !== null) {
        const id = "" + event.pointerId;
        if (hoverSet[id] !== void 0) {
          delete hoverSet[id];
          const eventHandlers = this.eventHandlers;
          if (eventHandlers !== null && eventHandlers.pointerleave !== void 0) {
            const leaveEvent = new PointerEvent("pointerleave", {
              bubbles: false,
              pointerId: event.pointerId,
              pointerType: event.pointerType,
              isPrimary: event.isPrimary,
              button: event.button,
              buttons: event.buttons,
              altKey: event.altKey,
              ctrlKey: event.ctrlKey,
              metaKey: event.metaKey,
              shiftKey: event.shiftKey,
              clientX: event.clientX,
              clientY: event.clientY,
              screenX: event.screenX,
              screenY: event.screenY,
              movementX: event.movementX,
              movementY: event.movementY,
              tiltX: event.tiltX,
              tiltY: event.tiltY,
              twist: event.twist,
              width: event.width,
              height: event.height,
              pressure: event.pressure,
              tangentialPressure: event.tangentialPressure,
              view: event.view,
              detail: event.detail,
              relatedTarget: event.relatedTarget
            });
            leaveEvent.targetView = this;
            leaveEvent.relatedTargetView = event.relatedTargetView;
            this.handleEvent(leaveEvent);
          }
        }
      }
    }
    init(init) {
      super.init(init);
      if (init.hidden !== void 0) {
        this.setHidden(init.hidden);
      }
    }
  }
  GraphicsView.UncullFlags = View.UncullFlags | View.NeedsRender;
  GraphicsView.UnhideFlags = View.UnhideFlags | View.NeedsRender;
  GraphicsView.InsertChildFlags = View.InsertChildFlags | View.NeedsRender;
  GraphicsView.RemoveChildFlags = View.RemoveChildFlags | View.NeedsRender;
  __decorate([ component.Provider({
    type: SpriteService,
    observes: false,
    service: SpriteService.global()
  }) ], GraphicsView.prototype, "spriteProvider", void 0);
  Object.defineProperty(GraphicsView.prototype, "renderer", {
    get() {
      const parent = this.parent;
      if (parent instanceof GraphicsView || parent instanceof CanvasView) {
        return parent.renderer;
      } else {
        return null;
      }
    },
    configurable: true
  });
  Object.defineProperty(GraphicsView.prototype, "viewBounds", {
    get() {
      return this.viewFrame;
    },
    configurable: true
  });
  class DrawingRenderer extends GraphicsRenderer {}
  class PathContext {
    constructor() {
      this.precision = -1;
      this.x0 = NaN;
      this.y0 = NaN;
      this.x1 = NaN;
      this.y1 = NaN;
      this.d = "";
    }
    setPrecision(precision) {
      this.precision = precision;
    }
    get anglePrecision() {
      const precision = this.precision;
      return precision > 0 ? Math.max(5, precision) : precision;
    }
    moveTo(x, y) {
      this.d += "M" + codec.Format.decimal(x, this.precision) + "," + codec.Format.decimal(y, this.precision);
      this.x0 = x;
      this.y0 = y;
      this.x1 = x;
      this.y1 = y;
    }
    lineTo(x, y) {
      this.d += "L" + codec.Format.decimal(x, this.precision) + "," + codec.Format.decimal(y, this.precision);
      this.x1 = x;
      this.y1 = y;
    }
    quadraticCurveTo(x1, y1, x, y) {
      this.d += "Q" + codec.Format.decimal(x1, this.precision) + "," + codec.Format.decimal(y1, this.precision) + "," + codec.Format.decimal(x, this.precision) + "," + codec.Format.decimal(y, this.precision);
      this.x1 = x;
      this.y1 = y;
    }
    bezierCurveTo(x1, y1, x2, y2, x, y) {
      this.d += "C" + codec.Format.decimal(x1, this.precision) + "," + codec.Format.decimal(y1, this.precision) + "," + codec.Format.decimal(x2, this.precision) + "," + codec.Format.decimal(y2, this.precision) + "," + codec.Format.decimal(x, this.precision) + "," + codec.Format.decimal(y, this.precision);
      this.x1 = x;
      this.y1 = y;
    }
    arcTo(x1, y1, x2, y2, r) {
      const x0 = this.x1;
      const y0 = this.y1;
      const x21 = x2 - x1;
      const y21 = y2 - y1;
      const x01 = x0 - x1;
      const y01 = y0 - y1;
      const l01_2 = x01 * x01 + y01 * y01;
      if (r < 0) {
        throw new Error("negative radius: " + r);
      } else if (isNaN(this.x1)) {
        this.d += "M" + codec.Format.decimal(x1, this.precision) + "," + codec.Format.decimal(y1, this.precision);
        this.x1 = x1;
        this.y1 = y1;
      } else if (!(l01_2 > PathContext.Epsilon)) ; else if (!(Math.abs(y01 * x21 - y21 * x01) > PathContext.Epsilon) || r === 0) {
        this.d += "L" + codec.Format.decimal(x1, this.precision) + "," + codec.Format.decimal(y1, this.precision);
        this.x1 = x1;
        this.y1 = y1;
      } else {
        const x20 = x2 - x0;
        const y20 = y2 - y0;
        const l21_2 = x21 * x21 + y21 * y21;
        const l20_2 = x20 * x20 + y20 * y20;
        const l21 = Math.sqrt(l21_2);
        const l01 = Math.sqrt(l01_2);
        const l = r * Math.tan((Math.PI - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2);
        const t01 = l / l01;
        const t21 = l / l21;
        if (Math.abs(t01 - 1) > PathContext.Epsilon) {
          this.d += "L" + codec.Format.decimal(x1 + t01 * x01, this.precision) + "," + codec.Format.decimal(y1 + t01 * y01, this.precision);
        }
        x1 = x1 + t21 * x21;
        y1 = y1 + t21 * y21;
        const rs = codec.Format.decimal(r, this.precision);
        this.d += "A" + rs + "," + rs + ",0" + ",0" + "," + (y01 * x20 > x01 * y20 ? "1" : "0") + "," + codec.Format.decimal(x1, this.precision) + "," + codec.Format.decimal(y1, this.precision);
        this.x1 = x1;
        this.y1 = y1;
      }
    }
    arc(cx, cy, r, a0, a1, ccw = false) {
      const dx = r * Math.cos(a0);
      const dy = r * Math.sin(a0);
      const x0 = cx + dx;
      const y0 = cy + dy;
      const cw = 1 ^ +ccw;
      let da = ccw ? a0 - a1 : a1 - a0;
      if (r < 0) {
        throw new Error("negative radius: " + r);
      } else if (isNaN(this.x1)) {
        this.d += "M" + codec.Format.decimal(x0, this.precision) + "," + codec.Format.decimal(y0, this.precision);
      } else if (Math.abs(this.x1 - x0) > PathContext.Epsilon || Math.abs(this.y1 - y0) > PathContext.Epsilon) {
        this.d += "L" + codec.Format.decimal(x0, this.precision) + "," + codec.Format.decimal(y0, this.precision);
      }
      if (r === 0) {
        return;
      } else if (da < 0) {
        da = da % (2 * Math.PI) + 2 * Math.PI;
      }
      const rs = codec.Format.decimal(r, this.precision);
      if (da > 2 * Math.PI - PathContext.Epsilon) {
        this.d += "A" + rs + "," + rs + ",0" + ",1" + "," + (cw ? "1" : "0") + "," + codec.Format.decimal(x0, this.precision) + "," + codec.Format.decimal(y0, this.precision);
        this.x1 = x0;
        this.y1 = y0;
      } else if (da > PathContext.Epsilon) {
        const x1 = cx + r * Math.cos(a1);
        const y1 = cy + r * Math.sin(a1);
        this.d += "A" + rs + "," + rs + ",0" + "," + (da >= Math.PI ? "1" : "0") + "," + (cw ? "1" : "0") + "," + codec.Format.decimal(x1, this.precision) + "," + codec.Format.decimal(y1, this.precision);
        this.x1 = x1;
        this.y1 = y1;
      }
    }
    rect(x, y, w, h) {
      this.d += "M" + codec.Format.decimal(x, this.precision) + "," + codec.Format.decimal(y, this.precision) + "h" + codec.Format.decimal(w, this.precision) + "v" + codec.Format.decimal(h, this.precision) + "h" + codec.Format.decimal(-w, this.precision) + "Z";
      this.x0 = x;
      this.y0 = y;
      this.x1 = x;
      this.y1 = y;
    }
    ellipse(cx, cy, rx, ry, phi, a0, a1, ccw = false) {
      const cosPhi = Math.cos(phi);
      const sinPhi = Math.sin(phi);
      const cosA1 = Math.cos(a1);
      const sinA1 = Math.sin(a1);
      const x1 = cosPhi * rx * cosA1 - sinPhi * ry * sinA1 + cx;
      const y1 = sinPhi * rx * cosA1 + cosPhi * ry * sinA1 + cy;
      const da = a1 - a0;
      const large = Math.abs(da) > Math.PI;
      const sweep = !ccw;
      this.d += "A" + codec.Format.decimal(rx, this.precision) + "," + codec.Format.decimal(ry, this.precision) + "," + codec.Format.decimal(phi, this.anglePrecision) + "," + (large ? "1" : "0") + "," + (sweep ? "1" : "0") + "," + codec.Format.decimal(x1, this.precision) + "," + codec.Format.decimal(y1, this.precision);
      this.x1 = x1;
      this.y1 = y1;
    }
    closePath() {
      if (!isNaN(this.x1)) {
        this.d += "Z";
        this.x1 = this.x0;
        this.y1 = this.y0;
      }
    }
    toString() {
      return this.d;
    }
  }
  PathContext.Epsilon = 1e-6;
  class PathRenderer extends DrawingRenderer {
    constructor(context) {
      super();
      this.context = context;
    }
    get transform() {
      return math.Transform.identity();
    }
    get pixelRatio() {
      return 1;
    }
  }
  class PaintingRenderer extends DrawingRenderer {}
  class SvgContext {
    constructor(view) {
      this.view = view;
      this.precision = -1;
      this.pathContext = null;
      this.pathView = null;
      this.pathFlags = 0;
      this.fillStyle = "";
      this.strokeStyle = "";
      this.lineWidth = 1;
      this.lineCap = "butt";
      this.lineJoin = "miter";
      this.miterLimit = 10;
      this.lineDashOffset = 0;
      this.lineDash = [];
    }
    setPrecision(precision) {
      this.precision = precision;
    }
    getPathContext() {
      const pathContext = this.pathContext;
      if (pathContext == null) {
        throw new Error("no path");
      }
      return pathContext;
    }
    getOrCreatePathContext() {
      let pathContext = this.pathContext;
      if (pathContext === null) {
        pathContext = this.createPathContext();
        this.pathContext = pathContext;
        if (this.pathView === null || this.pathFlags !== 0) {
          this.finalizePath();
          const pathView = this.nextPathView();
          this.setPathView(pathView);
        }
        this.setPathFlags(0);
      }
      return pathContext;
    }
    createPathContext() {
      const pathContext = new PathContext;
      pathContext.setPrecision(this.precision);
      return pathContext;
    }
    setPathView(pathView) {
      this.pathView = pathView;
    }
    nextPathView() {
      let pathView = this.pathView;
      if (pathView !== null) {
        let nextNode = pathView.node.nextSibling;
        pathView = null;
        while (nextNode !== null) {
          if (nextNode instanceof SVGPathElement) {
            pathView = SvgView.fromNode(nextNode);
            break;
          }
          nextNode = nextNode.nextSibling;
        }
      }
      return pathView;
    }
    finalizePath() {
      const pathView = this.pathView;
      if (pathView !== null) {
        const pathFlags = this.pathFlags;
        if ((pathFlags & SvgContext.FillFlag) === 0) {
          const fill = pathView.getFastener("fill", component.Property);
          if (fill !== null) {
            fill.setValue(null, component.Affinity.Intrinsic);
          }
        }
        if ((pathFlags & SvgContext.FillRuleFlag) === 0) {
          const fillRule = pathView.getFastener("fillRule", component.Property);
          if (fillRule !== null) {
            fillRule.setValue(void 0, component.Affinity.Intrinsic);
          }
        }
        if ((pathFlags & SvgContext.StrokeFlag) === 0) {
          const stroke = pathView.getFastener("stroke", component.Property);
          if (stroke !== null) {
            stroke.setValue(null, component.Affinity.Intrinsic);
          }
        }
        if ((pathFlags & SvgContext.PathFlag) === 0) {
          const d = pathView.getFastener("d", component.Property);
          if (d !== null) {
            d.setValue(void 0, component.Affinity.Intrinsic);
          }
        }
      }
    }
    setPathFlags(pathFlags) {
      this.pathFlags = pathFlags;
    }
    getLineDash() {
      return this.lineDash;
    }
    setLineDash(segments) {
      this.lineDash = segments;
    }
    beginPath() {
      this.pathContext = null;
    }
    moveTo(x, y) {
      this.getOrCreatePathContext().moveTo(x, y);
    }
    lineTo(x, y) {
      this.getPathContext().lineTo(x, y);
    }
    quadraticCurveTo(x1, y1, x, y) {
      this.getPathContext().quadraticCurveTo(x1, y1, x, y);
    }
    bezierCurveTo(x1, y1, x2, y2, x, y) {
      this.getPathContext().bezierCurveTo(x1, y1, x2, y2, x, y);
    }
    arcTo(x1, y1, x2, y2, r) {
      this.getPathContext().arcTo(x1, y1, x2, y2, r);
    }
    arc(cx, cy, r, a0, a1, ccw) {
      this.getOrCreatePathContext().arc(cx, cy, r, a0, a1, ccw);
    }
    ellipse(cx, cy, rx, ry, phi, a0, a1, ccw) {
      this.getOrCreatePathContext().ellipse(cx, cy, rx, ry, phi, a0, a1, ccw);
    }
    rect(x, y, w, h) {
      this.getOrCreatePathContext().rect(x, y, w, h);
    }
    closePath() {
      const pathContext = this.pathContext;
      if (pathContext !== null) {
        pathContext.closePath();
      }
    }
    fill(fillRule) {
      const fillStyle = this.fillStyle;
      if (typeof fillStyle === "string") {
        let pathView = this.pathView;
        if (pathView !== null && (this.pathFlags & SvgContext.FillFlag) !== 0) {
          this.finalizePath();
          pathView = this.nextPathView();
          this.setPathView(pathView);
        }
        let created = false;
        if (pathView === null) {
          pathView = SvgView.fromTag("path");
          this.setPathView(pathView);
          created = true;
        }
        pathView.fill.setState(fillStyle, component.Affinity.Intrinsic);
        this.setPathFlags(this.pathFlags | SvgContext.FillFlag);
        if (fillRule !== void 0) {
          pathView.fillRule.setState(fillRule, component.Affinity.Intrinsic);
          this.setPathFlags(this.pathFlags | SvgContext.FillRuleFlag);
        }
        if ((this.pathFlags & SvgContext.PathFlag) === 0) {
          const pathString = this.getPathContext().toString();
          pathView.d.setState(pathString, component.Affinity.Intrinsic);
          this.setPathFlags(this.pathFlags | SvgContext.PathFlag);
        }
        if (created) {
          this.view.appendChild(pathView);
        }
      } else {
        throw new Error("unsupported fill style: " + fillStyle);
      }
    }
    stroke() {
      const strokeStyle = this.strokeStyle;
      const lineWidth = this.lineWidth;
      if (typeof strokeStyle === "string" && lineWidth !== 0 && isFinite(lineWidth)) {
        let pathView = this.pathView;
        if (pathView !== null && (this.pathFlags & SvgContext.StrokeFlag) !== 0) {
          this.finalizePath();
          pathView = this.nextPathView();
          this.setPathView(pathView);
        }
        let created = false;
        if (pathView === null) {
          pathView = SvgView.fromTag("path");
          this.setPathView(pathView);
          created = true;
        }
        pathView.stroke.setState(strokeStyle, component.Affinity.Intrinsic);
        pathView.strokeWidth.setState(lineWidth, component.Affinity.Intrinsic);
        pathView.strokeLinecap.setState(this.lineCap, component.Affinity.Intrinsic);
        pathView.strokeLinejoin.setState(this.lineJoin, component.Affinity.Intrinsic);
        if (this.lineJoin === "miter") {
          pathView.strokeMiterlimit.setState(this.miterLimit, component.Affinity.Intrinsic);
        } else {
          pathView.strokeMiterlimit.setState(void 0, component.Affinity.Intrinsic);
        }
        if (this.lineDash.length !== 0) {
          let dash = "";
          for (let i = 0; i < this.lineDash.length; i += 1) {
            if (i !== 0) {
              dash += " ";
            }
            dash += this.lineDash[i];
          }
          pathView.strokeDasharray.setState(dash, component.Affinity.Intrinsic);
          if (this.lineDashOffset !== 0) {
            pathView.strokeDashoffset.setState(this.lineDashOffset, component.Affinity.Intrinsic);
          } else {
            pathView.strokeDashoffset.setState(void 0, component.Affinity.Intrinsic);
          }
        } else {
          pathView.strokeDasharray.setState(void 0, component.Affinity.Intrinsic);
          pathView.strokeDashoffset.setState(void 0, component.Affinity.Intrinsic);
        }
        this.setPathFlags(this.pathFlags | SvgContext.StrokeFlag);
        if ((this.pathFlags & SvgContext.PathFlag) === 0) {
          const pathString = this.getPathContext().toString();
          pathView.d.setState(pathString, component.Affinity.Intrinsic);
          this.setPathFlags(this.pathFlags | SvgContext.PathFlag);
        }
        if (created) {
          this.view.appendChild(pathView);
        }
      } else {
        throw new Error("unsupported stroke style: " + strokeStyle);
      }
    }
    beginSvg() {
      let pathView = null;
      let nextNode = this.view.node.firstChild;
      while (nextNode !== null) {
        if (nextNode instanceof SVGPathElement) {
          pathView = SvgView.fromNode(nextNode);
          break;
        }
        nextNode = nextNode.nextSibling;
      }
      this.setPathView(pathView);
      this.setPathFlags(0);
    }
    finalizeSvg() {
      let pathView = this.pathView;
      if (pathView !== null) {
        let nextNode = pathView.node.nextSibling;
        if (pathView.fill.state === null && pathView.stroke.state === null) {
          this.pathView = null;
          pathView.remove();
        }
        pathView = null;
        while (nextNode !== null) {
          const nextView = nextNode.view;
          nextNode = nextNode.nextSibling;
          if (nextView !== void 0) {
            nextView.remove();
          }
        }
      }
    }
  }
  SvgContext.FillFlag = 1 << 0;
  SvgContext.FillRuleFlag = 1 << 1;
  SvgContext.StrokeFlag = 1 << 2;
  SvgContext.PathFlag = 1 << 3;
  class SvgRenderer extends PaintingRenderer {
    constructor(context) {
      super();
      this.context = context;
    }
    get transform() {
      return math.Transform.identity();
    }
    get pixelRatio() {
      return 1;
    }
  }
  class CanvasRenderer extends PaintingRenderer {
    constructor(context, transform, pixelRatio) {
      super();
      this.context = context;
      this.transform = transform;
      this.pixelRatio = pixelRatio;
    }
    setTransform(transform) {
      this.transform = transform;
    }
  }
  class WebGLRenderer extends GraphicsRenderer {
    constructor(context, pixelRatio) {
      super();
      this.context = context;
      this.pixelRatio = pixelRatio !== void 0 ? pixelRatio : window.devicePixelRatio || 1;
    }
  }
  class CanvasView extends HtmlView {
    constructor(node) {
      super(node);
      Object.defineProperty(this, "renderer", {
        value: this.createRenderer(),
        writable: true,
        enumerable: true,
        configurable: true
      });
      this.viewFrame = math.R2Box.undefined();
      this.canvasFlags = CanvasView.ClickEventsFlag;
      this.eventNode = node;
      this.mouse = null;
      this.pointers = null;
      this.touches = null;
      this.onClick = this.onClick.bind(this);
      this.onDblClick = this.onDblClick.bind(this);
      this.onContextMenu = this.onContextMenu.bind(this);
      this.onWheel = this.onWheel.bind(this);
      this.onMouseEnter = this.onMouseEnter.bind(this);
      this.onMouseLeave = this.onMouseLeave.bind(this);
      this.onMouseDown = this.onMouseDown.bind(this);
      this.onMouseMove = this.onMouseMove.bind(this);
      this.onMouseUp = this.onMouseUp.bind(this);
      this.onPointerEnter = this.onPointerEnter.bind(this);
      this.onPointerLeave = this.onPointerLeave.bind(this);
      this.onPointerDown = this.onPointerDown.bind(this);
      this.onPointerMove = this.onPointerMove.bind(this);
      this.onPointerUp = this.onPointerUp.bind(this);
      this.onPointerCancel = this.onPointerCancel.bind(this);
      this.onTouchStart = this.onTouchStart.bind(this);
      this.onTouchMove = this.onTouchMove.bind(this);
      this.onTouchEnd = this.onTouchEnd.bind(this);
      this.onTouchCancel = this.onTouchCancel.bind(this);
      this.initCanvas();
    }
    initCanvas() {
      this.position.setState("absolute", component.Affinity.Intrinsic);
    }
    onMount() {
      super.onMount();
      this.attachEvents(this.eventNode);
    }
    onUnmount() {
      this.detachEvents(this.eventNode);
      super.onUnmount();
    }
    needsUpdate(updateFlags, immediate) {
      updateFlags = super.needsUpdate(updateFlags, immediate);
      updateFlags |= View.NeedsRender | View.NeedsComposite;
      this.setFlags(this.flags | (View.NeedsRender | View.NeedsComposite));
      return updateFlags;
    }
    needsProcess(processFlags, viewContext) {
      if ((processFlags & View.ProcessMask) !== 0) {
        this.requireUpdate(View.NeedsRender | View.NeedsComposite);
      }
      return processFlags;
    }
    onResize(viewContext) {
      super.onResize(viewContext);
      this.resizeCanvas(this.node);
      this.resetRenderer();
      this.requireUpdate(View.NeedsLayout | View.NeedsRender | View.NeedsComposite);
    }
    onScroll(viewContext) {
      super.onScroll(viewContext);
      this.setCulled(!this.intersectsViewport());
    }
    didDisplay(displayFlags, viewContext) {
      this.detectHitTargets();
      super.didDisplay(displayFlags, viewContext);
    }
    onRender(viewContext) {
      this.clearCanvas();
    }
    needsDisplay(displayFlags, viewContext) {
      displayFlags |= View.NeedsRender | View.NeedsComposite;
      return displayFlags;
    }
    get pixelRatio() {
      return window.devicePixelRatio || 1;
    }
    setRenderer(renderer) {
      if (typeof renderer === "string") {
        renderer = this.createRenderer(renderer);
      }
      this.renderer = renderer;
      this.resetRenderer();
    }
    createRenderer(rendererType = "canvas") {
      if (rendererType === "canvas") {
        const context = this.node.getContext("2d");
        if (context !== null) {
          const pixelRatio = this.pixelRatio;
          const transform = math.Transform.affine(pixelRatio, 0, 0, pixelRatio, 0, 0);
          return new CanvasRenderer(context, transform, pixelRatio);
        } else {
          throw new Error("Failed to create canvas rendering context");
        }
      } else if (rendererType === "webgl") {
        const context = this.node.getContext("webgl");
        if (context !== null) {
          return new WebGLRenderer(context, this.pixelRatio);
        } else {
          throw new Error("Failed to create webgl rendering context");
        }
      } else {
        throw new Error("Failed to create " + rendererType + " renderer");
      }
    }
    setCanvasFlags(canvasFlags) {
      this.canvasFlags = canvasFlags;
    }
    extendViewContext(viewContext) {
      const canvasViewContext = Object.create(viewContext);
      canvasViewContext.viewFrame = this.viewFrame;
      canvasViewContext.renderer = this.renderer;
      return canvasViewContext;
    }
    setViewFrame(viewFrame) {}
    get viewBounds() {
      return this.viewFrame;
    }
    get hitBounds() {
      return this.viewFrame;
    }
    cascadeHitTest(x, y, baseViewContext) {
      if (!this.hidden && !this.culled && !this.intangible) {
        const hitBounds = this.hitBounds;
        if (hitBounds.contains(x, y)) {
          if (baseViewContext === void 0) {
            baseViewContext = this.superViewContext;
          }
          const viewContext = this.extendViewContext(baseViewContext);
          let hit = this.hitTestChildren(x, y, viewContext);
          if (hit === null) {
            const outerViewContext = ViewContext.current;
            try {
              ViewContext.current = viewContext;
              this.setFlags(this.flags | View.ContextualFlag);
              hit = this.hitTest(x, y, viewContext);
            } finally {
              this.setFlags(this.flags & ~View.ContextualFlag);
              ViewContext.current = outerViewContext;
            }
          }
          return hit;
        }
      }
      return null;
    }
    hitTest(x, y, viewContext) {
      return null;
    }
    hitTestChildren(x, y, viewContext) {
      let child = this.firstChild;
      while (child !== null) {
        if (child instanceof GraphicsView) {
          const hit = this.hitTestChild(child, x, y, viewContext);
          if (hit !== null) {
            return hit;
          }
        }
        child = child.nextSibling;
      }
      return null;
    }
    hitTestChild(childView, x, y, viewContext) {
      return childView.cascadeHitTest(x, y, viewContext);
    }
    detectHitTargets(clientBounds) {
      if ((this.canvasFlags & CanvasView.MouseEventsFlag) !== 0) {
        const mouse = this.mouse;
        if (mouse !== null) {
          if (clientBounds === void 0) {
            clientBounds = this.clientBounds;
          }
          this.detectMouseTarget(mouse, this.clientBounds);
        }
      }
      if ((this.canvasFlags & CanvasView.PointerEventsFlag) !== 0) {
        const pointers = this.pointers;
        for (const id in pointers) {
          const pointer = pointers[id];
          if (clientBounds === void 0) {
            clientBounds = this.clientBounds;
          }
          this.detectPointerTarget(pointer, clientBounds);
        }
      }
    }
    setEventNode(newEventNode) {
      if (newEventNode === null) {
        newEventNode = this.node;
      }
      const oldEventNode = this.eventNode;
      if (oldEventNode !== newEventNode) {
        this.detachEvents(oldEventNode);
        this.eventNode = newEventNode;
        this.attachEvents(newEventNode);
      }
    }
    clickEventsEnabled(newClickEvents) {
      const oldClickEvents = (this.canvasFlags & CanvasView.ClickEventsFlag) !== 0;
      if (newClickEvents === void 0) {
        return oldClickEvents;
      } else {
        if (newClickEvents && !oldClickEvents) {
          this.setCanvasFlags(this.canvasFlags | CanvasView.ClickEventsFlag);
          this.attachClickEvents(this.eventNode);
        } else if (!newClickEvents && oldClickEvents) {
          this.setCanvasFlags(this.canvasFlags & ~CanvasView.ClickEventsFlag);
          this.detachClickEvents(this.eventNode);
        }
        return this;
      }
    }
    wheelEventsEnabled(newWheelEvents) {
      const oldWheelEvents = (this.canvasFlags & CanvasView.WheelEventsFlag) !== 0;
      if (newWheelEvents === void 0) {
        return oldWheelEvents;
      } else {
        if (newWheelEvents && !oldWheelEvents) {
          this.setCanvasFlags(this.canvasFlags | CanvasView.WheelEventsFlag);
          this.attachWheelEvents(this.eventNode);
        } else if (!newWheelEvents && oldWheelEvents) {
          this.setCanvasFlags(this.canvasFlags & ~CanvasView.WheelEventsFlag);
          this.detachWheelEvents(this.eventNode);
        }
        return this;
      }
    }
    mouseEventsEnabled(newMouseEvents) {
      const oldMouseEvents = (this.canvasFlags & CanvasView.MouseEventsFlag) !== 0;
      if (newMouseEvents === void 0) {
        return oldMouseEvents;
      } else {
        if (newMouseEvents && !oldMouseEvents) {
          this.setCanvasFlags(this.canvasFlags | CanvasView.MouseEventsFlag);
          this.attachPassiveMouseEvents(this.eventNode);
        } else if (!newMouseEvents && oldMouseEvents) {
          this.setCanvasFlags(this.canvasFlags & ~CanvasView.MouseEventsFlag);
          this.detachPassiveMouseEvents(this.eventNode);
        }
        return this;
      }
    }
    pointerEventsEnabled(newPointerEvents) {
      const oldPointerEvents = (this.canvasFlags & CanvasView.PointerEventsFlag) !== 0;
      if (newPointerEvents === void 0) {
        return oldPointerEvents;
      } else {
        if (newPointerEvents && !oldPointerEvents) {
          this.setCanvasFlags(this.canvasFlags | CanvasView.PointerEventsFlag);
          this.attachPassivePointerEvents(this.eventNode);
        } else if (!newPointerEvents && oldPointerEvents) {
          this.setCanvasFlags(this.canvasFlags & ~CanvasView.PointerEventsFlag);
          this.detachPassivePointerEvents(this.eventNode);
        }
        return this;
      }
    }
    touchEventsEnabled(newTouchEvents) {
      const oldTouchEvents = (this.canvasFlags & CanvasView.TouchEventsFlag) !== 0;
      if (newTouchEvents === void 0) {
        return oldTouchEvents;
      } else {
        if (newTouchEvents && !oldTouchEvents) {
          this.setCanvasFlags(this.canvasFlags | CanvasView.TouchEventsFlag);
          this.attachPassiveTouchEvents(this.eventNode);
        } else if (!newTouchEvents && oldTouchEvents) {
          this.setCanvasFlags(this.canvasFlags & ~CanvasView.TouchEventsFlag);
          this.detachPassiveTouchEvents(this.eventNode);
        }
        return this;
      }
    }
    handleEvent(event) {}
    bubbleEvent(event) {
      this.handleEvent(event);
      return this;
    }
    attachEvents(eventNode) {
      if ((this.canvasFlags & CanvasView.ClickEventsFlag) !== 0) {
        this.attachClickEvents(eventNode);
      }
      if ((this.canvasFlags & CanvasView.WheelEventsFlag) !== 0) {
        this.attachWheelEvents(eventNode);
      }
      if ((this.canvasFlags & CanvasView.MouseEventsFlag) !== 0) {
        this.attachPassiveMouseEvents(eventNode);
      }
      if ((this.canvasFlags & CanvasView.PointerEventsFlag) !== 0) {
        this.attachPassivePointerEvents(eventNode);
      }
      if ((this.canvasFlags & CanvasView.TouchEventsFlag) !== 0) {
        this.attachPassiveTouchEvents(eventNode);
      }
    }
    detachEvents(eventNode) {
      this.detachClickEvents(eventNode);
      this.detachWheelEvents(eventNode);
      this.detachPassiveMouseEvents(eventNode);
      this.detachActiveMouseEvents(eventNode);
      this.detachPassivePointerEvents(eventNode);
      this.detachActivePointerEvents(eventNode);
      this.detachPassiveTouchEvents(eventNode);
      this.detachActiveTouchEvents(eventNode);
    }
    fireEvent(event, clientX, clientY) {
      const clientBounds = this.clientBounds;
      if (clientBounds.contains(clientX, clientY)) {
        const x = clientX - clientBounds.x;
        const y = clientY - clientBounds.y;
        const hit = this.cascadeHitTest(x, y);
        if (hit !== null) {
          event.targetView = hit;
          hit.bubbleEvent(event);
          return hit;
        }
      }
      return null;
    }
    attachClickEvents(eventNode) {
      eventNode.addEventListener("click", this.onClick);
      eventNode.addEventListener("dblclick", this.onDblClick);
      eventNode.addEventListener("contextmenu", this.onContextMenu);
    }
    detachClickEvents(eventNode) {
      eventNode.removeEventListener("click", this.onClick);
      eventNode.removeEventListener("dblclick", this.onDblClick);
      eventNode.removeEventListener("contextmenu", this.onContextMenu);
    }
    attachWheelEvents(eventNode) {
      eventNode.addEventListener("wheel", this.onWheel);
    }
    detachWheelEvents(eventNode) {
      eventNode.removeEventListener("wheel", this.onWheel);
    }
    attachPassiveMouseEvents(eventNode) {
      eventNode.addEventListener("mouseenter", this.onMouseEnter);
      eventNode.addEventListener("mouseleave", this.onMouseLeave);
      eventNode.addEventListener("mousedown", this.onMouseDown);
    }
    detachPassiveMouseEvents(eventNode) {
      eventNode.removeEventListener("mouseenter", this.onMouseEnter);
      eventNode.removeEventListener("mouseleave", this.onMouseLeave);
      eventNode.removeEventListener("mousedown", this.onMouseDown);
    }
    attachActiveMouseEvents(eventNode) {
      document.body.addEventListener("mousemove", this.onMouseMove);
      document.body.addEventListener("mouseup", this.onMouseUp);
    }
    detachActiveMouseEvents(eventNode) {
      document.body.removeEventListener("mousemove", this.onMouseMove);
      document.body.removeEventListener("mouseup", this.onMouseUp);
    }
    updateMouse(mouse, event) {
      mouse.button = event.button;
      mouse.buttons = event.buttons;
      mouse.altKey = event.altKey;
      mouse.ctrlKey = event.ctrlKey;
      mouse.metaKey = event.metaKey;
      mouse.shiftKey = event.shiftKey;
      mouse.clientX = event.clientX;
      mouse.clientY = event.clientY;
      mouse.screenX = event.screenX;
      mouse.screenY = event.screenY;
      mouse.movementX = event.movementX;
      mouse.movementY = event.movementY;
      mouse.view = event.view;
      mouse.detail = event.detail;
      mouse.relatedTarget = event.relatedTarget;
    }
    fireMouseEvent(event) {
      return this.fireEvent(event, event.clientX, event.clientY);
    }
    onClick(event) {
      const mouse = this.mouse;
      if (mouse !== null) {
        this.updateMouse(mouse, event);
      }
      this.fireMouseEvent(event);
    }
    onDblClick(event) {
      const mouse = this.mouse;
      if (mouse !== null) {
        this.updateMouse(mouse, event);
      }
      this.fireMouseEvent(event);
    }
    onContextMenu(event) {
      const mouse = this.mouse;
      if (mouse !== null) {
        this.updateMouse(mouse, event);
      }
      this.fireMouseEvent(event);
    }
    onWheel(event) {
      const mouse = this.mouse;
      if (mouse !== null) {
        this.updateMouse(mouse, event);
      }
      this.fireMouseEvent(event);
    }
    onMouseEnter(event) {
      let mouse = this.mouse;
      if (mouse === null) {
        this.attachActiveMouseEvents(this.eventNode);
        mouse = {};
        this.mouse = mouse;
      }
      this.updateMouse(mouse, event);
    }
    onMouseLeave(event) {
      const mouse = this.mouse;
      if (mouse !== null) {
        this.mouse = null;
        this.detachActiveMouseEvents(this.eventNode);
      }
    }
    onMouseDown(event) {
      let mouse = this.mouse;
      if (mouse === null) {
        this.attachActiveMouseEvents(this.eventNode);
        mouse = {};
        this.mouse = mouse;
      }
      this.updateMouse(mouse, event);
      this.fireMouseEvent(event);
    }
    onMouseMove(event) {
      let mouse = this.mouse;
      if (mouse === null) {
        mouse = {};
        this.mouse = mouse;
      }
      this.updateMouse(mouse, event);
      const oldTargetView = mouse.targetView;
      let newTargetView = this.fireMouseEvent(event);
      if (newTargetView === null) {
        newTargetView = void 0;
      }
      if (newTargetView !== oldTargetView) {
        this.onMouseTargetChange(mouse, newTargetView, oldTargetView);
      }
    }
    onMouseUp(event) {
      const mouse = this.mouse;
      if (mouse !== null) {
        this.updateMouse(mouse, event);
      }
      this.fireMouseEvent(event);
    }
    onMouseTargetChange(mouse, newTargetView, oldTargetView) {
      mouse.bubbles = true;
      if (oldTargetView !== void 0) {
        const outEvent = new MouseEvent("mouseout", mouse);
        outEvent.targetView = oldTargetView;
        outEvent.relatedTargetView = newTargetView;
        oldTargetView.bubbleEvent(outEvent);
      }
      mouse.targetView = newTargetView;
      if (newTargetView !== void 0) {
        const overEvent = new MouseEvent("mouseover", mouse);
        overEvent.targetView = newTargetView;
        overEvent.relatedTargetView = oldTargetView;
        newTargetView.bubbleEvent(overEvent);
      }
    }
    detectMouseTarget(mouse, clientBounds) {
      const clientX = mouse.clientX;
      const clientY = mouse.clientY;
      if (clientBounds.contains(clientX, clientY)) {
        const x = clientX - clientBounds.x;
        const y = clientY - clientBounds.y;
        const oldTargetView = mouse.targetView;
        let newTargetView = this.cascadeHitTest(x, y);
        if (newTargetView === null) {
          newTargetView = void 0;
        }
        if (newTargetView !== oldTargetView) {
          this.onMouseTargetChange(mouse, newTargetView, oldTargetView);
        }
      }
    }
    attachPassivePointerEvents(eventNode) {
      eventNode.addEventListener("pointerenter", this.onPointerEnter);
      eventNode.addEventListener("pointerleave", this.onPointerLeave);
      eventNode.addEventListener("pointerdown", this.onPointerDown);
    }
    detachPassivePointerEvents(eventNode) {
      eventNode.removeEventListener("pointerenter", this.onPointerEnter);
      eventNode.removeEventListener("pointerleave", this.onPointerLeave);
      eventNode.removeEventListener("pointerdown", this.onPointerDown);
    }
    attachActivePointerEvents(eventNode) {
      document.body.addEventListener("pointermove", this.onPointerMove);
      document.body.addEventListener("pointerup", this.onPointerUp);
      document.body.addEventListener("pointercancel", this.onPointerCancel);
    }
    detachActivePointerEvents(eventNode) {
      document.body.removeEventListener("pointermove", this.onPointerMove);
      document.body.removeEventListener("pointerup", this.onPointerUp);
      document.body.removeEventListener("pointercancel", this.onPointerCancel);
    }
    updatePointer(pointer, event) {
      pointer.pointerId = event.pointerId;
      pointer.pointerType = event.pointerType;
      pointer.isPrimary = event.isPrimary;
      pointer.button = event.button;
      pointer.buttons = event.buttons;
      pointer.altKey = event.altKey;
      pointer.ctrlKey = event.ctrlKey;
      pointer.metaKey = event.metaKey;
      pointer.shiftKey = event.shiftKey;
      pointer.clientX = event.clientX;
      pointer.clientY = event.clientY;
      pointer.screenX = event.screenX;
      pointer.screenY = event.screenY;
      pointer.movementX = event.movementX;
      pointer.movementY = event.movementY;
      pointer.width = event.width;
      pointer.height = event.height;
      pointer.tiltX = event.tiltX;
      pointer.tiltY = event.tiltY;
      pointer.twist = event.twist;
      pointer.pressure = event.pressure;
      pointer.tangentialPressure = event.tangentialPressure;
      pointer.view = event.view;
      pointer.detail = event.detail;
      pointer.relatedTarget = event.relatedTarget;
    }
    firePointerEvent(event) {
      return this.fireEvent(event, event.clientX, event.clientY);
    }
    onPointerEnter(event) {
      const id = "" + event.pointerId;
      let pointers = this.pointers;
      if (pointers === null) {
        pointers = {};
        this.pointers = pointers;
      }
      let pointer = pointers[id];
      if (pointer === void 0) {
        if (Object.keys(pointers).length === 0) {
          this.attachActivePointerEvents(this.eventNode);
        }
        pointer = {};
        pointers[id] = pointer;
      }
      this.updatePointer(pointer, event);
    }
    onPointerLeave(event) {
      const id = "" + event.pointerId;
      let pointers = this.pointers;
      if (pointers === null) {
        pointers = {};
        this.pointers = pointers;
      }
      const pointer = pointers[id];
      if (pointer !== void 0) {
        if (pointer.targetView !== void 0) {
          this.onPointerTargetChange(pointer, void 0, pointer.targetView);
        }
        delete pointers[id];
        if (Object.keys(pointers).length === 0) {
          this.detachActivePointerEvents(this.eventNode);
        }
      }
    }
    onPointerDown(event) {
      const id = "" + event.pointerId;
      let pointers = this.pointers;
      if (pointers === null) {
        pointers = {};
        this.pointers = pointers;
      }
      let pointer = pointers[id];
      if (pointer === void 0) {
        if (Object.keys(pointers).length === 0) {
          this.attachActivePointerEvents(this.eventNode);
        }
        pointer = {};
        pointers[id] = pointer;
      }
      this.updatePointer(pointer, event);
      this.firePointerEvent(event);
    }
    onPointerMove(event) {
      const id = "" + event.pointerId;
      let pointers = this.pointers;
      if (pointers === null) {
        pointers = {};
        this.pointers = pointers;
      }
      let pointer = pointers[id];
      if (pointer === void 0) {
        if (Object.keys(pointers).length === 0) {
          this.attachActivePointerEvents(this.eventNode);
        }
        pointer = {};
        pointers[id] = pointer;
      }
      this.updatePointer(pointer, event);
      const oldTargetView = pointer.targetView;
      let newTargetView = this.firePointerEvent(event);
      if (newTargetView === null) {
        newTargetView = void 0;
      }
      if (newTargetView !== oldTargetView) {
        this.onPointerTargetChange(pointer, newTargetView, oldTargetView);
      }
    }
    onPointerUp(event) {
      const id = "" + event.pointerId;
      let pointers = this.pointers;
      if (pointers === null) {
        pointers = {};
        this.pointers = pointers;
      }
      const pointer = pointers[id];
      if (pointer !== void 0) {
        this.updatePointer(pointer, event);
      }
      this.firePointerEvent(event);
      if (pointer !== void 0 && event.pointerType !== "mouse") {
        if (pointer.targetView !== void 0) {
          this.onPointerTargetChange(pointer, void 0, pointer.targetView);
        }
        delete pointers[id];
        if (Object.keys(pointers).length === 0) {
          this.detachActivePointerEvents(this.eventNode);
        }
      }
    }
    onPointerCancel(event) {
      const id = "" + event.pointerId;
      let pointers = this.pointers;
      if (pointers === null) {
        pointers = {};
        this.pointers = pointers;
      }
      const pointer = pointers[id];
      if (pointer !== void 0) {
        this.updatePointer(pointer, event);
      }
      this.firePointerEvent(event);
      if (pointer !== void 0 && event.pointerType !== "mouse") {
        if (pointer.targetView !== void 0) {
          this.onPointerTargetChange(pointer, void 0, pointer.targetView);
        }
        delete pointers[id];
        if (Object.keys(pointers).length === 0) {
          this.detachActivePointerEvents(this.eventNode);
        }
      }
    }
    onPointerTargetChange(pointer, newTargetView, oldTargetView) {
      pointer.bubbles = true;
      if (oldTargetView !== void 0) {
        const outEvent = new PointerEvent("pointerout", pointer);
        outEvent.targetView = oldTargetView;
        outEvent.relatedTargetView = newTargetView;
        oldTargetView.bubbleEvent(outEvent);
      }
      pointer.targetView = newTargetView;
      if (newTargetView !== void 0) {
        const overEvent = new PointerEvent("pointerover", pointer);
        overEvent.targetView = newTargetView;
        overEvent.relatedTargetView = oldTargetView;
        newTargetView.bubbleEvent(overEvent);
      }
    }
    detectPointerTarget(pointer, clientBounds) {
      const clientX = pointer.clientX;
      const clientY = pointer.clientY;
      if (clientBounds.contains(clientX, clientY)) {
        const x = clientX - clientBounds.x;
        const y = clientY - clientBounds.y;
        const oldTargetView = pointer.targetView;
        let newTargetView = this.cascadeHitTest(x, y);
        if (newTargetView === null) {
          newTargetView = void 0;
        }
        if (newTargetView !== oldTargetView) {
          this.onPointerTargetChange(pointer, newTargetView, oldTargetView);
        }
      }
    }
    attachPassiveTouchEvents(eventNode) {
      eventNode.addEventListener("touchstart", this.onTouchStart);
    }
    detachPassiveTouchEvents(eventNode) {
      eventNode.removeEventListener("touchstart", this.onTouchStart);
    }
    attachActiveTouchEvents(eventNode) {
      eventNode.addEventListener("touchmove", this.onTouchMove);
      eventNode.addEventListener("touchend", this.onTouchEnd);
      eventNode.addEventListener("touchcancel", this.onTouchCancel);
    }
    detachActiveTouchEvents(eventNode) {
      eventNode.removeEventListener("touchmove", this.onTouchMove);
      eventNode.removeEventListener("touchend", this.onTouchEnd);
      eventNode.removeEventListener("touchcancel", this.onTouchCancel);
    }
    updateTouch(touch, event) {
      touch.clientX = event.clientX;
      touch.clientY = event.clientY;
      touch.screenX = event.screenX;
      touch.screenY = event.screenY;
      touch.pageX = event.pageX;
      touch.pageY = event.pageY;
      touch.radiusX = event.radiusX;
      touch.radiusY = event.radiusY;
      touch.rotationAngle = event.rotationAngle;
      touch.force = event.force;
    }
    fireTouchEvent(type, originalEvent) {
      const changedTouches = originalEvent.changedTouches;
      const dispatched = [];
      for (let i = 0, n = changedTouches.length; i < n; i += 1) {
        const changedTouch = changedTouches[i];
        const targetView = changedTouch.targetView;
        if (targetView !== void 0 && dispatched.indexOf(targetView) < 0) {
          const startEvent = new TouchEvent(type, {
            changedTouches: changedTouches,
            targetTouches: originalEvent.targetTouches,
            touches: originalEvent.touches,
            bubbles: true
          });
          startEvent.targetView = targetView;
          const targetViewTouches = [ changedTouch ];
          for (let j = i + 1; j < n; j += 1) {
            const nextTouch = changedTouches[j];
            if (nextTouch.targetView === targetView) {
              targetViewTouches.push(nextTouch);
            }
          }
          if (document.createTouchList !== void 0) {
            startEvent.targetViewTouches = document.createTouchList(...targetViewTouches);
          } else {
            targetViewTouches.item = function(index) {
              return targetViewTouches[index];
            };
            startEvent.targetViewTouches = targetViewTouches;
          }
          targetView.bubbleEvent(startEvent);
          dispatched.push(targetView);
        }
      }
    }
    onTouchStart(event) {
      let clientBounds;
      let touches = this.touches;
      if (touches === null) {
        touches = {};
        this.touches = touches;
      }
      const changedTouches = event.changedTouches;
      for (let i = 0, n = changedTouches.length; i < n; i += 1) {
        const changedTouch = changedTouches[i];
        const id = "" + changedTouch.identifier;
        let touch = touches[id];
        if (touch === void 0) {
          if (Object.keys(touches).length === 0) {
            this.attachActiveTouchEvents(this.eventNode);
          }
          touch = {
            identifier: changedTouch.identifier,
            target: changedTouch.target
          };
          touches[id] = touch;
        }
        this.updateTouch(touch, changedTouch);
        const clientX = touch.clientX;
        const clientY = touch.clientY;
        if (clientBounds === void 0) {
          clientBounds = this.clientBounds;
        }
        if (clientBounds.contains(clientX, clientY)) {
          const x = clientX - clientBounds.x;
          const y = clientY - clientBounds.y;
          const hit = this.cascadeHitTest(x, y);
          if (hit !== null) {
            touch.targetView = hit;
            changedTouch.targetView = hit;
          }
        }
      }
      this.fireTouchEvent("touchstart", event);
    }
    onTouchMove(event) {
      let touches = this.touches;
      if (touches === null) {
        touches = {};
        this.touches = touches;
      }
      const changedTouches = event.changedTouches;
      for (let i = 0, n = changedTouches.length; i < n; i += 1) {
        const changedTouch = changedTouches[i];
        const id = "" + changedTouch.identifier;
        let touch = touches[id];
        if (touch === void 0) {
          touch = {
            identifier: changedTouch.identifier,
            target: changedTouch.target
          };
          touches[id] = touch;
        }
        this.updateTouch(touch, changedTouch);
        changedTouch.targetView = touch.targetView;
      }
      this.fireTouchEvent("touchmove", event);
    }
    onTouchEnd(event) {
      let touches = this.touches;
      if (touches === null) {
        touches = {};
        this.touches = touches;
      }
      const changedTouches = event.changedTouches;
      const n = changedTouches.length;
      for (let i = 0; i < n; i += 1) {
        const changedTouch = changedTouches[i];
        const id = "" + changedTouch.identifier;
        let touch = touches[id];
        if (touch === void 0) {
          touch = {
            identifier: changedTouch.identifier,
            target: changedTouch.target
          };
          touches[id] = touch;
        }
        this.updateTouch(touch, changedTouch);
        changedTouch.targetView = touch.targetView;
      }
      this.fireTouchEvent("touchend", event);
      for (let i = 0; i < n; i += 1) {
        const changedTouch = changedTouches[i];
        const id = "" + changedTouch.identifier;
        delete touches[id];
        if (Object.keys(touches).length === 0) {
          this.detachActiveTouchEvents(this.eventNode);
        }
      }
    }
    onTouchCancel(event) {
      let touches = this.touches;
      if (touches === null) {
        touches = {};
        this.touches = touches;
      }
      const changedTouches = event.changedTouches;
      const n = changedTouches.length;
      for (let i = 0; i < n; i += 1) {
        const changedTouch = changedTouches[i];
        const id = "" + changedTouch.identifier;
        let touch = touches[id];
        if (touch === void 0) {
          touch = {
            identifier: changedTouch.identifier,
            target: changedTouch.target
          };
          touches[id] = touch;
        }
        this.updateTouch(touch, changedTouch);
        changedTouch.targetView = touch.targetView;
      }
      this.fireTouchEvent("touchcancel", event);
      for (let i = 0; i < n; i += 1) {
        const changedTouch = changedTouches[i];
        const id = "" + changedTouch.identifier;
        delete touches[id];
        if (Object.keys(touches).length === 0) {
          this.detachActiveTouchEvents(this.eventNode);
        }
      }
    }
    resizeCanvas(canvas) {
      let width;
      let height;
      let pixelRatio;
      let parentNode = canvas.parentNode;
      if (parentNode instanceof HTMLElement) {
        do {
          width = Math.floor(parentNode.offsetWidth);
          height = Math.floor(parentNode.offsetHeight);
          if (width !== 0 && height !== 0) {
            break;
          } else if ((width === 0 || height === 0) && HtmlView.isPositioned(parentNode)) {
            this.requireUpdate(View.NeedsResize);
          }
          parentNode = parentNode.parentNode;
        } while (parentNode instanceof HTMLElement);
        pixelRatio = this.pixelRatio;
        canvas.width = width * pixelRatio;
        canvas.height = height * pixelRatio;
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
      } else {
        width = Math.floor(canvas.width);
        height = Math.floor(canvas.height);
        pixelRatio = 1;
      }
      this.viewFrame = new math.R2Box(0, 0, width, height);
    }
    clearCanvas() {
      const renderer = this.renderer;
      if (renderer instanceof CanvasRenderer) {
        const frame = this.viewFrame;
        renderer.context.clearRect(0, 0, frame.width, frame.height);
      } else if (renderer instanceof WebGLRenderer) {
        const context = renderer.context;
        context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);
      }
    }
    resetRenderer() {
      const renderer = this.renderer;
      if (renderer instanceof CanvasRenderer) {
        const pixelRatio = this.pixelRatio;
        renderer.context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      } else if (renderer instanceof WebGLRenderer) {
        const frame = this.viewFrame;
        renderer.context.viewport(0, 0, frame.width, frame.height);
      }
    }
    onObserve(observer) {
      super.onObserve(observer);
      if (observer.viewWillRender !== void 0) {
        this.observerCache.viewWillRenderObservers = util.Arrays.inserted(observer, this.observerCache.viewWillRenderObservers);
      }
      if (observer.viewDidRender !== void 0) {
        this.observerCache.viewDidRenderObservers = util.Arrays.inserted(observer, this.observerCache.viewDidRenderObservers);
      }
      if (observer.viewWillRasterize !== void 0) {
        this.observerCache.viewWillRasterizeObservers = util.Arrays.inserted(observer, this.observerCache.viewWillRasterizeObservers);
      }
      if (observer.viewDidRasterize !== void 0) {
        this.observerCache.viewDidRasterizeObservers = util.Arrays.inserted(observer, this.observerCache.viewDidRasterizeObservers);
      }
      if (observer.viewWillComposite !== void 0) {
        this.observerCache.viewWillCompositeObservers = util.Arrays.inserted(observer, this.observerCache.viewWillCompositeObservers);
      }
      if (observer.viewDidComposite !== void 0) {
        this.observerCache.viewDidCompositeObservers = util.Arrays.inserted(observer, this.observerCache.viewDidCompositeObservers);
      }
    }
    onUnobserve(observer) {
      super.onUnobserve(observer);
      if (observer.viewWillRender !== void 0) {
        this.observerCache.viewWillRenderObservers = util.Arrays.removed(observer, this.observerCache.viewWillRenderObservers);
      }
      if (observer.viewDidRender !== void 0) {
        this.observerCache.viewDidRenderObservers = util.Arrays.removed(observer, this.observerCache.viewDidRenderObservers);
      }
      if (observer.viewWillRasterize !== void 0) {
        this.observerCache.viewWillRasterizeObservers = util.Arrays.removed(observer, this.observerCache.viewWillRasterizeObservers);
      }
      if (observer.viewDidRasterize !== void 0) {
        this.observerCache.viewDidRasterizeObservers = util.Arrays.removed(observer, this.observerCache.viewDidRasterizeObservers);
      }
      if (observer.viewWillComposite !== void 0) {
        this.observerCache.viewWillCompositeObservers = util.Arrays.removed(observer, this.observerCache.viewWillCompositeObservers);
      }
      if (observer.viewDidComposite !== void 0) {
        this.observerCache.viewDidCompositeObservers = util.Arrays.removed(observer, this.observerCache.viewDidCompositeObservers);
      }
    }
    init(init) {
      super.init(init);
      if (init.renderer !== void 0) {
        this.setRenderer(init.renderer);
      }
      if (init.clickEventsEnabled !== void 0) {
        this.clickEventsEnabled(init.clickEventsEnabled);
      }
      if (init.wheelEventsEnabled !== void 0) {
        this.wheelEventsEnabled(init.wheelEventsEnabled);
      }
      if (init.mouseEventsEnabled !== void 0) {
        this.mouseEventsEnabled(init.mouseEventsEnabled);
      }
      if (init.pointerEventsEnabled !== void 0) {
        this.pointerEventsEnabled(init.pointerEventsEnabled);
      }
      if (init.touchEventsEnabled !== void 0) {
        this.touchEventsEnabled(init.touchEventsEnabled);
      }
    }
  }
  CanvasView.tag = "canvas";
  CanvasView.ClickEventsFlag = 1 << 0;
  CanvasView.WheelEventsFlag = 1 << 1;
  CanvasView.MouseEventsFlag = 1 << 2;
  CanvasView.PointerEventsFlag = 1 << 3;
  CanvasView.TouchEventsFlag = 1 << 4;
  CanvasView.EventsMask = CanvasView.ClickEventsFlag | CanvasView.WheelEventsFlag | CanvasView.MouseEventsFlag | CanvasView.PointerEventsFlag | CanvasView.TouchEventsFlag;
  CanvasView.UncullFlags = HtmlView.UncullFlags | View.NeedsRender | View.NeedsComposite;
  CanvasView.UnhideFlags = HtmlView.UnhideFlags | View.NeedsRender | View.NeedsComposite;
  __decorate([ component.Provider({
    type: SpriteService,
    observes: false,
    service: SpriteService.global()
  }) ], CanvasView.prototype, "spriteProvider", void 0);
  class RasterView extends GraphicsView {
    constructor() {
      super();
      this.canvas = this.createCanvas();
      Object.defineProperty(this, "renderer", {
        value: this.createRenderer(),
        writable: true,
        enumerable: true,
        configurable: true
      });
      this.ownRasterFrame = null;
    }
    get pixelRatio() {
      return window.devicePixelRatio || 1;
    }
    get compositor() {
      const parent = this.parent;
      if (parent instanceof GraphicsView || parent instanceof CanvasView) {
        return parent.renderer;
      } else {
        return null;
      }
    }
    setRenderer(renderer) {
      if (typeof renderer === "string") {
        renderer = this.createRenderer(renderer);
      }
      this.renderer = renderer;
      this.requireUpdate(View.NeedsRender | View.NeedsComposite);
    }
    createRenderer(rendererType = "canvas") {
      if (rendererType === "canvas") {
        const context = this.canvas.getContext("2d");
        if (context !== null) {
          return new CanvasRenderer(context, math.Transform.identity(), this.pixelRatio);
        } else {
          throw new Error("Failed to create canvas rendering context");
        }
      } else if (rendererType === "webgl") {
        const context = this.canvas.getContext("webgl");
        if (context !== null) {
          return new WebGLRenderer(context, this.pixelRatio);
        } else {
          throw new Error("Failed to create webgl rendering context");
        }
      } else {
        throw new Error("Failed to create " + rendererType + " renderer");
      }
    }
    needsUpdate(updateFlags, immediate) {
      updateFlags = super.needsUpdate(updateFlags, immediate);
      const rasterFlags = updateFlags & (View.NeedsRender | View.NeedsComposite);
      if (rasterFlags !== 0) {
        updateFlags |= View.NeedsComposite;
        this.setFlags(this.flags | View.NeedsDisplay | View.NeedsComposite | rasterFlags);
      }
      return updateFlags;
    }
    needsProcess(processFlags, viewContext) {
      if ((this.flags & View.ProcessMask) === 0 && (processFlags & View.NeedsResize) === 0) {
        processFlags = 0;
      }
      return processFlags;
    }
    onResize(viewContext) {
      super.onResize(viewContext);
      this.requireUpdate(View.NeedsRender | View.NeedsComposite);
    }
    needsDisplay(displayFlags, viewContext) {
      if ((this.flags & View.DisplayMask) !== 0) {
        displayFlags |= View.NeedsComposite;
      } else if ((displayFlags & View.NeedsComposite) !== 0) {
        displayFlags = View.NeedsDisplay | View.NeedsComposite;
      } else {
        displayFlags = 0;
      }
      return displayFlags;
    }
    onRender(viewContext) {
      const rasterFrame = this.rasterFrame;
      this.resizeCanvas(this.canvas, rasterFrame);
      this.resetRenderer(rasterFrame);
      this.clearCanvas(rasterFrame);
      super.onRender(viewContext);
    }
    didComposite(viewContext) {
      this.compositeImage(viewContext);
      super.didComposite(viewContext);
    }
    extendViewContext(viewContext) {
      const rasterViewContext = Object.create(viewContext);
      rasterViewContext.compositor = viewContext.renderer;
      rasterViewContext.renderer = this.renderer;
      return rasterViewContext;
    }
    get rasterFrame() {
      let rasterFrame = this.ownRasterFrame;
      if (rasterFrame === null) {
        rasterFrame = this.deriveRasterFrame();
      }
      return rasterFrame;
    }
    setRasterFrame(rasterFrame) {
      this.ownRasterFrame = rasterFrame;
    }
    deriveRasterFrame() {
      return this.viewBounds;
    }
    createCanvas() {
      return document.createElement("canvas");
    }
    resizeCanvas(canvas, rasterFrame) {
      const pixelRatio = this.pixelRatio;
      const newWidth = rasterFrame.width;
      const newHeight = rasterFrame.height;
      const newCanvasWidth = newWidth * pixelRatio;
      const newCanvasHeight = newHeight * pixelRatio;
      const oldCanvasWidth = canvas.width;
      const oldCanvasHeight = canvas.height;
      if (newCanvasWidth !== oldCanvasWidth || newCanvasHeight !== oldCanvasHeight) {
        canvas.width = newCanvasWidth;
        canvas.height = newCanvasHeight;
        canvas.style.width = newWidth + "px";
        canvas.style.height = newHeight + "px";
      }
    }
    clearCanvas(rasterFrame) {
      const renderer = this.renderer;
      if (renderer instanceof CanvasRenderer) {
        renderer.context.clearRect(0, 0, rasterFrame.xMax, rasterFrame.yMax);
      } else if (renderer instanceof WebGLRenderer) {
        const context = renderer.context;
        context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);
      }
    }
    resetRenderer(rasterFrame) {
      const renderer = this.renderer;
      if (renderer instanceof CanvasRenderer) {
        const pixelRatio = this.pixelRatio;
        const dx = rasterFrame.xMin * pixelRatio;
        const dy = rasterFrame.yMin * pixelRatio;
        renderer.context.setTransform(pixelRatio, 0, 0, pixelRatio, -dx, -dy);
        renderer.setTransform(math.Transform.affine(pixelRatio, 0, 0, pixelRatio, -dx, -dy));
      } else if (renderer instanceof WebGLRenderer) {
        renderer.context.viewport(rasterFrame.x, rasterFrame.y, rasterFrame.xMax, rasterFrame.yMax);
      }
    }
    compositeImage(viewContext) {
      const compositor = viewContext.compositor;
      if (compositor instanceof CanvasRenderer) {
        const context = compositor.context;
        const rasterFrame = this.rasterFrame;
        const canvas = this.canvas;
        if (rasterFrame.isDefined() && rasterFrame.width !== 0 && rasterFrame.height !== 0 && canvas.width !== 0 && canvas.height !== 0) {
          const globalAlpha = context.globalAlpha;
          const globalCompositeOperation = context.globalCompositeOperation;
          context.globalAlpha = this.opacity.getValue();
          context.globalCompositeOperation = this.compositeOperation.getValue();
          context.drawImage(canvas, rasterFrame.x, rasterFrame.y, rasterFrame.width, rasterFrame.height);
          context.globalAlpha = globalAlpha;
          context.globalCompositeOperation = globalCompositeOperation;
        }
      }
    }
    init(init) {
      super.init(init);
      if (init.opacity !== void 0) {
        this.opacity(init.opacity);
      }
      if (init.compositeOperation !== void 0) {
        this.compositeOperation(init.compositeOperation);
      }
    }
  }
  RasterView.MountFlags = GraphicsView.MountFlags | View.NeedsComposite;
  RasterView.UncullFlags = GraphicsView.UncullFlags | View.NeedsComposite;
  RasterView.UnhideFlags = GraphicsView.UnhideFlags | View.NeedsComposite;
  __decorate([ ThemeConstraintAnimator({
    type: Number,
    value: 1,
    updateFlags: View.NeedsComposite
  }) ], RasterView.prototype, "opacity", void 0);
  __decorate([ component.Property({
    type: String,
    value: "source-over",
    updateFlags: View.NeedsComposite
  }) ], RasterView.prototype, "compositeOperation", void 0);
  Object.defineProperty(RasterView.prototype, "viewBounds", {
    get() {
      return this.deriveViewBounds();
    },
    configurable: true
  });
  const FillView = function() {
    const FillView = {};
    FillView.init = function(view, init) {
      if (init.fill !== void 0) {
        view.fill(init.fill);
      }
    };
    FillView.is = function(object) {
      if (typeof object === "object" && object !== null) {
        const view = object;
        return view instanceof GraphicsView && "fill" in view;
      }
      return false;
    };
    return FillView;
  }();
  const StrokeView = function() {
    const StrokeView = {};
    StrokeView.init = function(view, init) {
      if (init.stroke !== void 0) {
        view.stroke(init.stroke);
      }
      if (init.strokeWidth !== void 0) {
        view.strokeWidth(init.strokeWidth);
      }
    };
    StrokeView.is = function(object) {
      if (typeof object === "object" && object !== null) {
        const view = object;
        return view instanceof GraphicsView && "stroke" in view && "strokeWidth" in view;
      }
      return false;
    };
    return StrokeView;
  }();
  class Rect {
    constructor(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    }
    withX(x) {
      x = math.Length.fromAny(x);
      if (this.x.equals(x)) {
        return this;
      } else {
        return this.copy(x, this.y, this.width, this.height);
      }
    }
    withY(y) {
      y = math.Length.fromAny(y);
      if (this.y.equals(y)) {
        return this;
      } else {
        return this.copy(this.x, y, this.width, this.height);
      }
    }
    withWidth(width) {
      width = math.Length.fromAny(width);
      if (this.width.equals(width)) {
        return this;
      } else {
        return this.copy(this.x, this.y, width, this.height);
      }
    }
    withHeight(height) {
      height = math.Length.fromAny(height);
      if (this.height.equals(height)) {
        return this;
      } else {
        return this.copy(this.x, this.y, this.width, height);
      }
    }
    render(renderer, frame) {
      if (renderer === void 0) {
        const context = new PathContext;
        context.setPrecision(3);
        this.draw(context, frame);
        return context.toString();
      } else if (renderer instanceof PathRenderer) {
        this.draw(renderer.context, frame);
      }
    }
    draw(context, frame = null) {
      this.renderRect(context, frame);
    }
    renderRect(context, frame) {
      context.rect(this.x.pxValue(), this.y.pxValue(), this.width.pxValue(), this.height.pxValue());
    }
    copy(x, y, width, height) {
      return new Rect(x, y, width, height);
    }
    toAny() {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height
      };
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Rect) {
        return this.x.equals(that.x) && this.y.equals(that.y) && this.width.equals(that.width) && this.height.equals(that.height);
      }
      return false;
    }
    debug(output) {
      output = output.write("Rect").write(46).write("create").write(40).debug(this.x).write(", ").debug(this.y).write(", ").debug(this.width).write(", ").debug(this.height).write(41);
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static create(x, y, width, height) {
      x = math.Length.fromAny(x);
      y = math.Length.fromAny(y);
      width = math.Length.fromAny(width);
      height = math.Length.fromAny(height);
      return new Rect(x, y, width, height);
    }
    static fromAny(value) {
      if (value instanceof Rect) {
        return value;
      } else if (typeof value === "object" && value !== null) {
        return Rect.create(value.x, value.y, value.width, value.height);
      }
      throw new TypeError("" + value);
    }
  }
  class RectView extends GraphicsView {
    get value() {
      return new Rect(this.x.getValue(), this.y.getValue(), this.width.getValue(), this.height.getValue());
    }
    get state() {
      return new Rect(this.x.getState(), this.y.getState(), this.width.getState(), this.height.getState());
    }
    setState(rect, timing) {
      if (rect instanceof Rect) {
        rect = rect.toAny();
      }
      if (rect.x !== void 0) {
        this.x(rect.x, timing);
      }
      if (rect.y !== void 0) {
        this.y(rect.y, timing);
      }
      if (rect.width !== void 0) {
        this.width(rect.width, timing);
      }
      if (rect.height !== void 0) {
        this.height(rect.height, timing);
      }
      if (rect.fill !== void 0) {
        this.fill(rect.fill, timing);
      }
      if (rect.stroke !== void 0) {
        this.stroke(rect.stroke, timing);
      }
      if (rect.strokeWidth !== void 0) {
        this.strokeWidth(rect.strokeWidth, timing);
      }
    }
    onRender(viewContext) {
      super.onRender(viewContext);
      const renderer = viewContext.renderer;
      if (renderer instanceof PaintingRenderer && !this.hidden && !this.culled) {
        this.renderRect(renderer.context, this.viewFrame);
      }
    }
    renderRect(context, frame) {
      const x = this.x.getValue().pxValue(frame.width);
      const y = this.y.getValue().pxValue(frame.height);
      const width = this.width.getValue().pxValue(frame.width);
      const height = this.height.getValue().pxValue(frame.height);
      const contextFillStyle = context.fillStyle;
      const contextLineWidth = context.lineWidth;
      const contextStrokeStyle = context.strokeStyle;
      context.beginPath();
      context.rect(x, y, width, height);
      const fill = this.fill.value;
      if (fill !== null) {
        context.fillStyle = fill.toString();
        context.fill();
      }
      const stroke = this.stroke.value;
      if (stroke !== null) {
        const strokeWidth = this.strokeWidth.value;
        if (strokeWidth !== null) {
          const size = Math.min(frame.width, frame.height);
          context.lineWidth = strokeWidth.pxValue(size);
        }
        context.strokeStyle = stroke.toString();
        context.stroke();
      }
      context.fillStyle = contextFillStyle;
      context.lineWidth = contextLineWidth;
      context.strokeStyle = contextStrokeStyle;
    }
    hitTest(x, y, viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer) {
        const p = renderer.transform.transform(x, y);
        return this.hitTestRect(p.x, p.y, renderer.context, this.viewFrame);
      }
      return null;
    }
    hitTestRect(hx, hy, context, frame) {
      const x = this.x.getValue().pxValue(frame.width);
      const y = this.y.getValue().pxValue(frame.height);
      const width = this.width.getValue().pxValue(frame.width);
      const height = this.height.getValue().pxValue(frame.height);
      context.beginPath();
      context.rect(x, y, width, height);
      if (this.fill.value !== null && context.isPointInPath(hx, hy)) {
        return this;
      } else if (this.stroke.value !== null) {
        const strokeWidth = this.strokeWidth.value;
        if (strokeWidth !== null) {
          const contextLineWidth = context.lineWidth;
          const size = Math.min(frame.width, frame.height);
          context.lineWidth = strokeWidth.pxValue(size);
          const pointInStroke = context.isPointInStroke(hx, hy);
          context.lineWidth = contextLineWidth;
          if (pointInStroke) {
            return this;
          }
        }
      }
      return null;
    }
    init(init) {
      if (!(init instanceof Rect)) {
        super.init(init);
      }
      this.setState(init);
    }
  }
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.zero(),
    updateFlags: View.NeedsRender
  }) ], RectView.prototype, "x", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.zero(),
    updateFlags: View.NeedsRender
  }) ], RectView.prototype, "y", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.zero(),
    updateFlags: View.NeedsRender
  }) ], RectView.prototype, "width", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.zero(),
    updateFlags: View.NeedsRender
  }) ], RectView.prototype, "height", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], RectView.prototype, "fill", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], RectView.prototype, "stroke", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], RectView.prototype, "strokeWidth", void 0);
  Object.defineProperty(RectView.prototype, "viewBounds", {
    get() {
      const frame = this.viewFrame;
      const x = this.x.getValue().pxValue(frame.width);
      const y = this.y.getValue().pxValue(frame.height);
      const width = this.width.getValue().pxValue(frame.width);
      const height = this.height.getValue().pxValue(frame.height);
      return new math.R2Box(x, y, x + width, y + height);
    },
    configurable: true
  });
  class Arc {
    constructor(center, innerRadius, outerRadius, startAngle, sweepAngle, padAngle, padRadius, cornerRadius) {
      this.center = center;
      this.innerRadius = innerRadius;
      this.outerRadius = outerRadius;
      this.startAngle = startAngle;
      this.sweepAngle = sweepAngle;
      this.padAngle = padAngle;
      this.padRadius = padRadius;
      this.cornerRadius = cornerRadius;
    }
    withCenter(center) {
      center = math.R2Point.fromAny(center);
      if (this.center.equals(center)) {
        return this;
      } else {
        return this.copy(center, this.innerRadius, this.outerRadius, this.startAngle, this.sweepAngle, this.padAngle, this.padRadius, this.cornerRadius);
      }
    }
    withInnerRadius(innerRadius) {
      innerRadius = math.Length.fromAny(innerRadius);
      if (this.innerRadius.equals(innerRadius)) {
        return this;
      } else {
        return this.copy(this.center, innerRadius, this.outerRadius, this.startAngle, this.sweepAngle, this.padAngle, this.padRadius, this.cornerRadius);
      }
    }
    withOuterRadius(outerRadius) {
      outerRadius = math.Length.fromAny(outerRadius);
      if (this.outerRadius.equals(outerRadius)) {
        return this;
      } else {
        return this.copy(this.center, this.innerRadius, outerRadius, this.startAngle, this.sweepAngle, this.padAngle, this.padRadius, this.cornerRadius);
      }
    }
    withStartAngle(startAngle) {
      startAngle = math.Angle.fromAny(startAngle);
      if (this.startAngle.equals(startAngle)) {
        return this;
      } else {
        return this.copy(this.center, this.innerRadius, this.outerRadius, startAngle, this.sweepAngle, this.padAngle, this.padRadius, this.cornerRadius);
      }
    }
    withSweepAngle(sweepAngle) {
      sweepAngle = math.Angle.fromAny(sweepAngle);
      if (this.sweepAngle.equals(sweepAngle)) {
        return this;
      } else {
        return this.copy(this.center, this.innerRadius, this.outerRadius, this.startAngle, sweepAngle, this.padAngle, this.padRadius, this.cornerRadius);
      }
    }
    withPadAngle(padAngle) {
      padAngle = math.Angle.fromAny(padAngle);
      if (this.padAngle.equals(padAngle)) {
        return this;
      } else {
        return this.copy(this.center, this.innerRadius, this.outerRadius, this.startAngle, this.sweepAngle, padAngle, this.padRadius, this.cornerRadius);
      }
    }
    withPadRadius(padRadius) {
      if (padRadius !== null) {
        padRadius = math.Length.fromAny(padRadius);
      }
      if (util.Equals(this.padRadius, padRadius)) {
        return this;
      } else {
        return this.copy(this.center, this.innerRadius, this.outerRadius, this.startAngle, this.sweepAngle, this.padAngle, padRadius, this.cornerRadius);
      }
    }
    withCornerRadius(cornerRadius) {
      cornerRadius = math.Length.fromAny(cornerRadius);
      if (this.cornerRadius.equals(cornerRadius)) {
        return this;
      } else {
        return this.copy(this.center, this.innerRadius, this.outerRadius, this.startAngle, this.sweepAngle, this.padAngle, this.padRadius, cornerRadius);
      }
    }
    render(renderer, frame) {
      if (renderer === void 0) {
        const context = new PathContext;
        context.setPrecision(3);
        this.draw(context, frame);
        return context.toString();
      } else if (renderer instanceof PathRenderer) {
        this.draw(renderer.context, frame);
      }
    }
    draw(context, frame) {
      this.renderArc(context, frame);
    }
    renderArc(context, frame) {
      let size;
      if (frame !== void 0) {
        size = Math.min(frame.width, frame.height);
      }
      const center = this.center;
      const cx = center.x;
      const cy = center.y;
      let r0 = this.innerRadius.pxValue(size);
      let r1 = this.outerRadius.pxValue(size);
      const a0 = this.startAngle.radValue();
      const da = this.sweepAngle.radValue();
      const a1 = a0 + da;
      const cw = da >= 0;
      if (r1 < r0) {
        const r = r1;
        r1 = r0;
        r0 = r;
      }
      if (!(r1 > Arc.Epsilon)) {
        context.moveTo(cx, cy);
      } else if (da > 2 * Math.PI - Arc.Epsilon) {
        context.moveTo(cx + r1 * Math.cos(a0), cy + r1 * Math.sin(a0));
        context.arc(cx, cy, r1, a0, a1, !cw);
        if (r0 > Arc.Epsilon) {
          context.moveTo(cx + r0 * Math.cos(a1), cy + r0 * Math.sin(a1));
          context.arc(cx, cy, r0, a1, a0, cw);
        }
      } else {
        let a01 = a0;
        let a11 = a1;
        let a00 = a0;
        let a10 = a1;
        let da0 = da;
        let da1 = da;
        const ap = this.padAngle.radValue() / 2;
        const rp = +(ap > Arc.Epsilon) && (this.padRadius !== null ? this.padRadius.pxValue(size) : Math.sqrt(r0 * r0 + r1 * r1));
        const rc = Math.min(Math.abs(r1 - r0) / 2, this.cornerRadius.pxValue(size));
        let rc0 = rc;
        let rc1 = rc;
        if (rp > Arc.Epsilon) {
          let p0 = Math.asin(rp / r0 * Math.sin(ap));
          let p1 = Math.asin(rp / r1 * Math.sin(ap));
          if ((da0 -= p0 * 2) > Arc.Epsilon) {
            p0 *= cw ? 1 : -1;
            a00 += p0;
            a10 -= p0;
          } else {
            da0 = 0;
            a00 = a10 = (a0 + a1) / 2;
          }
          if ((da1 -= p1 * 2) > Arc.Epsilon) {
            p1 *= cw ? 1 : -1;
            a01 += p1;
            a11 -= p1;
          } else {
            da1 = 0;
            a01 = a11 = (a0 + a1) / 2;
          }
        }
        let x00;
        let y00;
        const x01 = r1 * Math.cos(a01);
        const y01 = r1 * Math.sin(a01);
        const x10 = r0 * Math.cos(a10);
        const y10 = r0 * Math.sin(a10);
        let x11;
        let y11;
        if (rc > Arc.Epsilon) {
          x11 = r1 * Math.cos(a11);
          y11 = r1 * Math.sin(a11);
          x00 = r0 * Math.cos(a00);
          y00 = r0 * Math.sin(a00);
          if (da < Math.PI) {
            const oc = da0 > Arc.Epsilon ? Arc.intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [ x10, y10 ];
            const ax = x01 - oc[0];
            const ay = y01 - oc[1];
            const bx = x11 - oc[0];
            const by = y11 - oc[1];
            const kc = 1 / Math.sin(.5 * Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))));
            const lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
            rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
          }
        }
        if (!(da1 > Arc.Epsilon)) {
          context.moveTo(cx + x01, cy + y01);
        } else if (rc1 > Arc.Epsilon) {
          const t0 = Arc.cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
          const t1 = Arc.cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
          context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01);
          if (rc1 < rc) {
            context.arc(cx + t0.cx, cy + t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);
          } else {
            context.arc(cx + t0.cx, cy + t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
            context.arc(cx, cy, r1, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
            context.arc(cx + t1.cx, cy + t1.cy, rc1, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
          }
        } else {
          context.moveTo(cx + x01, cy + y01);
          context.arc(cx, cy, r1, a01, a11, !cw);
        }
        if (!(r0 > Arc.Epsilon) || !(da0 > Arc.Epsilon)) {
          context.lineTo(cx + x10, cy + y10);
        } else if (rc0 > Arc.Epsilon) {
          const t0 = Arc.cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
          const t1 = Arc.cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
          context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01);
          if (rc0 < rc) {
            context.arc(cx + t0.cx, cy + t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);
          } else {
            context.arc(cx + t0.cx, cy + t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
            context.arc(cx, cy, r0, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
            context.arc(cx + t1.cx, cy + t1.cy, rc0, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
          }
        } else {
          context.arc(cx, cy, r0, a10, a00, cw);
        }
      }
      context.closePath();
    }
    copy(center, innerRadius, outerRadius, startAngle, sweepAngle, padAngle, padRadius, cornerRadius) {
      return new Arc(center, innerRadius, outerRadius, startAngle, sweepAngle, padAngle, padRadius, cornerRadius);
    }
    toAny() {
      return {
        center: this.center,
        innerRadius: this.innerRadius,
        outerRadius: this.outerRadius,
        startAngle: this.startAngle,
        sweepAngle: this.sweepAngle,
        padAngle: this.padAngle,
        padRadius: this.padRadius,
        cornerRadius: this.cornerRadius
      };
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Arc) {
        return this.center.equals(that.center) && this.innerRadius.equals(that.innerRadius) && this.outerRadius.equals(that.outerRadius) && this.startAngle.equals(that.startAngle) && this.sweepAngle.equals(that.sweepAngle) && this.padAngle.equals(that.padAngle) && util.Equals(this.padRadius, that.padRadius) && this.cornerRadius.equals(that.cornerRadius);
      }
      return false;
    }
    debug(output) {
      output = output.write("Arc").write(46).write("create").write(40).write(41);
      if (this.center.isDefined()) {
        output = output.write(46).write("center").write(40).debug(this.center).write(41);
      }
      if (this.innerRadius.isDefined()) {
        output = output.write(46).write("innerRadius").write(40).debug(this.innerRadius).write(41);
      }
      if (this.outerRadius.isDefined()) {
        output = output.write(46).write("outerRadius").write(40).debug(this.outerRadius).write(41);
      }
      if (this.startAngle.isDefined()) {
        output = output.write(46).write("startAngle").write(40).debug(this.startAngle).write(41);
      }
      if (this.sweepAngle.isDefined()) {
        output = output.write(46).write("sweepAngle").write(40).debug(this.sweepAngle).write(41);
      }
      if (this.padAngle.isDefined()) {
        output = output.write(46).write("padAngle").write(40).debug(this.padAngle).write(41);
      }
      if (this.padRadius !== null) {
        output = output.write(46).write("padRadius").write(40).debug(this.padRadius).write(41);
      }
      if (this.cornerRadius.isDefined()) {
        output = output.write(46).write("cornerRadius").write(40).debug(this.cornerRadius).write(41);
      }
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static create(center = math.R2Point.origin(), innerRadius = math.Length.zero(), outerRadius = math.Length.zero(), startAngle = math.Angle.zero(), sweepAngle = math.Angle.zero(), padAngle = math.Angle.zero(), padRadius = null, cornerRadius = math.Length.zero()) {
      center = math.R2Point.fromAny(center);
      innerRadius = math.Length.fromAny(innerRadius);
      outerRadius = math.Length.fromAny(outerRadius);
      startAngle = math.Angle.fromAny(startAngle);
      sweepAngle = math.Angle.fromAny(sweepAngle);
      padAngle = math.Angle.fromAny(padAngle);
      padRadius = padRadius !== null ? math.Length.fromAny(padRadius) : null;
      cornerRadius = math.Length.fromAny(cornerRadius);
      return new Arc(center, innerRadius, outerRadius, startAngle, sweepAngle, padAngle, padRadius, cornerRadius);
    }
    static fromAny(value) {
      if (value instanceof Arc) {
        return value;
      } else if (typeof value === "object" && value !== null) {
        return Arc.create(value.center, value.innerRadius, value.outerRadius, value.startAngle, value.sweepAngle, value.padAngle, value.padRadius, value.cornerRadius);
      }
      throw new TypeError("" + value);
    }
    static intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
      const x10 = x1 - x0;
      const y10 = y1 - y0;
      const x32 = x3 - x2;
      const y32 = y3 - y2;
      const t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
      return [ x0 + t * x10, y0 + t * y10 ];
    }
    static cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
      const x01 = x0 - x1;
      const y01 = y0 - y1;
      const lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01);
      const ox = lo * y01;
      const oy = -lo * x01;
      const x11 = x0 + ox;
      const y11 = y0 + oy;
      const x10 = x1 + ox;
      const y10 = y1 + oy;
      const x00 = (x11 + x10) / 2;
      const y00 = (y11 + y10) / 2;
      const dx = x10 - x11;
      const dy = y10 - y11;
      const d2 = dx * dx + dy * dy;
      const r = r1 - rc;
      const D = x11 * y10 - x10 * y11;
      const d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D));
      let cx0 = (D * dy - dx * d) / d2;
      let cy0 = (-D * dx - dy * d) / d2;
      const cx1 = (D * dy + dx * d) / d2;
      const cy1 = (-D * dx + dy * d) / d2;
      const dx0 = cx0 - x00;
      const dy0 = cy0 - y00;
      const dx1 = cx1 - x00;
      const dy1 = cy1 - y00;
      if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
        cx0 = cx1;
        cy0 = cy1;
      }
      return {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
      };
    }
  }
  Arc.Epsilon = 1e-12;
  class ArcView extends GraphicsView {
    get value() {
      return new Arc(this.center.value, this.innerRadius.value, this.outerRadius.value, this.startAngle.value, this.sweepAngle.value, this.padAngle.value, this.padRadius.value, this.cornerRadius.value);
    }
    get state() {
      return new Arc(this.center.state, this.innerRadius.state, this.outerRadius.state, this.startAngle.state, this.sweepAngle.state, this.padAngle.state, this.padRadius.state, this.cornerRadius.state);
    }
    setState(arc, timing) {
      if (arc instanceof Arc) {
        arc = arc.toAny();
      }
      if (arc.center !== void 0) {
        this.center(arc.center, timing);
      }
      if (arc.innerRadius !== void 0) {
        this.innerRadius(arc.innerRadius, timing);
      }
      if (arc.outerRadius !== void 0) {
        this.outerRadius(arc.outerRadius, timing);
      }
      if (arc.startAngle !== void 0) {
        this.startAngle(arc.startAngle, timing);
      }
      if (arc.sweepAngle !== void 0) {
        this.sweepAngle(arc.sweepAngle, timing);
      }
      if (arc.padAngle !== void 0) {
        this.padAngle(arc.padAngle, timing);
      }
      if (arc.padRadius !== void 0) {
        this.padRadius(arc.padRadius, timing);
      }
      if (arc.cornerRadius !== void 0) {
        this.cornerRadius(arc.cornerRadius, timing);
      }
      if (arc.fill !== void 0) {
        this.fill(arc.fill, timing);
      }
      if (arc.stroke !== void 0) {
        this.stroke(arc.stroke, timing);
      }
      if (arc.strokeWidth !== void 0) {
        this.strokeWidth(arc.strokeWidth, timing);
      }
    }
    layoutArc() {
      if (this.center.hasAffinity(component.Affinity.Intrinsic)) {
        const viewFrame = this.viewFrame;
        const cx = viewFrame.xMin + viewFrame.width * this.xAlign.getValue();
        const cy = viewFrame.yMin + viewFrame.height * this.yAlign.getValue();
        this.center.setState(new math.R2Point(cx, cy), component.Affinity.Intrinsic);
      }
    }
    onRender(viewContext) {
      super.onRender(viewContext);
      const renderer = viewContext.renderer;
      if (renderer instanceof PaintingRenderer && !this.hidden && !this.culled) {
        this.layoutArc();
        this.renderArc(renderer.context, this.viewFrame);
      }
    }
    renderArc(context, frame) {
      const contextFillStyle = context.fillStyle;
      const contextLineWidth = context.lineWidth;
      const contextStrokeStyle = context.strokeStyle;
      const arc = this.value;
      context.beginPath();
      arc.draw(context, frame);
      const fill = this.fill.value;
      if (fill !== null) {
        context.fillStyle = fill.toString();
        context.fill();
      }
      const stroke = this.stroke.value;
      if (stroke !== null) {
        const strokeWidth = this.strokeWidth.value;
        if (strokeWidth !== null) {
          const size = Math.min(frame.width, frame.height);
          context.lineWidth = strokeWidth.pxValue(size);
        }
        context.strokeStyle = stroke.toString();
        context.stroke();
      }
      context.fillStyle = contextFillStyle;
      context.lineWidth = contextLineWidth;
      context.strokeStyle = contextStrokeStyle;
    }
    get popoverFrame() {
      const frame = this.viewFrame;
      const size = Math.min(frame.width, frame.height);
      const inversePageTransform = this.pageTransform.inverse();
      const center = this.center.getValue();
      const px = inversePageTransform.transformX(center.x, center.y);
      const py = inversePageTransform.transformY(center.x, center.y);
      const r = (this.innerRadius.getValue().pxValue(size) + this.outerRadius.getValue().pxValue(size)) / 2;
      const a = this.startAngle.getValue().radValue() + this.sweepAngle.getValue().radValue() / 2;
      const x = px + r * Math.cos(a);
      const y = py + r * Math.sin(a);
      return new math.R2Box(x, y, x, y);
    }
    hitTest(x, y, viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer) {
        const p = renderer.transform.transform(x, y);
        this.layoutArc();
        return this.hitTestArc(p.x, p.y, renderer.context, this.viewFrame);
      }
      return null;
    }
    hitTestArc(x, y, context, frame) {
      const arc = this.value;
      context.beginPath();
      arc.draw(context, frame);
      if (this.fill.value !== null && context.isPointInPath(x, y)) {
        return this;
      } else if (this.stroke.value !== null) {
        const strokeWidth = this.strokeWidth.value;
        if (strokeWidth !== null) {
          const contextLineWidth = context.lineWidth;
          const size = Math.min(frame.width, frame.height);
          context.lineWidth = strokeWidth.pxValue(size);
          const pointInStroke = context.isPointInStroke(x, y);
          context.lineWidth = contextLineWidth;
          if (pointInStroke) {
            return this;
          }
        }
      }
      return null;
    }
    init(init) {
      if (!(init instanceof Arc)) {
        super.init(init);
      }
      this.setState(init);
    }
    static fromArc(arc) {
      const view = new ArcView;
      view.setState(arc);
      return view;
    }
  }
  __decorate([ component.Animator({
    type: Number,
    value: .5,
    updateFlags: View.NeedsRender
  }) ], ArcView.prototype, "xAlign", void 0);
  __decorate([ component.Animator({
    type: Number,
    value: .5,
    updateFlags: View.NeedsRender
  }) ], ArcView.prototype, "yAlign", void 0);
  __decorate([ component.Animator({
    type: math.R2Point,
    value: math.R2Point.origin(),
    updateFlags: View.NeedsRender
  }) ], ArcView.prototype, "center", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.zero(),
    updateFlags: View.NeedsRender
  }) ], ArcView.prototype, "innerRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.zero(),
    updateFlags: View.NeedsRender
  }) ], ArcView.prototype, "outerRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Angle,
    value: math.Angle.zero(),
    updateFlags: View.NeedsRender
  }) ], ArcView.prototype, "startAngle", void 0);
  __decorate([ ThemeAnimator({
    type: math.Angle,
    value: math.Angle.zero(),
    updateFlags: View.NeedsRender
  }) ], ArcView.prototype, "sweepAngle", void 0);
  __decorate([ ThemeAnimator({
    type: math.Angle,
    value: math.Angle.zero(),
    updateFlags: View.NeedsRender
  }) ], ArcView.prototype, "padAngle", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    updateFlags: View.NeedsRender
  }) ], ArcView.prototype, "padRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.zero(),
    updateFlags: View.NeedsRender
  }) ], ArcView.prototype, "cornerRadius", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], ArcView.prototype, "fill", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], ArcView.prototype, "stroke", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], ArcView.prototype, "strokeWidth", void 0);
  Object.defineProperty(ArcView.prototype, "viewBounds", {
    get() {
      const frame = this.viewFrame;
      const size = Math.min(frame.width, frame.height);
      const center = this.center.getValue();
      const radius = this.outerRadius.getValue().pxValue(size);
      return new math.R2Box(center.x - radius, center.y - radius, center.x + radius, center.y + radius);
    },
    configurable: true
  });
  const TypesetView = function() {
    const TypesetView = {};
    TypesetView.init = function(view, init) {
      if (init.font !== void 0) {
        view.font(init.font);
      }
      if (init.textAlign !== void 0) {
        view.textAlign(init.textAlign);
      }
      if (init.textBaseline !== void 0) {
        view.textBaseline(init.textBaseline);
      }
      if (init.textOrigin !== void 0) {
        view.textOrigin(init.textOrigin);
      }
      if (init.textColor !== void 0) {
        view.textColor(init.textColor);
      }
    };
    TypesetView.is = function(object) {
      if (typeof object === "object" && object !== null) {
        const view = object;
        return view instanceof GraphicsView && "font" in view && "textAlign" in view && "textBaseline" in view && "textOrigin" in view && "textColor" in view;
      }
      return false;
    };
    return TypesetView;
  }();
  class TextRun {
    constructor(text, font, textAlign, textBaseline, textOrigin, textColor) {
      this.text = text;
      this.font = font;
      this.textAlign = textAlign;
      this.textBaseline = textBaseline;
      this.textOrigin = textOrigin;
      this.textColor = textColor;
    }
    withText(text) {
      if (this.text === text) {
        return this;
      } else {
        return this.copy(text, this.font, this.textAlign, this.textBaseline, this.textOrigin, this.textColor);
      }
    }
    withFont(font) {
      if (font !== null) {
        font = Font.fromAny(font);
      }
      if (this.font === font) {
        return this;
      } else {
        return this.copy(this.text, font, this.textAlign, this.textBaseline, this.textOrigin, this.textColor);
      }
    }
    withTextAlign(textAlign) {
      if (this.textAlign === textAlign) {
        return this;
      } else {
        return this.copy(this.text, this.font, textAlign, this.textBaseline, this.textOrigin, this.textColor);
      }
    }
    withTextBaseline(textBaseline) {
      if (this.textBaseline === textBaseline) {
        return this;
      } else {
        return this.copy(this.text, this.font, this.textAlign, textBaseline, this.textOrigin, this.textColor);
      }
    }
    withTextOrigin(textOrigin) {
      if (textOrigin !== null) {
        textOrigin = math.R2Point.fromAny(textOrigin);
      }
      if (util.Equals(this.textOrigin, textOrigin)) {
        return this;
      } else {
        return this.copy(this.text, this.font, this.textAlign, this.textBaseline, textOrigin, this.textColor);
      }
    }
    withTextColor(textColor) {
      if (textColor !== null) {
        textColor = Color.fromAny(textColor);
      }
      if (util.Equals(this.textColor, textColor)) {
        return this;
      } else {
        return this.copy(this.text, this.font, this.textAlign, this.textBaseline, this.textOrigin, textColor);
      }
    }
    render(renderer, frame) {
      if (renderer instanceof CanvasRenderer) {
        this.draw(renderer.context, frame);
      }
    }
    draw(context, frame) {
      this.renderText(context, frame);
    }
    renderText(context, frame) {
      const contextFont = context.font;
      const contextTextAlign = context.textAlign;
      const contextTextBaseline = context.textBaseline;
      const contextFillStyle = context.fillStyle;
      if (this.font !== null) {
        context.font = this.font.toString();
      }
      if (this.textAlign !== null) {
        context.textAlign = this.textAlign;
      }
      if (this.textBaseline !== null) {
        context.textBaseline = this.textBaseline;
      }
      if (this.textColor !== null) {
        context.fillStyle = this.textColor.toString();
      }
      let textOrigin = this.textOrigin;
      if (textOrigin === null) {
        textOrigin = math.R2Point.origin();
      }
      context.fillText(this.text, textOrigin.x, textOrigin.y);
      context.font = contextFont;
      context.textAlign = contextTextAlign;
      context.textBaseline = contextTextBaseline;
      context.fillStyle = contextFillStyle;
    }
    copy(text, font, textAlign, textBaseline, textOrigin, textColor) {
      return new TextRun(text, font, textAlign, textBaseline, textOrigin, textColor);
    }
    toAny() {
      const init = {
        text: this.text
      };
      init.text = this.text;
      if (this.font !== null) {
        init.font = this.font;
      }
      if (this.font !== null) {
        init.font = this.font;
      }
      if (this.textAlign !== null) {
        init.textAlign = this.textAlign;
      }
      if (this.textBaseline !== null) {
        init.textBaseline = this.textBaseline;
      }
      if (this.textOrigin !== null) {
        init.textOrigin = this.textOrigin;
      }
      if (this.textColor !== null) {
        init.textColor = this.textColor;
      }
      return init;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof TextRun) {
        return this.text === that.text && util.Equals(this.font, that.font) && this.textAlign === that.textAlign && this.textBaseline === that.textBaseline && util.Equals(this.textOrigin, that.textOrigin) && util.Equals(this.textColor, that.textColor);
      }
      return false;
    }
    debug(output) {
      output = output.write("TextRun").write(46).write("create").write(40).debug(this.text).write(41);
      if (this.font !== null) {
        output = output.write(46).write("font").write(40).debug(this.font).write(41);
      }
      if (this.textAlign !== null) {
        output = output.write(46).write("textAlign").write(40).debug(this.textAlign).write(41);
      }
      if (this.textBaseline !== null) {
        output = output.write(46).write("textBaseline").write(40).debug(this.textBaseline).write(41);
      }
      if (this.textOrigin !== null) {
        output = output.write(46).write("textOrigin").write(40).debug(this.textOrigin).write(41);
      }
      if (this.textColor !== null) {
        output = output.write(46).write("textColor").write(40).debug(this.textColor).write(41);
      }
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static create(text, font = null, textAlign = null, textBaseline = null, textOrigin = null, textColor = null) {
      if (font !== null) {
        font = Font.fromAny(font);
      }
      if (textOrigin !== null) {
        textOrigin = math.R2Point.fromAny(textOrigin);
      }
      if (textColor !== null) {
        textColor = Color.fromAny(textColor);
      }
      return new TextRun(text, font, textAlign, textBaseline, textOrigin, textColor);
    }
    static fromAny(value) {
      if (value instanceof TextRun) {
        return value;
      } else if (typeof value === "string") {
        return TextRun.create(value);
      } else if (typeof value === "object" && value !== null) {
        return TextRun.create(value.text, value.font, value.textAlign, value.textBaseline, value.textOrigin, value.textColor);
      }
      throw new TypeError("" + value);
    }
  }
  class TextRunView extends GraphicsView {
    get value() {
      return new TextRun(this.text.getValue(), this.font.getValue(), this.textAlign.getValue(), this.textBaseline.getValue(), this.textOrigin.getValue(), this.textColor.getValue());
    }
    get state() {
      return new TextRun(this.text.getState(), this.font.getState(), this.textAlign.getState(), this.textBaseline.getState(), this.textOrigin.getState(), this.textColor.getState());
    }
    setState(run, timing) {
      if (typeof run === "string") {
        this.text(run, timing);
      } else {
        if (run instanceof TextRun) {
          run = run.toAny();
        }
        if (run.text !== void 0) {
          this.text(run.text, timing);
        }
        if (run.font !== void 0) {
          this.font(run.font, timing);
        }
        if (run.textAlign !== void 0) {
          this.textAlign(run.textAlign, timing);
        }
        if (run.textBaseline !== void 0) {
          this.textBaseline(run.textBaseline, timing);
        }
        if (run.textOrigin !== void 0) {
          this.textOrigin(run.textOrigin, timing);
        }
        if (run.textColor !== void 0) {
          this.textColor(run.textColor, timing);
        }
      }
    }
    onRender(viewContext) {
      super.onRender(viewContext);
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer && !this.hidden && !this.culled) {
        this.renderText(renderer.context);
      }
    }
    renderText(context) {
      const contextFont = context.font;
      const contextTextAlign = context.textAlign;
      const contextTextBaseline = context.textBaseline;
      const contextFillStyle = context.fillStyle;
      const font = this.font.value;
      if (font !== null) {
        context.font = font.toString();
      }
      const textAlign = this.textAlign.value;
      if (textAlign !== void 0) {
        context.textAlign = textAlign;
      }
      const textBaseline = this.textBaseline.value;
      if (textBaseline !== void 0) {
        context.textBaseline = textBaseline;
      }
      const textColor = this.textColor.value;
      if (textColor !== null) {
        context.fillStyle = textColor.toString();
      }
      let textOrigin = this.textOrigin.value;
      if (textOrigin === null) {
        textOrigin = math.R2Point.origin();
      }
      context.fillText(this.text.getValue(), textOrigin.x, textOrigin.y);
      context.font = contextFont;
      context.textAlign = contextTextAlign;
      context.textBaseline = contextTextBaseline;
      context.fillStyle = contextFillStyle;
    }
    init(init) {
      if (typeof init !== "string") {
        if (!(init instanceof TextRun)) {
          super.init(init);
        }
        this.setState(init);
      } else {
        this.text(init);
      }
    }
  }
  __decorate([ ThemeAnimator({
    type: String,
    value: "",
    updateFlags: View.NeedsRender
  }) ], TextRunView.prototype, "text", void 0);
  __decorate([ ThemeAnimator({
    type: Font,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], TextRunView.prototype, "font", void 0);
  __decorate([ ThemeAnimator({
    type: String,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], TextRunView.prototype, "textAlign", void 0);
  __decorate([ ThemeAnimator({
    type: String,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], TextRunView.prototype, "textBaseline", void 0);
  __decorate([ ThemeAnimator({
    type: math.R2Point,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], TextRunView.prototype, "textOrigin", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], TextRunView.prototype, "textColor", void 0);
  const IconLayout = function() {
    const IconLayout = {};
    IconLayout.fromAny = function(value) {
      if (value === void 0 || value === null) {
        return value;
      } else {
        const iconWidth = math.Length.fromAny(value.iconWidth);
        const iconHeight = math.Length.fromAny(value.iconHeight);
        const xAlign = value.xAlign;
        const yAlign = value.yAlign;
        return {
          iconWidth: iconWidth,
          iconHeight: iconHeight,
          xAlign: xAlign,
          yAlign: yAlign
        };
      }
    };
    IconLayout.is = function(object) {
      if (typeof object === "object" && object !== null || typeof object === "function") {
        const viewport = object;
        return "iconWidth" in viewport && "iconHeight" in viewport;
      }
      return false;
    };
    return IconLayout;
  }();
  class Icon {}
  class FilledIcon extends Icon {}
  class VectorIcon extends FilledIcon {
    constructor(path, fillRule, fillColor, fillLook, moodModifier) {
      super();
      this.path = path;
      this.fillRule = fillRule;
      this.fillColor = fillColor;
      this.fillLook = fillLook;
      this.moodModifier = moodModifier;
    }
    withFillRule(fillRule) {
      if (util.Equals(this.fillRule, fillRule)) {
        return this;
      } else {
        return this.copy(this.path, fillRule, this.fillColor, this.fillLook, this.moodModifier);
      }
    }
    withFillColor(fillColor) {
      if (util.Equals(this.fillColor, fillColor)) {
        return this;
      } else {
        return this.copy(this.path, this.fillRule, fillColor, this.fillLook, this.moodModifier);
      }
    }
    withFillLook(fillLook) {
      if (this.fillLook === fillLook) {
        return this;
      } else {
        return this.copy(this.path, this.fillRule, this.fillColor, fillLook, this.moodModifier);
      }
    }
    withMoodModifier(moodModifier) {
      if (util.Equals(this.moodModifier, moodModifier)) {
        return this;
      } else {
        return this.copy(this.path, this.fillRule, this.fillColor, this.fillLook, moodModifier);
      }
    }
    modifyMood(feel, updates) {
      let oldMoodModifier = this.moodModifier;
      if (oldMoodModifier === null) {
        oldMoodModifier = MoodMatrix.empty();
      }
      const newMoodModifier = oldMoodModifier.updatedCol(feel, updates, true);
      if (!newMoodModifier.equals(oldMoodModifier)) {
        return this.withMoodModifier(newMoodModifier);
      } else {
        return this;
      }
    }
    isThemed() {
      return this.fillColor !== null;
    }
    withTheme(theme, mood) {
      const fillLook = this.fillLook;
      if (fillLook !== null) {
        const moodModifier = this.moodModifier;
        if (moodModifier !== null) {
          mood = moodModifier.timesCol(mood, true);
        }
        return this.withFillColor(theme.getOr(fillLook, mood, null));
      } else {
        return this;
      }
    }
    render(renderer, frame) {
      if (renderer instanceof PaintingRenderer) {
        this.paint(renderer.context, frame);
      } else if (renderer instanceof DrawingRenderer) {
        this.draw(renderer.context, frame);
      }
    }
    paint(context, frame) {
      const contextFillStyle = context.fillStyle;
      context.beginPath();
      this.draw(context, frame);
      if (this.fillColor !== null) {
        context.fillStyle = this.fillColor.toString();
      }
      context.fill(this.fillRule);
      context.fillStyle = contextFillStyle;
    }
    draw(context, frame) {
      const transform = math.Transform.scale(frame.width, frame.height).translate(frame.x, frame.y);
      this.path.transformDraw(context, transform);
    }
    copy(path, fillRule, fillColor, fillLook, moodModifier) {
      return new VectorIcon(path, fillRule, fillColor, fillLook, moodModifier);
    }
    interpolateTo(that) {
      if (that instanceof VectorIcon) {
        return VectorIconInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof VectorIcon) {
        return this.path.equivalentTo(that.path, epsilon) && this.fillRule === that.fillRule && util.Equivalent(this.fillColor, that.fillColor, epsilon) && this.fillLook === that.fillLook && util.Equivalent(this.moodModifier, that.moodModifier, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof VectorIcon) {
        return this.path.equals(that.path) && this.fillRule === that.fillRule && util.Equals(this.fillColor, that.fillColor) && this.fillLook === that.fillLook && util.Equals(this.moodModifier, that.moodModifier);
      }
      return false;
    }
    debug(output) {
      output = output.write("new").write(32).write("VectorIcon").write(40).debug(this.path).write(", ").debug(this.fillRule).write(", ").debug(this.fillColor).write(", ").debug(this.fillLook).write(", ").debug(this.moodModifier).write(41);
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static create(width, height, path, fillRule) {
      path = math.R2Path.fromAny(path);
      if (width !== 1 || height !== 1) {
        path = path.transform(math.Transform.scale(1 / width, 1 / height));
      }
      if (fillRule === void 0) {
        fillRule = "nonzero";
      }
      return new VectorIcon(path, fillRule, null, Look.iconColor, null);
    }
  }
  const VectorIconInterpolator = function(_super) {
    const VectorIconInterpolator = function(i0, i1) {
      const interpolator = function(u) {
        const path = interpolator.path;
        const fillRule = interpolator.fillRule;
        const fillColor = interpolator.fillColorInterpolator(u);
        const fillLook = interpolator.fillLook;
        const moodModifier = interpolator.moodModifier;
        return new VectorIcon(path, fillRule, fillColor, fillLook, moodModifier);
      };
      Object.setPrototypeOf(interpolator, VectorIconInterpolator.prototype);
      interpolator.path = i1.path;
      interpolator.fillRule = i1.fillRule;
      interpolator.fillColorInterpolator = util.Interpolator(i0.fillColor, i1.fillColor);
      interpolator.fillLook = i1.fillLook;
      interpolator.moodModifier = i1.moodModifier;
      return interpolator;
    };
    VectorIconInterpolator.prototype = Object.create(_super.prototype);
    VectorIconInterpolator.prototype.constructor = VectorIconInterpolator;
    Object.defineProperty(VectorIconInterpolator.prototype, 0, {
      get() {
        const path = this.path;
        const fillRule = this.fillRule;
        const fillColor = this.fillColorInterpolator[0];
        const fillLook = this.fillLook;
        const moodModifier = this.moodModifier;
        return new VectorIcon(path, fillRule, fillColor, fillLook, moodModifier);
      },
      configurable: true
    });
    Object.defineProperty(VectorIconInterpolator.prototype, 1, {
      get() {
        const path = this.path;
        const fillRule = this.fillRule;
        const fillColor = this.fillColorInterpolator[1];
        const fillLook = this.fillLook;
        const moodModifier = this.moodModifier;
        return new VectorIcon(path, fillRule, fillColor, fillLook, moodModifier);
      },
      configurable: true
    });
    VectorIconInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof VectorIconInterpolator) {
        return this.path.equals(that.path) && this.fillRule === that.fillRule && this.fillColorInterpolator.equals(that.fillColorInterpolator) && this.fillLook === that.fillLook && util.Equals(this.moodModifier, that.moodModifier);
      }
      return false;
    };
    return VectorIconInterpolator;
  }(util.Interpolator);
  class CircleIcon extends FilledIcon {
    constructor(fillColor, fillLook, moodModifier) {
      super();
      this.fillColor = fillColor;
      this.fillLook = fillLook;
      this.moodModifier = moodModifier;
    }
    withFillColor(fillColor) {
      if (util.Equals(this.fillColor, fillColor)) {
        return this;
      } else {
        return this.copy(fillColor, this.fillLook, this.moodModifier);
      }
    }
    withFillLook(fillLook) {
      if (this.fillLook === fillLook) {
        return this;
      } else {
        return this.copy(this.fillColor, fillLook, this.moodModifier);
      }
    }
    withMoodModifier(moodModifier) {
      if (util.Equals(this.moodModifier, moodModifier)) {
        return this;
      } else {
        return this.copy(this.fillColor, this.fillLook, moodModifier);
      }
    }
    modifyMood(feel, updates) {
      let oldMoodModifier = this.moodModifier;
      if (oldMoodModifier === null) {
        oldMoodModifier = MoodMatrix.empty();
      }
      const newMoodModifier = oldMoodModifier.updatedCol(feel, updates, true);
      if (!newMoodModifier.equals(oldMoodModifier)) {
        return this.withMoodModifier(newMoodModifier);
      } else {
        return this;
      }
    }
    isThemed() {
      return this.fillColor !== null;
    }
    withTheme(theme, mood) {
      const fillLook = this.fillLook;
      if (fillLook !== null) {
        const moodModifier = this.moodModifier;
        if (moodModifier !== null) {
          mood = moodModifier.timesCol(mood, true);
        }
        return this.withFillColor(theme.getOr(fillLook, mood, null));
      } else {
        return this;
      }
    }
    render(renderer, frame) {
      if (renderer instanceof PaintingRenderer) {
        this.paint(renderer.context, frame);
      } else if (renderer instanceof DrawingRenderer) {
        this.draw(renderer.context, frame);
      }
    }
    paint(context, frame) {
      const contextFillStyle = context.fillStyle;
      context.beginPath();
      this.draw(context, frame);
      if (this.fillColor !== null) {
        context.fillStyle = this.fillColor.toString();
      }
      context.fill();
      context.fillStyle = contextFillStyle;
    }
    draw(context, frame) {
      const centerX = (frame.xMin + frame.xMax) / 2;
      const centerY = (frame.yMin + frame.yMax) / 2;
      const width = frame.width;
      const height = frame.height;
      const radius = Math.min(width, height) / 2;
      context.arc(centerX, centerY, radius, 0, 2 * Math.PI);
      context.closePath();
    }
    copy(fillColor, fillLook, moodModifier) {
      return new CircleIcon(fillColor, fillLook, moodModifier);
    }
    interpolateTo(that) {
      if (that instanceof CircleIcon) {
        return CircleIconInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof CircleIcon) {
        return util.Equivalent(this.fillColor, that.fillColor, epsilon) && this.fillLook === that.fillLook && util.Equivalent(this.moodModifier, that.moodModifier, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof CircleIcon) {
        return util.Equals(this.fillColor, that.fillColor) && this.fillLook === that.fillLook && util.Equals(this.moodModifier, that.moodModifier);
      }
      return false;
    }
    debug(output) {
      output = output.write("new").write(32).write("CircleIcon").write(40).debug(this.fillColor).write(", ").debug(this.fillLook).write(", ").debug(this.moodModifier).write(41);
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static create() {
      return new CircleIcon(null, Look.accentColor, null);
    }
  }
  __decorate([ util.Lazy ], CircleIcon, "create", null);
  const CircleIconInterpolator = function(_super) {
    const CircleIconInterpolator = function(i0, i1) {
      const interpolator = function(u) {
        const fillColor = interpolator.fillColorInterpolator(u);
        const fillLook = interpolator.fillLook;
        const moodModifier = interpolator.moodModifier;
        return new CircleIcon(fillColor, fillLook, moodModifier);
      };
      Object.setPrototypeOf(interpolator, CircleIconInterpolator.prototype);
      interpolator.fillColorInterpolator = util.Interpolator(i0.fillColor, i1.fillColor);
      interpolator.fillLook = i1.fillLook;
      interpolator.moodModifier = i1.moodModifier;
      return interpolator;
    };
    CircleIconInterpolator.prototype = Object.create(_super.prototype);
    CircleIconInterpolator.prototype.constructor = CircleIconInterpolator;
    Object.defineProperty(CircleIconInterpolator.prototype, 0, {
      get() {
        const fillColor = this.fillColorInterpolator[0];
        const fillLook = this.fillLook;
        const moodModifier = this.moodModifier;
        return new CircleIcon(fillColor, fillLook, moodModifier);
      },
      configurable: true
    });
    Object.defineProperty(CircleIconInterpolator.prototype, 1, {
      get() {
        const fillColor = this.fillColorInterpolator[1];
        const fillLook = this.fillLook;
        const moodModifier = this.moodModifier;
        return new CircleIcon(fillColor, fillLook, moodModifier);
      },
      configurable: true
    });
    CircleIconInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof CircleIconInterpolator) {
        return this.fillColorInterpolator.equals(that.fillColorInterpolator) && this.fillLook === that.fillLook && util.Equals(this.moodModifier, that.moodModifier);
      }
      return false;
    };
    return CircleIconInterpolator;
  }(util.Interpolator);
  class PolygonIcon extends FilledIcon {
    constructor(sides, rotation, fillColor, fillLook, moodModifier) {
      super();
      this.sides = sides;
      this.rotation = rotation;
      this.fillColor = fillColor;
      this.fillLook = fillLook;
      this.moodModifier = moodModifier;
    }
    withFillColor(fillColor) {
      if (util.Equals(this.fillColor, fillColor)) {
        return this;
      } else {
        return this.copy(this.sides, this.rotation, fillColor, this.fillLook, this.moodModifier);
      }
    }
    withFillLook(fillLook) {
      if (this.fillLook === fillLook) {
        return this;
      } else {
        return this.copy(this.sides, this.rotation, this.fillColor, fillLook, this.moodModifier);
      }
    }
    withMoodModifier(moodModifier) {
      if (util.Equals(this.moodModifier, moodModifier)) {
        return this;
      } else {
        return this.copy(this.sides, this.rotation, this.fillColor, this.fillLook, moodModifier);
      }
    }
    modifyMood(feel, updates) {
      let oldMoodModifier = this.moodModifier;
      if (oldMoodModifier === null) {
        oldMoodModifier = MoodMatrix.empty();
      }
      const newMoodModifier = oldMoodModifier.updatedCol(feel, updates, true);
      if (!newMoodModifier.equals(oldMoodModifier)) {
        return this.withMoodModifier(newMoodModifier);
      } else {
        return this;
      }
    }
    isThemed() {
      return this.fillColor !== null;
    }
    withTheme(theme, mood) {
      const fillLook = this.fillLook;
      if (fillLook !== null) {
        const moodModifier = this.moodModifier;
        if (moodModifier !== null) {
          mood = moodModifier.timesCol(mood, true);
        }
        return this.withFillColor(theme.getOr(fillLook, mood, null));
      } else {
        return this;
      }
    }
    render(renderer, frame) {
      if (renderer instanceof PaintingRenderer) {
        this.paint(renderer.context, frame);
      } else if (renderer instanceof DrawingRenderer) {
        this.draw(renderer.context, frame);
      }
    }
    paint(context, frame) {
      const contextFillStyle = context.fillStyle;
      context.beginPath();
      this.draw(context, frame);
      if (this.fillColor !== null) {
        context.fillStyle = this.fillColor.toString();
      }
      context.fill();
      context.fillStyle = contextFillStyle;
    }
    draw(context, frame) {
      const sides = this.sides;
      if (sides >= 3) {
        const centerX = (frame.xMin + frame.xMax) / 2;
        const centerY = (frame.yMin + frame.yMax) / 2;
        const width = frame.width;
        const height = frame.height;
        const radius = Math.min(width, height) / 2;
        const sector = 2 * Math.PI / sides;
        let angle = this.rotation.radValue();
        context.moveTo(centerX + radius * Math.cos(angle), centerY + radius * Math.sin(angle));
        angle += sector;
        for (let i = 1; i < sides; i += 1) {
          context.lineTo(centerX + radius * Math.cos(angle), centerY + radius * Math.sin(angle));
          angle += sector;
        }
        context.closePath();
      }
    }
    copy(sides, rotation, fillColor, fillLook, moodModifier) {
      return new PolygonIcon(sides, rotation, fillColor, fillLook, moodModifier);
    }
    interpolateTo(that) {
      if (that instanceof PolygonIcon) {
        return PolygonIconInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof PolygonIcon) {
        return this.sides === that.sides && this.rotation.equivalentTo(that.rotation, epsilon) && util.Equivalent(this.fillColor, that.fillColor, epsilon) && this.fillLook === that.fillLook && util.Equivalent(this.moodModifier, that.moodModifier, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof PolygonIcon) {
        return this.sides === that.sides && this.rotation.equals(that.rotation) && util.Equals(this.fillColor, that.fillColor) && this.fillLook === that.fillLook && util.Equals(this.moodModifier, that.moodModifier);
      }
      return false;
    }
    debug(output) {
      output = output.write("new").write(32).write("PolygonIcon").write(40).debug(this.sides).write(", ").debug(this.rotation).write(", ").debug(this.fillColor).write(", ").debug(this.fillLook).write(", ").debug(this.moodModifier).write(41);
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static create(sides, rotation) {
      if (rotation !== void 0) {
        rotation = math.Angle.fromAny(rotation);
      } else {
        rotation = math.Angle.zero();
      }
      return new PolygonIcon(sides, rotation, null, Look.accentColor, null);
    }
  }
  const PolygonIconInterpolator = function(_super) {
    const PolygonIconInterpolator = function(i0, i1) {
      const interpolator = function(u) {
        const sides = interpolator.sides;
        const rotation = interpolator.rotationInterpolator(u);
        const fillColor = interpolator.fillColorInterpolator(u);
        const fillLook = interpolator.fillLook;
        const moodModifier = interpolator.moodModifier;
        return new PolygonIcon(sides, rotation, fillColor, fillLook, moodModifier);
      };
      Object.setPrototypeOf(interpolator, PolygonIconInterpolator.prototype);
      interpolator.sides = i1.sides;
      interpolator.rotationInterpolator = i0.rotation.interpolateTo(i1.rotation);
      interpolator.fillColorInterpolator = util.Interpolator(i0.fillColor, i1.fillColor);
      interpolator.fillLook = i1.fillLook;
      interpolator.moodModifier = i1.moodModifier;
      return interpolator;
    };
    PolygonIconInterpolator.prototype = Object.create(_super.prototype);
    PolygonIconInterpolator.prototype.constructor = PolygonIconInterpolator;
    Object.defineProperty(PolygonIconInterpolator.prototype, 0, {
      get() {
        const sides = this.sides;
        const rotation = this.rotationInterpolator[0];
        const fillColor = this.fillColorInterpolator[0];
        const fillLook = this.fillLook;
        const moodModifier = this.moodModifier;
        return new PolygonIcon(sides, rotation, fillColor, fillLook, moodModifier);
      },
      configurable: true
    });
    Object.defineProperty(PolygonIconInterpolator.prototype, 1, {
      get() {
        const sides = this.sides;
        const rotation = this.rotationInterpolator[1];
        const fillColor = this.fillColorInterpolator[1];
        const fillLook = this.fillLook;
        const moodModifier = this.moodModifier;
        return new PolygonIcon(sides, rotation, fillColor, fillLook, moodModifier);
      },
      configurable: true
    });
    PolygonIconInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof PolygonIconInterpolator) {
        return this.sides === that.sides && this.rotationInterpolator.equals(that.rotationInterpolator) && this.fillColorInterpolator.equals(that.fillColorInterpolator) && this.fillLook === that.fillLook && util.Equals(this.moodModifier, that.moodModifier);
      }
      return false;
    };
    return PolygonIconInterpolator;
  }(util.Interpolator);
  class EnclosedIcon extends Icon {
    constructor(outer, inner, innerScale, moodModifier, outerMoodModifier, innerMoodModifier) {
      super();
      this.outer = outer;
      this.inner = inner;
      this.innerScale = innerScale;
      this.moodModifier = moodModifier;
      this.outerMoodModifier = outerMoodModifier;
      this.innerMoodModifier = innerMoodModifier;
    }
    withOuter(outer) {
      if (this.outer === outer) {
        return this;
      } else {
        return this.copy(outer, this.inner, this.innerScale, this.moodModifier, this.outerMoodModifier, this.innerMoodModifier);
      }
    }
    withInner(inner) {
      if (this.inner === inner) {
        return this;
      } else {
        return this.copy(this.outer, inner, this.innerScale, this.moodModifier, this.outerMoodModifier, this.innerMoodModifier);
      }
    }
    withInnerScale(innerScale) {
      if (this.innerScale === innerScale) {
        return this;
      } else {
        return this.copy(this.outer, this.inner, innerScale, this.moodModifier, this.outerMoodModifier, this.innerMoodModifier);
      }
    }
    withMoodModifier(moodModifier) {
      if (util.Equals(this.moodModifier, moodModifier)) {
        return this;
      } else {
        return this.copy(this.outer, this.inner, this.innerScale, moodModifier, this.outerMoodModifier, this.innerMoodModifier);
      }
    }
    modifyMood(feel, updates) {
      let oldMoodModifier = this.moodModifier;
      if (oldMoodModifier === null) {
        oldMoodModifier = MoodMatrix.empty();
      }
      const newMoodModifier = oldMoodModifier.updatedCol(feel, updates, true);
      if (!newMoodModifier.equals(oldMoodModifier)) {
        return this.withMoodModifier(newMoodModifier);
      } else {
        return this;
      }
    }
    withOuterMoodModifier(outerMoodModifier) {
      if (util.Equals(this.outerMoodModifier, outerMoodModifier)) {
        return this;
      } else {
        return this.copy(this.outer, this.inner, this.innerScale, this.moodModifier, outerMoodModifier, this.innerMoodModifier);
      }
    }
    modifyOuterMood(feel, updates) {
      let oldOuterMoodModifier = this.outerMoodModifier;
      if (oldOuterMoodModifier === null) {
        oldOuterMoodModifier = MoodMatrix.empty();
      }
      const newOuterMoodModifier = oldOuterMoodModifier.updatedCol(feel, updates, true);
      if (!newOuterMoodModifier.equals(oldOuterMoodModifier)) {
        return this.withOuterMoodModifier(newOuterMoodModifier);
      } else {
        return this;
      }
    }
    withInnerMoodModifier(innerMoodModifier) {
      if (util.Equals(this.innerMoodModifier, innerMoodModifier)) {
        return this;
      } else {
        return this.copy(this.outer, this.inner, this.innerScale, this.moodModifier, this.outerMoodModifier, innerMoodModifier);
      }
    }
    modifyInnerMood(feel, updates) {
      let oldInnerMoodModifier = this.innerMoodModifier;
      if (oldInnerMoodModifier === null) {
        oldInnerMoodModifier = MoodMatrix.empty();
      }
      const newInnerMoodModifier = oldInnerMoodModifier.updatedCol(feel, updates, true);
      if (!newInnerMoodModifier.equals(oldInnerMoodModifier)) {
        return this.withInnerMoodModifier(newInnerMoodModifier);
      } else {
        return this;
      }
    }
    isThemed() {
      const outer = this.outer;
      const inner = this.inner;
      return (outer === null || outer.isThemed()) && (inner === null || inner.isThemed());
    }
    withTheme(theme, mood) {
      const moodModifier = this.moodModifier;
      const outerMoodModifier = this.outerMoodModifier;
      const innerMoodModifier = this.innerMoodModifier;
      let modifiedMood = mood;
      if (moodModifier !== null) {
        modifiedMood = moodModifier.timesCol(modifiedMood, true);
      }
      const oldOuter = this.outer;
      let newOuter;
      if (oldOuter !== null) {
        let outerMood = modifiedMood;
        if (outerMoodModifier !== null) {
          outerMood = outerMoodModifier.timesCol(outerMood, true);
        }
        newOuter = oldOuter.withTheme(theme, outerMood);
      } else {
        newOuter = null;
      }
      const oldInner = this.inner;
      let newInner;
      if (oldInner !== null) {
        let innerMood = modifiedMood;
        if (innerMoodModifier !== null) {
          innerMood = innerMoodModifier.timesCol(innerMood, true);
        }
        newInner = oldInner.withTheme(theme, innerMood);
      } else {
        newInner = null;
      }
      if (oldOuter !== newOuter || oldInner !== newInner) {
        return this.copy(newOuter, newInner, this.innerScale, moodModifier, outerMoodModifier, innerMoodModifier);
      } else {
        return this;
      }
    }
    render(renderer, frame) {
      if (renderer instanceof PaintingRenderer) {
        this.paint(renderer.context, frame);
      } else if (renderer instanceof DrawingRenderer) {
        this.draw(renderer.context, frame);
      }
    }
    paint(context, frame) {
      const outer = this.outer;
      if (outer !== null) {
        outer.paint(context, this.outerFrame(frame));
      }
      const inner = this.inner;
      if (inner !== null) {
        inner.paint(context, this.innerFrame(frame));
      }
    }
    draw(context, frame) {
      const outer = this.outer;
      if (outer !== null) {
        outer.draw(context, this.outerFrame(frame));
      }
      const inner = this.inner;
      if (inner !== null) {
        inner.draw(context, this.innerFrame(frame));
      }
    }
    outerFrame(frame) {
      return frame;
    }
    innerFrame(frame) {
      let {xMin: xMin, xMax: xMax, yMin: yMin, yMax: yMax} = frame;
      let width = xMax - xMin;
      let height = yMax - yMin;
      const innerScale = this.innerScale;
      if (innerScale !== 1) {
        const cx = (xMin + xMax) / 2;
        const cy = (yMin + yMax) / 2;
        width = width * innerScale;
        height = height * innerScale;
        xMin = cx - width / 2;
        yMin = cy - height / 2;
        xMax = cx + width / 2;
        yMax = cy + height / 2;
      }
      if (width > height) {
        const ex = (width - height) / 2;
        xMin += ex;
        xMax -= ex;
      } else if (width < height) {
        const ey = (height - width) / 2;
        yMin += ey;
        yMax -= ey;
      }
      if (width !== height || innerScale !== 1) {
        return new math.R2Box(xMin, yMin, xMax, yMax);
      } else {
        return frame;
      }
    }
    copy(outer, inner, innerScale, moodModifier, outerMoodModifier, innerMoodModifier) {
      return new EnclosedIcon(outer, inner, innerScale, moodModifier, outerMoodModifier, innerMoodModifier);
    }
    interpolateTo(that) {
      if (that instanceof EnclosedIcon) {
        return EnclosedIconInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof EnclosedIcon) {
        return util.Equivalent(this.outer, that.outer, epsilon) && util.Equivalent(this.inner, that.inner, epsilon) && util.Equivalent(this.innerScale, that.innerScale, epsilon) && util.Equivalent(this.moodModifier, that.moodModifier, epsilon) && util.Equivalent(this.outerMoodModifier, that.outerMoodModifier, epsilon) && util.Equivalent(this.innerMoodModifier, that.innerMoodModifier, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof EnclosedIcon) {
        return util.Equals(this.outer, that.outer) && util.Equals(this.inner, that.inner) && util.Equals(this.innerScale, that.innerScale) && util.Equals(this.moodModifier, that.moodModifier) && util.Equals(this.outerMoodModifier, that.outerMoodModifier) && util.Equals(this.innerMoodModifier, that.innerMoodModifier);
      }
      return false;
    }
    debug(output) {
      output = output.write("new").write(32).write("EnclosedIcon").write(40).debug(this.outer).write(", ").debug(this.inner).write(", ").debug(this.innerScale).write(", ").debug(this.moodModifier).write(", ").debug(this.outerMoodModifier).write(", ").debug(this.innerMoodModifier).write(41);
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static create(outer, inner) {
      return new EnclosedIcon(outer, inner, 1, null, null, null);
    }
    static embossed(outer, inner) {
      return new EnclosedIcon(outer, inner, 1, null, null, EnclosedIcon.embossedMoodModifier);
    }
    static get embossedMoodModifier() {
      return MoodMatrix.empty().updatedCol(Feel.default, [ [ Feel.embossed, 1 ] ], true);
    }
  }
  __decorate([ util.Lazy ], EnclosedIcon, "embossedMoodModifier", null);
  const EnclosedIconInterpolator = function(_super) {
    const EnclosedIconInterpolator = function(i0, i1) {
      const interpolator = function(u) {
        const outer = interpolator.outerInterpolator(u);
        const inner = interpolator.innerInterpolator(u);
        const innerScale = interpolator.innerScaleInterpolator(u);
        const moodModifier = interpolator.moodModifier;
        const outerMoodModifier = interpolator.outerMoodModifier;
        const innerMoodModifier = interpolator.innerMoodModifier;
        return new EnclosedIcon(outer, inner, innerScale, moodModifier, outerMoodModifier, innerMoodModifier);
      };
      Object.setPrototypeOf(interpolator, EnclosedIconInterpolator.prototype);
      interpolator.outerInterpolator = util.Interpolator(i0.outer, i1.outer);
      interpolator.innerInterpolator = util.Interpolator(i0.inner, i1.inner);
      interpolator.innerScaleInterpolator = util.Interpolator(i0.innerScale, i1.innerScale);
      interpolator.moodModifier = i1.moodModifier;
      interpolator.outerMoodModifier = i1.outerMoodModifier;
      interpolator.innerMoodModifier = i1.innerMoodModifier;
      return interpolator;
    };
    EnclosedIconInterpolator.prototype = Object.create(_super.prototype);
    EnclosedIconInterpolator.prototype.constructor = EnclosedIconInterpolator;
    Object.defineProperty(EnclosedIconInterpolator.prototype, 0, {
      get() {
        const outer = this.outerInterpolator[0];
        const inner = this.innerInterpolator[0];
        const innerScale = this.innerScaleInterpolator[0];
        const moodModifier = this.moodModifier;
        const outerMoodModifier = this.outerMoodModifier;
        const innerMoodModifier = this.innerMoodModifier;
        return new EnclosedIcon(outer, inner, innerScale, moodModifier, outerMoodModifier, innerMoodModifier);
      },
      configurable: true
    });
    Object.defineProperty(EnclosedIconInterpolator.prototype, 1, {
      get() {
        const outer = this.outerInterpolator[1];
        const inner = this.innerInterpolator[1];
        const innerScale = this.innerScaleInterpolator[1];
        const moodModifier = this.moodModifier;
        const outerMoodModifier = this.outerMoodModifier;
        const innerMoodModifier = this.innerMoodModifier;
        return new EnclosedIcon(outer, inner, innerScale, moodModifier, outerMoodModifier, innerMoodModifier);
      },
      configurable: true
    });
    EnclosedIconInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof EnclosedIconInterpolator) {
        return this.outerInterpolator.equals(that.outerInterpolator) && this.innerInterpolator.equals(that.innerInterpolator) && this.innerScaleInterpolator.equals(that.innerScaleInterpolator) && util.Equals(this.moodModifier, that.moodModifier) && util.Equals(this.outerMoodModifier, that.outerMoodModifier) && util.Equals(this.innerMoodModifier, that.innerMoodModifier);
      }
      return false;
    };
    return EnclosedIconInterpolator;
  }(util.Interpolator);
  const IconView = function() {
    const IconView = {};
    IconView.is = function(object) {
      if (typeof object === "object" && object !== null) {
        const view = object;
        return view instanceof GraphicsIconView || view instanceof SvgIconView || view instanceof HtmlIconView || view instanceof View && "xAlign" in view && "yAlign" in view && "iconWidth" in view && "iconHeight" in view && "iconColor" in view && "graphics" in view;
      }
      return false;
    };
    IconView.init = function(view, init) {
      if (init.xAlign !== void 0) {
        view.xAlign(init.xAlign);
      }
      if (init.yAlign !== void 0) {
        view.yAlign(init.yAlign);
      }
      if (init.iconWidth !== void 0) {
        view.iconWidth(init.iconWidth);
      }
      if (init.iconHeight !== void 0) {
        view.iconHeight(init.iconHeight);
      }
      if (init.iconColor !== void 0) {
        view.iconColor(init.iconColor);
      }
      if (init.graphics !== void 0) {
        view.graphics(init.graphics);
      }
    };
    return IconView;
  }();
  const IconGraphicsAnimator = function(_super) {
    const IconGraphicsAnimator = _super.extend("IconGraphicsAnimator");
    IconGraphicsAnimator.prototype.transformState = function(icon) {
      const iconView = this.owner;
      if (IconView.is(iconView) && icon instanceof Icon) {
        const iconColor = iconView.iconColor.state;
        if (iconColor !== null && icon instanceof FilledIcon) {
          icon = icon.withFillColor(iconColor);
        } else {
          const theme = iconView.theme.value;
          const mood = iconView.mood.value;
          if (theme !== null && mood !== null) {
            icon = icon.withTheme(theme, mood);
          }
        }
      }
      return icon;
    };
    return IconGraphicsAnimator;
  }(ThemeAnimator);
  class GraphicsIconView extends GraphicsView {
    onApplyTheme(theme, mood, timing) {
      super.onApplyTheme(theme, mood, timing);
      if (!this.graphics.inherited) {
        const oldGraphics = this.graphics.value;
        if (oldGraphics instanceof Icon) {
          const newGraphics = oldGraphics.withTheme(theme, mood);
          this.graphics.setState(newGraphics, oldGraphics.isThemed() ? timing : false, component.Affinity.Reflexive);
        }
      }
    }
    onRender(viewContext) {
      super.onRender(viewContext);
      const renderer = viewContext.renderer;
      if (renderer instanceof PaintingRenderer && !this.hidden && !this.culled) {
        this.renderIcon(renderer, this.viewBounds);
      }
    }
    renderIcon(renderer, frame) {
      const graphics = this.graphics.value;
      if (graphics !== null) {
        const context = renderer.context;
        context.beginPath();
        graphics.render(renderer, frame);
      }
    }
    hitTest(x, y, viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer) {
        return this.hitTestIcon(x, y, renderer, this.viewBounds);
      }
      return null;
    }
    hitTestIcon(x, y, renderer, frame) {
      if (this.hitBounds.contains(x, y)) {
        return this;
      }
      return null;
    }
    init(init) {
      super.init(init);
      IconView.init(this, init);
    }
  }
  __decorate([ component.Animator({
    type: Number,
    value: .5,
    updateFlags: View.NeedsRender
  }) ], GraphicsIconView.prototype, "xAlign", void 0);
  __decorate([ component.Animator({
    type: Number,
    value: .5,
    updateFlags: View.NeedsRender
  }) ], GraphicsIconView.prototype, "yAlign", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    updateFlags: View.NeedsRender
  }) ], GraphicsIconView.prototype, "iconWidth", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    updateFlags: View.NeedsRender
  }) ], GraphicsIconView.prototype, "iconHeight", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    updateFlags: View.NeedsRender,
    didSetValue(newIconColor, oldIconColor) {
      if (newIconColor !== null) {
        const oldGraphics = this.owner.graphics.value;
        if (oldGraphics instanceof FilledIcon) {
          const newGraphics = oldGraphics.withFillColor(newIconColor);
          this.owner.graphics.setState(newGraphics, component.Affinity.Reflexive);
        }
      }
    }
  }) ], GraphicsIconView.prototype, "iconColor", void 0);
  __decorate([ ThemeAnimator({
    extends: IconGraphicsAnimator,
    type: Object,
    value: null,
    updateFlags: View.NeedsRender
  }) ], GraphicsIconView.prototype, "graphics", void 0);
  Object.defineProperty(GraphicsIconView.prototype, "viewBounds", {
    get() {
      const viewFrame = this.viewFrame;
      const viewWidth = viewFrame.width;
      const viewHeight = viewFrame.height;
      const viewSize = Math.min(viewWidth, viewHeight);
      let iconWidth = this.iconWidth.value;
      iconWidth = iconWidth instanceof math.Length ? iconWidth.pxValue(viewSize) : viewSize;
      let iconHeight = this.iconHeight.value;
      iconHeight = iconHeight instanceof math.Length ? iconHeight.pxValue(viewSize) : viewSize;
      const x = viewFrame.x + (viewWidth - iconWidth) * this.xAlign.getValue();
      const y = viewFrame.y + (viewHeight - iconHeight) * this.yAlign.getValue();
      return new math.R2Box(x, y, x + iconWidth, y + iconHeight);
    },
    configurable: true
  });
  class SvgIconView extends SvgView {
    constructor(node) {
      super(node);
    }
    onApplyTheme(theme, mood, timing) {
      super.onApplyTheme(theme, mood, timing);
      if (!this.graphics.inherited) {
        const oldGraphics = this.graphics.value;
        if (oldGraphics instanceof Icon) {
          const newGraphics = oldGraphics.withTheme(theme, mood);
          this.graphics.setState(newGraphics, oldGraphics.isThemed() ? timing : false, component.Affinity.Reflexive);
        }
      }
    }
    onResize(viewContext) {
      super.onResize(viewContext);
      this.requireUpdate(View.NeedsLayout);
    }
    needsDisplay(displayFlags, viewContext) {
      if ((this.flags & View.NeedsLayout) === 0) {
        displayFlags &= ~View.NeedsLayout;
      }
      return displayFlags;
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.renderIcon();
    }
    renderIcon() {
      const context = new SvgContext(this);
      context.setPrecision(3);
      context.beginSvg();
      const graphics = this.graphics.value;
      if (graphics !== null) {
        const frame = this.iconBounds;
        if (frame.isDefined() && frame.width > 0 && frame.height > 0) {
          context.beginPath();
          const renderer = new SvgRenderer(context);
          graphics.render(renderer, frame);
        }
      }
      context.finalizeSvg();
    }
    get iconBounds() {
      let viewportElement = this.node.viewportElement;
      if (viewportElement === null) {
        viewportElement = this.node;
      }
      if (viewportElement instanceof SVGSVGElement) {
        const viewBox = viewportElement.viewBox.animVal;
        const viewWidth = viewBox.width;
        const viewHeight = viewBox.height;
        const viewSize = Math.min(viewWidth, viewHeight);
        let iconWidth = this.iconWidth.value;
        iconWidth = iconWidth instanceof math.Length ? iconWidth.pxValue(viewSize) : viewSize;
        let iconHeight = this.iconHeight.value;
        iconHeight = iconHeight instanceof math.Length ? iconHeight.pxValue(viewSize) : viewSize;
        const x = viewBox.x + (viewWidth - iconWidth) * this.xAlign.getValue();
        const y = viewBox.y + (viewHeight - iconHeight) * this.yAlign.getValue();
        return new math.R2Box(x, y, x + iconWidth, y + iconHeight);
      } else {
        return math.R2Box.undefined();
      }
    }
    init(init) {
      super.init(init);
      IconView.init(this, init);
    }
  }
  SvgIconView.MountFlags = SvgView.MountFlags | View.NeedsAnimate;
  __decorate([ component.Animator({
    type: Number,
    value: .5,
    updateFlags: View.NeedsLayout
  }) ], SvgIconView.prototype, "xAlign", void 0);
  __decorate([ component.Animator({
    type: Number,
    value: .5,
    updateFlags: View.NeedsLayout
  }) ], SvgIconView.prototype, "yAlign", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], SvgIconView.prototype, "iconWidth", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], SvgIconView.prototype, "iconHeight", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    updateFlags: View.NeedsLayout,
    didSetValue(newIconColor, oldIconColor) {
      if (newIconColor !== null) {
        const oldGraphics = this.owner.graphics.value;
        if (oldGraphics instanceof FilledIcon) {
          const newGraphics = oldGraphics.withFillColor(newIconColor);
          this.owner.graphics.setState(newGraphics, component.Affinity.Reflexive);
        }
      }
    }
  }) ], SvgIconView.prototype, "iconColor", void 0);
  __decorate([ ThemeAnimator({
    extends: IconGraphicsAnimator,
    type: Object,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], SvgIconView.prototype, "graphics", void 0);
  class HtmlIconView extends HtmlView {
    constructor(node) {
      super(node);
      this.initIcon();
    }
    initIcon() {
      this.position.setState("relative", component.Affinity.Intrinsic);
      const svgView = this.createSvgView();
      if (svgView !== null) {
        this.setChild("svg", svgView);
      }
    }
    createSvgView() {
      return SvgIconView.create();
    }
    get svgView() {
      const svgView = this.getChild("svg");
      return svgView instanceof SvgIconView ? svgView : null;
    }
    onInsertChild(child, target) {
      super.onInsertChild(child, target);
      if (child.key === "svg" && child instanceof SvgIconView) {
        this.onInsertSvg(child);
      }
    }
    onInsertSvg(svgView) {
      svgView.xAlign.setInherits(true);
      svgView.yAlign.setInherits(true);
      svgView.iconWidth.setInherits(true);
      svgView.iconHeight.setInherits(true);
      svgView.iconColor.setInherits(true);
      svgView.graphics.setInherits(true);
      svgView.setStyle("position", "absolute");
    }
    onApplyTheme(theme, mood, timing) {
      super.onApplyTheme(theme, mood, timing);
      if (!this.graphics.inherited) {
        const oldGraphics = this.graphics.value;
        if (oldGraphics instanceof Icon) {
          const newGraphics = oldGraphics.withTheme(theme, mood);
          this.graphics.setState(newGraphics, oldGraphics.isThemed() ? timing : false, component.Affinity.Reflexive);
        }
      }
    }
    onResize(viewContext) {
      super.onResize(viewContext);
      this.requireUpdate(View.NeedsLayout);
    }
    needsDisplay(displayFlags, viewContext) {
      if ((this.flags & View.NeedsLayout) === 0) {
        displayFlags &= ~View.NeedsLayout;
      }
      return displayFlags;
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.layoutIcon();
    }
    layoutIcon() {
      const svgView = this.svgView;
      if (svgView !== null && (svgView.width.hasAffinity(component.Affinity.Intrinsic) || svgView.height.hasAffinity(component.Affinity.Intrinsic) || svgView.viewBox.hasAffinity(component.Affinity.Intrinsic))) {
        let viewWidth = this.width.value;
        viewWidth = viewWidth instanceof math.Length ? viewWidth.pxValue() : this.node.offsetWidth;
        let viewHeight = this.height.value;
        viewHeight = viewHeight instanceof math.Length ? viewHeight.pxValue() : this.node.offsetHeight;
        svgView.width.setState(viewWidth, component.Affinity.Intrinsic);
        svgView.height.setState(viewHeight, component.Affinity.Intrinsic);
        svgView.viewBox.setState("0 0 " + viewWidth + " " + viewHeight, component.Affinity.Intrinsic);
      }
    }
    init(init) {
      super.init(init);
      IconView.init(this, init);
    }
  }
  __decorate([ component.Animator({
    type: Number,
    value: .5,
    updateFlags: View.NeedsLayout
  }) ], HtmlIconView.prototype, "xAlign", void 0);
  __decorate([ component.Animator({
    type: Number,
    value: .5,
    updateFlags: View.NeedsLayout
  }) ], HtmlIconView.prototype, "yAlign", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], HtmlIconView.prototype, "iconWidth", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], HtmlIconView.prototype, "iconHeight", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    updateFlags: View.NeedsLayout,
    didSetValue(newIconColor, oldIconColor) {
      if (newIconColor !== null) {
        const oldGraphics = this.owner.graphics.value;
        if (oldGraphics instanceof FilledIcon) {
          const newGraphics = oldGraphics.withFillColor(newIconColor);
          this.owner.graphics.setState(newGraphics, component.Affinity.Reflexive);
        }
      }
    }
  }) ], HtmlIconView.prototype, "iconColor", void 0);
  __decorate([ ThemeAnimator({
    extends: IconGraphicsAnimator,
    type: Object,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], HtmlIconView.prototype, "graphics", void 0);
  const ControllerContext = function() {
    const ControllerContext = {};
    ControllerContext.current = null;
    ControllerContext.create = function() {
      return {
        updateTime: performance.now()
      };
    };
    return ControllerContext;
  }();
  class ExecuteService extends component.Service {
    constructor() {
      super();
      this.flags = 0;
      this.controllerContext = ControllerContext.create();
      this.updateDelay = ExecuteService.MinUpdateDelay;
      this.compileTimer = 0;
      this.executeTimer = 0;
      this.runCompilePass = this.runCompilePass.bind(this);
      this.runExecutePass = this.runExecutePass.bind(this);
      this.onVisibilityChange = this.onVisibilityChange.bind(this);
    }
    setFlags(flags) {
      this.flags = flags;
    }
    updatedControllerContext() {
      const controllerContext = this.controllerContext;
      controllerContext.updateTime = performance.now();
      return controllerContext;
    }
    needsUpdate(updateFlags, immediate) {
      return updateFlags;
    }
    requestUpdate(targetController, updateFlags, immediate) {
      updateFlags = this.needsUpdate(updateFlags, immediate);
      let deltaUpdateFlags = this.flags & ~updateFlags & Controller.UpdateMask;
      if ((updateFlags & Controller.CompileMask) !== 0) {
        deltaUpdateFlags |= Controller.NeedsCompile;
      }
      if ((updateFlags & Controller.ExecuteMask) !== 0) {
        deltaUpdateFlags |= Controller.NeedsExecute;
      }
      this.setFlags(this.flags | deltaUpdateFlags);
      if (immediate && (this.flags & (Controller.CompilingFlag | Controller.ExecutingFlag)) === 0 && this.updateDelay <= ExecuteService.MaxCompileInterval) {
        this.runImmediatePass();
      } else {
        this.scheduleUpdate();
      }
    }
    scheduleUpdate() {
      const flags = this.flags;
      if ((flags & Controller.CompilingFlag) === 0 && (flags & Controller.CompileMask) !== 0) {
        this.scheduleCompilePass(this.updateDelay);
      } else if ((flags & Controller.ExecutingFlag) === 0 && (flags & Controller.ExecuteMask) !== 0) {
        this.scheduleExecutePass(ExecuteService.MinExecuteInterval);
      }
    }
    cancelUpdate() {
      this.cancelCompilePass();
      this.cancelExecutePass();
    }
    runImmediatePass() {
      if ((this.flags & Controller.CompileMask) !== 0) {
        this.cancelUpdate();
        this.runCompilePass(true);
      }
      if ((this.flags & Controller.ExecuteMask) !== 0 && this.updateDelay <= ExecuteService.MaxCompileInterval) {
        this.cancelUpdate();
        this.runExecutePass(true);
      }
    }
    scheduleCompilePass(updateDelay) {
      if (this.compileTimer === 0) {
        this.compileTimer = setTimeout(this.runCompilePass, updateDelay);
      }
    }
    cancelCompilePass() {
      if (this.compileTimer !== 0) {
        clearTimeout(this.compileTimer);
        this.compileTimer = 0;
      }
    }
    runCompilePass(immediate = false) {
      this.setFlags(this.flags & ~Controller.CompileMask | Controller.CompilingFlag);
      try {
        const t0 = performance.now();
        const roots = this.roots;
        const controllerContext = this.controllerContext;
        controllerContext.updateTime = t0;
        for (let i = 0; i < roots.length; i += 1) {
          const root = roots[i];
          if ((root.flags & Controller.CompileMask) !== 0) {
            root.cascadeCompile(0, controllerContext);
          }
        }
        const t1 = performance.now();
        let compileDelay = Math.max(ExecuteService.MinCompileInterval, this.updateDelay);
        if (t1 - t0 > compileDelay) {
          this.updateDelay = Math.min(Math.max(2, this.updateDelay * 2), ExecuteService.MaxUpdateDelay);
        } else {
          this.updateDelay = Math.min(ExecuteService.MinUpdateDelay, this.updateDelay / 2);
        }
        this.cancelCompilePass();
        if ((this.flags & Controller.ExecuteMask) !== 0) {
          this.scheduleExecutePass(ExecuteService.MinExecuteInterval);
        } else if ((this.flags & Controller.CompileMask) !== 0) {
          if (immediate) {
            compileDelay = Math.max(ExecuteService.MaxCompileInterval, compileDelay);
          }
          this.cancelExecutePass();
          this.scheduleCompilePass(compileDelay);
        }
      } finally {
        this.setFlags(this.flags & ~Controller.CompilingFlag);
      }
    }
    scheduleExecutePass(updateDelay) {
      if (this.executeTimer === 0) {
        this.executeTimer = setTimeout(this.runExecutePass, updateDelay);
      }
    }
    cancelExecutePass() {
      if (this.executeTimer !== 0) {
        clearTimeout(this.executeTimer);
        this.executeTimer = 0;
      }
    }
    runExecutePass(immediate = false) {
      this.setFlags(this.flags & ~Controller.ExecuteMask | Controller.ExecutingFlag);
      try {
        const time = performance.now();
        const controllerContext = this.controllerContext;
        controllerContext.updateTime = time;
        const roots = this.roots;
        for (let i = 0; i < roots.length; i += 1) {
          const root = roots[i];
          if ((root.flags & Controller.ExecuteMask) !== 0) {
            root.cascadeExecute(0, controllerContext);
          }
        }
        this.cancelExecutePass();
        if ((this.flags & Controller.CompileMask) !== 0) {
          let compileDelay = this.updateDelay;
          if (immediate) {
            compileDelay = Math.max(ExecuteService.MaxCompileInterval, compileDelay);
          }
          this.scheduleCompilePass(compileDelay);
        } else if ((this.flags & Controller.ExecuteMask) !== 0) {
          this.cancelCompilePass();
          this.scheduleExecutePass(ExecuteService.MaxExecuteInterval);
        }
      } finally {
        this.setFlags(this.flags & ~Controller.ExecutingFlag);
      }
    }
    get powerFlags() {
      return 0;
    }
    power() {
      const roots = this.roots;
      for (let i = 0, n = roots.length; i < n; i += 1) {
        const root = roots[i];
        root.requireUpdate(this.powerFlags);
      }
    }
    unpower() {
      this.cancelUpdate();
      this.updateDelay = ExecuteService.MinUpdateDelay;
    }
    onAttachRoot(root) {
      super.onAttachRoot(root);
      this.requestUpdate(root, root.flags & Controller.UpdateMask, false);
    }
    onAttach() {
      super.onAttach();
      this.attachEvents();
    }
    onDetach() {
      this.detachEvents();
      super.onDetach();
    }
    attachEvents() {
      if (typeof document !== "undefined") {
        document.addEventListener("visibilitychange", this.onVisibilityChange);
      }
    }
    detachEvents() {
      if (typeof document !== "undefined") {
        document.removeEventListener("visibilitychange", this.onVisibilityChange);
      }
    }
    onVisibilityChange() {
      if (document.visibilityState === "visible") {
        this.power();
      } else {
        this.unpower();
      }
    }
    static global() {
      return new ExecuteService;
    }
  }
  ExecuteService.MinUpdateDelay = 0;
  ExecuteService.MaxUpdateDelay = 167;
  ExecuteService.MinCompileInterval = 12;
  ExecuteService.MaxCompileInterval = 33;
  ExecuteService.MinExecuteInterval = 4;
  ExecuteService.MaxExecuteInterval = 16;
  __decorate([ util.Lazy ], ExecuteService, "global", null);
  const ExecuteProvider = function(_super) {
    const ExecuteProvider = _super.extend("ExecuteProvider");
    Object.defineProperty(ExecuteProvider.prototype, "controllerContext", {
      get() {
        let service = this.service;
        if (service === void 0 || service === null) {
          service = ExecuteService.global();
        }
        return service.controllerContext;
      },
      configurable: true
    });
    ExecuteProvider.prototype.updatedControllerContext = function() {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = ExecuteService.global();
      }
      return service.updatedControllerContext();
    };
    ExecuteProvider.prototype.requestUpdate = function(target, updateFlags, immediate) {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = ExecuteService.global();
      }
      service.requestUpdate(target, updateFlags, immediate);
    };
    ExecuteProvider.prototype.createService = function() {
      return ExecuteService.global();
    };
    return ExecuteProvider;
  }(component.Provider);
  const HistoryState = function() {
    const HistoryState = {};
    HistoryState.empty = function() {
      return {
        fragment: void 0,
        permanent: {},
        ephemeral: {}
      };
    };
    HistoryState.current = function() {
      try {
        return HistoryState.fromUri(window.location.href);
      } catch (e) {
        console.error(e);
        return {
          fragment: void 0,
          permanent: {},
          ephemeral: {}
        };
      }
    };
    HistoryState.updated = function(delta, state) {
      if (state === void 0) {
        state = HistoryState.current();
      }
      if ("fragment" in delta) {
        state.fragment = delta.fragment;
      }
      for (const key in delta.permanent) {
        const value = delta.permanent[key];
        if (value !== void 0) {
          state.permanent[key] = value;
        } else {
          delete state.permanent[key];
        }
      }
      for (const key in delta.ephemeral) {
        const value = delta.ephemeral[key];
        if (value !== void 0) {
          state.ephemeral[key] = value;
        } else {
          delete state.ephemeral[key];
        }
      }
      return state;
    };
    HistoryState.cloned = function(oldState) {
      const newState = {
        fragment: oldState.fragment,
        permanent: {},
        ephemeral: {}
      };
      for (const key in oldState.permanent) {
        newState.permanent[key] = oldState.permanent[key];
      }
      for (const key in oldState.ephemeral) {
        newState.ephemeral[key] = oldState.ephemeral[key];
      }
      return newState;
    };
    HistoryState.fromUri = function(uri$1) {
      uri$1 = uri.Uri.fromAny(uri$1);
      const fragment = uri$1.fragment;
      if (fragment.isDefined()) {
        return HistoryState.fromUriFragment(fragment);
      } else {
        return HistoryState.empty();
      }
    };
    HistoryState.fromUriFragment = function(fragment) {
      fragment = uri.UriFragment.fromAny(fragment);
      let query = fragment.identifier !== void 0 ? uri.UriQuery.parse(fragment.identifier) : uri.UriQuery.undefined();
      const state = {
        fragment: void 0,
        permanent: {},
        ephemeral: {}
      };
      while (!query.isEmpty()) {
        const key = query.key;
        const value = query.value;
        if (key !== void 0) {
          state.permanent[key] = value;
        } else {
          state.fragment = value;
        }
        query = query.tail();
      }
      return state;
    };
    HistoryState.toUri = function(state) {
      const queryBuilder = uri.UriQuery.builder();
      if (state.fragment !== void 0) {
        queryBuilder.add(void 0, state.fragment);
      }
      for (const key in state.permanent) {
        const value = state.permanent[key];
        queryBuilder.add(key, value);
      }
      return uri.Uri.fragment(uri.UriFragment.create(queryBuilder.bind().toString()));
    };
    return HistoryState;
  }();
  class HistoryService extends component.Service {
    constructor() {
      super();
      this.historyState = HistoryState.current();
      this.popHistory = this.popHistory.bind(this);
    }
    get historyUri() {
      return HistoryState.toUri(this.historyState);
    }
    pushHistory(deltaState) {
      const oldState = this.historyState;
      const newState = HistoryState.updated(deltaState, HistoryState.cloned(oldState));
      const newUri = HistoryState.toUri(newState);
      this.willPushHistory(newState, oldState);
      this.historyState = newState;
      window.history.pushState(newState.ephemeral, "", newUri.toString());
      this.onPushHistory(newState, oldState);
      this.didPushHistory(newState, oldState);
    }
    willPushHistory(newState, oldState) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceWillPushHistory !== void 0) {
          observer.serviceWillPushHistory(newState, oldState, this);
        }
      }
    }
    onPushHistory(newState, oldState) {
      const roots = this.roots;
      for (let i = 0, n = roots.length; i < n; i += 1) {
        roots[i].requireUpdate(Controller.NeedsRevise);
      }
    }
    didPushHistory(newState, oldState) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceDidPushHistory !== void 0) {
          observer.serviceDidPushHistory(newState, oldState, this);
        }
      }
    }
    replaceHistory(deltaState) {
      const oldState = this.historyState;
      const newState = HistoryState.updated(deltaState, HistoryState.cloned(oldState));
      if (!util.Objects.equal(oldState, newState)) {
        const newUri = HistoryState.toUri(newState);
        this.willReplaceHistory(newState, oldState);
        this.historyState = newState;
        window.history.replaceState(newState.ephemeral, "", newUri.toString());
        this.onReplaceHistory(newState, oldState);
        this.didReplaceHistory(newState, oldState);
      }
    }
    willReplaceHistory(newState, oldState) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceWillReplaceHistory !== void 0) {
          observer.serviceWillReplaceHistory(newState, oldState, this);
        }
      }
    }
    onReplaceHistory(newState, oldState) {
      const roots = this.roots;
      for (let i = 0, n = roots.length; i < n; i += 1) {
        roots[i].requireUpdate(Controller.NeedsRevise);
      }
    }
    didReplaceHistory(newState, oldState) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceDidReplaceHistory !== void 0) {
          observer.serviceDidReplaceHistory(newState, oldState, this);
        }
      }
    }
    popHistory(event) {
      const deltaState = {};
      if (typeof event.state === "object" && event.state !== null) {
        deltaState.ephemeral = event.state;
      }
      const oldState = HistoryState.current();
      const newState = HistoryState.updated(deltaState, oldState);
      this.willPopHistory(newState, oldState);
      this.historyState = newState;
      this.onPopHistory(newState, oldState);
      this.didPopHistory(newState, oldState);
    }
    willPopHistory(newState, oldState) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceWillPopHistory !== void 0) {
          observer.serviceWillPopHistory(newState, oldState, this);
        }
      }
    }
    onPopHistory(newState, oldState) {
      const roots = this.roots;
      for (let i = 0, n = roots.length; i < n; i += 1) {
        roots[i].requireUpdate(Controller.NeedsRevise);
      }
    }
    didPopHistory(newState, oldState) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceDidPopHistory !== void 0) {
          observer.serviceDidPopHistory(newState, oldState, this);
        }
      }
    }
    onAttach() {
      super.onAttach();
      this.attachEvents();
    }
    onDetach() {
      this.detachEvents();
      super.onDetach();
    }
    attachEvents() {
      if (typeof window !== "undefined") {
        window.addEventListener("popstate", this.popHistory);
      }
    }
    detachEvents() {
      if (typeof window !== "undefined") {
        window.removeEventListener("popstate", this.popHistory);
      }
    }
    static global() {
      return new HistoryService;
    }
  }
  __decorate([ util.Lazy ], HistoryService, "global", null);
  const HistoryProvider = function(_super) {
    const HistoryProvider = _super.extend("HistoryProvider");
    Object.defineProperty(HistoryProvider.prototype, "historyState", {
      get() {
        let service = this.service;
        if (service === void 0 || service === null) {
          service = HistoryService.global();
        }
        return service.historyState;
      },
      configurable: true
    });
    HistoryProvider.prototype.pushHistory = function(deltaState) {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = HistoryService.global();
      }
      service.pushHistory(deltaState);
    };
    HistoryProvider.prototype.replaceHistory = function(deltaState) {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = HistoryService.global();
      }
      service.replaceHistory(deltaState);
    };
    HistoryProvider.prototype.createService = function() {
      return HistoryService.global();
    };
    return HistoryProvider;
  }(component.Provider);
  class StorageService extends component.Service {
    willSet(key, newValue, oldValue) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceWillStore !== void 0) {
          observer.serviceWillStore(key, newValue, oldValue, this);
        }
      }
    }
    onSet(key, newValue, oldValue) {
      const roots = this.roots;
      for (let i = 0, n = roots.length; i < n; i += 1) {
        roots[i].requireUpdate(Controller.NeedsRevise);
      }
    }
    didSet(key, newValue, oldValue) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceDidStore !== void 0) {
          observer.serviceDidStore(key, newValue, oldValue, this);
        }
      }
    }
    willClear() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceWillClear !== void 0) {
          observer.serviceWillClear(this);
        }
      }
    }
    onClear() {
      const roots = this.roots;
      for (let i = 0, n = roots.length; i < n; i += 1) {
        roots[i].requireUpdate(Controller.NeedsRevise);
      }
    }
    didClear() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceDidClear !== void 0) {
          observer.serviceDidClear(this);
        }
      }
    }
    static global() {
      let service = WebStorageService.local();
      if (service === null) {
        service = new EphemeralStorageService;
      }
      return service;
    }
  }
  __decorate([ util.Lazy ], StorageService, "global", null);
  class WebStorageService extends StorageService {
    constructor(storage) {
      super();
      this.storage = storage;
      this.onStorage = this.onStorage.bind(this);
    }
    get(key) {
      const value = this.storage.getItem(key);
      return value !== null ? value : void 0;
    }
    set(key, newValue) {
      let oldValue = this.storage.getItem(key);
      if (oldValue === null) {
        oldValue = void 0;
      }
      if (newValue !== oldValue) {
        this.willSet(key, newValue, oldValue);
        if (newValue !== void 0) {
          this.storage.setItem(key, newValue);
        } else {
          this.storage.removeItem(key);
        }
        this.onSet(key, newValue, oldValue);
        this.didSet(key, newValue, oldValue);
      }
      return oldValue;
    }
    clear() {
      this.willClear();
      this.storage.clear();
      this.onClear();
      this.didClear();
    }
    onStorage(event) {
      if (event.storageArea === this.storage) {
        const key = event.key;
        if (key !== null) {
          let newValue = event.newValue;
          if (newValue === null) {
            newValue = void 0;
          }
          let oldValue = event.oldValue;
          if (oldValue === null) {
            oldValue = void 0;
          }
          if (newValue !== oldValue) {
            this.willSet(key, newValue, oldValue);
            this.onSet(key, newValue, oldValue);
            this.didSet(key, newValue, oldValue);
          }
        } else {
          this.willClear();
          this.onClear();
          this.didClear();
        }
      }
    }
    onAttach() {
      super.onAttach();
      this.attachEvents();
    }
    onDetach() {
      this.detachEvents();
      super.onDetach();
    }
    attachEvents() {
      if (typeof window !== "undefined") {
        window.addEventListener("storage", this.onStorage);
      }
    }
    detachEvents() {
      if (typeof window !== "undefined") {
        window.removeEventListener("storage", this.onStorage);
      }
    }
    static local() {
      try {
        return new WebStorageService(window.localStorage);
      } catch (e) {
        return null;
      }
    }
    static session() {
      try {
        return new WebStorageService(window.sessionStorage);
      } catch (e) {
        return null;
      }
    }
  }
  __decorate([ util.Lazy ], WebStorageService, "local", null);
  __decorate([ util.Lazy ], WebStorageService, "session", null);
  class EphemeralStorageService extends StorageService {
    constructor(storage) {
      super();
      if (storage === void 0) {
        storage = {};
      }
      this.storage = storage;
    }
    get(key) {
      return this.storage[key];
    }
    set(key, newValue) {
      const storage = this.storage;
      const oldValue = storage[key];
      if (newValue !== oldValue) {
        this.willSet(key, newValue, oldValue);
        if (newValue !== void 0) {
          storage[key] = newValue;
        } else {
          delete storage[key];
        }
        this.onSet(key, newValue, oldValue);
        this.didSet(key, newValue, oldValue);
      }
      return oldValue;
    }
    clear() {
      this.willClear();
      this.storage = {};
      this.onClear();
      this.didClear();
    }
  }
  const StorageProvider = function(_super) {
    const StorageProvider = _super.extend("StorageProvider");
    StorageProvider.prototype.get = function(key) {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = StorageService.global();
      }
      return service.get(key);
    };
    StorageProvider.prototype.set = function(key, newValue) {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = StorageService.global();
      }
      return service.set(key, newValue);
    };
    StorageProvider.prototype.clear = function() {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = StorageService.global();
      }
      service.clear();
    };
    StorageProvider.prototype.createService = function() {
      return StorageService.global();
    };
    return StorageProvider;
  }(component.Provider);
  class Controller extends component.Component {
    get componentType() {
      return Controller;
    }
    willAttachParent(parent) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerWillAttachParent !== void 0) {
          observer.controllerWillAttachParent(parent, this);
        }
      }
    }
    onAttachParent(parent) {}
    didAttachParent(parent) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerDidAttachParent !== void 0) {
          observer.controllerDidAttachParent(parent, this);
        }
      }
    }
    willDetachParent(parent) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerWillDetachParent !== void 0) {
          observer.controllerWillDetachParent(parent, this);
        }
      }
    }
    onDetachParent(parent) {}
    didDetachParent(parent) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerDidDetachParent !== void 0) {
          observer.controllerDidDetachParent(parent, this);
        }
      }
    }
    setChild(key, newChild) {
      if (newChild !== null) {
        newChild = Controller.fromAny(newChild);
      }
      return super.setChild(key, newChild);
    }
    appendChild(child, key) {
      child = Controller.fromAny(child);
      return super.appendChild(child, key);
    }
    prependChild(child, key) {
      child = Controller.fromAny(child);
      return super.prependChild(child, key);
    }
    insertChild(child, target, key) {
      child = Controller.fromAny(child);
      return super.insertChild(child, target, key);
    }
    replaceChild(newChild, oldChild) {
      newChild = Controller.fromAny(newChild);
      return super.replaceChild(newChild, oldChild);
    }
    willInsertChild(child, target) {
      super.willInsertChild(child, target);
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerWillInsertChild !== void 0) {
          observer.controllerWillInsertChild(child, target, this);
        }
      }
    }
    onInsertChild(child, target) {
      super.onInsertChild(child, target);
    }
    didInsertChild(child, target) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerDidInsertChild !== void 0) {
          observer.controllerDidInsertChild(child, target, this);
        }
      }
      super.didInsertChild(child, target);
    }
    cascadeInsert(updateFlags, controllerContext) {
      if ((this.flags & Controller.MountedFlag) !== 0) {
        if (updateFlags === void 0) {
          updateFlags = 0;
        }
        updateFlags |= this.flags & Controller.UpdateMask;
        if ((updateFlags & Controller.CompileMask) !== 0) {
          if (controllerContext === void 0) {
            controllerContext = this.superControllerContext;
          }
          this.cascadeCompile(updateFlags, controllerContext);
        }
      }
    }
    willRemoveChild(child) {
      super.willRemoveChild(child);
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerWillRemoveChild !== void 0) {
          observer.controllerWillRemoveChild(child, this);
        }
      }
    }
    onRemoveChild(child) {
      super.onRemoveChild(child);
    }
    didRemoveChild(child) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerDidRemoveChild !== void 0) {
          observer.controllerDidRemoveChild(child, this);
        }
      }
      super.didRemoveChild(child);
    }
    willMount() {
      super.willMount();
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerWillMount !== void 0) {
          observer.controllerWillMount(this);
        }
      }
    }
    onMount() {
      this.requestUpdate(this, this.flags & Controller.UpdateMask, false);
      this.requireUpdate(this.mountFlags);
      if (this.decoherent !== null && this.decoherent.length !== 0) {
        this.requireUpdate(Controller.NeedsRevise);
      }
      this.mountFasteners();
    }
    didMount() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerDidMount !== void 0) {
          observer.controllerDidMount(this);
        }
      }
      super.didMount();
    }
    willUnmount() {
      super.willUnmount();
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerWillUnmount !== void 0) {
          observer.controllerWillUnmount(this);
        }
      }
    }
    didUnmount() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerDidUnmount !== void 0) {
          observer.controllerDidUnmount(this);
        }
      }
      super.didUnmount();
    }
    requireUpdate(updateFlags, immediate = false) {
      const flags = this.flags;
      const deltaUpdateFlags = updateFlags & ~flags & Controller.UpdateMask;
      if (deltaUpdateFlags !== 0) {
        this.setFlags(flags | deltaUpdateFlags);
        this.requestUpdate(this, deltaUpdateFlags, immediate);
      }
    }
    needsUpdate(updateFlags, immediate) {
      return updateFlags;
    }
    requestUpdate(target, updateFlags, immediate) {
      updateFlags = this.needsUpdate(updateFlags, immediate);
      let deltaUpdateFlags = this.flags & ~updateFlags & Controller.UpdateMask;
      if ((updateFlags & Controller.CompileMask) !== 0) {
        deltaUpdateFlags |= Controller.NeedsCompile;
      }
      if ((updateFlags & Controller.ExecuteMask) !== 0) {
        deltaUpdateFlags |= Controller.NeedsExecute;
      }
      if (deltaUpdateFlags !== 0 || immediate) {
        this.setFlags(this.flags | deltaUpdateFlags);
        const parent = this.parent;
        if (parent !== null) {
          parent.requestUpdate(target, updateFlags, immediate);
        } else if (this.mounted) {
          const executeService = this.executeProvider.service;
          if (executeService !== void 0 && executeService !== null) {
            executeService.requestUpdate(target, updateFlags, immediate);
          }
        }
      }
    }
    get updating() {
      return (this.flags & Controller.UpdatingMask) !== 0;
    }
    get compiling() {
      return (this.flags & Controller.CompilingFlag) !== 0;
    }
    needsCompile(compileFlags, controllerContext) {
      return compileFlags;
    }
    cascadeCompile(compileFlags, baseControllerContext) {
      const controllerContext = this.extendControllerContext(baseControllerContext);
      const outerControllerContext = ControllerContext.current;
      try {
        ControllerContext.current = controllerContext;
        compileFlags &= ~Controller.NeedsCompile;
        compileFlags |= this.flags & Controller.UpdateMask;
        compileFlags = this.needsCompile(compileFlags, controllerContext);
        if ((compileFlags & Controller.CompileMask) !== 0) {
          let cascadeFlags = compileFlags;
          this.setFlags(this.flags & ~Controller.NeedsCompile | (Controller.CompilingFlag | Controller.ContextualFlag));
          this.willCompile(cascadeFlags, controllerContext);
          if (((this.flags | compileFlags) & Controller.NeedsResolve) !== 0) {
            cascadeFlags |= Controller.NeedsResolve;
            this.setFlags(this.flags & ~Controller.NeedsResolve);
            this.willResolve(controllerContext);
          }
          if (((this.flags | compileFlags) & Controller.NeedsGenerate) !== 0) {
            cascadeFlags |= Controller.NeedsGenerate;
            this.setFlags(this.flags & ~Controller.NeedsGenerate);
            this.willGenerate(controllerContext);
          }
          if (((this.flags | compileFlags) & Controller.NeedsAssemble) !== 0) {
            cascadeFlags |= Controller.NeedsAssemble;
            this.setFlags(this.flags & ~Controller.NeedsAssemble);
            this.willAssemble(controllerContext);
          }
          this.onCompile(cascadeFlags, controllerContext);
          if ((cascadeFlags & Controller.NeedsResolve) !== 0) {
            this.onResolve(controllerContext);
          }
          if ((cascadeFlags & Controller.NeedsGenerate) !== 0) {
            this.onGenerate(controllerContext);
          }
          if ((cascadeFlags & Controller.NeedsAssemble) !== 0) {
            this.onAssemble(controllerContext);
          }
          if ((cascadeFlags & Controller.CompileMask) !== 0) {
            this.setFlags(this.flags & ~Controller.ContextualFlag);
            this.compileChildren(cascadeFlags, controllerContext, this.compileChild);
            this.setFlags(this.flags | Controller.ContextualFlag);
          }
          if ((cascadeFlags & Controller.NeedsAssemble) !== 0) {
            this.didAssemble(controllerContext);
          }
          if ((cascadeFlags & Controller.NeedsGenerate) !== 0) {
            this.didGenerate(controllerContext);
          }
          if ((cascadeFlags & Controller.NeedsResolve) !== 0) {
            this.didResolve(controllerContext);
          }
          this.didCompile(cascadeFlags, controllerContext);
        }
      } finally {
        this.setFlags(this.flags & ~(Controller.CompilingFlag | Controller.ContextualFlag));
        ControllerContext.current = outerControllerContext;
      }
    }
    willCompile(compileFlags, controllerContext) {}
    onCompile(compileFlags, controllerContext) {}
    didCompile(compileFlags, controllerContext) {}
    willResolve(controllerContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerWillResolve !== void 0) {
          observer.controllerWillResolve(controllerContext, this);
        }
      }
    }
    onResolve(controllerContext) {}
    didResolve(controllerContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerDidResolve !== void 0) {
          observer.controllerDidResolve(controllerContext, this);
        }
      }
    }
    willGenerate(controllerContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerWillGenerate !== void 0) {
          observer.controllerWillGenerate(controllerContext, this);
        }
      }
    }
    onGenerate(controllerContext) {}
    didGenerate(controllerContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerDidGenerate !== void 0) {
          observer.controllerDidGenerate(controllerContext, this);
        }
      }
    }
    willAssemble(controllerContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerWillAssemble !== void 0) {
          observer.controllerWillAssemble(controllerContext, this);
        }
      }
    }
    onAssemble(controllerContext) {}
    didAssemble(controllerContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerDidAssemble !== void 0) {
          observer.controllerDidAssemble(controllerContext, this);
        }
      }
    }
    compileChildren(compileFlags, controllerContext, compileChild) {
      let child = this.firstChild;
      while (child !== null) {
        const next = child.nextSibling;
        compileChild.call(this, child, compileFlags, controllerContext);
        if (next !== null && next.parent !== this) {
          throw new Error("inconsistent compile pass");
        }
        child = next;
      }
    }
    compileChild(child, compileFlags, controllerContext) {
      child.cascadeCompile(compileFlags, controllerContext);
    }
    get executing() {
      return (this.flags & Controller.ExecutingFlag) !== 0;
    }
    needsExecute(executeFlags, controllerContext) {
      return executeFlags;
    }
    cascadeExecute(executeFlags, baseControllerContext) {
      const controllerContext = this.extendControllerContext(baseControllerContext);
      const outerControllerContext = ControllerContext.current;
      try {
        ControllerContext.current = controllerContext;
        executeFlags &= ~Controller.NeedsExecute;
        executeFlags |= this.flags & Controller.UpdateMask;
        executeFlags = this.needsExecute(executeFlags, controllerContext);
        if ((executeFlags & Controller.ExecuteMask) !== 0) {
          let cascadeFlags = executeFlags;
          this.setFlags(this.flags & ~Controller.NeedsExecute | (Controller.ExecutingFlag | Controller.ContextualFlag));
          this.willExecute(cascadeFlags, controllerContext);
          if (((this.flags | executeFlags) & Controller.NeedsRevise) !== 0) {
            cascadeFlags |= Controller.NeedsRevise;
            this.setFlags(this.flags & ~Controller.NeedsRevise);
            this.willRevise(controllerContext);
          }
          if (((this.flags | executeFlags) & Controller.NeedsCompute) !== 0) {
            cascadeFlags |= Controller.NeedsCompute;
            this.setFlags(this.flags & ~Controller.NeedsCompute);
            this.willCompute(controllerContext);
          }
          this.onExecute(cascadeFlags, controllerContext);
          if ((cascadeFlags & Controller.NeedsRevise) !== 0) {
            this.onRevise(controllerContext);
          }
          if ((cascadeFlags & Controller.NeedsCompute) !== 0) {
            this.onCompute(controllerContext);
          }
          if ((cascadeFlags & Controller.ExecuteMask) !== 0) {
            this.setFlags(this.flags & ~Controller.ContextualFlag);
            this.executeChildren(cascadeFlags, controllerContext, this.executeChild);
            this.setFlags(this.flags | Controller.ContextualFlag);
          }
          if ((cascadeFlags & Controller.NeedsCompute) !== 0) {
            this.didCompute(controllerContext);
          }
          if ((cascadeFlags & Controller.NeedsRevise) !== 0) {
            this.didRevise(controllerContext);
          }
          this.didExecute(cascadeFlags, controllerContext);
        }
      } finally {
        this.setFlags(this.flags & ~(Controller.ExecutingFlag | Controller.ContextualFlag));
        ControllerContext.current = outerControllerContext;
      }
    }
    willExecute(executeFlags, controllerContext) {}
    onExecute(executeFlags, controllerContext) {}
    didExecute(executeFlags, controllerContext) {}
    willRevise(controllerContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerWillRevise !== void 0) {
          observer.controllerWillRevise(controllerContext, this);
        }
      }
    }
    onRevise(controllerContext) {
      this.recohereFasteners(controllerContext.updateTime);
    }
    didRevise(controllerContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerDidRevise !== void 0) {
          observer.controllerDidRevise(controllerContext, this);
        }
      }
    }
    willCompute(controllerContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerWillCompute !== void 0) {
          observer.controllerWillCompute(controllerContext, this);
        }
      }
    }
    onCompute(controllerContext) {}
    didCompute(controllerContext) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerDidCompute !== void 0) {
          observer.controllerDidCompute(controllerContext, this);
        }
      }
    }
    executeChildren(executeFlags, controllerContext, executeChild) {
      let child = this.firstChild;
      while (child !== null) {
        const next = child.nextSibling;
        executeChild.call(this, child, executeFlags, controllerContext);
        if (next !== null && next.parent !== this) {
          throw new Error("inconsistent execute pass");
        }
        child = next;
      }
    }
    executeChild(child, executeFlags, controllerContext) {
      child.cascadeExecute(executeFlags, controllerContext);
    }
    bindChildFastener(fastener, child, target) {
      super.bindChildFastener(fastener, child, target);
      if (fastener instanceof ControllerRelation) {
        fastener.bindController(child, target);
      }
    }
    unbindChildFastener(fastener, child) {
      if (fastener instanceof ControllerRelation) {
        fastener.unbindController(child);
      }
      super.unbindChildFastener(fastener, child);
    }
    decohereFastener(fastener) {
      super.decohereFastener(fastener);
      this.requireUpdate(Controller.NeedsRevise);
    }
    get superControllerContext() {
      const parent = this.parent;
      if (parent !== null) {
        return parent.controllerContext;
      } else {
        return this.executeProvider.updatedControllerContext();
      }
    }
    extendControllerContext(controllerContext) {
      return controllerContext;
    }
    get controllerContext() {
      if ((this.flags & Controller.ContextualFlag) !== 0) {
        return ControllerContext.current;
      } else {
        return this.extendControllerContext(this.superControllerContext);
      }
    }
    init(init) {}
    static create() {
      return new this;
    }
    static fromInit(init) {
      let type;
      if ((typeof init === "object" && init !== null || typeof init === "function") && util.Creatable.is(init.type)) {
        type = init.type;
      } else {
        type = this;
      }
      const controller = type.create();
      controller.init(init);
      return controller;
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return value;
      } else if (value instanceof Controller) {
        if (value instanceof this) {
          return value;
        } else {
          throw new TypeError(value + " not an instance of " + this);
        }
      } else if (util.Creatable.is(value)) {
        return value.create();
      } else {
        return this.fromInit(value);
      }
    }
  }
  Controller.uid = function() {
    let nextId = 1;
    return function uid() {
      const id = ~~nextId;
      nextId += 1;
      return id;
    };
  }();
  Controller.MountedFlag = component.Component.MountedFlag;
  Controller.RemovingFlag = component.Component.RemovingFlag;
  Controller.CompilingFlag = 1 << component.Component.FlagShift + 0;
  Controller.ExecutingFlag = 1 << component.Component.FlagShift + 1;
  Controller.ContextualFlag = 1 << component.Component.FlagShift + 2;
  Controller.UpdatingMask = Controller.CompilingFlag | Controller.ExecutingFlag;
  Controller.StatusMask = Controller.MountedFlag | Controller.RemovingFlag | Controller.CompilingFlag | Controller.ExecutingFlag | Controller.ContextualFlag;
  Controller.NeedsCompile = 1 << component.Component.FlagShift + 3;
  Controller.NeedsResolve = 1 << component.Component.FlagShift + 4;
  Controller.NeedsGenerate = 1 << component.Component.FlagShift + 5;
  Controller.NeedsAssemble = 1 << component.Component.FlagShift + 6;
  Controller.CompileMask = Controller.NeedsCompile | Controller.NeedsResolve | Controller.NeedsGenerate | Controller.NeedsAssemble;
  Controller.NeedsExecute = 1 << component.Component.FlagShift + 7;
  Controller.NeedsRevise = 1 << component.Component.FlagShift + 8;
  Controller.NeedsCompute = 1 << component.Component.FlagShift + 9;
  Controller.ExecuteMask = Controller.NeedsExecute | Controller.NeedsRevise | Controller.NeedsCompute;
  Controller.UpdateMask = Controller.CompileMask | Controller.ExecuteMask;
  Controller.FlagShift = component.Component.FlagShift + 10;
  Controller.FlagMask = (1 << Controller.FlagShift) - 1;
  Controller.MountFlags = 0;
  Controller.InsertChildFlags = 0;
  Controller.RemoveChildFlags = 0;
  __decorate([ component.Provider({
    extends: ExecuteProvider,
    type: ExecuteService,
    observes: false,
    service: ExecuteService.global()
  }) ], Controller.prototype, "executeProvider", void 0);
  __decorate([ component.Provider({
    extends: HistoryProvider,
    type: HistoryService,
    observes: false,
    service: HistoryService.global()
  }) ], Controller.prototype, "historyProvider", void 0);
  __decorate([ component.Provider({
    extends: StorageProvider,
    type: StorageService,
    observes: false,
    service: StorageService.global()
  }) ], Controller.prototype, "storageProvider", void 0);
  const ControllerRelation = function(_super) {
    const ControllerRelation = _super.extend("ControllerRelation");
    Object.defineProperty(ControllerRelation.prototype, "fastenerType", {
      get: function() {
        return ControllerRelation;
      },
      configurable: true
    });
    ControllerRelation.prototype.initController = function(controller) {};
    ControllerRelation.prototype.willAttachController = function(controller, target) {};
    ControllerRelation.prototype.onAttachController = function(controller, target) {
      if (this.observes === true) {
        controller.observe(this);
      }
    };
    ControllerRelation.prototype.didAttachController = function(controller, target) {};
    ControllerRelation.prototype.deinitController = function(controller) {};
    ControllerRelation.prototype.willDetachController = function(controller) {};
    ControllerRelation.prototype.onDetachController = function(controller) {
      if (this.observes === true) {
        controller.unobserve(this);
      }
    };
    ControllerRelation.prototype.didDetachController = function(controller) {};
    Object.defineProperty(ControllerRelation.prototype, "parentController", {
      get() {
        const owner = this.owner;
        return owner instanceof Controller ? owner : null;
      },
      configurable: true
    });
    ControllerRelation.prototype.insertChild = function(parent, child, target, key) {
      parent.insertChild(child, target, key);
    };
    ControllerRelation.prototype.bindController = function(controller, target) {};
    ControllerRelation.prototype.unbindController = function(controller) {};
    ControllerRelation.prototype.detectController = function(controller) {
      return null;
    };
    ControllerRelation.prototype.createController = function() {
      let controller;
      const type = this.type;
      if (type !== void 0) {
        controller = type.create();
      }
      if (controller === void 0 || controller === null) {
        let message = "Unable to create ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "controller";
        throw new Error(message);
      }
      return controller;
    };
    ControllerRelation.prototype.fromAny = function(value) {
      const type = this.type;
      if (type !== void 0) {
        return type.fromAny(value);
      } else {
        return Controller.fromAny(value);
      }
    };
    Object.defineProperty(ControllerRelation.prototype, "lazy", {
      get: function() {
        return false;
      },
      configurable: true
    });
    Object.defineProperty(ControllerRelation.prototype, "static", {
      get: function() {
        return true;
      },
      configurable: true
    });
    ControllerRelation.construct = function(fastenerClass, fastener, owner) {
      fastener = _super.construct(fastenerClass, fastener, owner);
      return fastener;
    };
    ControllerRelation.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        return fastener;
      };
      return fastenerClass;
    };
    return ControllerRelation;
  }(component.Fastener);
  const ControllerRef = function(_super) {
    const ControllerRef = _super.extend("ControllerRef");
    Object.defineProperty(ControllerRef.prototype, "fastenerType", {
      get: function() {
        return ControllerRef;
      },
      configurable: true
    });
    ControllerRef.prototype.onInherit = function(superFastener) {
      this.setController(superFastener.controller);
    };
    ControllerRef.prototype.getController = function() {
      const controller = this.controller;
      if (controller === null) {
        let message = controller + " ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "controller";
        throw new TypeError(message);
      }
      return controller;
    };
    ControllerRef.prototype.setController = function(newController, target, key) {
      if (newController !== null) {
        newController = this.fromAny(newController);
      }
      let oldController = this.controller;
      if (oldController !== newController) {
        if (target === void 0) {
          target = null;
        }
        let parent;
        if (this.binds && (parent = this.parentController, parent !== null)) {
          if (oldController !== null && oldController.parent === parent) {
            if (target === null) {
              target = oldController.nextSibling;
            }
            oldController.remove();
          }
          if (newController !== null) {
            if (key === void 0) {
              key = this.key;
            }
            this.insertChild(parent, newController, target, key);
          }
          oldController = this.controller;
        }
        if (oldController !== newController) {
          if (oldController !== null) {
            this.willDetachController(oldController);
            this.controller = null;
            this.onDetachController(oldController);
            this.deinitController(oldController);
            this.didDetachController(oldController);
          }
          if (newController !== null) {
            this.willAttachController(newController, target);
            this.controller = newController;
            this.onAttachController(newController, target);
            this.initController(newController);
            this.didAttachController(newController, target);
          }
        }
      }
      return oldController;
    };
    ControllerRef.prototype.attachController = function(newController, target) {
      const oldController = this.controller;
      if (newController !== void 0 && newController !== null) {
        newController = this.fromAny(newController);
      } else if (oldController === null) {
        newController = this.createController();
      } else {
        newController = oldController;
      }
      if (newController !== oldController) {
        if (target === void 0) {
          target = null;
        }
        if (oldController !== null) {
          this.willDetachController(oldController);
          this.controller = null;
          this.onDetachController(oldController);
          this.deinitController(oldController);
          this.didDetachController(oldController);
        }
        this.willAttachController(newController, target);
        this.controller = newController;
        this.onAttachController(newController, target);
        this.initController(newController);
        this.didAttachController(newController, target);
      }
      return newController;
    };
    ControllerRef.prototype.detachController = function() {
      const oldController = this.controller;
      if (oldController !== null) {
        this.willDetachController(oldController);
        this.controller = null;
        this.onDetachController(oldController);
        this.deinitController(oldController);
        this.didDetachController(oldController);
      }
      return oldController;
    };
    ControllerRef.prototype.insertController = function(parent, newController, target, key) {
      if (newController !== void 0 && newController !== null) {
        newController = this.fromAny(newController);
      } else {
        const oldController = this.controller;
        if (oldController === null) {
          newController = this.createController();
        } else {
          newController = oldController;
        }
      }
      if (parent === void 0 || parent === null) {
        parent = this.parentController;
      }
      if (target === void 0) {
        target = null;
      }
      if (key === void 0) {
        key = this.key;
      }
      if (parent !== null && (newController.parent !== parent || newController.key !== key)) {
        this.insertChild(parent, newController, target, key);
      }
      const oldController = this.controller;
      if (newController !== oldController) {
        if (oldController !== null) {
          this.willDetachController(oldController);
          this.controller = null;
          this.onDetachController(oldController);
          this.deinitController(oldController);
          this.didDetachController(oldController);
          oldController.remove();
        }
        this.willAttachController(newController, target);
        this.controller = newController;
        this.onAttachController(newController, target);
        this.initController(newController);
        this.didAttachController(newController, target);
      }
      return newController;
    };
    ControllerRef.prototype.removeController = function() {
      const controller = this.controller;
      if (controller !== null) {
        controller.remove();
      }
      return controller;
    };
    ControllerRef.prototype.deleteController = function() {
      const controller = this.detachController();
      if (controller !== null) {
        controller.remove();
      }
      return controller;
    };
    ControllerRef.prototype.bindController = function(controller, target) {
      if (this.binds && this.controller === null) {
        const newController = this.detectController(controller);
        if (newController !== null) {
          this.willAttachController(newController, target);
          this.controller = newController;
          this.onAttachController(newController, target);
          this.initController(newController);
          this.didAttachController(newController, target);
        }
      }
    };
    ControllerRef.prototype.unbindController = function(controller) {
      if (this.binds) {
        const oldController = this.detectController(controller);
        if (oldController !== null && this.controller === oldController) {
          this.willDetachController(oldController);
          this.controller = null;
          this.onDetachController(oldController);
          this.deinitController(oldController);
          this.didDetachController(oldController);
        }
      }
    };
    ControllerRef.prototype.detectController = function(controller) {
      const key = this.key;
      if (key !== void 0 && key === controller.key) {
        return controller;
      }
      return null;
    };
    ControllerRef.construct = function(fastenerClass, fastener, owner) {
      if (fastener === null) {
        fastener = function(controller, target, key) {
          if (controller === void 0) {
            return fastener.controller;
          } else {
            fastener.setController(controller, target, key);
            return fastener.owner;
          }
        };
        delete fastener.name;
        Object.setPrototypeOf(fastener, fastenerClass.prototype);
      }
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.key = void 0;
      fastener.controller = null;
      return fastener;
    };
    ControllerRef.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      if (descriptor.key === true) {
        Object.defineProperty(descriptor, "key", {
          value: className,
          configurable: true
        });
      } else if (descriptor.key === false) {
        Object.defineProperty(descriptor, "key", {
          value: void 0,
          configurable: true
        });
      }
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        return fastener;
      };
      return fastenerClass;
    };
    return ControllerRef;
  }(ControllerRelation);
  const ControllerSet = function(_super) {
    const ControllerSet = _super.extend("ControllerSet");
    Object.defineProperty(ControllerSet.prototype, "fastenerType", {
      get: function() {
        return ControllerSet;
      },
      configurable: true
    });
    ControllerSet.prototype.hasController = function(controller) {
      return this.controllers[controller.uid] !== void 0;
    };
    ControllerSet.prototype.addController = function(newController, target, key) {
      if (newController !== void 0 && newController !== null) {
        newController = this.fromAny(newController);
      } else {
        newController = this.createController();
      }
      if (target === void 0) {
        target = null;
      }
      let parent;
      if (this.binds && (parent = this.parentController, parent !== null)) {
        if (key === void 0) {
          key = this.key(newController);
        }
        this.insertChild(parent, newController, target, key);
      }
      const controllers = this.controllers;
      if (controllers[newController.uid] === void 0) {
        this.willAttachController(newController, target);
        controllers[newController.uid] = newController;
        this.controllerCount += 1;
        this.onAttachController(newController, target);
        this.initController(newController);
        this.didAttachController(newController, target);
      }
      return newController;
    };
    ControllerSet.prototype.attachController = function(newController, target) {
      if (newController !== void 0 && newController !== null) {
        newController = this.fromAny(newController);
      } else {
        newController = this.createController();
      }
      const controllers = this.controllers;
      if (controllers[newController.uid] === void 0) {
        if (target === void 0) {
          target = null;
        }
        this.willAttachController(newController, target);
        controllers[newController.uid] = newController;
        this.controllerCount += 1;
        this.onAttachController(newController, target);
        this.initController(newController);
        this.didAttachController(newController, target);
      }
      return newController;
    };
    ControllerSet.prototype.detachController = function(oldController) {
      const controllers = this.controllers;
      if (controllers[oldController.uid] !== void 0) {
        this.willDetachController(oldController);
        this.controllerCount -= 1;
        delete controllers[oldController.uid];
        this.onDetachController(oldController);
        this.deinitController(oldController);
        this.didDetachController(oldController);
        return oldController;
      }
      return null;
    };
    ControllerSet.prototype.insertController = function(parent, newController, target, key) {
      if (newController !== void 0 && newController !== null) {
        newController = this.fromAny(newController);
      } else {
        newController = this.createController();
      }
      if (parent === void 0 || parent === null) {
        parent = this.parentController;
      }
      if (target === void 0) {
        target = null;
      }
      if (key === void 0) {
        key = this.key(newController);
      }
      if (parent !== null && (newController.parent !== parent || newController.key !== key)) {
        this.insertChild(parent, newController, target, key);
      }
      const controllers = this.controllers;
      if (controllers[newController.uid] === void 0) {
        this.willAttachController(newController, target);
        controllers[newController.uid] = newController;
        this.controllerCount += 1;
        this.onAttachController(newController, target);
        this.initController(newController);
        this.didAttachController(newController, target);
      }
      return newController;
    };
    ControllerSet.prototype.removeController = function(controller) {
      if (this.hasController(controller)) {
        controller.remove();
        return controller;
      }
      return null;
    };
    ControllerSet.prototype.deleteController = function(controller) {
      const oldController = this.detachController(controller);
      if (oldController !== null) {
        oldController.remove();
      }
      return oldController;
    };
    ControllerSet.prototype.bindController = function(controller, target) {
      if (this.binds) {
        const newController = this.detectController(controller);
        const controllers = this.controllers;
        if (newController !== null && controllers[newController.uid] === void 0) {
          this.willAttachController(newController, target);
          controllers[newController.uid] = newController;
          this.controllerCount += 1;
          this.onAttachController(newController, target);
          this.initController(newController);
          this.didAttachController(newController, target);
        }
      }
    };
    ControllerSet.prototype.unbindController = function(controller) {
      if (this.binds) {
        const oldController = this.detectController(controller);
        const controllers = this.controllers;
        if (oldController !== null && controllers[oldController.uid] !== void 0) {
          this.willDetachController(oldController);
          this.controllerCount -= 1;
          delete controllers[oldController.uid];
          this.onDetachController(oldController);
          this.deinitController(oldController);
          this.didDetachController(oldController);
        }
      }
    };
    ControllerSet.prototype.detectController = function(controller) {
      if (typeof this.type === "function" && controller instanceof this.type) {
        return controller;
      }
      return null;
    };
    ControllerSet.prototype.key = function(controller) {
      return void 0;
    };
    Object.defineProperty(ControllerSet.prototype, "sorted", {
      get() {
        return (this.flags & ControllerSet.SortedFlag) !== 0;
      },
      configurable: true
    });
    ControllerSet.prototype.initInherits = function(sorted) {
      if (sorted) {
        this.flags = this.flags | ControllerSet.SortedFlag;
      } else {
        this.flags = this.flags & ~ControllerSet.SortedFlag;
      }
    };
    ControllerSet.prototype.sort = function(sorted) {
      if (sorted === void 0) {
        sorted = true;
      }
      const flags = this.flags;
      if (sorted && (flags & ControllerSet.SortedFlag) === 0) {
        const parent = this.parentController;
        this.willSort(parent);
        this.setFlags(flags | ControllerSet.SortedFlag);
        this.onSort(parent);
        this.didSort(parent);
      } else if (!sorted && (flags & ControllerSet.SortedFlag) !== 0) {
        this.setFlags(flags & ~ControllerSet.SortedFlag);
      }
      return this;
    };
    ControllerSet.prototype.willSort = function(parent) {};
    ControllerSet.prototype.onSort = function(parent) {
      if (parent !== null) {
        this.sortChildren(parent);
      }
    };
    ControllerSet.prototype.didSort = function(parent) {};
    ControllerSet.prototype.sortChildren = function(parent) {
      parent.sortChildren(this.compareChildren.bind(this));
    };
    ControllerSet.prototype.compareChildren = function(a, b) {
      const controllers = this.controllers;
      const x = controllers[a.uid];
      const y = controllers[b.uid];
      if (x !== void 0 && y !== void 0) {
        return this.compare(x, y);
      } else {
        return x !== void 0 ? 1 : y !== void 0 ? -1 : 0;
      }
    };
    ControllerSet.prototype.compare = function(a, b) {
      return a.uid < b.uid ? -1 : a.uid > b.uid ? 1 : 0;
    };
    ControllerSet.construct = function(fastenerClass, fastener, owner) {
      if (fastener === null) {
        fastener = function(newController) {
          fastener.addController(newController);
          return fastener.owner;
        };
        delete fastener.name;
        Object.setPrototypeOf(fastener, fastenerClass.prototype);
      }
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.controllers = {};
      fastener.controllerCount = 0;
      return fastener;
    };
    ControllerSet.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const sorted = descriptor.sorted;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.sorted;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        if (sorted !== void 0) {
          fastener.initSorted(sorted);
        }
        return fastener;
      };
      return fastenerClass;
    };
    ControllerSet.SortedFlag = 1 << _super.FlagShift + 0;
    ControllerSet.FlagShift = _super.FlagShift + 1;
    ControllerSet.FlagMask = (1 << ControllerSet.FlagShift) - 1;
    return ControllerSet;
  }(ControllerRelation);
  const TraitViewRef = function(_super) {
    const TraitViewRef = _super.extend("TraitViewRef");
    Object.defineProperty(TraitViewRef.prototype, "fastenerType", {
      get: function() {
        return TraitViewRef;
      },
      configurable: true
    });
    TraitViewRef.prototype.onInherit = function(superFastener) {
      this.setTrait(superFastener.trait);
      this.setView(superFastener.view);
    };
    TraitViewRef.prototype.getTrait = function() {
      const trait = this.trait;
      if (trait === null) {
        let message = trait + " ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "trait";
        throw new TypeError(message);
      }
      return trait;
    };
    TraitViewRef.prototype.setTrait = function(newTrait, target, key) {
      if (newTrait !== null) {
        newTrait = this.fromAnyTrait(newTrait);
      }
      let oldTrait = this.trait;
      if (oldTrait !== newTrait) {
        if (target === void 0) {
          target = null;
        }
        let model;
        if (this.bindsTrait && (model = this.parentModel, model !== null)) {
          if (oldTrait !== null && oldTrait.model === model) {
            if (target === null) {
              target = oldTrait.nextTrait;
            }
            oldTrait.remove();
          }
          if (newTrait !== null) {
            if (key === void 0) {
              key = this.traitKey;
            }
            this.insertChildTrait(model, newTrait, target, key);
          }
          oldTrait = this.trait;
        }
        if (oldTrait !== newTrait) {
          if (oldTrait !== null) {
            this.willDetachTrait(oldTrait);
            this.trait = null;
            this.onDetachTrait(oldTrait);
            this.deinitTrait(oldTrait);
            this.didDetachTrait(oldTrait);
          }
          if (newTrait !== null) {
            this.willAttachTrait(newTrait, target);
            this.trait = newTrait;
            this.onAttachTrait(newTrait, target);
            this.initTrait(newTrait);
            this.didAttachTrait(newTrait, target);
          }
        }
      }
      return oldTrait;
    };
    TraitViewRef.prototype.attachTrait = function(newTrait, target) {
      const oldTrait = this.trait;
      if (newTrait !== void 0 && newTrait !== null) {
        newTrait = this.fromAnyTrait(newTrait);
      } else if (oldTrait === null) {
        newTrait = this.createTrait();
      } else {
        newTrait = oldTrait;
      }
      if (newTrait !== oldTrait) {
        if (target === void 0) {
          target = null;
        }
        if (oldTrait !== null) {
          this.willDetachTrait(oldTrait);
          this.trait = null;
          this.onDetachTrait(oldTrait);
          this.deinitTrait(oldTrait);
          this.didDetachTrait(oldTrait);
        }
        this.willAttachTrait(newTrait, target);
        this.trait = newTrait;
        this.onAttachTrait(newTrait, target);
        this.initTrait(newTrait);
        this.didAttachTrait(newTrait, target);
      }
      return newTrait;
    };
    TraitViewRef.prototype.detachTrait = function() {
      const oldTrait = this.trait;
      if (oldTrait !== null) {
        this.willDetachTrait(oldTrait);
        this.trait = null;
        this.onDetachTrait(oldTrait);
        this.deinitTrait(oldTrait);
        this.didDetachTrait(oldTrait);
      }
      return oldTrait;
    };
    TraitViewRef.prototype.initTrait = function(trait) {};
    TraitViewRef.prototype.willAttachTrait = function(trait, target) {};
    TraitViewRef.prototype.onAttachTrait = function(trait, target) {
      if (this.observesTrait === true) {
        trait.observe(this);
      }
    };
    TraitViewRef.prototype.didAttachTrait = function(trait, target) {};
    TraitViewRef.prototype.deinitTrait = function(trait) {};
    TraitViewRef.prototype.willDetachTrait = function(trait) {};
    TraitViewRef.prototype.onDetachTrait = function(trait) {
      if (this.observesTrait === true) {
        trait.unobserve(this);
      }
    };
    TraitViewRef.prototype.didDetachTrait = function(trait) {};
    TraitViewRef.prototype.insertTrait = function(model, newTrait, target, key) {
      if (newTrait !== void 0 && newTrait !== null) {
        newTrait = this.fromAnyTrait(newTrait);
      } else {
        const oldTrait = this.trait;
        if (oldTrait === null) {
          newTrait = this.createTrait();
        } else {
          newTrait = oldTrait;
        }
      }
      if (model === void 0 || model === null) {
        model = this.parentModel;
      }
      if (target === void 0) {
        target = null;
      }
      if (key === void 0) {
        key = this.traitKey;
      }
      if (model !== null && (newTrait.parent !== model || newTrait.key !== key)) {
        this.insertChildTrait(model, newTrait, target, key);
      }
      const oldTrait = this.trait;
      if (newTrait !== oldTrait) {
        if (oldTrait !== null) {
          this.willDetachTrait(oldTrait);
          this.trait = null;
          this.onDetachTrait(oldTrait);
          this.deinitTrait(oldTrait);
          this.didDetachTrait(oldTrait);
          oldTrait.remove();
        }
        this.willAttachTrait(newTrait, target);
        this.trait = newTrait;
        this.onAttachTrait(newTrait, target);
        this.initTrait(newTrait);
        this.didAttachTrait(newTrait, target);
      }
      return newTrait;
    };
    TraitViewRef.prototype.removeTrait = function() {
      const trait = this.trait;
      if (trait !== null) {
        trait.remove();
      }
      return trait;
    };
    TraitViewRef.prototype.deleteTrait = function() {
      const trait = this.detachTrait();
      if (trait !== null) {
        trait.remove();
      }
      return trait;
    };
    Object.defineProperty(TraitViewRef.prototype, "parentModel", {
      get() {
        const owner = this.owner;
        if (owner instanceof Model) {
          return owner;
        } else if (owner instanceof Trait) {
          return owner.model;
        } else {
          return null;
        }
      },
      configurable: true
    });
    TraitViewRef.prototype.insertChildTrait = function(model, trait, target, key) {
      model.insertTrait(trait, target, key);
    };
    TraitViewRef.prototype.bindModel = function(model, targetModel) {
      if (this.bindsTrait && this.trait === null) {
        const newTrait = this.detectModel(model);
        if (newTrait !== null) {
          this.willAttachTrait(newTrait, null);
          this.trait = newTrait;
          this.onAttachTrait(newTrait, null);
          this.initTrait(newTrait);
          this.didAttachTrait(newTrait, null);
        }
      }
    };
    TraitViewRef.prototype.unbindModel = function(model) {
      if (this.bindsTrait) {
        const oldTrait = this.detectModel(model);
        if (oldTrait !== null && this.trait === oldTrait) {
          this.willDetachTrait(oldTrait);
          this.trait = null;
          this.onDetachTrait(oldTrait);
          this.deinitTrait(oldTrait);
          this.didDetachTrait(oldTrait);
        }
      }
    };
    TraitViewRef.prototype.detectModel = function(model) {
      return null;
    };
    TraitViewRef.prototype.bindTrait = function(trait, target) {
      if (this.bindsTrait && this.trait === null) {
        const newTrait = this.detectTrait(trait);
        if (newTrait !== null) {
          this.willAttachTrait(newTrait, target);
          this.trait = newTrait;
          this.onAttachTrait(newTrait, target);
          this.initTrait(newTrait);
          this.didAttachTrait(newTrait, target);
        }
      }
    };
    TraitViewRef.prototype.unbindTrait = function(trait) {
      if (this.bindsTrait) {
        const oldTrait = this.detectTrait(trait);
        if (oldTrait !== null && this.trait === oldTrait) {
          this.willDetachTrait(oldTrait);
          this.trait = null;
          this.onDetachTrait(oldTrait);
          this.deinitTrait(oldTrait);
          this.didDetachTrait(oldTrait);
        }
      }
    };
    TraitViewRef.prototype.detectTrait = function(trait) {
      const key = this.traitKey;
      if (key !== void 0 && key === trait.key) {
        return trait;
      }
      return null;
    };
    TraitViewRef.prototype.createTrait = function() {
      let trait;
      const type = this.traitType;
      if (type !== void 0) {
        trait = type.create();
      }
      if (trait === void 0 || trait === null) {
        let message = "Unable to create ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "trait";
        throw new Error(message);
      }
      return trait;
    };
    TraitViewRef.prototype.fromAnyTrait = function(value) {
      const type = this.traitType;
      if (type !== void 0) {
        return type.fromAny(value);
      } else {
        return Trait.fromAny(value);
      }
    };
    TraitViewRef.prototype.getView = function() {
      const view = this.view;
      if (view === null) {
        let message = view + " ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "view";
        throw new TypeError(message);
      }
      return view;
    };
    TraitViewRef.prototype.setView = function(newView, target, key) {
      if (newView !== null) {
        newView = this.fromAnyView(newView);
      }
      let oldView = this.view;
      if (oldView !== newView) {
        if (target === void 0) {
          target = null;
        }
        let parent;
        if (this.bindsView && (parent = this.parentView, parent !== null)) {
          if (oldView !== null && oldView.parent === parent) {
            if (target === null) {
              target = oldView.nextSibling;
            }
            oldView.remove();
          }
          if (newView !== null) {
            if (key === void 0) {
              key = this.viewKey;
            }
            this.insertChildView(parent, newView, target, key);
          }
          oldView = this.view;
        }
        if (oldView !== newView) {
          if (oldView !== null) {
            this.willDetachView(oldView);
            this.view = null;
            this.onDetachView(oldView);
            this.deinitView(oldView);
            this.didDetachView(oldView);
          }
          if (newView !== null) {
            this.willAttachView(newView, target);
            this.view = newView;
            this.onAttachView(newView, target);
            this.initView(newView);
            this.didAttachView(newView, target);
          }
        }
      }
      return oldView;
    };
    TraitViewRef.prototype.attachView = function(newView, target) {
      const oldView = this.view;
      if (newView !== void 0 && newView !== null) {
        newView = this.fromAnyView(newView);
      } else if (oldView === null) {
        newView = this.createView();
      } else {
        newView = oldView;
      }
      if (newView !== oldView) {
        if (target === void 0) {
          target = null;
        }
        if (oldView !== null) {
          this.willDetachView(oldView);
          this.view = null;
          this.onDetachView(oldView);
          this.deinitView(oldView);
          this.didDetachView(oldView);
        }
        this.willAttachView(newView, target);
        this.view = newView;
        this.onAttachView(newView, target);
        this.initView(newView);
        this.didAttachView(newView, target);
      }
      return newView;
    };
    TraitViewRef.prototype.detachView = function() {
      const oldView = this.view;
      if (oldView !== null) {
        this.willDetachView(oldView);
        this.view = null;
        this.onDetachView(oldView);
        this.deinitView(oldView);
        this.didDetachView(oldView);
      }
      return oldView;
    };
    TraitViewRef.prototype.initView = function(view) {};
    TraitViewRef.prototype.willAttachView = function(view, target) {};
    TraitViewRef.prototype.onAttachView = function(view, target) {
      if (this.observesView === true) {
        view.observe(this);
      }
    };
    TraitViewRef.prototype.didAttachView = function(view, target) {};
    TraitViewRef.prototype.deinitView = function(view) {};
    TraitViewRef.prototype.willDetachView = function(view) {};
    TraitViewRef.prototype.onDetachView = function(view) {
      if (this.observesView === true) {
        view.unobserve(this);
      }
    };
    TraitViewRef.prototype.didDetachView = function(view) {};
    TraitViewRef.prototype.insertView = function(parent, newView, target, key) {
      if (newView !== void 0 && newView !== null) {
        newView = this.fromAnyView(newView);
      } else {
        const oldView = this.view;
        if (oldView === null) {
          newView = this.createView();
        } else {
          newView = oldView;
        }
      }
      if (parent === void 0 || parent === null) {
        parent = this.parentView;
      }
      if (target === void 0) {
        target = null;
      }
      if (key === void 0) {
        key = this.viewKey;
      }
      if (parent !== null && (newView.parent !== parent || newView.key !== key)) {
        this.insertChildView(parent, newView, target, key);
      }
      const oldView = this.view;
      if (newView !== oldView) {
        if (oldView !== null) {
          this.willDetachView(oldView);
          this.view = null;
          this.onDetachView(oldView);
          this.deinitView(oldView);
          this.didDetachView(oldView);
          oldView.remove();
        }
        this.willAttachView(newView, target);
        this.view = newView;
        this.onAttachView(newView, target);
        this.initView(newView);
        this.didAttachView(newView, target);
      }
      return newView;
    };
    TraitViewRef.prototype.removeView = function() {
      const view = this.view;
      if (view !== null) {
        view.remove();
      }
      return view;
    };
    TraitViewRef.prototype.deleteView = function() {
      const view = this.detachView();
      if (view !== null) {
        view.remove();
      }
      return view;
    };
    Object.defineProperty(TraitViewRef.prototype, "parentView", {
      get() {
        const owner = this.owner;
        return owner instanceof View ? owner : null;
      },
      configurable: true
    });
    TraitViewRef.prototype.insertChildView = function(parent, child, target, key) {
      parent.insertChild(child, target, key);
    };
    TraitViewRef.prototype.bindView = function(view, target) {
      if (this.bindsView && this.view === null) {
        const newView = this.detectView(view);
        if (newView !== null) {
          this.willAttachView(newView, target);
          this.view = newView;
          this.onAttachView(newView, target);
          this.initView(newView);
          this.didAttachView(newView, target);
        }
      }
    };
    TraitViewRef.prototype.unbindView = function(view) {
      if (this.bindsView) {
        const oldView = this.detectView(view);
        if (oldView !== null && this.view === oldView) {
          this.willDetachView(oldView);
          this.view = null;
          this.onDetachView(oldView);
          this.deinitView(oldView);
          this.didDetachView(oldView);
        }
      }
    };
    TraitViewRef.prototype.detectView = function(view) {
      const key = this.viewKey;
      if (key !== void 0 && key === view.key) {
        return view;
      }
      return null;
    };
    TraitViewRef.prototype.createView = function() {
      let view;
      const type = this.viewType;
      if (type !== void 0) {
        view = type.create();
      }
      if (view === void 0 || view === null) {
        let message = "Unable to create ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "view";
        throw new Error(message);
      }
      return view;
    };
    TraitViewRef.prototype.fromAnyView = function(value) {
      const type = this.viewType;
      if (type !== void 0) {
        return type.fromAny(value);
      } else {
        return View.fromAny(value);
      }
    };
    Object.defineProperty(TraitViewRef.prototype, "lazy", {
      get: function() {
        return false;
      },
      configurable: true
    });
    Object.defineProperty(TraitViewRef.prototype, "static", {
      get: function() {
        return true;
      },
      configurable: true
    });
    TraitViewRef.construct = function(fastenerClass, fastener, owner) {
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.trait = null;
      fastener.view = null;
      return fastener;
    };
    TraitViewRef.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      if (descriptor.traitKey === true) {
        Object.defineProperty(descriptor, "traitKey", {
          value: className,
          configurable: true
        });
      } else if (descriptor.traitKey === false) {
        Object.defineProperty(descriptor, "traitKey", {
          value: void 0,
          configurable: true
        });
      }
      if (descriptor.viewKey === true) {
        Object.defineProperty(descriptor, "viewKey", {
          value: className,
          configurable: true
        });
      } else if (descriptor.viewKey === false) {
        Object.defineProperty(descriptor, "viewKey", {
          value: void 0,
          configurable: true
        });
      }
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        return fastener;
      };
      return fastenerClass;
    };
    return TraitViewRef;
  }(component.Fastener);
  const TraitControllerRef = function(_super) {
    const TraitControllerRef = _super.extend("TraitControllerRef");
    Object.defineProperty(TraitControllerRef.prototype, "fastenerType", {
      get: function() {
        return TraitControllerRef;
      },
      configurable: true
    });
    TraitControllerRef.prototype.getTraitRef = function(controller) {
      throw new Error("abstract");
    };
    Object.defineProperty(TraitControllerRef.prototype, "trait", {
      get: function() {
        const controller = this.controller;
        if (controller !== null) {
          const traitRef = this.getTraitRef(controller);
          return traitRef.trait;
        }
        return null;
      },
      configurable: true
    });
    TraitControllerRef.prototype.setTrait = function(trait, targetTrait, key) {
      let controller = this.controller;
      if (trait !== null) {
        if (controller === null) {
          controller = this.createController(trait);
        }
        const traitRef = this.getTraitRef(controller);
        traitRef.setTrait(trait, targetTrait, key);
        this.setController(controller, null, key);
      } else if (controller !== null) {
        const traitRef = this.getTraitRef(controller);
        traitRef.setTrait(null);
      }
      return controller;
    };
    TraitControllerRef.prototype.removeTrait = function(trait) {
      const controller = this.controller;
      if (controller !== null) {
        const traitRef = this.getTraitRef(controller);
        if (traitRef.trait === trait) {
          controller.remove();
          return controller;
        }
      }
      return null;
    };
    TraitControllerRef.prototype.deleteTrait = function(trait) {
      const controller = this.controller;
      if (controller !== null) {
        const traitRef = this.getTraitRef(controller);
        if (traitRef.trait === trait) {
          controller.remove();
          this.setController(null);
          return controller;
        }
      }
      return null;
    };
    TraitControllerRef.construct = function(fastenerClass, fastener, owner) {
      fastener = _super.construct(fastenerClass, fastener, owner);
      return fastener;
    };
    TraitControllerRef.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      if (descriptor.key === true) {
        Object.defineProperty(descriptor, "key", {
          value: className,
          configurable: true
        });
      } else if (descriptor.key === false) {
        Object.defineProperty(descriptor, "key", {
          value: void 0,
          configurable: true
        });
      }
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        return fastener;
      };
      return fastenerClass;
    };
    return TraitControllerRef;
  }(ControllerRef);
  const TraitControllerSet = function(_super) {
    const TraitControllerSet = _super.extend("TraitControllerSet");
    TraitControllerSet.prototype.getTraitRef = function(controller) {
      throw new Error("missing implementation");
    };
    TraitControllerSet.prototype.hasTraitController = function(trait) {
      return this.traitControllers[trait.uid] !== void 0;
    };
    TraitControllerSet.prototype.addTraitController = function(trait, targetTrait, key) {
      const traitControllers = this.traitControllers;
      let controller = traitControllers[trait.uid];
      if (controller === void 0) {
        controller = this.createController(trait);
        const traitRef = this.getTraitRef(controller);
        traitRef.setTrait(trait, targetTrait, key);
        const targetController = targetTrait !== void 0 && targetTrait !== null ? traitControllers[targetTrait.uid] : void 0;
        this.addController(controller, targetController, key);
      }
      return controller;
    };
    TraitControllerSet.prototype.removeTraitController = function(trait) {
      const controllers = this.controllers;
      for (const controllerId in controllers) {
        const controller = controllers[controllerId];
        const traitRef = this.getTraitRef(controller);
        if (traitRef.trait === trait) {
          this.removeController(controller);
          return controller;
        }
      }
      return null;
    };
    TraitControllerSet.prototype.deleteTraitController = function(trait) {
      const controllers = this.controllers;
      for (const controllerId in controllers) {
        const controller = controllers[controllerId];
        const traitRef = this.getTraitRef(controller);
        if (traitRef.trait === trait) {
          this.deleteController(controller);
          return controller;
        }
      }
      return null;
    };
    TraitControllerSet.prototype.attachControllerTrait = function(controller, trait, targetTrait) {
      const traitControllers = this.traitControllers;
      let traitController = traitControllers[trait.uid];
      if (traitController === void 0) {
        traitController = controller;
        if (targetTrait === void 0) {
          targetTrait = null;
        }
        this.willAttachControllerTrait(traitController, trait, targetTrait);
        traitControllers[trait.uid] = traitController;
        this.controllerCount += 1;
        this.onAttachControllerTrait(traitController, trait, targetTrait);
        this.initControllerTrait(traitController, trait);
        this.didAttachControllerTrait(traitController, trait, targetTrait);
      }
      return traitController;
    };
    TraitControllerSet.prototype.detachControllerTrait = function(controller, trait) {
      const traitControllers = this.traitControllers;
      const traitController = traitControllers[trait.uid];
      if (traitController !== void 0) {
        this.willDetachControllerTrait(traitController, trait);
        this.controllerCount -= 1;
        delete traitControllers[trait.uid];
        this.onDetachControllerTrait(traitController, trait);
        this.deinitControllerTrait(traitController, trait);
        this.didDetachControllerTrait(traitController, trait);
        return traitController;
      }
      return null;
    };
    TraitControllerSet.prototype.initControllerTrait = function(controller, trait) {};
    TraitControllerSet.prototype.willAttachControllerTrait = function(controller, trait, targetTrait) {};
    TraitControllerSet.prototype.onAttachControllerTrait = function(controller, trait, targetTrait) {};
    TraitControllerSet.prototype.didAttachControllerTrait = function(controller, trait, targetTrait) {};
    TraitControllerSet.prototype.deinitControllerTrait = function(controller, trait) {};
    TraitControllerSet.prototype.willDetachControllerTrait = function(controller, trait) {};
    TraitControllerSet.prototype.onDetachControllerTrait = function(controller, trait) {};
    TraitControllerSet.prototype.didDetachControllerTrait = function(controller, trait) {};
    TraitControllerSet.prototype.onAttachController = function(controller, targetController) {
      const trait = this.getTraitRef(controller).trait;
      if (trait !== null) {
        const targetTrait = targetController !== null && this.hasController(targetController) ? this.getTraitRef(targetController).trait : null;
        this.attachControllerTrait(controller, trait, targetTrait);
      }
      ControllerSet.prototype.onAttachController.call(this, controller, targetController);
    };
    TraitControllerSet.prototype.onDetachController = function(controller) {
      ControllerSet.prototype.onDetachController.call(this, controller);
      const trait = this.getTraitRef(controller).trait;
      if (trait !== null) {
        this.detachControllerTrait(controller, trait);
      }
    };
    TraitControllerSet.construct = function(fastenerClass, fastener, owner) {
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.traitControllers = {};
      return fastener;
    };
    TraitControllerSet.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const sorted = descriptor.sorted;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.sorted;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        if (sorted !== void 0) {
          fastener.initSorted(sorted);
        }
        return fastener;
      };
      return fastenerClass;
    };
    return TraitControllerSet;
  }(ControllerSet);
  const TraitViewControllerRef = function(_super) {
    const TraitViewControllerRef = _super.extend("TraitViewControllerRef");
    Object.defineProperty(TraitViewControllerRef.prototype, "fastenerType", {
      get: function() {
        return TraitViewControllerRef;
      },
      configurable: true
    });
    TraitViewControllerRef.prototype.getTraitViewRef = function(controller) {
      throw new Error("abstract");
    };
    Object.defineProperty(TraitViewControllerRef.prototype, "trait", {
      get: function() {
        const controller = this.controller;
        if (controller !== null) {
          const traitViewRef = this.getTraitViewRef(controller);
          return traitViewRef.trait;
        }
        return null;
      },
      configurable: true
    });
    TraitViewControllerRef.prototype.setTrait = function(trait, targetTrait, key) {
      let controller = this.controller;
      if (trait !== null) {
        if (controller === null) {
          controller = this.createController(trait);
        }
        const traitViewRef = this.getTraitViewRef(controller);
        traitViewRef.setTrait(trait, targetTrait, key);
        this.setController(controller, null, key);
        if (traitViewRef.view === null) {
          const view = traitViewRef.createView();
          traitViewRef.insertView(this.parentView, view, null, key);
        }
      } else if (controller !== null) {
        const traitViewRef = this.getTraitViewRef(controller);
        traitViewRef.setTrait(null);
      }
      return controller;
    };
    TraitViewControllerRef.prototype.removeTrait = function(trait) {
      const controller = this.controller;
      if (controller !== null) {
        const traitViewRef = this.getTraitViewRef(controller);
        if (traitViewRef.trait === trait) {
          controller.remove();
          return controller;
        }
      }
      return null;
    };
    TraitViewControllerRef.prototype.deleteTrait = function(trait) {
      const controller = this.controller;
      if (controller !== null) {
        const traitViewRef = this.getTraitViewRef(controller);
        if (traitViewRef.trait === trait) {
          controller.remove();
          this.setController(null);
          return controller;
        }
      }
      return null;
    };
    Object.defineProperty(TraitViewControllerRef.prototype, "view", {
      get: function() {
        const controller = this.controller;
        if (controller !== null) {
          const traitViewRef = this.getTraitViewRef(controller);
          return traitViewRef.view;
        }
        return null;
      },
      configurable: true
    });
    Object.defineProperty(TraitViewControllerRef.prototype, "parentView", {
      get: function() {
        return null;
      },
      configurable: true
    });
    TraitViewControllerRef.construct = function(fastenerClass, fastener, owner) {
      fastener = _super.construct(fastenerClass, fastener, owner);
      return fastener;
    };
    TraitViewControllerRef.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      if (descriptor.key === true) {
        Object.defineProperty(descriptor, "key", {
          value: className,
          configurable: true
        });
      } else if (descriptor.key === false) {
        Object.defineProperty(descriptor, "key", {
          value: void 0,
          configurable: true
        });
      }
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        return fastener;
      };
      return fastenerClass;
    };
    return TraitViewControllerRef;
  }(ControllerRef);
  const TraitViewControllerSet = function(_super) {
    const TraitViewControllerSet = _super.extend("TraitViewControllerSet");
    TraitViewControllerSet.prototype.getTraitViewRef = function(controller) {
      throw new Error("missing implementation");
    };
    TraitViewControllerSet.prototype.hasTraitController = function(trait) {
      return this.traitControllers[trait.uid] !== void 0;
    };
    TraitViewControllerSet.prototype.addTraitController = function(trait, targetTrait, key) {
      const traitControllers = this.traitControllers;
      let controller = traitControllers[trait.uid];
      if (controller === void 0) {
        controller = this.createController(trait);
        const traitViewRef = this.getTraitViewRef(controller);
        traitViewRef.setTrait(trait, targetTrait, key);
        const targetController = targetTrait !== void 0 && targetTrait !== null ? traitControllers[targetTrait.uid] : void 0;
        this.addController(controller, targetController, key);
        if (traitViewRef.view === null) {
          const view = traitViewRef.createView();
          const targetView = targetController !== void 0 ? this.getTraitViewRef(targetController).view : null;
          traitViewRef.insertView(this.parentView, view, targetView, key);
        }
      }
      return controller;
    };
    TraitViewControllerSet.prototype.removeTraitController = function(trait) {
      const controllers = this.controllers;
      for (const controllerId in controllers) {
        const controller = controllers[controllerId];
        const traitViewRef = this.getTraitViewRef(controller);
        if (traitViewRef.trait === trait) {
          this.removeController(controller);
          return controller;
        }
      }
      return null;
    };
    TraitViewControllerSet.prototype.deleteTraitController = function(trait) {
      const controllers = this.controllers;
      for (const controllerId in controllers) {
        const controller = controllers[controllerId];
        const traitViewRef = this.getTraitViewRef(controller);
        if (traitViewRef.trait === trait) {
          this.deleteController(controller);
          return controller;
        }
      }
      return null;
    };
    TraitViewControllerSet.prototype.attachControllerTrait = function(controller, trait, targetTrait) {
      const traitControllers = this.traitControllers;
      let traitController = traitControllers[trait.uid];
      if (traitController === void 0) {
        traitController = controller;
        if (targetTrait === void 0) {
          targetTrait = null;
        }
        this.willAttachControllerTrait(traitController, trait, targetTrait);
        traitControllers[trait.uid] = traitController;
        this.controllerCount += 1;
        this.onAttachControllerTrait(traitController, trait, targetTrait);
        this.initControllerTrait(traitController, trait);
        this.didAttachControllerTrait(traitController, trait, targetTrait);
      }
      return traitController;
    };
    TraitViewControllerSet.prototype.detachControllerTrait = function(controller, trait) {
      const traitControllers = this.traitControllers;
      const traitController = traitControllers[trait.uid];
      if (traitController !== void 0) {
        this.willDetachControllerTrait(traitController, trait);
        this.controllerCount -= 1;
        delete traitControllers[trait.uid];
        this.onDetachControllerTrait(traitController, trait);
        this.deinitControllerTrait(traitController, trait);
        this.didDetachControllerTrait(traitController, trait);
        return traitController;
      }
      return null;
    };
    TraitViewControllerSet.prototype.initControllerTrait = function(controller, trait) {};
    TraitViewControllerSet.prototype.willAttachControllerTrait = function(controller, trait, targetTrait) {};
    TraitViewControllerSet.prototype.onAttachControllerTrait = function(controller, trait, targetTrait) {};
    TraitViewControllerSet.prototype.didAttachControllerTrait = function(controller, trait, targetTrait) {};
    TraitViewControllerSet.prototype.deinitControllerTrait = function(controller, trait) {};
    TraitViewControllerSet.prototype.willDetachControllerTrait = function(controller, trait) {};
    TraitViewControllerSet.prototype.onDetachControllerTrait = function(controller, trait) {};
    TraitViewControllerSet.prototype.didDetachControllerTrait = function(controller, trait) {};
    TraitViewControllerSet.prototype.onAttachController = function(controller, targetController) {
      const trait = this.getTraitViewRef(controller).trait;
      if (trait !== null) {
        const targetTrait = targetController !== null && this.hasController(targetController) ? this.getTraitViewRef(targetController).trait : null;
        this.attachControllerTrait(controller, trait, targetTrait);
      }
      ControllerSet.prototype.onAttachController.call(this, controller, targetController);
    };
    TraitViewControllerSet.prototype.onDetachController = function(controller) {
      ControllerSet.prototype.onDetachController.call(this, controller);
      const trait = this.getTraitViewRef(controller).trait;
      if (trait !== null) {
        this.detachControllerTrait(controller, trait);
      }
    };
    Object.defineProperty(TraitViewControllerSet.prototype, "parentView", {
      get: function() {
        return null;
      },
      configurable: true
    });
    TraitViewControllerSet.construct = function(fastenerClass, fastener, owner) {
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.traitControllers = {};
      return fastener;
    };
    TraitViewControllerSet.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const sorted = descriptor.sorted;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.sorted;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        if (sorted !== void 0) {
          fastener.initSorted(sorted);
        }
        return fastener;
      };
      return fastenerClass;
    };
    return TraitViewControllerSet;
  }(ControllerSet);
  class ButtonGlow extends HtmlView {
    constructor(node) {
      super(node);
      this.glowState = "ready";
      this.glowTimer = 0;
      this.initGlow();
    }
    initGlow() {
      this.addClass("button-glow");
      this.position.setState("absolute", component.Affinity.Intrinsic);
      this.width.setState(math.Length.zero(), component.Affinity.Intrinsic);
      this.height.setState(math.Length.zero(), component.Affinity.Intrinsic);
      this.borderTopLeftRadius.setState(math.Length.pct(50), component.Affinity.Intrinsic);
      this.borderTopRightRadius.setState(math.Length.pct(50), component.Affinity.Intrinsic);
      this.borderBottomLeftRadius.setState(math.Length.pct(50), component.Affinity.Intrinsic);
      this.borderBottomRightRadius.setState(math.Length.pct(50), component.Affinity.Intrinsic);
      this.pointerEvents.setState("none", component.Affinity.Intrinsic);
    }
    didMount() {
      if (this.backgroundColor.hasAffinity(component.Affinity.Intrinsic)) {
        let highlightColor = this.getLookOr(Look.highlightColor, null);
        if (highlightColor !== null) {
          highlightColor = highlightColor.alpha(1);
        }
        this.backgroundColor.setState(highlightColor, component.Affinity.Intrinsic);
      }
      super.didMount();
    }
    onUnmount() {
      this.glowState = "ready";
      this.cancelGlow();
      this.remove();
      super.onUnmount();
    }
    onApplyTheme(theme, mood, timing) {
      super.onApplyTheme(theme, mood, timing);
      if (this.backgroundColor.hasAffinity(component.Affinity.Intrinsic)) {
        let highlightColor = theme.getOr(Look.highlightColor, mood, null);
        if (highlightColor !== null) {
          highlightColor = highlightColor.alpha(1);
        }
        this.backgroundColor.setState(highlightColor, component.Affinity.Intrinsic);
      }
    }
    glow(clientX, clientY, timing, delay = 0) {
      if (this.glowState === "ready") {
        this.cancelGlow();
        if (delay !== 0) {
          const glow = this.glow.bind(this, clientX, clientY, timing, component.Affinity.Intrinsic);
          this.glowTimer = setTimeout(glow, delay);
        } else {
          if (timing === void 0 || timing === true) {
            timing = this.getLookOr(Look.timing, false);
          } else {
            timing = util.Timing.fromAny(timing);
          }
          this.willGlow();
          const offsetParent = this.node.offsetParent;
          if (offsetParent !== null) {
            const clientBounds = offsetParent.getBoundingClientRect();
            const cx = clientX - clientBounds.left;
            const cy = clientY - clientBounds.top;
            const rx = Math.max(cx, clientBounds.width - cx);
            const ry = Math.max(cy, clientBounds.height - cy);
            const r = Math.sqrt(rx * rx + ry * ry);
            const highlightColor = this.getLook(Look.highlightColor);
            const opacity = highlightColor !== void 0 ? highlightColor.alpha() : .1;
            this.opacity.setState(opacity, component.Affinity.Intrinsic);
            if (timing !== false) {
              this.left.setState(cx, component.Affinity.Intrinsic);
              this.top.setState(cy, component.Affinity.Intrinsic);
              this.left.setState(cx - r, timing, component.Affinity.Intrinsic);
              this.top.setState(cy - r, timing, component.Affinity.Intrinsic);
              this.width.setState(2 * r, timing, component.Affinity.Intrinsic);
              this.height.setState(2 * r, timing, component.Affinity.Intrinsic);
            } else {
              this.left.setState(cx - r, component.Affinity.Intrinsic);
              this.top.setState(cy - r, component.Affinity.Intrinsic);
              this.width.setState(2 * r, component.Affinity.Intrinsic);
              this.height.setState(2 * r, component.Affinity.Intrinsic);
              this.didGlow();
            }
            this.glowState = "glowing";
          }
        }
      }
    }
    willGlow() {}
    didGlow() {}
    cancelGlow() {
      if (this.glowTimer !== 0) {
        clearTimeout(this.glowTimer);
        this.glowTimer = 0;
      }
    }
    pulse(clientX, clientY, timing) {
      if (timing === void 0 || timing === true) {
        timing = this.getLookOr(Look.timing, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      if (this.glowState === "ready") {
        this.glow(clientX, clientY, timing);
      }
      if (this.glowState === "glowing") {
        this.willPulse();
        if (timing !== false) {
          this.opacity.setState(0, timing, component.Affinity.Intrinsic);
        } else {
          this.opacity.setState(0, component.Affinity.Intrinsic);
          this.didPulse();
        }
        this.glowState = "pulsing";
      }
    }
    willPulse() {}
    didPulse() {
      this.remove();
    }
    fade(clientX, clientY, timing) {
      if (this.glowState === "ready") {
        this.cancelGlow();
        this.didFade();
      } else if (this.glowState === "glowing") {
        if (timing === void 0 || timing === true) {
          timing = this.getLookOr(Look.timing, false);
        } else {
          timing = util.Timing.fromAny(timing);
        }
        this.willFade();
        if (timing !== false) {
          this.opacity.setState(0, timing, component.Affinity.Intrinsic);
        } else {
          this.opacity.setState(0, component.Affinity.Intrinsic);
          this.didFade();
        }
      }
      this.glowState = "fading";
    }
    willFade() {}
    didFade() {
      this.remove();
    }
  }
  __decorate([ StyleConstraintAnimator({
    propertyNames: "left",
    type: math.Length,
    value: null,
    get constraintValue() {
      const node = this.owner.node;
      return node instanceof HTMLElement ? math.Length.px(node.offsetLeft) : null;
    },
    didTransition() {
      this.owner.didGlow();
    }
  }) ], ButtonGlow.prototype, "left", void 0);
  __decorate([ StyleAnimator({
    propertyNames: "opacity",
    type: Number,
    didTransition(opacity) {
      if (this.owner.glowState === "pulsing" && opacity === 0) {
        this.owner.didPulse();
      } else if (this.owner.glowState === "fading" && opacity === 0) {
        this.owner.didFade();
      }
    }
  }) ], ButtonGlow.prototype, "opacity", void 0);
  class ButtonMembrane extends HtmlView {
    constructor(node) {
      super(node);
      this.initMembrane(node);
    }
    initMembrane(node) {
      this.addClass("membrane");
    }
    glow(input) {
      if (input.detail instanceof ButtonGlow) {
        input.detail.fade(input.x, input.y);
        input.detail = void 0;
      }
      if (input.detail === void 0) {
        const delay = input.inputType === "mouse" ? 0 : 100;
        input.detail = this.prependChild(ButtonGlow);
        input.detail.glow(input.x, input.y, void 0, delay);
      }
    }
    init(init) {
      super.init(init);
    }
  }
  __decorate([ component.Property({
    type: Boolean,
    inherits: true,
    value: true
  }) ], ButtonMembrane.prototype, "glows", void 0);
  __decorate([ PositionGesture({
    self: true,
    didBeginPress(input, event) {
      if (this.owner.glows.value) {
        this.owner.glow(input);
      }
    },
    didMovePress(input, event) {
      if (input.isRunaway()) {
        this.cancelPress(input, event);
      } else if (!this.owner.clientBounds.contains(input.x, input.y)) {
        input.clearHoldTimer();
        this.beginHover(input, event);
        if (input.detail instanceof ButtonGlow) {
          input.detail.fade(input.x, input.y);
          input.detail = void 0;
        }
      }
    },
    didEndPress(input, event) {
      if (!this.owner.clientBounds.contains(input.x, input.y)) {
        this.endHover(input, event);
        if (input.detail instanceof ButtonGlow) {
          input.detail.fade(input.x, input.y);
          input.detail = void 0;
        }
      } else if (input.detail instanceof ButtonGlow) {
        input.detail.pulse(input.x, input.y);
      }
    },
    didCancelPress(input, event) {
      if (!this.owner.clientBounds.contains(input.x, input.y)) {
        this.endHover(input, event);
      }
      if (input.detail instanceof ButtonGlow) {
        input.detail.fade(input.x, input.y);
        input.detail = void 0;
      }
    }
  }) ], ButtonMembrane.prototype, "gesture", void 0);
  class FloatingButton extends ButtonMembrane {
    constructor(node) {
      super(node);
      this.buttonType = "regular";
      this.iconCount = 0;
      this.icon = null;
      this.initButton();
    }
    initButton() {
      this.addClass("floating-button");
      this.position.setState("relative", component.Affinity.Intrinsic);
      if (this.buttonType === "regular") {
        this.width.setState(56, component.Affinity.Intrinsic);
        this.height.setState(56, component.Affinity.Intrinsic);
      } else if (this.buttonType === "mini") {
        this.width.setState(40, component.Affinity.Intrinsic);
        this.height.setState(40, component.Affinity.Intrinsic);
      }
      this.borderTopLeftRadius.setState(math.Length.pct(50), component.Affinity.Intrinsic);
      this.borderTopRightRadius.setState(math.Length.pct(50), component.Affinity.Intrinsic);
      this.borderBottomLeftRadius.setState(math.Length.pct(50), component.Affinity.Intrinsic);
      this.borderBottomRightRadius.setState(math.Length.pct(50), component.Affinity.Intrinsic);
      this.overflowX.setState("hidden", component.Affinity.Intrinsic);
      this.overflowY.setState("hidden", component.Affinity.Intrinsic);
      this.cursor.setState("pointer", component.Affinity.Intrinsic);
    }
    setButtonType(buttonType) {
      if (this.buttonType !== buttonType) {
        this.buttonType = buttonType;
        if (buttonType === "regular") {
          this.width.setState(56, component.Affinity.Intrinsic);
          this.height.setState(56, component.Affinity.Intrinsic);
        } else if (buttonType === "mini") {
          this.width.setState(40, component.Affinity.Intrinsic);
          this.height.setState(40, component.Affinity.Intrinsic);
        }
      }
    }
    pushIcon(icon, timing) {
      if (timing === void 0 || timing === true) {
        timing = this.getLookOr(Look.timing, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      const oldIconCount = this.iconCount;
      const oldIconKey = "icon" + oldIconCount;
      const oldIconRef = this.getFastener(oldIconKey, ViewRef);
      const oldIconView = oldIconRef !== null ? oldIconRef.view : null;
      if (oldIconView !== null) {
        if (timing !== false) {
          oldIconView.opacity.setState(0, timing, component.Affinity.Intrinsic);
          oldIconView.transform.setState(math.Transform.rotate(math.Angle.deg(90)), timing, component.Affinity.Intrinsic);
        } else {
          oldIconView.remove();
        }
      }
      const newIconCount = oldIconCount + 1;
      const newIconKey = "icon" + newIconCount;
      const newIconRef = FloatingButton.IconRef.create(this);
      Object.defineProperty(newIconRef, "name", {
        value: newIconKey,
        enumerable: true,
        configurable: true
      });
      newIconRef.iconIndex = newIconCount;
      const newIconView = HtmlIconView.create();
      newIconView.position.setState("absolute", component.Affinity.Intrinsic);
      newIconView.left.setState(0, component.Affinity.Intrinsic);
      newIconView.top.setState(0, component.Affinity.Intrinsic);
      newIconView.width.setState(this.width.state, component.Affinity.Intrinsic);
      newIconView.height.setState(this.height.state, component.Affinity.Intrinsic);
      newIconView.opacity.setState(0, component.Affinity.Intrinsic);
      newIconView.opacity.setState(1, timing, component.Affinity.Intrinsic);
      newIconView.transform.setState(math.Transform.rotate(math.Angle.deg(-90)), component.Affinity.Intrinsic);
      newIconView.transform.setState(math.Transform.rotate(math.Angle.deg(0)), timing, component.Affinity.Intrinsic);
      newIconView.pointerEvents.setState("none", component.Affinity.Intrinsic);
      newIconView.iconWidth.setState(24, component.Affinity.Intrinsic);
      newIconView.iconHeight.setState(24, component.Affinity.Intrinsic);
      newIconView.iconColor.setAffinity(component.Affinity.Extrinsic);
      newIconView.graphics.setState(icon, component.Affinity.Intrinsic);
      newIconRef.setView(newIconView);
      this.setFastener(newIconKey, newIconRef);
      this.appendChild(newIconView, newIconKey);
      this.iconCount = newIconCount;
      this.icon = newIconRef;
    }
    popIcon(timing) {
      if (timing === void 0 || timing === true) {
        timing = this.getLookOr(Look.timing, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      const oldIconCount = this.iconCount;
      const oldIconKey = "icon" + oldIconCount;
      const oldIconRef = this.getFastener(oldIconKey, ViewRef);
      const oldIconView = oldIconRef !== null ? oldIconRef.view : null;
      if (oldIconView !== null) {
        if (timing !== false) {
          oldIconView.opacity.setState(0, timing, component.Affinity.Intrinsic);
          oldIconView.transform.setState(math.Transform.rotate(math.Angle.deg(-90)), timing, component.Affinity.Intrinsic);
        } else {
          oldIconView.remove();
        }
      }
      const newIconCount = oldIconCount - 1;
      const newIconKey = "icon" + newIconCount;
      const newIconRef = this.getFastener(newIconKey, ViewRef);
      const newIconView = newIconRef !== null ? newIconRef.view : null;
      if (newIconView !== null) {
        newIconView.opacity.setState(1, timing, component.Affinity.Intrinsic);
        newIconView.transform.setState(math.Transform.rotate(math.Angle.deg(0)), timing, component.Affinity.Intrinsic);
        this.appendChild(newIconView, newIconKey);
      }
      this.iconCount = newIconCount;
      this.icon = newIconRef;
    }
    onApplyTheme(theme, mood, timing) {
      super.onApplyTheme(theme, mood, timing);
      this.backgroundColor.setState(theme.getOr(Look.accentColor, mood, null), timing, component.Affinity.Intrinsic);
      let shadow = theme.getOr(Look.shadow, Mood.floating, null);
      if (shadow !== null) {
        const shadowColor = shadow.color;
        const phase = this.disclosure.getPhaseOr(1);
        shadow = shadow.withColor(shadowColor.alpha(shadowColor.alpha() * phase));
      }
      this.boxShadow.setState(shadow, timing, component.Affinity.Intrinsic);
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      let shadow = this.getLookOr(Look.shadow, Mood.floating, null);
      if (shadow !== null) {
        const shadowColor = shadow.color;
        const phase = this.disclosure.getPhaseOr(1);
        shadow = shadow.withColor(shadowColor.alpha(shadowColor.alpha() * phase));
      }
      this.boxShadow.setState(shadow, component.Affinity.Intrinsic);
    }
  }
  FloatingButton.IconRef = ViewRef.define("IconRef", {
    implements: true,
    type: HtmlIconView,
    observes: true,
    init() {
      this.iconIndex = 0;
    },
    viewDidApplyTheme(theme, mood, timing, iconView) {
      const iconColor = theme.getOr(Look.backgroundColor, mood, null);
      iconView.iconColor.setState(iconColor, timing);
    },
    viewDidAnimate(viewContext, iconView) {
      if (!iconView.opacity.tweening && this.iconIndex !== this.owner.iconCount) {
        iconView.remove();
        if (this.iconIndex > this.owner.iconCount) {
          this.owner.setFastener(this.key, null);
        }
      }
    }
  });
  __decorate([ PositionGesture({
    extends: true,
    didStartHovering() {
      this.owner.modifyMood(Feel.default, [ [ Feel.hovering, 1 ] ]);
      if (this.owner.backgroundColor.hasAffinity(component.Affinity.Intrinsic)) {
        const timing = this.owner.getLook(Look.timing);
        this.owner.backgroundColor.setState(this.owner.getLookOr(Look.accentColor, null), timing, component.Affinity.Intrinsic);
      }
    },
    didStopHovering() {
      this.owner.modifyMood(Feel.default, [ [ Feel.hovering, void 0 ] ]);
      if (this.owner.backgroundColor.hasAffinity(component.Affinity.Intrinsic)) {
        const timing = this.owner.getLook(Look.timing);
        this.owner.backgroundColor.setState(this.owner.getLookOr(Look.accentColor, null), timing, component.Affinity.Intrinsic);
      }
    },
    didMovePress(input, event) {}
  }) ], FloatingButton.prototype, "gesture", void 0);
  __decorate([ ThemeAnimator({
    type: Expansion,
    inherits: true
  }) ], FloatingButton.prototype, "disclosure", void 0);
  class ButtonItem extends HtmlView {
    constructor(node) {
      super(node);
      this.initButtonItem();
    }
    initButtonItem() {
      this.addClass("button-item");
      this.position.setState("relative", component.Affinity.Intrinsic);
      const button = this.createButton();
      if (button !== null) {
        this.setChild("button", button);
      }
    }
    createButton() {
      const button = FloatingButton.create();
      button.setButtonType("mini");
      return button;
    }
    get button() {
      const childView = this.getChild("button");
      return childView instanceof FloatingButton ? childView : null;
    }
    get icon() {
      const button = this.button;
      const buttonIcon = button !== null ? button.icon : null;
      return buttonIcon !== null ? buttonIcon.view : null;
    }
    get label() {
      const childView = this.getChild("label");
      return childView instanceof HtmlView ? childView : null;
    }
    onApplyTheme(theme, mood, timing) {
      super.onApplyTheme(theme, mood, timing);
      const label = this.label;
      if (label !== null && label.color.hasAffinity(component.Affinity.Intrinsic)) {
        label.color.setState(theme.getOr(Look.mutedColor, mood, null), timing, component.Affinity.Intrinsic);
      }
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      const phase = this.disclosure.getPhaseOr(1);
      const button = this.button;
      if (button !== null) {
        this.width.setState(button.width.state, component.Affinity.Intrinsic);
        this.height.setState(button.height.state, component.Affinity.Intrinsic);
      }
      const label = this.label;
      if (label !== null) {
        label.opacity.setState(phase, component.Affinity.Intrinsic);
      }
    }
    onInsertChild(childView, targetView) {
      super.onInsertChild(childView, targetView);
      const childKey = childView.key;
      if (childKey === "button" && childView instanceof FloatingButton) {
        this.onInsertButton(childView);
      } else if (childKey === "label" && childView instanceof HtmlView) {
        this.onInsertLabel(childView);
      }
    }
    onRemoveChild(childView) {
      const childKey = childView.key;
      if (childKey === "button" && childView instanceof FloatingButton) {
        this.onRemoveButton(childView);
      } else if (childKey === "label" && childView instanceof HtmlView) {
        this.onRemoveLabel(childView);
      }
      super.onRemoveChild(childView);
    }
    onInsertButton(button) {}
    onRemoveButton(button) {}
    onInsertLabel(label) {
      label.display.setState("block", component.Affinity.Intrinsic);
      label.position.setState("absolute", component.Affinity.Intrinsic);
      label.top.setState(0, component.Affinity.Intrinsic);
      label.right.setState(40 + 16, component.Affinity.Intrinsic);
      label.bottom.setState(0, component.Affinity.Intrinsic);
      label.fontSize.setState(17, component.Affinity.Intrinsic);
      label.fontWeight.setState("500", component.Affinity.Intrinsic);
      label.lineHeight.setState(40, component.Affinity.Intrinsic);
      label.whiteSpace.setState("nowrap", component.Affinity.Intrinsic);
      label.opacity.setState(this.disclosure.getPhaseOr(0), component.Affinity.Intrinsic);
    }
    onRemoveLabel(label) {}
  }
  __decorate([ ThemeAnimator({
    type: Expansion,
    inherits: true
  }) ], ButtonItem.prototype, "disclosure", void 0);
  class ButtonStack extends HtmlView {
    constructor(node) {
      super(node);
      this.stackHeight = 0;
      this.onClick = this.onClick.bind(this);
      this.onContextMenu = this.onContextMenu.bind(this);
      this.initButtonStack();
      this.initButton();
    }
    initButtonStack() {
      this.addClass("button-stack");
      this.display.setState("block", component.Affinity.Intrinsic);
      this.position.setState("relative", component.Affinity.Intrinsic);
      this.width.setState(56, component.Affinity.Intrinsic);
      this.height.setState(56, component.Affinity.Intrinsic);
      this.opacity.setState(1, component.Affinity.Intrinsic);
      this.cursor.setState("pointer", component.Affinity.Intrinsic);
    }
    initButton() {
      const button = this.createButton();
      if (button !== null) {
        this.appendChild(button, "button");
      }
    }
    createButton() {
      return FloatingButton.create();
    }
    get modalView() {
      return null;
    }
    get modalState() {
      return this.disclosure.modalState;
    }
    get modality() {
      return this.disclosure.phase;
    }
    showModal(options, timing) {
      this.disclosure.expand(timing);
    }
    hideModal(timing) {
      this.disclosure.collapse(timing);
    }
    get button() {
      const childView = this.getChild("button");
      return childView instanceof HtmlView ? childView : null;
    }
    get closeIcon() {
      return ButtonStack.closeIcon;
    }
    get items() {
      const childNodes = this.node.childNodes;
      const children = [];
      for (let i = 0, n = childNodes.length; i < n; i += 1) {
        const childView = childNodes[i].view;
        if (childView instanceof ButtonItem) {
          children.push(childView);
        }
      }
      return children;
    }
    insertItem(item, index, key) {
      if (index === void 0) {
        index = this.node.childNodes.length - 1;
      }
      this.insertChild(item.node, this.node.childNodes[1 + index] || null, key);
    }
    removeItems() {
      const childNodes = this.node.childNodes;
      for (let i = childNodes.length - 1; i >= 0; i -= 1) {
        const childView = childNodes[i].view;
        if (childView instanceof ButtonItem) {
          this.removeChild(childView);
        }
      }
    }
    onMount() {
      super.onMount();
      this.on("click", this.onClick);
      this.on("contextmenu", this.onContextMenu);
    }
    onUnmount() {
      this.off("click", this.onClick);
      this.off("contextmenu", this.onContextMenu);
      super.onUnmount();
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.layoutStack();
      const modalService = this.modalProvider.service;
      if (modalService !== void 0 && modalService !== null) {
        modalService.updateModality();
      }
    }
    layoutStack() {
      const phase = this.disclosure.getPhase();
      const childNodes = this.node.childNodes;
      const childCount = childNodes.length;
      const button = this.button;
      let zIndex = childCount - 1;
      let itemIndex = 0;
      let stackHeight = 0;
      let y;
      if (button !== null) {
        button.zIndex.setState(childCount, component.Affinity.Intrinsic);
        const buttonHeight = button !== null ? button.height.value : void 0;
        y = buttonHeight instanceof math.Length ? buttonHeight.pxValue() : button.node.offsetHeight;
      } else {
        y = 0;
      }
      const buttonSpacing = this.buttonSpacing.value;
      const itemSpacing = this.itemSpacing.value;
      for (let i = 0; i < childCount; i += 1) {
        const childView = childNodes[i].view;
        if (childView instanceof ButtonItem) {
          if (itemIndex === 0) {
            stackHeight += buttonSpacing;
            y += buttonSpacing;
          } else {
            stackHeight += itemSpacing;
            y += itemSpacing;
          }
          const itemHeight = childView.height.value;
          const dy = itemHeight instanceof math.Length ? itemHeight.pxValue() : childView.node.offsetHeight;
          childView.display.setState(phase === 0 ? "none" : "flex", component.Affinity.Intrinsic);
          childView.bottom.setState(phase * y, component.Affinity.Intrinsic);
          childView.zIndex.setState(zIndex, component.Affinity.Intrinsic);
          y += dy;
          stackHeight += dy;
          itemIndex += 1;
          zIndex -= 1;
        }
      }
      this.stackHeight = stackHeight;
    }
    onInsertChild(childView, targetView) {
      super.onInsertChild(childView, targetView);
      const childKey = childView.key;
      if (childKey === "button" && childView instanceof HtmlView) {
        this.onInsertButton(childView);
      } else if (childView instanceof ButtonItem) {
        this.onInsertItem(childView);
      }
    }
    onRemoveChild(childView) {
      const childKey = childView.key;
      if (childKey === "button" && childView instanceof HtmlView) {
        this.onRemoveButton(childView);
      } else if (childView instanceof ButtonItem) {
        this.onRemoveItem(childView);
      }
      super.onRemoveChild(childView);
    }
    onInsertButton(button) {
      this.gesture.setView(button);
      if (button instanceof FloatingButton) {
        button.disclosure.setState(Expansion.expanded(), component.Affinity.Intrinsic);
        if (this.disclosure.expanded || this.disclosure.expanding) {
          button.pushIcon(this.closeIcon);
        }
      }
      button.zIndex.setState(0, component.Affinity.Intrinsic);
    }
    onRemoveButton(button) {
      this.gesture.setView(null);
    }
    onInsertItem(item) {
      item.position.setState("absolute", component.Affinity.Intrinsic);
      item.right.setState(8, component.Affinity.Intrinsic);
      item.bottom.setState(8, component.Affinity.Intrinsic);
      item.left.setState(8, component.Affinity.Intrinsic);
      item.zIndex.setState(0, component.Affinity.Intrinsic);
    }
    onRemoveItem(item) {}
    willExpand() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.buttonStackWillExpand !== void 0) {
          observer.buttonStackWillExpand(this);
        }
      }
    }
    onExpand() {
      const button = this.button;
      if (button instanceof FloatingButton) {
        const timing = this.disclosure.timing;
        button.pushIcon(this.closeIcon, timing !== null ? timing : void 0);
      }
      this.modalProvider.presentModal(this);
    }
    didExpand() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.buttonStackDidExpand !== void 0) {
          observer.buttonStackDidExpand(this);
        }
      }
    }
    willCollapse() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.buttonStackWillCollapse !== void 0) {
          observer.buttonStackWillCollapse(this);
        }
      }
    }
    onCollapse() {
      this.modalProvider.dismissModal(this);
      const button = this.button;
      if (button instanceof FloatingButton && button.iconCount > 1) {
        const timing = this.disclosure.timing;
        button.popIcon(timing !== null ? timing : void 0);
      }
    }
    didCollapse() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.buttonStackDidCollapse !== void 0) {
          observer.buttonStackDidCollapse(this);
        }
      }
    }
    show(timing) {
      if (this.opacity.state !== 1) {
        if (timing === void 0 || timing === true) {
          timing = this.getLookOr(Look.timing, false);
        } else {
          timing = util.Timing.fromAny(timing);
        }
        this.willShowStack();
        if (timing !== false) {
          this.opacity.setState(1, timing, component.Affinity.Intrinsic);
        } else {
          this.opacity.setState(1, component.Affinity.Intrinsic);
          this.didShowStack();
        }
      }
    }
    willShowStack() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.buttonStackWillShow !== void 0) {
          observer.buttonStackWillShow(this);
        }
      }
      this.display("block");
    }
    didShowStack() {
      this.requireUpdate(View.NeedsLayout);
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.buttonStackDidShow !== void 0) {
          observer.buttonStackDidShow(this);
        }
      }
    }
    hide(timing) {
      if (this.opacity.state !== 0) {
        if (timing === void 0 || timing === true) {
          timing = this.getLookOr(Look.timing, false);
        } else {
          timing = util.Timing.fromAny(timing);
        }
        this.willHideStack();
        if (timing !== false) {
          this.opacity.setState(0, timing, component.Affinity.Intrinsic);
        } else {
          this.opacity.setState(0, component.Affinity.Intrinsic);
          this.didHideStack();
        }
      }
    }
    willHideStack() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.buttonStackWillHide !== void 0) {
          observer.buttonStackWillHide(this);
        }
      }
    }
    didHideStack() {
      this.display("none");
      this.requireUpdate(View.NeedsLayout);
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.buttonStackDidHide !== void 0) {
          observer.buttonStackDidHide(this);
        }
      }
    }
    onClick(event) {
      var _a;
      if (event.target === ((_a = this.button) === null || _a === void 0 ? void 0 : _a.node)) {
        event.stopPropagation();
      }
    }
    onContextMenu(event) {
      event.preventDefault();
    }
    static get closeIcon() {
      return VectorIcon.create(24, 24, "M19,6.4L17.6,5L12,10.6L6.4,5L5,6.4L10.6,12L5,17.6L6.4,19L12,13.4L17.6,19L19,17.6L13.4,12Z");
    }
  }
  __decorate([ PositionGesture({
    didMovePress(input, event) {
      if (!input.defaultPrevented && !this.owner.disclosure.expanded) {
        const stackHeight = this.owner.stackHeight;
        const phase = Math.min(Math.max(0, -(input.y - input.y0) / (.5 * stackHeight)), 1);
        this.owner.disclosure.setPhase(phase);
        if (phase > .1) {
          input.clearHoldTimer();
          if (!this.owner.disclosure.expanding) {
            this.owner.disclosure.setState(this.owner.disclosure.value.asExpanding());
          }
        }
      }
    },
    didEndPress(input, event) {
      if (!input.defaultPrevented) {
        const phase = this.owner.disclosure.getPhase();
        if (input.t - input.t0 < input.holdDelay) {
          if (phase < .1 || this.owner.disclosure.expanded) {
            this.owner.disclosure.collapse();
          } else {
            this.owner.disclosure.expand();
          }
        } else {
          if (phase < .5) {
            this.owner.disclosure.collapse();
          } else if (phase >= .5) {
            this.owner.disclosure.expand();
          }
        }
      }
    },
    didCancelPress(input, event) {
      if (input.buttons === 2) {
        this.owner.disclosure.toggle();
      } else {
        const phase = this.owner.disclosure.getPhase();
        if (phase < .1 || this.owner.disclosure.expanded) {
          this.owner.disclosure.collapse();
        } else {
          this.owner.disclosure.expand();
        }
      }
    },
    didLongPress(input) {
      input.preventDefault();
      this.owner.disclosure.toggle();
    }
  }) ], ButtonStack.prototype, "gesture", void 0);
  __decorate([ ThemeAnimator({
    type: Expansion,
    value: Expansion.collapsed(),
    updateFlags: View.NeedsLayout,
    willExpand() {
      this.owner.willExpand();
      this.owner.onExpand();
    },
    didExpand() {
      this.owner.didExpand();
    },
    willCollapse() {
      this.owner.willCollapse();
      this.owner.onCollapse();
    },
    didCollapse() {
      this.owner.didCollapse();
    }
  }) ], ButtonStack.prototype, "disclosure", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    value: 28,
    updateFlags: View.NeedsLayout
  }) ], ButtonStack.prototype, "buttonSpacing", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    value: 20,
    updateFlags: View.NeedsLayout
  }) ], ButtonStack.prototype, "itemSpacing", void 0);
  __decorate([ StyleAnimator({
    propertyNames: "opacity",
    type: Number,
    didTransition(opacity) {
      if (opacity === 1) {
        this.owner.didShowStack();
      } else if (opacity === 0) {
        this.owner.didHideStack();
      }
    }
  }) ], ButtonStack.prototype, "opacity", void 0);
  __decorate([ util.Lazy ], ButtonStack, "closeIcon", null);
  class IconButton extends ButtonMembrane {
    constructor(node) {
      super(node);
      this.iconCount = 0;
      this.icon = null;
      this.onClick = this.onClick.bind(this);
      this.initButton();
      this.initTheme();
    }
    initButton() {
      this.addClass("icon-button");
      this.position.setState("relative", component.Affinity.Intrinsic);
      this.width.setState(44, component.Affinity.Intrinsic);
      this.height.setState(44, component.Affinity.Intrinsic);
      this.display.setState("flex", component.Affinity.Intrinsic);
      this.justifyContent.setState("center", component.Affinity.Intrinsic);
      this.alignItems.setState("center", component.Affinity.Intrinsic);
      this.borderTopLeftRadius.setState(4, component.Affinity.Intrinsic);
      this.borderTopRightRadius.setState(4, component.Affinity.Intrinsic);
      this.borderBottomLeftRadius.setState(4, component.Affinity.Intrinsic);
      this.borderBottomRightRadius.setState(4, component.Affinity.Intrinsic);
      this.overflowX.setState("hidden", component.Affinity.Intrinsic);
      this.overflowY.setState("hidden", component.Affinity.Intrinsic);
      this.cursor.setState("pointer", component.Affinity.Intrinsic);
    }
    initTheme() {
      this.modifyTheme(Feel.default, [ [ Feel.translucent, 1 ] ]);
    }
    pushIcon(icon, timing) {
      const oldIconCount = this.iconCount;
      const newIconCount = oldIconCount + 1;
      this.iconCount = newIconCount;
      if (timing === void 0 && oldIconCount === 0) {
        timing = false;
      } else if (timing === void 0 || timing === true) {
        timing = this.getLookOr(Look.timing, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      const oldIconKey = "icon" + oldIconCount;
      const oldIconRef = this.getFastener(oldIconKey, ViewRef);
      const oldIconView = oldIconRef !== null ? oldIconRef.view : null;
      if (oldIconView !== null) {
        if (timing !== false) {
          oldIconView.opacity.setState(0, timing, component.Affinity.Intrinsic);
          oldIconView.cssTransform.setState(math.Transform.rotate(math.Angle.deg(90)), timing, component.Affinity.Intrinsic);
        } else {
          oldIconView.remove();
        }
      }
      const newIconKey = "icon" + newIconCount;
      const newIconRef = IconButton.IconRef.create(this);
      Object.defineProperty(newIconRef, "name", {
        value: newIconKey,
        enumerable: true,
        configurable: true
      });
      newIconRef.iconIndex = newIconCount;
      this.icon = newIconRef;
      const newIconView = SvgIconView.create();
      newIconView.setStyle("position", "absolute");
      newIconView.setStyle("left", "0");
      newIconView.setStyle("top", "0");
      newIconView.opacity.setState(0, component.Affinity.Intrinsic);
      newIconView.opacity.setState(1, timing, component.Affinity.Intrinsic);
      newIconView.cssTransform.setState(math.Transform.rotate(math.Angle.deg(-90)), component.Affinity.Intrinsic);
      newIconView.cssTransform.setState(math.Transform.rotate(math.Angle.deg(0)), timing, component.Affinity.Intrinsic);
      newIconView.pointerEvents.setState("none", component.Affinity.Intrinsic);
      newIconView.xAlign.setInherits(true);
      newIconView.yAlign.setInherits(true);
      newIconView.iconWidth.setInherits(true);
      newIconView.iconHeight.setInherits(true);
      newIconView.iconColor.setInherits(true);
      newIconView.graphics.setState(icon, component.Affinity.Intrinsic);
      newIconRef.setView(newIconView);
      this.setFastener(newIconKey, newIconRef);
      this.appendChild(newIconView, newIconKey);
    }
    popIcon(timing) {
      const oldIconCount = this.iconCount;
      const newIconCount = oldIconCount - 1;
      this.iconCount = newIconCount;
      if (timing === void 0 || timing === true) {
        timing = this.getLookOr(Look.timing, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      const oldIconKey = "icon" + oldIconCount;
      const oldIconRef = this.getFastener(oldIconKey, ViewRef);
      const oldIconView = oldIconRef !== null ? oldIconRef.view : null;
      if (oldIconView !== null) {
        if (timing !== false) {
          oldIconView.opacity.setState(0, timing, component.Affinity.Intrinsic);
          oldIconView.cssTransform.setState(math.Transform.rotate(math.Angle.deg(-90)), timing, component.Affinity.Intrinsic);
        } else {
          oldIconView.remove();
          this.setFastener(oldIconKey, null);
        }
      }
      const newIconKey = "icon" + newIconCount;
      const newIconRef = this.getFastener(newIconKey, ViewRef);
      this.icon = newIconRef;
      const newIconView = newIconRef !== null ? newIconRef.view : null;
      if (newIconView !== null) {
        newIconView.opacity.setState(1, timing, component.Affinity.Intrinsic);
        newIconView.cssTransform.setState(math.Transform.rotate(math.Angle.deg(0)), timing, component.Affinity.Intrinsic);
        this.appendChild(newIconView, newIconKey);
      }
      return oldIconView;
    }
    onApplyTheme(theme, mood, timing) {
      super.onApplyTheme(theme, mood, timing);
      if (this.backgroundColor.hasAffinity(component.Affinity.Intrinsic)) {
        let backgroundColor = this.getLookOr(Look.backgroundColor, null);
        if (!this.gesture.hovering && backgroundColor instanceof Color) {
          backgroundColor = backgroundColor.alpha(0);
        }
        this.backgroundColor.setState(backgroundColor, timing, component.Affinity.Intrinsic);
      }
      if (!this.graphics.inherited) {
        const oldGraphics = this.graphics.value;
        if (oldGraphics instanceof Icon) {
          const newGraphics = oldGraphics.withTheme(theme, mood);
          this.graphics.setState(newGraphics, oldGraphics.isThemed() ? timing : false, component.Affinity.Reflexive);
        }
      }
    }
    onResize(viewContext) {
      super.onResize(viewContext);
      this.requireUpdate(View.NeedsLayout);
    }
    needsDisplay(displayFlags, viewContext) {
      if ((this.flags & View.NeedsLayout) === 0) {
        displayFlags &= ~View.NeedsLayout;
      }
      return displayFlags;
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.layoutIcon();
    }
    layoutIcon() {
      const fasteners = this.fasteners;
      if (fasteners !== null) {
        let viewWidth = this.width.value;
        viewWidth = viewWidth instanceof math.Length ? viewWidth.pxValue() : this.node.offsetWidth;
        let viewHeight = this.height.value;
        viewHeight = viewHeight instanceof math.Length ? viewHeight.pxValue() : this.node.offsetHeight;
        for (const fastenerName in fasteners) {
          const fastener = fasteners[fastenerName];
          if (fastener instanceof IconButton.IconRef) {
            const iconView = fastener.view;
            if (iconView !== null) {
              iconView.width.setState(viewWidth, component.Affinity.Intrinsic);
              iconView.height.setState(viewHeight, component.Affinity.Intrinsic);
              iconView.viewBox.setState("0 0 " + viewWidth + " " + viewHeight, component.Affinity.Intrinsic);
            }
          }
        }
      }
    }
    onMount() {
      super.onMount();
      this.on("click", this.onClick);
    }
    onUnmount() {
      this.off("click", this.onClick);
      super.onUnmount();
    }
    get hovers() {
      return true;
    }
    setHovers(hovers) {
      if (this.hovers !== hovers) {
        Object.defineProperty(this, "hovers", {
          value: hovers,
          configurable: true
        });
      }
    }
    onClick(event) {
      event.stopPropagation();
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.buttonDidPress !== void 0) {
          observer.buttonDidPress(this);
        }
      }
    }
    init(init) {
      super.init(init);
      IconView.init(this, init);
    }
  }
  IconButton.IconRef = ViewRef.define("IconRef", {
    implements: true,
    type: SvgIconView,
    observes: true,
    init() {
      this.iconIndex = 0;
    },
    viewDidAnimate(viewContext, iconView) {
      if (!iconView.opacity.tweening && this.iconIndex !== this.owner.iconCount) {
        iconView.remove();
        if (this.iconIndex > this.owner.iconCount) {
          this.owner.setFastener(this.name, null);
        }
      }
    }
  });
  __decorate([ component.Animator({
    type: Number,
    value: .5,
    updateFlags: View.NeedsLayout
  }) ], IconButton.prototype, "xAlign", void 0);
  __decorate([ component.Animator({
    type: Number,
    value: .5,
    updateFlags: View.NeedsLayout
  }) ], IconButton.prototype, "yAlign", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.px(24),
    updateFlags: View.NeedsLayout
  }) ], IconButton.prototype, "iconWidth", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.px(24),
    updateFlags: View.NeedsLayout
  }) ], IconButton.prototype, "iconHeight", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    updateFlags: View.NeedsLayout,
    didSetValue(newIconColor, oldIconColor) {
      if (newIconColor !== null) {
        const oldGraphics = this.owner.graphics.value;
        if (oldGraphics instanceof FilledIcon) {
          const newGraphics = oldGraphics.withFillColor(newIconColor);
          this.owner.graphics.setState(newGraphics, component.Affinity.Reflexive);
        }
      }
    }
  }) ], IconButton.prototype, "iconColor", void 0);
  __decorate([ ThemeAnimator({
    extends: IconGraphicsAnimator,
    value: null,
    type: Object,
    updateFlags: View.NeedsLayout
  }) ], IconButton.prototype, "graphics", void 0);
  __decorate([ PositionGesture({
    extends: true,
    didStartHovering() {
      if (this.owner.hovers) {
        this.owner.modifyMood(Feel.default, [ [ Feel.hovering, 1 ] ]);
        const timing = this.owner.getLook(Look.timing);
        if (this.owner.backgroundColor.hasAffinity(component.Affinity.Intrinsic)) {
          this.owner.backgroundColor.setState(this.owner.getLookOr(Look.backgroundColor, null), timing, component.Affinity.Intrinsic);
        }
      }
    },
    didStopHovering() {
      this.owner.modifyMood(Feel.default, [ [ Feel.hovering, void 0 ] ]);
      const timing = this.owner.getLook(Look.timing);
      if (this.owner.backgroundColor.hasAffinity(component.Affinity.Intrinsic)) {
        let backgroundColor = this.owner.getLookOr(Look.backgroundColor, null);
        if (backgroundColor !== null) {
          backgroundColor = backgroundColor.alpha(0);
        }
        this.owner.backgroundColor.setState(backgroundColor, timing, component.Affinity.Intrinsic);
      }
    }
  }) ], IconButton.prototype, "gesture", void 0);
  class DisclosureButton extends HtmlView {
    constructor(node) {
      super(node);
      this.initDisclosureButton();
    }
    initDisclosureButton() {
      this.addClass("disclosure-button");
      this.display.setState("flex", component.Affinity.Intrinsic);
      this.justifyContent.setState("center", component.Affinity.Intrinsic);
      this.alignItems.setState("center", component.Affinity.Intrinsic);
      this.flexGrow.setState(1, component.Affinity.Intrinsic);
      this.flexShrink.setState(0, component.Affinity.Intrinsic);
      this.cursor.setState("pointer", component.Affinity.Intrinsic);
      const icon = this.appendChild(SvgView, "icon");
      icon.width.setState(24, component.Affinity.Intrinsic);
      icon.height.setState(24, component.Affinity.Intrinsic);
      icon.viewBox.setState("0 0 24 24", component.Affinity.Intrinsic);
      const arrow = icon.appendChild("polygon", "arrow");
      arrow.points.setState("0 4 -6 -2 -4.59 -3.41 0 1.17 4.59 -3.41 6 -2", component.Affinity.Intrinsic);
      arrow.transform.setState(math.Transform.translate(12, 12).rotate(math.Angle.deg(0)), component.Affinity.Intrinsic);
    }
    get icon() {
      return this.getChild("icon");
    }
    get arrow() {
      const icon = this.icon;
      return icon.getChild("arrow");
    }
    needsDisplay(displayFlags, viewContext) {
      if ((this.flags & View.NeedsLayout) === 0) {
        displayFlags &= ~View.NeedsLayout;
      }
      return displayFlags;
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      const phase = this.disclosure.getPhase();
      const collapsedColor = this.collapsedColor.value;
      const expandedColor = this.expandedColor.value;
      if (collapsedColor !== null && expandedColor !== null && this.arrow.fill.hasAffinity(component.Affinity.Intrinsic)) {
        const colorInterpolator = collapsedColor.interpolateTo(expandedColor);
        this.arrow.fill.setState(colorInterpolator(phase), component.Affinity.Intrinsic);
      }
      const transform = math.Transform.translate(12, 12).rotate(math.Angle.deg(-180 * phase));
      this.arrow.transform.setState(transform, component.Affinity.Intrinsic);
    }
  }
  __decorate([ ThemeAnimator({
    type: Expansion,
    inherits: true,
    updateFlags: View.NeedsLayout
  }) ], DisclosureButton.prototype, "disclosure", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    inherits: true,
    look: Look.color,
    updateFlags: View.NeedsLayout
  }) ], DisclosureButton.prototype, "collapsedColor", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    inherits: true,
    look: Look.accentColor,
    updateFlags: View.NeedsLayout
  }) ], DisclosureButton.prototype, "expandedColor", void 0);
  class TokenView extends HtmlView {
    constructor(node) {
      super(node);
      this.tokenState = "expanded";
      this.onClickHead = this.onClickHead.bind(this);
      this.onClickBody = this.onClickBody.bind(this);
      this.onClickFoot = this.onClickFoot.bind(this);
      this.initToken();
    }
    initToken() {
      this.addClass("token");
      this.position.setState("relative", component.Affinity.Intrinsic);
      this.height.setState(32, component.Affinity.Intrinsic);
      this.boxSizing.setState("content-box", component.Affinity.Intrinsic);
      this.shape.insertView();
    }
    initShape(shapeView) {
      shapeView.addClass("shape");
      shapeView.setStyle("position", "absolute");
      shapeView.setStyle("top", "0");
      shapeView.setStyle("left", "0");
      this.head.insertView(shapeView);
      this.headIcon.attachView();
      this.body.insertView(shapeView);
      this.foot.insertView(shapeView);
      this.footIcon.attachView();
    }
    initHead(headView) {
      headView.addClass("head");
      headView.fillRule.setState("evenodd", component.Affinity.Intrinsic);
      headView.pointerEvents.setState("bounding-box", component.Affinity.Intrinsic);
      headView.cursor.setState("pointer", component.Affinity.Intrinsic);
    }
    initHeadIcon(headIconView) {
      headIconView.addClass("head-icon");
      headIconView.pointerEvents.setState("none", component.Affinity.Intrinsic);
    }
    initBody(bodyView) {
      bodyView.addClass("body");
      bodyView.pointerEvents.setState("fill", component.Affinity.Intrinsic);
      bodyView.cursor.setState("pointer", component.Affinity.Intrinsic);
    }
    initFoot(footView) {
      footView.addClass("foot");
      footView.fillRule.setState("evenodd", component.Affinity.Intrinsic);
      footView.pointerEvents.setState("bounding-box", component.Affinity.Intrinsic);
      footView.cursor.setState("pointer", component.Affinity.Intrinsic);
    }
    initFootIcon(footIconView) {
      footIconView.addClass("foot-icon");
      footIconView.pointerEvents.setState("none", component.Affinity.Intrinsic);
    }
    initLabelContainer(labelContainer) {
      labelContainer.addClass("label");
      labelContainer.display.setState("block", component.Affinity.Intrinsic);
      labelContainer.position.setState("absolute", component.Affinity.Intrinsic);
      labelContainer.top.setState(0, component.Affinity.Intrinsic);
      labelContainer.left.setState(0, component.Affinity.Intrinsic);
      labelContainer.overflowX.setState("hidden", component.Affinity.Intrinsic);
      labelContainer.overflowY.setState("hidden", component.Affinity.Intrinsic);
      labelContainer.pointerEvents.setState("none", component.Affinity.Intrinsic);
    }
    initLabel(labelView) {
      labelView.position.setState("absolute", component.Affinity.Intrinsic);
      labelView.top.setState(0, component.Affinity.Intrinsic);
      labelView.bottom.setState(0, component.Affinity.Intrinsic);
      labelView.left.setState(0, component.Affinity.Intrinsic);
    }
    get expanded() {
      return this.tokenState === "expanded" || this.tokenState === "expanding";
    }
    get collapsed() {
      return this.tokenState === "collapsed" || this.tokenState === "collapsing";
    }
    get fillLook() {
      return Look.accentColor;
    }
    needsProcess(processFlags, viewContext) {
      if ((processFlags & View.NeedsLayout) !== 0) {
        processFlags |= View.NeedsAnimate;
      }
      return processFlags;
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.layoutToken();
    }
    layoutToken() {
      const gap = 2;
      const paddingTop = this.paddingTop.getStateOr(math.Length.zero()).pxValue();
      const paddingRight = this.paddingRight.getStateOr(math.Length.zero()).pxValue();
      const paddingBottom = this.paddingBottom.getStateOr(math.Length.zero()).pxValue();
      const paddingLeft = this.paddingLeft.getStateOr(math.Length.zero()).pxValue();
      const boxHeight = this.node.clientHeight;
      const tokenHeight = boxHeight - paddingTop - paddingBottom;
      const radius = tokenHeight / 2;
      const pad = Math.sqrt(gap * gap + 2 * radius * gap);
      const padAngle = Math.asin(pad / (radius + gap));
      const labelPaddingLeft = radius / 2;
      const labelPaddingRight = radius;
      const accessoryPaddingRight = radius / 2;
      const expandedPhase = this.expandedPhase.value;
      const icon = this.icon.value;
      const accessoryIcon = this.accessory.value;
      let labelWidth = 0;
      let bodyWidth = 0;
      const labelView = this.label.view;
      if (labelView !== null) {
        labelWidth = labelView.node.clientWidth;
        bodyWidth += labelPaddingLeft + labelWidth + labelPaddingRight;
      }
      let accessoryWidth = 0;
      let footWidth = 0;
      if (accessoryIcon !== null) {
        accessoryWidth = 2 * radius;
        footWidth += accessoryWidth + accessoryPaddingRight;
      }
      let tokenWidth = tokenHeight;
      if (expandedPhase !== 0 && bodyWidth !== 0) {
        tokenWidth += gap + expandedPhase * bodyWidth;
      }
      const bodyRight = tokenWidth;
      if (expandedPhase !== 0 && footWidth !== 0) {
        tokenWidth += gap + expandedPhase * footWidth;
      }
      const width = tokenWidth + paddingLeft + paddingRight;
      const height = boxHeight;
      this.width.setState(tokenWidth, component.Affinity.Intrinsic);
      const labelContainer = this.labelContainer.view;
      if (labelContainer !== null) {
        labelContainer.display.setState(expandedPhase !== 0 ? "block" : "none", component.Affinity.Intrinsic);
        labelContainer.left.setState(paddingLeft + tokenHeight + gap + labelPaddingLeft, component.Affinity.Intrinsic);
        labelContainer.top.setState(paddingTop, component.Affinity.Intrinsic);
        labelContainer.width.setState(expandedPhase * labelWidth, component.Affinity.Intrinsic);
        labelContainer.height.setState(tokenHeight, component.Affinity.Intrinsic);
      }
      const shapeView = this.shape.view;
      if (shapeView !== null) {
        shapeView.width.setState(width, component.Affinity.Intrinsic);
        shapeView.height.setState(height, component.Affinity.Intrinsic);
        shapeView.viewBox.setState("0 0 " + width + " " + height, component.Affinity.Intrinsic);
      }
      const headView = this.head.view;
      if (headView !== null) {
        const context = new PathContext;
        context.setPrecision(3);
        context.arc(paddingLeft + radius, paddingTop + radius, radius, -(Math.PI / 2), 3 * (Math.PI / 2));
        context.closePath();
        if (icon !== null && !this.icon.embossed) {
          const renderer = new PathRenderer(context);
          const frame = new math.R2Box(paddingLeft, paddingTop, paddingLeft + tokenHeight, paddingTop + tokenHeight);
          icon.render(renderer, frame);
          this.headIcon.removeView();
        }
        headView.d.setState(context.toString(), component.Affinity.Intrinsic);
      }
      const headIconView = this.headIcon.view;
      if (headIconView !== null) {
        if (icon !== null && this.icon.embossed) {
          const context = new PathContext;
          context.setPrecision(3);
          const renderer = new PathRenderer(context);
          const frame = new math.R2Box(paddingLeft, paddingTop, paddingLeft + tokenHeight, paddingTop + tokenHeight);
          icon.render(renderer, frame);
          headIconView.d.setState(context.toString(), component.Affinity.Intrinsic);
          this.headIcon.insertView();
        } else {
          this.headIcon.removeView();
        }
      }
      const bodyView = this.body.view;
      if (bodyView !== null) {
        const context = new PathContext;
        context.setPrecision(3);
        if (expandedPhase !== 0) {
          const u = 1 - expandedPhase;
          context.arc(paddingLeft + radius, paddingTop + radius, radius + gap, -(Math.PI / 2) + padAngle, Math.PI / 2 - padAngle);
          context.arc(paddingLeft + bodyRight - radius - u * gap, paddingTop + radius, radius + u * gap, Math.PI / 2 - u * padAngle, -(Math.PI / 2) + u * padAngle, true);
          context.closePath();
        }
        bodyView.d.setState(context.toString(), component.Affinity.Intrinsic);
      }
      const footView = this.foot.view;
      if (footView !== null && accessoryIcon !== null) {
        const context = new PathContext;
        context.setPrecision(3);
        if (expandedPhase !== 0) {
          const u = 1 - expandedPhase;
          context.arc(paddingLeft + bodyRight - radius, paddingTop + radius, radius + gap, -(Math.PI / 2) + padAngle, Math.PI / 2 - padAngle);
          context.arc(paddingLeft + tokenWidth - radius - u * gap, paddingTop + radius, radius + u * gap, Math.PI / 2 - u * padAngle, -(Math.PI / 2) + u * padAngle, true);
          context.closePath();
          if (accessoryIcon !== null && !this.accessory.embossed) {
            const renderer = new PathRenderer(context);
            const frame = new math.R2Box(paddingLeft + bodyRight + gap, paddingTop, paddingLeft + bodyRight + gap + 2 * radius, paddingTop + 2 * radius);
            accessoryIcon.render(renderer, frame);
            this.headIcon.removeView();
          }
        }
        footView.d.setState(context.toString(), component.Affinity.Intrinsic);
      }
      const footIconView = this.footIcon.view;
      if (footIconView !== null) {
        if (accessoryIcon !== null && this.accessory.embossed) {
          const context = new PathContext;
          context.setPrecision(3);
          if (expandedPhase !== 0) {
            const renderer = new PathRenderer(context);
            const frame = new math.R2Box(paddingLeft + bodyRight + gap, paddingTop, paddingLeft + bodyRight + gap + tokenHeight, paddingTop + tokenHeight);
            accessoryIcon.render(renderer, frame);
          }
          footIconView.d.setState(context.toString(), component.Affinity.Intrinsic);
          this.footIcon.insertView();
        } else {
          this.footIcon.removeView();
        }
      }
    }
    expand(timing) {
      if (this.tokenState !== "expanded" || this.expandedPhase.value !== 1) {
        if (timing === void 0 || timing === true) {
          timing = this.getLookOr(Look.timing, false);
        } else {
          timing = util.Timing.fromAny(timing);
        }
        if (this.tokenState !== "expanding") {
          this.willExpand();
          this.onExpand();
        }
        if (timing !== false) {
          if (this.expandedPhase.value !== 1) {
            this.expandedPhase.setState(1, timing, component.Affinity.Intrinsic);
          } else {
            setTimeout(this.didExpand.bind(this));
          }
        } else {
          this.expandedPhase.setState(1, component.Affinity.Intrinsic);
          this.didExpand();
        }
      }
    }
    willExpand() {
      this.tokenState = "expanding";
      const labelContainer = this.labelContainer.view;
      if (labelContainer !== null) {
        labelContainer.display.setState("block", component.Affinity.Intrinsic);
      }
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.tokenWillExpand !== void 0) {
          observer.tokenWillExpand(this);
        }
      }
    }
    onExpand() {}
    didExpand() {
      this.tokenState = "expanded";
      this.requireUpdate(View.NeedsLayout);
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.tokenDidExpand !== void 0) {
          observer.tokenDidExpand(this);
        }
      }
    }
    collapse(timing) {
      if (this.tokenState !== "collapsed" || this.expandedPhase.value !== 0) {
        if (timing === void 0 || timing === true) {
          timing = this.getLookOr(Look.timing, false);
        } else {
          timing = util.Timing.fromAny(timing);
        }
        if (this.tokenState !== "collapsing") {
          this.willCollapse();
          this.onCollapse();
        }
        if (timing !== false) {
          if (this.expandedPhase.value !== 0) {
            this.expandedPhase.setState(0, timing, component.Affinity.Intrinsic);
          } else {
            setTimeout(this.didCollapse.bind(this));
          }
        } else {
          this.expandedPhase.setState(0, component.Affinity.Intrinsic);
          this.didCollapse();
        }
      }
    }
    willCollapse() {
      this.tokenState = "collapsing";
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.tokenWillCollapse !== void 0) {
          observer.tokenWillCollapse(this);
        }
      }
    }
    onCollapse() {
      const labelView = this.label.view;
      if (labelView !== null) {
        labelView.node.blur();
      }
    }
    didCollapse() {
      this.tokenState = "collapsed";
      this.requireUpdate(View.NeedsLayout);
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.tokenDidCollapse !== void 0) {
          observer.tokenDidCollapse(this);
        }
      }
    }
    toggle(timing) {
      const tokenState = this.tokenState;
      if (tokenState === "collapsed" || tokenState === "collapsing") {
        this.expand(timing);
      } else if (tokenState === "expanded" || tokenState === "expanding") {
        this.collapse(timing);
      }
    }
    onClickHead(event) {
      this.toggle();
      const labelView = this.label.view;
      if (labelView !== null && this.expanded) {
        labelView.node.focus();
      }
      this.didPressHead();
    }
    didPressHead() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.tokenDidPressHead !== void 0) {
          observer.tokenDidPressHead(this);
        }
      }
    }
    onClickBody(event) {
      this.didPressBody();
    }
    didPressBody() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.tokenDidPressBody !== void 0) {
          observer.tokenDidPressBody(this);
        }
      }
    }
    onClickFoot(event) {
      this.didPressFoot();
    }
    didPressFoot() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.tokenDidPressFoot !== void 0) {
          observer.tokenDidPressFoot(this);
        }
      }
    }
    init(init) {
      super.init(init);
    }
  }
  __decorate([ component.Animator({
    type: Number,
    value: 1,
    updateFlags: View.NeedsLayout,
    didTransition(expandedPhase) {
      const tokenState = this.owner.tokenState;
      if (tokenState === "expanding" && expandedPhase === 1) {
        this.owner.didExpand();
      } else if (tokenState === "collapsing" && expandedPhase === 0) {
        this.owner.didCollapse();
      }
    }
  }) ], TokenView.prototype, "expandedPhase", void 0);
  __decorate([ ViewRef({
    key: true,
    type: SvgView,
    binds: true,
    didAttachView(shapeView) {
      this.owner.initShape(shapeView);
    }
  }) ], TokenView.prototype, "shape", void 0);
  __decorate([ ViewRef({
    key: true,
    type: SvgView.forTag("path"),
    observes: true,
    didAttachView(headView) {
      this.owner.initHead(headView);
      this.owner.headGesture.setView(headView);
    },
    willDetachView(headView) {
      this.owner.headGesture.setView(null);
    },
    viewDidMount(headView) {
      headView.on("click", this.owner.onClickHead);
    },
    viewWillUnmount(headView) {
      headView.off("click", this.owner.onClickHead);
    },
    viewDidApplyTheme(theme, mood, timing, headView) {
      headView.fill.setState(theme.getOr(this.owner.fillLook, mood, null), timing, component.Affinity.Intrinsic);
      const headIconView = this.owner.headIcon.view;
      if (headIconView !== null && headIconView.fill.hasAffinity(component.Affinity.Intrinsic)) {
        const iconColor = theme.getOr(this.owner.fillLook, mood.updated(Feel.embossed, 1), null);
        headIconView.fill.setState(iconColor, timing, component.Affinity.Intrinsic);
      }
    }
  }) ], TokenView.prototype, "head", void 0);
  __decorate([ PositionGesture({
    didStartHovering() {
      const headView = this.view;
      headView.modifyMood(Feel.default, [ [ Feel.hovering, 1 ] ]);
      const timing = headView.getLook(Look.timing);
      headView.fill.setState(headView.getLookOr(this.owner.fillLook, null), timing, component.Affinity.Intrinsic);
      const headIconView = this.owner.headIcon.view;
      if (headIconView !== null && headIconView.fill.hasAffinity(component.Affinity.Intrinsic)) {
        const iconColor = headView.getLookOr(this.owner.fillLook, headView.mood.getValue().updated(Feel.embossed, 1), null);
        headIconView.fill.setState(iconColor, timing, component.Affinity.Intrinsic);
      }
    },
    didStopHovering() {
      const headView = this.view;
      headView.modifyMood(Feel.default, [ [ Feel.hovering, void 0 ] ]);
      const timing = headView.getLook(Look.timing);
      headView.fill.setState(headView.getLookOr(this.owner.fillLook, null), timing, component.Affinity.Intrinsic);
      const headIconView = this.owner.headIcon.view;
      if (headIconView !== null && headIconView.fill.hasAffinity(component.Affinity.Intrinsic)) {
        const iconColor = headView.getLookOr(this.owner.fillLook, headView.mood.getValue().updated(Feel.embossed, 1), null);
        headIconView.fill.setState(iconColor, timing, component.Affinity.Intrinsic);
      }
    },
    didBeginPress(input, event) {
      if (input.inputType !== "mouse") {
        this.beginHover(input, event);
      }
    },
    didMovePress(input, event) {
      if (input.isRunaway()) {
        this.cancelPress(input, event);
      }
    },
    didEndPress(input, event) {
      if (input.inputType !== "mouse" || !this.view.clientBounds.contains(input.x, input.y)) {
        this.endHover(input, event);
      }
    },
    didCancelPress(input, event) {
      if (input.inputType !== "mouse" || !this.view.clientBounds.contains(input.x, input.y)) {
        this.endHover(input, event);
      }
    }
  }) ], TokenView.prototype, "headGesture", void 0);
  __decorate([ ViewRef({
    key: true,
    type: SvgView.forTag("path"),
    didAttachView(headIconView) {
      this.owner.initHeadIcon(headIconView);
    },
    insertChild(parent, child, target, key) {
      const shapeView = this.owner.shape.view;
      if (shapeView !== null) {
        shapeView.insertChild(child, this.owner.body.view, key);
      }
    }
  }) ], TokenView.prototype, "headIcon", void 0);
  __decorate([ component.Property({
    implements: true,
    type: Object,
    value: null,
    updateFlags: View.NeedsLayout,
    embossed: true
  }) ], TokenView.prototype, "icon", void 0);
  __decorate([ ViewRef({
    key: true,
    type: SvgView.forTag("path"),
    observes: true,
    didAttachView(bodyView) {
      this.owner.initBody(bodyView);
      this.owner.bodyGesture.setView(bodyView);
    },
    willDetachView(bodyView) {
      this.owner.bodyGesture.setView(null);
    },
    viewDidMount(headView) {
      headView.on("click", this.owner.onClickBody);
    },
    viewWillUnmount(headView) {
      headView.off("click", this.owner.onClickBody);
    },
    viewDidApplyTheme(theme, mood, timing, bodyView) {
      bodyView.fill.setState(theme.getOr(this.owner.fillLook, mood, null), timing, component.Affinity.Intrinsic);
      const labelView = this.owner.label.view;
      if (labelView !== null && labelView.color.hasAffinity(component.Affinity.Intrinsic)) {
        labelView.color.setState(theme.getOr(Look.backgroundColor, mood, null), timing, component.Affinity.Intrinsic);
      }
    }
  }) ], TokenView.prototype, "body", void 0);
  __decorate([ PositionGesture({
    didStartHovering() {
      const bodyView = this.view;
      bodyView.modifyMood(Feel.default, [ [ Feel.hovering, 1 ] ]);
      const timing = bodyView.getLook(Look.timing);
      bodyView.fill.setState(bodyView.getLookOr(this.owner.fillLook, null), timing, component.Affinity.Intrinsic);
      const labelView = this.owner.label.view;
      if (labelView !== null && labelView.color.hasAffinity(component.Affinity.Intrinsic)) {
        labelView.color.setState(bodyView.getLookOr(Look.backgroundColor, null), timing, component.Affinity.Intrinsic);
      }
    },
    didStopHovering() {
      const bodyView = this.view;
      bodyView.modifyMood(Feel.default, [ [ Feel.hovering, void 0 ] ]);
      const timing = bodyView.getLook(Look.timing);
      bodyView.fill.setState(bodyView.getLookOr(this.owner.fillLook, null), timing, component.Affinity.Intrinsic);
      const labelView = this.owner.label.view;
      if (labelView !== null && labelView.color.hasAffinity(component.Affinity.Intrinsic)) {
        labelView.color.setState(bodyView.getLookOr(Look.backgroundColor, null), timing, component.Affinity.Intrinsic);
      }
    },
    didBeginPress(input, event) {
      if (input.inputType !== "mouse") {
        this.beginHover(input, event);
      }
    },
    didMovePress(input, event) {
      if (input.isRunaway()) {
        this.cancelPress(input, event);
      }
    },
    didEndPress(input, event) {
      if (input.inputType !== "mouse" || !this.view.clientBounds.contains(input.x, input.y)) {
        this.endHover(input, event);
      }
    },
    didCancelPress(input, event) {
      if (input.inputType !== "mouse" || !this.view.clientBounds.contains(input.x, input.y)) {
        this.endHover(input, event);
      }
    }
  }) ], TokenView.prototype, "bodyGesture", void 0);
  __decorate([ ViewRef({
    key: true,
    type: SvgView.forTag("path"),
    observes: true,
    didAttachView(footView) {
      this.owner.initFoot(footView);
      this.owner.footGesture.setView(footView);
    },
    willDetachView(footView) {
      this.owner.footGesture.setView(null);
    },
    viewDidMount(footView) {
      footView.on("click", this.owner.onClickFoot);
    },
    viewWillUnmount(footView) {
      footView.off("click", this.owner.onClickFoot);
    },
    viewDidApplyTheme(theme, mood, timing, footView) {
      footView.fill.setState(theme.getOr(this.owner.fillLook, mood, null), timing, component.Affinity.Intrinsic);
      const footIconView = this.owner.footIcon.view;
      if (footIconView !== null && footIconView.fill.hasAffinity(component.Affinity.Intrinsic)) {
        const iconColor = theme.getOr(this.owner.fillLook, mood.updated(Feel.embossed, 1), null);
        footIconView.fill.setState(iconColor, timing, component.Affinity.Intrinsic);
      }
    }
  }) ], TokenView.prototype, "foot", void 0);
  __decorate([ PositionGesture({
    didStartHovering() {
      const footView = this.view;
      footView.modifyMood(Feel.default, [ [ Feel.hovering, 1 ] ]);
      const timing = footView.getLook(Look.timing);
      footView.fill.setState(footView.getLookOr(this.owner.fillLook, null), timing, component.Affinity.Intrinsic);
      const footIconView = this.owner.footIcon.view;
      if (footIconView !== null && footIconView.fill.hasAffinity(component.Affinity.Intrinsic)) {
        const iconColor = footView.getLookOr(this.owner.fillLook, footView.mood.getValue().updated(Feel.embossed, 1), null);
        footIconView.fill.setState(iconColor, timing, component.Affinity.Intrinsic);
      }
    },
    didStopHovering() {
      const footView = this.view;
      footView.modifyMood(Feel.default, [ [ Feel.hovering, void 0 ] ]);
      const timing = footView.getLook(Look.timing);
      footView.fill.setState(footView.getLookOr(this.owner.fillLook, null), timing, component.Affinity.Intrinsic);
      const footIconView = this.owner.footIcon.view;
      if (footIconView !== null && footIconView.fill.hasAffinity(component.Affinity.Intrinsic)) {
        const iconColor = footView.getLookOr(this.owner.fillLook, footView.mood.getValue().updated(Feel.embossed, 1), null);
        footIconView.fill.setState(iconColor, timing, component.Affinity.Intrinsic);
      }
    },
    didBeginPress(input, event) {
      if (input.inputType !== "mouse") {
        this.beginHover(input, event);
      }
    },
    didMovePress(input, event) {
      if (input.isRunaway()) {
        this.cancelPress(input, event);
      }
    },
    didEndPress(input, event) {
      if (input.inputType !== "mouse" || !this.view.clientBounds.contains(input.x, input.y)) {
        this.endHover(input, event);
      }
    },
    didCancelPress(input, event) {
      if (input.inputType !== "mouse" || !this.view.clientBounds.contains(input.x, input.y)) {
        this.endHover(input, event);
      }
    }
  }) ], TokenView.prototype, "footGesture", void 0);
  __decorate([ ViewRef({
    key: true,
    type: SvgView.forTag("path"),
    didAttachView(footIconView) {
      this.owner.initFootIcon(footIconView);
    },
    insertChild(parent, child, target, key) {
      const shapeView = this.owner.shape.view;
      if (shapeView !== null) {
        shapeView.appendChild(child, key);
      }
    }
  }) ], TokenView.prototype, "footIcon", void 0);
  __decorate([ component.Property({
    implements: true,
    type: Object,
    value: null,
    updateFlags: View.NeedsLayout,
    init() {
      this.embossed = true;
    }
  }) ], TokenView.prototype, "accessory", void 0);
  __decorate([ ViewRef({
    key: true,
    type: HtmlView,
    binds: true,
    didAttachView(labelContainer) {
      this.owner.initLabelContainer(labelContainer);
    }
  }) ], TokenView.prototype, "labelContainer", void 0);
  __decorate([ ViewRef({
    key: true,
    type: HtmlView,
    didAttachView(labelView) {
      if (labelView.parent === null) {
        this.owner.labelContainer.insertView();
        const labelContainer = this.owner.labelContainer.view;
        if (labelContainer !== null) {
          labelContainer.appendChild(labelView);
        }
      }
      this.owner.initLabel(labelView);
    }
  }) ], TokenView.prototype, "label", void 0);
  class InputTokenView extends TokenView {
    constructor(node) {
      super(node);
      this.onInputUpdate = this.onInputUpdate.bind(this);
      this.onInputChange = this.onInputChange.bind(this);
      this.onInputKey = this.onInputKey.bind(this);
    }
    initToken() {
      this.stylesheet.insertView();
      super.initToken();
      this.addClass("input-token");
      this.label.attachView();
    }
    initStylesheet(styleView) {
      const sheet = styleView.sheet;
      if (sheet !== null) {
        const placeholder = InputTokenView.PlaceholderRule.create(sheet);
        sheet.setFastener("placeholder", placeholder);
      }
    }
    initLabel(labelView) {
      super.initLabel(labelView);
      labelView.paddingTop.setState(0, component.Affinity.Intrinsic);
      labelView.paddingRight.setState(0, component.Affinity.Intrinsic);
      labelView.paddingBottom.setState(0, component.Affinity.Intrinsic);
      labelView.paddingLeft.setState(0, component.Affinity.Intrinsic);
      labelView.borderTopStyle.setState("none", component.Affinity.Intrinsic);
      labelView.borderRightStyle.setState("none", component.Affinity.Intrinsic);
      labelView.borderBottomStyle.setState("none", component.Affinity.Intrinsic);
      labelView.borderLeftStyle.setState("none", component.Affinity.Intrinsic);
      labelView.boxSizing.setState("border-box", component.Affinity.Intrinsic);
      labelView.backgroundColor.setState(Color.transparent(), component.Affinity.Intrinsic);
      labelView.appearance.setState("none", component.Affinity.Intrinsic);
      labelView.outlineStyle.setState("none", component.Affinity.Intrinsic);
      labelView.pointerEvents.setState("auto", component.Affinity.Intrinsic);
    }
    get placeholderLook() {
      return Look.neutralColor;
    }
    onApplyTheme(theme, mood, timing) {
      super.onApplyTheme(theme, mood, timing);
      const styleView = this.stylesheet.view;
      if (styleView !== null) {
        const placeholder = styleView.getFastener("placeholder", StyleRule);
        if (placeholder !== null) {
          placeholder.color.setState(theme.getOr(this.placeholderLook, mood, null), timing, component.Affinity.Intrinsic);
        }
      }
      const labelView = this.label.view;
      if (labelView !== null) {
        labelView.font(theme.getOr(Look.font, mood, null), false, component.Affinity.Intrinsic);
      }
    }
    onInputUpdate(event) {
      const inputView = this.label.view;
      if (inputView !== null) {
        this.didUpdateInput(inputView);
      }
    }
    didUpdateInput(inputView) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.tokenDidUpdateInput !== void 0) {
          observer.tokenDidUpdateInput(inputView, this);
        }
      }
    }
    onInputChange(event) {
      const inputView = this.label.view;
      if (inputView !== null) {
        this.didChangeInput(inputView);
      }
    }
    didChangeInput(inputView) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.tokenDidChangeInput !== void 0) {
          observer.tokenDidChangeInput(inputView, this);
        }
      }
    }
    onInputKey(event) {
      const inputView = this.label.view;
      if (inputView !== null && event.key === "Enter") {
        this.didAcceptInput(inputView);
      }
    }
    didAcceptInput(inputView) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.tokenDidAcceptInput !== void 0) {
          observer.tokenDidAcceptInput(inputView, this);
        }
      }
    }
    init(init) {
      super.init(init);
    }
  }
  InputTokenView.PlaceholderRule = StyleRule.define("PlaceholderRule", {
    css: "::placeholder {}"
  });
  __decorate([ ViewRef({
    key: true,
    type: StyleView,
    binds: true,
    observes: true,
    viewDidMount(styleView) {
      this.owner.initStylesheet(styleView);
    }
  }) ], InputTokenView.prototype, "stylesheet", void 0);
  __decorate([ ViewRef({
    type: HtmlView.forTag("input"),
    observes: true,
    didAttachView(labelView) {
      if (labelView.parent === null) {
        this.owner.labelContainer.insertView();
        const labelContainer = this.owner.labelContainer.view;
        if (labelContainer !== null) {
          labelContainer.appendChild(labelView);
        }
      }
      this.owner.initLabel(labelView);
    },
    viewDidMount(labelView) {
      labelView.on("input", this.owner.onInputUpdate);
      labelView.on("change", this.owner.onInputChange);
      labelView.on("keydown", this.owner.onInputKey);
    },
    viewWillUnmount(labelView) {
      labelView.off("input", this.owner.onInputUpdate);
      labelView.off("change", this.owner.onInputChange);
      labelView.off("keydown", this.owner.onInputKey);
    }
  }) ], InputTokenView.prototype, "label", void 0);
  class ColLayout {
    constructor(key, grow, shrink, basis, optional, persistent, textColor, width, left, right, hidden) {
      this.key = key;
      this.grow = grow;
      this.shrink = shrink;
      this.basis = basis;
      this.optional = optional;
      this.persistent = persistent;
      this.textColor = textColor;
      this.width = width;
      this.left = left;
      this.right = right;
      this.hidden = hidden;
    }
    withFlex(grow, shrink, basis) {
      if (basis !== void 0) {
        basis = math.Length.fromAny(basis);
      } else {
        basis = this.basis;
      }
      return this.copy(this.key, grow, shrink, basis, this.optional, this.persistent, this.textColor, this.width, this.left, this.right, this.hidden);
    }
    asOptional(optional) {
      return this.copy(this.key, this.grow, this.shrink, this.basis, optional, this.persistent, this.textColor, this.width, this.left, this.right, this.hidden);
    }
    asPersistent(persistent) {
      return this.copy(this.key, this.grow, this.shrink, this.basis, this.optional, persistent, this.textColor, this.width, this.left, this.right, this.hidden);
    }
    withTextColor(textColor) {
      if (textColor !== null && !(textColor instanceof Look)) {
        textColor = Color.fromAny(textColor);
      }
      return this.copy(this.key, this.grow, this.shrink, this.basis, this.optional, this.persistent, textColor, this.width, this.left, this.right, this.hidden);
    }
    asHidden(hidden) {
      return this.copy(this.key, this.grow, this.shrink, this.basis, this.optional, this.persistent, this.textColor, this.width, this.left, this.right, hidden);
    }
    resized(width, left, right, hidden) {
      if (width !== null) {
        width = math.Length.fromAny(width);
      }
      if (left !== null) {
        left = math.Length.fromAny(left);
      }
      if (right !== null) {
        right = math.Length.fromAny(right);
      }
      if (hidden === void 0) {
        hidden = this.hidden;
      }
      return this.copy(this.key, this.grow, this.shrink, this.basis, this.optional, this.persistent, this.textColor, width, left, right, hidden);
    }
    copy(key, grow, shrink, basis, optional, persistent, textColor, width, left, right, hidden) {
      return new ColLayout(key, grow, shrink, basis, optional, persistent, textColor, width, left, right, hidden);
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof ColLayout) {
        return this.key === that.key && this.grow === that.grow && this.shrink === that.shrink && this.basis.equivalentTo(that.basis, epsilon) && this.optional === that.optional && this.persistent === that.persistent && util.Equivalent(this.textColor, that.textColor, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof ColLayout) {
        return this.key === that.key && this.grow === that.grow && this.shrink === that.shrink && this.basis.equals(that.basis) && this.optional === that.optional && this.persistent === that.persistent && util.Equals(this.textColor, that.textColor) && util.Equals(this.width, that.width) && util.Equals(this.left, that.left) && util.Equals(this.right, that.right) && this.hidden === that.hidden;
      }
      return false;
    }
    debug(output) {
      output = output.write("ColLayout").write(46).write("create").write(40).debug(this.key).write(", ").debug(this.grow).write(", ").debug(this.shrink).write(", ").debug(this.basis).write(41);
      if (this.optional) {
        output = output.write(46).write("asOptional").write(40).debug(this.optional).write(41);
      }
      if (this.persistent) {
        output = output.write(46).write("asPersistent").write(40).debug(this.persistent).write(41);
      }
      if (this.textColor) {
        output = output.write(46).write("withTextColor").write(40).debug(this.textColor).write(41);
      }
      if (this.width !== null || this.left !== null || this.right !== null || this.hidden) {
        output = output.write(46).write("resized").write(40).debug(this.width).write(", ").debug(this.left).write(", ").debug(this.right).write(", ").debug(this.hidden).write(41);
      }
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static create(key, grow, shrink, basis, optional, persistent, textColor) {
      if (grow === void 0) {
        grow = 0;
      }
      if (shrink === void 0) {
        shrink = 1;
      }
      if (basis !== void 0) {
        basis = math.Length.fromAny(basis);
      } else {
        basis = math.Length.zero();
      }
      if (optional === void 0) {
        optional = false;
      }
      if (persistent === void 0) {
        persistent = false;
      }
      if (textColor === void 0) {
        textColor = null;
      }
      if (textColor !== null && !(textColor instanceof Look)) {
        textColor = Color.fromAny(textColor);
      }
      return new ColLayout(key, grow, shrink, basis, optional, persistent, textColor, null, null, null, false);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof ColLayout) {
        return value;
      } else if (typeof value === "object" && value !== null) {
        return ColLayout.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static fromInit(init) {
      let key = init.key;
      if (key === void 0) {
        key = "";
      }
      let grow = init.grow;
      if (grow === void 0) {
        grow = 0;
      }
      let shrink = init.shrink;
      if (shrink === void 0) {
        shrink = 1;
      }
      let basis = init.basis;
      if (basis !== void 0) {
        basis = math.Length.fromAny(basis);
      } else {
        basis = math.Length.zero();
      }
      let optional = init.optional;
      if (optional === void 0) {
        optional = false;
      }
      let persistent = init.persistent;
      if (persistent === void 0) {
        persistent = false;
      }
      let textColor = init.textColor;
      if (textColor === void 0) {
        textColor = null;
      }
      if (textColor !== null && !(textColor instanceof Look)) {
        textColor = Color.fromAny(textColor);
      }
      let width = init.width;
      if (width !== void 0 && width !== null) {
        width = math.Length.fromAny(width);
      } else {
        width = null;
      }
      let left = init.left;
      if (left !== void 0 && left !== null) {
        left = math.Length.fromAny(left);
      } else {
        left = null;
      }
      let right = init.right;
      if (right !== void 0 && right !== null) {
        right = math.Length.fromAny(right);
      } else {
        right = null;
      }
      let hidden = init.hidden;
      if (hidden === void 0) {
        hidden = false;
      }
      return new ColLayout(key, grow, shrink, basis, optional, persistent, textColor, width, left, right, hidden);
    }
  }
  class TableLayout {
    constructor(width, left, right, colSpacing, cols) {
      this.width = width;
      this.left = left;
      this.right = right;
      this.colSpacing = colSpacing;
      this.cols = cols;
    }
    getCol(key) {
      const cols = this.cols;
      for (let i = 0, n = cols.length; i < n; i += 1) {
        const col = cols[i];
        if (key === col.key) {
          return col;
        }
      }
      return null;
    }
    resized(width, left, right, colSpacing) {
      width = math.Length.fromAny(width);
      if (left === void 0) {
        left = this.left;
      } else if (left !== null) {
        left = math.Length.fromAny(left);
      }
      if (right === void 0) {
        right = this.right;
      } else if (right !== null) {
        right = math.Length.fromAny(right);
      }
      if (colSpacing === void 0) {
        colSpacing = this.colSpacing;
      } else if (colSpacing !== null) {
        colSpacing = math.Length.fromAny(colSpacing);
      }
      if (util.Equals(this.width, width) && util.Equals(this.left, left) && util.Equals(this.right, right) && util.Equals(this.colSpacing, colSpacing)) {
        return this;
      } else {
        const oldCols = this.cols;
        const colCount = oldCols.length;
        const newCols = new Array(colCount);
        const tableWidth = width.pxValue();
        const tableLeft = left !== null ? left.pxValue(tableWidth) : 0;
        const tableRight = right !== null ? right.pxValue(tableWidth) : 0;
        const spacing = colSpacing !== null ? colSpacing.pxValue(tableWidth) : 0;
        let grow = 0;
        let shrink = 0;
        let optional = 0;
        let basis = tableLeft + tableRight;
        let x = tableLeft;
        for (let i = 0; i < colCount; i += 1) {
          if (i !== 0) {
            basis += spacing;
            x += spacing;
          }
          const col = oldCols[i];
          const colWidth = col.basis.pxValue(tableWidth);
          newCols[i] = col.resized(colWidth, x, tableWidth - colWidth - x, false);
          grow += col.grow;
          shrink += col.shrink;
          if (col.optional) {
            optional += 1;
          }
          basis += colWidth;
          x += colWidth;
        }
        if (basis > tableWidth && optional > 0) {
          let i = colCount - 1;
          while (i >= 0 && optional > 0) {
            const col = newCols[i];
            const colWidth = col.width.pxValue();
            if (col.optional) {
              newCols[i] = col.resized(0, x, tableWidth - x, true);
              grow -= col.grow;
              shrink -= col.shrink;
              optional -= 1;
              basis -= colWidth;
            }
            x -= colWidth;
            if (i !== 0) {
              basis -= spacing;
              x -= spacing;
            }
            if (basis <= tableWidth) {
              break;
            }
            i -= 1;
          }
          i += 1;
          while (i < colCount) {
            const col = newCols[i];
            if (!col.optional) {
              basis += spacing;
              x += spacing;
              const colWidth = col.basis.pxValue(tableWidth);
              newCols[i] = col.resized(colWidth, x, tableWidth - colWidth - x);
              x += colWidth;
            }
            i += 1;
          }
        }
        if (basis < tableWidth && grow > 0) {
          const delta = tableWidth - basis;
          let x = tableLeft;
          let j = 0;
          for (let i = 0; i < colCount; i += 1) {
            const col = newCols[i];
            if (!col.hidden) {
              if (j !== 0) {
                x += spacing;
              }
              const colBasis = col.basis.pxValue(tableWidth);
              const colWidth = colBasis + delta * (col.grow / grow);
              newCols[i] = col.resized(colWidth, x, tableWidth - colWidth - x);
              x += colWidth;
              j += 1;
            } else {
              newCols[i] = col.resized(0, x + spacing, tableWidth - x - spacing);
            }
          }
        } else if (basis > tableWidth && shrink > 0) {
          const delta = basis - tableWidth;
          let x = tableLeft;
          let j = 0;
          for (let i = 0; i < colCount; i += 1) {
            const col = newCols[i];
            if (!col.hidden) {
              if (j !== 0) {
                x += spacing;
              }
              const colBasis = col.basis.pxValue(tableWidth);
              const colWidth = colBasis - delta * (col.shrink / shrink);
              newCols[i] = col.resized(colWidth, x, tableWidth - colWidth - x);
              x += colWidth;
              j += 1;
            } else {
              newCols[i] = col.resized(0, x + spacing, tableWidth - x - spacing);
            }
          }
        }
        return new TableLayout(width, left, right, colSpacing, newCols);
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof TableLayout) {
        const theseCols = this.cols;
        const thoseCols = that.cols;
        const n = theseCols.length;
        if (n === thoseCols.length) {
          for (let i = 0; i < n; i += 1) {
            if (!theseCols[i].equivalentTo(thoseCols[i], epsilon)) {
              return false;
            }
          }
          return true;
        }
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof TableLayout) {
        return util.Equals(this.width, that.width) && util.Equals(this.left, that.left) && util.Equals(this.right, that.right) && util.Equals(this.colSpacing, that.colSpacing) && util.Arrays.equal(this.cols, that.cols);
      }
      return false;
    }
    debug(output) {
      output = output.write("TableLayout").write(46).write("of").write(40);
      for (let i = 0, n = this.cols.length; i < n; i += 1) {
        if (i !== 0) {
          output = output.write(", ");
        }
        output = output.debug(this.cols[i]);
      }
      output = output.write(41);
      if (this.width !== null || this.left !== null || this.right !== null || this.colSpacing !== null) {
        output = output.write(46).write("resized").write(40).debug(this.width).write(", ").debug(this.left).write(", ").debug(this.right).write(", ").debug(this.colSpacing).write(41);
      }
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static of(...tableCols) {
      const n = tableCols.length;
      const cols = new Array(n);
      for (let i = 0; i < n; i += 1) {
        cols[i] = ColLayout.fromAny(tableCols[i]);
      }
      return new TableLayout(null, null, null, null, cols);
    }
    static create(cols) {
      return new TableLayout(null, null, null, null, cols);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof TableLayout) {
        return value;
      } else if (typeof value === "object" && value !== null) {
        return TableLayout.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static fromInit(init) {
      let width = init.width;
      if (width !== void 0 && width !== null) {
        width = math.Length.fromAny(width);
      } else {
        width = null;
      }
      let left = init.left;
      if (left !== void 0 && left !== null) {
        left = math.Length.fromAny(left);
      } else {
        left = null;
      }
      let right = init.right;
      if (right !== void 0 && right !== null) {
        right = math.Length.fromAny(right);
      } else {
        right = null;
      }
      let colSpacing = init.colSpacing;
      if (colSpacing !== void 0 && colSpacing !== null) {
        colSpacing = math.Length.fromAny(colSpacing);
      } else {
        colSpacing = null;
      }
      const colCount = init.cols.length;
      const cols = new Array(colCount);
      for (let i = 0; i < colCount; i += 1) {
        cols[i] = ColLayout.fromAny(init.cols[i]);
      }
      return new TableLayout(width, left, right, colSpacing, cols);
    }
  }
  class CellView extends HtmlView {
    constructor(node) {
      super(node);
      this.initCell();
    }
    initCell() {
      this.addClass("cell");
      this.overflowX.setState("hidden", component.Affinity.Intrinsic);
      this.overflowY.setState("hidden", component.Affinity.Intrinsic);
    }
    onPress(input, event) {}
    didPress(input, event) {
      this.callObservers("viewDidPress", input, event, this);
    }
    onLongPress(input) {}
    didLongPress(input) {
      this.callObservers("viewDidLongPress", input, this);
    }
  }
  class TextCellView extends CellView {
    initCell() {
      super.initCell();
      this.addClass("cell-text");
    }
  }
  __decorate([ ViewRef({
    implements: true,
    key: true,
    type: HtmlView,
    binds: true,
    willAttachView(contentView) {
      this.owner.callObservers("viewWillAttachContent", contentView, this.owner);
    },
    didDetachView(contentView) {
      this.owner.callObservers("viewDidDetachContent", contentView, this.owner);
    },
    create(value) {
      const contentView = HtmlView.fromTag("span");
      contentView.alignSelf.setState("center", component.Affinity.Intrinsic);
      contentView.whiteSpace.setState("nowrap", component.Affinity.Intrinsic);
      contentView.textOverflow.setState("ellipsis", component.Affinity.Intrinsic);
      contentView.overflowX.setState("hidden", component.Affinity.Intrinsic);
      contentView.overflowY.setState("hidden", component.Affinity.Intrinsic);
      if (value !== void 0) {
        contentView.text(value);
      }
      return contentView;
    },
    fromAny(value) {
      if (typeof value === "string") {
        return this.create(value);
      } else {
        return HtmlView.fromAny(value);
      }
    }
  }) ], TextCellView.prototype, "content", void 0);
  class IconCellView extends CellView {
    constructor(node) {
      super(node);
      this.initSvg();
    }
    initCell() {
      super.initCell();
      this.addClass("cell-icon");
    }
    initSvg() {
      const svgView = this.createSvgView();
      if (svgView !== null) {
        this.setChild("svg", svgView);
      }
    }
    createSvgView() {
      return SvgIconView.create();
    }
    get svgView() {
      const svgView = this.getChild("svg");
      return svgView instanceof SvgIconView ? svgView : null;
    }
    onInsertChild(child, target) {
      super.onInsertChild(child, target);
      if (child.key === "svg" && child instanceof SvgIconView) {
        this.onInsertSvg(child);
      }
    }
    onInsertSvg(svgView) {
      svgView.xAlign.setInherits(true);
      svgView.yAlign.setInherits(true);
      svgView.iconWidth.setInherits(true);
      svgView.iconHeight.setInherits(true);
      svgView.iconColor.setInherits(true);
      svgView.graphics.setInherits(true);
      svgView.setStyle("position", "absolute");
    }
    onApplyTheme(theme, mood, timing) {
      super.onApplyTheme(theme, mood, timing);
      if (!this.graphics.inherited) {
        const oldGraphics = this.graphics.value;
        if (oldGraphics instanceof Icon) {
          const newGraphics = oldGraphics.withTheme(theme, mood);
          this.graphics.setState(newGraphics, oldGraphics.isThemed() ? timing : false, component.Affinity.Reflexive);
        }
      }
    }
    onResize(viewContext) {
      super.onResize(viewContext);
      this.requireUpdate(View.NeedsLayout);
    }
    needsDisplay(displayFlags, viewContext) {
      if ((this.flags & View.NeedsLayout) === 0) {
        displayFlags &= ~View.NeedsLayout;
      }
      return displayFlags;
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.layoutIcon();
    }
    layoutIcon() {
      const svgView = this.svgView;
      if (svgView !== null && (svgView.width.hasAffinity(component.Affinity.Intrinsic) || svgView.height.hasAffinity(component.Affinity.Intrinsic) || svgView.viewBox.hasAffinity(component.Affinity.Intrinsic))) {
        let viewWidth = this.width.value;
        viewWidth = viewWidth instanceof math.Length ? viewWidth.pxValue() : this.node.offsetWidth;
        let viewHeight = this.height.value;
        viewHeight = viewHeight instanceof math.Length ? viewHeight.pxValue() : this.node.offsetHeight;
        svgView.width.setState(viewWidth, component.Affinity.Intrinsic);
        svgView.height.setState(viewHeight, component.Affinity.Intrinsic);
        svgView.viewBox.setState("0 0 " + viewWidth + " " + viewHeight, component.Affinity.Intrinsic);
      }
    }
  }
  __decorate([ component.Animator({
    type: Number,
    value: .5,
    updateFlags: View.NeedsLayout
  }) ], IconCellView.prototype, "xAlign", void 0);
  __decorate([ component.Animator({
    type: Number,
    value: .5,
    updateFlags: View.NeedsLayout
  }) ], IconCellView.prototype, "yAlign", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], IconCellView.prototype, "iconWidth", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], IconCellView.prototype, "iconHeight", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    updateFlags: View.NeedsLayout,
    didSetValue(newIconColor, oldIconColor) {
      if (newIconColor !== null) {
        const oldGraphics = this.owner.graphics.value;
        if (oldGraphics instanceof FilledIcon) {
          const newGraphics = oldGraphics.withFillColor(newIconColor);
          this.owner.graphics.setState(newGraphics, component.Affinity.Reflexive);
        }
      }
    }
  }) ], IconCellView.prototype, "iconColor", void 0);
  __decorate([ ThemeAnimator({
    extends: IconGraphicsAnimator,
    type: Object,
    value: null,
    updateFlags: View.NeedsLayout,
    willSetValue(newGraphics, oldGraphics) {
      this.owner.callObservers("viewWillSetGraphics", newGraphics, oldGraphics, this.owner);
    },
    didSetValue(newGraphics, oldGraphics) {
      this.owner.requireUpdate(View.NeedsRasterize | View.NeedsComposite);
      this.owner.callObservers("viewDidSetGraphics", newGraphics, oldGraphics, this.owner);
    }
  }) ], IconCellView.prototype, "graphics", void 0);
  class DisclosureCellView extends CellView {
    initCell() {
      super.initCell();
      this.addClass("cell-disclosure");
      this.button.insertView();
    }
    didPress(input, event) {
      input.preventDefault();
      const superDisclosure = this.disclosure.superFastener;
      if (superDisclosure instanceof ExpansionThemeAnimator) {
        superDisclosure.toggle();
      }
      super.didPress(input, event);
    }
  }
  __decorate([ ThemeAnimator({
    type: Expansion,
    inherits: true
  }) ], DisclosureCellView.prototype, "disclosure", void 0);
  __decorate([ ViewRef({
    key: true,
    type: DisclosureButton,
    binds: true
  }) ], DisclosureCellView.prototype, "button", void 0);
  class CellTrait extends Trait {}
  class TextCellTrait extends CellTrait {}
  __decorate([ component.Property({
    value: null,
    willSetValue(newContent, oldContent) {
      this.owner.callObservers("traitWillSetContent", newContent, oldContent, this.owner);
    },
    didSetValue(newContent, oldContent) {
      this.owner.callObservers("traitDidSetContent", newContent, oldContent, this.owner);
    }
  }) ], TextCellTrait.prototype, "content", void 0);
  class IconCellTrait extends CellTrait {}
  __decorate([ component.Property({
    value: null,
    willSetValue(newIcon, oldIcon) {
      this.owner.callObservers("traitWillSetIcon", newIcon, oldIcon, this.owner);
    },
    didSetValue(newIcon, oldIcon) {
      this.owner.callObservers("traitDidSetIcon", newIcon, oldIcon, this.owner);
    }
  }) ], IconCellTrait.prototype, "icon", void 0);
  class CellController extends Controller {
    static fromTrait(cellTrait) {
      if (cellTrait instanceof TextCellTrait) {
        return new TextCellController;
      } else if (cellTrait instanceof IconCellTrait) {
        return new IconCellController;
      } else {
        return new CellController;
      }
    }
  }
  __decorate([ TraitViewRef({
    traitType: CellTrait,
    willAttachTrait(cellTrait) {
      this.owner.callObservers("controllerWillAttachCellTrait", cellTrait, this.owner);
    },
    didDetachTrait(cellTrait) {
      this.owner.callObservers("controllerDidDetachCellTrait", cellTrait, this.owner);
    },
    viewType: CellView,
    observesView: true,
    willAttachView(cellView) {
      this.owner.callObservers("controllerWillAttachCellView", cellView, this.owner);
    },
    didDetachView(cellView) {
      this.owner.callObservers("controllerDidDetachCellView", cellView, this.owner);
    },
    viewDidPress(input, event, cellView) {
      this.owner.callObservers("controllerDidPressCellView", input, event, cellView, this.owner);
    },
    viewDidLongPress(input, cellView) {
      this.owner.callObservers("controllerDidLongPressCellView", input, cellView, this.owner);
    }
  }) ], CellController.prototype, "cell", void 0);
  class TextCellController extends CellController {
    createContentView(content, cellTrait) {
      if (typeof content === "function") {
        return content(cellTrait);
      } else {
        return content;
      }
    }
    setContentView(content, cellTrait) {
      const cellView = this.cell.view;
      if (cellView !== null) {
        const contentView = content !== null ? this.createContentView(content, cellTrait) : null;
        cellView.content.setView(contentView);
      }
    }
  }
  __decorate([ TraitViewRef({
    extends: true,
    traitType: TextCellTrait,
    observesTrait: true,
    initTrait(cellTrait) {
      this.owner.setContentView(cellTrait.content.value, cellTrait);
    },
    deinitTrait(cellTrait) {
      this.owner.setContentView(null, cellTrait);
    },
    traitDidSetContent(newContent, oldContent, cellTrait) {
      this.owner.setContentView(newContent, cellTrait);
    },
    viewType: TextCellView,
    observesView: true,
    initView(cellView) {
      this.owner.content.setView(cellView.content.view);
      const cellTrait = this.trait;
      if (cellTrait !== null) {
        this.owner.setContentView(cellTrait.content.value, cellTrait);
      }
    },
    deinitView(cellView) {
      this.owner.content.setView(null);
    },
    viewWillAttachContent(contentView) {
      this.owner.content.setView(contentView);
    },
    viewDidDetachContent(contentView) {
      this.owner.content.setView(null);
    }
  }) ], TextCellController.prototype, "cell", void 0);
  __decorate([ ViewRef({
    type: HtmlView,
    willAttachView(contentView) {
      this.owner.callObservers("controllerWillAttachCellContentView", contentView, this.owner);
    },
    didDetachView(contentView) {
      this.owner.callObservers("controllerDidDetachCellContentView", contentView, this.owner);
    }
  }) ], TextCellController.prototype, "content", void 0);
  class IconCellController extends CellController {
    setIcon(icon) {
      const cellView = this.cell.view;
      if (cellView !== null) {
        cellView.graphics.setState(icon);
      }
    }
  }
  __decorate([ TraitViewRef({
    extends: true,
    traitType: IconCellTrait,
    observesTrait: true,
    initTrait(cellTrait) {
      this.owner.setIcon(cellTrait.icon.value);
    },
    deinitTrait(cellTrait) {
      this.owner.setIcon(null);
    },
    traitDidSetIcon(newCellIcon, oldCellIcon) {
      this.owner.setIcon(newCellIcon);
    },
    viewType: IconCellView,
    observesView: true,
    initView(cellView) {
      const cellTrait = this.trait;
      if (cellTrait !== null) {
        this.owner.setIcon(cellTrait.icon.value);
      }
    },
    viewWillSetGraphics(newCellIcon, oldCellIcon) {
      this.owner.callObservers("controllerWillSetCellIcon", newCellIcon, oldCellIcon, this.owner);
    },
    viewDidSetGraphics(newCellIcon, oldCellIcon) {
      this.owner.callObservers("controllerDidSetCellIcon", newCellIcon, oldCellIcon, this.owner);
    }
  }) ], IconCellController.prototype, "cell", void 0);
  class LeafView extends HtmlView {
    constructor(node) {
      super(node);
      this.initLeaf();
    }
    initLeaf() {
      this.addClass("leaf");
      this.position.setState("relative", component.Affinity.Intrinsic);
      this.overflowX.setState("hidden", component.Affinity.Intrinsic);
      this.overflowY.setState("hidden", component.Affinity.Intrinsic);
      const highlightPhase = this.highlight.getPhase();
      const hoverPhase = this.hover.getPhase();
      const backgroundPhase = Math.max(highlightPhase, hoverPhase);
      this.modifyMood(Feel.default, [ [ Feel.transparent, 1 - backgroundPhase ], [ Feel.hovering, hoverPhase * (1 - highlightPhase) ], [ Feel.selected, highlightPhase ] ], false);
    }
    getCell(key, cellViewClass) {
      if (cellViewClass === void 0) {
        cellViewClass = CellView;
      }
      const cellView = this.getChild(key);
      return cellView instanceof cellViewClass ? cellView : null;
    }
    getOrCreateCell(key, cellViewClass) {
      let cellView = this.getChild(key, cellViewClass);
      if (cellView === null) {
        cellView = cellViewClass.create();
        this.setChild(key, cellView);
      }
      return cellView;
    }
    setCell(key, cellView) {
      this.setChild(key, cellView);
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.layoutLeaf();
    }
    layoutLeaf() {
      const rowHeight = this.rowHeight.value;
      if (rowHeight !== null) {
        this.height.setState(rowHeight, component.Affinity.Intrinsic);
      }
    }
    displayChildren(displayFlags, viewContext, displayChild) {
      if ((displayFlags & View.NeedsLayout) !== 0) {
        this.layoutChildViews(displayFlags, viewContext, displayChild);
      } else {
        super.displayChildren(displayFlags, viewContext, displayChild);
      }
    }
    layoutChildViews(displayFlags, viewContext, displayChild) {
      const layout = this.layout.value;
      const height = this.height.state;
      const stretch = this.stretch.getPhaseOr(1);
      function layoutChildView(child, displayFlags, viewContext) {
        if (child instanceof CellView) {
          const key = child.key;
          const col = layout !== null && key !== void 0 ? layout.getCol(key) : null;
          if (col !== null) {
            child.display.setState(!col.hidden ? "flex" : "none", component.Affinity.Intrinsic);
            child.left.setState(col.left, component.Affinity.Intrinsic);
            child.width.setState(col.width, component.Affinity.Intrinsic);
            child.height.setState(height, component.Affinity.Intrinsic);
            const textColor = col.textColor;
            if (textColor instanceof Look) {
              child.color.setLook(textColor, component.Affinity.Intrinsic);
            } else {
              child.color.setState(textColor, component.Affinity.Intrinsic);
            }
            if (!col.persistent) {
              child.opacity.setState(stretch, component.Affinity.Intrinsic);
            }
          } else {
            child.display.setState("none", component.Affinity.Intrinsic);
            child.left.setState(null, component.Affinity.Intrinsic);
            child.width.setState(null, component.Affinity.Intrinsic);
            child.height.setState(null, component.Affinity.Intrinsic);
          }
        }
        displayChild.call(this, child, displayFlags, viewContext);
      }
      super.displayChildren(displayFlags, viewContext, layoutChildView);
    }
    glow(input) {
      if (input.detail instanceof ButtonGlow) {
        input.detail.fade(input.x, input.y);
        input.detail = void 0;
      }
      if (input.detail === void 0) {
        const delay = input.inputType === "mouse" ? 0 : 100;
        input.detail = this.prependChild(ButtonGlow);
        input.detail.glow(input.x, input.y, void 0, delay);
      }
    }
  }
  __decorate([ component.Property({
    type: TableLayout,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], LeafView.prototype, "layout", void 0);
  __decorate([ component.Property({
    type: Number,
    inherits: true,
    value: 0,
    updateFlags: View.NeedsLayout
  }) ], LeafView.prototype, "depth", void 0);
  __decorate([ ThemeConstraintAnimator({
    type: math.Length,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], LeafView.prototype, "rowSpacing", void 0);
  __decorate([ ThemeConstraintAnimator({
    type: math.Length,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], LeafView.prototype, "rowHeight", void 0);
  __decorate([ ThemeAnimator({
    type: Expansion,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], LeafView.prototype, "stretch", void 0);
  __decorate([ component.Property({
    type: Boolean,
    inherits: true,
    value: false
  }) ], LeafView.prototype, "hovers", void 0);
  __decorate([ ThemeAnimator({
    type: Focus,
    value: Focus.unfocused(),
    didSetValue(newHover, oldHover) {
      const highlightPhase = this.owner.highlight.getPhase();
      const hoverPhase = newHover.phase;
      const backgroundPhase = Math.max(highlightPhase, hoverPhase);
      this.owner.modifyMood(Feel.default, [ [ Feel.transparent, 1 - backgroundPhase ], [ Feel.hovering, hoverPhase * (1 - highlightPhase) ], [ Feel.selected, highlightPhase ] ], false);
      if (backgroundPhase !== 0) {
        this.owner.backgroundColor.setLook(Look.backgroundColor, component.Affinity.Intrinsic);
      } else {
        this.owner.backgroundColor.setLook(null, component.Affinity.Intrinsic);
        this.owner.backgroundColor.setState(null, component.Affinity.Intrinsic);
      }
    }
  }) ], LeafView.prototype, "hover", void 0);
  __decorate([ ThemeAnimator({
    type: Focus,
    value: Focus.unfocused(),
    willFocus() {
      this.owner.callObservers("viewWillHighlight", this.owner);
    },
    didFocus() {
      this.owner.callObservers("viewDidHighlight", this.owner);
    },
    willUnfocus() {
      this.owner.callObservers("viewWillUnhighlight", this.owner);
    },
    didUnfocus() {
      this.owner.callObservers("viewDidUnhighlight", this.owner);
    },
    didSetValue(newHighlight, oldHighlight) {
      const highlightPhase = newHighlight.phase;
      const hoverPhase = this.owner.hover.getPhase();
      const backgroundPhase = Math.max(highlightPhase, hoverPhase);
      this.owner.modifyMood(Feel.default, [ [ Feel.transparent, 1 - backgroundPhase ], [ Feel.hovering, hoverPhase * (1 - highlightPhase) ], [ Feel.selected, highlightPhase ] ], false);
      if (backgroundPhase !== 0) {
        this.owner.backgroundColor.setLook(Look.backgroundColor, component.Affinity.Intrinsic);
      } else {
        this.owner.backgroundColor.setLook(null, component.Affinity.Intrinsic);
        this.owner.backgroundColor.setState(null, component.Affinity.Intrinsic);
      }
    }
  }) ], LeafView.prototype, "highlight", void 0);
  __decorate([ ViewSet({
    type: CellView,
    binds: true,
    initView(cellView) {
      cellView.display.setState("none", component.Affinity.Intrinsic);
      cellView.position.setState("absolute", component.Affinity.Intrinsic);
      cellView.left.setState(0, component.Affinity.Intrinsic);
      cellView.top.setState(0, component.Affinity.Intrinsic);
      cellView.width.setState(0, component.Affinity.Intrinsic);
      cellView.height.setState(this.owner.height.state, component.Affinity.Intrinsic);
    },
    willAttachView(cellView, target) {
      this.owner.callObservers("viewWillAttachCell", cellView, target, this.owner);
    },
    didDetachView(cellView) {
      this.owner.callObservers("viewDidDetachCell", cellView, this.owner);
    }
  }) ], LeafView.prototype, "cells", void 0);
  __decorate([ component.Property({
    type: Boolean,
    inherits: true,
    value: true
  }) ], LeafView.prototype, "glows", void 0);
  __decorate([ PositionGesture({
    self: true,
    didBeginPress(input, event) {
      if (this.owner.glows.value) {
        this.owner.glow(input);
      }
    },
    didMovePress(input, event) {
      if (input.isRunaway()) {
        this.cancelPress(input, event);
      } else if (!this.owner.clientBounds.contains(input.x, input.y)) {
        input.clearHoldTimer();
        this.beginHover(input, event);
        if (input.detail instanceof ButtonGlow) {
          input.detail.fade(input.x, input.y);
          input.detail = void 0;
        }
      }
    },
    didEndPress(input, event) {
      if (!this.owner.clientBounds.contains(input.x, input.y)) {
        this.endHover(input, event);
        if (input.detail instanceof ButtonGlow) {
          input.detail.fade(input.x, input.y);
          input.detail = void 0;
        }
      } else if (input.detail instanceof ButtonGlow) {
        input.detail.pulse(input.x, input.y);
      }
    },
    didCancelPress(input, event) {
      if (!this.owner.clientBounds.contains(input.x, input.y)) {
        this.endHover(input, event);
      }
      if (input.detail instanceof ButtonGlow) {
        input.detail.fade(input.x, input.y);
        input.detail = void 0;
      }
    },
    didStartHovering() {
      if (this.owner.hovers.value) {
        this.owner.hover.focus(false);
      }
      this.owner.callObservers("viewDidEnter", this.owner);
    },
    didStopHovering() {
      if (this.owner.hovers.value) {
        this.owner.hover.unfocus();
      }
      this.owner.callObservers("viewDidLeave", this.owner);
    },
    didPress(input, event) {
      if (this.owner.clientBounds.contains(input.x, input.y)) {
        if (!input.defaultPrevented) {
          let target = input.target;
          while (target !== null && target !== this.owner.node) {
            const targetView = target.view;
            if (targetView instanceof CellView) {
              targetView.onPress(input, event);
              targetView.didPress(input, event);
              break;
            }
            target = target instanceof Node ? target.parentNode : null;
          }
        }
        if (!input.defaultPrevented) {
          this.owner.callObservers("viewDidPress", input, event, this.owner);
        }
      }
    },
    didLongPress(input) {
      if (!input.defaultPrevented) {
        let target = input.target;
        while (target !== null && target !== this.owner.node) {
          const targetView = target.view;
          if (targetView instanceof CellView) {
            targetView.onLongPress(input);
            targetView.didLongPress(input);
            break;
          }
          target = target instanceof Node ? target.parentNode : null;
        }
      }
      if (!input.defaultPrevented) {
        this.owner.callObservers("viewDidLongPress", input, this.owner);
      }
    }
  }) ], LeafView.prototype, "gesture", void 0);
  class LeafTrait extends Trait {
    getCell(key, cellTraitClass) {
      if (cellTraitClass === void 0) {
        cellTraitClass = CellTrait;
      }
      const cellTrait = this.getTrait(key);
      return cellTrait instanceof cellTraitClass ? cellTrait : null;
    }
    getOrCreateCell(key, cellTraitClass) {
      let cellTrait = this.getTrait(key, cellTraitClass);
      if (cellTrait === null) {
        cellTrait = cellTraitClass.create();
        this.setTrait(key, cellTrait);
      }
      return cellTrait;
    }
    setCell(key, cellTrait) {
      this.setTrait(key, cellTrait);
    }
    startConsumingCells() {
      const cellTraits = this.cells.traits;
      for (const traitId in cellTraits) {
        const cellTrait = cellTraits[traitId];
        cellTrait.consume(this);
      }
    }
    stopConsumingCells() {
      const cellTraits = this.cells.traits;
      for (const traitId in cellTraits) {
        const cellTrait = cellTraits[traitId];
        cellTrait.unconsume(this);
      }
    }
    onStartConsuming() {
      super.onStartConsuming();
      this.startConsumingCells();
    }
    onStopConsuming() {
      super.onStopConsuming();
      this.stopConsumingCells();
    }
  }
  __decorate([ TraitSet({
    type: CellTrait,
    binds: true,
    willAttachTrait(cellTrait, targetTrait) {
      this.owner.callObservers("traitWillAttachCell", cellTrait, targetTrait, this.owner);
    },
    didAttachTrait(cellTrait, targetTrait) {
      if (this.owner.consuming) {
        cellTrait.consume(this.owner);
      }
    },
    willDetachTrait(cellTrait) {
      if (this.owner.consuming) {
        cellTrait.unconsume(this.owner);
      }
    },
    didDetachTrait(cellTrait) {
      this.owner.callObservers("traitDidDetachCell", cellTrait, this.owner);
    },
    detectModel(model) {
      return model.getTrait(CellTrait);
    }
  }) ], LeafTrait.prototype, "cells", void 0);
  class LeafController extends Controller {
    getCellTrait(key, cellTraitClass) {
      const leafTrait = this.leaf.trait;
      return leafTrait !== null ? leafTrait.getCell(key, cellTraitClass) : null;
    }
    getOrCreateCellTrait(key, cellTraitClass) {
      const leafTrait = this.leaf.trait;
      if (leafTrait === null) {
        throw new Error("no leaf trait");
      }
      return leafTrait.getOrCreateCell(key, cellTraitClass);
    }
    setCellTrait(key, cellTrait) {
      const leafTrait = this.leaf.trait;
      if (leafTrait === null) {
        throw new Error("no leaf trait");
      }
      leafTrait.setCell(key, cellTrait);
    }
    getCellView(key, cellViewClass) {
      const leafView = this.leaf.view;
      return leafView !== null ? leafView.getCell(key, cellViewClass) : null;
    }
    getOrCreateCellView(key, cellViewClass) {
      let leafView = this.leaf.view;
      if (leafView === null) {
        leafView = this.leaf.createView();
        if (leafView === null) {
          throw new Error("no leaf view");
        }
        this.leaf.setView(leafView);
      }
      return leafView.getOrCreateCell(key, cellViewClass);
    }
    setCellView(key, cellView) {
      let leafView = this.leaf.view;
      if (leafView === null) {
        leafView = this.leaf.createView();
        if (leafView === null) {
          throw new Error("no leaf view");
        }
        this.leaf.setView(leafView);
      }
      leafView.setCell(key, cellView);
    }
  }
  __decorate([ TraitViewRef({
    traitType: LeafTrait,
    observesTrait: true,
    willAttachTrait(leafTrait) {
      this.owner.callObservers("controllerWillAttachLeafTrait", leafTrait, this.owner);
    },
    didAttachTrait(leafTrait) {
      const cellTraits = leafTrait.cells.traits;
      for (const traitId in cellTraits) {
        const cellTrait = cellTraits[traitId];
        this.owner.cells.addTraitController(cellTrait);
      }
    },
    willDetachTrait(leafTrait) {
      const cellTraits = leafTrait.cells.traits;
      for (const traitId in cellTraits) {
        const cellTrait = cellTraits[traitId];
        this.owner.cells.deleteTraitController(cellTrait);
      }
    },
    didDetachTrait(leafTrait) {
      this.owner.callObservers("controllerDidDetachLeafTrait", leafTrait, this.owner);
    },
    traitWillAttachCell(cellTrait, targetTrait) {
      this.owner.cells.addTraitController(cellTrait, targetTrait);
    },
    traitDidDetachCell(cellTrait) {
      this.owner.cells.deleteTraitController(cellTrait);
    },
    viewType: LeafView,
    observesView: true,
    initView(leafView) {
      const cellControllers = this.owner.cells.controllers;
      for (const controllerId in cellControllers) {
        const cellController = cellControllers[controllerId];
        const cellView = cellController.cell.view;
        if (cellView !== null && cellView.parent === null) {
          const cellTrait = cellController.cell.trait;
          if (cellTrait !== null) {
            cellController.cell.insertView(leafView, void 0, void 0, cellTrait.key);
          }
        }
      }
    },
    willAttachView(leafView) {
      this.owner.callObservers("controllerWillAttachLeafView", leafView, this.owner);
    },
    didDetachView(leafView) {
      this.owner.callObservers("controllerDidDetachLeafView", leafView, this.owner);
    },
    viewWillHighlight(leafView) {
      this.owner.callObservers("controllerWillHighlightLeafView", leafView, this.owner);
    },
    viewDidHighlight(leafView) {
      this.owner.callObservers("controllerDidHighlightLeafView", leafView, this.owner);
    },
    viewWillUnhighlight(leafView) {
      this.owner.callObservers("controllerWillUnhighlightLeafView", leafView, this.owner);
    },
    viewDidUnhighlight(leafView) {
      this.owner.callObservers("controllerDidUnhighlightLeafView", leafView, this.owner);
    },
    viewDidEnter(leafView) {
      this.owner.callObservers("controllerDidEnterLeafView", leafView, this.owner);
    },
    viewDidLeave(leafView) {
      this.owner.callObservers("controllerDidLeaveLeafView", leafView, this.owner);
    },
    viewDidPress(input, event, leafView) {
      this.owner.callObservers("controllerDidPressLeafView", input, event, leafView, this.owner);
    },
    viewDidLongPress(input, leafView) {
      this.owner.callObservers("controllerDidLongPressLeafView", input, leafView, this.owner);
    }
  }) ], LeafController.prototype, "leaf", void 0);
  __decorate([ TraitViewControllerSet({
    implements: true,
    type: CellController,
    binds: true,
    observes: true,
    get parentView() {
      return this.owner.leaf.view;
    },
    getTraitViewRef(cellController) {
      return cellController.cell;
    },
    willAttachController(cellController) {
      this.owner.callObservers("controllerWillAttachCell", cellController, this.owner);
    },
    didAttachController(cellController) {
      const cellTrait = cellController.cell.trait;
      if (cellTrait !== null) {
        this.attachCellTrait(cellTrait, cellController);
      }
      const cellView = cellController.cell.view;
      if (cellView !== null) {
        this.attachCellView(cellView, cellController);
      }
    },
    willDetachController(cellController) {
      const cellView = cellController.cell.view;
      if (cellView !== null) {
        this.detachCellView(cellView, cellController);
      }
      const cellTrait = cellController.cell.trait;
      if (cellTrait !== null) {
        this.detachCellTrait(cellTrait, cellController);
      }
    },
    didDetachController(cellController) {
      this.owner.callObservers("controllerDidDetachCell", cellController, this.owner);
    },
    controllerWillAttachCellTrait(cellTrait, cellController) {
      this.owner.callObservers("controllerWillAttachCellTrait", cellTrait, cellController, this.owner);
      this.attachCellTrait(cellTrait, cellController);
    },
    controllerDidDetachCellTrait(cellTrait, cellController) {
      this.detachCellTrait(cellTrait, cellController);
      this.owner.callObservers("controllerDidDetachCellTrait", cellTrait, cellController, this.owner);
    },
    attachCellTrait(cellTrait, cellController) {},
    detachCellTrait(cellTrait, cellController) {},
    controllerWillAttachCellView(cellView, cellController) {
      this.owner.callObservers("controllerWillAttachCellView", cellView, cellController, this.owner);
      this.attachCellView(cellView, cellController);
    },
    controllerDidDetachCellView(cellView, cellController) {
      this.detachCellView(cellView, cellController);
      this.owner.callObservers("controllerDidDetachCellView", cellView, cellController, this.owner);
    },
    attachCellView(cellView, cellController) {
      if (cellView instanceof TextCellView) {
        const cellContentView = cellView.content.view;
        if (cellContentView !== null) {
          this.attachCellContentView(cellContentView, cellController);
        }
      }
    },
    detachCellView(cellView, cellController) {
      if (cellView instanceof TextCellView) {
        const cellContentView = cellView.content.view;
        if (cellContentView !== null) {
          this.detachCellContentView(cellContentView, cellController);
        }
      }
      cellView.remove();
    },
    controllerDidPressCellView(input, event, cellView, cellController) {
      this.owner.callObservers("controllerDidPressCellView", input, event, cellView, cellController, this.owner);
    },
    controllerDidLongPressCellView(input, cellView, cellController) {
      this.owner.callObservers("controllerDidLongPressCellView", input, cellView, cellController, this.owner);
    },
    controllerWillAttachCellContentView(contentView, cellController) {
      this.attachCellContentView(contentView, cellController);
      this.owner.callObservers("controllerWillAttachCellContentView", contentView, cellController, this.owner);
    },
    controllerDidDetachCellContentView(contentView, cellController) {
      this.owner.callObservers("controllerDidDetachCellContentView", contentView, cellController, this.owner);
      this.detachCellContentView(contentView, cellController);
    },
    attachCellContentView(cellContentView, cellController) {},
    detachCellContentView(cellContentView, cellController) {},
    controllerWillSetCellIcon(newCellIcon, oldCellIcon, cellController) {
      this.owner.callObservers("controllerWillSetCellIcon", newCellIcon, oldCellIcon, cellController, this.owner);
    },
    controllerDidSetCellIcon(newCellIcon, oldCellIcon, cellController) {
      this.owner.callObservers("controllerDidSetCellIcon", newCellIcon, oldCellIcon, cellController, this.owner);
    },
    createController(cellTrait) {
      if (cellTrait !== void 0) {
        return CellController.fromTrait(cellTrait);
      } else {
        return TraitViewControllerSet.prototype.createController.call(this);
      }
    }
  }) ], LeafController.prototype, "cells", void 0);
  class RowView extends HtmlView {
    constructor(node) {
      super(node);
      this.visibleFrame = new math.R2Box(0, 0, window.innerWidth, window.innerHeight);
      this.initRow();
    }
    initRow() {
      this.addClass("row");
      this.position.setState("relative", component.Affinity.Intrinsic);
    }
    getCell(key, cellViewClass) {
      const leafView = this.leaf.view;
      return leafView !== null ? leafView.getCell(key, cellViewClass) : null;
    }
    getOrCreateCell(key, cellViewClass) {
      const leafView = this.leaf.insertView();
      if (leafView === null) {
        throw new Error("no leaf view");
      }
      return leafView.getOrCreateCell(key, cellViewClass);
    }
    setCell(key, cellView) {
      const leafView = this.leaf.insertView();
      if (leafView === null) {
        throw new Error("no leaf view");
      }
      leafView.setCell(key, cellView);
    }
    detectVisibleFrame(viewContext) {
      const xBleed = 0;
      const yBleed = this.rowHeight.getValueOr(math.Length.zero()).pxValue();
      const parentVisibleFrame = viewContext.visibleFrame;
      if (parentVisibleFrame !== void 0) {
        let left = this.left.state;
        left = left instanceof math.Length ? left.pxValue() : 0;
        let top = this.top.state;
        top = top instanceof math.Length ? top.pxValue() : 0;
        return new math.R2Box(parentVisibleFrame.xMin - left - xBleed, parentVisibleFrame.yMin - top - yBleed, parentVisibleFrame.xMax - left + xBleed, parentVisibleFrame.yMax - top + yBleed);
      } else {
        const bounds = this.node.getBoundingClientRect();
        const xMin = -bounds.x - xBleed;
        const yMin = -bounds.y - yBleed;
        const xMax = window.innerWidth - bounds.x + xBleed;
        const yMax = window.innerHeight - bounds.y + yBleed;
        return new math.R2Box(xMin, yMin, xMax, yMax);
      }
    }
    extendViewContext(viewContext) {
      const treeViewContext = Object.create(viewContext);
      treeViewContext.visibleFrame = this.visibleFrame;
      return treeViewContext;
    }
    onProcess(processFlags, viewContext) {
      super.onProcess(processFlags, viewContext);
      const visibleFrame = this.detectVisibleFrame(Object.getPrototypeOf(viewContext));
      this.visibleFrame = visibleFrame;
      viewContext.visibleFrame = this.visibleFrame;
    }
    needsProcess(processFlags, viewContext) {
      if ((processFlags & View.NeedsResize) !== 0) {
        processFlags |= View.NeedsScroll;
      }
      return processFlags;
    }
    onDisplay(displayFlags, viewContext) {
      super.onDisplay(displayFlags, viewContext);
      const visibleFrame = this.detectVisibleFrame(Object.getPrototypeOf(viewContext));
      this.visibleFrame = visibleFrame;
      viewContext.visibleFrame = this.visibleFrame;
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.resizeRow();
      const leafView = this.leaf.view;
      if (leafView !== null) {
        this.layoutLeaf(leafView);
      }
    }
    resizeRow() {
      const oldLayout = !this.layout.inherited ? this.layout.value : null;
      if (oldLayout !== null) {
        const superLayout = this.layout.superValue;
        let width = null;
        if (superLayout !== void 0 && superLayout !== null && superLayout.width !== null) {
          width = superLayout.width.pxValue();
        }
        if (width === null) {
          width = this.width.state;
          width = width instanceof math.Length ? width.pxValue() : this.node.offsetWidth;
        }
        const newLayout = oldLayout.resized(width, 0, 0);
        this.layout.setValue(newLayout);
      }
    }
    layoutLeaf(leafView) {
      const layout = this.layout.value;
      const width = layout !== null ? layout.width : null;
      const timing = this.getLook(Look.timing);
      leafView.top.setState(0, timing, component.Affinity.Intrinsic);
      leafView.width.setState(width, component.Affinity.Intrinsic);
    }
    didLayout(viewContext) {
      this.layoutRow();
      super.didLayout(viewContext);
    }
    layoutRow() {
      const layout = this.layout.value;
      const width = layout !== null ? layout.width : null;
      const rowSpacing = this.rowSpacing.getValueOr(math.Length.zero()).pxValue();
      const disclosure = this.disclosure.getValue();
      const disclosingPhase = this.disclosing.getPhaseOr(1);
      let leafHeightValue = 0;
      let leafHeightState = 0;
      const leafView = this.leaf.view;
      if (leafView !== null) {
        leafView.width.setState(width, component.Affinity.Intrinsic);
        leafView.display.setState("flex", component.Affinity.Intrinsic);
        leafHeightValue = leafView.height.value;
        leafHeightValue = leafHeightValue instanceof math.Length ? leafHeightValue.pxValue() : leafView.node.offsetHeight;
        leafHeightState = leafView.height.state;
        leafHeightState = leafHeightState instanceof math.Length ? leafHeightState.pxValue() : leafHeightValue;
      }
      const headView = this.head.view;
      if (headView !== null) {
        if (!disclosure.collapsed) {
          headView.top.setState(leafHeightValue, component.Affinity.Intrinsic);
          headView.width.setState(width, component.Affinity.Intrinsic);
          headView.height.setState(rowSpacing * disclosingPhase, component.Affinity.Intrinsic);
          headView.opacity.setState(disclosingPhase, component.Affinity.Intrinsic);
          headView.display.setState("block", component.Affinity.Intrinsic);
        } else {
          headView.display.setState("none", component.Affinity.Intrinsic);
        }
      }
      let treeHeightValue = 0;
      let treeHeightState = 0;
      const treeView = this.tree.view;
      if (treeView !== null) {
        if (!disclosure.collapsed) {
          treeView.top.setState((leafHeightValue + rowSpacing) * disclosingPhase, component.Affinity.Intrinsic);
          treeView.width.setState(width, component.Affinity.Intrinsic);
          treeView.display.setState("block", component.Affinity.Intrinsic);
          treeHeightValue = treeView.height.value;
          treeHeightValue = treeHeightValue instanceof math.Length ? treeHeightValue.pxValue() : treeView.node.offsetHeight;
          treeHeightValue += rowSpacing;
          treeHeightState = treeView.height.state;
          treeHeightState = treeHeightState instanceof math.Length ? treeHeightState.pxValue() : treeHeightValue;
          treeHeightState += rowSpacing;
        } else {
          treeView.display.setState("none", component.Affinity.Intrinsic);
        }
      }
      const footView = this.foot.view;
      if (footView !== null) {
        if (!disclosure.collapsed) {
          footView.top.setState(leafHeightValue + treeHeightValue, component.Affinity.Intrinsic);
          footView.width.setState(width, component.Affinity.Intrinsic);
          footView.height.setState(rowSpacing * disclosingPhase, component.Affinity.Intrinsic);
          footView.opacity.setState(disclosingPhase, component.Affinity.Intrinsic);
          footView.display.setState("block", component.Affinity.Intrinsic);
        } else {
          footView.display.setState("none", component.Affinity.Intrinsic);
        }
      }
      if (this.height.hasAffinity(component.Affinity.Intrinsic)) {
        const heightValue = leafHeightValue + treeHeightValue * disclosingPhase;
        const heightState = leafHeightState + treeHeightState;
        this.height.setInterpolatedValue(math.Length.px(heightValue), math.Length.px(heightState));
      }
    }
    onCull() {
      super.onCull();
      this.display.setState("none", component.Affinity.Intrinsic);
    }
    onUncull() {
      super.onUncull();
      this.display.setState("block", component.Affinity.Intrinsic);
    }
  }
  __decorate([ component.Property({
    type: TableLayout,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], RowView.prototype, "layout", void 0);
  __decorate([ component.Property({
    type: Number,
    inherits: true,
    value: 0,
    updateFlags: View.NeedsLayout,
    didSetValue(newDepth, oldDepth) {
      const treeView = this.owner.tree.view;
      if (treeView !== null) {
        treeView.depth.setValue(newDepth + 1, component.Affinity.Intrinsic);
      }
    }
  }) ], RowView.prototype, "depth", void 0);
  __decorate([ ThemeConstraintAnimator({
    type: math.Length,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], RowView.prototype, "rowSpacing", void 0);
  __decorate([ ThemeConstraintAnimator({
    type: math.Length,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], RowView.prototype, "rowHeight", void 0);
  __decorate([ component.Property({
    type: Boolean,
    inherits: true,
    value: false
  }) ], RowView.prototype, "hovers", void 0);
  __decorate([ component.Property({
    type: Boolean,
    inherits: true,
    value: true
  }) ], RowView.prototype, "glows", void 0);
  __decorate([ ViewRef({
    key: true,
    type: LeafView,
    binds: true,
    observes: true,
    initView(leafView) {
      leafView.display.setState("none", component.Affinity.Intrinsic);
      leafView.position.setState("absolute", component.Affinity.Intrinsic);
      leafView.left.setState(0, component.Affinity.Intrinsic);
      leafView.top.setState(0, component.Affinity.Intrinsic);
      const layout = this.owner.layout.value;
      leafView.width.setState(layout !== null ? layout.width : null, component.Affinity.Intrinsic);
      leafView.zIndex.setState(1, component.Affinity.Intrinsic);
    },
    willAttachView(leafView) {
      this.owner.callObservers("viewWillAttachLeaf", leafView, this.owner);
    },
    didDetachView(leafView) {
      this.owner.callObservers("viewDidDetachLeaf", leafView, this.owner);
    },
    viewWillHighlight(leafView) {
      this.owner.callObservers("viewWillHighlightLeaf", leafView, this.owner);
    },
    viewDidHighlight(leafView) {
      this.owner.callObservers("viewDidHighlightLeaf", leafView, this.owner);
    },
    viewWillUnhighlight(leafView) {
      this.owner.callObservers("viewWillUnhighlightLeaf", leafView, this.owner);
    },
    viewDidUnhighlight(leafView) {
      this.owner.callObservers("viewDidUnhighlightLeaf", leafView, this.owner);
    },
    viewDidEnter(leafView) {
      this.owner.callObservers("viewDidEnterLeaf", leafView, this.owner);
    },
    viewDidLeave(leafView) {
      this.owner.callObservers("viewDidLeaveLeaf", leafView, this.owner);
    },
    viewDidPress(input, event, leafView) {
      this.owner.callObservers("viewDidPressLeaf", input, event, leafView, this.owner);
    },
    viewDidLongPress(input, leafView) {
      this.owner.callObservers("viewDidLongPressLeaf", input, leafView, this.owner);
    }
  }) ], RowView.prototype, "leaf", void 0);
  __decorate([ ViewRef({
    key: true,
    type: HtmlView,
    binds: true,
    initView(headView) {
      headView.addClass("head");
      headView.display.setState("none", component.Affinity.Intrinsic);
      headView.position.setState("absolute", component.Affinity.Intrinsic);
      headView.left.setState(0, component.Affinity.Intrinsic);
      headView.top.setState(this.owner.rowHeight.state, component.Affinity.Intrinsic);
      const layout = this.owner.layout.value;
      headView.width.setState(layout !== null ? layout.width : null, component.Affinity.Intrinsic);
      headView.height.setState(this.owner.rowSpacing.state, component.Affinity.Intrinsic);
      headView.backgroundColor.setLook(Look.accentColor, component.Affinity.Intrinsic);
      headView.opacity.setState(this.owner.disclosing.phase, component.Affinity.Intrinsic);
      headView.zIndex.setState(1, component.Affinity.Intrinsic);
    }
  }) ], RowView.prototype, "head", void 0);
  __decorate([ ViewRef({
    key: true,
    binds: true,
    initView(treeView) {
      treeView.addClass("tree");
      treeView.display.setState(this.owner.disclosure.collapsed ? "none" : "block", component.Affinity.Intrinsic);
      treeView.position.setState("absolute", component.Affinity.Intrinsic);
      treeView.left.setState(0, component.Affinity.Intrinsic);
      const layout = this.owner.layout.value;
      treeView.width.setState(layout !== null ? layout.width : null, component.Affinity.Intrinsic);
      treeView.zIndex.setState(0, component.Affinity.Intrinsic);
      treeView.depth.setValue(this.owner.depth.value + 1, component.Affinity.Intrinsic);
    },
    willAttachView(treeView) {
      this.owner.callObservers("viewWillAttachTree", treeView, this.owner);
    },
    didDetachView(treeView) {
      this.owner.callObservers("viewDidDetachTree", treeView, this.owner);
    },
    createView() {
      return TableView.create();
    }
  }) ], RowView.prototype, "tree", void 0);
  __decorate([ ViewRef({
    key: true,
    type: HtmlView,
    binds: true,
    initView(footView) {
      footView.addClass("foot");
      footView.display.setState("none", component.Affinity.Intrinsic);
      footView.position.setState("absolute", component.Affinity.Intrinsic);
      footView.left.setState(0, component.Affinity.Intrinsic);
      footView.top.setState(this.owner.rowHeight.state, component.Affinity.Intrinsic);
      const layout = this.owner.layout.value;
      footView.width.setState(layout !== null ? layout.width : null, component.Affinity.Intrinsic);
      footView.height.setState(this.owner.rowSpacing.state, component.Affinity.Intrinsic);
      footView.backgroundColor.setLook(Look.borderColor, component.Affinity.Intrinsic);
      footView.opacity.setState(this.owner.disclosing.phase, component.Affinity.Intrinsic);
      footView.zIndex.setState(1, component.Affinity.Intrinsic);
    }
  }) ], RowView.prototype, "foot", void 0);
  __decorate([ ThemeAnimator({
    type: Expansion,
    value: Expansion.collapsed(),
    willExpand() {
      this.owner.callObservers("viewWillExpand", this.owner);
      const treeView = this.owner.tree.view;
      if (treeView !== null) {
        treeView.display.setState("block", component.Affinity.Intrinsic);
      }
    },
    didExpand() {
      this.owner.callObservers("viewDidExpand", this.owner);
    },
    willCollapse() {
      this.owner.callObservers("viewWillCollapse", this.owner);
    },
    didCollapse() {
      const treeView = this.owner.tree.view;
      if (treeView !== null) {
        treeView.display.setState("none", component.Affinity.Intrinsic);
      }
      this.owner.callObservers("viewDidCollapse", this.owner);
    },
    didSetValue(newDisclosure, oldDisclosure) {
      if (newDisclosure.direction !== 0) {
        this.owner.disclosing.setState(newDisclosure, component.Affinity.Intrinsic);
      } else {
        this.owner.disclosing.setState(null, component.Affinity.Intrinsic);
        this.owner.disclosing.setAffinity(component.Affinity.Transient);
      }
      const tableView = this.owner.getBase(TableView);
      if (tableView !== null) {
        tableView.requireUpdate(View.NeedsLayout);
      }
    }
  }) ], RowView.prototype, "disclosure", void 0);
  __decorate([ ThemeAnimator({
    type: Expansion,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], RowView.prototype, "disclosing", void 0);
  class RowTrait extends LeafTrait {}
  __decorate([ TraitRef({
    binds: true,
    willAttachTrait(treeTrait) {
      this.owner.callObservers("traitWillAttachTree", treeTrait, this.owner);
    },
    didDetachTrait(treeTrait) {
      this.owner.callObservers("traitDidDetachTree", treeTrait, this.owner);
    },
    detectModel(model) {
      return model.getTrait(TableTrait);
    },
    detectTrait(trait) {
      return trait instanceof TableTrait ? trait : null;
    },
    createTrait() {
      return TableTrait.create();
    }
  }) ], RowTrait.prototype, "tree", void 0);
  class RowController extends LeafController {}
  __decorate([ TraitViewRef({
    traitType: RowTrait,
    observesTrait: true,
    initTrait(rowTrait) {
      if (this.owner.leaf.trait === null) {
        this.owner.leaf.setTrait(rowTrait);
      }
      const treeTrait = rowTrait.tree.trait;
      if (treeTrait !== null) {
        this.owner.tree.setTrait(treeTrait);
      }
    },
    deinitTrait(rowTrait) {
      const treeTrait = rowTrait.tree.trait;
      if (treeTrait !== null) {
        this.owner.tree.deleteTrait(treeTrait);
      }
      if (this.owner.leaf.trait === rowTrait) {
        this.owner.leaf.setTrait(null);
      }
    },
    willAttachTrait(rowTrait) {
      this.owner.callObservers("controllerWillAttachRowTrait", rowTrait, this.owner);
    },
    didDetachTrait(rowTrait) {
      this.owner.callObservers("controllerDidDetachRowTrait", rowTrait, this.owner);
    },
    traitWillAttachTree(treeTrait) {
      this.owner.tree.setTrait(treeTrait);
    },
    traitDidDetachTree(treeTrait) {
      this.owner.tree.deleteTrait(treeTrait);
    },
    viewType: RowView,
    observesView: true,
    initView(rowView) {
      if (this.owner.leaf.view === null) {
        const leafView = rowView.leaf.insertView();
        this.owner.leaf.setView(leafView);
      }
      const treeController = this.owner.tree.controller;
      if (treeController !== null) {
        treeController.table.insertView(rowView);
      }
    },
    willAttachView(rowView) {
      this.owner.callObservers("controllerWillAttachRowView", rowView, this.owner);
    },
    didDetachView(rowView) {
      this.owner.callObservers("controllerDidDetachRowView", rowView, this.owner);
    },
    viewWillExpand(rowView) {
      this.owner.callObservers("controllerWillExpandRowView", rowView, this.owner);
    },
    viewDidExpand(rowView) {
      this.owner.callObservers("controllerDidExpandRowView", rowView, this.owner);
    },
    viewWillCollapse(rowView) {
      this.owner.callObservers("controllerWillCollapseRowView", rowView, this.owner);
    },
    viewDidCollapse(rowView) {
      this.owner.callObservers("controllerDidCollapseRowView", rowView, this.owner);
    },
    viewWillAttachTree(treeView) {
      const treeController = this.owner.tree.controller;
      if (treeController !== null) {
        treeController.table.setView(treeView);
      }
    }
  }) ], RowController.prototype, "row", void 0);
  __decorate([ TraitViewControllerRef({
    implements: true,
    binds: true,
    observes: true,
    get parentView() {
      return this.owner.row.view;
    },
    getTraitViewRef(treeController) {
      return treeController.table;
    },
    initController(treeController) {
      const treeTrait = treeController.table.trait;
      if (treeTrait !== null) {
        this.attachTreeTrait(treeTrait, treeController);
      }
      const treeView = treeController.table.view;
      if (treeView !== null) {
        this.attachTreeView(treeView, treeController);
      }
      const rowTrait = this.owner.row.trait;
      if (rowTrait !== null) {
        const treeTrait = rowTrait.tree.trait;
        if (treeTrait !== null) {
          treeController.table.setTrait(treeTrait);
        }
      }
    },
    deinitController(treeController) {
      const treeTrait = treeController.table.trait;
      if (treeTrait !== null) {
        this.detachTreeTrait(treeTrait, treeController);
      }
      const treeView = treeController.table.view;
      if (treeView !== null) {
        this.detachTreeView(treeView, treeController);
      }
    },
    willAttachController(treeController) {
      this.owner.callObservers("controllerWillAttachTree", treeController, this.owner);
    },
    didDetachController(treeController) {
      this.owner.callObservers("controllerDidDetachTree", treeController, this.owner);
    },
    controllerWillAttachTreeTrait(treeTrait, treeController) {
      this.owner.callObservers("controllerWillAttachTreeTrait", treeTrait, treeController, this.owner);
      this.attachTreeTrait(treeTrait, treeController);
    },
    controllerDidDetachTreeTrait(treeTrait, treeController) {
      this.detachTreeTrait(treeTrait, treeController);
      this.owner.callObservers("controllerDidDetachTreeTrait", treeTrait, treeController, this.owner);
    },
    attachTreeTrait(treeTrait, treeController) {},
    detachTreeTrait(treeTrait, treeController) {},
    controllerWillAttachTableView(treeView, treeController) {
      this.owner.callObservers("controllerWillAttachTreeView", treeView, treeController, this.owner);
      this.attachTreeView(treeView, treeController);
    },
    controllerDidDetachTableView(treeView, treeController) {
      this.detachTreeView(treeView, treeController);
      this.owner.callObservers("controllerDidDetachTreeView", treeView, treeController, this.owner);
    },
    attachTreeView(treeView, treeController) {},
    detachTreeView(treeView, treeController) {
      treeView.remove();
    },
    detectController(controller) {
      return controller instanceof TableController ? controller : null;
    },
    createController() {
      return TableController.create();
    }
  }) ], RowController.prototype, "tree", void 0);
  class ColView extends HtmlView {
    constructor(node) {
      super(node);
      this.initCol();
    }
    initCol() {
      this.addClass("col");
      this.overflowX.setState("hidden", component.Affinity.Intrinsic);
      this.overflowY.setState("hidden", component.Affinity.Intrinsic);
    }
  }
  __decorate([ ViewRef({
    implements: true,
    key: true,
    type: HtmlView,
    binds: true,
    willAttachView(labelView) {
      this.owner.callObservers("viewWillAttachLabel", labelView, this.owner);
    },
    didDetachView(labelView) {
      this.owner.callObservers("viewDidDetachLabel", labelView, this.owner);
    },
    createView(value) {
      const labelView = HtmlView.fromTag("span");
      labelView.alignSelf.setState("center", component.Affinity.Intrinsic);
      labelView.whiteSpace.setState("nowrap", component.Affinity.Intrinsic);
      labelView.textOverflow.setState("ellipsis", component.Affinity.Intrinsic);
      labelView.overflowX.setState("hidden", component.Affinity.Intrinsic);
      labelView.overflowY.setState("hidden", component.Affinity.Intrinsic);
      labelView.color.setLook(Look.neutralColor, component.Affinity.Intrinsic);
      if (value !== void 0) {
        labelView.text(value);
      }
      return labelView;
    },
    fromAny(value) {
      if (typeof value === "string") {
        return this.createView(value);
      } else {
        return HtmlView.fromAny(value);
      }
    }
  }) ], ColView.prototype, "label", void 0);
  class ColTrait extends Trait {}
  __decorate([ component.Property({
    type: ColLayout,
    value: null,
    willSetValue(newLayout, oldLayout) {
      this.owner.callObservers("traitWillSetLayout", newLayout, oldLayout, this.owner);
    },
    didSetValue(newLayout, oldLayout) {
      this.owner.callObservers("traitDidSetLayout", newLayout, oldLayout, this.owner);
    }
  }) ], ColTrait.prototype, "layout", void 0);
  __decorate([ component.Property({
    value: null,
    willSetValue(newLabel, oldLabel) {
      this.owner.callObservers("traitWillSetLabel", newLabel, oldLabel, this.owner);
    },
    didSetValue(newLabel, oldLabel) {
      this.owner.callObservers("traitDidSetLabel", newLabel, oldLabel, this.owner);
    }
  }) ], ColTrait.prototype, "label", void 0);
  class ColController extends Controller {
    createLabelView(label, colTrait) {
      if (typeof label === "function") {
        return label(colTrait);
      } else {
        return label;
      }
    }
    setLabelView(label, colTrait) {
      const colView = this.col.view;
      if (colView !== null) {
        const labelView = label !== null ? this.createLabelView(label, colTrait) : null;
        colView.label.setView(labelView);
      }
    }
  }
  __decorate([ TraitViewRef({
    traitType: ColTrait,
    observesTrait: true,
    initTrait(colTrait) {
      const colView = this.view;
      if (colView !== null) {
        this.owner.setLabelView(colTrait.label.value, colTrait);
      }
    },
    deinitTrait(colTrait) {
      const colView = this.view;
      if (colView !== null) {
        this.owner.setLabelView(null, colTrait);
      }
    },
    willAttachTrait(colTrait) {
      this.owner.callObservers("controllerWillAttachColTrait", colTrait, this.owner);
    },
    didDetachTrait(colTrait) {
      this.owner.callObservers("controllerDidDetachColTrait", colTrait, this.owner);
    },
    traitWillSetLayout(newLayout, oldLayout) {
      this.owner.callObservers("controllerWillSetColLayout", newLayout, oldLayout, this.owner);
    },
    traitDidSetLayout(newLayout, oldLayout) {
      this.owner.callObservers("controllerDidSetColLayout", newLayout, oldLayout, this.owner);
    },
    traitDidSetLabel(newLabel, oldLabel, colTrait) {
      this.owner.setLabelView(newLabel, colTrait);
    },
    viewType: ColView,
    observesView: true,
    initView(colView) {
      this.owner.label.setView(colView.label.view);
      const colTrait = this.trait;
      if (colTrait !== null) {
        this.owner.setLabelView(colTrait.label.value, colTrait);
      }
    },
    deinitView(colView) {
      this.owner.label.setView(null);
    },
    willAttachView(colView) {
      this.owner.callObservers("controllerWillAttachColView", colView, this.owner);
    },
    didDetachView(colView) {
      this.owner.callObservers("controllerDidDetachColView", colView, this.owner);
    },
    viewWillAttachLabel(labelView) {
      this.owner.label.setView(labelView);
    },
    viewDidDetachLabel(labelView) {
      this.owner.label.setView(null);
    }
  }) ], ColController.prototype, "col", void 0);
  __decorate([ ViewRef({
    type: HtmlView,
    willAttachView(labelView) {
      this.owner.callObservers("controllerWillAttachColLabelView", labelView, this.owner);
    },
    didDetachView(labelView) {
      this.owner.callObservers("controllerDidDetachColLabelView", labelView, this.owner);
    }
  }) ], ColController.prototype, "label", void 0);
  class HeaderView extends HtmlView {
    constructor(node) {
      super(node);
      this.initHeader();
    }
    initHeader() {
      this.addClass("header");
      this.position.setState("relative", component.Affinity.Intrinsic);
      this.overflowX.setState("hidden", component.Affinity.Intrinsic);
      this.overflowY.setState("hidden", component.Affinity.Intrinsic);
    }
    getCol(key, colViewClass) {
      if (colViewClass === void 0) {
        colViewClass = ColView;
      }
      const colView = this.getChild(key);
      return colView instanceof colViewClass ? colView : null;
    }
    getOrCreateCol(key, colViewClass) {
      if (colViewClass === void 0) {
        colViewClass = ColView;
      }
      let colView = this.getChild(key);
      if (!(colView instanceof colViewClass)) {
        colView = colViewClass.create();
        this.setChild(key, colView);
      }
      return colView;
    }
    setCol(key, colView) {
      this.setChild(key, colView);
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.layoutHeader();
    }
    layoutHeader() {
      const rowHeight = this.rowHeight.value;
      if (rowHeight !== null) {
        this.height.setState(rowHeight, component.Affinity.Intrinsic);
      }
    }
    displayChildren(displayFlags, viewContext, displayChild) {
      if ((displayFlags & View.NeedsLayout) !== 0) {
        this.layoutChildViews(displayFlags, viewContext, displayChild);
      } else {
        super.displayChildren(displayFlags, viewContext, displayChild);
      }
    }
    layoutChildViews(displayFlags, viewContext, displayChild) {
      const layout = this.layout.value;
      const height = this.height.state;
      const stretch = this.stretch.getPhaseOr(1);
      function layoutChildView(child, displayFlags, viewContext) {
        if (child instanceof ColView) {
          const key = child.key;
          const col = layout !== null && key !== void 0 ? layout.getCol(key) : null;
          if (col !== null) {
            child.display.setState(!col.hidden ? "flex" : "none", component.Affinity.Intrinsic);
            child.left.setState(col.left, component.Affinity.Intrinsic);
            child.width.setState(col.width, component.Affinity.Intrinsic);
            child.height.setState(height, component.Affinity.Intrinsic);
            const textColor = col.textColor;
            if (textColor instanceof Look) {
              child.color.setLook(textColor, component.Affinity.Intrinsic);
            } else {
              child.color.setState(textColor, component.Affinity.Intrinsic);
            }
            if (!col.persistent) {
              child.opacity.setState(stretch, component.Affinity.Intrinsic);
            }
          } else {
            child.display.setState("none", component.Affinity.Intrinsic);
            child.left.setState(null, component.Affinity.Intrinsic);
            child.width.setState(null, component.Affinity.Intrinsic);
            child.height.setState(null, component.Affinity.Intrinsic);
          }
        }
        displayChild.call(this, child, displayFlags, viewContext);
      }
      super.displayChildren(displayFlags, viewContext, layoutChildView);
    }
  }
  __decorate([ component.Property({
    type: TableLayout,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], HeaderView.prototype, "layout", void 0);
  __decorate([ component.Property({
    type: Number,
    inherits: true,
    value: 0,
    updateFlags: View.NeedsLayout
  }) ], HeaderView.prototype, "depth", void 0);
  __decorate([ ThemeConstraintAnimator({
    type: math.Length,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], HeaderView.prototype, "rowSpacing", void 0);
  __decorate([ ThemeConstraintAnimator({
    type: math.Length,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], HeaderView.prototype, "rowHeight", void 0);
  __decorate([ ThemeAnimator({
    type: Expansion,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], HeaderView.prototype, "stretch", void 0);
  __decorate([ ViewSet({
    type: ColView,
    binds: true,
    initView(colView) {
      colView.display.setState("none", component.Affinity.Intrinsic);
      colView.position.setState("absolute", component.Affinity.Intrinsic);
      colView.left.setState(0, component.Affinity.Intrinsic);
      colView.top.setState(0, component.Affinity.Intrinsic);
      colView.width.setState(0, component.Affinity.Intrinsic);
      colView.height.setState(this.owner.height.state, component.Affinity.Intrinsic);
    },
    willAttachView(colView, target) {
      this.owner.callObservers("viewWillAttachCol", colView, target, this.owner);
    },
    didDetachView(colView) {
      this.owner.callObservers("viewDidDetachCol", colView, this.owner);
    }
  }) ], HeaderView.prototype, "cols", void 0);
  class HeaderTrait extends Trait {
    getCol(key, colTraitClass) {
      if (colTraitClass === void 0) {
        colTraitClass = ColTrait;
      }
      const colTrait = this.getTrait(key);
      return colTrait instanceof colTraitClass ? colTrait : null;
    }
    getOrCreateCol(key, colTraitConstructor) {
      if (colTraitConstructor === void 0) {
        colTraitConstructor = ColTrait;
      }
      let colTrait = this.getTrait(key);
      if (!(colTrait instanceof colTraitConstructor)) {
        colTrait = new colTraitConstructor;
        this.setTrait(key, colTrait);
      }
      return colTrait;
    }
    setCol(key, colTrait) {
      this.setTrait(key, colTrait);
    }
    startConsumingCols() {
      const colTraits = this.cols.traits;
      for (const traitId in colTraits) {
        const colTrait = colTraits[traitId];
        colTrait.consume(this);
      }
    }
    stopConsumingCols() {
      const colTraits = this.cols.traits;
      for (const traitId in colTraits) {
        const colTrait = colTraits[traitId];
        colTrait.unconsume(this);
      }
    }
    onStartConsuming() {
      super.onStartConsuming();
      this.startConsumingCols();
    }
    onStopConsuming() {
      super.onStopConsuming();
      this.stopConsumingCols();
    }
  }
  __decorate([ TraitSet({
    type: ColTrait,
    binds: true,
    willAttachTrait(colTrait, targetTrait) {
      this.owner.callObservers("traitWillAttachCol", colTrait, targetTrait, this.owner);
    },
    didAttachTrait(colTrait) {
      if (this.owner.consuming) {
        colTrait.consume(this.owner);
      }
    },
    willDetachTrait(colTrait) {
      if (this.owner.consuming) {
        colTrait.unconsume(this.owner);
      }
    },
    didDetachTrait(colTrait) {
      this.owner.callObservers("traitDidDetachCol", colTrait, this.owner);
    },
    detectModel(model) {
      return model.getTrait(ColTrait);
    }
  }) ], HeaderTrait.prototype, "cols", void 0);
  class HeaderController extends Controller {
    getColTrait(key, colTraitClass) {
      const headerTrait = this.header.trait;
      return headerTrait !== null ? headerTrait.getCol(key, colTraitClass) : null;
    }
    getOrCreateColTrait(key, colTraitConstructor) {
      const headerTrait = this.header.trait;
      if (headerTrait === null) {
        throw new Error("no header trait");
      }
      return headerTrait.getOrCreateCol(key, colTraitConstructor);
    }
    setColTrait(key, colTrait) {
      const headerTrait = this.header.trait;
      if (headerTrait === null) {
        throw new Error("no header trait");
      }
      headerTrait.setCol(key, colTrait);
    }
    getColView(key, colViewClass) {
      const headerView = this.header.view;
      return headerView !== null ? headerView.getCol(key, colViewClass) : null;
    }
    getOrCreateColView(key, colViewClass) {
      let headerView = this.header.view;
      if (headerView === null) {
        headerView = this.header.createView();
        if (headerView === null) {
          throw new Error("no header view");
        }
        this.header.setView(headerView);
      }
      return headerView.getOrCreateCol(key, colViewClass);
    }
    setColView(key, colView) {
      let headerView = this.header.view;
      if (headerView === null) {
        headerView = this.header.createView();
        if (headerView === null) {
          throw new Error("no header view");
        }
        this.header.setView(headerView);
      }
      headerView.setCol(key, colView);
    }
  }
  __decorate([ TraitViewRef({
    traitType: HeaderTrait,
    observesTrait: true,
    willAttachTrait(headerTrait) {
      this.owner.callObservers("controllerWillAttachHeaderTrait", headerTrait, this.owner);
    },
    didAttachTrait(headerTrait) {
      const colTraits = headerTrait.cols.traits;
      for (const traitId in colTraits) {
        const colTrait = colTraits[traitId];
        this.owner.cols.addTraitController(colTrait);
      }
    },
    willDetachTrait(headerTrait) {
      const colTraits = headerTrait.cols.traits;
      for (const traitId in colTraits) {
        const colTrait = colTraits[traitId];
        this.owner.cols.deleteTraitController(colTrait);
      }
    },
    didDetachTrait(headerTrait) {
      this.owner.callObservers("controllerDidDetachHeaderTrait", headerTrait, this.owner);
    },
    traitWillAttachCol(colTrait, targetTrait) {
      this.owner.cols.addTraitController(colTrait, targetTrait);
    },
    traitDidDetachCol(colTrait) {
      this.owner.cols.deleteTraitController(colTrait);
    },
    viewType: HeaderView,
    observesView: true,
    initView(headerView) {
      const colControllers = this.owner.cols.controllers;
      for (const controllerId in colControllers) {
        const colController = colControllers[controllerId];
        const colView = colController.col.view;
        if (colView !== null && colView.parent === null) {
          const colTrait = colController.col.trait;
          if (colTrait !== null) {
            colController.col.insertView(headerView, void 0, void 0, colTrait.key);
          }
        }
      }
    },
    willAttachView(headerView) {
      this.owner.callObservers("controllerWillAttachHeaderView", headerView, this.owner);
    },
    didDetachView(headerView) {
      this.owner.callObservers("controllerDidDetachHeaderView", headerView, this.owner);
    },
    insertChildView(parent, childView, targetView, key) {
      parent.prependChild(childView, key);
    }
  }) ], HeaderController.prototype, "header", void 0);
  __decorate([ TraitViewControllerSet({
    implements: true,
    type: ColController,
    binds: true,
    observes: true,
    get parentView() {
      return this.owner.header.view;
    },
    getTraitViewRef(colController) {
      return colController.col;
    },
    willAttachController(colController) {
      this.owner.callObservers("controllerWillAttachCol", colController, this.owner);
    },
    didAttachController(colController) {
      const colTrait = colController.col.trait;
      if (colTrait !== null) {
        this.attachColTrait(colTrait, colController);
      }
      const colView = colController.col.view;
      if (colView !== null) {
        this.attachColView(colView, colController);
      }
    },
    willDetachController(colController) {
      const colView = colController.col.view;
      if (colView !== null) {
        this.detachColView(colView, colController);
      }
      const colTrait = colController.col.trait;
      if (colTrait !== null) {
        this.detachColTrait(colTrait, colController);
      }
    },
    didDetachController(colController) {
      this.owner.callObservers("controllerDidDetachCol", colController, this.owner);
    },
    controllerWillAttachColTrait(colTrait, colController) {
      this.owner.callObservers("controllerWillAttachColTrait", colTrait, colController, this.owner);
      this.attachColTrait(colTrait, colController);
    },
    controllerDidDetachColTrait(colTrait, colController) {
      this.detachColTrait(colTrait, colController);
      this.owner.callObservers("controllerDidDetachColTrait", colTrait, colController, this.owner);
    },
    attachColTrait(colTrait, colController) {},
    detachColTrait(colTrait, colController) {},
    controllerWillAttachColView(colView, colController) {
      this.owner.callObservers("controllerWillAttachColView", colView, colController, this.owner);
      this.attachColView(colView, colController);
    },
    controllerDidDetachColView(colView, colController) {
      this.detachColView(colView, colController);
      this.owner.callObservers("controllerDidDetachColView", colView, colController, this.owner);
    },
    attachColView(colView, colController) {
      const colLabelView = colView.label.view;
      if (colLabelView !== null) {
        this.attachColLabelView(colLabelView, colController);
      }
    },
    detachColView(colView, colController) {
      const colLabelView = colView.label.view;
      if (colLabelView !== null) {
        this.detachColLabelView(colLabelView, colController);
      }
      colView.remove();
    },
    controllerWillSetColLayout(newColLayout, oldColLayout, colController) {
      this.owner.callObservers("controllerWillSetColLayout", newColLayout, oldColLayout, colController, this.owner);
    },
    controllerDidSetColLayout(newColLayout, oldColLayout, colController) {
      this.owner.callObservers("controllerDidSetColLayout", newColLayout, oldColLayout, colController, this.owner);
    },
    controllerWillAttachColLabelView(colLabelView, colController) {
      this.owner.callObservers("controllerWillAttachColLabelView", colLabelView, colController, this.owner);
      this.attachColLabelView(colLabelView, colController);
    },
    controllerDidDetachColLabelView(colLabelView, colController) {
      this.detachColLabelView(colLabelView, colController);
      this.owner.callObservers("controllerDidDetachColLabelView", colLabelView, colController, this.owner);
    },
    attachColLabelView(colLabelView, colController) {},
    detachColLabelView(colLabelView, colController) {}
  }) ], HeaderController.prototype, "cols", void 0);
  class TableView extends HtmlView {
    constructor(node) {
      super(node);
      this.visibleViews = [];
      this.visibleFrame = new math.R2Box(0, 0, window.innerWidth, window.innerHeight);
      this.initTable();
    }
    initTable() {
      this.addClass("table");
      this.position.setState("relative", component.Affinity.Intrinsic);
      this.backgroundColor.setLook(Look.backgroundColor, component.Affinity.Intrinsic);
    }
    detectVisibleFrame(viewContext) {
      const xBleed = 0;
      const yBleed = this.rowHeight.getValueOr(math.Length.zero()).pxValue();
      const parentVisibleFrame = viewContext.visibleFrame;
      if (parentVisibleFrame !== void 0) {
        let left = this.left.state;
        left = left instanceof math.Length ? left.pxValue() : 0;
        let top = this.top.state;
        top = top instanceof math.Length ? top.pxValue() : 0;
        return new math.R2Box(parentVisibleFrame.xMin - left - xBleed, parentVisibleFrame.yMin - top - yBleed, parentVisibleFrame.xMax - left + xBleed, parentVisibleFrame.yMax - top + yBleed);
      } else {
        const bounds = this.node.getBoundingClientRect();
        const xMin = -bounds.x - xBleed;
        const yMin = -bounds.y - yBleed;
        const xMax = window.innerWidth - bounds.x + xBleed;
        const yMax = window.innerHeight - bounds.y + yBleed;
        return new math.R2Box(xMin, yMin, xMax, yMax);
      }
    }
    extendViewContext(viewContext) {
      const treeViewContext = Object.create(viewContext);
      treeViewContext.visibleFrame = this.visibleFrame;
      return treeViewContext;
    }
    needsProcess(processFlags, viewContext) {
      if ((processFlags & View.NeedsResize) !== 0) {
        processFlags |= View.NeedsScroll;
      }
      return processFlags;
    }
    onResize(viewContext) {
      super.onResize(viewContext);
      this.resizeTable();
    }
    resizeTable() {
      const oldLayout = !this.layout.inherited ? this.layout.value : null;
      if (oldLayout !== null) {
        const superLayout = this.layout.superValue;
        let width = null;
        if (superLayout !== void 0 && superLayout !== null && superLayout.width !== null) {
          width = superLayout.width.pxValue();
        }
        if (width === null) {
          width = this.width.state;
          width = width instanceof math.Length ? width.pxValue() : this.node.offsetWidth;
        }
        const edgeInsets = this.edgeInsets.value;
        let paddingLeft = this.paddingLeft.state;
        paddingLeft = paddingLeft instanceof math.Length ? paddingLeft.pxValue(width) : 0;
        let paddingRight = this.paddingRight.state;
        paddingRight = paddingRight instanceof math.Length ? paddingRight.pxValue(width) : 0;
        let left = edgeInsets !== null ? edgeInsets.insetLeft : 0;
        left += paddingLeft;
        let right = edgeInsets !== null ? edgeInsets.insetRight : 0;
        right += paddingRight;
        const newLayout = oldLayout.resized(width, left, right);
        this.layout.setValue(newLayout);
      }
    }
    processVisibleViews(processFlags, viewContext, processChild) {
      const visibleViews = this.visibleViews;
      let i = 0;
      while (i < visibleViews.length) {
        const child = visibleViews[i];
        processChild.call(this, child, processFlags, viewContext);
        if ((child.flags & View.RemovingFlag) !== 0) {
          child.setFlags(child.flags & ~View.RemovingFlag);
          this.removeChild(child);
          continue;
        }
        i += 1;
      }
    }
    processChildren(processFlags, viewContext, processChild) {
      if (!this.culled) {
        if ((processFlags & View.NeedsScroll) !== 0) {
          this.scrollChildViews(processFlags, viewContext, processChild);
        } else {
          this.processVisibleViews(processFlags, viewContext, processChild);
        }
      }
    }
    scrollChildViews(processFlags, viewContext, processChild) {
      const visibleViews = this.visibleViews;
      visibleViews.length = 0;
      const visibleFrame = this.detectVisibleFrame(Object.getPrototypeOf(viewContext));
      viewContext.visibleFrame = visibleFrame;
      this.visibleFrame = visibleFrame;
      function scrollChildView(child, processFlags, viewContext) {
        let isVisible;
        if (child instanceof HtmlView) {
          const top = child.top.state;
          const height = child.height.state;
          if (top instanceof math.Length && height instanceof math.Length) {
            const yMin0 = visibleFrame.yMin;
            const yMax0 = visibleFrame.yMax;
            const yMin1 = top.pxValue();
            const yMax1 = yMin1 + height.pxValue();
            isVisible = yMin0 <= yMax1 && yMin1 <= yMax0;
            child.display.setState(isVisible ? "flex" : "none", component.Affinity.Intrinsic);
            child.setCulled(!isVisible);
          } else {
            isVisible = true;
          }
        } else {
          isVisible = true;
        }
        if (isVisible) {
          visibleViews.push(child);
          processChild.call(this, child, processFlags, viewContext);
        }
      }
      super.processChildren(processFlags, viewContext, scrollChildView);
    }
    displayVisibleViews(displayFlags, viewContext, displayChild) {
      const visibleViews = this.visibleViews;
      let i = 0;
      while (i < visibleViews.length) {
        const child = visibleViews[i];
        displayChild.call(this, child, displayFlags, viewContext);
        if ((child.flags & View.RemovingFlag) !== 0) {
          child.setFlags(child.flags & ~View.RemovingFlag);
          this.removeChild(child);
          continue;
        }
        i += 1;
      }
    }
    displayChildren(displayFlags, viewContext, displayChild) {
      if ((displayFlags & View.NeedsLayout) !== 0) {
        this.layoutChildViews(displayFlags, viewContext, displayChild);
      } else {
        this.displayVisibleViews(displayFlags, viewContext, displayChild);
      }
    }
    layoutChildViews(displayFlags, viewContext, displayChild) {
      this.resizeTable();
      const layout = this.layout.value;
      const width = layout !== null ? layout.width : null;
      const rowHeight = this.rowHeight.getValue();
      const rowSpacing = this.rowSpacing.getValue().pxValue(rowHeight.pxValue());
      const disclosingPhase = this.disclosing.getPhaseOr(1);
      const visibleViews = this.visibleViews;
      visibleViews.length = 0;
      const visibleFrame = this.detectVisibleFrame(Object.getPrototypeOf(viewContext));
      viewContext.visibleFrame = visibleFrame;
      this.visibleFrame = visibleFrame;
      let yValue = 0;
      let yState = 0;
      let rowIndex = 0;
      function layoutChildView(child, displayFlags, viewContext) {
        if (child instanceof RowView || child instanceof HeaderView) {
          if (rowIndex !== 0) {
            yValue += rowSpacing * disclosingPhase;
            yState += rowSpacing;
          }
          if (child.top.hasAffinity(component.Affinity.Intrinsic)) {
            child.top.setInterpolatedValue(math.Length.px(yValue), math.Length.px(yState));
          }
          child.width.setState(width, component.Affinity.Intrinsic);
        }
        let isVisible;
        if (child instanceof HtmlView) {
          const top = child.top.state;
          const height = child.height.state;
          if (top instanceof math.Length && height instanceof math.Length) {
            const yMin0 = visibleFrame.yMin;
            const yMax0 = visibleFrame.yMax;
            const yMin1 = top.pxValue();
            const yMax1 = yMin1 + height.pxValue();
            isVisible = yMin0 <= yMax1 && yMin1 <= yMax0;
          } else {
            isVisible = true;
          }
          child.display.setState(isVisible ? "flex" : "none", component.Affinity.Intrinsic);
          child.setCulled(!isVisible);
        } else {
          isVisible = true;
        }
        if (isVisible) {
          visibleViews.push(child);
        }
        displayChild.call(this, child, displayFlags, viewContext);
        if (child instanceof RowView || child instanceof HeaderView) {
          let heightValue = child.height.value;
          heightValue = heightValue instanceof math.Length ? heightValue.pxValue() : child.node.offsetHeight;
          let heightState = child.height.state;
          heightState = heightState instanceof math.Length ? heightState.pxValue() : heightValue;
          yValue += heightValue * disclosingPhase;
          yState += heightState;
          rowIndex += 1;
        }
      }
      super.displayChildren(displayFlags, viewContext, layoutChildView);
      if (this.height.hasAffinity(component.Affinity.Intrinsic)) {
        this.height.setInterpolatedValue(math.Length.px(yValue), math.Length.px(yState));
      }
      const disclosurePhase = this.disclosure.getPhaseOr(1);
      this.opacity.setState(disclosurePhase, component.Affinity.Intrinsic);
    }
  }
  __decorate([ component.Property({
    type: TableLayout,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], TableView.prototype, "layout", void 0);
  __decorate([ component.Property({
    type: Object,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], TableView.prototype, "edgeInsets", void 0);
  __decorate([ component.Property({
    type: Number,
    inherits: true,
    value: 0,
    updateFlags: View.NeedsLayout,
    didSetValue(newDepth, oldDepth) {
      this.owner.modifyTheme(Feel.default, [ [ Feel.nested, newDepth !== 0 ? 1 : void 0 ] ], false);
    }
  }) ], TableView.prototype, "depth", void 0);
  __decorate([ ThemeConstraintAnimator({
    type: math.Length,
    inherits: true,
    value: math.Length.zero(),
    updateFlags: View.NeedsLayout
  }) ], TableView.prototype, "rowSpacing", void 0);
  __decorate([ ThemeConstraintAnimator({
    type: math.Length,
    inherits: true,
    value: math.Length.px(24),
    updateFlags: View.NeedsLayout
  }) ], TableView.prototype, "rowHeight", void 0);
  __decorate([ component.Property({
    type: Boolean,
    inherits: true,
    value: false
  }) ], TableView.prototype, "hovers", void 0);
  __decorate([ component.Property({
    type: Boolean,
    inherits: true,
    value: true
  }) ], TableView.prototype, "glows", void 0);
  __decorate([ ThemeAnimator({
    type: Expansion,
    inherits: true,
    value: null
  }) ], TableView.prototype, "disclosure", void 0);
  __decorate([ ThemeAnimator({
    type: Expansion,
    inherits: true,
    value: null
  }) ], TableView.prototype, "disclosing", void 0);
  __decorate([ ThemeAnimator({
    type: Expansion,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout
  }) ], TableView.prototype, "stretch", void 0);
  __decorate([ ViewRef({
    key: true,
    type: HeaderView,
    binds: true,
    initView(headerView) {
      headerView.display.setState("none", component.Affinity.Intrinsic);
      headerView.position.setState("absolute", component.Affinity.Intrinsic);
      headerView.left.setState(0, component.Affinity.Intrinsic);
      headerView.top.setState(null, component.Affinity.Intrinsic);
      const layout = this.owner.layout.value;
      headerView.width.setState(layout !== null ? layout.width : null, component.Affinity.Intrinsic);
      headerView.setCulled(true);
    },
    willAttachView(headerView) {
      this.owner.callObservers("viewWillAttachHeader", headerView, this.owner);
    },
    didDetachView(headerView) {
      this.owner.callObservers("viewDidDetachHeader", headerView, this.owner);
    },
    insertChild(parent, child, target, key) {
      parent.prependChild(child, key);
    }
  }) ], TableView.prototype, "header", void 0);
  __decorate([ ViewSet({
    type: RowView,
    binds: true,
    observes: true,
    initView(rowView) {
      rowView.display.setState("none", component.Affinity.Intrinsic);
      rowView.position.setState("absolute", component.Affinity.Intrinsic);
      rowView.left.setState(0, component.Affinity.Intrinsic);
      rowView.top.setState(null, component.Affinity.Intrinsic);
      const layout = this.owner.layout.value;
      rowView.width.setState(layout !== null ? layout.width : null, component.Affinity.Intrinsic);
      rowView.setCulled(true);
    },
    willAttachView(rowView, target) {
      this.owner.callObservers("viewWillAttachRow", rowView, target, this.owner);
    },
    didDetachView(rowView) {
      this.owner.callObservers("viewDidDetachRow", rowView, this.owner);
    },
    viewWillAttachLeaf(leafView, rowView) {
      this.owner.callObservers("viewWillAttachLeaf", leafView, rowView);
    },
    viewDidDetachLeaf(leafView, rowView) {
      this.owner.callObservers("viewDidDetachLeaf", leafView, rowView);
    },
    viewDidEnterLeaf(leafView, rowView) {
      this.owner.callObservers("viewDidEnterLeaf", leafView, rowView);
    },
    viewDidLeaveLeaf(leafView, rowView) {
      this.owner.callObservers("viewDidLeaveLeaf", leafView, rowView);
    },
    viewDidPressLeaf(input, event, leafView, rowView) {
      this.owner.callObservers("viewDidPressLeaf", input, event, leafView, rowView);
    },
    viewDidLongPressLeaf(input, leafView, rowView) {
      this.owner.callObservers("viewDidLongPressLeaf", input, leafView, rowView);
    },
    viewWillAttachTree(treeView, rowView) {
      this.owner.callObservers("viewWillAttachTree", treeView, rowView);
    },
    viewDidDetachTree(treeView, rowView) {
      this.owner.callObservers("viewDidDetachTree", treeView, rowView);
    },
    viewWillHighlightLeaf(leafView, rowView) {
      this.owner.callObservers("viewWillHighlightLeaf", leafView, rowView);
    },
    viewDidHighlightLeaf(leafView, rowView) {
      this.owner.callObservers("viewDidHighlightLeaf", leafView, rowView);
    },
    viewWillUnhighlightLeaf(leafView, rowView) {
      this.owner.callObservers("viewWillUnhighlightLeaf", leafView, rowView);
    },
    viewDidUnhighlightLeaf(leafView, rowView) {
      this.owner.callObservers("viewDidUnhighlightLeaf", leafView, rowView);
    },
    viewWillExpand(rowView) {
      this.owner.callObservers("viewWillExpandRow", rowView);
    },
    viewDidExpand(rowView) {
      this.owner.callObservers("viewDidExpandRow", rowView);
    },
    viewWillCollapse(rowView) {
      this.owner.callObservers("viewWillCollapseRow", rowView);
    },
    viewDidCollapse(rowView) {
      this.owner.callObservers("viewDidCollapseRow", rowView);
    }
  }) ], TableView.prototype, "rows", void 0);
  class TableTrait extends Trait {
    createLayout() {
      const colLayouts = [];
      const colTraits = this.cols.traits;
      for (const traitId in colTraits) {
        const colTrait = colTraits[traitId];
        const colLayout = colTrait.layout.value;
        if (colLayout !== null) {
          colLayouts.push(colLayout);
        }
      }
      const colSpacing = this.colSpacing.value;
      return new TableLayout(null, null, null, colSpacing, colLayouts);
    }
    updateLayout() {
      const layout = this.createLayout();
      this.layout.setValue(layout, component.Affinity.Intrinsic);
    }
    startConsumingCols() {
      const colTraits = this.cols.traits;
      for (const traitId in colTraits) {
        const colTrait = colTraits[traitId];
        colTrait.consume(this);
      }
    }
    stopConsumingCols() {
      const colTraits = this.cols.traits;
      for (const traitId in colTraits) {
        const colTrait = colTraits[traitId];
        colTrait.unconsume(this);
      }
    }
    startConsumingRows() {
      const rowTraits = this.rows.traits;
      for (const traitId in rowTraits) {
        const rowTrait = rowTraits[traitId];
        rowTrait.consume(this);
      }
    }
    stopConsumingRows() {
      const rowTraits = this.rows.traits;
      for (const traitId in rowTraits) {
        const rowTrait = rowTraits[traitId];
        rowTrait.unconsume(this);
      }
    }
    onStartConsuming() {
      super.onStartConsuming();
      this.startConsumingCols();
      this.startConsumingRows();
    }
    onStopConsuming() {
      super.onStopConsuming();
      this.stopConsumingRows();
      this.stopConsumingCols();
    }
  }
  __decorate([ component.Property({
    type: TableLayout,
    value: null,
    willSetValue(newLayout, oldLayout) {
      this.owner.callObservers("traitWillSetTableLayout", newLayout, oldLayout, this.owner);
    },
    didSetValue(newLayout, oldLayout) {
      this.owner.callObservers("traitDidSetTableLayout", newLayout, oldLayout, this.owner);
    }
  }) ], TableTrait.prototype, "layout", void 0);
  __decorate([ component.Property({
    type: math.Length,
    value: null,
    didSetValue(newColSpacing, oldColSpacing) {
      this.owner.updateLayout();
    }
  }) ], TableTrait.prototype, "colSpacing", void 0);
  __decorate([ TraitRef({
    type: HeaderTrait,
    binds: true,
    willAttachTrait(headerTrait) {
      this.owner.callObservers("traitWillAttachHeader", headerTrait, this.owner);
    },
    didDetachTrait(headerTrait) {
      this.owner.callObservers("traitDidDetachHeader", headerTrait, this.owner);
    },
    detectTrait(trait) {
      return trait instanceof HeaderTrait ? trait : null;
    }
  }) ], TableTrait.prototype, "header", void 0);
  __decorate([ TraitSet({
    type: ColTrait,
    binds: true,
    observes: true,
    willAttachTrait(colTrait, targetTrait) {
      this.owner.callObservers("traitWillAttachCol", colTrait, targetTrait, this.owner);
    },
    didAttachTrait(colTrait) {
      this.owner.updateLayout();
      if (this.owner.consuming) {
        colTrait.consume(this.owner);
      }
    },
    willDetachTrait(colTrait) {
      if (this.owner.consuming) {
        colTrait.unconsume(this.owner);
      }
    },
    didDetachTrait(colTrait) {
      this.owner.updateLayout();
      this.owner.callObservers("traitDidDetachCol", colTrait, this.owner);
    },
    traitDidSetLayout(newColLayout, oldColLayout) {
      this.owner.updateLayout();
    },
    detectModel(model) {
      return model.getTrait(ColTrait);
    }
  }) ], TableTrait.prototype, "cols", void 0);
  __decorate([ TraitSet({
    type: RowTrait,
    binds: true,
    willAttachTrait(rowTrait, targetTrait) {
      this.owner.callObservers("traitWillAttachRow", rowTrait, targetTrait, this.owner);
    },
    didAttachTrait(rowTrait) {
      if (this.owner.consuming) {
        rowTrait.consume(this.owner);
      }
    },
    willDetachTrait(rowTrait) {
      if (this.owner.consuming) {
        rowTrait.unconsume(this.owner);
      }
    },
    didDetachTrait(rowTrait) {
      this.owner.callObservers("traitDidDetachRow", rowTrait, this.owner);
    },
    detectModel(model) {
      return model.getTrait(RowTrait);
    },
    detectTrait(trait) {
      return null;
    }
  }) ], TableTrait.prototype, "rows", void 0);
  class TableController extends Controller {
    layoutTable(tableLayout, tableView) {
      tableView.layout.setValue(tableLayout, component.Affinity.Intrinsic);
    }
  }
  __decorate([ TraitViewRef({
    traitType: TableTrait,
    observesTrait: true,
    willAttachTrait(tableTrait) {
      this.owner.callObservers("controllerWillAttachTableTrait", tableTrait, this.owner);
    },
    didAttachTrait(tableTrait) {
      const headerTrait = tableTrait.header.trait;
      if (headerTrait !== null) {
        this.owner.header.setTrait(headerTrait);
      }
      const colTraits = tableTrait.cols.traits;
      for (const traitId in colTraits) {
        const colTrait = colTraits[traitId];
        this.owner.cols.addTraitController(colTrait, null, colTrait.key);
      }
      const rowTraits = tableTrait.rows.traits;
      for (const traitId in rowTraits) {
        const rowTrait = rowTraits[traitId];
        this.owner.rows.addTraitController(rowTrait);
      }
      const tableView = this.view;
      if (tableView !== null) {
        const tableLayout = tableTrait.layout.value;
        if (tableLayout !== null) {
          this.owner.layoutTable(tableLayout, tableView);
        }
      }
    },
    willDetachTrait(tableTrait) {
      const rowTraits = tableTrait.rows.traits;
      for (const traitId in rowTraits) {
        const rowTrait = rowTraits[traitId];
        this.owner.rows.deleteTraitController(rowTrait);
      }
      const colTraits = tableTrait.cols.traits;
      for (const traitId in colTraits) {
        const colTrait = colTraits[traitId];
        this.owner.cols.deleteTraitController(colTrait);
      }
      const headerTrait = tableTrait.header.trait;
      if (headerTrait !== null) {
        this.owner.header.deleteTrait(headerTrait);
      }
    },
    didDetachTrait(tableTrait) {
      this.owner.callObservers("controllerDidDetachTableTrait", tableTrait, this.owner);
    },
    traitWillSetTableLayout(newTableLayout, oldTableLayout) {
      this.owner.callObservers("controllerWillSetTableLayout", newTableLayout, oldTableLayout, this.owner);
    },
    traitDidSetTableLayout(newTableLayout, oldTableLayout) {
      this.owner.callObservers("controllerDidSetTableLayout", newTableLayout, oldTableLayout, this.owner);
    },
    traitWillAttachHeader(headerTrait) {
      this.owner.header.setTrait(headerTrait);
    },
    traitDidDetachHeader(headerTrait) {
      this.owner.header.deleteTrait(headerTrait);
    },
    traitWillAttachCol(colTrait, targetTrait) {
      this.owner.cols.addTraitController(colTrait, targetTrait, colTrait.key);
    },
    traitDidDetachCol(colTrait) {
      this.owner.cols.deleteTraitController(colTrait);
    },
    traitWillAttachRow(rowTrait, targetTrait) {
      this.owner.rows.addTraitController(rowTrait, targetTrait);
    },
    traitDidDetachRow(rowTrait) {
      this.owner.rows.deleteTraitController(rowTrait);
    },
    viewType: TableView,
    observesView: true,
    initView(tableView) {
      const headerController = this.owner.header.controller;
      if (headerController !== null) {
        headerController.header.insertView(tableView);
        if (tableView.header.view === null) {
          tableView.header.setView(headerController.header.view);
        }
      }
      const rowControllers = this.owner.rows.controllers;
      for (const controllerId in rowControllers) {
        const rowController = rowControllers[controllerId];
        const rowView = rowController.row.view;
        if (rowView !== null && rowView.parent === null) {
          rowController.row.insertView(tableView);
        }
      }
      const tableTrait = this.trait;
      if (tableTrait !== null) {
        const tableLayout = tableTrait.layout.value;
        if (tableLayout !== null) {
          this.owner.layoutTable(tableLayout, tableView);
        }
      }
    },
    willAttachView(tableView) {
      this.owner.callObservers("controllerWillAttachTableView", tableView, this.owner);
    },
    didDetachView(tableView) {
      this.owner.callObservers("controllerDidDetachTableView", tableView, this.owner);
    },
    viewWillAttachHeader(headerView) {
      const headerController = this.owner.header.controller;
      if (headerController !== null) {
        headerController.header.setView(headerView);
      }
    },
    viewDidDetachHeader(headerView) {
      const headerController = this.owner.header.controller;
      if (headerController !== null) {
        headerController.header.setView(null);
      }
    }
  }) ], TableController.prototype, "table", void 0);
  __decorate([ TraitViewControllerRef({
    implements: true,
    type: HeaderController,
    binds: true,
    observes: true,
    get parentView() {
      return this.owner.table.view;
    },
    getTraitViewRef(headerController) {
      return headerController.header;
    },
    initController(headerController) {
      const tableTrait = this.owner.table.trait;
      if (tableTrait !== null) {
        const headerTrait = tableTrait.header.trait;
        if (headerTrait !== null) {
          headerController.header.setTrait(headerTrait);
        }
      }
    },
    willAttachController(headerController) {
      this.owner.callObservers("controllerWillAttachHeader", headerController, this.owner);
    },
    didAttachController(headerController) {
      const headerTrait = headerController.header.trait;
      if (headerTrait !== null) {
        this.attachHeaderTrait(headerTrait, headerController);
      }
      const headerView = headerController.header.view;
      if (headerView !== null) {
        this.attachHeaderView(headerView, headerController);
      }
    },
    willDetachController(headerController) {
      const headerView = headerController.header.view;
      if (headerView !== null) {
        this.detachHeaderView(headerView, headerController);
      }
      const headerTrait = headerController.header.trait;
      if (headerTrait !== null) {
        this.detachHeaderTrait(headerTrait, headerController);
      }
    },
    didDetachController(headerController) {
      this.owner.callObservers("controllerDidDetachHeader", headerController, this.owner);
    },
    controllerWillAttachHeaderTrait(headerTrait, headerController) {
      this.owner.callObservers("controllerWillAttachHeaderTrait", headerTrait, this.owner);
      this.attachHeaderTrait(headerTrait, headerController);
    },
    controllerDidDetachHeaderTrait(headerTrait, headerController) {
      this.detachHeaderTrait(headerTrait, headerController);
      this.owner.callObservers("controllerDidDetachHeaderTrait", headerTrait, this.owner);
    },
    attachHeaderTrait(headerTrait, headerController) {},
    detachHeaderTrait(headerTrait, headerController) {},
    controllerWillAttachHeaderView(headerView, headerController) {
      this.owner.callObservers("controllerWillAttachHeaderView", headerView, this.owner);
      this.attachHeaderView(headerView, headerController);
    },
    controllerDidDetachHeaderView(headerView, headerController) {
      this.detachHeaderView(headerView, headerController);
      this.owner.callObservers("controllerDidDetachHeaderView", headerView, this.owner);
    },
    attachHeaderView(headerView, headerController) {},
    detachHeaderView(headerView, headerController) {
      headerView.remove();
    },
    detectController(controller) {
      return controller instanceof HeaderController ? controller : null;
    }
  }) ], TableController.prototype, "header", void 0);
  __decorate([ TraitViewControllerSet({
    implements: true,
    type: ColController,
    binds: true,
    observes: true,
    getTraitViewRef(colController) {
      return colController.col;
    },
    willAttachController(colController) {
      this.owner.callObservers("controllerWillAttachCol", colController, this.owner);
    },
    didAttachController(colController) {
      const colTrait = colController.col.trait;
      if (colTrait !== null) {
        this.attachColTrait(colTrait, colController);
      }
      const colView = colController.col.view;
      if (colView !== null) {
        this.attachColView(colView, colController);
      }
    },
    willDetachController(colController) {
      const colTrait = colController.col.trait;
      if (colTrait !== null) {
        this.detachColTrait(colTrait, colController);
      }
      const colView = colController.col.view;
      if (colView !== null) {
        this.detachColView(colView, colController);
      }
    },
    didDetachController(colController) {
      this.owner.callObservers("controllerDidDetachCol", colController, this.owner);
    },
    controllerWillAttachColTrait(colTrait, colController) {
      this.owner.callObservers("controllerWillAttachColTrait", colTrait, colController, this.owner);
      this.attachColTrait(colTrait, colController);
    },
    controllerDidDetachColTrait(colTrait, colController) {
      this.detachColTrait(colTrait, colController);
      this.owner.callObservers("controllerDidDetachColTrait", colTrait, colController, this.owner);
    },
    attachColTrait(colTrait, colController) {},
    detachColTrait(colTrait, colController) {},
    controllerWillSetColLayout(newColLayout, oldColLayout, colController) {
      this.owner.callObservers("controllerWillSetColLayout", newColLayout, oldColLayout, colController, this.owner);
    },
    controllerDidSetColLayout(newColLayout, oldColLayout, colController) {
      this.owner.callObservers("controllerDidSetColLayout", newColLayout, oldColLayout, colController, this.owner);
    },
    controllerWillAttachColView(colView, colController) {
      this.owner.callObservers("controllerWillAttachColView", colView, colController, this.owner);
      this.attachColView(colView, colController);
    },
    controllerDidDetachColView(colView, colController) {
      this.detachColView(colView, colController);
      this.owner.callObservers("controllerDidDetachColView", colView, colController, this.owner);
    },
    attachColView(colView, colController) {
      const colLabelView = colView.label.view;
      if (colLabelView !== null) {
        this.attachColLabelView(colLabelView, colController);
      }
    },
    detachColView(colView, colController) {
      const colLabelView = colView.label.view;
      if (colLabelView !== null) {
        this.detachColLabelView(colLabelView, colController);
      }
      colView.remove();
    },
    controllerWillAttachColLabelView(colLabelView, colController) {
      this.owner.callObservers("controllerWillAttachColLabelView", colLabelView, colController, this.owner);
      this.attachColLabelView(colLabelView, colController);
    },
    controllerDidDetachColLabelView(colLabelView, colController) {
      this.detachColLabelView(colLabelView, colController);
      this.owner.callObservers("controllerDidDetachColLabelView", colLabelView, colController, this.owner);
    },
    attachColLabelView(colLabelView, colController) {},
    detachColLabelView(colLabelView, colController) {}
  }) ], TableController.prototype, "cols", void 0);
  __decorate([ TraitViewControllerSet({
    implements: true,
    type: RowController,
    binds: true,
    observes: true,
    get parentView() {
      return this.owner.table.view;
    },
    getTraitViewRef(rowController) {
      return rowController.row;
    },
    willAttachController(rowController) {
      this.owner.callObservers("controllerWillAttachRow", rowController, this.owner);
    },
    didAttachController(rowController) {
      const rowTrait = rowController.row.trait;
      if (rowTrait !== null) {
        this.attachRowTrait(rowTrait, rowController);
      }
      const rowView = rowController.row.view;
      if (rowView !== null) {
        this.attachRowView(rowView, rowController);
      }
    },
    willDetachController(rowController) {
      const rowView = rowController.row.view;
      if (rowView !== null) {
        this.detachRowView(rowView, rowController);
      }
      const rowTrait = rowController.row.trait;
      if (rowTrait !== null) {
        this.detachRowTrait(rowTrait, rowController);
      }
    },
    didDetachController(rowController) {
      this.owner.callObservers("controllerDidDetachRow", rowController, this.owner);
    },
    controllerWillAttachRowTrait(rowTrait, rowController) {
      this.owner.callObservers("controllerWillAttachRowTrait", rowTrait, rowController, this.owner);
      this.attachRowTrait(rowTrait, rowController);
    },
    controllerDidDetachRowTrait(rowTrait, rowController) {
      this.detachRowTrait(rowTrait, rowController);
      this.owner.callObservers("controllerDidDetachRowTrait", rowTrait, rowController, this.owner);
    },
    attachRowTrait(rowTrait, rowController) {},
    detachRowTrait(rowTrait, rowController) {},
    controllerWillAttachRowView(rowView, rowController) {
      this.owner.callObservers("controllerWillAttachRowView", rowView, rowController, this.owner);
      this.attachRowView(rowView, rowController);
    },
    controllerDidDetachRowView(rowView, rowController) {
      this.detachRowView(rowView, rowController);
      this.owner.callObservers("controllerDidDetachRowView", rowView, rowController, this.owner);
    },
    attachRowView(rowView, rowController) {},
    detachRowView(rowView, rowController) {
      rowView.remove();
    },
    controllerWillAttachLeafTrait(leafTrait, rowController) {
      this.owner.callObservers("controllerWillAttachLeafTrait", leafTrait, rowController, this.owner);
      this.attachLeafTrait(leafTrait, rowController);
    },
    controllerDidDetachLeafTrait(leafTrait, rowController) {
      this.detachLeafTrait(leafTrait, rowController);
      this.owner.callObservers("controllerDidDetachLeafTrait", leafTrait, rowController, this.owner);
    },
    attachLeafTrait(leafTrait, rowController) {},
    detachLeafTrait(leafTrait, rowController) {},
    controllerWillAttachLeafView(leafView, rowController) {
      this.owner.callObservers("controllerWillAttachLeafView", leafView, rowController, this.owner);
      this.attachLeafView(leafView, rowController);
    },
    controllerDidDetachLeafView(leafView, rowController) {
      this.detachLeafView(leafView, rowController);
      this.owner.callObservers("controllerDidDetachLeafView", leafView, rowController, this.owner);
    },
    attachLeafView(leafView, rowController) {},
    detachLeafView(leafView, rowController) {},
    controllerWillAttachCell(cellController, rowController) {
      this.owner.callObservers("controllerWillAttachCell", cellController, rowController, this.owner);
      this.attachCell(cellController, rowController);
    },
    controllerDidDetachCell(cellController, rowController) {
      this.detachCell(cellController, rowController);
      this.owner.callObservers("controllerDidDetachCell", cellController, rowController, this.owner);
    },
    attachCell(cellController, rowController) {
      const cellTrait = cellController.cell.trait;
      if (cellTrait !== null) {
        this.attachCellTrait(cellTrait, cellController, rowController);
      }
      const cellView = cellController.cell.view;
      if (cellView !== null) {
        this.attachCellView(cellView, cellController, rowController);
      }
    },
    detachCell(cellController, rowController) {
      const cellTrait = cellController.cell.trait;
      if (cellTrait !== null) {
        this.detachCellTrait(cellTrait, cellController, rowController);
      }
      const cellView = cellController.cell.view;
      if (cellView !== null) {
        this.detachCellView(cellView, cellController, rowController);
      }
    },
    controllerWillAttachCellTrait(cellTrait, cellController, rowController) {
      this.owner.callObservers("controllerWillAttachCellTrait", cellTrait, cellController, rowController, this.owner);
      this.attachCellTrait(cellTrait, cellController, rowController);
    },
    controllerDidDetachCellTrait(cellTrait, cellController, rowController) {
      this.detachCellTrait(cellTrait, cellController, rowController);
      this.owner.callObservers("controllerDidDetachCellTrait", cellTrait, cellController, rowController, this.owner);
    },
    attachCellTrait(cellTrait, cellController, rowController) {},
    detachCellTrait(cellTrait, cellController, rowController) {},
    controllerWillAttachCellView(cellView, cellController, rowController) {
      this.owner.callObservers("controllerWillAttachCellView", cellView, cellController, rowController, this.owner);
      this.attachCellView(cellView, cellController, rowController);
    },
    controllerDidDetachCellView(cellView, cellController, rowController) {
      this.detachCellView(cellView, cellController, rowController);
      this.owner.callObservers("controllerDidDetachCellView", cellView, cellController, rowController, this.owner);
    },
    attachCellView(cellView, cellController, rowController) {
      if (cellView instanceof TextCellView) {
        const cellContentView = cellView.content.view;
        if (cellContentView !== null) {
          this.attachCellContentView(cellContentView, cellController, rowController);
        }
      }
    },
    detachCellView(cellView, cellController, rowController) {
      if (cellView instanceof TextCellView) {
        const cellContentView = cellView.content.view;
        if (cellContentView !== null) {
          this.detachCellContentView(cellContentView, cellController, rowController);
        }
      }
    },
    controllerWillAttachCellContentView(cellContentView, cellController, rowController) {
      this.owner.callObservers("controllerWillAttachCellContentView", cellContentView, cellController, rowController, this.owner);
      this.attachCellContentView(cellContentView, cellController, rowController);
    },
    controllerDidDetachCellContentView(cellContentView, cellController, rowController) {
      this.detachCellContentView(cellContentView, cellController, rowController);
      this.owner.callObservers("controllerDidDetachCellContentView", cellContentView, cellController, rowController, this.owner);
    },
    attachCellContentView(cellContentView, cellController, rowController) {},
    detachCellContentView(cellContentView, cellController, rowController) {},
    controllerWillSetCellIcon(newCellIcon, oldCellIcon, cellController, rowController) {
      this.owner.callObservers("controllerWillSetCellIcon", newCellIcon, oldCellIcon, cellController, rowController, this.owner);
    },
    controllerDidSetCellIcon(newCellIcon, oldCellIcon, cellController, rowController) {
      this.owner.callObservers("controllerDidSetCellIcon", newCellIcon, oldCellIcon, cellController, rowController, this.owner);
    },
    controllerWillAttachTree(treeController, rowController) {
      this.owner.callObservers("controllerWillAttachTree", treeController, rowController, this.owner);
      this.attachTree(treeController, rowController);
    },
    controllerDidDetachTree(treeController, rowController) {
      this.detachTree(treeController, rowController);
      this.owner.callObservers("controllerDidDetachTree", treeController, rowController, this.owner);
    },
    attachTree(treeController, rowController) {
      const treeTrait = treeController.table.trait;
      if (treeTrait !== null) {
        this.attachTreeTrait(treeTrait, treeController, rowController);
      }
      const treeView = treeController.table.view;
      if (treeView !== null) {
        this.attachTreeView(treeView, treeController, rowController);
      }
    },
    detachTree(treeController, rowController) {
      const treeTrait = treeController.table.trait;
      if (treeTrait !== null) {
        this.detachTreeTrait(treeTrait, treeController, rowController);
      }
      const treeView = treeController.table.view;
      if (treeView !== null) {
        this.detachTreeView(treeView, treeController, rowController);
      }
    },
    controllerWillAttachTreeTrait(treeTrait, treeController, rowController) {
      this.owner.callObservers("controllerWillAttachTreeTrait", treeTrait, treeController, rowController, this.owner);
      this.attachTreeTrait(treeTrait, treeController, rowController);
    },
    controllerDidDetachTreeTrait(treeTrait, treeController, rowController) {
      this.detachTreeTrait(treeTrait, treeController, rowController);
      this.owner.callObservers("controllerDidDetachTreeTrait", treeTrait, treeController, rowController, this.owner);
    },
    attachTreeTrait(treeTrait, treeController, rowController) {},
    detachTreeTrait(treeTrait, treeController, rowController) {},
    controllerWillAttachTreeView(treeView, treeController, rowController) {
      this.owner.callObservers("controllerWillAttachTreeView", treeView, treeController, rowController, this.owner);
      this.attachTreeView(treeView, treeController, rowController);
    },
    controllerDidDetachTreeView(treeView, treeController, rowController) {
      this.detachTreeView(treeView, treeController, rowController);
      this.owner.callObservers("controllerDidDetachTreeView", treeView, treeController, rowController, this.owner);
    },
    attachTreeView(treeView, treeController, rowController) {},
    detachTreeView(treeView, treeController, rowController) {},
    controllerWillExpandRowView(rowView, rowController) {
      this.owner.callObservers("controllerWillExpandRowView", rowView, rowController, this.owner);
    },
    controllerDidExpandRowView(rowView, rowController) {
      this.owner.callObservers("controllerDidExpandRowView", rowView, rowController, this.owner);
    },
    controllerWillCollapseRowView(rowView, rowController) {
      this.owner.callObservers("controllerWillCollapseRowView", rowView, rowController, this.owner);
    },
    controllerDidCollapseRowView(rowView, rowController) {
      this.owner.callObservers("controllerDidCollapseRowView", rowView, rowController, this.owner);
    }
  }) ], TableController.prototype, "rows", void 0);
  class ScrimView extends HtmlView {
    constructor(node) {
      super(node);
      this.displayState = ScrimView.HiddenState;
      this.onClick = this.onClick.bind(this);
      if (typeof PointerEvent !== "undefined") {
        this.onSyntheticClick = this.onSyntheticClick.bind(this);
        this.on("pointerup", this.onClick);
        this.on("click", this.onSyntheticClick);
      } else if (typeof TouchEvent !== "undefined") {
        this.onSyntheticClick = this.onSyntheticClick.bind(this);
        this.on("touchend", this.onClick);
        this.on("click", this.onSyntheticClick);
      } else {
        this.on("click", this.onClick);
      }
      this.initScrim();
    }
    initScrim() {
      this.addClass("scrim");
      this.display.setState("none", component.Affinity.Intrinsic);
      this.position.setState("absolute", component.Affinity.Intrinsic);
      this.top.setState(0, component.Affinity.Intrinsic);
      this.right.setState(0, component.Affinity.Intrinsic);
      this.bottom.setState(0, component.Affinity.Intrinsic);
      this.left.setState(0, component.Affinity.Intrinsic);
      this.pointerEvents.setState("auto", component.Affinity.Intrinsic);
      this.cursor.setState("pointer", component.Affinity.Intrinsic);
      this.backgroundColor.setState(Color.black(0), component.Affinity.Intrinsic);
    }
    setDisplayState(displayState) {
      this.displayState = displayState;
    }
    isShown() {
      switch (this.displayState) {
       case ScrimView.ShownState:
       case ScrimView.ShowingState:
       case ScrimView.ShowState:
        return true;

       default:
        return false;
      }
    }
    isHidden() {
      switch (this.displayState) {
       case ScrimView.HiddenState:
       case ScrimView.HidingState:
       case ScrimView.HideState:
        return true;

       default:
        return false;
      }
    }
    show(opacity, timing) {
      if (this.isHidden()) {
        if (timing === void 0 || timing === true) {
          timing = this.getLookOr(Look.timing, false);
        } else {
          timing = util.Timing.fromAny(timing);
        }
        this.setDisplayState(ScrimView.ShowState);
        if (timing !== false) {
          this.backgroundColor.setState(Color.black(0), component.Affinity.Intrinsic);
          this.backgroundColor.setState(Color.black(opacity), timing, component.Affinity.Intrinsic);
        } else {
          this.willShowScrim();
          this.backgroundColor.setState(Color.black(opacity), component.Affinity.Intrinsic);
          this.didShowScrim();
        }
      }
    }
    willShowScrim() {
      this.setDisplayState(ScrimView.ShowingState);
      this.display.setState("block", component.Affinity.Intrinsic);
    }
    didShowScrim() {
      this.setDisplayState(ScrimView.ShownState);
    }
    hide(timing) {
      if (this.isShown()) {
        if (timing === void 0 || timing === true) {
          timing = this.getLookOr(Look.timing, false);
        } else {
          timing = util.Timing.fromAny(timing);
        }
        this.setDisplayState(ScrimView.HideState);
        if (timing !== false) {
          this.backgroundColor.setState(Color.black(0), timing, component.Affinity.Intrinsic);
        } else {
          this.willHideScrim();
          this.backgroundColor.setState(Color.black(0), component.Affinity.Intrinsic);
          this.didHideScrim();
        }
      }
    }
    willHideScrim() {
      this.setDisplayState(ScrimView.HidingState);
    }
    didHideScrim() {
      this.setDisplayState(ScrimView.HiddenState);
      this.display.setState("none", component.Affinity.Intrinsic);
    }
    onMount() {
      super.onMount();
      const modalService = this.modalProvider.service;
      if (modalService !== void 0 && modalService !== null) {
        modalService.observe(this);
        this.serviceDidUpdateModality(modalService.modality, 0, modalService);
      }
    }
    onUnmount() {
      const modalService = this.modalProvider.service;
      if (modalService !== void 0 && modalService !== null) {
        modalService.unobserve(this);
      }
      this.hide(false);
      super.onUnmount();
    }
    serviceDidUpdateModality(newModality, oldModality, modalService) {
      if (newModality !== 0) {
        const opacity = .5 * newModality;
        if (oldModality === 0) {
          this.show(opacity);
        } else {
          this.backgroundColor.setState(Color.black(opacity), component.Affinity.Intrinsic);
          if (this.displayState === ScrimView.ShowingState) {
            this.didShowScrim();
          }
        }
      } else {
        this.hide();
      }
    }
    onClick(event) {
      const modalService = this.modalProvider.service;
      if (modalService !== void 0 && modalService !== null) {
        modalService.displaceModals(event);
      }
    }
    onSyntheticClick(event) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  ScrimView.HiddenState = 0;
  ScrimView.HidingState = 1;
  ScrimView.HideState = 2;
  ScrimView.ShownState = 3;
  ScrimView.ShowingState = 4;
  ScrimView.ShowState = 5;
  __decorate([ StyleAnimator({
    propertyNames: "background-color",
    type: Color,
    value: null,
    willTransition() {
      const displayState = this.owner.displayState;
      if (displayState === ScrimView.ShowState) {
        this.owner.willShowScrim();
      } else if (displayState === ScrimView.HideState) {
        this.owner.willHideScrim();
      }
    },
    didTransition() {
      const displayState = this.owner.displayState;
      if (displayState === ScrimView.ShowingState) {
        this.owner.didShowScrim();
      } else if (displayState === ScrimView.HidingState) {
        this.owner.didHideScrim();
      }
    }
  }) ], ScrimView.prototype, "backgroundColor", void 0);
  class PopoverView extends HtmlView {
    constructor(node) {
      super(node);
      this.sourceFrame = null;
      this.displayState = PopoverView.HiddenState;
      this.modality = false;
      this.allowedPlacement = [ "top", "bottom", "right", "left" ];
      this.currentPlacement = "none";
      this.onClick = this.onClick.bind(this);
      this.initArrow();
    }
    initArrow() {
      const arrow = this.createArrow();
      if (arrow !== null) {
        this.prependChild(arrow, "arrow");
      }
    }
    createArrow() {
      const arrow = HtmlView.fromTag("div");
      arrow.addClass("popover-arrow");
      arrow.display.setState("none", component.Affinity.Intrinsic);
      arrow.position.setState("absolute", component.Affinity.Intrinsic);
      arrow.width.setState(0, component.Affinity.Intrinsic);
      arrow.height.setState(0, component.Affinity.Intrinsic);
      return arrow;
    }
    setDisplayState(displayState) {
      this.displayState = displayState;
    }
    setSource(sourceView) {
      this.source.setView(sourceView);
    }
    get modalView() {
      return this;
    }
    get modalState() {
      switch (this.displayState) {
       case PopoverView.HiddenState:
        return "hidden";

       case PopoverView.HidingState:
       case PopoverView.HideState:
        return "hiding";

       case PopoverView.ShownState:
        return "shown";

       case PopoverView.ShowingState:
       case PopoverView.ShowState:
        return "showing";

       default:
        throw new Error("" + this.displayState);
      }
    }
    isShown() {
      switch (this.displayState) {
       case PopoverView.ShownState:
       case PopoverView.ShowingState:
       case PopoverView.ShowState:
        return true;

       default:
        return false;
      }
    }
    isHidden() {
      switch (this.displayState) {
       case PopoverView.HiddenState:
       case PopoverView.HidingState:
       case PopoverView.HideState:
        return true;

       default:
        return false;
      }
    }
    showModal(options, timing) {
      if (this.isHidden()) {
        if (timing === void 0 || timing === true) {
          timing = this.getLookOr(Look.timing, false);
        } else {
          timing = util.Timing.fromAny(timing);
        }
        if (options.modal !== void 0) {
          this.modality = options.modal;
        }
        this.setDisplayState(PopoverView.ShowState);
        if (timing !== false) {
          this.displayPhase.setState(1, timing);
        } else {
          this.willShowPopover();
          this.didShowPopover();
        }
      }
    }
    willShowPopover() {
      this.setDisplayState(PopoverView.ShowingState);
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.popoverWillShow !== void 0) {
          observer.popoverWillShow(this);
        }
      }
      this.place();
      this.visibility.setState("visible", component.Affinity.Intrinsic);
    }
    didShowPopover() {
      this.setDisplayState(PopoverView.ShownState);
      this.pointerEvents.setState("auto", component.Affinity.Intrinsic);
      this.marginTop.setState(null, component.Affinity.Intrinsic);
      this.opacity.setState(void 0, component.Affinity.Intrinsic);
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.popoverDidShow !== void 0) {
          observer.popoverDidShow(this);
        }
      }
    }
    hideModal(timing) {
      if (this.isShown()) {
        if (timing === void 0 || timing === true) {
          timing = this.getLookOr(Look.timing, false);
        } else {
          timing = util.Timing.fromAny(timing);
        }
        this.setDisplayState(PopoverView.HideState);
        if (timing !== false) {
          this.displayPhase.setState(0, timing);
        } else {
          this.willHidePopover();
          this.didHidePopover();
        }
      }
    }
    willHidePopover() {
      this.setDisplayState(PopoverView.HidingState);
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.popoverWillHide !== void 0) {
          observer.popoverWillHide(this);
        }
      }
      this.pointerEvents.setState("none", component.Affinity.Intrinsic);
    }
    didHidePopover() {
      this.setDisplayState(PopoverView.HiddenState);
      this.visibility.setState("hidden", component.Affinity.Intrinsic);
      this.marginTop.setState(null, component.Affinity.Intrinsic);
      this.opacity.setState(void 0, component.Affinity.Intrinsic);
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.popoverDidHide !== void 0) {
          observer.popoverDidHide(this);
        }
      }
    }
    placement(placement) {
      if (placement === void 0) {
        return this.allowedPlacement;
      } else {
        if (!util.Arrays.equal(this.allowedPlacement, placement)) {
          this.allowedPlacement.length = 0;
          this.allowedPlacement.push(...placement);
          this.place();
        }
        return this;
      }
    }
    onMount() {
      super.onMount();
      this.attachEvents();
    }
    onUnmount() {
      super.onUnmount();
      this.detachEvents();
    }
    attachEvents() {
      this.on("click", this.onClick);
    }
    detachEvents() {
      this.off("click", this.onClick);
    }
    needsProcess(processFlags, viewContext) {
      if ((processFlags & (View.NeedsScroll | View.NeedsAnimate)) !== 0) {
        this.requireUpdate(View.NeedsLayout);
      }
      return processFlags;
    }
    onAnimate(viewContext) {
      super.onAnimate(viewContext);
      const displayState = this.displayState;
      if (displayState === PopoverView.ShowState) {
        this.willShowPopover();
      } else if (displayState === PopoverView.HideState) {
        this.willHidePopover();
      } else if (displayState === PopoverView.ShowingState && !this.displayPhase.tweening) {
        this.didShowPopover();
      } else if (displayState === PopoverView.HidingState && !this.displayPhase.tweening) {
        this.didHidePopover();
      }
      if (this.displayPhase.tweening) {
        this.applyDisplayPhase(this.displayPhase.value);
      }
    }
    applyDisplayPhase(displayPhase) {
      const placement = this.currentPlacement;
      if (placement === "above") {
        this.opacity.setState(void 0, component.Affinity.Intrinsic);
        this.marginTop.setState((1 - displayPhase) * -this.node.clientHeight, component.Affinity.Intrinsic);
      } else if (placement === "below") {
        this.opacity.setState(void 0, component.Affinity.Intrinsic);
        this.marginTop.setState((1 - displayPhase) * this.node.clientHeight, component.Affinity.Intrinsic);
      } else {
        this.marginTop.setState(null, component.Affinity.Intrinsic);
        this.opacity.setState(displayPhase, component.Affinity.Intrinsic);
      }
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.place();
    }
    place(force = false) {
      const sourceView = this.source.view;
      const oldSourceFrame = this.sourceFrame;
      const newSourceFrame = sourceView !== null ? sourceView.popoverFrame : null;
      if (newSourceFrame !== null && this.allowedPlacement.length !== 0 && (force || !newSourceFrame.equals(oldSourceFrame))) {
        this.sourceFrame = null;
        const placement = this.placePopover(sourceView, newSourceFrame);
        const arrow = this.getChild("arrow");
        if (arrow instanceof HtmlView) {
          this.placeArrow(sourceView, newSourceFrame, arrow, placement);
        }
        return placement;
      } else {
        return "none";
      }
    }
    placePopover(sourceView, sourceFrame) {
      const node = this.node;
      const parent = node.offsetParent;
      if (parent === null) {
        return "none";
      }
      const popoverWidth = node.clientWidth;
      const popoverHeight = node.clientHeight;
      const parentBounds = parent.getBoundingClientRect();
      const parentLeft = parentBounds.left;
      const parentTop = parentBounds.top;
      const sourceLeft = sourceFrame.left - window.pageXOffset - parentLeft;
      const sourceRight = sourceFrame.right - window.pageXOffset - parentLeft;
      const sourceTop = sourceFrame.top - window.pageYOffset - parentTop;
      const sourceBottom = sourceFrame.bottom - window.pageYOffset - parentTop;
      const sourceWidth = sourceFrame.width;
      const sourceHeight = sourceFrame.height;
      const sourceX = sourceLeft + sourceWidth / 2;
      const sourceY = sourceTop + sourceHeight / 2;
      const placementFrame = this.placementFrame.value;
      const placementLeft = placementFrame !== null ? placementFrame.left : 0;
      const placementRight = (placementFrame !== null ? placementFrame.right : window.innerWidth) - parentLeft;
      const placementTop = placementFrame !== null ? placementFrame.top : 0;
      const placementBottom = (placementFrame !== null ? placementFrame.bottom : window.innerHeight) - parentTop;
      const marginLeft = sourceLeft - placementLeft - window.pageXOffset;
      const marginRight = placementRight - sourceLeft - sourceWidth;
      const marginTop = sourceTop - placementTop - window.pageYOffset;
      const marginBottom = placementBottom - sourceTop - sourceHeight;
      const dropdown = this.dropdown.value;
      const arrowHeight = this.arrowHeight.getValue().pxValue();
      const placementGap = this.placementGap.getValue().pxValue();
      let placement;
      const allowedPlacement = this.allowedPlacement;
      for (let i = 0, n = allowedPlacement.length; i < n; i += 1) {
        const p = allowedPlacement[i];
        if (p === "above" || p === "below" || p === "over") {
          placement = p;
          break;
        } else if (p === "top" && popoverHeight + arrowHeight + placementGap <= marginTop) {
          placement = p;
          break;
        } else if (p === "bottom" && popoverHeight + arrowHeight + placementGap <= marginBottom) {
          placement = p;
          break;
        } else if (p === "left" && popoverWidth + arrowHeight + placementGap <= marginLeft) {
          placement = p;
          break;
        } else if (p === "right" && popoverWidth + arrowHeight + placementGap <= marginRight) {
          placement = p;
          break;
        }
      }
      if (placement === void 0) {
        placement = "none";
        for (let i = 0, n = allowedPlacement.length; i < n; i += 1) {
          const p = allowedPlacement[i];
          if (p === "top" && marginTop >= marginBottom) {
            placement = p;
            break;
          } else if (p === "bottom" && marginBottom >= marginTop) {
            placement = p;
            break;
          } else if (p === "left" && marginLeft >= marginRight) {
            placement = p;
            break;
          } else if (p === "right" && marginRight >= marginLeft) {
            placement = p;
            break;
          }
        }
      }
      let left = node.offsetLeft;
      let top = node.offsetTop;
      let right = null;
      let bottom = null;
      let oldWidth = this.width.state;
      oldWidth = oldWidth instanceof math.Length ? oldWidth.pxValue() : null;
      let oldHeight = this.height.state;
      oldHeight = oldHeight instanceof math.Length ? oldHeight.pxValue() : null;
      let width = oldWidth;
      let height = oldHeight;
      let oldMaxWidth = this.maxWidth.state;
      oldMaxWidth = oldMaxWidth instanceof math.Length ? oldMaxWidth.pxValue() : null;
      let oldMaxHeight = this.maxHeight.state;
      oldMaxHeight = oldMaxHeight instanceof math.Length ? oldMaxHeight.pxValue() : null;
      let maxWidth = oldMaxWidth;
      let maxHeight = oldMaxHeight;
      if (placement === "above") {
        left = Math.round(placementLeft);
        top = Math.round(placementTop);
        right = Math.round((placementFrame !== null ? placementFrame.width : window.innerWidth) - placementRight);
        width = Math.round(Math.max(0, placementRight - placementLeft));
        height = null;
        maxWidth = null;
        maxHeight = Math.round(Math.max(0, placementBottom - placementTop));
      } else if (placement === "below") {
        left = Math.round(placementLeft);
        top = Math.round(placementBottom - popoverHeight);
        right = Math.round(placementRight - (placementFrame !== null ? placementFrame.width : window.innerWidth));
        width = Math.round(Math.max(0, placementRight - placementLeft));
        height = null;
        maxWidth = null;
        maxHeight = Math.round(Math.max(0, placementBottom - placementTop));
      } else if (placement === "over") {
        left = Math.round(placementLeft);
        top = Math.round(placementTop);
        right = Math.round(placementRight - (placementFrame !== null ? placementFrame.width : window.innerWidth));
        bottom = Math.round(placementBottom - (placementFrame !== null ? placementFrame.height : window.innerHeight));
        width = Math.round(Math.max(0, placementRight - placementLeft));
        height = Math.round(Math.max(0, placementBottom - placementTop));
        maxWidth = null;
        maxHeight = null;
      } else if (placement === "top" && !dropdown) {
        if (sourceX - popoverWidth / 2 <= placementLeft) {
          left = Math.round(placementLeft);
        } else if (sourceX + popoverWidth / 2 >= placementRight) {
          left = Math.round(placementRight - popoverWidth);
        } else {
          left = Math.round(sourceX - popoverWidth / 2);
        }
        top = Math.round(Math.max(placementTop, sourceTop - (popoverHeight + arrowHeight + placementGap)));
        maxWidth = Math.round(Math.max(0, placementRight - placementLeft));
        maxHeight = Math.round(Math.max(0, sourceBottom - placementTop));
      } else if (placement === "bottom" && !dropdown) {
        if (sourceX - popoverWidth / 2 <= placementLeft) {
          left = Math.round(placementLeft);
        } else if (sourceX + popoverWidth / 2 >= placementRight) {
          left = Math.round(placementRight - popoverWidth);
        } else {
          left = Math.round(sourceX - popoverWidth / 2);
        }
        top = Math.round(Math.max(placementTop, sourceBottom + arrowHeight + placementGap));
        maxWidth = Math.round(Math.max(0, placementRight - placementLeft));
        maxHeight = Math.round(Math.max(0, placementBottom - sourceTop));
      } else if (placement === "left" && !dropdown) {
        left = Math.round(Math.max(placementLeft, sourceLeft - (popoverWidth + arrowHeight + placementGap)));
        if (sourceY - popoverHeight / 2 <= placementTop) {
          top = Math.round(placementTop);
        } else if (sourceY + popoverHeight / 2 >= placementBottom) {
          top = Math.round(placementBottom - popoverHeight);
        } else {
          top = Math.round(sourceY - popoverHeight / 2);
        }
        maxWidth = Math.round(Math.max(0, sourceRight - placementLeft));
        maxHeight = Math.round(Math.max(0, placementBottom - placementTop));
      } else if (placement === "right" && !dropdown) {
        left = Math.round(Math.max(placementLeft, sourceRight + arrowHeight + placementGap));
        if (sourceY - popoverHeight / 2 <= placementTop) {
          top = Math.round(placementTop);
        } else if (sourceY + popoverHeight / 2 >= placementBottom) {
          top = Math.round(placementBottom - popoverHeight);
        } else {
          top = Math.round(sourceY - popoverHeight / 2);
        }
        maxWidth = Math.round(Math.max(0, placementRight - sourceLeft));
        maxHeight = Math.round(Math.max(0, placementBottom - placementTop));
      } else if (placement === "top" && dropdown) {
        left = Math.max(placementLeft, sourceLeft);
        top = Math.round(Math.max(placementTop, sourceTop - (popoverHeight + placementGap)));
        width = Math.round(Math.max(0, Math.min(sourceWidth, placementRight - sourceLeft)));
        height = null;
        maxWidth = Math.round(Math.max(0, placementRight - placementLeft));
        maxHeight = Math.round(Math.max(0, sourceBottom - placementTop));
      } else if (placement === "bottom" && dropdown) {
        left = Math.max(placementLeft, sourceLeft);
        top = Math.round(Math.max(placementTop, sourceBottom + placementGap));
        width = Math.round(Math.max(0, Math.min(sourceWidth, placementRight - sourceLeft)));
        height = null;
        maxWidth = Math.round(Math.max(0, placementRight - placementLeft));
        maxHeight = Math.round(Math.max(0, placementBottom - sourceTop));
      } else if (placement === "left" && dropdown) {
        left = Math.round(Math.max(placementLeft, sourceLeft - (popoverWidth + placementGap)));
        top = Math.max(placementTop, sourceTop);
        width = null;
        height = Math.round(Math.max(0, Math.min(sourceHeight, placementBottom - sourceTop)));
        maxWidth = Math.round(Math.max(0, sourceRight - placementLeft));
        maxHeight = Math.round(Math.max(0, placementBottom - placementTop));
      } else if (placement === "right" && dropdown) {
        left = Math.round(Math.max(placementLeft, sourceRight + placementGap));
        top = Math.max(placementTop, sourceTop);
        width = null;
        height = Math.round(Math.max(0, Math.min(sourceHeight, placementBottom - sourceTop)));
        maxWidth = Math.round(Math.max(0, placementRight - sourceLeft));
        maxHeight = Math.round(Math.max(0, placementBottom - placementTop));
      }
      if (placement !== "none" && (left !== node.offsetLeft && this.left.hasAffinity(component.Affinity.Intrinsic) || top !== node.offsetTop && this.top.hasAffinity(component.Affinity.Intrinsic) || width !== oldWidth && this.width.hasAffinity(component.Affinity.Intrinsic) || height !== oldHeight && this.height.hasAffinity(component.Affinity.Intrinsic) || maxWidth !== oldMaxWidth && this.maxWidth.hasAffinity(component.Affinity.Intrinsic) || maxHeight !== oldMaxHeight && this.maxHeight.hasAffinity(component.Affinity.Intrinsic))) {
        this.willPlacePopover(placement);
        this.position.setState("absolute", component.Affinity.Intrinsic);
        this.left.setState(left, component.Affinity.Intrinsic);
        this.right.setState(right, component.Affinity.Intrinsic);
        this.top.setState(top, component.Affinity.Intrinsic);
        this.bottom.setState(bottom, component.Affinity.Intrinsic);
        this.width.setState(width, component.Affinity.Intrinsic);
        this.height.setState(height, component.Affinity.Intrinsic);
        this.maxWidth.setState(maxWidth, component.Affinity.Intrinsic);
        this.maxHeight.setState(maxHeight, component.Affinity.Intrinsic);
        this.onPlacePopover(placement);
        this.didPlacePopover(placement);
      }
      this.currentPlacement = placement;
      return placement;
    }
    willPlacePopover(placement) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.popoverWillPlace !== void 0) {
          observer.popoverWillPlace(placement, this);
        }
      }
    }
    onPlacePopover(placement) {}
    didPlacePopover(placement) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.popoverDidPlace !== void 0) {
          observer.popoverDidPlace(placement, this);
        }
      }
    }
    placeArrow(sourceView, sourceFrame, arrow, placement) {
      const node = this.node;
      const parent = node.offsetParent;
      if (parent === null) {
        return;
      }
      const parentBounds = parent.getBoundingClientRect();
      const parentLeft = parentBounds.left;
      const parentTop = parentBounds.top;
      const sourceLeft = sourceFrame.left - window.pageXOffset - parentLeft;
      const sourceTop = sourceFrame.top - window.pageYOffset - parentTop;
      const sourceWidth = sourceFrame.width;
      const sourceHeight = sourceFrame.height;
      const sourceX = sourceLeft + sourceWidth / 2;
      const sourceY = sourceTop + sourceHeight / 2;
      const offsetLeft = node.offsetLeft;
      const offsetRight = offsetLeft + node.clientWidth;
      const offsetTop = node.offsetTop;
      const offsetBottom = offsetTop + node.clientHeight;
      let backgroundColor = this.backgroundColor.value;
      if (backgroundColor === null) {
        backgroundColor = Color.transparent();
      }
      const borderRadius = this.borderRadius();
      const radius = borderRadius instanceof math.Length ? borderRadius.pxValue() : 0;
      const arrowWidth = this.arrowWidth.getValue().pxValue();
      const arrowHeight = this.arrowHeight.getValue().pxValue();
      const arrowXMin = offsetLeft + radius + arrowWidth / 2;
      const arrowXMax = offsetRight - radius - arrowWidth / 2;
      const arrowYMin = offsetTop + radius + arrowWidth / 2;
      const arrowYMax = offsetBottom - radius - arrowWidth / 2;
      arrow.top.setState(null, component.Affinity.Intrinsic);
      arrow.right.setState(null, component.Affinity.Intrinsic);
      arrow.bottom.setState(null, component.Affinity.Intrinsic);
      arrow.left.setState(null, component.Affinity.Intrinsic);
      arrow.borderLeftWidth.setState(null, component.Affinity.Intrinsic);
      arrow.borderLeftStyle.setState(void 0, component.Affinity.Intrinsic);
      arrow.borderLeftColor.setState(null, component.Affinity.Intrinsic);
      arrow.borderRightWidth.setState(null, component.Affinity.Intrinsic);
      arrow.borderRightStyle.setState(void 0, component.Affinity.Intrinsic);
      arrow.borderRightColor.setState(null, component.Affinity.Intrinsic);
      arrow.borderTopWidth.setState(null, component.Affinity.Intrinsic);
      arrow.borderTopStyle.setState(void 0, component.Affinity.Intrinsic);
      arrow.borderTopColor.setState(null, component.Affinity.Intrinsic);
      arrow.borderBottomWidth.setState(null, component.Affinity.Intrinsic);
      arrow.borderBottomStyle.setState(void 0, component.Affinity.Intrinsic);
      arrow.borderBottomColor.setState(null, component.Affinity.Intrinsic);
      arrow.zIndex.setState(100, component.Affinity.Intrinsic);
      if (placement === "none" || placement === "above" || placement === "below" || placement === "over") {
        arrow.display.setState("none", component.Affinity.Intrinsic);
      } else if (Math.round(sourceY) <= Math.round(offsetTop - arrowHeight) && arrowXMin <= sourceX && sourceX <= arrowXMax) {
        arrow.display.setState("block", component.Affinity.Intrinsic);
        arrow.top.setState(Math.round(-arrowHeight), component.Affinity.Intrinsic);
        arrow.left.setState(Math.round(sourceX - offsetLeft - arrowWidth / 2), component.Affinity.Intrinsic);
        arrow.borderLeftWidth.setState(Math.round(arrowWidth / 2), component.Affinity.Intrinsic);
        arrow.borderLeftStyle.setState("solid", component.Affinity.Intrinsic);
        arrow.borderLeftColor.setState(Color.transparent(), component.Affinity.Intrinsic);
        arrow.borderRightWidth.setState(Math.round(arrowWidth / 2), component.Affinity.Intrinsic);
        arrow.borderRightStyle.setState("solid", component.Affinity.Intrinsic);
        arrow.borderRightColor.setState(Color.transparent(), component.Affinity.Intrinsic);
        arrow.borderBottomWidth.setState(Math.round(arrowHeight), component.Affinity.Intrinsic);
        arrow.borderBottomStyle.setState("solid", component.Affinity.Intrinsic);
        arrow.borderBottomColor.setState(backgroundColor, component.Affinity.Intrinsic);
      } else if (Math.round(offsetBottom + arrowHeight) <= Math.round(sourceY) && arrowXMin <= sourceX && sourceX <= arrowXMax) {
        arrow.display.setState("block", component.Affinity.Intrinsic);
        arrow.bottom.setState(Math.round(-arrowHeight), component.Affinity.Intrinsic);
        arrow.left.setState(Math.round(sourceX - offsetLeft - arrowWidth / 2), component.Affinity.Intrinsic);
        arrow.borderLeftWidth.setState(Math.round(arrowWidth / 2), component.Affinity.Intrinsic);
        arrow.borderLeftStyle.setState("solid", component.Affinity.Intrinsic);
        arrow.borderLeftColor.setState(Color.transparent(), component.Affinity.Intrinsic);
        arrow.borderRightWidth.setState(Math.round(arrowWidth / 2), component.Affinity.Intrinsic);
        arrow.borderRightStyle.setState("solid", component.Affinity.Intrinsic);
        arrow.borderRightColor.setState(Color.transparent(), component.Affinity.Intrinsic);
        arrow.borderTopWidth.setState(Math.round(arrowHeight), component.Affinity.Intrinsic);
        arrow.borderTopStyle.setState("solid", component.Affinity.Intrinsic);
        arrow.borderTopColor.setState(backgroundColor, component.Affinity.Intrinsic);
      } else if (Math.round(sourceX) <= Math.round(offsetLeft - arrowHeight) && arrowYMin <= sourceY && sourceY <= arrowYMax) {
        arrow.display.setState("block");
        arrow.left.setState(Math.round(-arrowHeight), component.Affinity.Intrinsic);
        arrow.top.setState(Math.round(sourceY - offsetTop - arrowWidth / 2), component.Affinity.Intrinsic);
        arrow.borderTopWidth.setState(Math.round(arrowWidth / 2), component.Affinity.Intrinsic);
        arrow.borderTopStyle.setState("solid", component.Affinity.Intrinsic);
        arrow.borderTopColor.setState(Color.transparent(), component.Affinity.Intrinsic);
        arrow.borderBottomWidth.setState(Math.round(arrowWidth / 2), component.Affinity.Intrinsic);
        arrow.borderBottomStyle.setState("solid", component.Affinity.Intrinsic);
        arrow.borderBottomColor.setState(Color.transparent(), component.Affinity.Intrinsic);
        arrow.borderRightWidth.setState(Math.round(arrowHeight), component.Affinity.Intrinsic);
        arrow.borderRightStyle.setState("solid", component.Affinity.Intrinsic);
        arrow.borderRightColor.setState(backgroundColor, component.Affinity.Intrinsic);
      } else if (Math.round(offsetRight + arrowHeight) <= Math.round(sourceX) && arrowYMin <= sourceY && sourceY <= arrowYMax) {
        arrow.display.setState("block", component.Affinity.Intrinsic);
        arrow.right.setState(Math.round(-arrowHeight), component.Affinity.Intrinsic);
        arrow.top.setState(Math.round(sourceY - offsetTop - arrowWidth / 2), component.Affinity.Intrinsic);
        arrow.borderTopWidth.setState(Math.round(arrowWidth / 2), component.Affinity.Intrinsic);
        arrow.borderTopStyle.setState("solid", component.Affinity.Intrinsic);
        arrow.borderTopColor.setState(Color.transparent(), component.Affinity.Intrinsic);
        arrow.borderBottomWidth.setState(Math.round(arrowWidth / 2), component.Affinity.Intrinsic);
        arrow.borderBottomStyle.setState("solid", component.Affinity.Intrinsic);
        arrow.borderBottomColor.setState(Color.transparent(), component.Affinity.Intrinsic);
        arrow.borderLeftWidth.setState(Math.round(arrowHeight), component.Affinity.Intrinsic);
        arrow.borderLeftStyle.setState("solid", component.Affinity.Intrinsic);
        arrow.borderLeftColor.setState(backgroundColor, component.Affinity.Intrinsic);
      } else {
        arrow.display.setState("none", component.Affinity.Intrinsic);
      }
    }
    onClick(event) {
      event.stopPropagation();
    }
    init(init) {
      super.init(init);
      if (init.source !== void 0) {
        this.source.setView(init.source);
      }
      if (init.placement !== void 0) {
        this.placement(init.placement);
      }
      if (init.placementFrame !== void 0) {
        this.placementFrame(init.placementFrame);
      }
      if (init.arrowWidth !== void 0) {
        this.arrowWidth(init.arrowWidth);
      }
      if (init.arrowHeight !== void 0) {
        this.arrowHeight(init.arrowHeight);
      }
    }
  }
  PopoverView.HiddenState = 0;
  PopoverView.HidingState = 1;
  PopoverView.HideState = 2;
  PopoverView.ShownState = 3;
  PopoverView.ShowingState = 4;
  PopoverView.ShowState = 5;
  __decorate([ StyleAnimator({
    propertyNames: "background-color",
    type: Color,
    value: null,
    didSetValue(newBackgroundColor, oldBackgroundColor) {
      this.owner.place();
    }
  }) ], PopoverView.prototype, "backgroundColor", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    value: 0
  }) ], PopoverView.prototype, "displayPhase", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.zero()
  }) ], PopoverView.prototype, "placementGap", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.px(10)
  }) ], PopoverView.prototype, "arrowWidth", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.px(8)
  }) ], PopoverView.prototype, "arrowHeight", void 0);
  __decorate([ ViewRef({
    implements: true,
    observes: true,
    willAttachView(sourceView) {
      this.owner.callObservers("popoverWillAttachSource", sourceView, this.owner);
    },
    didAttachView(sourceView) {
      this.owner.requireUpdate(View.NeedsLayout);
    },
    didDetachView(sourceView) {
      this.owner.callObservers("popoverDidDetachSource", sourceView, this.owner);
    },
    viewDidMount(view) {
      this.owner.place();
    },
    viewDidResize(viewContext, view) {
      this.owner.place();
    },
    viewDidScroll(viewContext, view) {
      this.owner.place();
    },
    viewDidAnimate(viewContext, view) {
      this.owner.place();
    },
    viewDidLayout(viewContext, view) {
      this.owner.place();
    },
    viewDidProject(viewContext, view) {
      this.owner.place();
    },
    viewDidSetAttribute(name, value, view) {
      this.owner.place();
    },
    viewDidSetStyle(name, value, priority, view) {
      this.owner.place();
    }
  }) ], PopoverView.prototype, "source", void 0);
  __decorate([ component.Property({
    type: math.R2Box,
    value: null,
    didSetValue(placementFrame) {
      this.owner.place();
    },
    fromAny(value) {
      return value !== null ? math.R2Box.fromAny(value) : null;
    }
  }) ], PopoverView.prototype, "placementFrame", void 0);
  __decorate([ component.Property({
    type: Boolean,
    value: false,
    didSetValue(dropdown) {
      this.owner.place();
    }
  }) ], PopoverView.prototype, "dropdown", void 0);
  class DrawerView extends HtmlView {
    constructor(node) {
      super(node);
      this.modality = true;
      this.initDrawer();
    }
    initDrawer() {
      this.addClass("drawer");
      this.display.setState("flex", component.Affinity.Intrinsic);
      this.overflowX.setState("hidden", component.Affinity.Intrinsic);
      this.overflowY.setState("auto", component.Affinity.Intrinsic);
      this.overscrollBehaviorY.setState("contain", component.Affinity.Intrinsic);
      this.overflowScrolling.setState("touch", component.Affinity.Intrinsic);
    }
    isHorizontal() {
      return this.placement.value === "top" || this.placement.value === "bottom";
    }
    isVertical() {
      return this.placement.value === "left" || this.placement.value === "right";
    }
    willSetPlacement(newPlacement, oldPlacement) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewWillSetPlacement !== void 0) {
          observer.viewWillSetPlacement(newPlacement, oldPlacement, this);
        }
      }
    }
    onSetPlacement(newPlacement, oldPlacement) {}
    didSetPlacement(newPlacement, oldPlacement) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewDidSetPlacement !== void 0) {
          observer.viewDidSetPlacement(newPlacement, oldPlacement, this);
        }
      }
    }
    willPresent() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewWillPresent !== void 0) {
          observer.viewWillPresent(this);
        }
      }
    }
    didPresent() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewDidPresent !== void 0) {
          observer.viewDidPresent(this);
        }
      }
    }
    willDismiss() {
      const modalService = this.modalProvider.service;
      if (modalService !== void 0 && modalService !== null) {
        modalService.dismissModal(this);
      }
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewWillDismiss !== void 0) {
          observer.viewWillDismiss(this);
        }
      }
    }
    didDismiss() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewDidDismiss !== void 0) {
          observer.viewDidDismiss(this);
        }
      }
    }
    willExpand() {
      const modalService = this.modalProvider.service;
      if (modalService !== void 0 && modalService !== null) {
        modalService.dismissModal(this);
      }
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewWillExpand !== void 0) {
          observer.viewWillExpand(this);
        }
      }
    }
    didExpand() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewDidExpand !== void 0) {
          observer.viewDidExpand(this);
        }
      }
    }
    willCollapse() {
      const modalService = this.modalProvider.service;
      if (modalService !== void 0 && modalService !== null) {
        modalService.dismissModal(this);
      }
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewWillCollapse !== void 0) {
          observer.viewWillCollapse(this);
        }
      }
    }
    didCollapse() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewDidCollapse !== void 0) {
          observer.viewDidCollapse(this);
        }
      }
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.display.setState(!this.slide.dismissed ? "flex" : "none", component.Affinity.Intrinsic);
      this.layoutDrawer(viewContext);
      if (viewContext.viewportIdiom === "mobile") {
        this.boxShadow.setState(this.getLookOr(Look.shadow, Mood.floating, null), component.Affinity.Intrinsic);
      } else {
        this.boxShadow.setState(this.getLookOr(Look.shadow, null), component.Affinity.Intrinsic);
      }
    }
    layoutDrawer(viewContext) {
      const placement = this.placement.value;
      if (placement === "top") {
        this.layoutDrawerTop(viewContext);
      } else if (placement === "right") {
        this.layoutDrawerRight(viewContext);
      } else if (placement === "bottom") {
        this.layoutDrawerBottom(viewContext);
      } else if (placement === "left") {
        this.layoutDrawerLeft(viewContext);
      }
    }
    layoutDrawerTop(viewContext) {
      const slidePhase = this.slide.getPhase();
      this.addClass("drawer-top").removeClass("drawer-right").removeClass("drawer-bottom").removeClass("drawer-left");
      this.position.setState("fixed", component.Affinity.Intrinsic);
      this.width.setState(null, component.Affinity.Intrinsic);
      this.height.setState(null, component.Affinity.Intrinsic);
      this.left.setState(math.Length.zero(), component.Affinity.Intrinsic);
      this.right.setState(math.Length.zero(), component.Affinity.Intrinsic);
      this.bottom.setState(null, component.Affinity.Intrinsic);
      let height = this.height.value;
      if (height === null) {
        height = math.Length.px(this.node.offsetHeight);
      }
      this.top.setState(height.times(slidePhase - 1), component.Affinity.Intrinsic);
      this.effectiveWidth.setValue(this.width.value);
      this.effectiveHeight.setValue(height.times(slidePhase), component.Affinity.Intrinsic);
      let edgeInsets = this.edgeInsets.superValue;
      if (edgeInsets === void 0 || edgeInsets === null) {
        edgeInsets = viewContext.viewport.safeArea;
      }
      this.edgeInsets.setValue({
        insetTop: 0,
        insetRight: edgeInsets.insetRight,
        insetBottom: 0,
        insetLeft: edgeInsets.insetLeft
      }, component.Affinity.Intrinsic);
      if (this.stretch.collapsed) {
        this.expand();
      }
    }
    layoutDrawerRight(viewContext) {
      const stretchPhase = this.stretch.getPhase();
      const slidePhase = this.slide.getPhase();
      this.removeClass("drawer-top").addClass("drawer-right").removeClass("drawer-bottom").removeClass("drawer-left");
      this.position.setState("fixed", component.Affinity.Intrinsic);
      this.height.setState(null, component.Affinity.Intrinsic);
      this.top.setState(math.Length.zero(), component.Affinity.Intrinsic);
      this.bottom.setState(math.Length.zero(), component.Affinity.Intrinsic);
      this.left.setState(null, component.Affinity.Intrinsic);
      let width;
      if (this.width.hasAffinity(component.Affinity.Intrinsic)) {
        const collapsedWidth = this.collapsedWidth.getValue();
        const expandedWidth = this.expandedWidth.getValue();
        width = collapsedWidth.times(1 - stretchPhase).plus(expandedWidth.times(stretchPhase));
      } else {
        width = this.width.value;
        if (width === null) {
          width = math.Length.px(this.node.offsetWidth);
        }
      }
      this.width.setState(width, component.Affinity.Intrinsic);
      this.right.setState(width.times(slidePhase - 1), component.Affinity.Intrinsic);
      this.effectiveWidth.setValue(width.times(slidePhase), component.Affinity.Intrinsic);
      this.effectiveHeight.setValue(this.height.value, component.Affinity.Intrinsic);
      let edgeInsets = this.edgeInsets.superValue;
      if (edgeInsets === void 0 || edgeInsets === null || edgeInsets === null) {
        edgeInsets = viewContext.viewport.safeArea;
      }
      this.paddingTop.setState(math.Length.px(edgeInsets.insetTop), component.Affinity.Intrinsic);
      this.paddingBottom.setState(math.Length.px(edgeInsets.insetBottom), component.Affinity.Intrinsic);
      this.edgeInsets.setValue({
        insetTop: 0,
        insetRight: edgeInsets.insetRight,
        insetBottom: 0,
        insetLeft: 0
      }, component.Affinity.Intrinsic);
    }
    layoutDrawerBottom(viewContext) {
      const slidePhase = this.slide.getPhase();
      this.removeClass("drawer-top").removeClass("drawer-right").addClass("drawer-bottom").removeClass("drawer-left");
      this.position.setState("fixed", component.Affinity.Intrinsic);
      this.width.setState(null, component.Affinity.Intrinsic);
      this.height.setState(null, component.Affinity.Intrinsic);
      this.left.setState(math.Length.zero(), component.Affinity.Intrinsic);
      this.right.setState(math.Length.zero(), component.Affinity.Intrinsic);
      this.top.setState(null, component.Affinity.Intrinsic);
      let height = this.height.value;
      if (height === null) {
        height = math.Length.px(this.node.offsetHeight);
      }
      this.bottom.setState(height.times(slidePhase - 1), component.Affinity.Intrinsic);
      this.effectiveWidth.setValue(this.width.value, component.Affinity.Intrinsic);
      this.effectiveHeight.setValue(height.times(slidePhase), component.Affinity.Intrinsic);
      let edgeInsets = this.edgeInsets.superValue;
      if (edgeInsets === void 0 || edgeInsets === null || edgeInsets === null) {
        edgeInsets = viewContext.viewport.safeArea;
      }
      this.edgeInsets.setValue({
        insetTop: 0,
        insetRight: edgeInsets.insetRight,
        insetBottom: 0,
        insetLeft: edgeInsets.insetLeft
      }, component.Affinity.Intrinsic);
      if (this.stretch.collapsed) {
        this.expand();
      }
    }
    layoutDrawerLeft(viewContext) {
      const stretchPhase = this.stretch.getPhase();
      const slidePhase = this.slide.getPhase();
      this.removeClass("drawer-top").removeClass("drawer-right").removeClass("drawer-bottom").addClass("drawer-left");
      this.position.setState("fixed", component.Affinity.Intrinsic);
      this.height.setState(null, component.Affinity.Intrinsic);
      this.top.setState(math.Length.zero(), component.Affinity.Intrinsic);
      this.bottom.setState(math.Length.zero(), component.Affinity.Intrinsic);
      this.right.setState(null, component.Affinity.Intrinsic);
      let width;
      if (this.width.hasAffinity(component.Affinity.Intrinsic)) {
        const collapsedWidth = this.collapsedWidth.getValue();
        const expandedWidth = this.expandedWidth.getValue();
        width = collapsedWidth.times(1 - stretchPhase).plus(expandedWidth.times(stretchPhase));
      } else {
        width = this.width.value;
        if (width === null) {
          width = math.Length.px(this.node.offsetWidth);
        }
      }
      this.width.setState(width, component.Affinity.Intrinsic);
      this.left.setState(width.times(slidePhase - 1), component.Affinity.Intrinsic);
      this.effectiveWidth.setValue(width.times(slidePhase), component.Affinity.Intrinsic);
      this.effectiveHeight.setValue(this.height.value, component.Affinity.Intrinsic);
      let edgeInsets = this.edgeInsets.superValue;
      if (edgeInsets === void 0 || edgeInsets === null || edgeInsets === null) {
        edgeInsets = viewContext.viewport.safeArea;
      }
      this.paddingTop.setState(math.Length.px(edgeInsets.insetTop), component.Affinity.Intrinsic);
      this.paddingBottom.setState(math.Length.px(edgeInsets.insetBottom), component.Affinity.Intrinsic);
      this.edgeInsets.setValue({
        insetTop: 0,
        insetRight: 0,
        insetBottom: 0,
        insetLeft: edgeInsets.insetLeft
      }, component.Affinity.Intrinsic);
    }
    get modalView() {
      return this;
    }
    get modalState() {
      return this.slide.modalState;
    }
    showModal(options, timing) {
      if (options.modal !== void 0) {
        this.modality = options.modal;
      }
      this.present(timing);
    }
    hideModal(timing) {
      this.dismiss(timing);
    }
    present(timing) {
      if (timing === void 0 || timing === true) {
        timing = this.getLookOr(Look.timing, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      this.slide.present(timing);
    }
    dismiss(timing) {
      if (timing === void 0 || timing === true) {
        timing = this.getLookOr(Look.timing, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      this.slide.dismiss(timing);
    }
    expand(timing) {
      if (timing === void 0 || timing === true) {
        timing = this.getLookOr(Look.timing, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      this.stretch.expand(timing);
    }
    collapse(timing) {
      if (timing === void 0 || timing === true) {
        timing = this.getLookOr(Look.timing, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      this.stretch.collapse(timing);
    }
    toggle(timing) {
      if (timing === void 0 || timing === true) {
        timing = this.getLookOr(Look.timing, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      if (this.viewportIdiom === "mobile" || this.isHorizontal()) {
        if (this.slide.presented) {
          this.slide.dismiss(timing);
        } else {
          this.stretch.expand(timing);
          this.slide.present(timing);
          const modalService = this.modalProvider.service;
          if (modalService !== void 0 && modalService !== null) {
            modalService.presentModal(this, {
              modal: true
            });
          }
        }
      } else {
        this.stretch.toggle(timing);
        this.slide.present(timing);
      }
    }
    init(init) {
      super.init(init);
      if (init.placement !== void 0) {
        this.placement(init.placement);
      }
      if (init.collapsedWidth !== void 0) {
        this.collapsedWidth(init.collapsedWidth);
      }
      if (init.expandedWidth !== void 0) {
        this.expandedWidth(init.expandedWidth);
      }
    }
  }
  __decorate([ ThemeConstraintAnimator({
    type: math.Length,
    value: math.Length.px(60)
  }) ], DrawerView.prototype, "collapsedWidth", void 0);
  __decorate([ ThemeConstraintAnimator({
    type: math.Length,
    value: math.Length.px(200)
  }) ], DrawerView.prototype, "expandedWidth", void 0);
  __decorate([ constraint.ConstraintProperty({
    type: math.Length,
    value: null,
    toNumber(value) {
      return value !== null ? value.pxValue() : 0;
    }
  }) ], DrawerView.prototype, "effectiveWidth", void 0);
  __decorate([ constraint.ConstraintProperty({
    type: math.Length,
    value: null,
    toNumber(value) {
      return value !== null ? value.pxValue() : 0;
    }
  }) ], DrawerView.prototype, "effectiveHeight", void 0);
  __decorate([ component.Property({
    type: String,
    value: "left",
    updateFlags: View.NeedsResize | View.NeedsLayout,
    willSetValue(newPlacement, oldPlacement) {
      this.owner.willSetPlacement(newPlacement, oldPlacement);
    },
    didSetValue(newPlacement, oldPlacement) {
      this.owner.onSetPlacement(newPlacement, oldPlacement);
      this.owner.didSetPlacement(newPlacement, oldPlacement);
    }
  }) ], DrawerView.prototype, "placement", void 0);
  __decorate([ ThemeAnimator({
    type: Presence,
    value: Presence.presented(),
    updateFlags: View.NeedsLayout,
    willPresent() {
      this.owner.willPresent();
    },
    didPresent() {
      this.owner.didPresent();
    },
    willDismiss() {
      this.owner.willDismiss();
    },
    didDismiss() {
      this.owner.didDismiss();
    }
  }) ], DrawerView.prototype, "slide", void 0);
  __decorate([ ThemeAnimator({
    type: Expansion,
    value: Expansion.expanded(),
    updateFlags: View.NeedsResize | View.NeedsLayout,
    willExpand() {
      this.owner.willExpand();
    },
    didExpand() {
      this.owner.didExpand();
    },
    willCollapse() {
      this.owner.willCollapse();
    },
    didCollapse() {
      this.owner.didCollapse();
    }
  }) ], DrawerView.prototype, "stretch", void 0);
  __decorate([ component.Property({
    type: Object,
    inherits: true,
    value: null
  }) ], DrawerView.prototype, "edgeInsets", void 0);
  class DrawerButton extends IconButton {
    constructor(node) {
      super(node);
      this.drawerView = null;
      this.initIcon();
    }
    initButton() {
      super.initButton();
      this.addClass("drawer-button");
    }
    initIcon() {
      this.pushIcon(DrawerButton.hamburgerIcon);
    }
    setDrawerView(drawerView) {
      this.drawerView = drawerView;
    }
    onClick(event) {
      super.onClick(event);
      const drawerView = this.drawerView;
      if (drawerView !== null) {
        drawerView.toggle();
      }
    }
    static get hamburgerIcon() {
      return VectorIcon.create(24, 24, "M21,17L21,19L3,19L3,17L21,17ZM21,11L21,13L3,13L3,11L21,11ZM3,5L3,7L21,7L21,5L3,5Z");
    }
  }
  __decorate([ util.Lazy ], DrawerButton, "hamburgerIcon", null);
  class DeckPost {
    constructor(key, grow, shrink, basis, width, left, right) {
      this.key = key;
      this.grow = grow;
      this.shrink = shrink;
      this.basis = basis;
      this.width = width;
      this.left = left;
      this.right = right;
    }
    withGrow(grow) {
      return this.copy(this.key, grow, this.shrink, this.basis, this.width, this.left, this.right);
    }
    withShrink(shrink) {
      return this.copy(this.key, this.grow, shrink, this.basis, this.width, this.left, this.right);
    }
    withBasis(basis) {
      basis = math.Length.fromAny(basis);
      return this.copy(this.key, this.grow, this.shrink, basis, this.width, this.left, this.right);
    }
    resized(width, left, right) {
      if (width !== null) {
        width = math.Length.fromAny(width);
      }
      if (left !== null) {
        left = math.Length.fromAny(left);
      }
      if (right !== null) {
        right = math.Length.fromAny(right);
      }
      return this.copy(this.key, this.grow, this.shrink, this.basis, width, left, right);
    }
    copy(key, grow, shrink, basis, width, left, right) {
      return new DeckPost(key, grow, shrink, basis, width, left, right);
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof DeckPost) {
        return this.key === that.key && this.grow === that.grow && this.shrink === that.shrink && this.basis.equivalentTo(that.basis, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof DeckPost) {
        return this.key === that.key && this.grow === that.grow && this.shrink === that.shrink && this.basis.equals(that.basis) && util.Equals(this.width, that.width) && util.Equals(this.left, that.left) && util.Equals(this.right, that.right);
      }
      return false;
    }
    debug(output) {
      output = output.write("DeckPost").write(46).write("create").write(40).debug(this.key).write(", ").debug(this.grow).write(", ").debug(this.shrink).write(", ").debug(this.basis).write(41);
      if (this.width !== null || this.left !== null || this.right !== null) {
        output = output.write(46).write("resized").write(40).debug(this.width).write(", ").debug(this.left).write(", ").debug(this.right).write(", ").write(41);
      }
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static create(key, grow, shrink, basis) {
      if (grow === void 0) {
        grow = 0;
      }
      if (shrink === void 0) {
        shrink = 1;
      }
      if (basis !== void 0) {
        basis = math.Length.fromAny(basis);
      } else {
        basis = math.Length.zero();
      }
      return new DeckPost(key, grow, shrink, basis, null, null, null);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof DeckPost) {
        return value;
      } else if (typeof value === "object" && value !== null) {
        return DeckPost.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static fromInit(init) {
      let key = init.key;
      if (key === void 0) {
        key = "";
      }
      let grow = init.grow;
      if (grow === void 0) {
        grow = 0;
      }
      let shrink = init.shrink;
      if (shrink === void 0) {
        shrink = 1;
      }
      let basis = init.basis;
      if (basis !== void 0) {
        basis = math.Length.fromAny(basis);
      } else {
        basis = math.Length.zero();
      }
      let width = init.width;
      if (width !== void 0 && width !== null) {
        width = math.Length.fromAny(width);
      } else {
        width = null;
      }
      let left = init.left;
      if (left !== void 0 && left !== null) {
        left = math.Length.fromAny(left);
      } else {
        left = null;
      }
      let right = init.right;
      if (right !== void 0 && right !== null) {
        right = math.Length.fromAny(right);
      } else {
        right = null;
      }
      return new DeckPost(key, grow, shrink, basis, width, left, right);
    }
  }
  class DeckRail {
    constructor(width, left, right, spacing, posts) {
      this.width = width;
      this.left = left;
      this.right = right;
      this.spacing = spacing;
      this.posts = posts;
    }
    lookupPost(key) {
      const posts = this.posts;
      for (let i = 0, n = posts.length; i < n; i += 1) {
        const post = posts[i];
        if (key === post.key) {
          return i;
        }
      }
      return void 0;
    }
    getPost(key) {
      const posts = this.posts;
      if (typeof key === "number") {
        const post = posts[key];
        if (post !== void 0) {
          return post;
        }
      } else if (typeof key === "string") {
        for (let i = 0, n = posts.length; i < n; i += 1) {
          const post = posts[i];
          if (key === post.key) {
            return post;
          }
        }
      }
      return null;
    }
    resized(width, left, right, spacing) {
      width = math.Length.fromAny(width);
      if (left === void 0) {
        left = this.left;
      } else if (left !== null) {
        left = math.Length.fromAny(left);
      }
      if (right === void 0) {
        right = this.right;
      } else if (right !== null) {
        right = math.Length.fromAny(right);
      }
      if (spacing === void 0) {
        spacing = this.spacing;
      } else if (spacing !== null) {
        spacing = math.Length.fromAny(spacing);
      }
      if (util.Equals(this.width, width) && util.Equals(this.left, left) && util.Equals(this.right, right) && util.Equals(this.spacing, spacing)) {
        return this;
      } else {
        const oldPosts = this.posts;
        const postCount = oldPosts.length;
        const newPosts = new Array(postCount);
        const railWidth = width.pxValue();
        const railLeft = left !== null ? left.pxValue(railWidth) : 0;
        const railRight = right !== null ? right.pxValue(railWidth) : 0;
        const postSpacing = spacing !== null ? spacing.pxValue(railWidth) : 0;
        let grow = 0;
        let shrink = 0;
        let basis = railLeft + railRight;
        let x = railLeft;
        for (let i = 0; i < postCount; i += 1) {
          if (i !== 0) {
            basis += postSpacing;
            x += postSpacing;
          }
          const post = oldPosts[i];
          const postWidth = post.basis.pxValue(railWidth);
          newPosts[i] = post.resized(postWidth, x, railWidth - postWidth - x);
          grow += post.grow;
          shrink += post.shrink;
          basis += postWidth;
          x += postWidth;
        }
        if (basis < railWidth && grow > 0) {
          const delta = railWidth - basis;
          let x = railLeft;
          let j = 0;
          for (let i = 0; i < postCount; i += 1) {
            const post = newPosts[i];
            if (j !== 0) {
              basis += postSpacing;
              x += postSpacing;
            }
            const postBasis = post.basis.pxValue(railWidth);
            const postWidth = postBasis + delta * (post.grow / grow);
            newPosts[i] = post.resized(postWidth, x, railWidth - postWidth - x);
            x += postWidth;
            j += 1;
          }
        } else if (basis > railWidth && shrink > 0) {
          const delta = basis - railWidth;
          let x = railLeft;
          let j = 0;
          for (let i = 0; i < postCount; i += 1) {
            const post = newPosts[i];
            if (j !== 0) {
              basis += postSpacing;
              x += postSpacing;
            }
            const postBasis = post.basis.pxValue(railWidth);
            const postWidth = postBasis - delta * (post.shrink / shrink);
            newPosts[i] = post.resized(postWidth, x, railWidth - postWidth - x);
            x += postWidth;
            j += 1;
          }
        }
        return new DeckRail(width, left, right, spacing, newPosts);
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof DeckRail) {
        const thesePosts = this.posts;
        const thosePosts = that.posts;
        const n = thesePosts.length;
        if (n === thosePosts.length) {
          for (let i = 0; i < n; i += 1) {
            if (!thesePosts[i].equivalentTo(thosePosts[i], epsilon)) {
              return false;
            }
          }
          return true;
        }
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof DeckRail) {
        return util.Equals(this.width, that.width) && util.Equals(this.left, that.left) && util.Equals(this.right, that.right) && util.Equals(this.spacing, that.spacing) && util.Arrays.equal(this.posts, that.posts);
      }
      return false;
    }
    debug(output) {
      output = output.write("DeckRail").write(46).write("of").write(40);
      for (let i = 0, n = this.posts.length; i < n; i += 1) {
        if (i !== 0) {
          output = output.write(", ");
        }
        output = output.debug(this.posts[i]);
      }
      output = output.write(41);
      if (this.width !== null || this.left !== null || this.right !== null || this.spacing !== null) {
        output = output.write(46).write("resized").write(40).debug(this.width).write(", ").debug(this.left).write(", ").debug(this.right).write(", ").debug(this.spacing).write(41);
      }
      return output;
    }
    toString() {
      return codec.Format.debug(this);
    }
    static of(...deckPosts) {
      const n = deckPosts.length;
      const posts = new Array(n);
      for (let i = 0; i < n; i += 1) {
        posts[i] = DeckPost.fromAny(deckPosts[i]);
      }
      return new DeckRail(null, null, null, null, posts);
    }
    static create(posts) {
      return new DeckRail(null, null, null, null, posts);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof DeckRail) {
        return value;
      } else if (typeof value === "object" && value !== null) {
        return DeckRail.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static fromInit(init) {
      let width = init.width;
      if (width !== void 0 && width !== null) {
        width = math.Length.fromAny(width);
      } else {
        width = null;
      }
      let left = init.left;
      if (left !== void 0 && left !== null) {
        left = math.Length.fromAny(left);
      } else {
        left = null;
      }
      let right = init.right;
      if (right !== void 0 && right !== null) {
        right = math.Length.fromAny(right);
      } else {
        right = null;
      }
      let spacing = init.spacing;
      if (spacing !== void 0 && spacing !== null) {
        spacing = math.Length.fromAny(spacing);
      } else {
        spacing = null;
      }
      let posts;
      if (init.posts !== void 0) {
        const n = init.posts.length;
        posts = new Array(n);
        for (let i = 0; i < n; i += 1) {
          posts[i] = DeckPost.fromAny(init.posts[i]);
        }
      } else {
        posts = [];
      }
      return new DeckRail(width, left, right, spacing, posts);
    }
  }
  class DeckSlot extends HtmlView {
    constructor(node) {
      super(node);
      this.initSlot();
    }
    initSlot() {
      this.addClass("deck-slot");
    }
  }
  __decorate([ component.Property({
    type: DeckPost,
    value: null,
    inherits: true
  }) ], DeckSlot.prototype, "post", void 0);
  __decorate([ component.Property({
    type: DeckPost,
    value: null
  }) ], DeckSlot.prototype, "nextPost", void 0);
  __decorate([ component.Property({
    type: DeckPost,
    value: null
  }) ], DeckSlot.prototype, "prevPost", void 0);
  class DeckSlider extends DeckSlot {
    constructor(node) {
      super(node);
      this.itemCount = 0;
      this.item = null;
      this.initSlider();
    }
    initSlider() {
      this.addClass("deck-slider");
      this.position.setState("relative", component.Affinity.Intrinsic);
    }
    get colorLook() {
      return Look.color;
    }
    createItem(value) {
      const itemView = HtmlView.fromTag("span");
      itemView.display.setState("flex", component.Affinity.Intrinsic);
      itemView.alignItems.setState("center", component.Affinity.Intrinsic);
      itemView.whiteSpace.setState("nowrap", component.Affinity.Intrinsic);
      itemView.text(value);
      return itemView;
    }
    pushItem(newItemView, timing) {
      if (typeof newItemView === "string") {
        newItemView = this.createItem(newItemView);
      }
      const oldItemCount = this.itemCount;
      const newItemCount = oldItemCount + 1;
      this.itemCount = newItemCount;
      const oldItemKey = "item" + oldItemCount;
      const oldItemRef = this.getFastener(oldItemKey, ViewRef);
      const oldItemView = oldItemRef !== null ? oldItemRef.view : null;
      const newItemKey = "item" + newItemCount;
      const newItemRef = DeckSliderItemRef.create(this);
      Object.defineProperty(newItemRef, "name", {
        value: newItemKey,
        configurable: true
      });
      newItemRef.itemIndex = newItemCount;
      this.willPushItem(newItemView, oldItemView);
      this.item = newItemRef;
      this.setFastener(newItemKey, newItemRef);
      newItemRef.setView(newItemView);
      newItemRef.insertView();
      if (timing === void 0 && oldItemCount === 0) {
        timing = false;
      } else if (timing === void 0 || timing === true) {
        timing = this.getLookOr(Look.timing, Mood.navigating, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      if (timing === false) {
        this.didPushItem(newItemView, oldItemView);
      }
    }
    willPushItem(newItemView, oldItemView) {
      this.forEachObserver((function(observer) {
        if (observer.deckSliderWillPushItem !== void 0) {
          observer.deckSliderWillPushItem(newItemView, oldItemView, this);
        }
      }));
    }
    didPushItem(newItemView, oldItemView) {
      if (oldItemView !== null && oldItemView.parent === this) {
        oldItemView.remove();
      }
      this.forEachObserver((function(observer) {
        if (observer.deckSliderDidPushItem !== void 0) {
          observer.deckSliderDidPushItem(newItemView, oldItemView, this);
        }
      }));
    }
    popItem(timing) {
      const oldItemCount = this.itemCount;
      const newItemCount = oldItemCount - 1;
      this.itemCount = newItemCount;
      const oldItemKey = "item" + oldItemCount;
      const oldItemRef = this.getFastener(oldItemKey, ViewRef);
      const oldItemView = oldItemRef !== null ? oldItemRef.view : null;
      if (oldItemView !== null) {
        const newItemKey = "item" + newItemCount;
        const newItemRef = this.getFastener(newItemKey, ViewRef);
        const newItemView = newItemRef !== null ? newItemRef.view : null;
        this.willPopItem(newItemView, oldItemView);
        this.item = newItemRef;
        if (newItemRef !== null) {
          newItemRef.insertView();
        }
        if (timing === void 0 || timing === true) {
          timing = this.getLookOr(Look.timing, Mood.navigating, false);
        } else {
          timing = util.Timing.fromAny(timing);
        }
        if (timing === false) {
          this.didPopItem(newItemView, oldItemView);
        }
      }
      return oldItemView;
    }
    willPopItem(newItemView, oldItemView) {
      this.forEachObserver((function(observer) {
        if (observer.deckSliderWillPopItem !== void 0) {
          observer.deckSliderWillPopItem(newItemView, oldItemView, this);
        }
      }));
    }
    didPopItem(newItemView, oldItemView) {
      const oldItemKey = oldItemView.key;
      oldItemView.remove();
      if (oldItemKey !== void 0) {
        const oldItemRef = this.getFastener(oldItemKey, ViewRef);
        if (oldItemRef !== null && oldItemRef.itemIndex > this.itemCount) {
          this.setFastener(oldItemKey, null);
        }
      }
      this.forEachObserver((function(observer) {
        if (observer.deckSliderDidPopItem !== void 0) {
          observer.deckSliderDidPopItem(newItemView, oldItemView, this);
        }
      }));
    }
    didLayout(viewContext) {
      if (!this.deckPhase.tweening) {
        const deckPhase = this.deckPhase.value;
        if (deckPhase !== void 0) {
          const nextItemIndex = Math.round(deckPhase + 1);
          const nextItemKey = "item" + nextItemIndex;
          const nextItemRef = this.getFastener(nextItemKey, ViewRef);
          const nextItemView = nextItemRef !== null ? nextItemRef.view : null;
          if (nextItemView !== null) {
            this.didPopItem(this.item !== null ? this.item.view : null, nextItemView);
          } else if (this.item !== null && this.item.view !== null && Math.round(deckPhase) > 0) {
            const prevItemIndex = Math.round(deckPhase - 1);
            const prevItemKey = "item" + prevItemIndex;
            const prevItemRef = this.getFastener(prevItemKey, ViewRef);
            const prevItemView = prevItemRef !== null ? prevItemRef.view : null;
            this.didPushItem(this.item.view, prevItemView);
          }
        }
      }
      super.didLayout(viewContext);
    }
  }
  __decorate([ ThemeAnimator({
    type: Number,
    inherits: true,
    updateFlags: View.NeedsLayout
  }) ], DeckSlider.prototype, "deckPhase", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    value: .5
  }) ], DeckSlider.prototype, "slotAlign", void 0);
  const DeckSliderItem = function(_super) {
    const DeckSliderItem = _super.extend("DeckSliderItem");
    DeckSliderItem.prototype.didAttachView = function(itemView) {
      this.initItem(itemView);
    };
    DeckSliderItem.prototype.insertChild = function(parent, child, target, key) {
      const targetKey = "item" + (this.itemIndex + 1);
      target = parent.getChild(targetKey);
      parent.insertChild(child, target, key);
    };
    DeckSliderItem.prototype.viewDidApplyTheme = function(theme, mood, timing, itemView) {
      if (itemView.color.hasAffinity(component.Affinity.Intrinsic)) {
        itemView.color.setState(theme.getOr(this.owner.colorLook, mood, null), timing, component.Affinity.Intrinsic);
      }
    };
    DeckSliderItem.prototype.viewDidLayout = function(viewContext, itemView) {
      this.layoutItem(itemView);
    };
    DeckSliderItem.prototype.initItem = function(itemView) {
      itemView.position.setState("absolute", component.Affinity.Intrinsic);
    };
    DeckSliderItem.prototype.layoutItem = function(itemView) {
      const itemIndex = this.itemIndex;
      const slotAlign = this.owner.slotAlign.getValue();
      let slotWidth = this.owner.width.state;
      slotWidth = slotWidth instanceof math.Length ? slotWidth.pxValue() : this.owner.node.offsetWidth;
      let slotHeight = this.owner.height.state;
      slotHeight = slotHeight instanceof math.Length ? slotHeight.pxValue() : this.owner.node.offsetHeight;
      const deckPhase = this.owner.deckPhase.getValueOr(0);
      const nextIndex = Math.max(this.owner.itemCount, Math.ceil(deckPhase));
      const prevIndex = nextIndex - 1;
      const itemPhase = deckPhase - prevIndex;
      let itemWidth = itemView.width.state;
      this.itemWidth = itemWidth;
      if (itemWidth instanceof math.Length) {
        itemWidth = itemWidth.pxValue(slotWidth);
      } else {
        itemWidth = itemView.node.offsetWidth;
        if (this.owner.deckPhase.tweening) {
          itemView.width.setState(itemWidth, component.Affinity.Intrinsic);
        } else {
          itemView.width.setState(this.itemWidth, component.Affinity.Intrinsic);
        }
      }
      const slotSpace = slotWidth - itemWidth;
      if (itemIndex < prevIndex || itemIndex === prevIndex && itemPhase === 1) {
        itemView.left.setState(0, component.Affinity.Intrinsic);
        itemView.top.setState(0, component.Affinity.Intrinsic);
        itemView.height.setState(slotHeight, component.Affinity.Intrinsic);
        itemView.opacity.setState(0, component.Affinity.Intrinsic);
        itemView.setCulled(true);
      } else if (itemIndex === prevIndex) {
        itemView.left.setState(slotSpace * slotAlign * (1 - itemPhase), component.Affinity.Intrinsic);
        itemView.top.setState(0, component.Affinity.Intrinsic);
        itemView.height.setState(slotHeight, component.Affinity.Intrinsic);
        itemView.opacity.setState(1 - itemPhase, component.Affinity.Intrinsic);
        itemView.setCulled(false);
      } else if (itemIndex === nextIndex) {
        itemView.left.setState(slotSpace * (1 - itemPhase) + slotSpace * slotAlign * itemPhase, component.Affinity.Intrinsic);
        itemView.top.setState(0, component.Affinity.Intrinsic);
        itemView.height.setState(slotHeight, component.Affinity.Intrinsic);
        itemView.opacity.setState(itemPhase, component.Affinity.Intrinsic);
        itemView.setCulled(false);
      } else {
        itemView.left.setState(slotSpace, component.Affinity.Intrinsic);
        itemView.top.setState(0, component.Affinity.Intrinsic);
        itemView.height.setState(slotHeight, component.Affinity.Intrinsic);
        itemView.opacity.setState(0, component.Affinity.Intrinsic);
        itemView.setCulled(true);
      }
    };
    DeckSliderItem.construct = function(fastenerClass, fastener, owner) {
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.itemIndex = 0;
      fastener.itemWidth = null;
      return fastener;
    };
    return DeckSliderItem;
  }(ViewRef);
  const DeckSliderItemRef = ViewRef.define("DeckSliderItemRef", {
    extends: DeckSliderItem,
    key: true,
    type: HtmlView,
    observes: true
  });
  class DeckButton extends DeckSlot {
    constructor(node) {
      super(node);
      this.labelCount = 0;
      this.label = null;
      this.initButton();
    }
    initButton() {
      this.addClass("deck-button");
      this.position.setState("relative", component.Affinity.Intrinsic);
      this.cursor.setState("pointer", component.Affinity.Intrinsic);
    }
    get colorLook() {
      return Look.accentColor;
    }
    createLabel(value) {
      const labelView = HtmlView.fromTag("span");
      labelView.display.setState("flex", component.Affinity.Intrinsic);
      labelView.alignItems.setState("center", component.Affinity.Intrinsic);
      labelView.whiteSpace.setState("nowrap", component.Affinity.Intrinsic);
      labelView.text(value);
      return labelView;
    }
    pushLabel(newLabelView, timing) {
      if (typeof newLabelView === "string") {
        newLabelView = this.createLabel(newLabelView);
      }
      const oldLabelCount = this.labelCount;
      const newLabelCount = oldLabelCount + 1;
      this.labelCount = newLabelCount;
      const oldLabelKey = "label" + oldLabelCount;
      const oldLabelRef = this.getFastener(oldLabelKey, ViewRef);
      const oldLabelView = oldLabelRef !== null ? oldLabelRef.view : null;
      const newLabelKey = "label" + newLabelCount;
      const newLabelRef = DeckButtonLabelRef.create(this);
      Object.defineProperty(newLabelRef, "name", {
        value: newLabelKey,
        configurable: true
      });
      newLabelRef.labelIndex = newLabelCount;
      this.willPushLabel(newLabelView, oldLabelView);
      this.label = newLabelRef;
      this.setFastener(newLabelKey, newLabelRef);
      newLabelRef.setView(newLabelView);
      newLabelRef.insertView();
      if (timing === void 0 && oldLabelCount === 0) {
        timing = false;
      } else if (timing === void 0 || timing === true) {
        timing = this.getLookOr(Look.timing, Mood.navigating, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      if (timing === false) {
        this.didPushLabel(newLabelView, oldLabelView);
      }
    }
    willPushLabel(newLabelView, oldLabelView) {
      this.forEachObserver((function(observer) {
        if (observer.deckButtonWillPushLabel !== void 0) {
          observer.deckButtonWillPushLabel(newLabelView, oldLabelView, this);
        }
      }));
    }
    didPushLabel(newLabelView, oldLabelView) {
      if (oldLabelView !== null && oldLabelView.parent === this) {
        oldLabelView.remove();
      }
      this.forEachObserver((function(observer) {
        if (observer.deckButtonDidPushLabel !== void 0) {
          observer.deckButtonDidPushLabel(newLabelView, oldLabelView, this);
        }
      }));
    }
    popLabel(timing) {
      const oldLabelCount = this.labelCount;
      const newLabelCount = oldLabelCount - 1;
      this.labelCount = newLabelCount;
      const oldLabelKey = "label" + oldLabelCount;
      const oldLabelRef = this.getFastener(oldLabelKey, ViewRef);
      const oldLabelView = oldLabelRef !== null ? oldLabelRef.view : null;
      if (oldLabelView !== null) {
        const newLabelKey = "label" + newLabelCount;
        const newLabelRef = this.getFastener(newLabelKey, ViewRef);
        const newLabelView = newLabelRef !== null ? newLabelRef.view : null;
        this.willPopLabel(newLabelView, oldLabelView);
        this.label = newLabelRef;
        if (newLabelRef !== null) {
          newLabelRef.insertView();
        }
        if (timing === void 0 || timing === true) {
          timing = this.getLookOr(Look.timing, Mood.navigating, false);
        } else {
          timing = util.Timing.fromAny(timing);
        }
        if (timing === false) {
          this.didPopLabel(newLabelView, oldLabelView);
        }
      }
      return oldLabelView;
    }
    willPopLabel(newLabelView, oldLabelView) {
      this.forEachObserver((function(observer) {
        if (observer.deckButtonWillPopLabel !== void 0) {
          observer.deckButtonWillPopLabel(newLabelView, oldLabelView, this);
        }
      }));
    }
    didPopLabel(newLabelView, oldLabelView) {
      const oldLabelKey = oldLabelView.key;
      oldLabelView.remove();
      if (oldLabelKey !== void 0) {
        const oldLabelRef = this.getFastener(oldLabelKey, ViewRef);
        if (oldLabelRef !== null && oldLabelRef.labelIndex > this.labelCount) {
          this.setFastener(oldLabelKey, null);
        }
      }
      this.forEachObserver((function(observer) {
        if (observer.deckButtonDidPopLabel !== void 0) {
          observer.deckButtonDidPopLabel(newLabelView, oldLabelView, this);
        }
      }));
    }
    didLayout(viewContext) {
      if (!this.deckPhase.tweening) {
        const deckPhase = this.deckPhase.value;
        if (deckPhase !== void 0) {
          const nextLabelIndex = Math.round(deckPhase + 1);
          const nextLabelKey = "label" + nextLabelIndex;
          const nextLabelRef = this.getFastener(nextLabelKey, ViewRef);
          const nextLabelView = nextLabelRef !== null ? nextLabelRef.view : null;
          if (nextLabelView !== null) {
            this.didPopLabel(this.label !== null ? this.label.view : null, nextLabelView);
          } else if (this.label !== null && this.label.view !== null && Math.round(deckPhase) > 0) {
            const prevLabelIndex = Math.round(deckPhase - 1);
            const prevLabelKey = "label" + prevLabelIndex;
            const prevLabelRef = this.getFastener(prevLabelKey, ViewRef);
            const prevLabelView = prevLabelRef !== null ? prevLabelRef.view : null;
            this.didPushLabel(this.label.view, prevLabelView);
          }
        }
      }
      super.didLayout(viewContext);
    }
  }
  __decorate([ component.Property({
    type: math.Length,
    value: math.Length.px(12)
  }) ], DeckButton.prototype, "iconPadding", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    inherits: true,
    updateFlags: View.NeedsLayout
  }) ], DeckButton.prototype, "deckPhase", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    value: 0
  }) ], DeckButton.prototype, "slotAlign", void 0);
  const DeckButtonCloseIcon = function(_super) {
    const DeckButtonCloseIcon = _super.extend("DeckButtonCloseIcon");
    DeckButtonCloseIcon.prototype.didAttachView = function(iconView) {
      this.initIcon(iconView);
    };
    DeckButtonCloseIcon.prototype.insertChild = function(parent, child, target, key) {
      parent.prependChild(child, key);
    };
    DeckButtonCloseIcon.prototype.viewDidLayout = function(viewContext, iconView) {
      this.layoutIcon(iconView);
    };
    DeckButtonCloseIcon.prototype.initIcon = function(iconView) {
      iconView.addClass("close-icon");
      iconView.setStyle("position", "absolute");
      iconView.pointerEvents.setState("none", component.Affinity.Intrinsic);
    };
    DeckButtonCloseIcon.prototype.layoutIcon = function(iconView) {
      const slotAlign = this.owner.slotAlign.getValue();
      let slotWidth = this.owner.width.state;
      slotWidth = slotWidth instanceof math.Length ? slotWidth.pxValue() : this.owner.node.offsetWidth;
      let slotHeight = this.owner.height.state;
      slotHeight = slotHeight instanceof math.Length ? slotHeight.pxValue() : this.owner.node.offsetHeight;
      const iconPadding = this.owner.iconPadding.getValue().pxValue(slotWidth);
      let iconWidth = iconView.width.state;
      iconWidth = iconWidth instanceof math.Length ? iconWidth.pxValue() : 0;
      let iconHeight = iconView.height.state;
      iconHeight = iconHeight instanceof math.Length ? iconHeight.pxValue() : 0;
      const deckPhase = this.owner.deckPhase.getValueOr(0);
      const iconPhase = Math.min(Math.max(0, deckPhase - 1), 1);
      const slotSpace = slotWidth - iconWidth - iconPadding;
      const iconLeft = iconPadding + slotSpace * slotAlign;
      const iconTop = (slotHeight - iconHeight) / 2;
      iconView.setStyle("left", iconLeft + "px");
      iconView.setStyle("top", iconTop + "px");
      iconView.viewBox.setState("0 0 " + iconWidth + " " + iconHeight, component.Affinity.Intrinsic);
      iconView.opacity.setState(1 - iconPhase, component.Affinity.Intrinsic);
    };
    return DeckButtonCloseIcon;
  }(ViewRef);
  ViewRef({
    extends: DeckButtonCloseIcon,
    key: true,
    type: SvgIconView,
    observes: true
  })(DeckButton.prototype, "closeIcon");
  const DeckButtonBackIcon = function(_super) {
    const DeckButtonBackIcon = _super.extend("DeckButtonBackIcon");
    DeckButtonBackIcon.prototype.didAttachView = function(iconView) {
      this.initIcon(iconView);
    };
    DeckButtonBackIcon.prototype.insertChild = function(parent, child, target, key) {
      parent.prependChild(child, key);
    };
    DeckButtonBackIcon.prototype.viewDidLayout = function(viewContext, iconView) {
      this.layoutIcon(iconView);
    };
    DeckButtonBackIcon.prototype.initIcon = function(iconView) {
      iconView.addClass("back-icon");
      iconView.setStyle("position", "absolute");
      iconView.pointerEvents.setState("none", component.Affinity.Intrinsic);
    };
    DeckButtonBackIcon.prototype.layoutIcon = function(iconView) {
      const slotAlign = this.owner.slotAlign.getValue();
      let slotWidth = this.owner.width.state;
      slotWidth = slotWidth instanceof math.Length ? slotWidth.pxValue() : this.owner.node.offsetWidth;
      let slotHeight = this.owner.height.state;
      slotHeight = slotHeight instanceof math.Length ? slotHeight.pxValue() : this.owner.node.offsetHeight;
      const iconPadding = this.owner.iconPadding.getValue().pxValue(slotWidth);
      let iconWidth = iconView.width.state;
      iconWidth = iconWidth instanceof math.Length ? iconWidth.pxValue() : 0;
      let iconHeight = iconView.height.state;
      iconHeight = iconHeight instanceof math.Length ? iconHeight.pxValue() : 0;
      const deckPhase = this.owner.deckPhase.getValueOr(0);
      const nextIndex = Math.max(this.owner.labelCount, Math.ceil(deckPhase));
      const labelKey = "label" + nextIndex;
      const labelView = this.owner.getChild(labelKey);
      const slotSpace = slotWidth - iconWidth - iconPadding;
      let iconLeft = iconPadding + slotSpace * slotAlign;
      const iconTop = (slotHeight - iconHeight) / 2;
      let iconOpacity;
      if (deckPhase <= 1) {
        iconOpacity = 0;
        iconView.iconColor.setState(null, component.Affinity.Intrinsic);
      } else if (labelView !== null && deckPhase < 2) {
        const parent = this.owner.parent;
        const nextPost = this.owner.nextPost.value;
        const nextSlot = parent !== null && nextPost !== null ? parent.getChild(nextPost.key) : null;
        let nextSlotAlign;
        let nextSlotWidth;
        if (nextSlot instanceof DeckSlot) {
          nextSlotAlign = nextSlot.slotAlign.value;
          nextSlotWidth = nextSlot.width.state;
          nextSlotWidth = nextSlotWidth instanceof math.Length ? nextSlotWidth.pxValue() : nextSlot.node.offsetWidth;
          let nextSlotLeft = nextSlot.left.state;
          nextSlotLeft = nextSlotLeft instanceof math.Length ? nextSlotLeft.pxValue() : nextSlot.node.offsetLeft;
          let slotLeft = this.owner.left.state;
          slotLeft = slotLeft instanceof math.Length ? slotLeft.pxValue() : this.owner.node.offsetLeft;
          const slotGap = nextSlotLeft - (slotLeft + slotWidth);
          nextSlotWidth += slotGap;
        } else {
          nextSlotAlign = 0;
          nextSlotWidth = 0;
        }
        const prevIndex = nextIndex - 1;
        const labelPhase = deckPhase - prevIndex;
        let labelWidth = labelView.width.state;
        if (labelWidth instanceof math.Length) {
          labelWidth = labelWidth.pxValue(slotWidth);
        } else {
          labelWidth = labelView.node.offsetWidth;
        }
        const labelSlotSpace = slotWidth - iconLeft - iconWidth + (nextSlotWidth - labelWidth) * nextSlotAlign;
        iconLeft += labelSlotSpace * (1 - labelPhase) + labelSlotSpace * slotAlign * labelPhase;
        iconOpacity = labelPhase;
        const nextColor = nextSlot instanceof DeckSlot ? nextSlot.getLookOr(nextSlot.colorLook, null) : null;
        const thisColor = this.owner.getLookOr(this.owner.colorLook, null);
        if (nextColor !== null && thisColor !== null) {
          iconView.iconColor.setState(nextColor.interpolateTo(thisColor)(labelPhase), component.Affinity.Intrinsic);
        } else {
          iconView.iconColor.setState(thisColor, component.Affinity.Intrinsic);
        }
      }
      iconView.setStyle("left", iconLeft + "px");
      iconView.setStyle("top", iconTop + "px");
      iconView.viewBox.setState("0 0 " + iconWidth + " " + iconHeight, component.Affinity.Intrinsic);
      iconView.opacity.setState(iconOpacity, component.Affinity.Intrinsic);
    };
    return DeckButtonBackIcon;
  }(ViewRef);
  ViewRef({
    extends: DeckButtonBackIcon,
    key: true,
    type: SvgIconView,
    observes: true
  })(DeckButton.prototype, "backIcon");
  const DeckButtonLabel = function(_super) {
    const DeckButtonLabel = _super.extend("DeckButtonLabel");
    DeckButtonLabel.prototype.didAttachView = function(labelView) {
      this.initLabel(labelView);
    };
    DeckButtonLabel.prototype.insertChild = function(parent, child, target, key) {
      const targetKey = "label" + (this.labelIndex + 1);
      target = parent.getChild(targetKey);
      parent.insertChild(child, target, key);
    };
    DeckButtonLabel.prototype.viewDidApplyTheme = function(theme, mood, timing, labelView) {
      if (labelView.color.hasAffinity(component.Affinity.Intrinsic)) {
        labelView.color.setState(theme.getOr(this.owner.colorLook, mood, null), timing, component.Affinity.Intrinsic);
      }
    };
    DeckButtonLabel.prototype.viewDidLayout = function(viewContext, labelView) {
      this.layoutLabel(labelView);
    };
    DeckButtonLabel.prototype.initLabel = function(labelView) {
      labelView.position.setState("absolute", component.Affinity.Intrinsic);
      labelView.pointerEvents.setState("none", component.Affinity.Intrinsic);
    };
    DeckButtonLabel.prototype.layoutLabel = function(labelView) {
      const labelIndex = this.labelIndex;
      const slotAlign = this.owner.slotAlign.getValue();
      let slotWidth = this.owner.width.state;
      slotWidth = slotWidth instanceof math.Length ? slotWidth.pxValue() : this.owner.node.offsetWidth;
      let slotHeight = this.owner.height.state;
      slotHeight = slotHeight instanceof math.Length ? slotHeight.pxValue() : this.owner.node.offsetHeight;
      const parent = this.owner.parent;
      const nextPost = this.owner.nextPost.value;
      const nextSlot = parent !== null && nextPost !== null ? parent.getChild(nextPost.key) : null;
      let nextSlotAlign;
      let nextSlotWidth;
      if (nextSlot instanceof DeckSlot) {
        nextSlotAlign = nextSlot.slotAlign.value;
        nextSlotWidth = nextSlot.width.state;
        nextSlotWidth = nextSlotWidth instanceof math.Length ? nextSlotWidth.pxValue() : nextSlot.node.offsetWidth;
        let nextSlotLeft = nextSlot.left.state;
        nextSlotLeft = nextSlotLeft instanceof math.Length ? nextSlotLeft.pxValue() : nextSlot.node.offsetLeft;
        let slotLeft = this.owner.left.state;
        slotLeft = slotLeft instanceof math.Length ? slotLeft.pxValue() : this.owner.node.offsetLeft;
        const slotGap = nextSlotLeft - (slotLeft + slotWidth);
        nextSlotWidth += slotGap;
      } else {
        nextSlotAlign = 0;
        nextSlotWidth = 0;
      }
      const iconPadding = this.owner.iconPadding.getValue().pxValue(slotWidth);
      let iconWidth;
      let iconHeight;
      const iconView = this.owner.backIcon.view;
      if (iconView !== null) {
        iconWidth = iconView.width.state;
        iconWidth = iconWidth instanceof math.Length ? iconWidth.pxValue() : 0;
        iconHeight = iconView.height.state;
        iconHeight = iconHeight instanceof math.Length ? iconHeight.pxValue() : 0;
      } else {
        iconWidth = 0;
        iconHeight = 0;
      }
      const deckPhase = this.owner.deckPhase.getValueOr(0);
      const nextIndex = Math.max(this.owner.labelCount, Math.ceil(deckPhase));
      const prevIndex = nextIndex - 1;
      const labelPhase = deckPhase - prevIndex;
      let labelWidth = labelView.width.state;
      this.labelWidth = labelWidth;
      if (labelWidth instanceof math.Length) {
        labelWidth = labelWidth.pxValue(slotWidth);
      } else {
        labelWidth = labelView.node.offsetWidth;
        if (this.owner.deckPhase.tweening) {
          labelView.width.setState(labelWidth, component.Affinity.Intrinsic);
        } else {
          labelView.width.setState(this.labelWidth, component.Affinity.Intrinsic);
        }
      }
      const slotSpace = slotWidth - iconWidth - iconPadding;
      const iconLeft = iconPadding + slotSpace * slotAlign;
      const iconTop = (slotHeight - iconHeight) / 2;
      const labelSlotSpace = slotWidth - iconLeft - iconWidth + (nextSlotWidth - labelWidth) * nextSlotAlign;
      if (labelIndex < prevIndex || labelIndex === prevIndex && labelPhase === 1) {
        labelView.left.setState(iconLeft + iconWidth, component.Affinity.Intrinsic);
        labelView.top.setState(iconTop, component.Affinity.Intrinsic);
        labelView.height.setState(iconHeight, component.Affinity.Intrinsic);
        labelView.opacity.setState(0, component.Affinity.Intrinsic);
        labelView.setCulled(true);
      } else if (labelIndex === prevIndex) {
        labelView.left.setState(iconLeft + iconWidth + labelSlotSpace * slotAlign * (1 - labelPhase), component.Affinity.Intrinsic);
        labelView.top.setState(iconTop, component.Affinity.Intrinsic);
        labelView.height.setState(iconHeight, component.Affinity.Intrinsic);
        labelView.opacity.setState(1 - labelPhase, component.Affinity.Intrinsic);
        labelView.setCulled(false);
      } else if (labelIndex === nextIndex) {
        labelView.left.setState(iconLeft + iconWidth + (labelSlotSpace * (1 - labelPhase) + labelSlotSpace * slotAlign * labelPhase), component.Affinity.Intrinsic);
        labelView.top.setState(iconTop, component.Affinity.Intrinsic);
        labelView.height.setState(iconHeight, component.Affinity.Intrinsic);
        const nextColor = nextSlot instanceof DeckSlot ? nextSlot.getLookOr(nextSlot.colorLook, null) : null;
        const thisColor = this.owner.getLookOr(this.owner.colorLook, null);
        if (nextColor !== null && thisColor !== null) {
          labelView.color.setState(nextColor.interpolateTo(thisColor)(labelPhase), component.Affinity.Intrinsic);
        } else {
          labelView.color.setState(thisColor, component.Affinity.Intrinsic);
        }
        labelView.opacity.setState(1, component.Affinity.Intrinsic);
        labelView.setCulled(false);
      } else {
        labelView.left.setState(iconLeft + iconWidth + labelSlotSpace, component.Affinity.Intrinsic);
        labelView.top.setState(iconTop, component.Affinity.Intrinsic);
        labelView.height.setState(iconHeight, component.Affinity.Intrinsic);
        labelView.opacity.setState(0, component.Affinity.Intrinsic);
        labelView.setCulled(true);
      }
      this.layoutWidth = iconLeft + iconWidth + labelWidth + iconPadding;
    };
    DeckButtonLabel.construct = function(fastenerClass, fastener, owner) {
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.labelIndex = 0;
      fastener.labelWidth = null;
      fastener.layoutWidth = 0;
      return fastener;
    };
    return DeckButtonLabel;
  }(ViewRef);
  const DeckButtonLabelRef = ViewRef.define("DeckButtonLabelRef", {
    extends: DeckButtonLabel,
    key: true,
    type: HtmlView,
    observes: true
  });
  class DeckBar extends HtmlView {
    constructor(node) {
      super(node);
      this.initBar();
      this.initTheme();
    }
    initBar() {
      this.addClass("deck-bar");
      this.position.setState("relative", component.Affinity.Intrinsic);
      this.height.setState(this.barHeight.value, component.Affinity.Intrinsic);
      this.edgeInsets.setValue({
        insetTop: 0,
        insetRight: 0,
        insetBottom: 0,
        insetLeft: 0
      }, component.Affinity.Intrinsic);
    }
    initTheme() {
      this.modifyTheme(Feel.default, [ [ Feel.translucent, 1 ], [ Feel.primary, 1 ] ]);
    }
    onApplyTheme(theme, mood, timing) {
      super.onApplyTheme(theme, mood, timing);
      if (this.backgroundColor.hasAffinity(component.Affinity.Intrinsic)) {
        this.backgroundColor.setState(theme.getOr(Look.backgroundColor, mood, null), timing, component.Affinity.Intrinsic);
      }
    }
    onInsertChild(childView, targetView) {
      super.onInsertChild(childView, targetView);
      if (childView instanceof DeckSlot) {
        this.onInsertSlot(childView);
      }
    }
    onInsertSlot(childView) {
      childView.position.setState("absolute", component.Affinity.Intrinsic);
    }
    onResize(viewContext) {
      super.onResize(viewContext);
      this.resizeBar(viewContext);
    }
    resizeBar(viewContext) {
      const oldRail = !this.rail.inherited ? this.rail.value : null;
      if (oldRail !== void 0 && oldRail !== null) {
        const superRail = this.rail.superValue;
        let width = null;
        if (superRail !== void 0 && superRail !== null && superRail.width !== null) {
          width = superRail.width.pxValue();
        }
        if (width === null) {
          const parent = this.parent;
          if (parent instanceof HtmlView) {
            width = parent.width.state;
            width = width instanceof math.Length ? width.pxValue() : parent.node.offsetWidth;
          }
        }
        if (width === null) {
          width = this.width.state;
          width = width instanceof math.Length ? width.pxValue() : this.node.offsetWidth;
        }
        let edgeInsets = this.edgeInsets.superValue;
        if ((edgeInsets === void 0 || edgeInsets === null) && this.edgeInsets.hasAffinity(component.Affinity.Intrinsic)) {
          edgeInsets = viewContext.viewport.safeArea;
        }
        const insetTop = edgeInsets !== void 0 && edgeInsets !== null ? edgeInsets.insetTop : 0;
        const insetLeft = edgeInsets !== void 0 && edgeInsets !== null ? edgeInsets.insetLeft : 0;
        const insetRight = edgeInsets !== void 0 && edgeInsets !== null ? edgeInsets.insetRight : 0;
        const spacing = this.itemSpacing.getValueOr(math.Length.zero()).pxValue(width);
        const newRail = oldRail.resized(width, insetLeft, insetRight, spacing);
        this.rail.setValue(newRail);
        this.height.setState(this.barHeight.value.plus(insetTop), component.Affinity.Intrinsic);
      }
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.layoutBar(viewContext);
    }
    layoutBar(viewContext) {
      let edgeInsets = this.edgeInsets.superValue;
      if ((edgeInsets === void 0 || edgeInsets === null) && this.edgeInsets.hasAffinity(component.Affinity.Intrinsic)) {
        edgeInsets = viewContext.viewport.safeArea;
      }
      const insetTop = edgeInsets !== void 0 && edgeInsets !== null ? edgeInsets.insetTop : 0;
      this.height.setState(this.barHeight.value.plus(insetTop), component.Affinity.Intrinsic);
    }
    displayChildren(displayFlags, viewContext, displayChild) {
      const needsLayout = (displayFlags & View.NeedsLayout) !== 0;
      if (needsLayout) {
        this.layoutChildViews(displayFlags, viewContext, displayChild);
      } else {
        super.displayChildren(displayFlags, viewContext, displayChild);
      }
    }
    layoutChildViews(displayFlags, viewContext, displayChild) {
      const rail = this.rail.value;
      let edgeInsets = this.edgeInsets.superValue;
      if ((edgeInsets === void 0 || edgeInsets === null) && this.edgeInsets.hasAffinity(component.Affinity.Intrinsic)) {
        edgeInsets = viewContext.viewport.safeArea;
      }
      let height = this.height.state;
      height = height instanceof math.Length ? height.pxValue() : this.node.offsetHeight;
      const slotTop = edgeInsets !== void 0 && edgeInsets !== null ? edgeInsets.insetTop : 0;
      const slotHeight = this.barHeight.value;
      function layoutChildView(childView, displayFlags, viewContext) {
        if (childView instanceof DeckSlot) {
          const key = childView.key;
          const postIndex = rail !== null && key !== void 0 ? rail.lookupPost(key) : void 0;
          if (postIndex !== void 0) {
            const post = rail.getPost(postIndex);
            const nextPost = rail.getPost(postIndex + 1);
            const prevPost = rail.getPost(postIndex - 1);
            childView.display.setState("flex", component.Affinity.Intrinsic);
            childView.left.setState(post.left, component.Affinity.Intrinsic);
            childView.top.setState(slotTop, component.Affinity.Intrinsic);
            childView.width.setState(post.width, component.Affinity.Intrinsic);
            childView.height.setState(slotHeight, component.Affinity.Intrinsic);
            childView.post.setValue(post, component.Affinity.Intrinsic);
            childView.nextPost.setValue(nextPost, component.Affinity.Intrinsic);
            childView.prevPost.setValue(prevPost, component.Affinity.Intrinsic);
          } else {
            childView.display.setState("none", component.Affinity.Intrinsic);
            childView.left.setState(null, component.Affinity.Intrinsic);
            childView.top.setState(null, component.Affinity.Intrinsic);
            childView.width.setState(null, component.Affinity.Intrinsic);
            childView.height.setState(null, component.Affinity.Intrinsic);
            childView.post.setValue(null, component.Affinity.Intrinsic);
            childView.nextPost.setValue(null, component.Affinity.Intrinsic);
            childView.prevPost.setValue(null, component.Affinity.Intrinsic);
          }
        }
        displayChild.call(this, childView, displayFlags, viewContext);
      }
      super.displayChildren(displayFlags, viewContext, layoutChildView);
    }
    didPressBackButton(event) {
      this.forEachObserver((function(observer) {
        if (observer.deckBarDidPressBackButton !== void 0) {
          observer.deckBarDidPressBackButton(event, this);
        }
      }));
    }
    didPressCloseButton(event) {
      this.forEachObserver((function(observer) {
        if (observer.deckBarDidPressCloseButton !== void 0) {
          observer.deckBarDidPressCloseButton(event, this);
        }
      }));
    }
  }
  __decorate([ component.Property({
    type: DeckRail,
    value: null
  }) ], DeckBar.prototype, "rail", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    inherits: true
  }) ], DeckBar.prototype, "deckPhase", void 0);
  __decorate([ component.Property({
    type: math.Length,
    value: math.Length.px(48),
    updateFlags: View.NeedsLayout
  }) ], DeckBar.prototype, "barHeight", void 0);
  __decorate([ component.Property({
    type: math.Length,
    value: math.Length.zero(),
    updateFlags: View.NeedsResize
  }) ], DeckBar.prototype, "itemSpacing", void 0);
  __decorate([ component.Property({
    type: Object,
    inherits: true,
    value: null,
    updateFlags: View.NeedsResize
  }) ], DeckBar.prototype, "edgeInsets", void 0);
  class DeckCard extends HtmlView {
    constructor(node) {
      super(node);
      this.initCard();
    }
    initCard() {
      this.addClass("deck-card");
      this.position.setState("relative", component.Affinity.Intrinsic);
      this.overflowX.setState("auto", component.Affinity.Intrinsic);
      this.overflowY.setState("auto", component.Affinity.Intrinsic);
      this.overflowScrolling.setState("touch", component.Affinity.Intrinsic);
    }
    onApplyTheme(theme, mood, timing) {
      super.onApplyTheme(theme, mood, timing);
      if (this.backgroundColor.hasAffinity(component.Affinity.Intrinsic)) {
        this.backgroundColor.setState(theme.getOr(Look.backgroundColor, mood, null), timing, component.Affinity.Intrinsic);
      }
    }
  }
  __decorate([ component.Property({
    type: Object,
    inherits: true,
    value: null
  }) ], DeckCard.prototype, "edgeInsets", void 0);
  __decorate([ component.Property({
    type: String
  }) ], DeckCard.prototype, "cardTitle", void 0);
  __decorate([ ViewRef({
    type: HtmlView
  }) ], DeckCard.prototype, "backItem", void 0);
  __decorate([ ViewRef({
    type: HtmlView
  }) ], DeckCard.prototype, "titleView", void 0);
  __decorate([ ViewRef({
    type: HtmlView
  }) ], DeckCard.prototype, "leftItem", void 0);
  __decorate([ ViewRef({
    type: HtmlView
  }) ], DeckCard.prototype, "rightItem", void 0);
  class DeckView extends HtmlView {
    constructor(node) {
      super(node);
      this.cardCount = 0;
      this.card = null;
      this.initDeck();
    }
    initDeck() {
      this.addClass("deck");
      this.position.setState("relative", component.Affinity.Intrinsic);
      this.overflowX.setState("hidden", component.Affinity.Intrinsic);
      this.overflowY.setState("hidden", component.Affinity.Intrinsic);
    }
    pushCard(newCardView, timing) {
      if (this.deckPhase.tweening) {
        return;
      }
      const oldCardCount = this.cardCount;
      const newCardCount = oldCardCount + 1;
      this.cardCount = newCardCount;
      const oldCardKey = "card" + oldCardCount;
      const oldCardRef = this.getFastener(oldCardKey, ViewRef);
      const oldCardView = oldCardRef !== null ? oldCardRef.view : null;
      const newCardKey = "card" + newCardCount;
      const newCardRef = DeckViewCardRef.create(this);
      Object.defineProperty(newCardRef, "name", {
        value: newCardKey,
        configurable: true
      });
      newCardRef.cardIndex = newCardCount;
      this.willPushCard(newCardView, oldCardView);
      this.card = newCardRef;
      this.setFastener(newCardKey, newCardRef);
      newCardRef.setView(newCardView);
      newCardRef.insertView();
      if (timing === void 0 && oldCardCount === 0) {
        timing = false;
      } else if (timing === void 0 || timing === true) {
        timing = this.getLookOr(Look.timing, Mood.navigating, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      this.deckPhase.setState(newCardCount, timing);
      this.onPushCard(newCardView, oldCardView);
      if (timing === false) {
        this.didPushCard(newCardView, oldCardView);
      }
    }
    willPushCard(newCardView, oldCardView) {
      this.forEachObserver((function(observer) {
        if (observer.deckWillPushCard !== void 0) {
          observer.deckWillPushCard(newCardView, oldCardView, this);
        }
      }));
    }
    onPushCard(newCardView, oldCardView) {}
    didPushCard(newCardView, oldCardView) {
      if (oldCardView !== null && oldCardView.parent === this) {
        oldCardView.remove();
      }
      this.forEachObserver((function(observer) {
        if (observer.deckDidPushCard !== void 0) {
          observer.deckDidPushCard(newCardView, oldCardView, this);
        }
      }));
    }
    popCard(timing) {
      if (this.deckPhase.tweening) {
        return null;
      }
      const oldCardCount = this.cardCount;
      const newCardCount = oldCardCount - 1;
      this.cardCount = newCardCount;
      const oldCardKey = "card" + oldCardCount;
      const oldCardRef = this.getFastener(oldCardKey, ViewRef);
      const oldCardView = oldCardRef !== null ? oldCardRef.view : null;
      if (oldCardView !== null) {
        const newCardKey = "card" + newCardCount;
        const newCardRef = this.getFastener(newCardKey, ViewRef);
        const newCardView = newCardRef !== null ? newCardRef.view : null;
        this.willPopCard(newCardView, oldCardView);
        this.card = newCardRef;
        if (newCardRef !== null) {
          newCardRef.insertView();
        }
        if (timing === void 0 || timing === true) {
          timing = this.getLookOr(Look.timing, Mood.navigating, false);
        } else {
          timing = util.Timing.fromAny(timing);
        }
        this.deckPhase.setState(newCardCount, timing);
        this.onPopCard(newCardView, oldCardView);
        if (timing === false) {
          this.didPopCard(newCardView, oldCardView);
        }
      }
      return oldCardView;
    }
    willPopCard(newCardView, oldCardView) {
      this.forEachObserver((function(observer) {
        if (observer.deckWillPopCard !== void 0) {
          observer.deckWillPopCard(newCardView, oldCardView, this);
        }
      }));
    }
    onPopCard(newCardView, oldCardView) {}
    didPopCard(newCardView, oldCardView) {
      const oldCardKey = oldCardView.key;
      oldCardView.remove();
      if (oldCardKey !== void 0) {
        const oldCardRef = this.getFastener(oldCardKey, ViewRef);
        if (oldCardRef !== null && oldCardRef.cardIndex > this.cardCount) {
          this.setFastener(oldCardKey, null);
        }
      }
      this.forEachObserver((function(observer) {
        if (observer.deckDidPopCard !== void 0) {
          observer.deckDidPopCard(newCardView, oldCardView, this);
        }
      }));
    }
    didLayout(viewContext) {
      if (!this.deckPhase.tweening) {
        const deckPhase = this.deckPhase.value;
        if (deckPhase !== void 0) {
          const nextCardIndex = Math.round(deckPhase + 1);
          const nextCardKey = "card" + nextCardIndex;
          const nextCardRef = this.getFastener(nextCardKey, ViewRef);
          const nextCardView = nextCardRef !== null ? nextCardRef.view : null;
          if (nextCardView !== null) {
            this.didPopCard(this.card !== null ? this.card.view : null, nextCardView);
          } else if (this.card !== null && this.card.view !== null && Math.round(deckPhase) > 0) {
            const prevCardIndex = Math.round(deckPhase - 1);
            const prevCardKey = "card" + prevCardIndex;
            const prevCardRef = this.getFastener(prevCardKey, ViewRef);
            const catdCardView = prevCardRef !== null ? prevCardRef.view : null;
            this.didPushCard(this.card.view, catdCardView);
          }
        }
      }
      super.didLayout(viewContext);
    }
    didPressBackButton(event) {
      this.forEachObserver((function(observer) {
        if (observer.deckDidPressBackButton !== void 0) {
          observer.deckDidPressBackButton(event, this);
        }
      }));
    }
    didPressCloseButton(event) {
      this.forEachObserver((function(observer) {
        if (observer.deckDidPressCloseButton !== void 0) {
          observer.deckDidPressCloseButton(event, this);
        }
      }));
    }
  }
  __decorate([ ThemeAnimator({
    type: Number,
    value: 0,
    updateFlags: View.NeedsLayout
  }) ], DeckView.prototype, "deckPhase", void 0);
  __decorate([ component.Property({
    type: Number,
    value: 1
  }) ], DeckView.prototype, "inAlign", void 0);
  __decorate([ component.Property({
    type: Number,
    value: 1 / 3
  }) ], DeckView.prototype, "outAlign", void 0);
  __decorate([ component.Property({
    type: Object,
    inherits: true,
    value: null,
    updateFlags: View.NeedsResize
  }) ], DeckView.prototype, "edgeInsets", void 0);
  const DeckViewBar = function(_super) {
    const DeckViewBar = _super.extend("DeckSliderItem");
    DeckViewBar.prototype.didAttachView = function(barView) {
      this.initBar(barView);
    };
    DeckViewBar.prototype.insertChild = function(parent, child, target, key) {
      parent.prependChild(child, key);
    };
    DeckViewBar.prototype.viewDidResize = function(viewContext, barView) {
      this.resizeBar(barView);
    };
    DeckViewBar.prototype.initBar = function(barView) {
      let deckWidth = this.owner.width.state;
      deckWidth = deckWidth instanceof math.Length ? deckWidth : math.Length.px(this.owner.node.offsetWidth);
      barView.position.setState("absolute", component.Affinity.Intrinsic);
      barView.left.setState(0, component.Affinity.Intrinsic);
      barView.top.setState(0, component.Affinity.Intrinsic);
      barView.width.setState(deckWidth, component.Affinity.Intrinsic);
      barView.zIndex.setState(1, component.Affinity.Intrinsic);
    };
    DeckViewBar.prototype.resizeBar = function(barView) {
      let deckWidth = this.owner.width.state;
      deckWidth = deckWidth instanceof math.Length ? deckWidth : math.Length.px(this.owner.node.offsetWidth);
      barView.width.setState(deckWidth, component.Affinity.Intrinsic);
    };
    DeckViewBar.prototype.deckBarDidPressBackButton = function(event) {
      this.owner.didPressBackButton(event);
    };
    DeckViewBar.prototype.deckBarDidPressCloseButton = function(event) {
      this.owner.didPressCloseButton(event);
    };
    return DeckViewBar;
  }(ViewRef);
  ViewRef({
    extends: DeckViewBar,
    key: true,
    type: DeckBar,
    binds: true,
    observes: true
  })(DeckView.prototype, "bar");
  const DeckViewCard = function(_super) {
    const DeckViewCard = _super.extend("DeckSliderItem");
    DeckViewCard.prototype.didAttachView = function(cardView) {
      this.initCard(cardView);
    };
    DeckViewCard.prototype.insertChild = function(parent, child, target, key) {
      const targetKey = "card" + (this.cardIndex + 1);
      target = parent.getChild(targetKey);
      parent.insertChild(child, target, key);
    };
    DeckViewCard.prototype.viewDidResize = function(viewContext, cardView) {
      this.resizeCard(cardView, viewContext);
    };
    DeckViewCard.prototype.viewDidLayout = function(viewContext, cardView) {
      this.layoutCard(cardView, viewContext);
    };
    DeckViewCard.prototype.initCard = function(cardView) {
      let edgeInsets = this.owner.edgeInsets.value;
      if (edgeInsets === void 0 && this.owner.edgeInsets.hasAffinity(component.Affinity.Intrinsic)) {
        edgeInsets = this.owner.viewport.safeArea;
      }
      let deckWidth = this.owner.width.state;
      deckWidth = deckWidth instanceof math.Length ? deckWidth : math.Length.px(this.owner.node.offsetWidth);
      let deckHeight = this.owner.height.state;
      deckHeight = deckHeight instanceof math.Length ? deckHeight : math.Length.px(this.owner.node.offsetHeight);
      let barHeight = null;
      const barView = this.owner.bar.view;
      if (barView !== null) {
        barHeight = barView.height.state;
        barHeight = barHeight instanceof math.Length ? barHeight : math.Length.px(barView.node.offsetHeight);
        if (edgeInsets !== null) {
          edgeInsets = {
            insetTop: 0,
            insetRight: edgeInsets.insetRight,
            insetBottom: edgeInsets.insetBottom,
            insetLeft: edgeInsets.insetLeft
          };
        }
      }
      cardView.edgeInsets.setValue(edgeInsets, component.Affinity.Intrinsic);
      cardView.position.setState("absolute", component.Affinity.Intrinsic);
      cardView.left.setState(deckWidth, component.Affinity.Intrinsic);
      cardView.top.setState(0, component.Affinity.Intrinsic);
      cardView.width.setState(deckWidth, component.Affinity.Intrinsic);
      cardView.height.setState(deckHeight, component.Affinity.Intrinsic);
      cardView.paddingTop.setState(barHeight, component.Affinity.Intrinsic);
      cardView.boxSizing.setState("border-box", component.Affinity.Intrinsic);
      cardView.zIndex.setState(0, component.Affinity.Intrinsic);
      cardView.visibility.setState("hidden", component.Affinity.Intrinsic);
    };
    DeckViewCard.prototype.resizeCard = function(cardView, viewContext) {
      let edgeInsets = this.owner.edgeInsets.value;
      if (edgeInsets === void 0 && this.owner.edgeInsets.hasAffinity(component.Affinity.Intrinsic)) {
        edgeInsets = viewContext.viewport.safeArea;
      }
      let deckWidth = this.owner.width.state;
      deckWidth = deckWidth instanceof math.Length ? deckWidth : math.Length.px(this.owner.node.offsetWidth);
      let deckHeight = this.owner.height.state;
      deckHeight = deckHeight instanceof math.Length ? deckHeight : math.Length.px(this.owner.node.offsetHeight);
      let barHeight = null;
      const barView = this.owner.bar.view;
      if (barView !== null) {
        barHeight = barView.height.state;
        barHeight = barHeight instanceof math.Length ? barHeight : math.Length.px(barView.node.offsetHeight);
        if (edgeInsets !== null) {
          edgeInsets = {
            insetTop: 0,
            insetRight: edgeInsets.insetRight,
            insetBottom: edgeInsets.insetBottom,
            insetLeft: edgeInsets.insetLeft
          };
        }
      }
      cardView.edgeInsets.setValue(edgeInsets, component.Affinity.Intrinsic);
      cardView.width.setState(deckWidth, component.Affinity.Intrinsic);
      cardView.height.setState(deckHeight, component.Affinity.Intrinsic);
      cardView.paddingTop.setState(barHeight, component.Affinity.Intrinsic);
    };
    DeckViewCard.prototype.layoutCard = function(cardView, viewContext) {
      let cardWidth = cardView.width.state;
      cardWidth = cardWidth instanceof math.Length ? cardWidth : math.Length.px(cardView.node.offsetWidth);
      const inAlign = this.owner.inAlign.value;
      const outAlign = this.owner.outAlign.value;
      const deckPhase = this.owner.deckPhase.getValue();
      const nextIndex = Math.max(this.owner.cardCount, Math.ceil(deckPhase));
      const prevIndex = nextIndex - 1;
      const cardPhase = deckPhase - prevIndex;
      const cardIndex = this.cardIndex;
      if (cardIndex < prevIndex || cardIndex === prevIndex && cardPhase === 1) {
        cardView.left.setState(-cardWidth.pxValue() * outAlign, component.Affinity.Intrinsic);
        cardView.visibility.setState("hidden", component.Affinity.Intrinsic);
        cardView.setCulled(true);
      } else if (cardIndex === prevIndex) {
        cardView.left.setState(-cardWidth.pxValue() * outAlign * cardPhase, component.Affinity.Intrinsic);
        cardView.visibility.setState(void 0, component.Affinity.Intrinsic);
        cardView.setCulled(false);
      } else if (cardIndex === nextIndex) {
        cardView.left.setState(cardWidth.pxValue() * inAlign * (1 - cardPhase), component.Affinity.Intrinsic);
        cardView.visibility.setState(void 0, component.Affinity.Intrinsic);
        cardView.setCulled(false);
      } else {
        cardView.left.setState(cardWidth.pxValue() * inAlign, component.Affinity.Intrinsic);
        cardView.visibility.setState("hidden", component.Affinity.Intrinsic);
        cardView.setCulled(true);
      }
    };
    DeckViewCard.construct = function(fastenerClass, fastener, owner) {
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.cardIndex = 0;
      return fastener;
    };
    return DeckViewCard;
  }(ViewRef);
  const DeckViewCardRef = ViewRef.define("DeckViewCardRef", {
    extends: DeckViewCard,
    key: true,
    type: DeckCard,
    observes: true
  });
  class TitleDeckBar extends DeckBar {
    constructor(node) {
      super(node);
      this.onBackButtonClick = this.onBackButtonClick.bind(this);
      this.initRail();
    }
    initRail() {
      const backPost = DeckPost.create("backButton", 0, 0, 48);
      const titlePost = DeckPost.create("titleSlider", 1, 1);
      const morePost = DeckPost.create("moreSlider", 0, 0, 48);
      const rail = DeckRail.create([ backPost, titlePost, morePost ]);
      this.rail.setValue(rail, component.Affinity.Intrinsic);
      this.backMembrane.insertView();
      this.backButton.insertView();
      this.titleSlider.insertView();
      this.moreSlider.insertView();
    }
    get closeIcon() {
      return TitleDeckBar.closeIcon;
    }
    createCloseIcon() {
      const closeIcon = SvgIconView.create();
      closeIcon.width.setState(24, component.Affinity.Intrinsic);
      closeIcon.height.setState(24, component.Affinity.Intrinsic);
      closeIcon.iconWidth.setState(24, component.Affinity.Intrinsic);
      closeIcon.iconHeight.setState(24, component.Affinity.Intrinsic);
      closeIcon.graphics.setState(this.closeIcon, component.Affinity.Intrinsic);
      return closeIcon;
    }
    initBackMembrane(backMembrane) {
      backMembrane.display.setState("none", component.Affinity.Intrinsic);
      backMembrane.position.setState("absolute", component.Affinity.Intrinsic);
      backMembrane.left.setState(0, component.Affinity.Intrinsic);
      backMembrane.top.setState(0, component.Affinity.Intrinsic);
      backMembrane.borderTopLeftRadius.setState(4, component.Affinity.Intrinsic);
      backMembrane.borderTopRightRadius.setState(4, component.Affinity.Intrinsic);
      backMembrane.borderBottomLeftRadius.setState(4, component.Affinity.Intrinsic);
      backMembrane.borderBottomRightRadius.setState(4, component.Affinity.Intrinsic);
      backMembrane.overflowX.setState("hidden", component.Affinity.Intrinsic);
      backMembrane.overflowY.setState("hidden", component.Affinity.Intrinsic);
      backMembrane.cursor.setState("pointer", component.Affinity.Intrinsic);
    }
    get backIcon() {
      return TitleDeckBar.backIcon;
    }
    createBackIcon() {
      const backIcon = SvgIconView.create();
      backIcon.width.setState(24, component.Affinity.Intrinsic);
      backIcon.height.setState(24, component.Affinity.Intrinsic);
      backIcon.iconWidth.setState(24, component.Affinity.Intrinsic);
      backIcon.iconHeight.setState(24, component.Affinity.Intrinsic);
      backIcon.graphics.setState(this.backIcon, component.Affinity.Intrinsic);
      return backIcon;
    }
    createBackButton() {
      const backButton = DeckButton.create();
      backButton.backIcon.setView(this.createBackIcon());
      backButton.backIcon.insertView();
      return backButton;
    }
    initBackButton(backButton) {
      backButton.pointerEvents.setState("none", component.Affinity.Intrinsic);
    }
    initTitleSlider(titleSlider) {
      titleSlider.pointerEvents.setState("none", component.Affinity.Intrinsic);
    }
    initMoreSlider(moreSlider) {}
    pushTitle(title, timing) {
      const titleSlider = this.titleSlider.view;
      const backButton = this.backButton.view;
      if (titleSlider !== null && backButton !== null) {
        const titleRef = titleSlider.item;
        let titleView = null;
        if (titleRef !== null) {
          titleView = titleRef.view;
          titleRef.setView(null);
          titleSlider.item = null;
        }
        titleSlider.pushItem(title, timing);
        if (titleView !== null) {
          backButton.pushLabel(titleView, timing);
        } else {
          backButton.labelCount = titleSlider.itemCount;
        }
      }
    }
    popTitle(timing) {
      const titleSlider = this.titleSlider.view;
      const backButton = this.backButton.view;
      if (titleSlider !== null && backButton !== null) {
        titleSlider.popItem(timing);
        backButton.popLabel(timing);
      }
    }
    didPopBackButton(newLabelView, oldLabelView, backButton) {
      const backRef = backButton.getFastener(oldLabelView.key, ViewRef);
      if (backRef !== null) {
        backRef.setView(null);
        backButton.setFastener(backRef.key, null);
      }
      const titleSlider = this.titleSlider.view;
      if (titleSlider !== null) {
        const titleKey = "item" + titleSlider.itemCount;
        const titleRef = titleSlider.getFastener(titleKey, ViewRef);
        if (titleRef !== null) {
          titleRef.setView(oldLabelView);
        }
        titleSlider.item = titleRef;
        titleSlider.appendChild(oldLabelView, titleKey);
      }
    }
    didLayout(viewContext) {
      const backMembrane = this.backMembrane.view;
      const backButton = this.backButton.view;
      if (backMembrane !== null && backButton !== null) {
        if (backMembrane.width.hasAffinity(component.Affinity.Intrinsic)) {
          let backButtonLeft = backButton.left.state;
          backButtonLeft = backButtonLeft instanceof math.Length ? backButtonLeft.pxValue() : backButton.node.offsetLeft;
          if (backButton.label !== null) {
            backMembrane.width.setState(backButtonLeft + backButton.label.layoutWidth, component.Affinity.Intrinsic);
          } else {
            let backButtonWidth = backButton.height.state;
            backButtonWidth = backButtonWidth instanceof math.Length ? backButtonWidth.pxValue() : backButton.node.offsetWidth;
            backMembrane.width.setState(backButtonLeft + backButtonWidth, component.Affinity.Intrinsic);
          }
        }
        if (backMembrane.height.hasAffinity(component.Affinity.Intrinsic)) {
          let backButtonTop = backButton.top.state;
          backButtonTop = backButtonTop instanceof math.Length ? backButtonTop.pxValue() : backButton.node.offsetTop;
          let backButtonHeight = backButton.height.state;
          backButtonHeight = backButtonHeight instanceof math.Length ? backButtonHeight.pxValue() : backButton.node.offsetHeight;
          backMembrane.height.setState(backButtonTop + backButtonHeight, component.Affinity.Intrinsic);
        }
        const backIcon = backButton.backIcon.view;
        if (backIcon !== null) {
          const closeIcon = backButton.closeIcon.view;
          const deckPhase = backButton.deckPhase.getValueOr(0);
          const iconPhase = Math.min(Math.max(0, deckPhase - 1), 1);
          backMembrane.display.setState(closeIcon === null && iconPhase === 0 ? "none" : "block", component.Affinity.Intrinsic);
        }
      }
      super.didLayout(viewContext);
    }
    onBackButtonClick(event) {
      event.stopPropagation();
      const deckPhase = this.deckPhase.getStateOr(0);
      if (deckPhase > 1) {
        this.didPressBackButton(event);
      } else {
        this.didPressCloseButton(event);
      }
    }
    static get closeIcon() {
      return VectorIcon.create(24, 24, "M19,6.4L17.6,5L12,10.6L6.4,5L5,6.4L10.6,12L5,17.6L6.4,19L12,13.4L17.6,19L19,17.6L13.4,12Z");
    }
    static get backIcon() {
      return VectorIcon.create(24, 24, "M11.7,3.9L9.9,2.1L0,12L9.9,21.9L11.7,20.1L3.5,12Z").withFillLook(Look.accentColor);
    }
  }
  __decorate([ ViewRef({
    key: true,
    type: ButtonMembrane,
    binds: true,
    didAttachView(backMembrane) {
      this.owner.initBackMembrane(backMembrane);
      backMembrane.on("click", this.owner.onBackButtonClick);
    },
    willDetachView(backMembrane) {
      backMembrane.off("click", this.owner.onBackButtonClick);
    }
  }) ], TitleDeckBar.prototype, "backMembrane", void 0);
  __decorate([ ViewRef({
    key: true,
    type: DeckButton,
    binds: true,
    observes: true,
    didAttachView(backButton) {
      this.owner.initBackButton(backButton);
    },
    createView() {
      return this.owner.createBackButton();
    },
    deckButtonDidPopLabel(newLabelView, oldLabelView, backButton) {
      this.owner.didPopBackButton(newLabelView, oldLabelView, backButton);
    }
  }) ], TitleDeckBar.prototype, "backButton", void 0);
  __decorate([ ViewRef({
    key: true,
    type: DeckSlider,
    binds: true,
    didAttachView(titleSlider) {
      this.owner.initTitleSlider(titleSlider);
    }
  }) ], TitleDeckBar.prototype, "titleSlider", void 0);
  __decorate([ ViewRef({
    key: true,
    type: DeckSlider,
    binds: true,
    didAttachView(moreSlider) {
      this.owner.initMoreSlider(moreSlider);
    }
  }) ], TitleDeckBar.prototype, "moreSlider", void 0);
  __decorate([ util.Lazy ], TitleDeckBar, "closeIcon", null);
  __decorate([ util.Lazy ], TitleDeckBar, "backIcon", null);
  class TitleDeckView extends DeckView {
    constructor(node) {
      super(node);
      this.initBar();
    }
    initBar() {
      let deckBar = this.bar.view;
      if (!(deckBar instanceof TitleDeckBar)) {
        deckBar = TitleDeckBar.create();
        this.bar.setView(deckBar);
      }
    }
    willPushCard(newCardView, oldCardView) {
      super.willPushCard(newCardView, oldCardView);
      const deckBar = this.bar.view;
      if (deckBar instanceof TitleDeckBar) {
        deckBar.pushTitle(newCardView.cardTitle.getValueOr(""));
        const backMembrane = deckBar.backMembrane.view;
        if (backMembrane !== null) {
          backMembrane.pointerEvents.setState("none", component.Affinity.Intrinsic);
        }
      }
    }
    didPushCard(newCardView, oldCardView) {
      const deckBar = this.bar.view;
      if (deckBar instanceof TitleDeckBar) {
        const backMembrane = deckBar.backMembrane.view;
        if (backMembrane !== null) {
          backMembrane.pointerEvents.setState("auto", component.Affinity.Intrinsic);
        }
      }
      super.didPushCard(newCardView, oldCardView);
    }
    willPopCard(newCardView, oldCardView) {
      super.willPopCard(newCardView, oldCardView);
      const deckBar = this.bar.view;
      if (deckBar instanceof TitleDeckBar) {
        deckBar.popTitle();
      }
    }
    didPressBackButton(event) {
      if (!this.deckPhase.tweening) {
        this.popCard();
      }
      super.didPressBackButton(event);
    }
  }
  class DialView extends GraphicsView {
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.center.recohere(viewContext.updateTime);
    }
    onRender(viewContext) {
      super.onRender(viewContext);
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer && !this.hidden && !this.culled) {
        const context = renderer.context;
        context.save();
        this.renderDial(context, this.viewFrame);
        context.restore();
      }
    }
    renderDial(context, frame) {
      const width = frame.width;
      const height = frame.height;
      const size = Math.min(width, height);
      const value = this.value.getValue();
      const limit = this.limit.getValue();
      const delta = limit !== 0 ? value / limit : 0;
      const center = this.center.getValue();
      const innerRadius = this.innerRadius.getValue().px(size);
      const outerRadius = this.outerRadius.getValue().px(size);
      const deltaRadius = outerRadius.value - innerRadius.value;
      const startAngle = this.startAngle.getValue().rad();
      const sweepAngle = this.sweepAngle.getValue().rad();
      const cornerRadius = this.cornerRadius.getValue().px(deltaRadius);
      const dial = new Arc(center, innerRadius, outerRadius, startAngle, sweepAngle, math.Angle.zero(), null, cornerRadius);
      const meter = dial.withSweepAngle(sweepAngle.times(delta));
      context.save();
      context.beginPath();
      const dialColor = this.dialColor.value;
      if (dialColor !== null) {
        context.fillStyle = dialColor.toString();
      }
      dial.draw(context, frame);
      if (dialColor !== null) {
        context.fill();
      }
      context.clip();
      const meterColor = this.meterColor.value;
      if (meterColor !== null) {
        context.beginPath();
        context.fillStyle = meterColor.toString();
        meter.draw(context, frame);
        context.fill();
      }
      context.restore();
      const labelView = this.label.view;
      if (labelView !== null && !labelView.hidden) {
        const r = (innerRadius.value + outerRadius.value) / 2;
        const rx = r * Math.cos(startAngle.value + util.Equivalent.Epsilon);
        const ry = r * Math.sin(startAngle.value + util.Equivalent.Epsilon);
        let textAlign;
        if (rx >= 0) {
          if (ry >= 0) {
            textAlign = "start";
          } else {
            textAlign = "end";
          }
        } else {
          if (ry < 0) {
            textAlign = "end";
          } else {
            textAlign = "start";
          }
        }
        const padAngle = startAngle.value - Math.PI / 2;
        const labelPadding = this.labelPadding.getValue().pxValue(deltaRadius);
        const dx = labelPadding * Math.cos(padAngle);
        const dy = labelPadding * Math.sin(padAngle);
        if (TypesetView.is(labelView)) {
          labelView.textAlign.setState(textAlign, component.Affinity.Intrinsic);
          labelView.textBaseline.setState("middle", component.Affinity.Intrinsic);
          labelView.textOrigin.setState(new math.R2Point(center.x + rx + dx, center.y + ry + dy), component.Affinity.Intrinsic);
        }
      }
      const legendView = this.legend.view;
      if (legendView !== null && !legendView.hidden) {
        const tickAlign = this.tickAlign.getValue();
        const tickAngle = startAngle.value + sweepAngle.value * delta * tickAlign;
        const tickRadius = this.tickRadius.getValue().pxValue(size);
        const tickLength = this.tickLength.getValue().pxValue(width);
        const tickWidth = this.tickWidth.getValue().pxValue(size);
        const tickColor = this.tickColor.value;
        const cx = center.x;
        const cy = center.y;
        const r1x = outerRadius.value * Math.cos(tickAngle + util.Equivalent.Epsilon);
        const r1y = outerRadius.value * Math.sin(tickAngle + util.Equivalent.Epsilon);
        const r2x = tickRadius * Math.cos(tickAngle + util.Equivalent.Epsilon);
        const r2y = tickRadius * Math.sin(tickAngle + util.Equivalent.Epsilon);
        let dx = 0;
        if (tickColor !== null) {
          context.beginPath();
          context.lineWidth = tickWidth;
          context.strokeStyle = tickColor.toString();
          context.moveTo(cx + r1x, cy + r1y);
          context.lineTo(cx + r2x, cy + r2y);
          if (tickLength !== 0) {
            if (r2x >= 0) {
              context.lineTo(cx + tickLength, cy + r2y);
              dx = tickLength - r2x;
            } else if (r2x < 0) {
              context.lineTo(cx - tickLength, cy + r2y);
              dx = tickLength + r2x;
            }
          }
          context.stroke();
        }
        let textAlign;
        if (r2x >= 0) {
          if (r2y >= 0) {
            textAlign = "end";
          } else {
            textAlign = "end";
          }
        } else {
          dx = -dx;
          if (r2y < 0) {
            textAlign = "start";
          } else {
            textAlign = "start";
          }
        }
        if (TypesetView.is(legendView)) {
          const tickPadding = this.tickPadding.getValue().pxValue(size);
          if (FillView.is(legendView)) {
            legendView.fill.setState(tickColor, component.Affinity.Intrinsic);
          }
          legendView.textAlign.setState(textAlign, component.Affinity.Intrinsic);
          legendView.textBaseline.setState("alphabetic", component.Affinity.Intrinsic);
          legendView.textOrigin.setState(new math.R2Point(cx + r2x + dx, cy + r2y - tickPadding), component.Affinity.Intrinsic);
        }
      }
    }
    hitTest(x, y, viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer) {
        const p = renderer.transform.transform(x, y);
        return this.hitTestDial(p.x, p.y, renderer.context, this.viewFrame);
      }
      return null;
    }
    hitTestDial(x, y, context, frame) {
      const size = Math.min(frame.width, frame.height);
      const center = this.center.getValue();
      const innerRadius = this.innerRadius.getValue().px(size);
      const outerRadius = this.outerRadius.getValue().px(size);
      const deltaRadius = outerRadius.value - innerRadius.value;
      const startAngle = this.startAngle.getValue();
      const sweepAngle = this.sweepAngle.getValue();
      const cornerRadius = this.cornerRadius.getValue().px(deltaRadius);
      const dial = new Arc(center, innerRadius, outerRadius, startAngle, sweepAngle, math.Angle.zero(), null, cornerRadius);
      context.beginPath();
      dial.draw(context, frame);
      if (context.isPointInPath(x, y)) {
        return this;
      }
      return null;
    }
    init(init) {
      super.init(init);
      if (init.value !== void 0) {
        this.value(init.value);
      }
      if (init.limit !== void 0) {
        this.limit(init.limit);
      }
      if (init.center !== void 0) {
        this.center(init.center);
      }
      if (init.innerRadius !== void 0) {
        this.innerRadius(init.innerRadius);
      }
      if (init.outerRadius !== void 0) {
        this.outerRadius(init.outerRadius);
      }
      if (init.startAngle !== void 0) {
        this.startAngle(init.startAngle);
      }
      if (init.sweepAngle !== void 0) {
        this.sweepAngle(init.sweepAngle);
      }
      if (init.cornerRadius !== void 0) {
        this.cornerRadius(init.cornerRadius);
      }
      if (init.dialColor !== void 0) {
        this.dialColor(init.dialColor);
      }
      if (init.meterColor !== void 0) {
        this.meterColor(init.meterColor);
      }
      if (init.labelPadding !== void 0) {
        this.labelPadding(init.labelPadding);
      }
      if (init.tickAlign !== void 0) {
        this.tickAlign(init.tickAlign);
      }
      if (init.tickRadius !== void 0) {
        this.tickRadius(init.tickRadius);
      }
      if (init.tickLength !== void 0) {
        this.tickLength(init.tickLength);
      }
      if (init.tickWidth !== void 0) {
        this.tickWidth(init.tickWidth);
      }
      if (init.tickPadding !== void 0) {
        this.tickPadding(init.tickPadding);
      }
      if (init.tickColor !== void 0) {
        this.tickColor(init.tickColor);
      }
      if (init.font !== void 0) {
        this.font(init.font);
      }
      if (init.textColor !== void 0) {
        this.textColor(init.textColor);
      }
      if (init.arrangement !== void 0) {
        this.arrangement(init.arrangement);
      }
      if (init.label !== void 0) {
        this.label(init.label);
      }
      if (init.legend !== void 0) {
        this.legend(init.legend);
      }
    }
  }
  __decorate([ component.Animator({
    type: Number,
    value: 0,
    updateFlags: View.NeedsRender,
    willSetValue(newValue, oldValue) {
      this.owner.callObservers("viewWillSetDialValue", newValue, oldValue, this.owner);
    },
    didSetValue(newValue, oldValue) {
      this.owner.callObservers("viewDidSetDialValue", newValue, oldValue, this.owner);
    }
  }) ], DialView.prototype, "value", void 0);
  __decorate([ component.Animator({
    type: Number,
    value: 1,
    updateFlags: View.NeedsRender,
    willSetValue(newLimit, oldLimit) {
      this.owner.callObservers("viewWillSetDialLimit", newLimit, oldLimit, this.owner);
    },
    didSetValue(newLimit, oldLimit) {
      this.owner.callObservers("viewDidSetDialLimit", newLimit, oldLimit, this.owner);
    }
  }) ], DialView.prototype, "limit", void 0);
  __decorate([ component.Animator({
    type: math.R2Point,
    inherits: true,
    value: math.R2Point.origin(),
    updateFlags: View.NeedsRender
  }) ], DialView.prototype, "center", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    inherits: true,
    value: math.Length.pct(30),
    updateFlags: View.NeedsRender
  }) ], DialView.prototype, "innerRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    inherits: true,
    value: math.Length.pct(40),
    updateFlags: View.NeedsRender
  }) ], DialView.prototype, "outerRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Angle,
    inherits: true,
    value: math.Angle.rad(-Math.PI / 2),
    updateFlags: View.NeedsRender
  }) ], DialView.prototype, "startAngle", void 0);
  __decorate([ ThemeAnimator({
    type: math.Angle,
    inherits: true,
    value: math.Angle.rad(2 * Math.PI),
    updateFlags: View.NeedsRender
  }) ], DialView.prototype, "sweepAngle", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    inherits: true,
    value: math.Length.pct(50),
    updateFlags: View.NeedsRender
  }) ], DialView.prototype, "cornerRadius", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    inherits: true,
    value: null,
    look: Look.subduedColor,
    updateFlags: View.NeedsRender
  }) ], DialView.prototype, "dialColor", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    inherits: true,
    value: null,
    look: Look.accentColor,
    updateFlags: View.NeedsRender
  }) ], DialView.prototype, "meterColor", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    inherits: true,
    value: math.Length.pct(25),
    updateFlags: View.NeedsRender
  }) ], DialView.prototype, "labelPadding", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    inherits: true,
    value: 1,
    updateFlags: View.NeedsRender
  }) ], DialView.prototype, "tickAlign", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    inherits: true,
    value: math.Length.pct(45),
    updateFlags: View.NeedsRender
  }) ], DialView.prototype, "tickRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    inherits: true,
    value: math.Length.pct(50),
    updateFlags: View.NeedsRender
  }) ], DialView.prototype, "tickLength", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    inherits: true,
    value: math.Length.px(1),
    updateFlags: View.NeedsRender
  }) ], DialView.prototype, "tickWidth", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    inherits: true,
    value: math.Length.px(2),
    updateFlags: View.NeedsRender
  }) ], DialView.prototype, "tickPadding", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    inherits: true,
    value: null,
    look: Look.neutralColor,
    updateFlags: View.NeedsRender
  }) ], DialView.prototype, "tickColor", void 0);
  __decorate([ ThemeAnimator({
    type: Font,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], DialView.prototype, "font", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    inherits: true,
    look: Look.mutedColor,
    updateFlags: View.NeedsRender
  }) ], DialView.prototype, "textColor", void 0);
  __decorate([ ViewRef({
    key: true,
    type: TextRunView,
    binds: true,
    willAttachView(labelView) {
      this.owner.callObservers("viewWillAttachDialLabel", labelView, this.owner);
    },
    didDetachView(labelView) {
      this.owner.callObservers("viewDidDetachDialLabel", labelView, this.owner);
    },
    fromAny(value) {
      if (typeof value === "string") {
        if (this.view instanceof TextRunView) {
          this.view.text(value);
          return this.view;
        } else {
          return TextRunView.fromAny(value);
        }
      } else {
        return GraphicsView.fromAny(value);
      }
    }
  }) ], DialView.prototype, "label", void 0);
  __decorate([ ViewRef({
    key: true,
    type: TextRunView,
    binds: true,
    willAttachView(legendView) {
      this.owner.callObservers("viewWillAttachDialLegend", legendView, this.owner);
    },
    didDetachView(legendView) {
      this.owner.callObservers("viewDidDetachDialLegend", legendView, this.owner);
    },
    fromAny(value) {
      if (typeof value === "string") {
        if (this.view instanceof TextRunView) {
          this.view.text(value);
          return this.view;
        } else {
          return TextRunView.fromAny(value);
        }
      } else {
        return GraphicsView.fromAny(value);
      }
    }
  }) ], DialView.prototype, "legend", void 0);
  __decorate([ component.Property({
    type: String,
    value: "auto"
  }) ], DialView.prototype, "arrangement", void 0);
  class DialTrait extends Trait {
    formatLabel(value, limit) {
      return void 0;
    }
    formatLegend(value, limit) {
      return void 0;
    }
  }
  __decorate([ component.Property({
    type: Number,
    value: 0,
    willSetValue(newValue, oldValue) {
      this.owner.callObservers("traitWillSetDialValue", newValue, oldValue, this.owner);
    },
    didSetValue(newValue, oldValue) {
      this.owner.callObservers("traitDidSetDialValue", newValue, oldValue, this.owner);
    }
  }) ], DialTrait.prototype, "value", void 0);
  __decorate([ component.Property({
    type: Number,
    value: 1,
    willSetValue(newLimit, oldLimit) {
      this.owner.callObservers("traitWillSetDialLimit", newLimit, oldLimit, this.owner);
    },
    didSetValue(newLimit, oldLimit) {
      this.owner.callObservers("traitDidSetDialLimit", newLimit, oldLimit, this.owner);
    }
  }) ], DialTrait.prototype, "limit", void 0);
  __decorate([ component.Property({
    value: null,
    willSetValue(newDialColor, oldDialColor) {
      this.owner.callObservers("traitWillSetDialColor", newDialColor, oldDialColor, this.owner);
    },
    didSetValue(newDialColor, oldDialColor) {
      this.owner.callObservers("traitDidSetDialColor", newDialColor, oldDialColor, this.owner);
    },
    fromAny(dialColor) {
      if (dialColor !== null && !(dialColor instanceof Look)) {
        dialColor = Color.fromAny(dialColor);
      }
      return dialColor;
    }
  }) ], DialTrait.prototype, "dialColor", void 0);
  __decorate([ component.Property({
    value: null,
    willSetValue(newMeterColor, oldMeterColor) {
      this.owner.callObservers("traitWillSetMeterColor", newMeterColor, oldMeterColor, this.owner);
    },
    didSetValue(newMeterColor, oldMeterColor) {
      this.owner.callObservers("traitDidSetMeterColor", newMeterColor, oldMeterColor, this.owner);
    },
    fromAny(meterColor) {
      if (meterColor !== null && !(meterColor instanceof Look)) {
        meterColor = Color.fromAny(meterColor);
      }
      return meterColor;
    }
  }) ], DialTrait.prototype, "meterColor", void 0);
  __decorate([ component.Property({
    value: null,
    willSetValue(newLabel, oldLabel) {
      this.owner.callObservers("traitWillSetDialLabel", newLabel, oldLabel, this.owner);
    },
    didSetValue(newLabel, oldLabel) {
      this.owner.callObservers("traitDidSetDialLabel", newLabel, oldLabel, this.owner);
    }
  }) ], DialTrait.prototype, "label", void 0);
  __decorate([ component.Property({
    value: null,
    willSetValue(newLegend, oldLegend) {
      this.owner.callObservers("traitWillSetDialLegend", newLegend, oldLegend, this.owner);
    },
    didSetValue(newLegend, oldLegend) {
      this.owner.callObservers("traitDidSetDialLegend", newLegend, oldLegend, this.owner);
    }
  }) ], DialTrait.prototype, "legend", void 0);
  class DialController extends Controller {
    updateLabel(value, limit, dialTrait) {
      if (dialTrait.label.hasAffinity(component.Affinity.Intrinsic)) {
        const label = dialTrait.formatLabel(value, limit);
        if (label !== void 0) {
          dialTrait.label.setValue(label, component.Affinity.Intrinsic);
        }
      }
    }
    updateLegend(value, limit, dialTrait) {
      if (dialTrait.legend.hasAffinity(component.Affinity.Intrinsic)) {
        const legend = dialTrait.formatLegend(value, limit);
        if (legend !== void 0) {
          dialTrait.legend.setValue(legend, component.Affinity.Intrinsic);
        }
      }
    }
    setValue(value, timing) {
      const dialView = this.dial.view;
      if (dialView !== null && dialView.value.hasAffinity(component.Affinity.Intrinsic)) {
        if (timing === void 0 || timing === true) {
          timing = this.dialTiming.value;
          if (timing === true) {
            timing = dialView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        dialView.value.setState(value, timing, component.Affinity.Intrinsic);
      }
    }
    setLimit(limit, timing) {
      const dialView = this.dial.view;
      if (dialView !== null && dialView.limit.hasAffinity(component.Affinity.Intrinsic)) {
        if (timing === void 0 || timing === true) {
          timing = this.dialTiming.value;
          if (timing === true) {
            timing = dialView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        dialView.limit.setState(limit, timing, component.Affinity.Intrinsic);
      }
    }
    setDialColor(dialColor, timing) {
      const dialView = this.dial.view;
      if (dialView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.dialTiming.value;
          if (timing === true) {
            timing = dialView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        if (dialColor instanceof Look) {
          dialView.dialColor.setLook(dialColor, timing, component.Affinity.Intrinsic);
        } else {
          dialView.dialColor.setState(dialColor, timing, component.Affinity.Intrinsic);
        }
      }
    }
    setMeterColor(meterColor, timing) {
      const dialView = this.dial.view;
      if (dialView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.dialTiming.value;
          if (timing === true) {
            timing = dialView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        if (meterColor instanceof Look) {
          dialView.meterColor.setLook(meterColor, timing, component.Affinity.Intrinsic);
        } else {
          dialView.meterColor.setState(meterColor, timing, component.Affinity.Intrinsic);
        }
      }
    }
    createLabelView(label) {
      if (typeof label === "function") {
        return label(this.dial.trait);
      } else {
        return label;
      }
    }
    setLabelView(label) {
      const dialView = this.dial.view;
      if (dialView !== null) {
        const labelView = label !== null ? this.createLabelView(label) : null;
        dialView.label.setView(labelView);
      }
    }
    createLegendView(legend) {
      if (typeof legend === "function") {
        return legend(this.dial.trait);
      } else {
        return legend;
      }
    }
    setLegendView(legend) {
      const dialView = this.dial.view;
      if (dialView !== null) {
        const legendView = legend !== null ? this.createLegendView(legend) : null;
        dialView.legend.setView(legendView);
      }
    }
  }
  __decorate([ component.Property({
    type: util.Timing,
    inherits: true
  }) ], DialController.prototype, "dialTiming", void 0);
  __decorate([ TraitViewRef({
    traitType: DialTrait,
    observesTrait: true,
    willAttachTrait(dialTrait) {
      this.owner.callObservers("controllerWillAttachDialTrait", dialTrait, this.owner);
    },
    didAttachTrait(dialTrait) {
      const dialView = this.view;
      if (dialView !== null) {
        this.owner.setValue(dialTrait.value.value);
        this.owner.setLimit(dialTrait.limit.value);
        const dialColor = dialTrait.dialColor.value;
        if (dialColor !== null) {
          this.owner.setDialColor(dialColor);
        }
        const meterColor = dialTrait.meterColor.value;
        if (meterColor !== null) {
          this.owner.setMeterColor(meterColor);
        }
        this.owner.setLabelView(dialTrait.label.value);
        this.owner.setLegendView(dialTrait.legend.value);
      }
    },
    didDetachTrait(dialTrait) {
      this.owner.callObservers("controllerDidDetachDialTrait", dialTrait, this.owner);
    },
    traitDidSetDialValue(newValue, oldValue) {
      this.owner.setValue(newValue);
    },
    traitDidSetDialLimit(newLimit, oldLimit) {
      this.owner.setLimit(newLimit);
    },
    traitDidSetDialColor(newDialColor, oldDialColor) {
      this.owner.setDialColor(newDialColor);
    },
    traitDidSetMeterColor(newMeterColor, oldMeterColor) {
      this.owner.setMeterColor(newMeterColor);
    },
    traitDidSetDialLabel(newLabel, oldLabel) {
      this.owner.setLabelView(newLabel);
    },
    traitDidSetDialLegend(newLegend, oldLegend) {
      this.owner.setLegendView(newLegend);
    },
    viewType: DialView,
    observesView: true,
    willAttachView(dialView) {
      this.owner.callObservers("controllerWillAttachDialView", dialView, this.owner);
    },
    didAttachView(dialView) {
      const dialTrait = this.trait;
      if (dialTrait !== null) {
        const dialColor = dialTrait.dialColor.value;
        if (dialColor !== null) {
          this.owner.setDialColor(dialColor);
        }
        const meterColor = dialTrait.meterColor.value;
        if (meterColor !== null) {
          this.owner.setMeterColor(meterColor);
        }
      }
      this.owner.label.setView(dialView.label.view);
      this.owner.legend.setView(dialView.legend.view);
      if (dialTrait !== null) {
        const value = dialView.value.value;
        const limit = dialView.limit.value;
        this.owner.updateLabel(value, limit, dialTrait);
        this.owner.updateLegend(value, limit, dialTrait);
        this.owner.setValue(dialTrait.value.value);
        this.owner.setLimit(dialTrait.limit.value);
        this.owner.setLabelView(dialTrait.label.value);
        this.owner.setLegendView(dialTrait.legend.value);
      }
    },
    willDetachView(dialView) {
      this.owner.label.setView(null);
      this.owner.legend.setView(null);
    },
    didDetachView(dialView) {
      this.owner.callObservers("controllerDidDetachDialView", dialView, this.owner);
    },
    viewWillSetDialValue(newValue, oldValue, dialView) {
      this.owner.callObservers("controllerWillSetDialValue", newValue, oldValue, this.owner);
    },
    viewDidSetDialValue(newValue, oldValue, dialView) {
      const dialTrait = this.trait;
      if (dialTrait !== null) {
        const limit = dialView.limit.value;
        this.owner.updateLabel(newValue, limit, dialTrait);
        this.owner.updateLegend(newValue, limit, dialTrait);
      }
      this.owner.callObservers("controllerDidSetDialValue", newValue, oldValue, this.owner);
    },
    viewWillSetDialLimit(newLimit, oldLimit, dialView) {
      this.owner.callObservers("controllerWillSetDialLimit", newLimit, oldLimit, this.owner);
    },
    viewDidSetDialLimit(newLimit, oldLimit, dialView) {
      const dialTrait = this.trait;
      if (dialTrait !== null) {
        const value = dialView.value.value;
        this.owner.updateLabel(value, newLimit, dialTrait);
        this.owner.updateLegend(value, newLimit, dialTrait);
      }
      this.owner.callObservers("controllerDidSetDialLimit", newLimit, oldLimit, this.owner);
    },
    viewWillAttachDialLabel(labelView) {
      this.owner.label.setView(labelView);
    },
    viewDidDetachDialLabel(labelView) {
      this.owner.label.setView(null);
    },
    viewWillAttachDialLegend(legendView) {
      this.owner.legend.setView(legendView);
    },
    viewDidDetachDialLegend(legendView) {
      this.owner.legend.setView(null);
    }
  }) ], DialController.prototype, "dial", void 0);
  __decorate([ ViewRef({
    key: true,
    willAttachView(labelView) {
      this.owner.callObservers("controllerWillAttachDialLabelView", labelView, this.owner);
    },
    didDetachView(labelView) {
      this.owner.callObservers("controllerDidDetachDialLabelView", labelView, this.owner);
    }
  }) ], DialController.prototype, "label", void 0);
  __decorate([ ViewRef({
    key: true,
    willAttachView(legendView) {
      this.owner.callObservers("controllerWillAttachDialLegendView", legendView, this.owner);
    },
    didDetachView(legendView) {
      this.owner.callObservers("controllerDidDetachDialLegendView", legendView, this.owner);
    }
  }) ], DialController.prototype, "legend", void 0);
  class GaugeView extends GraphicsView {
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.layoutGauge(this.viewFrame);
    }
    layoutGauge(frame) {
      if (this.center.hasAffinity(component.Affinity.Intrinsic)) {
        const cx = (frame.xMin + frame.xMax) / 2;
        const cy = (frame.yMin + frame.yMax) / 2;
        this.center.setState(new math.R2Point(cx, cy), component.Affinity.Intrinsic);
      }
      const dialViews = this.dials.views;
      let autoCount = 0;
      for (const viewId in dialViews) {
        const dialView = dialViews[viewId];
        if (dialView.arrangement.value === "auto") {
          autoCount += 1;
        }
      }
      const size = Math.min(frame.width, frame.height);
      const gaugeLimit = this.limit.getValue();
      const startAngle = this.startAngle.getValue();
      const sweepAngle = this.sweepAngle.getValue();
      let r0 = this.innerRadius.getValue().pxValue(size);
      const r1 = this.outerRadius.getValue().pxValue(size);
      const rs = this.dialSpacing.getValue().pxValue(size);
      const dr = autoCount > 1 ? (r1 - r0 - rs * (autoCount - 1)) / autoCount : r1 - r0;
      for (const viewId in dialViews) {
        const dialView = dialViews[viewId];
        if (dialView.arrangement.value === "auto") {
          if (isFinite(gaugeLimit)) {
            const dialLimit = dialView.limit.getValue();
            dialView.limit.setState(Math.max(dialLimit, gaugeLimit), component.Affinity.Intrinsic);
          }
          dialView.startAngle.setState(startAngle, component.Affinity.Intrinsic);
          dialView.sweepAngle.setState(sweepAngle, component.Affinity.Intrinsic);
          dialView.innerRadius.setState(math.Length.px(r0), component.Affinity.Intrinsic);
          dialView.outerRadius.setState(math.Length.px(r0 + dr), component.Affinity.Intrinsic);
          r0 = r0 + dr + rs;
        }
      }
      const titleView = this.title.view;
      if (TypesetView.is(titleView)) {
        titleView.textOrigin.setState(this.center.state, component.Affinity.Intrinsic);
      }
    }
    init(init) {
      super.init(init);
      if (init.limit !== void 0) {
        this.limit(init.limit);
      }
      if (init.innerRadius !== void 0) {
        this.innerRadius(init.innerRadius);
      }
      if (init.outerRadius !== void 0) {
        this.outerRadius(init.outerRadius);
      }
      if (init.startAngle !== void 0) {
        this.startAngle(init.startAngle);
      }
      if (init.sweepAngle !== void 0) {
        this.sweepAngle(init.sweepAngle);
      }
      if (init.cornerRadius !== void 0) {
        this.cornerRadius(init.cornerRadius);
      }
      if (init.dialSpacing !== void 0) {
        this.dialSpacing(init.dialSpacing);
      }
      if (init.dialColor !== void 0) {
        this.dialColor(init.dialColor);
      }
      if (init.meterColor !== void 0) {
        this.meterColor(init.meterColor);
      }
      if (init.labelPadding !== void 0) {
        this.labelPadding(init.labelPadding);
      }
      if (init.tickAlign !== void 0) {
        this.tickAlign(init.tickAlign);
      }
      if (init.tickRadius !== void 0) {
        this.tickRadius(init.tickRadius);
      }
      if (init.tickLength !== void 0) {
        this.tickLength(init.tickLength);
      }
      if (init.tickWidth !== void 0) {
        this.tickWidth(init.tickWidth);
      }
      if (init.tickPadding !== void 0) {
        this.tickPadding(init.tickPadding);
      }
      if (init.tickColor !== void 0) {
        this.tickColor(init.tickColor);
      }
      if (init.font !== void 0) {
        this.font(init.font);
      }
      if (init.textColor !== void 0) {
        this.textColor(init.textColor);
      }
      if (init.title !== void 0) {
        this.title(init.title);
      }
      const dials = init.dials;
      if (dials !== void 0) {
        for (let i = 0, n = dials.length; i < n; i += 1) {
          const dial = dials[i];
          this.appendChild(DialView.fromAny(dial), dial.key);
        }
      }
    }
  }
  __decorate([ component.Animator({
    type: Number,
    value: 0,
    updateFlags: View.NeedsLayout
  }) ], GaugeView.prototype, "limit", void 0);
  __decorate([ component.Animator({
    type: math.R2Point,
    value: math.R2Point.origin(),
    updateFlags: View.NeedsLayout
  }) ], GaugeView.prototype, "center", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.pct(30),
    updateFlags: View.NeedsLayout
  }) ], GaugeView.prototype, "innerRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.pct(40),
    updateFlags: View.NeedsLayout
  }) ], GaugeView.prototype, "outerRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Angle,
    value: math.Angle.rad(-Math.PI / 2),
    updateFlags: View.NeedsLayout
  }) ], GaugeView.prototype, "startAngle", void 0);
  __decorate([ ThemeAnimator({
    type: math.Angle,
    value: math.Angle.rad(2 * Math.PI),
    updateFlags: View.NeedsLayout
  }) ], GaugeView.prototype, "sweepAngle", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.pct(50)
  }) ], GaugeView.prototype, "cornerRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.px(1),
    updateFlags: View.NeedsLayout
  }) ], GaugeView.prototype, "dialSpacing", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    look: Look.subduedColor
  }) ], GaugeView.prototype, "dialColor", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    look: Look.accentColor
  }) ], GaugeView.prototype, "meterColor", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.pct(25)
  }) ], GaugeView.prototype, "labelPadding", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    value: 1
  }) ], GaugeView.prototype, "tickAlign", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.pct(45)
  }) ], GaugeView.prototype, "tickRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.pct(50)
  }) ], GaugeView.prototype, "tickLength", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.px(1)
  }) ], GaugeView.prototype, "tickWidth", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.px(2)
  }) ], GaugeView.prototype, "tickPadding", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    look: Look.neutralColor
  }) ], GaugeView.prototype, "tickColor", void 0);
  __decorate([ ThemeAnimator({
    type: Font,
    value: null,
    inherits: true
  }) ], GaugeView.prototype, "font", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    look: Look.mutedColor
  }) ], GaugeView.prototype, "textColor", void 0);
  __decorate([ ViewRef({
    key: true,
    type: TextRunView,
    binds: true,
    initView(titleView) {
      if (TypesetView.is(titleView)) {
        titleView.textAlign.setState("center", component.Affinity.Intrinsic);
        titleView.textBaseline.setState("middle", component.Affinity.Intrinsic);
        titleView.textOrigin.setState(this.owner.center.state, component.Affinity.Intrinsic);
      }
    },
    willAttachView(titleView) {
      this.owner.callObservers("viewWillAttachGaugeTitle", titleView, this.owner);
    },
    didDetachView(titleView) {
      this.owner.callObservers("viewDidDetachGaugeTitle", titleView, this.owner);
    },
    fromAny(value) {
      if (typeof value === "string") {
        if (this.view instanceof TextRunView) {
          this.view.text(value);
          return this.view;
        } else {
          return TextRunView.fromAny(value);
        }
      } else {
        return GraphicsView.fromAny(value);
      }
    }
  }) ], GaugeView.prototype, "title", void 0);
  __decorate([ ViewSet({
    implements: true,
    type: DialView,
    binds: true,
    observes: true,
    willAttachView(dialView, targetView) {
      this.owner.callObservers("viewWillAttachDial", dialView, targetView, this.owner);
    },
    didAttachView(dialView) {
      const labelView = dialView.label.view;
      if (labelView !== null) {
        this.attachLabelView(labelView);
      }
      const legendView = dialView.legend.view;
      if (legendView !== null) {
        this.attachLegendView(legendView);
      }
    },
    willDetachView(dialView) {
      const legendView = dialView.legend.view;
      if (legendView !== null) {
        this.detachLegendView(legendView);
      }
      const labelView = dialView.label.view;
      if (labelView !== null) {
        this.detachLabelView(labelView);
      }
    },
    didDetachView(dialView) {
      this.owner.callObservers("viewDidDetachDial", dialView, this.owner);
    },
    viewDidSetDialValue(newValue, oldValue) {
      this.owner.requireUpdate(View.NeedsLayout);
    },
    viewWillAttachDialLabel(labelView) {
      this.attachLabelView(labelView);
    },
    viewDidDetachDialLabel(labelView) {
      this.detachLabelView(labelView);
    },
    attachLabelView(labelView) {},
    detachLabelView(labelView) {},
    viewWillAttachDialLegend(legendView) {
      this.attachLegendView(legendView);
    },
    viewDidDetachDialLegend(legendView) {
      this.detachLegendView(legendView);
    },
    attachLegendView(legendView) {},
    detachLegendView(legendView) {}
  }) ], GaugeView.prototype, "dials", void 0);
  class GaugeTrait extends Trait {
    startConsumingDials() {
      const dialTraits = this.dials.traits;
      for (const traitId in dialTraits) {
        const dialTrait = dialTraits[traitId];
        dialTrait.consume(this);
      }
    }
    stopConsumingDials() {
      const dialTraits = this.dials.traits;
      for (const traitId in dialTraits) {
        const dialTrait = dialTraits[traitId];
        dialTrait.unconsume(this);
      }
    }
    onStartConsuming() {
      super.onStartConsuming();
      this.startConsumingDials();
    }
    onStopConsuming() {
      super.onStopConsuming();
      this.stopConsumingDials();
    }
  }
  __decorate([ component.Property({
    value: null,
    willSetValue(newTitle, oldTitle) {
      this.owner.callObservers("traitWillSetGaugeTitle", newTitle, oldTitle, this.owner);
    },
    didSetValue(newTitle, oldTitle) {
      this.owner.callObservers("traitDidSetGaugeTitle", newTitle, oldTitle, this.owner);
    }
  }) ], GaugeTrait.prototype, "title", void 0);
  __decorate([ component.Property({
    value: 0,
    willSetValue(newLimit, oldLimit) {
      this.owner.callObservers("traitWillSetGaugeLimit", newLimit, oldLimit, this.owner);
    },
    didSetValue(newLimit, oldLimit) {
      this.owner.callObservers("traitDidSetGaugeLimit", newLimit, oldLimit, this.owner);
    }
  }) ], GaugeTrait.prototype, "limit", void 0);
  __decorate([ TraitSet({
    type: DialTrait,
    binds: true,
    willAttachTrait(dialTrait, targetTrait) {
      this.owner.callObservers("traitWillAttachDial", dialTrait, targetTrait, this.owner);
    },
    didAttachTrait(dialTrait) {
      if (this.owner.consuming) {
        dialTrait.consume(this.owner);
      }
    },
    willDetachTrait(dialTrait) {
      if (this.owner.consuming) {
        dialTrait.unconsume(this.owner);
      }
    },
    didDetachTrait(dialTrait) {
      this.owner.callObservers("traitDidDetachDial", dialTrait, this.owner);
    },
    detectModel(model) {
      return model.getTrait(DialTrait);
    }
  }) ], GaugeTrait.prototype, "dials", void 0);
  class GaugeController extends Controller {
    createTitleView(title, gaugeTrait) {
      if (typeof title === "function") {
        return title(gaugeTrait);
      } else {
        return title;
      }
    }
    setTitleView(title, gaugeTrait) {
      const gaugeView = this.gauge.view;
      if (gaugeView !== null) {
        const titleView = title !== null ? this.createTitleView(title, gaugeTrait) : null;
        gaugeView.title.setView(titleView);
      }
    }
    setLimit(limit) {
      const gaugeView = this.gauge.view;
      if (gaugeView !== null) {
        gaugeView.limit.setState(limit);
      }
    }
  }
  __decorate([ TraitViewRef({
    traitType: GaugeTrait,
    observesTrait: true,
    willAttachTrait(gaugeTrait) {
      this.owner.callObservers("controllerWillAttachGaugeTrait", gaugeTrait, this.owner);
    },
    didAttachTrait(gaugeTrait) {
      const dialTraits = gaugeTrait.dials.traits;
      for (const traitId in dialTraits) {
        const dialTrait = dialTraits[traitId];
        this.owner.dials.addTraitController(dialTrait);
      }
      const gaugeView = this.view;
      if (gaugeView !== null) {
        this.owner.setTitleView(gaugeTrait.title.value, gaugeTrait);
        this.owner.setLimit(gaugeTrait.limit.value);
      }
    },
    willDetachTrait(gaugeTrait) {
      const gaugeView = this.view;
      if (gaugeView !== null) {
        this.owner.setTitleView(null, gaugeTrait);
        this.owner.setLimit(0);
      }
      const dialTraits = gaugeTrait.dials.traits;
      for (const traitId in dialTraits) {
        const dialTrait = dialTraits[traitId];
        this.owner.dials.deleteTraitController(dialTrait);
      }
    },
    didDetachTrait(gaugeTrait) {
      this.owner.callObservers("controllerDidDetachGaugeTrait", gaugeTrait, this.owner);
    },
    traitDidSetGaugeTitle(newTitle, oldTitle, gaugeTrait) {
      this.owner.setTitleView(newTitle, gaugeTrait);
    },
    traitDidSetGaugeLimit(newLimit, oldLimit, gaugeTrait) {
      this.owner.setLimit(newLimit);
    },
    traitWillAttachDial(dialTrait, targetTrait) {
      this.owner.dials.addTraitController(dialTrait, targetTrait);
    },
    traitDidDetachDial(dialTrait) {
      this.owner.dials.deleteTraitController(dialTrait);
    },
    viewType: GaugeView,
    observesView: true,
    initView(gaugeView) {
      const dialControllers = this.owner.dials.controllers;
      for (const controllerId in dialControllers) {
        const dialController = dialControllers[controllerId];
        const dialView = dialController.dial.view;
        if (dialView !== null && dialView.parent === null) {
          dialController.dial.insertView(gaugeView);
        }
      }
      this.owner.title.setView(gaugeView.title.view);
      const gaugeTrait = this.trait;
      if (gaugeTrait !== null) {
        this.owner.setTitleView(gaugeTrait.title.value, gaugeTrait);
        this.owner.setLimit(gaugeTrait.limit.value);
      }
    },
    deinitView(gaugeView) {
      this.owner.title.setView(null);
    },
    willAttachView(gaugeView) {
      this.owner.callObservers("controllerWillAttachGaugeView", gaugeView, this.owner);
    },
    didDetachView(gaugeView) {
      this.owner.callObservers("controllerDidDetachGaugeView", gaugeView, this.owner);
    },
    viewWillAttachGaugeTitle(titleView) {
      this.owner.title.setView(titleView);
    },
    viewDidDetachGaugeTitle(titleView) {
      this.owner.title.setView(null);
    }
  }) ], GaugeController.prototype, "gauge", void 0);
  __decorate([ ViewRef({
    key: true,
    willAttachView(titleView) {
      this.owner.callObservers("controllerWillAttachGaugeTitleView", titleView, this.owner);
    },
    didDetachView(titleView) {
      this.owner.callObservers("controllerDidDetachGaugeTitleView", titleView, this.owner);
    }
  }) ], GaugeController.prototype, "title", void 0);
  __decorate([ component.Property({
    type: util.Timing,
    value: true
  }) ], GaugeController.prototype, "dialTiming", void 0);
  __decorate([ TraitViewControllerSet({
    implements: true,
    type: DialController,
    binds: true,
    observes: true,
    get parentView() {
      return this.owner.gauge.view;
    },
    getTraitViewRef(dialController) {
      return dialController.dial;
    },
    willAttachController(dialController) {
      this.owner.callObservers("controllerWillAttachDial", dialController, this.owner);
    },
    didAttachController(dialController) {
      const dialTrait = dialController.dial.trait;
      if (dialTrait !== null) {
        this.attachDialTrait(dialTrait, dialController);
      }
      const dialView = dialController.dial.view;
      if (dialView !== null) {
        this.attachDialView(dialView, dialController);
      }
    },
    willDetachController(dialController) {
      const dialView = dialController.dial.view;
      if (dialView !== null) {
        this.detachDialView(dialView, dialController);
      }
      const dialTrait = dialController.dial.trait;
      if (dialTrait !== null) {
        this.detachDialTrait(dialTrait, dialController);
      }
    },
    didDetachController(dialController) {
      this.owner.callObservers("controllerDidDetachDial", dialController, this.owner);
    },
    controllerWillAttachDialTrait(dialTrait, dialController) {
      this.owner.callObservers("controllerWillAttachDialTrait", dialTrait, dialController, this.owner);
      this.attachDialTrait(dialTrait, dialController);
    },
    controllerDidDetachDialTrait(dialTrait, dialController) {
      this.detachDialTrait(dialTrait, dialController);
      this.owner.callObservers("controllerDidDetachDialTrait", dialTrait, dialController, this.owner);
    },
    attachDialTrait(dialTrait, dialController) {},
    detachDialTrait(dialTrait, dialController) {},
    controllerWillAttachDialView(dialView, dialController) {
      this.owner.callObservers("controllerWillAttachDialView", dialView, dialController, this.owner);
      this.attachDialView(dialView, dialController);
    },
    controllerDidDetachDialView(dialView, dialController) {
      this.detachDialView(dialView, dialController);
      this.owner.callObservers("controllerDidDetachDialView", dialView, dialController, this.owner);
    },
    attachDialView(dialView, dialController) {
      const labelView = dialView.label.view;
      if (labelView !== null) {
        this.attachDialLabelView(labelView, dialController);
      }
      const legendView = dialView.legend.view;
      if (legendView !== null) {
        this.attachDialLegendView(legendView, dialController);
      }
    },
    detachDialView(dialView, dialController) {
      const legendView = dialView.legend.view;
      if (legendView !== null) {
        this.detachDialLegendView(legendView, dialController);
      }
      const labelView = dialView.label.view;
      if (labelView !== null) {
        this.detachDialLabelView(labelView, dialController);
      }
      dialView.remove();
    },
    controllerWillSetDialValue(newValue, oldValue, dialController) {
      this.owner.callObservers("controllerWillSetDialValue", newValue, oldValue, dialController, this.owner);
    },
    controllerDidSetDialValue(newValue, oldValue, dialController) {
      this.owner.callObservers("controllerDidSetDialValue", newValue, oldValue, dialController, this.owner);
    },
    controllerWillSetDialLimit(newLimit, oldLimit, dialController) {
      this.owner.callObservers("controllerWillSetDialLimit", newLimit, oldLimit, dialController, this.owner);
    },
    controllerDidSetDialLimit(newLimit, oldLimit, dialController) {
      this.owner.callObservers("controllerDidSetDialLimit", newLimit, oldLimit, dialController, this.owner);
    },
    controllerWillAttachDialLabelView(labelView, dialController) {
      this.owner.callObservers("controllerWillAttachDialLabelView", labelView, dialController, this.owner);
      this.attachDialLabelView(labelView, dialController);
    },
    controllerDidDetachDialLabelView(labelView, dialController) {
      this.detachDialLabelView(labelView, dialController);
      this.owner.callObservers("controllerDidDetachDialLabelView", labelView, dialController, this.owner);
    },
    attachDialLabelView(labelView, dialController) {},
    detachDialLabelView(labelView, dialController) {},
    controllerWillAttachDialLegendView(legendView, dialController) {
      this.owner.callObservers("controllerWillAttachDialLegendView", legendView, dialController, this.owner);
      this.attachDialLegendView(legendView, dialController);
    },
    controllerDidDetachDialLegendView(legendView, dialController) {
      this.detachDialLegendView(legendView, dialController);
      this.owner.callObservers("controllerDidDetachDialLegendView", legendView, dialController, this.owner);
    },
    attachDialLegendView(legendView, dialController) {},
    detachDialLegendView(legendView, dialController) {}
  }) ], GaugeController.prototype, "dials", void 0);
  class SliceView extends GraphicsView {
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.center.recohere(viewContext.updateTime);
    }
    onRender(viewContext) {
      super.onRender(viewContext);
      const renderer = viewContext.renderer;
      if (renderer instanceof PaintingRenderer && !this.hidden && !this.culled) {
        this.renderSlice(renderer.context, this.viewFrame);
      }
    }
    renderSlice(context, frame) {
      const width = frame.width;
      const height = frame.height;
      const size = Math.min(width, height);
      const value = this.value.getValue();
      const total = this.total.getValue();
      const delta = total !== 0 ? value / total : 0;
      const center = this.center.getValue();
      const innerRadius = this.innerRadius.getValue().px(size);
      const outerRadius = this.outerRadius.getValue().px(size);
      const deltaRadius = outerRadius.value - innerRadius.value;
      const startAngle = this.phaseAngle.getValue().rad();
      const sweepAngle = math.Angle.rad(2 * Math.PI * delta);
      const padAngle = this.padAngle.getValue();
      const padRadius = this.padRadius.getValueOr(null);
      const cornerRadius = this.cornerRadius.getValue().px(deltaRadius);
      const arc = new Arc(center, innerRadius, outerRadius, startAngle, sweepAngle, padAngle, padRadius, cornerRadius);
      const sliceColor = this.sliceColor.value;
      if (sliceColor !== null) {
        const contextFillStyle = context.fillStyle;
        context.beginPath();
        context.fillStyle = sliceColor.toString();
        arc.draw(context, frame);
        context.fill();
        context.fillStyle = contextFillStyle;
      }
      const labelView = this.label.view;
      if (labelView !== null && !labelView.hidden) {
        const labelRadius = this.labelRadius.getValue().pxValue(deltaRadius);
        const labelAngle = startAngle.value + sweepAngle.value / 2;
        const r = innerRadius.value + labelRadius;
        const rx = r * Math.cos(labelAngle);
        const ry = r * Math.sin(labelAngle);
        if (TypesetView.is(labelView)) {
          labelView.textAlign.setState("center", component.Affinity.Intrinsic);
          labelView.textBaseline.setState("middle", component.Affinity.Intrinsic);
          labelView.textOrigin.setState(new math.R2Point(center.x + rx, center.y + ry), component.Affinity.Intrinsic);
        }
      }
      const legendView = this.legend.view;
      if (legendView !== null && !legendView.hidden) {
        const tickAlign = this.tickAlign.getValue();
        const tickAngle = startAngle.value + sweepAngle.value * tickAlign;
        const tickRadius = this.tickRadius.getValue().pxValue(size);
        const tickLength = this.tickLength.getValue().pxValue(width);
        const tickWidth = this.tickWidth.getValue().pxValue(size);
        const tickColor = this.tickColor.value;
        const cx = center.x;
        const cy = center.y;
        const r1x = outerRadius.value * Math.cos(tickAngle + util.Equivalent.Epsilon);
        const r1y = outerRadius.value * Math.sin(tickAngle + util.Equivalent.Epsilon);
        const r2x = tickRadius * Math.cos(tickAngle + util.Equivalent.Epsilon);
        const r2y = tickRadius * Math.sin(tickAngle + util.Equivalent.Epsilon);
        let dx = 0;
        if (tickColor !== null && tickWidth !== 0) {
          const contextLineWidth = context.lineWidth;
          const contextStrokeStyle = context.strokeStyle;
          context.beginPath();
          context.lineWidth = tickWidth;
          context.strokeStyle = tickColor.toString();
          context.moveTo(cx + r1x, cy + r1y);
          context.lineTo(cx + r2x, cy + r2y);
          if (tickLength !== 0) {
            if (r2x >= 0) {
              context.lineTo(cx + tickLength, cy + r2y);
              dx = tickLength - r2x;
            } else if (r2x < 0) {
              context.lineTo(cx - tickLength, cy + r2y);
              dx = tickLength + r2x;
            }
          }
          context.stroke();
          context.lineWidth = contextLineWidth;
          context.strokeStyle = contextStrokeStyle;
        }
        let textAlign;
        if (r2x >= 0) {
          if (r2y >= 0) {
            textAlign = "end";
          } else {
            textAlign = "end";
          }
        } else {
          dx = -dx;
          if (r2y < 0) {
            textAlign = "start";
          } else {
            textAlign = "start";
          }
        }
        if (TypesetView.is(legendView)) {
          const tickPadding = this.tickPadding.getValue().pxValue(size);
          if (FillView.is(legendView)) {
            legendView.fill.setState(tickColor, component.Affinity.Intrinsic);
          }
          legendView.textAlign.setState(textAlign, component.Affinity.Intrinsic);
          legendView.textBaseline.setState("alphabetic", component.Affinity.Intrinsic);
          legendView.textOrigin.setState(new math.R2Point(cx + r2x + dx, cy + r2y - tickPadding), component.Affinity.Intrinsic);
        }
      }
    }
    hitTest(x, y, viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer) {
        const p = renderer.transform.transform(x, y);
        return this.hitTestSlice(p.x, p.y, renderer.context, this.viewFrame);
      }
      return null;
    }
    hitTestSlice(x, y, context, frame) {
      const size = Math.min(frame.width, frame.height);
      const value = this.value.getValue();
      const total = this.total.getValue();
      const delta = total !== 0 ? value / total : 0;
      const center = this.center.getValue();
      const innerRadius = this.innerRadius.getValue().px(size);
      const outerRadius = this.outerRadius.getValue().px(size);
      const deltaRadius = outerRadius.value - innerRadius.value;
      const startAngle = this.phaseAngle.getValue().rad();
      const sweepAngle = math.Angle.rad(2 * Math.PI * delta);
      const padAngle = this.padAngle.getValue();
      const padRadius = this.padRadius.getValueOr(null);
      const cornerRadius = this.cornerRadius.getValue().px(deltaRadius);
      const arc = new Arc(center, innerRadius, outerRadius, startAngle, sweepAngle, padAngle, padRadius, cornerRadius);
      context.beginPath();
      arc.draw(context, frame);
      if (context.isPointInPath(x, y)) {
        return this;
      }
      return null;
    }
    init(init) {
      super.init(init);
      if (init.value !== void 0) {
        this.value(init.value);
      }
      if (init.total !== void 0) {
        this.total(init.total);
      }
      if (init.center !== void 0) {
        this.center(init.center);
      }
      if (init.innerRadius !== void 0) {
        this.innerRadius(init.innerRadius);
      }
      if (init.outerRadius !== void 0) {
        this.outerRadius(init.outerRadius);
      }
      if (init.phaseAngle !== void 0) {
        this.phaseAngle(init.phaseAngle);
      }
      if (init.padAngle !== void 0) {
        this.padAngle(init.padAngle);
      }
      if (init.padRadius !== void 0) {
        this.padRadius(init.padRadius);
      }
      if (init.cornerRadius !== void 0) {
        this.cornerRadius(init.cornerRadius);
      }
      if (init.labelRadius !== void 0) {
        this.labelRadius(init.labelRadius);
      }
      if (init.sliceColor !== void 0) {
        this.sliceColor(init.sliceColor);
      }
      if (init.tickAlign !== void 0) {
        this.tickAlign(init.tickAlign);
      }
      if (init.tickRadius !== void 0) {
        this.tickRadius(init.tickRadius);
      }
      if (init.tickLength !== void 0) {
        this.tickLength(init.tickLength);
      }
      if (init.tickWidth !== void 0) {
        this.tickWidth(init.tickWidth);
      }
      if (init.tickPadding !== void 0) {
        this.tickPadding(init.tickPadding);
      }
      if (init.tickColor !== void 0) {
        this.tickColor(init.tickColor);
      }
      if (init.font !== void 0) {
        this.font(init.font);
      }
      if (init.textColor !== void 0) {
        this.textColor(init.textColor);
      }
      if (init.label !== void 0) {
        this.label(init.label);
      }
      if (init.legend !== void 0) {
        this.legend(init.legend);
      }
    }
  }
  __decorate([ component.Animator({
    type: Number,
    value: 0,
    updateFlags: View.NeedsRender,
    willSetValue(newValue, oldValue) {
      this.owner.callObservers("viewWillSetSliceValue", newValue, oldValue, this.owner);
    },
    didSetValue(newValue, oldValue) {
      this.owner.callObservers("viewDidSetSliceValue", newValue, oldValue, this.owner);
    }
  }) ], SliceView.prototype, "value", void 0);
  __decorate([ component.Animator({
    type: Number,
    value: 1,
    updateFlags: View.NeedsRender
  }) ], SliceView.prototype, "total", void 0);
  __decorate([ component.Animator({
    type: math.R2Point,
    inherits: true,
    value: math.R2Point.origin(),
    updateFlags: View.NeedsRender
  }) ], SliceView.prototype, "center", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    inherits: true,
    value: math.Length.pct(3),
    updateFlags: View.NeedsRender
  }) ], SliceView.prototype, "innerRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    inherits: true,
    value: math.Length.pct(25),
    updateFlags: View.NeedsRender
  }) ], SliceView.prototype, "outerRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Angle,
    value: math.Angle.zero(),
    updateFlags: View.NeedsRender
  }) ], SliceView.prototype, "phaseAngle", void 0);
  __decorate([ ThemeAnimator({
    type: math.Angle,
    inherits: true,
    value: math.Angle.deg(2),
    updateFlags: View.NeedsRender
  }) ], SliceView.prototype, "padAngle", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    inherits: true,
    value: null,
    updateFlags: View.NeedsRender
  }) ], SliceView.prototype, "padRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    inherits: true,
    value: math.Length.zero(),
    updateFlags: View.NeedsRender
  }) ], SliceView.prototype, "cornerRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    inherits: true,
    value: math.Length.pct(50),
    updateFlags: View.NeedsRender
  }) ], SliceView.prototype, "labelRadius", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    inherits: true,
    value: null,
    look: Look.accentColor,
    updateFlags: View.NeedsRender
  }) ], SliceView.prototype, "sliceColor", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    inherits: true,
    value: .5,
    updateFlags: View.NeedsRender
  }) ], SliceView.prototype, "tickAlign", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    inherits: true,
    value: math.Length.pct(30),
    updateFlags: View.NeedsRender
  }) ], SliceView.prototype, "tickRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    inherits: true,
    value: math.Length.pct(50),
    updateFlags: View.NeedsRender
  }) ], SliceView.prototype, "tickLength", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    inherits: true,
    value: math.Length.px(1),
    updateFlags: View.NeedsRender
  }) ], SliceView.prototype, "tickWidth", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    inherits: true,
    value: math.Length.px(2),
    updateFlags: View.NeedsRender
  }) ], SliceView.prototype, "tickPadding", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    inherits: true,
    value: null,
    look: Look.neutralColor,
    updateFlags: View.NeedsRender
  }) ], SliceView.prototype, "tickColor", void 0);
  __decorate([ ThemeAnimator({
    type: Font,
    inherits: true,
    value: null,
    updateFlags: View.NeedsRender
  }) ], SliceView.prototype, "font", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    inherits: true,
    value: null,
    look: Look.mutedColor,
    updateFlags: View.NeedsRender
  }) ], SliceView.prototype, "textColor", void 0);
  __decorate([ ViewRef({
    key: true,
    type: TextRunView,
    binds: true,
    willAttachView(labelView) {
      this.owner.callObservers("viewWillAttachSliceLabel", labelView, this.owner);
    },
    didDetachView(labelView) {
      this.owner.callObservers("viewDidDetachSliceLabel", labelView, this.owner);
    },
    fromAny(value) {
      if (typeof value === "string") {
        if (this.view instanceof TextRunView) {
          this.view.text(value);
          return this.view;
        } else {
          return TextRunView.fromAny(value);
        }
      } else {
        return GraphicsView.fromAny(value);
      }
    }
  }) ], SliceView.prototype, "label", void 0);
  __decorate([ ViewRef({
    key: true,
    type: TextRunView,
    binds: true,
    willAttachView(legendView) {
      this.owner.callObservers("viewWillAttachSliceLegend", legendView, this.owner);
    },
    didDetachView(legendView) {
      this.owner.callObservers("viewDidDetachSliceLegend", legendView, this.owner);
    },
    fromAny(value) {
      if (typeof value === "string") {
        if (this.view instanceof TextRunView) {
          this.view.text(value);
          return this.view;
        } else {
          return TextRunView.fromAny(value);
        }
      } else {
        return GraphicsView.fromAny(value);
      }
    }
  }) ], SliceView.prototype, "legend", void 0);
  class SliceTrait extends Trait {
    formatLabel(value) {
      return void 0;
    }
    formatLegend(value) {
      return void 0;
    }
  }
  __decorate([ component.Property({
    type: Number,
    value: 0,
    willSetValue(newValue, oldValue) {
      this.owner.callObservers("traitWillSetSliceValue", newValue, oldValue, this.owner);
    },
    didSetValue(newValue, oldValue) {
      this.owner.callObservers("traitDidSetSliceValue", newValue, oldValue, this.owner);
    }
  }) ], SliceTrait.prototype, "value", void 0);
  __decorate([ component.Property({
    value: null,
    willSetValue(newSliceColor, oldSliceColor) {
      this.owner.callObservers("traitWillSetSliceColor", newSliceColor, oldSliceColor, this.owner);
    },
    didSetValue(newSliceColor, oldSliceColor) {
      this.owner.callObservers("traitDidSetSliceColor", newSliceColor, oldSliceColor, this.owner);
    },
    fromAny(sliceColor) {
      if (sliceColor !== null && !(sliceColor instanceof Look)) {
        sliceColor = Color.fromAny(sliceColor);
      }
      return sliceColor;
    }
  }) ], SliceTrait.prototype, "sliceColor", void 0);
  __decorate([ component.Property({
    value: null,
    willSetValue(newLabel, oldLabel) {
      this.owner.callObservers("traitWillSetSliceLabel", newLabel, oldLabel, this.owner);
    },
    didSetValue(newLabel, oldLabel) {
      this.owner.callObservers("traitDidSetSliceLabel", newLabel, oldLabel, this.owner);
    }
  }) ], SliceTrait.prototype, "label", void 0);
  __decorate([ component.Property({
    value: null,
    willSetValue(newLegend, oldLegend) {
      this.owner.callObservers("traitWillSetSliceLegend", newLegend, oldLegend, this.owner);
    },
    didSetValue(newLegend, oldLegend) {
      this.owner.callObservers("traitDidSetSliceLegend", newLegend, oldLegend, this.owner);
    }
  }) ], SliceTrait.prototype, "legend", void 0);
  class SliceController extends Controller {
    updateLabel(value, sliceTrait) {
      if (sliceTrait.label.hasAffinity(component.Affinity.Intrinsic)) {
        const label = sliceTrait.formatLabel(value);
        if (label !== void 0) {
          sliceTrait.label.setValue(label, component.Affinity.Intrinsic);
        }
      }
    }
    updateLegend(value, sliceTrait) {
      if (sliceTrait.legend.hasAffinity(component.Affinity.Intrinsic)) {
        const legend = sliceTrait.formatLegend(value);
        if (legend !== void 0) {
          sliceTrait.legend.setValue(legend, component.Affinity.Intrinsic);
        }
      }
    }
    setValue(value, timing) {
      const sliceView = this.slice.view;
      if (sliceView !== null && sliceView.value.hasAffinity(component.Affinity.Intrinsic)) {
        if (timing === void 0 || timing === true) {
          timing = this.sliceTiming.value;
          if (timing === true) {
            timing = sliceView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        sliceView.value.setState(value, timing, component.Affinity.Intrinsic);
      }
    }
    setSliceColor(sliceColor, timing) {
      const sliceView = this.slice.view;
      if (sliceView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.sliceTiming.value;
          if (timing === true) {
            timing = sliceView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        if (sliceColor instanceof Look) {
          sliceView.sliceColor.setLook(sliceColor, timing, component.Affinity.Intrinsic);
        } else {
          sliceView.sliceColor.setState(sliceColor, timing, component.Affinity.Intrinsic);
        }
      }
    }
    createLabelView(label) {
      if (typeof label === "function") {
        return label(this.slice.trait);
      } else {
        return label;
      }
    }
    setLabelView(label) {
      const sliceView = this.slice.view;
      if (sliceView !== null) {
        const labelView = label !== null ? this.createLabelView(label) : null;
        sliceView.label.setView(labelView);
      }
    }
    createLegendView(legend) {
      if (typeof legend === "function") {
        return legend(this.slice.trait);
      } else {
        return legend;
      }
    }
    setLegendView(legend) {
      const sliceView = this.slice.view;
      if (sliceView !== null) {
        const legendView = legend !== null ? this.createLegendView(legend) : null;
        sliceView.legend.setView(legendView);
      }
    }
  }
  __decorate([ component.Property({
    type: util.Timing,
    inherits: true
  }) ], SliceController.prototype, "sliceTiming", void 0);
  __decorate([ TraitViewRef({
    traitType: SliceTrait,
    observesTrait: true,
    willAttachTrait(sliceTrait) {
      this.owner.callObservers("controllerWillAttachSliceTrait", sliceTrait, this.owner);
    },
    didAttachTrait(sliceTrait) {
      const sliceView = this.view;
      if (sliceView !== null) {
        this.owner.setValue(sliceTrait.value.value);
        const sliceColor = sliceTrait.sliceColor.value;
        if (sliceColor !== null) {
          this.owner.setSliceColor(sliceColor);
        }
        this.owner.setLabelView(sliceTrait.label.value);
        this.owner.setLegendView(sliceTrait.legend.value);
      }
    },
    didDetachTrait(sliceTrait) {
      this.owner.callObservers("controllerDidDetachSliceTrait", sliceTrait, this.owner);
    },
    traitDidSetSliceValue(newValue, oldValue) {
      this.owner.setValue(newValue);
    },
    traitDidSetSliceColor(newSliceColor, oldSliceColor) {
      this.owner.setSliceColor(newSliceColor);
    },
    traitDidSetSliceLabel(newLabel, oldLabel) {
      this.owner.setLabelView(newLabel);
    },
    traitDidSetSliceLegend(newLegend, oldLegend) {
      this.owner.setLegendView(newLegend);
    },
    viewType: SliceView,
    observesView: true,
    willAttachView(sliceView) {
      this.owner.callObservers("controllerWillAttachSliceView", sliceView, this.owner);
    },
    didAttachView(sliceView) {
      const sliceTrait = this.trait;
      if (sliceTrait !== null) {
        const sliceColor = sliceTrait.sliceColor.value;
        if (sliceColor !== null) {
          this.owner.setSliceColor(sliceColor);
        }
      }
      this.owner.label.setView(sliceView.label.view);
      this.owner.legend.setView(sliceView.legend.view);
      const value = sliceView.value.value;
      sliceView.setHidden(value === 0);
      if (sliceTrait !== null) {
        this.owner.updateLabel(value, sliceTrait);
        this.owner.updateLegend(value, sliceTrait);
        this.owner.setValue(sliceTrait.value.value);
        this.owner.setLabelView(sliceTrait.label.value);
        this.owner.setLegendView(sliceTrait.legend.value);
      }
    },
    willDetachView(sliceView) {
      this.owner.label.setView(null);
      this.owner.legend.setView(null);
    },
    didDetachView(sliceView) {
      this.owner.callObservers("controllerDidDetachSliceView", sliceView, this.owner);
    },
    viewWillSetSliceValue(newValue, oldValue, sliceView) {
      this.owner.callObservers("controllerWillSetSliceValue", newValue, oldValue, this.owner);
    },
    viewDidSetSliceValue(newValue, oldValue, sliceView) {
      sliceView.setHidden(newValue === 0);
      const sliceTrait = this.trait;
      if (sliceTrait !== null) {
        this.owner.updateLabel(newValue, sliceTrait);
        this.owner.updateLegend(newValue, sliceTrait);
      }
      this.owner.callObservers("controllerDidSetSliceValue", newValue, oldValue, this.owner);
    },
    viewWillAttachSliceLabel(labelView) {
      this.owner.label.setView(labelView);
    },
    viewDidDetachSliceLabel(labelView) {
      this.owner.label.setView(null);
    },
    viewWillAttachSliceLegend(legendView) {
      this.owner.legend.setView(legendView);
    },
    viewDidDetachSliceLegend(legendView) {
      this.owner.legend.setView(null);
    }
  }) ], SliceController.prototype, "slice", void 0);
  __decorate([ ViewRef({
    key: true,
    willAttachView(labelView) {
      this.owner.callObservers("controllerWillAttachSliceLabelView", labelView, this.owner);
    },
    didDetachView(labelView) {
      this.owner.callObservers("controllerDidDetachSliceLabelView", labelView, this.owner);
    }
  }) ], SliceController.prototype, "label", void 0);
  __decorate([ ViewRef({
    key: true,
    willAttachView(legendView) {
      this.owner.callObservers("controllerWillAttachSliceLegendView", legendView, this.owner);
    },
    didDetachView(legendView) {
      this.owner.callObservers("controllerDidDetachSliceLegendView", legendView, this.owner);
    }
  }) ], SliceController.prototype, "legend", void 0);
  class PieView extends GraphicsView {
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.layoutPie(this.viewFrame);
    }
    layoutPie(frame) {
      if (this.center.hasAffinity(component.Affinity.Intrinsic)) {
        const cx = (frame.xMin + frame.xMax) / 2;
        const cy = (frame.yMin + frame.yMax) / 2;
        this.center.setState(new math.R2Point(cx, cy), component.Affinity.Intrinsic);
      }
      const sliceViews = this.slices.views;
      let total = 0;
      for (const viewId in sliceViews) {
        const sliceView = sliceViews[viewId];
        const value = sliceView.value.getValue();
        if (isFinite(value)) {
          total += value;
        }
      }
      total = Math.max(total, this.limit.getValue());
      let baseAngle = this.baseAngle.getValue().rad();
      for (const viewId in sliceViews) {
        const sliceView = sliceViews[viewId];
        sliceView.total.setState(total, component.Affinity.Intrinsic);
        sliceView.phaseAngle.setState(baseAngle, component.Affinity.Intrinsic);
        const value = sliceView.value.getValue();
        if (isFinite(value)) {
          const delta = total !== 0 ? value / total : 0;
          baseAngle = math.Angle.rad(baseAngle.value + 2 * Math.PI * delta);
        }
      }
      const titleView = this.title.view;
      if (TypesetView.is(titleView)) {
        titleView.textOrigin.setState(this.center.value, component.Affinity.Intrinsic);
      }
    }
    init(init) {
      super.init(init);
      if (init.limit !== void 0) {
        this.limit(init.limit);
      }
      if (init.center !== void 0) {
        this.center(init.center);
      }
      if (init.baseAngle !== void 0) {
        this.baseAngle(init.baseAngle);
      }
      if (init.innerRadius !== void 0) {
        this.innerRadius(init.innerRadius);
      }
      if (init.outerRadius !== void 0) {
        this.outerRadius(init.outerRadius);
      }
      if (init.padAngle !== void 0) {
        this.padAngle(init.padAngle);
      }
      if (init.padRadius !== void 0) {
        this.padRadius(init.padRadius);
      }
      if (init.cornerRadius !== void 0) {
        this.cornerRadius(init.cornerRadius);
      }
      if (init.labelRadius !== void 0) {
        this.labelRadius(init.labelRadius);
      }
      if (init.sliceColor !== void 0) {
        this.sliceColor(init.sliceColor);
      }
      if (init.tickAlign !== void 0) {
        this.tickAlign(init.tickAlign);
      }
      if (init.tickRadius !== void 0) {
        this.tickRadius(init.tickRadius);
      }
      if (init.tickLength !== void 0) {
        this.tickLength(init.tickLength);
      }
      if (init.tickWidth !== void 0) {
        this.tickWidth(init.tickWidth);
      }
      if (init.tickPadding !== void 0) {
        this.tickPadding(init.tickPadding);
      }
      if (init.tickColor !== void 0) {
        this.tickColor(init.tickColor);
      }
      if (init.font !== void 0) {
        this.font(init.font);
      }
      if (init.textColor !== void 0) {
        this.textColor(init.textColor);
      }
      if (init.title !== void 0) {
        this.title(init.title);
      }
      const slices = init.slices;
      if (slices !== void 0) {
        for (let i = 0, n = slices.length; i < n; i += 1) {
          const slice = slices[i];
          this.appendChild(SliceView.fromAny(slice), slice.key);
        }
      }
    }
  }
  __decorate([ component.Animator({
    type: Number,
    value: 0,
    updateFlags: View.NeedsLayout
  }) ], PieView.prototype, "limit", void 0);
  __decorate([ component.Animator({
    type: math.R2Point,
    value: math.R2Point.origin(),
    updateFlags: View.NeedsLayout
  }) ], PieView.prototype, "center", void 0);
  __decorate([ ThemeAnimator({
    type: math.Angle,
    value: math.Angle.rad(-Math.PI / 2),
    updateFlags: View.NeedsLayout
  }) ], PieView.prototype, "baseAngle", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.pct(3)
  }) ], PieView.prototype, "innerRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.pct(25)
  }) ], PieView.prototype, "outerRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Angle,
    value: math.Angle.deg(2)
  }) ], PieView.prototype, "padAngle", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null
  }) ], PieView.prototype, "padRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.zero()
  }) ], PieView.prototype, "cornerRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.pct(50)
  }) ], PieView.prototype, "labelRadius", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    look: Look.accentColor
  }) ], PieView.prototype, "sliceColor", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    value: .5
  }) ], PieView.prototype, "tickAlign", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.pct(30)
  }) ], PieView.prototype, "tickRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.pct(50)
  }) ], PieView.prototype, "tickLength", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.px(1)
  }) ], PieView.prototype, "tickWidth", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.px(2)
  }) ], PieView.prototype, "tickPadding", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    look: Look.neutralColor
  }) ], PieView.prototype, "tickColor", void 0);
  __decorate([ ThemeAnimator({
    type: Font,
    value: null,
    inherits: true
  }) ], PieView.prototype, "font", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    look: Look.mutedColor
  }) ], PieView.prototype, "textColor", void 0);
  __decorate([ ViewRef({
    key: true,
    type: TextRunView,
    binds: true,
    initView(titleView) {
      if (TypesetView.is(titleView)) {
        titleView.textAlign.setState("center", component.Affinity.Intrinsic);
        titleView.textBaseline.setState("middle", component.Affinity.Intrinsic);
        titleView.textOrigin.setState(this.owner.center.state, component.Affinity.Intrinsic);
      }
    },
    willAttachView(titleView) {
      this.owner.callObservers("viewWillAttachPieTitle", titleView, this.owner);
    },
    didDetachView(titleView) {
      this.owner.callObservers("viewDidDetachPieTitle", titleView, this.owner);
    },
    fromAny(value) {
      if (typeof value === "string") {
        if (this.view instanceof TextRunView) {
          this.view.text(value);
          return this.view;
        } else {
          return TextRunView.fromAny(value);
        }
      } else {
        return GraphicsView.fromAny(value);
      }
    }
  }) ], PieView.prototype, "title", void 0);
  __decorate([ ViewSet({
    implements: true,
    type: SliceView,
    binds: true,
    observes: true,
    willAttachView(sliceView, targetView) {
      this.owner.callObservers("viewWillAttachSlice", sliceView, targetView, this.owner);
    },
    didAttachView(sliceView) {
      const labelView = sliceView.label.view;
      if (labelView !== null) {
        this.attachLabelView(labelView);
      }
      const legendView = sliceView.legend.view;
      if (legendView !== null) {
        this.attachLegendView(legendView);
      }
    },
    willDetachView(sliceView) {
      const legendView = sliceView.legend.view;
      if (legendView !== null) {
        this.detachLegendView(legendView);
      }
      const labelView = sliceView.label.view;
      if (labelView !== null) {
        this.detachLabelView(labelView);
      }
    },
    didDetachView(sliceView) {
      this.owner.callObservers("viewDidDetachSlice", sliceView, this.owner);
    },
    viewDidSetSliceValue(newValue, oldValue) {
      this.owner.requireUpdate(View.NeedsLayout);
    },
    viewWillAttachSliceLabel(labelView) {
      this.attachLabelView(labelView);
    },
    viewDidDetachSliceLabel(labelView) {
      this.detachLabelView(labelView);
    },
    attachLabelView(labelView) {},
    detachLabelView(labelView) {},
    viewWillAttachSliceLegend(legendView) {
      this.attachLegendView(legendView);
    },
    viewDidDetachSliceLegend(legendView) {
      this.detachLegendView(legendView);
    },
    attachLegendView(legendView) {},
    detachLegendView(legendView) {}
  }) ], PieView.prototype, "slices", void 0);
  class PieTrait extends Trait {
    startConsumingSlices() {
      const sliceTraits = this.slices.traits;
      for (const traitId in sliceTraits) {
        const sliceTrait = sliceTraits[traitId];
        sliceTrait.consume(this);
      }
    }
    stopConsumingSlices() {
      const sliceTraits = this.slices.traits;
      for (const traitId in sliceTraits) {
        const sliceTrait = sliceTraits[traitId];
        sliceTrait.unconsume(this);
      }
    }
    onStartConsuming() {
      super.onStartConsuming();
      this.startConsumingSlices();
    }
    onStopConsuming() {
      super.onStopConsuming();
      this.stopConsumingSlices();
    }
  }
  __decorate([ component.Property({
    value: null,
    willSetValue(newTitle, oldTitle) {
      this.owner.callObservers("traitWillSetPieTitle", newTitle, oldTitle, this.owner);
    },
    didSetValue(newTitle, oldTitle) {
      this.owner.callObservers("traitDidSetPieTitle", newTitle, oldTitle, this.owner);
    }
  }) ], PieTrait.prototype, "title", void 0);
  __decorate([ TraitSet({
    type: SliceTrait,
    binds: true,
    willAttachTrait(sliceTrait, targetTrait) {
      this.owner.callObservers("traitWillAttachSlice", sliceTrait, targetTrait, this.owner);
    },
    didAttachTrait(sliceTrait) {
      if (this.owner.consuming) {
        sliceTrait.consume(this.owner);
      }
    },
    willDetachTrait(sliceTrait) {
      if (this.owner.consuming) {
        sliceTrait.unconsume(this.owner);
      }
    },
    didDetachTrait(sliceTrait) {
      this.owner.callObservers("traitDidDetachSlice", sliceTrait, this.owner);
    },
    detectModel(model) {
      return model.getTrait(SliceTrait);
    }
  }) ], PieTrait.prototype, "slices", void 0);
  class PieController extends Controller {
    createTitleView(title, pieTrait) {
      if (typeof title === "function") {
        return title(pieTrait);
      } else {
        return title;
      }
    }
    setTitleView(title, pieTrait) {
      const pieView = this.pie.view;
      if (pieView !== null) {
        const titleView = title !== null ? this.createTitleView(title, pieTrait) : null;
        pieView.title.setView(titleView);
      }
    }
  }
  __decorate([ TraitViewRef({
    traitType: PieTrait,
    observesTrait: true,
    willAttachTrait(pieTrait) {
      this.owner.callObservers("controllerWillAttachPieTrait", pieTrait, this.owner);
    },
    didAttachTrait(pieTrait) {
      const sliceTraits = pieTrait.slices.traits;
      for (const traitId in sliceTraits) {
        const sliceTrait = sliceTraits[traitId];
        this.owner.slices.addTraitController(sliceTrait);
      }
      const pieView = this.view;
      if (pieView !== null) {
        this.owner.setTitleView(pieTrait.title.value, pieTrait);
      }
    },
    willDetachTrait(pieTrait) {
      const pieView = this.view;
      if (pieView !== null) {
        this.owner.setTitleView(pieTrait.title.value, pieTrait);
      }
      const sliceTraits = pieTrait.slices.traits;
      for (const traitId in sliceTraits) {
        const sliceTrait = sliceTraits[traitId];
        this.owner.slices.deleteTraitController(sliceTrait);
      }
    },
    didDetachTrait(pieTrait) {
      this.owner.callObservers("controllerDidDetachPieTrait", pieTrait, this.owner);
    },
    traitDidSetPieTitle(newTitle, oldTitle, pieTrait) {
      this.owner.setTitleView(newTitle, pieTrait);
    },
    traitWillAttachSlice(sliceTrait, targetTrait) {
      this.owner.slices.addTraitController(sliceTrait);
    },
    traitDidDetachSlice(sliceTrait) {
      this.owner.slices.deleteTraitController(sliceTrait);
    },
    viewType: PieView,
    observesView: true,
    initView(pieView) {
      const sliceControllers = this.owner.slices.controllers;
      for (const controllerId in sliceControllers) {
        const sliceController = sliceControllers[controllerId];
        const sliceView = sliceController.slice.view;
        if (sliceView !== null && sliceView.parent === null) {
          sliceController.slice.insertView(pieView);
        }
      }
      this.owner.title.setView(pieView.title.view);
      const pieTrait = this.trait;
      if (pieTrait !== null) {
        this.owner.setTitleView(pieTrait.title.value, pieTrait);
      }
    },
    deinitView(pieView) {
      this.owner.title.setView(null);
    },
    willAttachView(pieView) {
      this.owner.callObservers("controllerWillAttachPieView", pieView, this.owner);
    },
    didDetachView(pieView) {
      this.owner.callObservers("controllerDidDetachPieView", pieView, this.owner);
    },
    viewWillAttachPieTitle(titleView) {
      this.owner.title.setView(titleView);
    },
    viewDidDetachPieTitle(titleView) {
      this.owner.title.setView(titleView);
    }
  }) ], PieController.prototype, "pie", void 0);
  __decorate([ ViewRef({
    key: true,
    willAttachView(titleView) {
      this.owner.callObservers("controllerWillAttachPieTitleView", titleView, this.owner);
    },
    didDetachView(titleView) {
      this.owner.callObservers("controllerDidDetachPieTitleView", titleView, this.owner);
    }
  }) ], PieController.prototype, "title", void 0);
  __decorate([ component.Property({
    type: util.Timing,
    value: true
  }) ], PieController.prototype, "sliceTiming", void 0);
  __decorate([ TraitViewControllerSet({
    implements: true,
    type: SliceController,
    binds: true,
    observes: true,
    get parentView() {
      return this.owner.pie.view;
    },
    getTraitViewRef(sliceController) {
      return sliceController.slice;
    },
    willAttachController(sliceController) {
      this.owner.callObservers("controllerWillAttachSlice", sliceController, this.owner);
    },
    didAttachController(sliceController) {
      const sliceTrait = sliceController.slice.trait;
      if (sliceTrait !== null) {
        this.attachSliceTrait(sliceTrait, sliceController);
      }
      const sliceView = sliceController.slice.view;
      if (sliceView !== null) {
        this.attachSliceView(sliceView, sliceController);
      }
    },
    willDetachController(sliceController) {
      const sliceView = sliceController.slice.view;
      if (sliceView !== null) {
        this.detachSliceView(sliceView, sliceController);
      }
      const sliceTrait = sliceController.slice.trait;
      if (sliceTrait !== null) {
        this.detachSliceTrait(sliceTrait, sliceController);
      }
    },
    didDetachController(sliceController) {
      this.owner.callObservers("controllerDidDetachSlice", sliceController, this.owner);
    },
    controllerWillAttachSliceTrait(sliceTrait, sliceController) {
      this.owner.callObservers("controllerWillAttachSliceTrait", sliceTrait, sliceController, this.owner);
      this.attachSliceTrait(sliceTrait, sliceController);
    },
    controllerDidDetachSliceTrait(sliceTrait, sliceController) {
      this.detachSliceTrait(sliceTrait, sliceController);
      this.owner.callObservers("controllerDidDetachSliceTrait", sliceTrait, sliceController, this.owner);
    },
    attachSliceTrait(sliceTrait, sliceController) {},
    detachSliceTrait(sliceTrait, sliceController) {},
    controllerWillAttachSliceView(sliceView, sliceController) {
      this.owner.callObservers("controllerWillAttachSliceView", sliceView, sliceController, this.owner);
      this.attachSliceView(sliceView, sliceController);
    },
    controllerDidDetachSliceView(sliceView, sliceController) {
      this.detachSliceView(sliceView, sliceController);
      this.owner.callObservers("controllerDidDetachSliceView", sliceView, sliceController, this.owner);
    },
    attachSliceView(sliceView, sliceController) {
      const labelView = sliceView.label.view;
      if (labelView !== null) {
        this.attachSliceLabelView(labelView, sliceController);
      }
      const legendView = sliceView.legend.view;
      if (legendView !== null) {
        this.attachSliceLegendView(legendView, sliceController);
      }
    },
    detachSliceView(sliceView, sliceController) {
      const legendView = sliceView.legend.view;
      if (legendView !== null) {
        this.detachSliceLegendView(legendView, sliceController);
      }
      const labelView = sliceView.label.view;
      if (labelView !== null) {
        this.detachSliceLabelView(labelView, sliceController);
      }
      sliceView.remove();
    },
    controllerWillSetSliceValue(newValue, oldValue, sliceController) {
      this.owner.callObservers("controllerWillSetSliceValue", newValue, oldValue, sliceController, this.owner);
    },
    controllerDidSetSliceValue(newValue, oldValue, sliceController) {
      this.owner.callObservers("controllerDidSetSliceValue", newValue, oldValue, sliceController, this.owner);
    },
    controllerWillAttachSliceLabelView(labelView, sliceController) {
      this.owner.callObservers("controllerWillAttachSliceLabelView", labelView, sliceController, this.owner);
      this.attachSliceLabelView(labelView, sliceController);
    },
    controllerDidDetachSliceLabelView(labelView, sliceController) {
      this.detachSliceLabelView(labelView, sliceController);
      this.owner.callObservers("controllerDidDetachSliceLabelView", labelView, sliceController, this.owner);
    },
    attachSliceLabelView(labelView, sliceController) {},
    detachSliceLabelView(labelView, sliceController) {},
    controllerWillAttachSliceLegendView(legendView, sliceController) {
      this.owner.callObservers("controllerWillAttachSliceLegendView", legendView, sliceController, this.owner);
      this.attachSliceLegendView(legendView, sliceController);
    },
    controllerDidDetachSliceLegendView(legendView, sliceController) {
      this.detachSliceLegendView(legendView, sliceController);
      this.owner.callObservers("controllerDidDetachSliceLegendView", legendView, sliceController, this.owner);
    },
    attachSliceLegendView(legendView, sliceController) {},
    detachSliceLegendView(legendView, sliceController) {}
  }) ], PieController.prototype, "slices", void 0);
  class DataPointView extends GraphicsView {
    constructor() {
      super();
      this.xCoord = NaN;
      this.yCoord = NaN;
      this.y2Coord = void 0;
      this.gradientStop = false;
    }
    setXCoord(xCoord) {
      this.xCoord = xCoord;
    }
    setYCoord(yCoord) {
      this.yCoord = yCoord;
    }
    setY2Coord(y2Coord) {
      this.y2Coord = y2Coord;
    }
    setState(point, timing) {
      if (point.x !== void 0) {
        this.x(point.x, timing);
      }
      if (point.y !== void 0) {
        this.y(point.y, timing);
      }
      if (point.y2 !== void 0) {
        this.y2(point.y2, timing);
      }
      if (point.radius !== void 0) {
        this.radius(point.radius, timing);
      }
      if (point.hitRadius !== void 0) {
        this.hitRadius(point.hitRadius);
      }
      if (point.color !== void 0) {
        this.color(point.color, timing);
      }
      if (point.opacity !== void 0) {
        this.opacity(point.opacity, timing);
      }
      if (point.font !== void 0) {
        this.font(point.font, timing);
      }
      if (point.textColor !== void 0) {
        this.textColor(point.textColor, timing);
      }
      if (point.category !== void 0) {
        this.category(point.category);
      }
      if (point.labelPadding !== void 0) {
        this.labelPadding(point.labelPadding, timing);
      }
      if (point.labelPlacement !== void 0) {
        this.labelPlacement(point.labelPlacement);
      }
      if (point.label !== void 0) {
        this.label(point.label);
      }
    }
    isGradientStop() {
      return this.gradientStop;
    }
    updateGradientStop() {
      this.gradientStop = this.color.value !== null || this.opacity.value !== void 0;
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.layoutDataPoint(this.viewFrame);
    }
    layoutDataPoint(frame) {
      const labelView = this.label.view;
      if (labelView !== null) {
        this.layoutLabel(labelView, frame);
      }
    }
    layoutLabel(labelView, frame) {
      let placement = this.labelPlacement.value;
      if (placement !== "above" && placement !== "below" && placement !== "middle") {
        const category = this.category.value;
        if (category === "increasing" || category === "maxima") {
          placement = "above";
        } else if (category === "decreasing" || category === "minima") {
          placement = "below";
        } else {
          placement = "above";
        }
      }
      const x = this.xCoord;
      const y0 = this.yCoord;
      let y1 = y0;
      if (placement === "above") {
        y1 -= this.labelPadding.getValue().pxValue(Math.min(frame.width, frame.height));
      } else if (placement === "below") {
        y1 += this.labelPadding.getValue().pxValue(Math.min(frame.width, frame.height));
      }
      if (TypesetView.is(labelView)) {
        labelView.textAlign.setState("center", component.Affinity.Intrinsic);
        if (placement === "above") {
          labelView.textBaseline.setState("bottom", component.Affinity.Intrinsic);
        } else if (placement === "below") {
          labelView.textBaseline.setState("top", component.Affinity.Intrinsic);
        } else if (placement === "middle") {
          labelView.textBaseline.setState("middle", component.Affinity.Intrinsic);
        }
        labelView.textOrigin.setState(new math.R2Point(x, y1), component.Affinity.Intrinsic);
      }
    }
    hitTest(x, y, viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer) {
        return this.hitTestPoint(x, y, renderer.context, this.viewFrame);
      }
      return null;
    }
    hitTestPoint(x, y, context, frame) {
      let hitRadius = this.hitRadius.value;
      const radius = this.radius.value;
      if (radius !== null) {
        const size = Math.min(frame.width, frame.height);
        hitRadius = Math.max(hitRadius, radius.pxValue(size));
      }
      const dx = this.xCoord - x;
      const dy = this.yCoord - y;
      if (dx * dx + dy * dy < hitRadius * hitRadius) {
        return this;
      }
      return null;
    }
    init(init) {
      super.init(init);
      this.setState(init);
    }
    static fromAny(value) {
      return super.fromAny(value);
    }
  }
  __decorate([ component.Animator({
    willSetValue(newX, oldX) {
      this.owner.callObservers("viewWillSetDataPointX", newX, oldX, this.owner);
    },
    didSetValue(newX, oldX) {
      this.owner.callObservers("viewDidSetDataPointX", newX, oldX, this.owner);
    }
  }) ], DataPointView.prototype, "x", void 0);
  __decorate([ component.Animator({
    willSetValue(newY, oldY) {
      this.owner.callObservers("viewWillSetDataPointY", newY, oldY, this.owner);
    },
    didSetValue(newY, oldY) {
      this.owner.callObservers("viewDidSetDataPointY", newY, oldY, this.owner);
    }
  }) ], DataPointView.prototype, "y", void 0);
  __decorate([ component.Animator({
    willSetValue(newY2, oldY2) {
      this.owner.callObservers("viewWillSetDataPointY2", newY2, oldY2, this.owner);
    },
    didSetValue(newY2, oldY2) {
      this.owner.callObservers("viewDidSetDataPointY2", newY2, oldY2, this.owner);
    }
  }) ], DataPointView.prototype, "y2", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    willSetValue(newRadius, oldRadius) {
      this.owner.callObservers("viewWillSetDataPointRadius", newRadius, oldRadius, this.owner);
    },
    didSetValue(newRadius, oldRadius) {
      this.owner.callObservers("viewDidSetDataPointRadius", newRadius, oldRadius, this.owner);
    }
  }) ], DataPointView.prototype, "radius", void 0);
  __decorate([ component.Property({
    type: Number,
    value: 5
  }) ], DataPointView.prototype, "hitRadius", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    willSetValue(newColor, oldColor) {
      this.owner.callObservers("viewWillSetDataPointColor", newColor, oldColor, this.owner);
    },
    didSetValue(newColor, oldColor) {
      this.owner.updateGradientStop();
      this.owner.callObservers("viewDidSetDataPointColor", newColor, oldColor, this.owner);
    }
  }) ], DataPointView.prototype, "color", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    willSetValue(newOpacity, oldOpacity) {
      this.owner.callObservers("viewWillSetDataPointOpacity", newOpacity, oldOpacity, this.owner);
    },
    didSetValue(newOpacity, oldOpacity) {
      this.owner.updateGradientStop();
      this.owner.callObservers("viewDidSetDataPointOpacity", newOpacity, oldOpacity, this.owner);
    }
  }) ], DataPointView.prototype, "opacity", void 0);
  __decorate([ ThemeAnimator({
    type: Font,
    inherits: true
  }) ], DataPointView.prototype, "font", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    inherits: true
  }) ], DataPointView.prototype, "textColor", void 0);
  __decorate([ component.Property({
    type: String
  }) ], DataPointView.prototype, "category", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.zero(),
    updateFlags: View.NeedsLayout
  }) ], DataPointView.prototype, "labelPadding", void 0);
  __decorate([ ViewRef({
    key: true,
    type: TextRunView,
    binds: true,
    willAttachView(labelView) {
      this.owner.callObservers("viewWillAttachDataPointLabel", labelView, this.owner);
    },
    didDetachView(labelView) {
      this.owner.callObservers("viewDidDetachDataPointLabel", labelView, this.owner);
    },
    fromAny(value) {
      if (typeof value === "string") {
        if (this.view instanceof TextRunView) {
          this.view.text(value);
          return this.view;
        } else {
          return TextRunView.fromAny(value);
        }
      } else {
        return GraphicsView.fromAny(value);
      }
    }
  }) ], DataPointView.prototype, "label", void 0);
  __decorate([ component.Property({
    type: String,
    value: "auto"
  }) ], DataPointView.prototype, "labelPlacement", void 0);
  class DataPointTrait extends Trait {
    constructor(x, y) {
      super();
      this.x.setValue(x);
      this.y.setValue(y);
    }
    formatLabel(x, y) {
      return void 0;
    }
  }
  __decorate([ component.Property({
    willSetValue(newX, oldX) {
      this.owner.callObservers("traitWillSetDataPointX", newX, oldX, this.owner);
    },
    didSetValue(newX, oldX) {
      this.owner.callObservers("traitDidSetDataPointX", newX, oldX, this.owner);
    }
  }) ], DataPointTrait.prototype, "x", void 0);
  __decorate([ component.Property({
    willSetValue(newY, oldY) {
      this.owner.callObservers("traitWillSetDataPointY", newY, oldY, this.owner);
    },
    didSetValue(newY, oldY) {
      this.owner.callObservers("traitDidSetDataPointY", newY, oldY, this.owner);
    }
  }) ], DataPointTrait.prototype, "y", void 0);
  __decorate([ component.Property({
    willSetValue(newY2, oldY2) {
      this.owner.callObservers("traitWillSetDataPointY2", newY2, oldY2, this.owner);
    },
    didSetValue(newY2, oldY2) {
      this.owner.callObservers("traitDidSetDataPointY2", newY2, oldY2, this.owner);
    }
  }) ], DataPointTrait.prototype, "y2", void 0);
  __decorate([ component.Property({
    type: math.Length,
    value: null,
    willSetValue(newRadius, oldRadius) {
      this.owner.callObservers("traitWillSetDataPointRadius", newRadius, oldRadius, this.owner);
    },
    didSetValue(newRadius, oldRadius) {
      this.owner.callObservers("traitDidSetDataPointRadius", newRadius, oldRadius, this.owner);
    }
  }) ], DataPointTrait.prototype, "radius", void 0);
  __decorate([ component.Property({
    value: null,
    willSetValue(newColor, oldColor) {
      this.owner.callObservers("traitWillSetDataPointColor", newColor, oldColor, this.owner);
    },
    didSetValue(newColor, oldColor) {
      this.owner.callObservers("traitDidSetDataPointColor", newColor, oldColor, this.owner);
    },
    fromAny(color) {
      if (color !== null && !(color instanceof Look)) {
        color = Color.fromAny(color);
      }
      return color;
    }
  }) ], DataPointTrait.prototype, "color", void 0);
  __decorate([ component.Property({
    type: Number,
    willSetValue(newOpacity, oldOpacity) {
      this.owner.callObservers("traitWillSetDataPointOpacity", newOpacity, oldOpacity, this.owner);
    },
    didSetValue(newOpacity, oldOpacity) {
      this.owner.callObservers("traitDidSetDataPointOpacity", newOpacity, oldOpacity, this.owner);
    }
  }) ], DataPointTrait.prototype, "opacity", void 0);
  __decorate([ component.Property({
    value: null,
    willSetValue(newLabel, oldLabel) {
      this.owner.callObservers("traitWillSetDataPointLabel", newLabel, oldLabel, this.owner);
    },
    didSetValue(newLabel, oldLabel) {
      this.owner.callObservers("traitDidSetDataPointLabel", newLabel, oldLabel, this.owner);
    }
  }) ], DataPointTrait.prototype, "label", void 0);
  class DataSetTrait extends Trait {
    startConsumingDataPoints() {
      const dataPointTraits = this.dataPoints.traits;
      for (const traitId in dataPointTraits) {
        const dataPointTrait = dataPointTraits[traitId];
        dataPointTrait.consume(this);
      }
    }
    stopConsumingDataPoints() {
      const dataPointTraits = this.dataPoints.traits;
      for (const traitId in dataPointTraits) {
        const dataPointTrait = dataPointTraits[traitId];
        dataPointTrait.unconsume(this);
      }
    }
    onStartConsuming() {
      super.onStartConsuming();
      this.startConsumingDataPoints();
    }
    onStopConsuming() {
      super.onStopConsuming();
      this.stopConsumingDataPoints();
    }
  }
  __decorate([ TraitSet({
    type: DataPointTrait,
    binds: true,
    willAttachTrait(dataPointTrait, targetTrait) {
      this.owner.callObservers("traitWillAttachDataPoint", dataPointTrait, targetTrait, this.owner);
    },
    didAttachTrait(dataPointTrait) {
      if (this.owner.consuming) {
        dataPointTrait.consume(this.owner);
      }
    },
    willDetachTrait(dataPointTrait) {
      if (this.owner.consuming) {
        dataPointTrait.unconsume(this.owner);
      }
    },
    didDetachTrait(dataPointTrait) {
      this.owner.callObservers("traitDidDetachDataPoint", dataPointTrait, this.owner);
    },
    detectModel(model) {
      return model.getTrait(DataPointTrait);
    }
  }) ], DataSetTrait.prototype, "dataPoints", void 0);
  class DataPointController extends Controller {
    updateLabel(x, y, dataPointTrait) {
      const label = dataPointTrait.formatLabel(x, y);
      if (label !== void 0) {
        dataPointTrait.label.setValue(label, component.Affinity.Intrinsic);
      }
    }
    setX(x, dataPointTrait, timing) {
      const dataPointView = this.dataPoint.view;
      if (dataPointView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.dataPointTiming.value;
          if (timing === true) {
            timing = dataPointView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        dataPointView.x.setState(x, timing, component.Affinity.Intrinsic);
      }
    }
    setY(y, dataPointTrait, timing) {
      const dataPointView = this.dataPoint.view;
      if (dataPointView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.dataPointTiming.value;
          if (timing === true) {
            timing = dataPointView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        dataPointView.y.setState(y, timing, component.Affinity.Intrinsic);
      }
    }
    setY2(y2, dataPointTrait, timing) {
      const dataPointView = this.dataPoint.view;
      if (dataPointView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.dataPointTiming.value;
          if (timing === true) {
            timing = dataPointView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        dataPointView.y2.setState(y2, timing, component.Affinity.Intrinsic);
      }
    }
    setRadius(radius, dataPointTrait, timing) {
      const dataPointView = this.dataPoint.view;
      if (dataPointView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.dataPointTiming.value;
          if (timing === true) {
            timing = dataPointView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        dataPointView.radius.setState(radius, timing, component.Affinity.Intrinsic);
      }
    }
    setColor(color, dataPointTrait, timing) {
      const dataPointView = this.dataPoint.view;
      if (dataPointView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.dataPointTiming.value;
          if (timing === true) {
            timing = dataPointView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        if (color instanceof Look) {
          dataPointView.color.setLook(color, timing, component.Affinity.Intrinsic);
        } else {
          dataPointView.color.setState(color, timing, component.Affinity.Intrinsic);
        }
      }
    }
    setOpacity(opacity, dataPointTrait, timing) {
      const dataPointView = this.dataPoint.view;
      if (dataPointView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.dataPointTiming.value;
          if (timing === true) {
            timing = dataPointView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        dataPointView.opacity.setState(opacity, timing, component.Affinity.Intrinsic);
      }
    }
    createLabelView(label, dataPointTrait) {
      if (typeof label === "function") {
        return label(dataPointTrait);
      } else {
        return label;
      }
    }
    setLabelView(label, dataPointTrait) {
      const dataPointView = this.dataPoint.view;
      if (dataPointView !== null) {
        const labelView = label !== null ? this.createLabelView(label, dataPointTrait) : null;
        dataPointView.label.setView(labelView);
      }
    }
  }
  __decorate([ component.Property({
    type: util.Timing,
    inherits: true
  }) ], DataPointController.prototype, "dataPointTiming", void 0);
  __decorate([ TraitViewRef({
    traitType: DataPointTrait,
    observesTrait: true,
    willAttachTrait(dataPointTrait) {
      this.owner.callObservers("controllerWillAttachDataPointTrait", dataPointTrait, this.owner);
    },
    didAttachTrait(dataPointTrait) {
      const dataPointView = this.view;
      if (dataPointView !== null) {
        this.owner.setX(dataPointTrait.x.value, dataPointTrait);
        this.owner.setY(dataPointTrait.y.value, dataPointTrait);
        this.owner.setY2(dataPointTrait.y2.value, dataPointTrait);
        this.owner.setRadius(dataPointTrait.radius.value, dataPointTrait);
        this.owner.setColor(dataPointTrait.color.value, dataPointTrait);
        this.owner.setOpacity(dataPointTrait.opacity.value, dataPointTrait);
        this.owner.setLabelView(dataPointTrait.label.value, dataPointTrait);
      }
    },
    willDetachTrait(dataPointTrait) {
      const dataPointView = this.view;
      if (dataPointView !== null) {
        this.owner.setLabelView(null, dataPointTrait);
      }
    },
    didDetachTrait(dataPointTrait) {
      this.owner.callObservers("controllerDidDetachDataPointTrait", dataPointTrait, this.owner);
    },
    traitDidSetDataPointX(newX, oldX, dataPointTrait) {
      this.owner.setX(newX, dataPointTrait);
    },
    traitDidSetDataPointY(newY, oldY, dataPointTrait) {
      this.owner.setY(newY, dataPointTrait);
    },
    traitDidSetDataPointY2(newY2, oldY2, dataPointTrait) {
      this.owner.setY2(newY2, dataPointTrait);
    },
    traitDidSetDataPointRadius(newRadius, oldRadius, dataPointTrait) {
      this.owner.setRadius(newRadius, dataPointTrait);
    },
    traitDidSetDataPointColor(newColor, oldColor, dataPointTrait) {
      this.owner.setColor(newColor, dataPointTrait);
    },
    traitDidSetDataPointOpacity(newOpacity, oldOpacity, dataPointTrait) {
      this.owner.setOpacity(newOpacity, dataPointTrait);
    },
    traitDidSetDataPointLabel(newLabel, oldLabel, dataPointTrait) {
      this.owner.setLabelView(newLabel, dataPointTrait);
    },
    viewType: DataPointView,
    observesView: true,
    willAttachView(dataPointView) {
      this.owner.callObservers("controllerWillAttachDataPointView", dataPointView, this.owner);
    },
    didAttachView(dataPointView) {
      this.owner.label.setView(dataPointView.label.view);
      const dataPointTrait = this.trait;
      if (dataPointTrait !== null) {
        this.owner.setX(dataPointTrait.x.value, dataPointTrait);
        this.owner.setY(dataPointTrait.y.value, dataPointTrait);
        this.owner.setY2(dataPointTrait.y2.value, dataPointTrait);
        this.owner.setRadius(dataPointTrait.radius.value, dataPointTrait);
        this.owner.setColor(dataPointTrait.color.value, dataPointTrait);
        this.owner.setOpacity(dataPointTrait.opacity.value, dataPointTrait);
        this.owner.setLabelView(dataPointTrait.label.value, dataPointTrait);
        const x = dataPointView.x.value;
        const y = dataPointView.y.value;
        this.owner.updateLabel(x, y, dataPointTrait);
      }
    },
    willDetachView(dataPointView) {
      this.owner.label.setView(null);
    },
    didDetachView(dataPointView) {
      this.owner.callObservers("controllerDidDetachDataPointView", dataPointView, this.owner);
    },
    viewWillSetDataPointX(newX, oldX, dataPointView) {
      this.owner.callObservers("controllerWillSetDataPointX", newX, oldX, this.owner);
    },
    viewDidSetDataPointX(newX, oldX, dataPointView) {
      const dataPointTrait = this.trait;
      if (dataPointTrait !== null) {
        const y = dataPointView.y.value;
        this.owner.updateLabel(newX, y, dataPointTrait);
      }
      this.owner.callObservers("controllerDidSetDataPointX", newX, oldX, this.owner);
    },
    viewWillSetDataPointY(newY, oldY, dataPointView) {
      this.owner.callObservers("controllerWillSetDataPointY", newY, oldY, this.owner);
    },
    viewDidSetDataPointY(newY, oldY, dataPointView) {
      const dataPointTrait = this.trait;
      if (dataPointTrait !== null) {
        const x = dataPointView.x.value;
        this.owner.updateLabel(x, newY, dataPointTrait);
      }
      this.owner.callObservers("controllerDidSetDataPointY", newY, oldY, this.owner);
    },
    viewWillSetDataPointY2(newY2, oldY2, dataPointView) {
      this.owner.callObservers("controllerWillSetDataPointY2", newY2, oldY2, this.owner);
    },
    viewDidSetDataPointY2(newY2, oldY2, dataPointView) {
      this.owner.callObservers("controllerDidSetDataPointY2", newY2, oldY2, this.owner);
    },
    viewWillSetDataPointRadius(newRadius, oldRadius, dataPointView) {
      this.owner.callObservers("controllerWillSetDataPointRadius", newRadius, oldRadius, this.owner);
    },
    viewDidSetDataPointRadius(newRadius, oldRadius, dataPointView) {
      this.owner.callObservers("controllerDidSetDataPointRadius", newRadius, oldRadius, this.owner);
    },
    viewWillSetDataPointColor(newColor, oldColor, dataPointView) {
      this.owner.callObservers("controllerWillSetDataPointColor", newColor, oldColor, this.owner);
    },
    viewDidSetDataPointColor(newColor, oldColor, dataPointView) {
      this.owner.callObservers("controllerDidSetDataPointColor", newColor, oldColor, this.owner);
    },
    viewWillSetDataPointOpacity(newOpacity, oldOpacity, dataPointView) {
      this.owner.callObservers("controllerWillSetDataPointOpacity", newOpacity, oldOpacity, this.owner);
    },
    viewDidSetDataPointOpacity(newOpacity, oldOpacity, dataPointView) {
      this.owner.callObservers("controllerDidSetDataPointOpacity", newOpacity, oldOpacity, this.owner);
    },
    viewWillAttachDataPointLabel(labelView) {
      this.owner.label.setView(labelView);
    },
    viewDidDetachDataPointLabel(labelView) {
      this.owner.label.setView(null);
    },
    createView() {
      const dataPointView = new DataPointView;
      const dataPointTrait = this.trait;
      if (dataPointTrait !== null) {
        dataPointView.x.setState(dataPointTrait.x.value, component.Affinity.Intrinsic);
        dataPointView.y.setState(dataPointTrait.y.value, component.Affinity.Intrinsic);
        dataPointView.y2.setState(dataPointTrait.y2.value, component.Affinity.Intrinsic);
        dataPointView.radius.setState(dataPointTrait.radius.value, component.Affinity.Intrinsic);
      }
      return dataPointView;
    }
  }) ], DataPointController.prototype, "dataPoint", void 0);
  __decorate([ ViewRef({
    key: true,
    willAttachView(labelView) {
      this.owner.callObservers("controllerWillAttachDataPointLabelView", labelView, this.owner);
    },
    didDetachView(labelView) {
      this.owner.callObservers("controllerDidDetachDataPointLabelView", labelView, this.owner);
    }
  }) ], DataPointController.prototype, "label", void 0);
  class DataSetController extends Controller {}
  __decorate([ TraitRef({
    type: DataSetTrait,
    observes: true,
    willAttachTrait(dataSetTrait) {
      this.owner.callObservers("controllerWillAttachDataSetTrait", dataSetTrait, this.owner);
    },
    didAttachTrait(dataSetTrait) {
      const dataPointTraits = dataSetTrait.dataPoints.traits;
      for (const traitId in dataPointTraits) {
        const dataPointTrait = dataPointTraits[traitId];
        this.owner.dataPoints.addTraitController(dataPointTrait);
      }
    },
    willDetachTrait(dataSetTrait) {
      const dataPointTraits = dataSetTrait.dataPoints.traits;
      for (const traitId in dataPointTraits) {
        const dataPointTrait = dataPointTraits[traitId];
        this.owner.dataPoints.deleteTraitController(dataPointTrait);
      }
    },
    didDetachTrait(dataSetTrait) {
      this.owner.callObservers("controllerDidDetachDataSetTrait", dataSetTrait, this.owner);
    },
    traitWillAttachDataPoint(dataPointTrait, targetTrait) {
      this.owner.dataPoints.addTraitController(dataPointTrait, targetTrait);
    },
    traitDidDetachDataPoint(dataPointTrait) {
      this.owner.dataPoints.deleteTraitController(dataPointTrait);
    }
  }) ], DataSetController.prototype, "dataSet", void 0);
  __decorate([ component.Property({
    type: util.Timing,
    value: true
  }) ], DataSetController.prototype, "dataPointTiming", void 0);
  __decorate([ TraitViewControllerSet({
    implements: true,
    type: DataPointController,
    binds: true,
    observes: true,
    getTraitViewRef(dataPointController) {
      return dataPointController.dataPoint;
    },
    willAttachController(dataPointController) {
      this.owner.callObservers("controllerWillAttachDataPoint", dataPointController, this.owner);
    },
    didAttachController(dataPointController) {
      const dataPointTrait = dataPointController.dataPoint.trait;
      if (dataPointTrait !== null) {
        this.attachDataPointTrait(dataPointTrait, dataPointController);
      }
      const dataPointView = dataPointController.dataPoint.view;
      if (dataPointView !== null) {
        this.attachDataPointView(dataPointView, dataPointController);
      }
      const parentView = this.parentView;
      if (parentView !== null) {
        dataPointController.dataPoint.insertView(parentView);
      }
    },
    willDetachController(dataPointController) {
      const dataPointView = dataPointController.dataPoint.view;
      if (dataPointView !== null) {
        this.detachDataPointView(dataPointView, dataPointController);
      }
      const dataPointTrait = dataPointController.dataPoint.trait;
      if (dataPointTrait !== null) {
        this.detachDataPointTrait(dataPointTrait, dataPointController);
      }
    },
    didDetachController(dataPointController) {
      this.owner.callObservers("controllerDidDetachDataPoint", dataPointController, this.owner);
    },
    controllerWillAttachDataPointTrait(dataPointTrait, dataPointController) {
      this.owner.callObservers("controllerWillAttachDataPointTrait", dataPointTrait, dataPointController, this.owner);
      this.attachDataPointTrait(dataPointTrait, dataPointController);
    },
    controllerDidDetachDataPointTrait(dataPointTrait, dataPointController) {
      this.detachDataPointTrait(dataPointTrait, dataPointController);
      this.owner.callObservers("controllerDidDetachDataPointTrait", dataPointTrait, dataPointController, this.owner);
    },
    attachDataPointTrait(dataPointTrait, dataPointController) {},
    detachDataPointTrait(dataPointTrait, dataPointController) {},
    controllerWillAttachDataPointView(dataPointView, dataPointController) {
      this.owner.callObservers("controllerWillAttachDataPointView", dataPointView, dataPointController, this.owner);
      this.attachDataPointView(dataPointView, dataPointController);
    },
    controllerDidDetachDataPointView(dataPointView, dataPointController) {
      this.detachDataPointView(dataPointView, dataPointController);
      this.owner.callObservers("controllerDidDetachDataPointView", dataPointView, dataPointController, this.owner);
    },
    attachDataPointView(dataPointView, dataPointController) {
      const labelView = dataPointView.label.view;
      if (labelView !== null) {
        this.attachDataPointLabelView(labelView, dataPointController);
      }
    },
    detachDataPointView(dataPointView, dataPointController) {
      const labelView = dataPointView.label.view;
      if (labelView !== null) {
        this.detachDataPointLabelView(labelView, dataPointController);
      }
      dataPointView.remove();
    },
    controllerWillSetDataPointX(newX, oldX, dataPointController) {
      this.owner.callObservers("controllerWillSetDataPointX", newX, oldX, dataPointController, this.owner);
    },
    controllerDidSetDataPointX(newX, oldX, dataPointController) {
      this.owner.callObservers("controllerDidSetDataPointX", newX, oldX, dataPointController, this.owner);
    },
    controllerWillSetDataPointY(newY, oldY, dataPointController) {
      this.owner.callObservers("controllerWillSetDataPointY", newY, oldY, dataPointController, this.owner);
    },
    controllerDidSetDataPointY(newY, oldY, dataPointController) {
      this.owner.callObservers("controllerDidSetDataPointY", newY, oldY, dataPointController, this.owner);
    },
    controllerWillSetDataPointY2(newY2, oldY2, dataPointController) {
      this.owner.callObservers("controllerWillSetDataPointY2", newY2, oldY2, dataPointController, this.owner);
    },
    controllerDidSetDataPointY2(newY2, oldY2, dataPointController) {
      this.owner.callObservers("controllerDidSetDataPointY2", newY2, oldY2, dataPointController, this.owner);
    },
    controllerWillSetDataPointRadius(newRadius, oldRadius, dataPointController) {
      this.owner.callObservers("controllerWillSetDataPointRadius", newRadius, oldRadius, dataPointController, this.owner);
    },
    controllerDidSetDataPointRadius(newRadius, oldRadius, dataPointController) {
      this.owner.callObservers("controllerDidSetDataPointRadius", newRadius, oldRadius, dataPointController, this.owner);
    },
    controllerWillSetDataPointColor(newColor, oldColor, dataPointController) {
      this.owner.callObservers("controllerWillSetDataPointColor", newColor, oldColor, dataPointController, this.owner);
    },
    controllerDidSetDataPointColor(newColor, oldColor, dataPointController) {
      this.owner.callObservers("controllerDidSetDataPointColor", newColor, oldColor, dataPointController, this.owner);
    },
    controllerWillSetDataPointOpacity(newOpacity, oldOpacity, dataPointController) {
      this.owner.callObservers("controllerWillSetDataPointOpacity", newOpacity, oldOpacity, dataPointController, this.owner);
    },
    controllerDidSetDataPointOpacity(newOpacity, oldOpacity, dataPointController) {
      this.owner.callObservers("controllerDidSetDataPointOpacity", newOpacity, oldOpacity, dataPointController, this.owner);
    },
    controllerWillAttachDataPointLabelView(labelView, dataPointController) {
      this.owner.callObservers("controllerWillAttachDataPointLabelView", labelView, dataPointController, this.owner);
      this.attachDataPointLabelView(labelView, dataPointController);
    },
    controllerDidDetachDataPointLabelView(labelView, dataPointController) {
      this.detachDataPointLabelView(labelView, dataPointController);
      this.owner.callObservers("controllerDidDetachDataPointLabelView", labelView, dataPointController, this.owner);
    },
    attachDataPointLabelView(labelView, dataPointController) {},
    detachDataPointLabelView(labelView, dataPointController) {}
  }) ], DataSetController.prototype, "dataPoints", void 0);
  const ContinuousScaleAnimator = function(_super) {
    const ContinuousScaleAnimator = _super.extend("ContinuousScaleAnimator");
    ContinuousScaleAnimator.prototype.setScale = function(xMin, xMax, yMin, yMax, timing) {
      if (typeof xMin === "string") {
        xMin = ScaledView.parseScale(xMin).domain;
      }
      if (xMin instanceof util.Domain) {
        timing = yMin;
        if (xMax instanceof util.Domain) {
          yMax = xMax[1];
          yMin = xMax[0];
        }
        xMax = xMin[1];
        xMin = xMin[0];
      }
      const oldState = this.state;
      let newState;
      if (oldState !== void 0 && oldState !== null) {
        newState = oldState.withDomain(xMin, xMax);
        if (yMin !== void 0 && yMax !== void 0) {
          newState = newState.overRange(yMin, yMax);
        }
        if ((timing === void 0 || timing === null || timing === false) && (this.flags & component.Animator.TweeningFlag) !== 0) {
          const oldValue = this.getValue();
          const newValue = oldValue.withDomain(xMin, xMax);
          this.setValue(newValue, component.Affinity.Extrinsic);
          timing = true;
        }
      } else {
        newState = ScaledView.createScale(xMin, xMax, yMin, yMax);
      }
      this.setState(newState, timing, component.Affinity.Extrinsic);
    };
    ContinuousScaleAnimator.prototype.setDomain = function(xMin, xMax, timing) {
      if (typeof xMin === "string") {
        xMin = ScaledView.parseScale(xMin).domain;
      }
      if (xMin instanceof util.Domain) {
        timing = xMax;
        xMax = xMin[1];
        xMin = xMin[0];
      }
      const oldState = this.state;
      let newState;
      if (oldState !== void 0 && oldState !== null) {
        newState = oldState.withDomain(xMin, xMax);
        if ((timing === void 0 || timing === null || timing === false) && (this.flags & component.Animator.TweeningFlag) !== 0) {
          const oldValue = this.getValue();
          const newValue = oldValue.withDomain(xMin, xMax);
          this.setValue(newValue, component.Affinity.Extrinsic);
          timing = true;
        }
      } else {
        newState = ScaledView.createScale(xMin, xMax, 0, 1);
      }
      this.setState(newState, timing, component.Affinity.Extrinsic);
    };
    ContinuousScaleAnimator.prototype.setRange = function(yMin, yMax, timing) {
      const oldState = this.state;
      if (oldState !== void 0 && oldState !== null) {
        if (yMin instanceof util.Range) {
          timing = yMax;
          yMax = yMin[1];
          yMin = yMin[0];
        }
        const newState = oldState.overRange(yMin, yMax);
        if ((timing === void 0 || timing === null || timing === false) && (this.flags & component.Animator.TweeningFlag) !== 0) {
          const oldValue = this.getValue();
          const newValue = oldValue.overRange(yMin, yMax);
          this.setValue(newValue, component.Affinity.Extrinsic);
          timing = true;
        }
        this.setState(newState, timing, component.Affinity.Extrinsic);
      }
    };
    ContinuousScaleAnimator.prototype.setBaseScale = function(xMin, xMax, yMin, yMax, timing) {
      if (this.inherited && this.superFastener instanceof ContinuousScaleAnimator) {
        this.superFastener.setBaseScale(xMin, xMax, yMin, yMax, timing);
      } else {
        this.setScale(xMin, xMax, yMin, yMax, timing);
      }
    };
    ContinuousScaleAnimator.prototype.setBaseDomain = function(xMin, xMax, timing) {
      if (this.inherited && this.superFastener instanceof ContinuousScaleAnimator) {
        this.superFastener.setBaseDomain(xMin, xMax, timing);
      } else {
        this.setDomain(xMin, xMax, timing);
      }
    };
    ContinuousScaleAnimator.prototype.setBaseRange = function(yMin, yMax, timing) {
      if (this.inherited && this.superFastener instanceof ContinuousScaleAnimator) {
        this.superFastener.setBaseRange(yMin, yMax, timing);
      } else {
        this.setRange(yMin, yMax, timing);
      }
    };
    ContinuousScaleAnimator.prototype.fromAny = function(value) {
      if (typeof value === "string") {
        value = ScaledView.parseScale(value);
      }
      return value;
    };
    return ContinuousScaleAnimator;
  }(component.Animator);
  const ScaledXView = function() {
    const ScaledXView = {};
    ScaledXView.is = function(object) {
      if (typeof object === "object" && object !== null) {
        const view = object;
        return view instanceof ScaledView || view instanceof GraphicsView && "xScale" in view;
      }
      return false;
    };
    return ScaledXView;
  }();
  const ScaledYView = function() {
    const ScaledYView = {};
    ScaledYView.is = function(object) {
      if (typeof object === "object" && object !== null) {
        const view = object;
        return view instanceof ScaledView || view instanceof GraphicsView && "yScale" in view;
      }
      return false;
    };
    return ScaledYView;
  }();
  const ScaledXYView = function() {
    const ScaledXYView = {};
    ScaledXYView.is = function(object) {
      if (typeof object === "object" && object !== null) {
        const view = object;
        return view instanceof ScaledView || view instanceof GraphicsView && "xScale" in view && "yScale" in view;
      }
      return false;
    };
    return ScaledXYView;
  }();
  class ScaledView extends GraphicsView {
    constructor() {
      super();
      this.scaledFlags = 0;
      this.xDataDomain = null;
      this.yDataDomain = null;
      this.xDataRange = null;
      this.yDataRange = null;
      this.xDataDomainPadded = null;
      this.yDataDomainPadded = null;
    }
    setScaledFlags(scaledFlags) {
      this.scaledFlags = scaledFlags;
    }
    xDomain(xMin, xMax, timing) {
      if (xMin === void 0) {
        const xScale = this.xScale.value;
        return xScale !== null ? xScale.domain : null;
      } else {
        if (xMin instanceof util.Domain || typeof xMin === "string") {
          timing = xMax;
        }
        if (timing === true) {
          timing = this.rescaleTransition.value;
        }
        const xRange = this.xRange();
        if (xMin instanceof util.Domain || typeof xMin === "string") {
          if (xRange !== null) {
            this.xScale.setBaseScale(xMin, xRange, timing);
          } else {
            this.xScale.setBaseDomain(xMin, timing);
          }
        } else {
          if (xRange !== null) {
            this.xScale.setBaseScale(xMin, xMax, xRange[0], xRange[1], timing);
          } else {
            this.xScale.setBaseDomain(xMin, xMax, timing);
          }
        }
        return this;
      }
    }
    yDomain(yMin, yMax, timing) {
      if (yMin === void 0) {
        const yScale = this.yScale.value;
        return yScale !== null ? yScale.domain : null;
      } else {
        if (yMin instanceof util.Domain || typeof yMin === "string") {
          timing = yMax;
        }
        if (timing === true) {
          timing = this.rescaleTransition.value;
        }
        const yRange = this.yRange();
        if (yMin instanceof util.Domain || typeof yMin === "string") {
          if (yRange !== null) {
            this.yScale.setBaseScale(yMin, yRange, timing);
          } else {
            this.yScale.setBaseDomain(yMin, timing);
          }
        } else {
          if (yRange !== null) {
            this.yScale.setBaseScale(yMin, yMax, yRange[0], yRange[1], timing);
          } else {
            this.yScale.setBaseDomain(yMin, yMax, timing);
          }
        }
        return this;
      }
    }
    xRange() {
      const width = this.viewFrame.width;
      if (isFinite(width)) {
        const xRangePadding = this.xRangePadding.value;
        const xRangeMin = xRangePadding[0];
        const xRangeMax = width - xRangePadding[1];
        return util.LinearRange(xRangeMin, xRangeMax);
      } else {
        return null;
      }
    }
    yRange() {
      const height = this.viewFrame.height;
      if (isFinite(height)) {
        const yRangePadding = this.yRangePadding.value;
        const yRangeMin = yRangePadding[0];
        const yRangeMax = height - yRangePadding[1];
        return util.LinearRange(yRangeMax, yRangeMin);
      } else {
        return null;
      }
    }
    setXDataDomain(newXDataDomain) {
      const oldXDataDomain = this.xDataDomain;
      if (!util.Equals(newXDataDomain, oldXDataDomain)) {
        this.willSetXDataDomain(newXDataDomain, oldXDataDomain);
        this.xDataDomain = newXDataDomain;
        this.onSetXDataDomain(newXDataDomain, oldXDataDomain);
        this.didSetXDataDomain(newXDataDomain, oldXDataDomain);
      }
    }
    willSetXDataDomain(newXDataDomain, oldXDataDomain) {
      this.callObservers("viewWillSetXDataDomain", newXDataDomain, oldXDataDomain, this);
    }
    onSetXDataDomain(newXDataDomain, oldXDataDomain) {
      this.updateXDataRange();
      this.updateXDataDomainPadded();
      this.requireUpdate(View.NeedsLayout);
    }
    didSetXDataDomain(newXDataDomain, oldXDataDomain) {
      this.callObservers("viewDidSetXDataDomain", newXDataDomain, oldXDataDomain, this);
    }
    updateXDataDomain(xScaledDomain) {
      let xDataDomain = this.xDataDomain;
      if (xDataDomain === null || this.scaled.viewCount === 1) {
        xDataDomain = xScaledDomain;
      } else if (xScaledDomain !== null) {
        if (util.Values.compare(xScaledDomain[0], xDataDomain[0]) < 0) {
          xDataDomain = util.Domain(xScaledDomain[0], xDataDomain[1]);
        }
        if (util.Values.compare(xDataDomain[1], xScaledDomain[1]) < 0) {
          xDataDomain = util.Domain(xDataDomain[0], xScaledDomain[1]);
        }
      }
      this.setXDataDomain(xDataDomain);
    }
    setYDataDomain(newYDataDomain) {
      const oldYDataDomain = this.yDataDomain;
      if (!util.Equals(newYDataDomain, oldYDataDomain)) {
        this.willSetYDataDomain(newYDataDomain, oldYDataDomain);
        this.yDataDomain = newYDataDomain;
        this.onSetYDataDomain(newYDataDomain, oldYDataDomain);
        this.didSetYDataDomain(newYDataDomain, oldYDataDomain);
      }
    }
    willSetYDataDomain(newYDataDomain, oldYDataDomain) {
      this.callObservers("viewWillSetYDataDomain", newYDataDomain, oldYDataDomain, this);
    }
    onSetYDataDomain(newYDataDomain, oldYDataDomain) {
      this.updateYDataRange();
      this.updateYDataDomainPadded();
      this.requireUpdate(View.NeedsLayout);
    }
    didSetYDataDomain(newYDataDomain, oldYDataDomain) {
      this.callObservers("viewDidSetYDataDomain", newYDataDomain, oldYDataDomain, this);
    }
    updateYDataDomain(yScaledDomain) {
      let yDataDomain = this.yDataDomain;
      if (yDataDomain === null || this.scaled.viewCount === 1) {
        yDataDomain = yScaledDomain;
      } else if (yScaledDomain !== null) {
        if (util.Values.compare(yScaledDomain[0], yDataDomain[0]) < 0) {
          yDataDomain = util.Domain(yScaledDomain[0], yDataDomain[1]);
        }
        if (util.Values.compare(yDataDomain[1], yScaledDomain[1]) < 0) {
          yDataDomain = util.Domain(yDataDomain[0], yScaledDomain[1]);
        }
      }
      this.setYDataDomain(yDataDomain);
    }
    setXDataRange(xDataRange) {
      this.xDataRange = xDataRange;
    }
    updateXDataRange() {
      const xDataDomain = this.xDataDomain;
      if (xDataDomain !== null) {
        const xScale = this.xScale.value;
        if (xScale !== null) {
          this.setXDataRange(util.LinearRange(xScale(xDataDomain[0]), xScale(xDataDomain[1])));
        } else {
          this.setXDataRange(null);
        }
      }
    }
    setYDataRange(yDataRange) {
      this.yDataRange = yDataRange;
    }
    updateYDataRange() {
      const yDataDomain = this.yDataDomain;
      if (yDataDomain !== null) {
        const yScale = this.yScale.value;
        if (yScale !== null) {
          this.setYDataRange(util.LinearRange(yScale(yDataDomain[0]), yScale(yDataDomain[1])));
        } else {
          this.setYDataRange(null);
        }
      }
    }
    setXDataDomainPadded(xDataDomainPadded) {
      this.xDataDomainPadded = xDataDomainPadded;
    }
    updateXDataDomainPadded() {
      let xDataDomainPadded;
      const xDataDomain = this.xDataDomain;
      if (xDataDomain !== null) {
        let xDataDomainPaddedMin = xDataDomain[0];
        let xDataDomainPaddedMax = xDataDomain[1];
        const xDomainPadding = this.xDomainPadding.value;
        if (typeof xDomainPadding[0] !== "boolean") {
          xDataDomainPaddedMin = +xDataDomainPaddedMin - +xDomainPadding[0];
        }
        if (typeof xDomainPadding[1] !== "boolean") {
          xDataDomainPaddedMax = +xDataDomainPaddedMax + +xDomainPadding[1];
        }
        xDataDomainPadded = util.Domain(xDataDomainPaddedMin, xDataDomainPaddedMax);
      } else {
        xDataDomainPadded = null;
      }
      this.setXDataDomainPadded(xDataDomainPadded);
    }
    setYDataDomainPadded(yDataDomainPadded) {
      this.yDataDomainPadded = yDataDomainPadded;
    }
    updateYDataDomainPadded() {
      let yDataDomainPadded;
      const yDataDomain = this.yDataDomain;
      if (yDataDomain !== null) {
        let yDataDomainPaddedMin = yDataDomain[0];
        let yDataDomainPaddedMax = yDataDomain[1];
        const yDomainPadding = this.yDomainPadding.value;
        if (typeof yDomainPadding[0] !== "boolean") {
          yDataDomainPaddedMin = +yDataDomainPaddedMin - +yDomainPadding[0];
        }
        if (typeof yDomainPadding[1] !== "boolean") {
          yDataDomainPaddedMax = +yDataDomainPaddedMax + +yDomainPadding[1];
        }
        yDataDomainPadded = util.Domain(yDataDomainPaddedMin, yDataDomainPaddedMax);
      } else {
        yDataDomainPadded = null;
      }
      this.setYDataDomainPadded(yDataDomainPadded);
    }
    updateXRangePadding(xScaledRangePadding) {
      if (this.xRangePadding.hasAffinity(component.Affinity.Intrinsic)) {
        let xRangePadding = this.xRangePadding.value;
        if (xRangePadding === null || this.scaled.viewCount === 1) {
          xRangePadding = xScaledRangePadding;
        } else if (xScaledRangePadding !== null) {
          xRangePadding = [ Math.max(xRangePadding[0], xScaledRangePadding[0]), Math.max(xRangePadding[1], xScaledRangePadding[1]) ];
        }
        this.xRangePadding.setValue(xRangePadding, component.Affinity.Intrinsic);
      }
    }
    updateYRangePadding(yScaledRangePadding) {
      if (this.yRangePadding.hasAffinity(component.Affinity.Intrinsic)) {
        let yRangePadding = this.yRangePadding.value;
        if (yRangePadding === null || this.scaled.viewCount === 1) {
          yRangePadding = yScaledRangePadding;
        } else if (yScaledRangePadding !== null) {
          yRangePadding = [ Math.max(yRangePadding[0], yScaledRangePadding[0]), Math.max(yRangePadding[1], yScaledRangePadding[1]) ];
        }
        this.yRangePadding.setValue(yRangePadding, component.Affinity.Intrinsic);
      }
    }
    xFitAlign(xFitAlign) {
      const fitAlign = this.fitAlign.value;
      if (xFitAlign === void 0) {
        return fitAlign[0];
      } else {
        this.fitAlign.setValue([ xFitAlign, fitAlign[1] ]);
        return this;
      }
    }
    yFitAlign(yFitAlign) {
      const fitAlign = this.fitAlign.value;
      if (yFitAlign === void 0) {
        return fitAlign[0];
      } else {
        this.fitAlign.setValue([ fitAlign[0], yFitAlign ]);
        return this;
      }
    }
    preserveAspectRatio(preserveAspectRatio) {
      if (preserveAspectRatio === void 0) {
        return this.gesture.preserveAspectRatio;
      } else {
        this.gesture.preserveAspectRatio = preserveAspectRatio;
        return this;
      }
    }
    domainTracking(xDomainTracking, yDomainTracking) {
      if (xDomainTracking === void 0) {
        return [ (this.scaledFlags & ScaledView.XDomainTrackingFlag) !== 0, (this.scaledFlags & ScaledView.YDomainTrackingFlag) !== 0 ];
      } else {
        if (Array.isArray(xDomainTracking)) {
          yDomainTracking = xDomainTracking[1];
          xDomainTracking = xDomainTracking[0];
        } else if (yDomainTracking === void 0) {
          yDomainTracking = xDomainTracking;
        }
        if (xDomainTracking) {
          this.setScaledFlags(this.scaledFlags | ScaledView.XDomainTrackingFlag);
        } else {
          this.setScaledFlags(this.scaledFlags & ~ScaledView.XDomainTrackingFlag);
        }
        if (yDomainTracking) {
          this.setScaledFlags(this.scaledFlags | ScaledView.YDomainTrackingFlag);
        } else {
          this.setScaledFlags(this.scaledFlags & ~ScaledView.YDomainTrackingFlag);
        }
        return this;
      }
    }
    xDomainTracking(xDomainTracking) {
      if (xDomainTracking === void 0) {
        return (this.scaledFlags & ScaledView.XDomainTrackingFlag) !== 0;
      } else {
        if (xDomainTracking) {
          this.setScaledFlags(this.scaledFlags | ScaledView.XDomainTrackingFlag);
        } else {
          this.setScaledFlags(this.scaledFlags & ~ScaledView.XDomainTrackingFlag);
        }
        return this;
      }
    }
    yDomainTracking(yDomainTracking) {
      if (yDomainTracking === void 0) {
        return (this.scaledFlags & ScaledView.YDomainTrackingFlag) !== 0;
      } else {
        if (yDomainTracking) {
          this.setScaledFlags(this.scaledFlags | ScaledView.YDomainTrackingFlag);
        } else {
          this.setScaledFlags(this.scaledFlags & ~ScaledView.YDomainTrackingFlag);
        }
        return this;
      }
    }
    scaleGestures(xScaleGestures, yScaleGestures) {
      if (xScaleGestures === void 0) {
        return [ (this.scaledFlags & ScaledView.XScaleGesturesFlag) !== 0, (this.scaledFlags & ScaledView.YScaleGesturesFlag) !== 0 ];
      } else {
        if (Array.isArray(xScaleGestures)) {
          yScaleGestures = xScaleGestures[1];
          xScaleGestures = xScaleGestures[0];
        } else if (yScaleGestures === void 0) {
          yScaleGestures = xScaleGestures;
        }
        if (xScaleGestures) {
          this.setScaledFlags(this.scaledFlags | ScaledView.XScaleGesturesFlag);
        } else {
          this.setScaledFlags(this.scaledFlags & ~ScaledView.XScaleGesturesFlag);
        }
        if (yScaleGestures) {
          this.setScaledFlags(this.scaledFlags | ScaledView.YScaleGesturesFlag);
        } else {
          this.setScaledFlags(this.scaledFlags & ~ScaledView.YScaleGesturesFlag);
        }
        return this;
      }
    }
    xScaleGestures(xScaleGestures) {
      if (xScaleGestures === void 0) {
        return (this.scaledFlags & ScaledView.XScaleGesturesFlag) !== 0;
      } else {
        if (xScaleGestures) {
          this.setScaledFlags(this.scaledFlags | ScaledView.XScaleGesturesFlag);
        } else {
          this.setScaledFlags(this.scaledFlags & ~ScaledView.XScaleGesturesFlag);
        }
        return this;
      }
    }
    yScaleGestures(yScaleGestures) {
      if (yScaleGestures === void 0) {
        return (this.scaledFlags & ScaledView.YScaleGesturesFlag) !== 0;
      } else {
        if (yScaleGestures) {
          this.setScaledFlags(this.scaledFlags | ScaledView.YScaleGesturesFlag);
        } else {
          this.setScaledFlags(this.scaledFlags & ~ScaledView.YScaleGesturesFlag);
        }
        return this;
      }
    }
    fitX(tween = false) {
      this.setScaledFlags(this.scaledFlags | ScaledView.XFitFlag);
      if (tween === true) {
        this.setScaledFlags(this.scaledFlags | ScaledView.XFitTweenFlag);
      }
      this.requireUpdate(View.NeedsLayout);
    }
    fitY(tween = false) {
      this.setScaledFlags(this.scaledFlags | ScaledView.YFitFlag);
      if (tween === true) {
        this.setScaledFlags(this.scaledFlags | ScaledView.YFitTweenFlag);
      }
      this.requireUpdate(View.NeedsLayout);
    }
    fit(tween = false) {
      this.setScaledFlags(this.scaledFlags | (ScaledView.XFitFlag | ScaledView.YFitFlag));
      if (tween === true) {
        this.setScaledFlags(this.scaledFlags | ScaledView.FitTweenMask);
      }
      this.requireUpdate(View.NeedsLayout);
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.xScale.recohere(viewContext.updateTime);
      this.yScale.recohere(viewContext.updateTime);
      this.resizeScales();
      this.updateScales();
    }
    resizeScales() {
      let xScale;
      const xRange = this.xRange();
      if (xRange !== null) {
        xScale = !this.xScale.inherited ? this.xScale.state : null;
        if (xScale !== null) {
          if (!xScale.range.equals(xRange)) {
            this.xScale.setRange(xRange);
            this.setScaledFlags(this.scaledFlags | ScaledView.RescaleFlag);
          }
        } else if (this.xScale.superFastener === null || this.xScale.superValue === null) {
          const xDataDomainPadded = this.xDataDomainPadded;
          if (xDataDomainPadded !== null) {
            xScale = ScaledView.createScale(xDataDomainPadded[0], xDataDomainPadded[1], xRange[0], xRange[1]);
            this.xScale.setState(xScale);
            this.setScaledFlags(this.scaledFlags | ScaledView.XFitFlag);
          }
        }
      }
      let yScale;
      const yRange = this.yRange();
      if (yRange !== null) {
        yScale = !this.yScale.inherited ? this.yScale.state : null;
        if (yScale !== null) {
          if (!yScale.range.equals(yRange)) {
            this.yScale.setRange(yRange);
            this.setScaledFlags(this.scaledFlags | ScaledView.RescaleFlag);
          }
        } else if (this.yScale.superFastener === null || this.yScale.superValue === null) {
          const yDataDomainPadded = this.yDataDomainPadded;
          if (yDataDomainPadded !== null) {
            yScale = ScaledView.createScale(yDataDomainPadded[0], yDataDomainPadded[1], yRange[0], yRange[1]);
            this.yScale.setState(yScale);
            this.setScaledFlags(this.scaledFlags | ScaledView.YFitFlag);
          }
        }
      }
    }
    updateScales() {
      const xScale = !this.xScale.inherited ? this.xScale.state : null;
      const yScale = !this.yScale.inherited ? this.yScale.state : null;
      if (xScale !== null && yScale !== null) {
        const isPressing = this.gesture.pressing;
        if (!isPressing) {
          const isCoasting = this.gesture.coasting;
          this.boundScales(xScale, yScale, isCoasting);
        }
      }
    }
    boundScales(oldXScale, oldYScale, isCoasting) {
      const oldXDomain = oldXScale.domain;
      const oldYDomain = oldYScale.domain;
      let newXDomain = oldXDomain;
      let newYDomain = oldYDomain;
      const xDataDomainPadded = this.xDataDomainPadded;
      if (xDataDomainPadded !== null && (this.scaledFlags & ScaledView.XFitFlag) !== 0) {
        newXDomain = xDataDomainPadded;
        this.setScaledFlags(this.scaledFlags | ScaledView.XInRangeMask);
      } else {
        newXDomain = oldXDomain;
      }
      const yDataDomainPadded = this.yDataDomainPadded;
      if (yDataDomainPadded !== null && (this.scaledFlags & ScaledView.YFitFlag) !== 0) {
        newYDomain = yDataDomainPadded;
        this.setScaledFlags(this.scaledFlags | ScaledView.YInRangeMask);
      } else {
        newYDomain = oldYDomain;
      }
      const xDomainPadded = xDataDomainPadded !== null ? xDataDomainPadded : oldXDomain;
      const xDomainBounds = this.xDomainBounds.value;
      const xDomainMin = xDomainBounds[0] === false ? void 0 : xDomainBounds[0] === true ? xDomainPadded[0] : xDomainBounds[0];
      const xDomainMax = xDomainBounds[1] === false ? void 0 : xDomainBounds[1] === true ? xDomainPadded[1] : xDomainBounds[1];
      const xZoomBounds = this.xZoomBounds.value;
      let xZoomMin = xZoomBounds[0];
      let xZoomMax = xZoomBounds[1];
      if (xZoomMin === true) {
        if (oldXScale instanceof util.LinearScale) {
          xZoomMin = ScaledView.LinearZoomMin;
        } else if (oldXScale instanceof time.TimeScale) {
          xZoomMin = ScaledView.TimeZoomMin;
        } else {
          xZoomMin = void 0;
        }
      } else if (xZoomMin === false) {
        xZoomMin = void 0;
      }
      if (xZoomMax === true) {
        if (oldXScale instanceof util.LinearScale) {
          xZoomMax = ScaledView.LinearZoomMax;
        } else if (oldXScale instanceof time.TimeScale) {
          xZoomMax = ScaledView.TimeZoomMax;
        } else {
          xZoomMax = void 0;
        }
      } else if (xZoomMax === false) {
        xZoomMax = void 0;
      }
      newXDomain = oldXScale.clampDomain(xDomainMin, xDomainMax, xZoomMin, xZoomMax).domain;
      const yDomainPadded = yDataDomainPadded !== null ? yDataDomainPadded : oldYDomain;
      const yDomainBounds = this.yDomainBounds.value;
      const yDomainMin = yDomainBounds[0] === false ? void 0 : yDomainBounds[0] === true ? yDomainPadded[0] : yDomainBounds[0];
      const yDomainMax = yDomainBounds[1] === false ? void 0 : yDomainBounds[1] === true ? yDomainPadded[1] : yDomainBounds[1];
      const yZoomBounds = this.yZoomBounds.value;
      let yZoomMin = yZoomBounds[0];
      let yZoomMax = yZoomBounds[1];
      if (yZoomMin === true) {
        if (oldYScale instanceof util.LinearScale) {
          yZoomMin = ScaledView.LinearZoomMin;
        } else if (oldYScale instanceof time.TimeScale) {
          yZoomMin = ScaledView.TimeZoomMin;
        } else {
          yZoomMin = void 0;
        }
      } else if (yZoomMin === false) {
        yZoomMin = void 0;
      }
      if (yZoomMax === true) {
        if (oldYScale instanceof util.LinearScale) {
          yZoomMax = ScaledView.LinearZoomMax;
        } else if (oldYScale instanceof time.TimeScale) {
          yZoomMax = ScaledView.TimeZoomMax;
        } else {
          yZoomMax = void 0;
        }
      } else if (yZoomMax === false) {
        yZoomMax = void 0;
      }
      newYDomain = oldYScale.clampDomain(yDomainMin, yDomainMax, yZoomMin, yZoomMax).domain;
      if (xDataDomainPadded !== null && !isCoasting && (this.scaledFlags & ScaledView.XDomainTrackingFlag) !== 0 && (this.scaledFlags & ScaledView.XInRangeMask) !== 0) {
        if ((this.scaledFlags & ScaledView.XInRangeMask) === ScaledView.XInRangeMask) {
          newXDomain = xDataDomainPadded;
        } else {
          const xDomainWidth = +newXDomain[1] - +newXDomain[0];
          if ((this.scaledFlags & ScaledView.XMinInRangeFlag) !== 0) {
            newXDomain = util.Domain(xDataDomainPadded[0], +xDataDomainPadded[0] + +xDomainWidth);
          } else {
            newXDomain = util.Domain(+xDataDomainPadded[1] - +xDomainWidth, xDataDomainPadded[1]);
          }
        }
      }
      if (yDataDomainPadded !== null && !isCoasting && (this.scaledFlags & ScaledView.YDomainTrackingFlag) !== 0 && (this.scaledFlags & ScaledView.YInRangeMask) !== 0) {
        if ((this.scaledFlags & ScaledView.YInRangeMask) === ScaledView.YInRangeMask) {
          newYDomain = yDataDomainPadded;
        } else {
          const yDomainWidth = +newYDomain[1] - +newYDomain[0];
          if ((this.scaledFlags & ScaledView.YMinInRangeFlag) !== 0) {
            newYDomain = util.Domain(yDataDomainPadded[0], +yDataDomainPadded[0] + +yDomainWidth);
          } else {
            newYDomain = util.Domain(+yDataDomainPadded[1] - +yDomainWidth, yDataDomainPadded[1]);
          }
        }
      }
      const fitAspectRatio = this.fitAspectRatio.value;
      if (fitAspectRatio !== void 0 && (this.gesture.preserveAspectRatio || (this.scaledFlags & ScaledView.FitMask) !== 0)) {
        const xRange = oldXScale.range;
        const yRange = oldYScale.range;
        const oldDomainWidth = +newXDomain[1] - +newXDomain[0];
        const oldDomainHeight = +newYDomain[1] - +newYDomain[0];
        const domainAspectRatio = oldDomainWidth / oldDomainHeight;
        const rangeAspectRatio = (xRange[1] - xRange[0]) / (yRange[0] - yRange[1]);
        const anamorphicAspectRatio = Math.abs(fitAspectRatio * rangeAspectRatio);
        if (!util.Equivalent(domainAspectRatio, anamorphicAspectRatio)) {
          const fitAlign = this.fitAlign.value;
          if (fitAspectRatio < 0 && domainAspectRatio < anamorphicAspectRatio || fitAspectRatio > 0 && domainAspectRatio > anamorphicAspectRatio) {
            const newDomainWidth = oldDomainHeight * anamorphicAspectRatio;
            const dx = newDomainWidth - oldDomainWidth;
            newXDomain = util.Domain(+newXDomain[0] - dx * fitAlign[0], +newXDomain[1] + dx * (1 - fitAlign[0]));
          } else {
            const newDomainHeight = oldDomainWidth / anamorphicAspectRatio;
            const dy = newDomainHeight - oldDomainHeight;
            newYDomain = util.Domain(+newYDomain[0] - dy * fitAlign[1], +newYDomain[1] + dy * (1 - fitAlign[1]));
          }
        }
      }
      if ((this.scaledFlags & ScaledView.XBoundingFlag) === 0 && !util.Equivalent(newXDomain, oldXDomain)) {
        let timing;
        if ((this.scaledFlags & (ScaledView.XFitFlag | ScaledView.RescaleFlag)) === 0 || (this.scaledFlags & ScaledView.XFitTweenFlag) !== 0) {
          timing = (this.scaledFlags & ScaledView.InteractingMask) !== 0 ? this.reboundTransition.value : this.rescaleTransition.value;
          if (timing !== void 0 && timing !== false) {
            this.setScaledFlags(this.scaledFlags | ScaledView.XBoundingFlag);
          }
        }
        this.willReboundX(oldXScale);
        this.xDomain(newXDomain, timing);
        if (timing === void 0 && timing !== false) {
          this.didReboundX(this.xScale.getState());
        }
        if (xDataDomainPadded !== null && (this.scaledFlags & ScaledView.XFitFlag) !== 0) {
          this.setScaledFlags(this.scaledFlags & ~ScaledView.XFitFlag);
        }
      }
      if ((this.scaledFlags & ScaledView.YBoundingFlag) === 0 && !util.Equivalent(newYDomain, oldYDomain)) {
        let timing;
        if ((this.scaledFlags & (ScaledView.YFitFlag | ScaledView.RescaleFlag)) === 0 || (this.scaledFlags & ScaledView.YFitTweenFlag) !== 0) {
          timing = (this.scaledFlags & ScaledView.InteractingMask) !== 0 ? this.reboundTransition.value : this.rescaleTransition.value;
          if (timing !== void 0 && timing !== false) {
            this.setScaledFlags(this.scaledFlags | ScaledView.YBoundingFlag);
          }
        }
        this.willReboundY(oldYScale);
        this.yDomain(newYDomain, timing);
        if (timing === void 0 && timing !== false) {
          this.didReboundY(this.yScale.getState());
        }
        if (yDataDomainPadded !== null && (this.scaledFlags & ScaledView.YFitFlag) !== 0) {
          this.setScaledFlags(this.scaledFlags & ~ScaledView.YFitFlag);
        }
      }
      this.setScaledFlags(this.scaledFlags & ~(ScaledView.InteractedFlag | ScaledView.RescaleFlag));
    }
    displayChildren(displayFlags, viewContext, displayChild) {
      let xScale;
      let yScale;
      if ((displayFlags & View.NeedsLayout) !== 0 && (xScale = this.xScale.value, xScale !== null) && (yScale = this.yScale.value, 
      yScale !== null)) {
        this.layoutChildViews(xScale, yScale, displayFlags, viewContext, displayChild);
      } else {
        super.displayChildren(displayFlags, viewContext, displayChild);
      }
    }
    layoutChildViews(xScale, yScale, displayFlags, viewContext, displayChild) {
      let xDataDomainMin;
      let xDataDomainMax;
      let yDataDomainMin;
      let yDataDomainMax;
      let xRangePaddingMin = 0;
      let xRangePaddingMax = 0;
      let yRangePaddingMin = 0;
      let yRangePaddingMax = 0;
      let xCount = 0;
      let yCount = 0;
      function layoutChildView(childView, displayFlags, viewContext) {
        displayChild.call(this, childView, displayFlags, viewContext);
        if (ScaledXView.is(childView) && childView.xScale.inherited) {
          const childXDataDomain = childView.xDataDomain;
          if (childXDataDomain !== null) {
            if (xCount !== 0) {
              if (util.Values.compare(childXDataDomain[0], xDataDomainMin) < 0) {
                xDataDomainMin = childXDataDomain[0];
              }
              if (util.Values.compare(xDataDomainMax, childXDataDomain[1]) < 0) {
                xDataDomainMax = childXDataDomain[1];
              }
            } else {
              xDataDomainMin = childXDataDomain[0];
              xDataDomainMax = childXDataDomain[1];
            }
            const childXRangePadding = childView.xRangePadding();
            xRangePaddingMin = Math.max(childXRangePadding[0], xRangePaddingMin);
            xRangePaddingMax = Math.max(childXRangePadding[1], xRangePaddingMax);
            xCount += 1;
          }
        }
        if (ScaledYView.is(childView) && childView.yScale.inherited) {
          const childYDataDomain = childView.yDataDomain;
          if (childYDataDomain !== null) {
            if (yCount !== 0) {
              if (util.Values.compare(childYDataDomain[0], yDataDomainMin) < 0) {
                yDataDomainMin = childYDataDomain[0];
              }
              if (util.Values.compare(yDataDomainMax, childYDataDomain[1]) < 0) {
                yDataDomainMax = childYDataDomain[1];
              }
            } else {
              yDataDomainMin = childYDataDomain[0];
              yDataDomainMax = childYDataDomain[1];
            }
            const childYRangePadding = childView.yRangePadding();
            yRangePaddingMin = Math.max(childYRangePadding[0], yRangePaddingMin);
            yRangePaddingMax = Math.max(childYRangePadding[1], yRangePaddingMax);
            yCount += 1;
          }
        }
      }
      super.displayChildren(displayFlags, viewContext, layoutChildView);
      this.setXDataDomain(xCount !== 0 ? util.Domain(xDataDomainMin, xDataDomainMax) : null);
      this.setYDataDomain(yCount !== 0 ? util.Domain(yDataDomainMin, yDataDomainMax) : null);
      this.xRangePadding.setValue([ xRangePaddingMin, xRangePaddingMax ], component.Affinity.Intrinsic);
      this.yRangePadding.setValue([ yRangePaddingMin, yRangePaddingMax ], component.Affinity.Intrinsic);
    }
    onBeginBoundingXScale(xScale) {}
    onEndBoundingXScale(xScale) {
      this.setScaledFlags(this.scaledFlags & ~ScaledView.XBoundingFlag);
      this.didReboundX(xScale);
    }
    onInterruptBoundingXScale(xScale) {
      this.setScaledFlags(this.scaledFlags & ~ScaledView.XBoundingFlag);
      this.didReboundX(xScale);
    }
    onBeginBoundingYScale(yScale) {}
    onEndBoundingYScale(yScale) {
      this.setScaledFlags(this.scaledFlags & ~ScaledView.YBoundingFlag);
      this.didReboundY(yScale);
    }
    onInterruptBoundingYScale(yScale) {
      this.setScaledFlags(this.scaledFlags & ~ScaledView.YBoundingFlag);
      this.didReboundY(yScale);
    }
    willReboundX(xScale) {
      this.gesture.neutralizeX();
    }
    didReboundX(xScale) {}
    willReboundY(yScale) {
      this.gesture.neutralizeY();
    }
    didReboundY(yScale) {}
    init(init) {
      super.init(init);
      if (init.xScale !== void 0) {
        this.xScale(init.xScale);
      }
      if (init.yScale !== void 0) {
        this.yScale(init.yScale);
      }
      if (init.xDomainBounds !== void 0) {
        this.xDomainBounds(init.xDomainBounds);
      }
      if (init.yDomainBounds !== void 0) {
        this.yDomainBounds(init.yDomainBounds);
      }
      if (init.xZoomBounds !== void 0) {
        this.xZoomBounds(init.xZoomBounds);
      }
      if (init.yZoomBounds !== void 0) {
        this.yZoomBounds(init.yZoomBounds);
      }
      if (init.xDomainPadding !== void 0) {
        this.xDomainPadding(init.xDomainPadding);
      }
      if (init.yDomainPadding !== void 0) {
        this.yDomainPadding(init.yDomainPadding);
      }
      if (init.xRangePadding !== void 0) {
        this.xRangePadding(init.xRangePadding);
      }
      if (init.yRangePadding !== void 0) {
        this.yRangePadding(init.yRangePadding);
      }
      if (init.fitAlign !== void 0) {
        this.fitAlign(init.fitAlign);
      }
      if (init.xFitAlign !== void 0) {
        this.xFitAlign(init.xFitAlign);
      }
      if (init.yFitAlign !== void 0) {
        this.yFitAlign(init.yFitAlign);
      }
      if (init.fitAspectRatio !== void 0) {
        this.fitAspectRatio(init.fitAspectRatio);
      }
      if (init.preserveAspectRatio !== void 0) {
        this.preserveAspectRatio(init.preserveAspectRatio);
      }
      if (init.domainTracking !== void 0) {
        this.domainTracking(init.domainTracking);
      }
      if (init.xDomainTracking !== void 0) {
        this.xDomainTracking(init.xDomainTracking);
      }
      if (init.yDomainTracking !== void 0) {
        this.yDomainTracking(init.yDomainTracking);
      }
      if (init.scaleGestures !== void 0) {
        this.scaleGestures(init.scaleGestures);
      }
      if (init.xScaleGestures !== void 0) {
        this.xScaleGestures(init.xScaleGestures);
      }
      if (init.yScaleGestures !== void 0) {
        this.yScaleGestures(init.yScaleGestures);
      }
      if (init.rescaleTransition !== void 0) {
        this.rescaleTransition.setValue(init.rescaleTransition);
      }
      if (init.reboundTransition !== void 0) {
        this.reboundTransition.setValue(init.reboundTransition);
      }
    }
    static createScale(x0, x1, y0, y1) {
      let range;
      if (typeof y0 === "number" && typeof y1 === "number") {
        range = util.LinearRange(y0, y1);
      } else {
        range = util.LinearRange(0, 1);
      }
      if (typeof x0 === "number" && typeof x1 === "number") {
        return util.LinearScale(util.LinearDomain(x0, x1), range);
      } else if (x0 instanceof time.DateTime && x1 instanceof time.DateTime) {
        return time.TimeScale(time.TimeDomain(x0, x1), range);
      } else {
        throw new TypeError(x0 + ", " + x1 + ", " + y0 + ", " + y1);
      }
    }
    static parseScale(string) {
      if (string === "linear") {
        return util.LinearScale(util.LinearDomain(0, 1), util.LinearRange(0, 1));
      } else if (string === "time") {
        const d1 = time.DateTime.current();
        const d0 = d1.withDay(d1.day - 1);
        return time.TimeScale(time.TimeDomain(d0, d1), util.LinearRange(0, 1));
      } else {
        const domain = string.split("...");
        const x0 = +domain[0];
        const x1 = +domain[1];
        if (isFinite(x0) && isFinite(x1)) {
          return util.LinearScale(util.LinearDomain(x0, x1), util.LinearRange(0, 1));
        } else {
          const d0 = time.DateTime.parse(domain[0]);
          const d1 = time.DateTime.parse(domain[1]);
          return time.TimeScale(time.TimeDomain(d0, d1), util.LinearRange(0, 1));
        }
      }
    }
  }
  ScaledView.XDomainTrackingFlag = 1 << 0;
  ScaledView.YDomainTrackingFlag = 1 << 1;
  ScaledView.XScaleGesturesFlag = 1 << 2;
  ScaledView.YScaleGesturesFlag = 1 << 3;
  ScaledView.XMinInRangeFlag = 1 << 4;
  ScaledView.XMaxInRangeFlag = 1 << 5;
  ScaledView.YMinInRangeFlag = 1 << 6;
  ScaledView.YMaxInRangeFlag = 1 << 7;
  ScaledView.InteractingFlag = 1 << 8;
  ScaledView.InteractedFlag = 1 << 9;
  ScaledView.XBoundingFlag = 1 << 10;
  ScaledView.YBoundingFlag = 1 << 11;
  ScaledView.XFitFlag = 1 << 12;
  ScaledView.YFitFlag = 1 << 13;
  ScaledView.XFitTweenFlag = 1 << 14;
  ScaledView.YFitTweenFlag = 1 << 15;
  ScaledView.RescaleFlag = 1 << 16;
  ScaledView.DomainTrackingMask = ScaledView.XDomainTrackingFlag | ScaledView.YDomainTrackingFlag;
  ScaledView.ScaleGesturesMask = ScaledView.XScaleGesturesFlag | ScaledView.YScaleGesturesFlag;
  ScaledView.XInRangeMask = ScaledView.XMinInRangeFlag | ScaledView.XMaxInRangeFlag;
  ScaledView.YInRangeMask = ScaledView.YMinInRangeFlag | ScaledView.YMaxInRangeFlag;
  ScaledView.InteractingMask = ScaledView.InteractingFlag | ScaledView.InteractedFlag;
  ScaledView.BoundingMask = ScaledView.XBoundingFlag | ScaledView.YBoundingFlag;
  ScaledView.FitMask = ScaledView.XFitFlag | ScaledView.YFitFlag;
  ScaledView.FitTweenMask = ScaledView.XFitTweenFlag | ScaledView.YFitTweenFlag;
  ScaledView.LinearZoomMin = 1e6;
  ScaledView.LinearZoomMax = .001;
  ScaledView.TimeZoomMin = 864e5;
  ScaledView.TimeZoomMax = 1;
  ScaledView.InsertChildFlags = GraphicsView.InsertChildFlags | View.NeedsResize;
  __decorate([ component.Animator({
    extends: ContinuousScaleAnimator,
    type: util.ContinuousScale,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout,
    willSetValue(newXScale, oldXScale) {
      this.owner.callObservers("viewWillSetXScale", newXScale, oldXScale, this.owner);
    },
    didSetValue(newXScale, oldXScale) {
      this.owner.updateXDataRange();
      this.owner.callObservers("viewDidSetXScale", newXScale, oldXScale, this.owner);
    },
    willTransition(xScale) {
      if ((this.owner.scaledFlags & ScaledView.XBoundingFlag) !== 0) {
        this.owner.onBeginBoundingXScale(xScale);
      }
    },
    didTransition(xScale) {
      if ((this.owner.scaledFlags & ScaledView.XBoundingFlag) !== 0) {
        this.owner.onEndBoundingXScale(xScale);
      }
    },
    didInterrupt(xScale) {
      if ((this.owner.scaledFlags & ScaledView.XBoundingFlag) !== 0) {
        this.owner.onInterruptBoundingXScale(xScale);
      }
    }
  }) ], ScaledView.prototype, "xScale", void 0);
  __decorate([ component.Animator({
    extends: ContinuousScaleAnimator,
    type: util.ContinuousScale,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout,
    willSetValue(newYScale, oldYScale) {
      this.owner.callObservers("viewWillSetYScale", newYScale, oldYScale, this.owner);
    },
    didSetValue(newYScale, oldYScale) {
      this.owner.updateYDataRange();
      this.owner.callObservers("viewDidSetYScale", newYScale, oldYScale, this.owner);
    },
    willTransition(yScale) {
      if ((this.owner.scaledFlags & ScaledView.YBoundingFlag) !== 0) {
        this.owner.onBeginBoundingYScale(yScale);
      }
    },
    didTransition(yScale) {
      if ((this.owner.scaledFlags & ScaledView.YBoundingFlag) !== 0) {
        this.owner.onEndBoundingYScale(yScale);
      }
    },
    didInterrupt(yScale) {
      if ((this.owner.scaledFlags & ScaledView.YBoundingFlag) !== 0) {
        this.owner.onInterruptBoundingYScale(yScale);
      }
    }
  }) ], ScaledView.prototype, "yScale", void 0);
  __decorate([ component.Property({
    updateFlags: View.NeedsLayout,
    initValue() {
      return [ true, true ];
    },
    equalValues(newXDomainBounds, oldXDomainBounds) {
      return util.Arrays.equal(newXDomainBounds, oldXDomainBounds);
    }
  }) ], ScaledView.prototype, "xDomainBounds", void 0);
  __decorate([ component.Property({
    updateFlags: View.NeedsLayout,
    initValue() {
      return [ true, true ];
    },
    equalValues(newYDomainBounds, oldYDomainBounds) {
      return util.Arrays.equal(newYDomainBounds, oldYDomainBounds);
    }
  }) ], ScaledView.prototype, "yDomainBounds", void 0);
  __decorate([ component.Property({
    updateFlags: View.NeedsLayout,
    initValue() {
      return [ true, true ];
    },
    equalValues(newXZoomBounds, oldXZoomBounds) {
      return util.Arrays.equal(newXZoomBounds, oldXZoomBounds);
    }
  }) ], ScaledView.prototype, "xZoomBounds", void 0);
  __decorate([ component.Property({
    updateFlags: View.NeedsLayout,
    initValue() {
      return [ true, true ];
    },
    equalValues(newYDomainBounds, oldYDomainBounds) {
      return util.Arrays.equal(newYDomainBounds, oldYDomainBounds);
    }
  }) ], ScaledView.prototype, "yZoomBounds", void 0);
  __decorate([ component.Property({
    updateFlags: View.NeedsLayout,
    initValue() {
      return [ false, false ];
    },
    equalValues(newXDomainPadding, oldXDomainPadding) {
      return util.Arrays.equal(newXDomainPadding, oldXDomainPadding);
    }
  }) ], ScaledView.prototype, "xDomainPadding", void 0);
  __decorate([ component.Property({
    updateFlags: View.NeedsLayout,
    initValue() {
      return [ false, false ];
    },
    equalValues(newYDomainPadding, oldYDomainPadding) {
      return util.Arrays.equal(newYDomainPadding, oldYDomainPadding);
    }
  }) ], ScaledView.prototype, "yDomainPadding", void 0);
  __decorate([ component.Property({
    updateFlags: View.NeedsLayout,
    initValue() {
      return [ 0, 0 ];
    },
    willSetValue(newXRangePadding, oldXRangePadding) {
      this.owner.callObservers("viewWillSetXRangePadding", newXRangePadding, oldXRangePadding, this.owner);
    },
    didSetValue(newXRangePadding, oldXRangePadding) {
      this.owner.callObservers("viewDidSetXRangePadding", newXRangePadding, oldXRangePadding, this.owner);
    },
    equalValues(newXRangePadding, oldXRangePadding) {
      return util.Arrays.equal(newXRangePadding, oldXRangePadding);
    }
  }) ], ScaledView.prototype, "xRangePadding", void 0);
  __decorate([ component.Property({
    updateFlags: View.NeedsLayout,
    initValue() {
      return [ 0, 0 ];
    },
    willSetValue(newYRangePadding, oldYRangePadding) {
      this.owner.callObservers("viewWillSetYRangePadding", newYRangePadding, oldYRangePadding, this.owner);
    },
    didSetValue(newYRangePadding, oldYRangePadding) {
      this.owner.callObservers("viewDidSetYRangePadding", newYRangePadding, oldYRangePadding, this.owner);
    },
    equalValues(newYRangePadding, oldYRangePadding) {
      return util.Arrays.equal(newYRangePadding, oldYRangePadding);
    }
  }) ], ScaledView.prototype, "yRangePadding", void 0);
  __decorate([ component.Property({
    type: Object,
    initValue() {
      return [ 1, .5 ];
    },
    equalValues(newFitAlign, oldFitAlign) {
      return util.Arrays.equal(newFitAlign, oldFitAlign);
    },
    fromAny(value) {
      if (typeof value === "number") {
        return [ value, value ];
      } else {
        return value;
      }
    }
  }) ], ScaledView.prototype, "fitAlign", void 0);
  __decorate([ component.Property({
    type: Number
  }) ], ScaledView.prototype, "fitAspectRatio", void 0);
  __decorate([ component.Property({
    type: util.Timing,
    inherits: true,
    initValue() {
      return util.Easing.linear.withDuration(250);
    }
  }) ], ScaledView.prototype, "rescaleTransition", void 0);
  __decorate([ component.Property({
    type: util.Timing,
    inherits: true,
    initValue() {
      return util.Easing.cubicOut.withDuration(250);
    }
  }) ], ScaledView.prototype, "reboundTransition", void 0);
  __decorate([ ViewSet({
    binds: true,
    observes: true,
    willAttachView(scaledView, targetView) {
      this.owner.callObservers("viewWillAttachScaled", scaledView, targetView, this.owner);
    },
    didAttachView(newScaledView) {
      if (ScaledXView.is(newScaledView)) {
        this.owner.updateXDataDomain(newScaledView.xDataDomain);
      }
      if (ScaledYView.is(newScaledView)) {
        this.owner.updateYDataDomain(newScaledView.yDataDomain);
      }
    },
    didDetachView(scaledView) {
      this.owner.callObservers("viewDidDetachScaled", scaledView, this.owner);
    },
    viewDidSetXRangePadding(newXRangePadding, oldXRangePadding) {
      this.owner.updateXRangePadding(newXRangePadding);
    },
    viewDidSetYRangePadding(newYRangePadding, oldYRangePadding) {
      this.owner.updateYRangePadding(newYRangePadding);
    },
    viewDidSetXDataDomain(newXDataDomain, oldXDataDomain) {
      this.owner.updateXDataDomain(newXDataDomain);
      this.owner.requireUpdate(View.NeedsLayout);
    },
    viewDidSetYDataDomain(newYDataDomain, oldYDataDomain) {
      this.owner.updateYDataDomain(newYDataDomain);
      this.owner.requireUpdate(View.NeedsLayout);
    },
    detectView(view) {
      return ScaledXView.is(view) || ScaledYView.is(view) ? view : null;
    }
  }) ], ScaledView.prototype, "scaled", void 0);
  __decorate([ ScaleGesture({
    self: true,
    getXScale() {
      if ((this.owner.scaledFlags & ScaledView.XScaleGesturesFlag) !== 0) {
        return this.owner.xScale();
      } else {
        return null;
      }
    },
    setXScale(xScale, timing) {
      if ((this.owner.scaledFlags & ScaledView.XScaleGesturesFlag) !== 0) {
        this.owner.xScale(xScale, timing);
      }
    },
    getYScale() {
      if ((this.owner.scaledFlags & ScaledView.YScaleGesturesFlag) !== 0) {
        return this.owner.yScale();
      } else {
        return null;
      }
    },
    setYScale(yScale, timing) {
      if ((this.owner.scaledFlags & ScaledView.YScaleGesturesFlag) !== 0) {
        this.owner.yScale(yScale, timing);
      }
    },
    willStartInteracting() {
      this.owner.setScaledFlags(this.owner.scaledFlags & ~ScaledView.BoundingMask | ScaledView.InteractingFlag);
    },
    didStopInteracting() {
      const xScale = this.owner.xScale.value;
      const xDataDomain = this.owner.xDataDomain;
      if (xScale !== null && xDataDomain !== null) {
        const xDomain = xScale.domain;
        if (xDomain.contains(xDataDomain[0])) {
          this.owner.setScaledFlags(this.owner.scaledFlags | ScaledView.XMinInRangeFlag);
        } else {
          this.owner.setScaledFlags(this.owner.scaledFlags & ~ScaledView.XMinInRangeFlag);
        }
        if (xDomain.contains(xDataDomain[1])) {
          this.owner.setScaledFlags(this.owner.scaledFlags | ScaledView.XMaxInRangeFlag);
        } else {
          this.owner.setScaledFlags(this.owner.scaledFlags & ~ScaledView.XMaxInRangeFlag);
        }
      }
      const yScale = this.owner.yScale.value;
      const yDataDomain = this.owner.yDataDomain;
      if (yScale !== null && yDataDomain !== null) {
        const yDomain = yScale.domain;
        if (yDomain.contains(yDataDomain[0])) {
          this.owner.setScaledFlags(this.owner.scaledFlags | ScaledView.YMinInRangeFlag);
        } else {
          this.owner.setScaledFlags(this.owner.scaledFlags & ~ScaledView.YMinInRangeFlag);
        }
        if (yDomain.contains(yDataDomain[1])) {
          this.owner.setScaledFlags(this.owner.scaledFlags | ScaledView.YMaxInRangeFlag);
        } else {
          this.owner.setScaledFlags(this.owner.scaledFlags & ~ScaledView.YMaxInRangeFlag);
        }
      }
      this.owner.setScaledFlags(this.owner.scaledFlags & ~ScaledView.InteractingFlag | ScaledView.InteractedFlag);
    },
    didStopPressing() {
      this.owner.requireUpdate(View.NeedsLayout);
    },
    willBeginCoast(input, event) {
      if ((this.owner.scaledFlags & ScaledView.XScaleGesturesFlag) === 0) {
        input.disableX = true;
        input.vx = 0;
        input.ax = 0;
      }
      if ((this.owner.scaledFlags & ScaledView.YScaleGesturesFlag) === 0) {
        input.disableY = true;
        input.vy = 0;
        input.ay = 0;
      }
    }
  }) ], ScaledView.prototype, "gesture", void 0);
  class ScatterPlotView extends GraphicsView {
    constructor() {
      super();
      this.xDataDomain = null;
      this.yDataDomain = null;
      this.xDataRange = null;
      this.yDataRange = null;
    }
    xDomain(xMin, xMax, timing) {
      if (arguments.length === 0) {
        const xScale = this.xScale.value;
        return xScale !== null ? xScale.domain : null;
      } else {
        this.xScale.setDomain(xMin, xMax, timing);
        return this;
      }
    }
    yDomain(yMin, yMax, timing) {
      if (arguments.length === 0) {
        const yScale = this.yScale.value;
        return yScale !== null ? yScale.domain : null;
      } else {
        this.yScale.setDomain(yMin, yMax, timing);
        return this;
      }
    }
    xRange() {
      const xScale = this.xScale.value;
      return xScale !== null ? xScale.range : null;
    }
    yRange() {
      const yScale = this.yScale.value;
      return yScale !== null ? yScale.range : null;
    }
    setXDataDomain(newXDataDomain) {
      const oldXDataDomain = this.xDataDomain;
      if (!util.Equals(newXDataDomain, oldXDataDomain)) {
        this.willSetXDataDomain(newXDataDomain, oldXDataDomain);
        this.xDataDomain = newXDataDomain;
        this.onSetXDataDomain(newXDataDomain, oldXDataDomain);
        this.didSetXDataDomain(newXDataDomain, oldXDataDomain);
      }
    }
    willSetXDataDomain(newXDataDomain, oldXDataDomain) {
      this.callObservers("viewWillSetXDataDomain", newXDataDomain, oldXDataDomain, this);
    }
    onSetXDataDomain(newXDataDomain, oldXDataDomain) {
      this.updateXDataRange();
      this.requireUpdate(View.NeedsLayout);
    }
    didSetXDataDomain(newXDataDomain, oldXDataDomain) {
      this.callObservers("viewDidSetXDataDomain", newXDataDomain, oldXDataDomain, this);
    }
    updateXDataDomain(dataPointView) {
      const x = dataPointView.x.getValue();
      let xDataDomain = this.xDataDomain;
      if (xDataDomain === null) {
        xDataDomain = util.Domain(x, x);
      } else {
        if (util.Values.compare(x, xDataDomain[0]) < 0) {
          xDataDomain = util.Domain(x, xDataDomain[1]);
        } else if (util.Values.compare(xDataDomain[1], x) < 0) {
          xDataDomain = util.Domain(xDataDomain[0], x);
        }
      }
      this.setXDataDomain(xDataDomain);
    }
    setYDataDomain(newYDataDomain) {
      const oldYDataDomain = this.yDataDomain;
      if (!util.Equals(newYDataDomain, oldYDataDomain)) {
        this.willSetYDataDomain(newYDataDomain, oldYDataDomain);
        this.yDataDomain = newYDataDomain;
        this.onSetYDataDomain(newYDataDomain, oldYDataDomain);
        this.didSetYDataDomain(newYDataDomain, oldYDataDomain);
      }
    }
    willSetYDataDomain(newYDataDomain, oldYDataDomain) {
      this.callObservers("viewWillSetYDataDomain", newYDataDomain, oldYDataDomain, this);
    }
    onSetYDataDomain(newYDataDomain, oldYDataDomain) {
      this.updateYDataRange();
      this.requireUpdate(View.NeedsLayout);
    }
    didSetYDataDomain(newYDataDomain, oldYDataDomain) {
      this.callObservers("viewDidSetYDataDomain", newYDataDomain, oldYDataDomain, this);
    }
    updateYDataDomain(dataPointView) {
      const y = dataPointView.y.value;
      const y2 = dataPointView.y2.value;
      let yDataDomain = this.yDataDomain;
      if (yDataDomain === null) {
        yDataDomain = util.Domain(y, y);
      } else {
        if (util.Values.compare(y, yDataDomain[0]) < 0) {
          yDataDomain = util.Domain(y, yDataDomain[1]);
        } else if (util.Values.compare(yDataDomain[1], y) < 0) {
          yDataDomain = util.Domain(yDataDomain[0], y);
        }
        if (y2 !== void 0) {
          if (util.Values.compare(y2, yDataDomain[0]) < 0) {
            yDataDomain = util.Domain(y2, yDataDomain[1]);
          } else if (util.Values.compare(yDataDomain[1], y2) < 0) {
            yDataDomain = util.Domain(yDataDomain[0], y2);
          }
        }
      }
      this.setYDataDomain(yDataDomain);
    }
    setXDataRange(xDataRange) {
      this.xDataRange = xDataRange;
    }
    updateXDataRange() {
      const xDataDomain = this.xDataDomain;
      if (xDataDomain !== null) {
        const xScale = this.xScale.value;
        if (xScale !== null) {
          this.setXDataRange(util.LinearRange(xScale(xDataDomain[0]), xScale(xDataDomain[1])));
        } else {
          this.setXDataRange(null);
        }
      }
    }
    setYDataRange(yDataRange) {
      this.yDataRange = yDataRange;
    }
    updateYDataRange() {
      const yDataDomain = this.yDataDomain;
      if (yDataDomain !== null) {
        const yScale = this.yScale.value;
        if (yScale !== null) {
          this.setYDataRange(util.LinearRange(yScale(yDataDomain[0]), yScale(yDataDomain[1])));
        } else {
          this.setYDataRange(null);
        }
      }
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.xScale.recohere(viewContext.updateTime);
      this.yScale.recohere(viewContext.updateTime);
      this.resizeScales(this.viewFrame);
    }
    resizeScales(frame) {
      const xScale = !this.xScale.inherited ? this.xScale.value : null;
      if (xScale !== null && xScale.range[1] !== frame.width) {
        this.xScale.setRange(0, frame.width);
      }
      const yScale = !this.yScale.inherited ? this.yScale.value : null;
      if (yScale !== null && yScale.range[1] !== frame.height) {
        this.yScale.setRange(0, frame.height);
      }
    }
    displayChildren(displayFlags, viewContext, displayChild) {
      let xScale;
      let yScale;
      if ((displayFlags & View.NeedsLayout) !== 0 && (xScale = this.xScale.value, xScale !== null) && (yScale = this.yScale.value, 
      yScale !== null)) {
        this.layoutChildViews(xScale, yScale, displayFlags, viewContext, displayChild);
      } else {
        super.displayChildren(displayFlags, viewContext, displayChild);
      }
    }
    layoutChildViews(xScale, yScale, displayFlags, viewContext, displayChild) {
      const frame = this.viewFrame;
      const size = Math.min(frame.width, frame.height);
      let xDataDomainMin;
      let xDataDomainMax;
      let yDataDomainMin;
      let yDataDomainMax;
      let xRangePaddingMin = 0;
      let xRangePaddingMax = 0;
      let yRangePaddingMin = 0;
      let yRangePaddingMax = 0;
      let point0 = null;
      function layoutChildView(point1, displayFlags, viewContext) {
        if (point1 instanceof DataPointView) {
          const x1 = point1.x.getValue();
          const y1 = point1.y.getValue();
          const dy1 = point1.y2.value;
          const r1 = point1.radius.value;
          const sx1 = xScale(x1);
          const sy1 = yScale(y1);
          point1.setXCoord(frame.xMin + sx1);
          point1.setYCoord(frame.yMin + sy1);
          if (point0 !== null) {
            if (util.Values.compare(x1, xDataDomainMin) < 0) {
              xDataDomainMin = x1;
            } else if (util.Values.compare(xDataDomainMax, x1) < 0) {
              xDataDomainMax = x1;
            }
            if (util.Values.compare(y1, yDataDomainMin) < 0) {
              yDataDomainMin = y1;
            } else if (util.Values.compare(yDataDomainMax, y1) < 0) {
              yDataDomainMax = y1;
            }
            if (dy1 !== void 0) {
              if (util.Values.compare(dy1, yDataDomainMin) < 0) {
                yDataDomainMin = dy1;
              } else if (util.Values.compare(yDataDomainMax, dy1) < 0) {
                yDataDomainMax = dy1;
              }
            }
          } else {
            xDataDomainMin = x1;
            xDataDomainMax = x1;
            yDataDomainMin = y1;
            yDataDomainMax = y1;
          }
          if (r1 !== null) {
            const radius = r1.pxValue(size);
            xRangePaddingMin = Math.max(radius, xRangePaddingMin);
            xRangePaddingMax = Math.max(radius, xRangePaddingMax);
            yRangePaddingMin = Math.max(radius, yRangePaddingMin);
            yRangePaddingMax = Math.max(radius, yRangePaddingMax);
          }
          point0 = point1;
        }
        displayChild.call(this, point1, displayFlags, viewContext);
      }
      super.displayChildren(displayFlags, viewContext, layoutChildView);
      this.setXDataDomain(point0 !== null ? util.Domain(xDataDomainMin, xDataDomainMax) : null);
      this.setYDataDomain(point0 !== null ? util.Domain(yDataDomainMin, yDataDomainMax) : null);
      this.xRangePadding.setValue([ xRangePaddingMin, xRangePaddingMax ], component.Affinity.Intrinsic);
      this.yRangePadding.setValue([ yRangePaddingMin, yRangePaddingMax ], component.Affinity.Intrinsic);
    }
    didRender(viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer && !this.hidden && !this.culled) {
        this.renderPlot(renderer.context, this.viewFrame);
      }
      super.didRender(viewContext);
    }
    init(init) {
      super.init(init);
      if (init.xScale !== void 0) {
        this.xScale(init.xScale);
      }
      if (init.yScale !== void 0) {
        this.yScale(init.yScale);
      }
      const data = init.data;
      if (data !== void 0) {
        for (let i = 0, n = data.length; i < n; i += 1) {
          this.appendChild(DataPointView.fromAny(data[i]));
        }
      }
      if (init.font !== void 0) {
        this.font(init.font);
      }
      if (init.textColor !== void 0) {
        this.textColor(init.textColor);
      }
    }
  }
  __decorate([ ThemeAnimator({
    type: Font,
    value: null,
    inherits: true
  }) ], ScatterPlotView.prototype, "font", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    inherits: true
  }) ], ScatterPlotView.prototype, "textColor", void 0);
  __decorate([ component.Animator({
    extends: ContinuousScaleAnimator,
    type: util.ContinuousScale,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout,
    willSetValue(newXScale, oldXScale) {
      this.owner.callObservers("viewWillSetXScale", newXScale, oldXScale, this.owner);
    },
    didSetValue(newXScale, oldXScale) {
      this.owner.updateXDataRange();
      this.owner.callObservers("viewDidSetXScale", newXScale, oldXScale, this.owner);
    }
  }) ], ScatterPlotView.prototype, "xScale", void 0);
  __decorate([ component.Animator({
    extends: ContinuousScaleAnimator,
    type: util.ContinuousScale,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout,
    willSetValue(newYScale, oldYScale) {
      this.owner.callObservers("viewWillSetYScale", newYScale, oldYScale, this.owner);
    },
    didSetValue(newYScale, oldYScale) {
      this.owner.updateYDataRange();
      this.owner.callObservers("viewDidSetYScale", newYScale, oldYScale, this.owner);
    }
  }) ], ScatterPlotView.prototype, "yScale", void 0);
  __decorate([ component.Property({
    initValue() {
      return [ 0, 0 ];
    },
    willSetValue(newXRangePadding, oldXRangePadding) {
      this.owner.callObservers("viewWillSetXRangePadding", newXRangePadding, oldXRangePadding, this.owner);
    },
    didSetValue(newXRangePadding, oldXRangePadding) {
      this.owner.callObservers("viewDidSetXRangePadding", newXRangePadding, oldXRangePadding, this.owner);
    }
  }) ], ScatterPlotView.prototype, "xRangePadding", void 0);
  __decorate([ component.Property({
    initValue() {
      return [ 0, 0 ];
    },
    willSetValue(newYRangePadding, oldYRangePadding) {
      this.owner.callObservers("viewWillSetYRangePadding", newYRangePadding, oldYRangePadding, this.owner);
    },
    didSetValue(newYRangePadding, oldYRangePadding) {
      this.owner.callObservers("viewDidSetYRangePadding", newYRangePadding, oldYRangePadding, this.owner);
    }
  }) ], ScatterPlotView.prototype, "yRangePadding", void 0);
  __decorate([ ViewSet({
    implements: true,
    type: DataPointView,
    binds: true,
    observes: true,
    willAttachView(newDataPointView, targetView) {
      this.owner.callObservers("viewWillAttachDataPoint", newDataPointView, targetView, this.owner);
    },
    didAttachView(dataPointView) {
      this.owner.updateXDataDomain(dataPointView);
      this.owner.updateYDataDomain(dataPointView);
      const labelView = dataPointView.label.view;
      if (labelView !== null) {
        this.attachDataPointLabelView(labelView);
      }
    },
    willDetachView(dataPointView) {
      const labelView = dataPointView.label.view;
      if (labelView !== null) {
        this.detachDataPointLabelView(labelView);
      }
    },
    didDetachView(newDataPointView) {
      this.owner.callObservers("viewDidDetachDataPoint", newDataPointView, this.owner);
    },
    viewDidSetDataPointX(newX, oldX, dataPointView) {
      this.owner.updateXDataDomain(dataPointView);
      this.owner.requireUpdate(View.NeedsLayout);
    },
    viewDidSetDataPointY(newY, oldY, dataPointView) {
      this.owner.updateYDataDomain(dataPointView);
      this.owner.requireUpdate(View.NeedsLayout);
    },
    viewDidSetDataPointY2(newY2, oldY2, dataPointView) {
      this.owner.updateYDataDomain(dataPointView);
      this.owner.requireUpdate(View.NeedsLayout);
    },
    viewWillAttachDataPointLabel(labelView) {
      this.attachDataPointLabelView(labelView);
    },
    viewDidDetachDataPointLabel(labelView) {
      this.detachDataPointLabelView(labelView);
    },
    attachDataPointLabelView(labelView) {
      this.owner.requireUpdate(View.NeedsLayout);
    },
    detachDataPointLabelView(labelView) {}
  }) ], ScatterPlotView.prototype, "dataPoints", void 0);
  class SeriesPlotView extends GraphicsView {
    constructor() {
      super();
      this.xDataDomain = null;
      this.yDataDomain = null;
      this.xDataRange = null;
      this.yDataRange = null;
      this.gradientStops = 0;
      this.dataPointViews = new collections.BTree;
    }
    xDomain(xMin, xMax, timing) {
      if (arguments.length === 0) {
        const xScale = this.xScale.value;
        return xScale !== null ? xScale.domain : null;
      } else {
        this.xScale.setDomain(xMin, xMax, timing);
        return this;
      }
    }
    yDomain(yMin, yMax, timing) {
      if (arguments.length === 0) {
        const yScale = this.yScale.value;
        return yScale !== null ? yScale.domain : null;
      } else {
        this.yScale.setDomain(yMin, yMax, timing);
        return this;
      }
    }
    xRange() {
      const xScale = this.xScale.value;
      return xScale !== null ? xScale.range : null;
    }
    yRange() {
      const yScale = this.yScale.value;
      return yScale !== null ? yScale.range : null;
    }
    setXDataDomain(newXDataDomain) {
      const oldXDataDomain = this.xDataDomain;
      if (!util.Equals(newXDataDomain, oldXDataDomain)) {
        this.willSetXDataDomain(newXDataDomain, oldXDataDomain);
        this.xDataDomain = newXDataDomain;
        this.onSetXDataDomain(newXDataDomain, oldXDataDomain);
        this.didSetXDataDomain(newXDataDomain, oldXDataDomain);
      }
    }
    willSetXDataDomain(newXDataDomain, oldXDataDomain) {
      this.callObservers("viewWillSetXDataDomain", newXDataDomain, oldXDataDomain, this);
    }
    onSetXDataDomain(newXDataDomain, oldXDataDomain) {
      this.updateXDataRange();
      this.requireUpdate(View.NeedsLayout);
    }
    didSetXDataDomain(newXDataDomain, oldXDataDomain) {
      this.callObservers("viewDidSetXDataDomain", newXDataDomain, oldXDataDomain, this);
    }
    updateXDataDomain(dataPointView) {
      const dataPointViews = this.dataPointViews;
      const xMin = dataPointViews.firstKey();
      const xMax = dataPointViews.lastKey();
      let xDataDomain;
      if (xMin !== void 0 && xMax !== void 0) {
        xDataDomain = util.Domain(xMin, xMax);
      } else {
        const x = dataPointView.x.getValue();
        xDataDomain = util.Domain(x, x);
      }
      this.setXDataDomain(xDataDomain);
    }
    setYDataDomain(newYDataDomain) {
      const oldYDataDomain = this.yDataDomain;
      if (!util.Equals(newYDataDomain, oldYDataDomain)) {
        this.willSetYDataDomain(newYDataDomain, oldYDataDomain);
        this.yDataDomain = newYDataDomain;
        this.onSetYDataDomain(newYDataDomain, oldYDataDomain);
        this.didSetYDataDomain(newYDataDomain, oldYDataDomain);
      }
    }
    willSetYDataDomain(newYDataDomain, oldYDataDomain) {
      this.callObservers("viewWillSetYDataDomain", newYDataDomain, oldYDataDomain, this);
    }
    onSetYDataDomain(newYDataDomain, oldYDataDomain) {
      this.updateYDataRange();
      this.requireUpdate(View.NeedsLayout);
    }
    didSetYDataDomain(newYDataDomain, oldYDataDomain) {
      this.callObservers("viewDidSetYDataDomain", newYDataDomain, oldYDataDomain, this);
    }
    updateYDataDomain(dataPointView) {
      const y = dataPointView.y.value;
      const y2 = dataPointView.y2.value;
      let yDataDomain = this.yDataDomain;
      if (yDataDomain === null) {
        yDataDomain = util.Domain(y, y);
      } else {
        if (util.Values.compare(y, yDataDomain[0]) < 0) {
          yDataDomain = util.Domain(y, yDataDomain[1]);
        } else if (util.Values.compare(yDataDomain[1], y) < 0) {
          yDataDomain = util.Domain(yDataDomain[0], y);
        }
        if (y2 !== void 0) {
          if (util.Values.compare(y2, yDataDomain[0]) < 0) {
            yDataDomain = util.Domain(y2, yDataDomain[1]);
          } else if (util.Values.compare(yDataDomain[1], y2) < 0) {
            yDataDomain = util.Domain(yDataDomain[0], y2);
          }
        }
      }
      this.setYDataDomain(yDataDomain);
    }
    setXDataRange(xDataRange) {
      this.xDataRange = xDataRange;
    }
    updateXDataRange() {
      const xDataDomain = this.xDataDomain;
      if (xDataDomain !== null) {
        const xScale = this.xScale.value;
        if (xScale !== null) {
          this.setXDataRange(util.LinearRange(xScale(xDataDomain[0]), xScale(xDataDomain[1])));
        } else {
          this.setXDataRange(null);
        }
      }
    }
    setYDataRange(yDataRange) {
      this.yDataRange = yDataRange;
    }
    updateYDataRange() {
      const yDataDomain = this.yDataDomain;
      if (yDataDomain !== null) {
        const yScale = this.yScale.value;
        if (yScale !== null) {
          this.setYDataRange(util.LinearRange(yScale(yDataDomain[0]), yScale(yDataDomain[1])));
        } else {
          this.setYDataRange(null);
        }
      }
    }
    getDataPoint(x) {
      const dataPoint = this.dataPointViews.get(x);
      return dataPoint !== void 0 ? dataPoint : null;
    }
    insertDataPoint(dataPointView) {
      return this.insertChild(DataPointView.fromAny(dataPointView), null);
    }
    insertDataPoints(...dataPointViews) {
      for (let i = 0, n = dataPointViews.length; i < n; i += 1) {
        this.insertDataPoint(dataPointViews[i]);
      }
    }
    removeDataPoint(x) {
      const dataPointView = this.getDataPoint(x);
      if (dataPointView !== null) {
        this.removeChild(dataPointView);
      }
      return dataPointView;
    }
    setChild(key, newChild) {
      var _a;
      if (newChild !== null) {
        newChild = View.fromAny(newChild);
      }
      if (newChild instanceof DataPointView) {
        const target = (_a = this.dataPointViews.nextValue(newChild.x.state)) !== null && _a !== void 0 ? _a : null;
        const oldView = this.getChild(key);
        super.insertChild(newChild, target, key);
        return oldView;
      } else {
        return super.setChild(key, newChild);
      }
    }
    appendChild(child, key) {
      var _a;
      child = View.fromAny(child);
      if (child instanceof DataPointView) {
        const target = (_a = this.dataPointViews.nextValue(child.x.state)) !== null && _a !== void 0 ? _a : null;
        return super.insertChild(child, target, key);
      } else {
        return super.appendChild(child, key);
      }
    }
    prependChild(child, key) {
      var _a;
      child = View.fromAny(child);
      if (child instanceof DataPointView) {
        const target = (_a = this.dataPointViews.nextValue(child.x.state)) !== null && _a !== void 0 ? _a : null;
        return super.insertChild(child, target, key);
      } else {
        return super.prependChild(child, key);
      }
    }
    insertChild(child, target, key) {
      var _a;
      child = View.fromAny(child);
      if (child instanceof DataPointView && target === null) {
        target = (_a = this.dataPointViews.nextValue(child.x.state)) !== null && _a !== void 0 ? _a : null;
      }
      return super.insertChild(child, target, key);
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.xScale.recohere(viewContext.updateTime);
      this.yScale.recohere(viewContext.updateTime);
      this.resizeScales(this.viewFrame);
    }
    resizeScales(frame) {
      const xScale = !this.xScale.inherited ? this.xScale.value : null;
      if (xScale !== null && xScale.range[1] !== frame.width) {
        this.xScale.setRange(0, frame.width);
      }
      const yScale = !this.yScale.inherited ? this.yScale.value : null;
      if (yScale !== null && yScale.range[1] !== frame.height) {
        this.yScale.setRange(0, frame.height);
      }
    }
    displayChildren(displayFlags, viewContext, displayChild) {
      let xScale;
      let yScale;
      if ((displayFlags & View.NeedsLayout) !== 0 && (xScale = this.xScale.value, xScale !== null) && (yScale = this.yScale.value, 
      yScale !== null)) {
        this.layoutChildViews(xScale, yScale, displayFlags, viewContext, displayChild);
      } else {
        super.displayChildren(displayFlags, viewContext, displayChild);
      }
    }
    layoutChildViews(xScale, yScale, displayFlags, viewContext, displayChild) {
      const frame = this.viewFrame;
      let xDataDomainMin;
      let xDataDomainMax;
      let yDataDomainMin;
      let yDataDomainMax;
      let gradientStops = 0;
      let point0 = null;
      let point1 = null;
      let y0;
      let y1;
      function layoutChildView(child, displayFlags, viewContext) {
        const point2 = child;
        const x2 = point2.x.getValue();
        const y2 = point2.y.getValue();
        const dy2 = point2.y2.value;
        const sx2 = xScale(x2);
        const sy2 = yScale(y2);
        point2.setXCoord(frame.xMin + sx2);
        point2.setYCoord(frame.yMin + sy2);
        const sdy2 = dy2 !== void 0 ? yScale(dy2) : void 0;
        if (sdy2 !== void 0) {
          point2.setY2Coord(frame.yMin + sdy2);
        } else if (point2.y2Coord !== void 0) {
          point2.setY2Coord(void 0);
        }
        if (point2.isGradientStop()) {
          gradientStops += 1;
        }
        if (point1 !== null) {
          let category;
          if (point0 !== null) {
            if (util.Values.compare(y0, y1) < 0 && util.Values.compare(y2, y1) < 0) {
              category = "maxima";
            } else if (util.Values.compare(y1, y0) < 0 && util.Values.compare(y1, y2) < 0) {
              category = "minima";
            } else if (util.Values.compare(y0, y1) < 0 && util.Values.compare(y1, y2) < 0) {
              category = "increasing";
            } else if (util.Values.compare(y1, y0) < 0 && util.Values.compare(y2, y1) < 0) {
              category = "decreasing";
            } else {
              category = "flat";
            }
          } else {
            if (util.Values.compare(y1, y2) < 0) {
              category = "increasing";
            } else if (util.Values.compare(y2, y1) < 0) {
              category = "decreasing";
            } else {
              category = "flat";
            }
          }
          point1.category.setValue(category, component.Affinity.Intrinsic);
          if (util.Values.compare(y2, yDataDomainMin) < 0) {
            yDataDomainMin = y2;
          } else if (util.Values.compare(yDataDomainMax, y2) < 0) {
            yDataDomainMax = y2;
          }
          if (dy2 !== void 0) {
            if (util.Values.compare(dy2, yDataDomainMin) < 0) {
              yDataDomainMin = dy2;
            } else if (util.Values.compare(yDataDomainMax, dy2) < 0) {
              yDataDomainMax = dy2;
            }
          }
        } else {
          xDataDomainMin = x2;
          xDataDomainMax = x2;
          yDataDomainMin = y2;
          yDataDomainMax = y2;
        }
        point0 = point1;
        point1 = point2;
        y0 = y1;
        y1 = y2;
        xDataDomainMax = x2;
        displayChild.call(this, child, displayFlags, viewContext);
      }
      super.displayChildren(displayFlags, viewContext, layoutChildView);
      if (point1 !== null) {
        let category;
        if (point0 !== null) {
          if (util.Values.compare(y0, y1) < 0) {
            category = "increasing";
          } else if (util.Values.compare(y1, y0) < 0) {
            category = "decreasing";
          } else {
            category = "flat";
          }
        } else {
          category = "flat";
        }
        point1.category.setValue(category, component.Affinity.Intrinsic);
      }
      this.setXDataDomain(point0 !== null ? util.Domain(xDataDomainMin, xDataDomainMax) : null);
      this.setYDataDomain(point0 !== null ? util.Domain(yDataDomainMin, yDataDomainMax) : null);
      this.gradientStops = gradientStops;
    }
    didRender(viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer && !this.hidden && !this.culled) {
        this.renderPlot(renderer.context, this.viewFrame);
      }
      super.didRender(viewContext);
    }
    hitTest(x, y, viewContext) {
      const hitMode = this.hitMode.value;
      if (hitMode !== "none") {
        const renderer = viewContext.renderer;
        if (renderer instanceof CanvasRenderer) {
          let hit;
          if (hitMode === "domain") {
            const viewFrame = this.viewFrame;
            hit = this.hitTestDomain(x - viewFrame.x, y - viewFrame.y, renderer);
          } else {
            hit = this.hitTestPlot(x, y, renderer);
          }
          return hit;
        }
      }
      return null;
    }
    hitTestChildren(x, y, viewContext) {
      return null;
    }
    hitTestDomain(x, y, renderer) {
      const xScale = this.xScale.value;
      if (xScale !== null) {
        const d = xScale.inverse(x);
        const v0 = this.dataPointViews.previousValue(d);
        const v1 = this.dataPointViews.nextValue(d);
        const x0 = v0 !== void 0 ? v0.x.value : void 0;
        const x1 = v1 !== void 0 ? v1.x.value : void 0;
        const dx0 = x0 !== void 0 ? +d - +x0 : NaN;
        const dx1 = x1 !== void 0 ? +x1 - +d : NaN;
        if (dx0 <= dx1) {
          return v0;
        } else if (dx0 > dx1) {
          return v1;
        } else if (v0 !== void 0) {
          return v0;
        } else if (v1 !== void 0) {
          return v1;
        }
      }
      return null;
    }
    init(init) {
      super.init(init);
      if (init.xScale !== void 0) {
        this.xScale(init.xScale);
      }
      if (init.yScale !== void 0) {
        this.yScale(init.yScale);
      }
      const data = init.data;
      if (data !== void 0) {
        this.insertDataPoints(...data);
      }
      if (init.font !== void 0) {
        this.font(init.font);
      }
      if (init.textColor !== void 0) {
        this.textColor(init.textColor);
      }
      if (init.hitMode !== void 0) {
        this.hitMode(init.hitMode);
      }
    }
  }
  __decorate([ ThemeAnimator({
    type: Font,
    value: null,
    inherits: true
  }) ], SeriesPlotView.prototype, "font", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    inherits: true
  }) ], SeriesPlotView.prototype, "textColor", void 0);
  __decorate([ component.Property({
    type: String,
    value: "domain"
  }) ], SeriesPlotView.prototype, "hitMode", void 0);
  __decorate([ component.Animator({
    extends: ContinuousScaleAnimator,
    type: util.ContinuousScale,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout,
    willSetValue(newXScale, oldXScale) {
      this.owner.callObservers("viewWillSetXScale", newXScale, oldXScale, this.owner);
    },
    didSetValue(newXScale, oldXScale) {
      this.owner.updateXDataRange();
      this.owner.callObservers("viewDidSetXScale", newXScale, oldXScale, this.owner);
    }
  }) ], SeriesPlotView.prototype, "xScale", void 0);
  __decorate([ component.Animator({
    extends: ContinuousScaleAnimator,
    type: util.ContinuousScale,
    inherits: true,
    value: null,
    updateFlags: View.NeedsLayout,
    willSetValue(newYScale, oldYScale) {
      this.owner.callObservers("viewWillSetYScale", newYScale, oldYScale, this.owner);
    },
    didSetValue(newYScale, oldYScale) {
      this.owner.updateYDataRange();
      this.owner.callObservers("viewDidSetYScale", newYScale, oldYScale, this.owner);
    }
  }) ], SeriesPlotView.prototype, "yScale", void 0);
  __decorate([ component.Property({
    initValue() {
      return [ 0, 0 ];
    },
    willSetValue(newXRangePadding, oldXRangePadding) {
      this.owner.callObservers("viewWillSetXRangePadding", newXRangePadding, oldXRangePadding, this.owner);
    },
    didSetValue(newXRangePadding, oldXRangePadding) {
      this.owner.callObservers("viewDidSetXRangePadding", newXRangePadding, oldXRangePadding, this.owner);
    }
  }) ], SeriesPlotView.prototype, "xRangePadding", void 0);
  __decorate([ component.Property({
    initValue() {
      return [ 0, 0 ];
    },
    willSetValue(newYRangePadding, oldYRangePadding) {
      this.owner.callObservers("viewWillSetYRangePadding", newYRangePadding, oldYRangePadding, this.owner);
    },
    didSetValue(newYRangePadding, oldYRangePadding) {
      this.owner.callObservers("viewDidSetYRangePadding", newYRangePadding, oldYRangePadding, this.owner);
    }
  }) ], SeriesPlotView.prototype, "yRangePadding", void 0);
  __decorate([ ViewSet({
    implements: true,
    type: DataPointView,
    binds: true,
    observes: true,
    willAttachView(dataPointView, targetView) {
      this.owner.callObservers("viewWillAttachDataPoint", dataPointView, targetView, this.owner);
    },
    didAttachView(dataPointView) {
      if (this.owner.dataPointViews.get(dataPointView.x.state) === void 0) {
        this.owner.dataPointViews.set(dataPointView.x.state, dataPointView);
      }
      this.owner.updateXDataDomain(dataPointView);
      this.owner.updateYDataDomain(dataPointView);
      const labelView = dataPointView.label.view;
      if (labelView !== null) {
        this.attachDataPointLabelView(labelView);
      }
    },
    willDetachView(dataPointView) {
      if (this.owner.dataPointViews.get(dataPointView.x.state) === dataPointView) {
        this.owner.dataPointViews.delete(dataPointView.x.state);
      }
      const labelView = dataPointView.label.view;
      if (labelView !== null) {
        this.detachDataPointLabelView(labelView);
      }
      this.owner.updateXDataDomain(dataPointView);
    },
    didDetachView(dataPointView) {
      this.owner.callObservers("viewDidDetachDataPoint", dataPointView, this.owner);
    },
    viewDidSetDataPointX(newX, oldX, dataPointView) {
      this.owner.updateXDataDomain(dataPointView);
      this.owner.requireUpdate(View.NeedsLayout);
    },
    viewDidSetDataPointY(newY, oldY, dataPointView) {
      this.owner.updateYDataDomain(dataPointView);
      this.owner.requireUpdate(View.NeedsLayout);
    },
    viewDidSetDataPointY2(newY2, oldY2, dataPointView) {
      this.owner.updateYDataDomain(dataPointView);
      this.owner.requireUpdate(View.NeedsLayout);
    },
    viewWillAttachDataPointLabel(labelView) {
      this.attachDataPointLabelView(labelView);
    },
    viewDidDetachDataPointLabel(labelView) {
      this.detachDataPointLabelView(labelView);
    },
    attachDataPointLabelView(labelView) {
      this.owner.requireUpdate(View.NeedsLayout);
    },
    detachDataPointLabelView(labelView) {}
  }) ], SeriesPlotView.prototype, "dataPoints", void 0);
  class BubblePlotView extends ScatterPlotView {
    renderPlot(context, frame) {
      const size = Math.min(frame.width, frame.height);
      const radius = this.radius.getValueOr(math.Length.zero());
      const fill = this.fill.value;
      const stroke = this.stroke.value;
      const strokeWidth = this.strokeWidth.value;
      const contextFillStyle = context.fillStyle;
      const contextLineWidth = context.lineWidth;
      const contextStrokeStyle = context.strokeStyle;
      const dataPointViews = this.dataPoints.views;
      for (const viewId in dataPointViews) {
        const p = dataPointViews[viewId];
        context.beginPath();
        const r = p.radius.getValueOr(radius).pxValue(size);
        context.arc(p.xCoord, p.yCoord, r, 0, 2 * Math.PI);
        let fillColor = p.color.getValueOr(fill);
        if (fillColor !== null) {
          const opacity = p.opacity.value;
          if (opacity !== void 0) {
            fillColor = fillColor.alpha(opacity);
          }
          context.fillStyle = fillColor.toString();
          context.fill();
        }
        if (stroke !== null) {
          if (strokeWidth !== null) {
            context.lineWidth = strokeWidth.pxValue(size);
          }
          context.strokeStyle = stroke.toString();
          context.stroke();
        }
      }
      context.fillStyle = contextFillStyle;
      context.lineWidth = contextLineWidth;
      context.strokeStyle = contextStrokeStyle;
    }
    init(init) {
      super.init(init);
      if (init.radius !== void 0) {
        this.radius(init.radius);
      }
      if (init.fill !== void 0) {
        this.fill(init.fill);
      }
      if (init.stroke !== void 0) {
        this.stroke(init.stroke);
      }
      if (init.strokeWidth !== void 0) {
        this.strokeWidth(init.strokeWidth);
      }
    }
  }
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.px(5),
    updateFlags: View.NeedsRender,
    willSetValue(newRadius, oldRadius) {
      this.owner.callObservers("viewWillSetPlotRadius", newRadius, oldRadius, this.owner);
    },
    didSetValue(newRadius, oldRadius) {
      this.owner.callObservers("viewDidSetPlotRadius", newRadius, oldRadius, this.owner);
    }
  }) ], BubblePlotView.prototype, "radius", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    look: Look.accentColor,
    updateFlags: View.NeedsRender,
    willSetValue(newFill, oldFill) {
      this.owner.callObservers("viewWillSetPlotFill", newFill, oldFill, this.owner);
    },
    didSetValue(newFill, oldFill) {
      this.owner.callObservers("viewDidSetPlotFill", newFill, oldFill, this.owner);
    }
  }) ], BubblePlotView.prototype, "fill", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    updateFlags: View.NeedsRender
  }) ], BubblePlotView.prototype, "stroke", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    updateFlags: View.NeedsRender
  }) ], BubblePlotView.prototype, "strokeWidth", void 0);
  class LinePlotView extends SeriesPlotView {
    renderPlot(context, frame) {
      const size = Math.min(frame.width, frame.height);
      const stroke = this.stroke.getValueOr(Color.transparent());
      const strokeWidth = this.strokeWidth.getValueOr(math.Length.zero()).pxValue(size);
      const gradientStops = this.gradientStops;
      let gradient = null;
      let x0;
      let x1;
      let dx;
      const dataPointViews = this.dataPointViews;
      if (!dataPointViews.isEmpty()) {
        const p0 = dataPointViews.firstValue();
        const p1 = dataPointViews.lastValue();
        x0 = p0.xCoord;
        x1 = p1.xCoord;
        dx = x1 - x0;
        if (gradientStops !== 0) {
          gradient = context.createLinearGradient(x0, 0, x1, 0);
        }
      } else {
        x0 = NaN;
        x1 = NaN;
        dx = NaN;
      }
      context.beginPath();
      let i = 0;
      dataPointViews.forEach((function(x, p) {
        const xCoord = p.xCoord;
        const yCoord = p.yCoord;
        if (i === 0) {
          context.moveTo(xCoord, yCoord);
        } else {
          context.lineTo(xCoord, yCoord);
        }
        if (gradient !== null && p.isGradientStop()) {
          let color = p.color.getValueOr(stroke);
          const opacity = p.opacity.value;
          if (opacity !== void 0) {
            color = color.alpha(opacity);
          }
          const offset = (xCoord - x0) / (dx || 1);
          gradient.addColorStop(offset, color.toString());
        }
        i += 1;
      }), this);
      const contextLineWidth = context.lineWidth;
      const contextStrokeStyle = context.strokeStyle;
      context.lineWidth = strokeWidth;
      context.strokeStyle = gradient !== null ? gradient : stroke.toString();
      context.stroke();
      context.lineWidth = contextLineWidth;
      context.strokeStyle = contextStrokeStyle;
    }
    hitTestPlot(x, y, renderer) {
      const context = renderer.context;
      let hitWidth = this.hitWidth.value;
      const strokeWidth = this.strokeWidth.value;
      if (strokeWidth !== null) {
        const frame = this.viewFrame;
        const size = Math.min(frame.width, frame.height);
        hitWidth = Math.max(hitWidth, strokeWidth.pxValue(size));
      }
      context.beginPath();
      let i = 0;
      this.dataPointViews.forEach((function(x, p) {
        const xCoord = p.xCoord;
        const yCoord = p.yCoord;
        if (i === 0) {
          context.moveTo(xCoord, yCoord);
        } else {
          context.lineTo(xCoord, yCoord);
        }
        i += 1;
      }), this);
      const contextLineWidth = context.lineWidth;
      context.lineWidth = hitWidth;
      const p = renderer.transform.transform(x, y);
      const pointInStroke = context.isPointInStroke(p.x, p.y);
      context.lineWidth = contextLineWidth;
      if (pointInStroke) {
        const hitMode = this.hitMode.value;
        if (hitMode === "plot") {
          return this;
        } else if (hitMode === "data") {
          return this.hitTestDomain(x, y, renderer);
        }
      }
      return null;
    }
    init(init) {
      super.init(init);
      if (init.hitWidth !== void 0) {
        this.hitWidth(init.hitWidth);
      }
      if (init.stroke !== void 0) {
        this.stroke(init.stroke);
      }
      if (init.strokeWidth !== void 0) {
        this.strokeWidth(init.strokeWidth);
      }
    }
  }
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    look: Look.accentColor,
    updateFlags: View.NeedsRender,
    willSetValue(newStroke, oldStroke) {
      this.owner.callObservers("viewWillSetPlotStroke", newStroke, oldStroke, this.owner);
    },
    didSetValue(newStroke, oldStroke) {
      this.owner.callObservers("viewDidSetPlotStroke", newStroke, oldStroke, this.owner);
    }
  }) ], LinePlotView.prototype, "stroke", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.px(1),
    updateFlags: View.NeedsRender,
    willSetValue(newStrokeWidth, oldStrokeWidth) {
      this.owner.callObservers("viewWillSetPlotStrokeWidth", newStrokeWidth, oldStrokeWidth, this.owner);
    },
    didSetValue(newStrokeWidth, oldStrokeWidth) {
      if (this.owner.xRangePadding.hasAffinity(component.Affinity.Intrinsic) || this.owner.yRangePadding.hasAffinity(component.Affinity.Intrinsic)) {
        const frame = this.owner.viewFrame;
        const size = Math.min(frame.width, frame.height);
        const strokeWidth = this.getValueOr(math.Length.zero()).pxValue(size);
        const strokeRadius = strokeWidth / 2;
        this.owner.xRangePadding.setValue([ strokeRadius, strokeRadius ], component.Affinity.Intrinsic);
        this.owner.yRangePadding.setValue([ strokeRadius, strokeRadius ], component.Affinity.Intrinsic);
      }
      this.owner.callObservers("viewDidSetPlotStrokeWidth", newStrokeWidth, oldStrokeWidth, this.owner);
    }
  }) ], LinePlotView.prototype, "strokeWidth", void 0);
  __decorate([ component.Property({
    type: Number,
    value: 5
  }) ], LinePlotView.prototype, "hitWidth", void 0);
  class AreaPlotView extends SeriesPlotView {
    renderPlot(context, frame) {
      const fill = this.fill.getValueOr(Color.transparent());
      const gradientStops = this.gradientStops;
      let gradient = null;
      context.beginPath();
      let x0;
      let x1;
      let dx;
      const dataPointViews = this.dataPointViews;
      if (!dataPointViews.isEmpty()) {
        const p0 = dataPointViews.firstValue();
        const p1 = dataPointViews.lastValue();
        x0 = p0.xCoord;
        x1 = p1.xCoord;
        dx = x1 - x0;
        context.moveTo(p0.xCoord, p0.yCoord);
        if (gradientStops !== 0) {
          gradient = context.createLinearGradient(x0, 0, x1, 0);
          if (p0.isGradientStop()) {
            let color = p0.color.getValueOr(fill);
            const opacity = p0.opacity.value;
            if (opacity !== void 0) {
              color = color.alpha(opacity);
            }
            gradient.addColorStop(0, color.toString());
          }
        }
      } else {
        x0 = NaN;
        x1 = NaN;
        dx = NaN;
      }
      const cursor = dataPointViews.values();
      cursor.next();
      while (cursor.hasNext()) {
        const p = cursor.next().value;
        context.lineTo(p.xCoord, p.yCoord);
        if (gradient !== null && p.isGradientStop()) {
          let color = p.color.value || fill;
          const opacity = p.opacity.value;
          if (opacity !== void 0) {
            color = color.alpha(opacity);
          }
          const offset = (p.xCoord - x0) / (dx || 1);
          gradient.addColorStop(offset, color.toString());
        }
      }
      while (cursor.hasPrevious()) {
        const p = cursor.previous().value;
        context.lineTo(p.xCoord, p.y2Coord);
      }
      if (!dataPointViews.isEmpty()) {
        context.closePath();
      }
      const contextFillStyle = context.fillStyle;
      context.fillStyle = gradient !== null ? gradient : fill.toString();
      context.fill();
      context.fillStyle = contextFillStyle;
    }
    hitTestPlot(x, y, renderer) {
      const context = renderer.context;
      const dataPointViews = this.dataPointViews;
      context.beginPath();
      const cursor = dataPointViews.values();
      if (cursor.hasNext()) {
        const p = cursor.next().value;
        context.moveTo(p.xCoord, p.yCoord);
      }
      while (cursor.hasNext()) {
        const p = cursor.next().value;
        context.lineTo(p.xCoord, p.yCoord);
      }
      while (cursor.hasPrevious()) {
        const p = cursor.previous().value;
        context.lineTo(p.xCoord, p.y2Coord);
      }
      if (!dataPointViews.isEmpty()) {
        context.closePath();
      }
      const p = renderer.transform.transform(x, y);
      if (context.isPointInPath(p.x, p.y)) {
        const hitMode = this.hitMode.value;
        if (hitMode === "plot") {
          return this;
        } else if (hitMode === "data") {
          return this.hitTestDomain(x, y, renderer);
        }
      }
      return null;
    }
    init(init) {
      super.init(init);
      if (init.fill !== void 0) {
        this.fill(init.fill);
      }
    }
  }
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    look: Look.accentColor,
    updateFlags: View.NeedsRender,
    willSetValue(newFill, oldFill) {
      this.owner.callObservers("viewWillSetPlotFill", newFill, oldFill, this.owner);
    },
    didSetValue(newFill, oldFill) {
      this.owner.callObservers("viewDidSetPlotFill", newFill, oldFill, this.owner);
    }
  }) ], AreaPlotView.prototype, "fill", void 0);
  class PlotTrait extends Trait {
    onStartConsuming() {
      super.onStartConsuming();
      const dataSetTrait = this.dataSet.trait;
      if (dataSetTrait !== null) {
        dataSetTrait.consume(this);
      }
    }
    onStopConsuming() {
      super.onStopConsuming();
      const dataSetTrait = this.dataSet.trait;
      if (dataSetTrait !== null) {
        dataSetTrait.unconsume(this);
      }
    }
  }
  __decorate([ TraitRef({
    type: DataSetTrait,
    binds: true,
    willAttachTrait(dataSetTrait, targetTrait) {
      this.owner.callObservers("traitWillAttachDataSet", dataSetTrait, this.owner);
    },
    didAttachTrait(dataSetTrait) {
      if (this.owner.consuming) {
        dataSetTrait.consume(this.owner);
      }
    },
    willDetachTrait(dataSetTrait) {
      if (this.owner.consuming) {
        dataSetTrait.unconsume(this.owner);
      }
    },
    didDetachTrait(dataSetTrait) {
      this.owner.callObservers("traitDidDetachDataSet", dataSetTrait, this.owner);
    },
    detectModel(model) {
      return null;
    },
    detectTrait(trait) {
      return trait instanceof DataSetTrait ? trait : null;
    }
  }) ], PlotTrait.prototype, "dataSet", void 0);
  class ScatterPlotTrait extends PlotTrait {}
  class SeriesPlotTrait extends PlotTrait {}
  class BubblePlotTrait extends ScatterPlotTrait {}
  __decorate([ component.Property({
    type: math.Length,
    value: null,
    willSetValue(newRadius, oldRadius) {
      this.owner.callObservers("traitWillSetPlotRadius", newRadius, oldRadius, this.owner);
    },
    didSetValue(newRadius, oldRadius) {
      this.owner.callObservers("traitDidSetPlotRadius", newRadius, oldRadius, this.owner);
    }
  }) ], BubblePlotTrait.prototype, "radius", void 0);
  __decorate([ component.Property({
    value: null,
    willSetValue(newFill, oldFill) {
      this.owner.callObservers("traitWillSetPlotFill", newFill, oldFill, this.owner);
    },
    didSetValue(newFill, oldFill) {
      this.owner.callObservers("traitDidSetPlotFill", newFill, oldFill, this.owner);
    },
    fromAny(fill) {
      if (fill !== null && !(fill instanceof Look)) {
        fill = Color.fromAny(fill);
      }
      return fill;
    }
  }) ], BubblePlotTrait.prototype, "fill", void 0);
  class LinePlotTrait extends SeriesPlotTrait {}
  __decorate([ component.Property({
    value: null,
    willSetValue(newStroke, oldStroke) {
      this.owner.callObservers("traitWillSetPlotStroke", newStroke, oldStroke, this.owner);
    },
    didSetValue(newStroke, oldStroke) {
      this.owner.callObservers("traitDidSetPlotStroke", newStroke, oldStroke, this.owner);
    },
    fromAny(stroke) {
      if (stroke !== null && !(stroke instanceof Look)) {
        stroke = Color.fromAny(stroke);
      }
      return stroke;
    }
  }) ], LinePlotTrait.prototype, "stroke", void 0);
  __decorate([ component.Property({
    type: math.Length,
    value: null,
    willSetValue(newStrokeWidth, oldStrokeWidth) {
      this.owner.callObservers("traitWillSetPlotStrokeWidth", newStrokeWidth, oldStrokeWidth, this.owner);
    },
    didSetValue(newStrokeWidth, oldStrokeWidth) {
      this.owner.callObservers("traitDidSetPlotStrokeWidth", newStrokeWidth, oldStrokeWidth, this.owner);
    }
  }) ], LinePlotTrait.prototype, "strokeWidth", void 0);
  class AreaPlotTrait extends SeriesPlotTrait {}
  __decorate([ component.Property({
    value: null,
    willSetValue(newFill, oldFill) {
      this.owner.callObservers("traitWillSetPlotFill", newFill, oldFill, this.owner);
    },
    didSetValue(newFill, oldFill) {
      this.owner.callObservers("traitDidSetPlotFill", newFill, oldFill, this.owner);
    },
    fromAny(fill) {
      if (fill !== null && !(fill instanceof Look)) {
        fill = Color.fromAny(fill);
      }
      return fill;
    }
  }) ], AreaPlotTrait.prototype, "fill", void 0);
  class PlotController extends DataSetController {
    static fromTrait(plotTrait) {
      if (plotTrait instanceof BubblePlotTrait) {
        return new BubblePlotController;
      } else if (plotTrait instanceof LinePlotTrait) {
        return new LinePlotController;
      } else if (plotTrait instanceof AreaPlotTrait) {
        return new AreaPlotController;
      } else {
        throw new Error("Can't create PlotController from " + plotTrait);
      }
    }
  }
  __decorate([ component.Property({
    type: util.Timing,
    inherits: true
  }) ], PlotController.prototype, "plotTiming", void 0);
  class ScatterPlotController extends PlotController {}
  class SeriesPlotController extends PlotController {}
  class BubblePlotController extends ScatterPlotController {
    setPlotRadius(radius, timing) {
      const plotView = this.plot.view;
      if (plotView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.plotTiming.value;
          if (timing === true) {
            timing = plotView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        plotView.radius.setState(radius, timing, component.Affinity.Intrinsic);
      }
    }
    setPlotFill(fill, timing) {
      const plotView = this.plot.view;
      if (plotView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.plotTiming.value;
          if (timing === true) {
            timing = plotView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        if (fill instanceof Look) {
          plotView.fill.setLook(fill, timing, component.Affinity.Intrinsic);
        } else {
          plotView.fill.setState(fill, timing, component.Affinity.Intrinsic);
        }
      }
    }
  }
  __decorate([ TraitViewControllerSet({
    extends: true,
    get parentView() {
      return this.owner.plot.view;
    }
  }) ], BubblePlotController.prototype, "dataPoints", void 0);
  __decorate([ TraitViewRef({
    traitType: BubblePlotTrait,
    observesTrait: true,
    initTrait(plotTrait) {
      if (this.owner.dataSet.trait === null) {
        const dataSetTrait = plotTrait.getTrait(DataSetTrait);
        if (dataSetTrait !== null) {
          this.owner.dataSet.setTrait(dataSetTrait);
        }
      }
      const plotView = this.view;
      if (plotView !== null) {
        this.owner.setPlotRadius(plotTrait.radius.value);
        this.owner.setPlotFill(plotTrait.fill.value);
      }
    },
    willAttachTrait(plotTrait) {
      this.owner.callObservers("controllerWillAttachPlotTrait", plotTrait, this.owner);
    },
    didDetachTrait(plotTrait) {
      this.owner.callObservers("controllerDidDetachPlotTrait", plotTrait, this.owner);
    },
    traitDidSetPlotRadius(newRadius, oldRadius) {
      this.owner.setPlotRadius(newRadius);
    },
    traitDidSetPlotFill(newFill, oldFill) {
      this.owner.setPlotFill(newFill);
    },
    viewType: BubblePlotView,
    observesView: true,
    initView(plotView) {
      const dataPointControllers = this.owner.dataPoints.controllers;
      for (const controllerId in dataPointControllers) {
        const dataPointController = dataPointControllers[controllerId];
        dataPointController.dataPoint.insertView(plotView);
      }
      const plotTrait = this.trait;
      if (plotTrait !== null) {
        this.owner.setPlotRadius(plotTrait.radius.value);
        this.owner.setPlotFill(plotTrait.fill.value);
      }
    },
    willAttachView(plotView) {
      this.owner.callObservers("controllerWillAttachPlotView", plotView, this.owner);
    },
    didDetachView(plotView) {
      this.owner.callObservers("controllerDidDetachPlotView", plotView, this.owner);
    },
    viewWillSetPlotRadius(newRadius, oldRadius, plotView) {
      this.owner.callObservers("controllerWillSetPlotRadius", newRadius, oldRadius, this.owner);
    },
    viewDidSetPlotRadius(newRadius, oldRadius, plotView) {
      this.owner.callObservers("controllerDidSetPlotRadius", newRadius, oldRadius, this.owner);
    },
    viewWillSetPlotFill(newFill, oldFill, plotView) {
      this.owner.callObservers("controllerWillSetPlotFill", newFill, oldFill, this.owner);
    },
    viewDidSetPlotFill(newFill, oldFill, plotView) {
      this.owner.callObservers("controllerDidSetPlotFill", newFill, oldFill, this.owner);
    }
  }) ], BubblePlotController.prototype, "plot", void 0);
  class LinePlotController extends SeriesPlotController {
    setPlotStroke(stroke, timing) {
      const plotView = this.plot.view;
      if (plotView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.plotTiming.value;
          if (timing === true) {
            timing = plotView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        if (stroke instanceof Look) {
          plotView.stroke.setLook(stroke, timing, component.Affinity.Intrinsic);
        } else {
          plotView.stroke.setState(stroke, timing, component.Affinity.Intrinsic);
        }
      }
    }
    setPlotStrokeWidth(strokeWidth, timing) {
      const plotView = this.plot.view;
      if (plotView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.plotTiming.value;
          if (timing === true) {
            timing = plotView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        plotView.strokeWidth.setState(strokeWidth, timing, component.Affinity.Intrinsic);
      }
    }
  }
  __decorate([ TraitViewControllerSet({
    extends: true,
    get parentView() {
      return this.owner.plot.view;
    }
  }) ], LinePlotController.prototype, "dataPoints", void 0);
  __decorate([ TraitViewRef({
    traitType: LinePlotTrait,
    observesTrait: true,
    initTrait(plotTrait) {
      if (this.owner.dataSet.trait === null) {
        const dataSetTrait = plotTrait.getTrait(DataSetTrait);
        if (dataSetTrait !== null) {
          this.owner.dataSet.setTrait(dataSetTrait);
        }
      }
      const plotView = this.view;
      if (plotView !== null) {
        const stroke = plotTrait.stroke.value;
        if (stroke !== null) {
          this.owner.setPlotStroke(stroke);
        }
        const strokeWidth = plotTrait.strokeWidth.value;
        if (strokeWidth !== null) {
          this.owner.setPlotStrokeWidth(strokeWidth);
        }
      }
    },
    willAttachTrait(plotTrait) {
      this.owner.callObservers("controllerWillAttachPlotTrait", plotTrait, this.owner);
    },
    didDetachTrait(plotTrait) {
      this.owner.callObservers("controllerDidDetachPlotTrait", plotTrait, this.owner);
    },
    traitDidSetPlotStroke(newStroke, oldStroke) {
      this.owner.setPlotStroke(newStroke);
    },
    traitDidSetPlotStrokeWidth(newStrokeWidth, oldStrokeWidth) {
      this.owner.setPlotStrokeWidth(newStrokeWidth);
    },
    viewType: LinePlotView,
    observesView: true,
    initView(plotView) {
      const dataPointControllers = this.owner.dataPoints.controllers;
      for (const controllerId in dataPointControllers) {
        const dataPointController = dataPointControllers[controllerId];
        dataPointController.dataPoint.insertView(plotView);
      }
      const plotTrait = this.trait;
      if (plotTrait !== null) {
        const stroke = plotTrait.stroke.value;
        if (stroke !== null) {
          this.owner.setPlotStroke(stroke);
        }
        const strokeWidth = plotTrait.strokeWidth.value;
        if (strokeWidth !== null) {
          this.owner.setPlotStrokeWidth(strokeWidth);
        }
      }
    },
    willAttachView(plotView) {
      this.owner.callObservers("controllerWillAttachPlotView", plotView, this.owner);
    },
    didDetachView(plotView) {
      this.owner.callObservers("controllerDidDetachPlotView", plotView, this.owner);
    },
    viewWillSetPlotStroke(newStroke, oldStroke, plotView) {
      this.owner.callObservers("controllerWillSetPlotStroke", newStroke, oldStroke, this.owner);
    },
    viewDidSetPlotStroke(newStroke, oldStroke, plotView) {
      this.owner.callObservers("controllerDidSetPlotStroke", newStroke, oldStroke, this.owner);
    },
    viewWillSetPlotStrokeWidth(newStrokeWidth, oldStrokeWidth, plotView) {
      this.owner.callObservers("controllerWillSetPlotStrokeWidth", newStrokeWidth, oldStrokeWidth, this.owner);
    },
    viewDidSetPlotStrokeWidth(newStrokeWidth, oldStrokeWidth, plotView) {
      this.owner.callObservers("controllerDidSetPlotStrokeWidth", newStrokeWidth, oldStrokeWidth, this.owner);
    }
  }) ], LinePlotController.prototype, "plot", void 0);
  class AreaPlotController extends SeriesPlotController {
    setPlotFill(fill, timing) {
      const plotView = this.plot.view;
      if (plotView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.plotTiming.value;
          if (timing === true) {
            timing = plotView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        if (fill instanceof Look) {
          plotView.fill.setLook(fill, timing, component.Affinity.Intrinsic);
        } else {
          plotView.fill.setState(fill, timing, component.Affinity.Intrinsic);
        }
      }
    }
    willSetPlotFill(newFill, oldFill, plotView) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerWillSetPlotFill !== void 0) {
          observer.controllerWillSetPlotFill(newFill, oldFill, this);
        }
      }
    }
    onSetPlotFill(newFill, oldFill, plotView) {}
    didSetPlotFill(newFill, oldFill, plotView) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.controllerDidSetPlotFill !== void 0) {
          observer.controllerDidSetPlotFill(newFill, oldFill, this);
        }
      }
    }
  }
  __decorate([ TraitViewControllerSet({
    extends: true,
    get parentView() {
      return this.owner.plot.view;
    }
  }) ], AreaPlotController.prototype, "dataPoints", void 0);
  __decorate([ TraitViewRef({
    traitType: AreaPlotTrait,
    observesTrait: true,
    initTrait(plotTrait) {
      if (this.owner.dataSet.trait === null) {
        const dataSetTrait = plotTrait.getTrait(DataSetTrait);
        if (dataSetTrait !== null) {
          this.owner.dataSet.setTrait(dataSetTrait);
        }
      }
      const plotView = this.view;
      if (plotView !== null) {
        const fill = plotTrait.fill.value;
        if (fill !== null) {
          this.owner.setPlotFill(fill);
        }
      }
    },
    willAttachTrait(plotTrait) {
      this.owner.callObservers("controllerWillAttachPlotTrait", plotTrait, this.owner);
    },
    didDetachTrait(plotTrait) {
      this.owner.callObservers("controllerDidDetachPlotTrait", plotTrait, this.owner);
    },
    traitDidSetPlotFill(newFill, oldFill) {
      this.owner.setPlotFill(newFill);
    },
    viewType: AreaPlotView,
    observesView: true,
    initView(plotView) {
      const dataPointControllers = this.owner.dataPoints.controllers;
      for (const controllerId in dataPointControllers) {
        const dataPointController = dataPointControllers[controllerId];
        dataPointController.dataPoint.insertView(plotView);
      }
      const plotTrait = this.trait;
      if (plotTrait !== null) {
        const fill = plotTrait.fill.value;
        if (fill !== null) {
          this.owner.setPlotFill(fill);
        }
      }
    },
    willAttachView(plotView) {
      this.owner.callObservers("controllerWillAttachPlotView", plotView, this.owner);
    },
    didDetachView(plotView) {
      this.owner.callObservers("controllerDidDetachPlotView", plotView, this.owner);
    },
    viewWillSetPlotFill(newFill, oldFill, plotView) {
      this.owner.willSetPlotFill(newFill, oldFill, plotView);
    },
    viewDidSetPlotFill(newFill, oldFill, plotView) {
      this.owner.onSetPlotFill(newFill, oldFill, plotView);
      this.owner.didSetPlotFill(newFill, oldFill, plotView);
    }
  }) ], AreaPlotController.prototype, "plot", void 0);
  class GraphView extends ScaledView {
    addPlot(plot, key) {
      plot = View.fromAny(plot);
      this.appendChild(plot);
    }
    willRender(viewContext) {
      super.willRender(viewContext);
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer) {
        const context = renderer.context;
        context.save();
        this.clipGraph(context, this.viewFrame);
      }
    }
    didRender(viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer) {
        const context = renderer.context;
        context.restore();
      }
      super.didRender(viewContext);
    }
    clipGraph(context, frame) {
      context.beginPath();
      context.rect(frame.x, frame.y, frame.width, frame.height);
      context.clip();
    }
    hitTest(x, y, viewContext) {
      return this;
    }
    init(init) {
      super.init(init);
      const plots = init.plots;
      if (plots !== void 0) {
        for (let i = 0, n = plots.length; i < n; i += 1) {
          this.addPlot(plots[i]);
        }
      }
      if (init.font !== void 0) {
        this.font(init.font);
      }
      if (init.textColor !== void 0) {
        this.textColor(init.textColor);
      }
    }
  }
  __decorate([ ThemeAnimator({
    type: Font,
    inherits: true,
    value: null
  }) ], GraphView.prototype, "font", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    inherits: true,
    value: null
  }) ], GraphView.prototype, "textColor", void 0);
  class GraphTrait extends Trait {
    startConsumingPlots() {
      const plotTraits = this.plots.traits;
      for (const traitId in plotTraits) {
        const plotTrait = plotTraits[traitId];
        plotTrait.consume(this);
      }
    }
    stopConsumingPlots() {
      const plotTraits = this.plots.traits;
      for (const traitId in plotTraits) {
        const plotTrait = plotTraits[traitId];
        plotTrait.unconsume(this);
      }
    }
    onStartConsuming() {
      super.onStartConsuming();
      this.startConsumingPlots();
    }
    onStopConsuming() {
      super.onStopConsuming();
      this.stopConsumingPlots();
    }
  }
  __decorate([ TraitSet({
    type: PlotTrait,
    binds: true,
    willAttachTrait(plotTrait) {
      this.owner.callObservers("traitWillAttachPlot", plotTrait, this.owner);
    },
    didAttachTrait(plotTrait) {
      if (this.owner.consuming) {
        plotTrait.consume(this.owner);
      }
    },
    willDetachTrait(plotTrait) {
      if (this.owner.consuming) {
        plotTrait.unconsume(this.owner);
      }
    },
    didDetachTrait(plotTrait) {
      this.owner.callObservers("traitDidDetachPlot", plotTrait, this.owner);
    },
    detectModel(model) {
      return model.getTrait(PlotTrait);
    }
  }) ], GraphTrait.prototype, "plots", void 0);
  class GraphController extends Controller {}
  __decorate([ TraitViewRef({
    traitType: GraphTrait,
    observesTrait: true,
    willAttachTrait(graphTrait) {
      this.owner.callObservers("controllerWillAttachGraphTrait", graphTrait, this.owner);
    },
    didAttachTrait(graphTrait) {
      const plotTraits = graphTrait.plots.traits;
      for (const traitId in plotTraits) {
        const plotTrait = plotTraits[traitId];
        this.owner.plots.addTraitController(plotTrait);
      }
    },
    willDetachTrait(graphTrait) {
      const plotTraits = graphTrait.plots.traits;
      for (const traitId in plotTraits) {
        const plotTrait = plotTraits[traitId];
        this.owner.plots.deleteTraitController(plotTrait);
      }
    },
    didDetachTrait(graphTrait) {
      this.owner.callObservers("controllerDidDetachGraphTrait", graphTrait, this.owner);
    },
    traitWillAttachPlot(plotTrait, targetTrait) {
      this.owner.plots.addTraitController(plotTrait, targetTrait);
    },
    traitDidDetachPlot(plotTrait) {
      this.owner.plots.deleteTraitController(plotTrait);
    },
    viewType: GraphView,
    initView(graphView) {
      const plotControllers = this.owner.plots.controllers;
      for (const controllerId in plotControllers) {
        const plotController = plotControllers[controllerId];
        const plotView = plotController.plot.view;
        if (plotView !== null && plotView.parent === null) {
          plotController.plot.insertView(graphView);
        }
      }
    },
    willAttachView(newGraphView) {
      this.owner.callObservers("controllerWillAttachGraphView", newGraphView, this.owner);
    },
    didDetachView(newGraphView) {
      this.owner.callObservers("controllerDidDetachGraphView", newGraphView, this.owner);
    }
  }) ], GraphController.prototype, "graph", void 0);
  __decorate([ TraitViewControllerSet({
    implements: true,
    type: PlotController,
    binds: true,
    observes: true,
    get parentView() {
      return this.owner.graph.view;
    },
    getTraitViewRef(plotController) {
      return plotController.plot;
    },
    willAttachController(plotController) {
      this.owner.callObservers("controllerWillAttachPlot", plotController, this.owner);
    },
    didAttachController(plotController) {
      const plotTrait = plotController.plot.trait;
      if (plotTrait !== null) {
        this.attachPlotTrait(plotTrait, plotController);
      }
      const plotView = plotController.plot.view;
      if (plotView !== null) {
        this.attachPlotView(plotView, plotController);
      }
      const dataSetTrait = plotController.dataSet.trait;
      if (dataSetTrait !== null) {
        this.attachDataSetTrait(dataSetTrait, plotController);
      }
    },
    willDetachController(plotController) {
      const dataSetTrait = plotController.dataSet.trait;
      if (dataSetTrait !== null) {
        this.detachDataSetTrait(dataSetTrait, plotController);
      }
      const plotView = plotController.plot.view;
      if (plotView !== null) {
        this.detachPlotView(plotView, plotController);
      }
      const plotTrait = plotController.plot.trait;
      if (plotTrait !== null) {
        this.detachPlotTrait(plotTrait, plotController);
      }
    },
    didDetachController(plotController) {
      this.owner.callObservers("controllerDidDetachPlot", plotController, this.owner);
    },
    controllerWillAttachPlotTrait(plotTrait, plotController) {
      this.owner.callObservers("controllerWillAttachPlotTrait", plotTrait, plotController, this.owner);
      this.attachPlotTrait(plotTrait, plotController);
    },
    controllerDidDetachPlotTrait(plotTrait, plotController) {
      this.detachPlotTrait(plotTrait, plotController);
      this.owner.callObservers("controllerDidDetachPlotTrait", plotTrait, plotController, this.owner);
    },
    attachPlotTrait(plotTrait, plotController) {},
    detachPlotTrait(plotTrait, plotController) {},
    controllerWillAttachPlotView(plotView, plotController) {
      this.owner.callObservers("controllerWillAttachPlotView", plotView, plotController, this.owner);
      this.attachPlotView(plotView, plotController);
    },
    controllerDidDetachPlotView(plotView, plotController) {
      this.detachPlotView(plotView, plotController);
      this.owner.callObservers("controllerDidDetachPlotView", plotView, plotController, this.owner);
    },
    attachPlotView(plotView, plotController) {},
    detachPlotView(plotView, plotController) {
      plotView.remove();
    },
    controllerWillAttachDataSetTrait(dataSetTrait, plotController) {
      this.owner.callObservers("controllerWillAttachDataSetTrait", dataSetTrait, plotController, this.owner);
      this.attachDataSetTrait(dataSetTrait, plotController);
    },
    controllerDidDetachDataSetTrait(dataSetTrait, plotController) {
      this.detachDataSetTrait(dataSetTrait, plotController);
      this.owner.callObservers("controllerDidDetachDataSetTrait", dataSetTrait, plotController, this.owner);
    },
    attachDataSetTrait(dataSetTrait, plotController) {},
    detachDataSetTrait(dataSetTrait, plotController) {},
    controllerWillAttachDataPoint(dataPointController, plotController) {
      this.owner.callObservers("controllerWillAttachDataPoint", dataPointController, plotController, this.owner);
      this.attachDataPoint(dataPointController, plotController);
    },
    controllerDidDetachDataPoint(dataPointController, plotController) {
      this.detachDataPoint(dataPointController, plotController);
      this.owner.callObservers("controllerDidDetachDataPoint", dataPointController, plotController, this.owner);
    },
    attachDataPoint(dataPointController, plotController) {
      const dataPointTrait = dataPointController.dataPoint.trait;
      if (dataPointTrait !== null) {
        this.attachDataPointTrait(dataPointTrait, dataPointController, plotController);
      }
      const dataPointView = dataPointController.dataPoint.view;
      if (dataPointView !== null) {
        this.attachDataPointView(dataPointView, dataPointController, plotController);
      }
    },
    detachDataPoint(dataPointController, plotController) {
      const dataPointTrait = dataPointController.dataPoint.trait;
      if (dataPointTrait !== null) {
        this.detachDataPointTrait(dataPointTrait, dataPointController, plotController);
      }
      const dataPointView = dataPointController.dataPoint.view;
      if (dataPointView !== null) {
        this.detachDataPointView(dataPointView, dataPointController, plotController);
      }
    },
    controllerWillAttachDataPointTrait(dataPointTrait, dataPointController, plotController) {
      this.owner.callObservers("controllerWillAttachDataPointTrait", dataPointTrait, dataPointController, plotController, this.owner);
      this.attachDataPointTrait(dataPointTrait, dataPointController, plotController);
    },
    controllerDidDetachDataPointTrait(dataPointTrait, dataPointController, plotController) {
      this.detachDataPointTrait(dataPointTrait, dataPointController, plotController);
      this.owner.callObservers("controllerDidDetachDataPointTrait", dataPointTrait, dataPointController, plotController, this.owner);
    },
    attachDataPointTrait(dataPointTrait, dataPointController, plotController) {},
    detachDataPointTrait(dataPointTrait, dataPointController, plotController) {},
    controllerWillAttachDataPointView(dataPointView, dataPointController, plotController) {
      this.owner.callObservers("controllerWillAttachDataPointView", dataPointView, dataPointController, plotController, this.owner);
      this.attachDataPointView(dataPointView, dataPointController, plotController);
    },
    controllerDidDetachDataPointView(dataPointView, dataPointController, plotController) {
      this.detachDataPointView(dataPointView, dataPointController, plotController);
      this.owner.callObservers("controllerDidDetachDataPointView", dataPointView, dataPointController, plotController, this.owner);
    },
    attachDataPointView(dataPointView, dataPointController, plotController) {
      const labelView = dataPointView.label.view;
      if (labelView !== null) {
        this.attachDataPointLabelView(labelView, dataPointController, plotController);
      }
    },
    detachDataPointView(dataPointView, dataPointController, plotController) {
      const labelView = dataPointView.label.view;
      if (labelView !== null) {
        this.detachDataPointLabelView(labelView, dataPointController, plotController);
      }
    },
    controllerWillAttachDataPointLabelView(labelView, dataPointController, plotController) {
      this.owner.callObservers("controllerWillAttachDataPointLabelView", labelView, dataPointController, plotController, this.owner);
      this.attachDataPointLabelView(labelView, dataPointController, plotController);
    },
    controllerDidDetachDataPointLabelView(labelView, dataPointController, plotController) {
      this.detachDataPointLabelView(labelView, dataPointController, plotController);
      this.owner.callObservers("controllerDidDetachDataPointLabelView", labelView, dataPointController, plotController, this.owner);
    },
    attachDataPointLabelView(dataPointLabelView, dataPointController, plotController) {},
    detachDataPointLabelView(dataPointLabelView, dataPointController, plotController) {},
    createController(plotTrait) {
      if (plotTrait !== void 0) {
        return PlotController.fromTrait(plotTrait);
      } else {
        return TraitViewControllerSet.prototype.createController.call(this);
      }
    }
  }) ], GraphController.prototype, "plots", void 0);
  const ERROR_10 = Math.sqrt(50);
  const ERROR_5 = Math.sqrt(10);
  const ERROR_2 = Math.sqrt(2);
  const SECOND = 1e3;
  const MINUTE = 60 * SECOND;
  const HOUR = 60 * MINUTE;
  const DAY = 24 * HOUR;
  const WEEK = 7 * DAY;
  const MONTH = 30 * DAY;
  const YEAR = 365 * DAY;
  const TIME_TICK_INTERVALS = (new collections.BTree).set(SECOND, time.TimeInterval.second).set(5 * SECOND, time.TimeInterval.second.every(5)).set(15 * SECOND, time.TimeInterval.second.every(15)).set(30 * SECOND, time.TimeInterval.second.every(30)).set(MINUTE, time.TimeInterval.minute).set(5 * MINUTE, time.TimeInterval.minute.every(5)).set(15 * MINUTE, time.TimeInterval.minute.every(15)).set(30 * MINUTE, time.TimeInterval.minute.every(30)).set(HOUR, time.TimeInterval.hour).set(3 * HOUR, time.TimeInterval.hour.every(3)).set(6 * HOUR, time.TimeInterval.hour.every(6)).set(12 * HOUR, time.TimeInterval.hour.every(12)).set(DAY, time.TimeInterval.day).set(2 * DAY, time.TimeInterval.day.every(2)).set(WEEK, time.TimeInterval.week).set(MONTH, time.TimeInterval.month).set(3 * MONTH, time.TimeInterval.month.every(3)).set(YEAR, time.TimeInterval.year);
  const MILLISECOND_FORMAT = time.DateTimeFormat.pattern(".%L");
  const SECOND_FORMAT = time.DateTimeFormat.pattern(":%S");
  const MINUTE_FORMAT = time.DateTimeFormat.pattern("%I:%M");
  const HOUR_FORMAT = time.DateTimeFormat.pattern("%I %p");
  const WEEKDAY_FORMAT = time.DateTimeFormat.pattern("%a %d");
  const MONTHDAY_FORMAT = time.DateTimeFormat.pattern("%b %d");
  const MONTH_FORMAT = time.DateTimeFormat.pattern("%B");
  const YEAR_FORMAT = time.DateTimeFormat.pattern("%Y");
  class TickGenerator {
    format(tickValue) {
      return "" + tickValue;
    }
    static fromScale(scale, n) {
      if (n === void 0) {
        n = 10;
      }
      if (scale instanceof time.TimeScale) {
        const domain = scale.domain;
        return new TimeTickGenerator(domain[0], domain[1], n);
      } else if (scale instanceof util.LinearScale) {
        const domain = scale.domain;
        return new NumberTickGenerator(domain[0], domain[1], n);
      } else {
        throw new TypeError("" + scale);
      }
    }
    static step(dx, n) {
      const step0 = Math.abs(dx) / n;
      let step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10));
      const error = step0 / step1;
      if (error >= ERROR_10) {
        step1 *= 10;
      } else if (error >= ERROR_5) {
        step1 *= 5;
      } else if (error >= ERROR_2) {
        step1 *= 2;
      }
      return dx < 0 ? -step1 : step1;
    }
  }
  class NumberTickGenerator extends TickGenerator {
    constructor(x0, x1, n) {
      super();
      this.x0 = x0;
      this.dx = x1 - this.x0;
      this.n = Math.max(0, n);
    }
    count(n) {
      if (n === void 0) {
        return this.n;
      } else {
        this.n = Math.max(0, n);
        return this;
      }
    }
    domain(x0, x1) {
      if (x0 === void 0) {
        return util.LinearDomain(this.x0, this.x0 + this.dx);
      } else if (x1 === void 0) {
        this.x0 = x0[0];
        this.dx = x0[1] - this.x0;
        return this;
      } else {
        this.x0 = x0;
        this.dx = x1 - this.x0;
        return this;
      }
    }
    generate() {
      let x0;
      let x1;
      if (this.dx < 0) {
        x1 = this.x0;
        x0 = x1 + this.dx;
      } else {
        x0 = this.x0;
        x1 = x0 + this.dx;
      }
      const step = NumberTickGenerator.interval(x1 - x0, this.n);
      if (step === 0 || !isFinite(step)) {
        return [];
      }
      let ticks;
      if (step > 0) {
        x0 = Math.ceil(x0 / step);
        x1 = Math.floor(x1 / step);
        const n = Math.ceil(x1 - x0 + 1);
        ticks = new Array(n);
        for (let i = 0; i < n; i += 1) {
          ticks[i] = (x0 + i) * step;
        }
      } else {
        x0 = Math.floor(x0 * step);
        x1 = Math.ceil(x1 * step);
        const n = Math.ceil(x0 - x1 + 1);
        ticks = new Array(n);
        for (let i = 0; i < n; i += 1) {
          ticks[i] = (x0 - i) / step;
        }
      }
      if (this.dx < 0) {
        ticks.reverse();
      }
      return ticks;
    }
    static interval(dx, n = 10) {
      const step = dx / n;
      const power = Math.floor(Math.log(step) / Math.LN10);
      const power10 = Math.pow(10, power);
      const error = step / power10;
      const base = error >= ERROR_10 ? 10 : error >= ERROR_5 ? 5 : error >= ERROR_2 ? 2 : 1;
      return power >= 0 ? power10 * base : -Math.pow(10, -power) / base;
    }
  }
  class TimeTickGenerator extends TickGenerator {
    constructor(t0, t1, n, zone) {
      super();
      const d0 = time.DateTime.fromAny(t0);
      const d1 = time.DateTime.fromAny(t1);
      this.t0 = d0.time;
      this.dt = d1.time - this.t0;
      this.zone = zone !== void 0 ? zone : d0.zone;
      this.n = Math.max(0, n);
    }
    count(n) {
      if (n === void 0) {
        return this.n;
      } else {
        this.n = Math.max(0, n);
        return this;
      }
    }
    domain(d0, d1) {
      if (d0 === void 0) {
        return time.TimeDomain(new time.DateTime(this.t0, this.zone), new time.DateTime(this.t0 + this.dt, this.zone));
      } else {
        if (d1 === void 0) {
          d1 = d0[1];
          d0 = d0[0];
        } else {
          d0 = d0;
        }
        d0 = time.DateTime.fromAny(d0);
        d1 = time.DateTime.fromAny(d1);
        this.t0 = d0.time;
        this.dt = d1.time - this.t0;
        return this;
      }
    }
    generate(interval) {
      let t0;
      let t1;
      if (this.dt < 0) {
        t1 = this.t0;
        t0 = t1 + this.dt;
      } else {
        t0 = this.t0;
        t1 = t0 + this.dt;
      }
      if (interval === void 0) {
        interval = this.n;
      }
      interval = TimeTickGenerator.interval(t1 - t0, interval);
      const ticks = interval.range(new time.DateTime(t0, this.zone), new time.DateTime(t1 + 1, this.zone));
      if (this.dt < 0) {
        ticks.reverse();
      }
      return ticks;
    }
    format(tickValue) {
      if (time.TimeInterval.second.floor(tickValue) < tickValue) {
        return MILLISECOND_FORMAT.format(tickValue);
      } else if (time.TimeInterval.minute.floor(tickValue) < tickValue) {
        return SECOND_FORMAT.format(tickValue);
      } else if (time.TimeInterval.hour.floor(tickValue) < tickValue) {
        return MINUTE_FORMAT.format(tickValue);
      } else if (time.TimeInterval.day.floor(tickValue) < tickValue) {
        return HOUR_FORMAT.format(tickValue);
      } else if (time.TimeInterval.month.floor(tickValue) < tickValue) {
        if (time.TimeInterval.week.floor(tickValue) < tickValue) {
          return WEEKDAY_FORMAT.format(tickValue);
        } else {
          return MONTHDAY_FORMAT.format(tickValue);
        }
      } else if (time.TimeInterval.year.floor(tickValue) < tickValue) {
        return MONTH_FORMAT.format(tickValue);
      } else {
        return YEAR_FORMAT.format(tickValue);
      }
    }
    static interval(dt, interval = 10) {
      if (typeof interval === "number") {
        const t = Math.abs(dt) / interval;
        const duration = TIME_TICK_INTERVALS.nextKey(t);
        if (duration === void 0) {
          const k = TickGenerator.step(dt / YEAR, interval);
          interval = time.TimeInterval.year.every(k);
        } else if (duration > SECOND) {
          if (t / TIME_TICK_INTERVALS.previousKey(t) < duration / t) {
            interval = TIME_TICK_INTERVALS.previousValue(t);
          } else {
            interval = TIME_TICK_INTERVALS.nextValue(t);
          }
        } else {
          const k = Math.max(1, TickGenerator.step(dt, interval));
          interval = time.TimeInterval.millisecond.every(k);
        }
      }
      return interval;
    }
  }
  exports.TickState = void 0;
  (function(TickState) {
    TickState[TickState["Excluded"] = 0] = "Excluded";
    TickState[TickState["Entering"] = 1] = "Entering";
    TickState[TickState["Included"] = 2] = "Included";
    TickState[TickState["Leaving"] = 3] = "Leaving";
  })(exports.TickState || (exports.TickState = {}));
  class TickView extends GraphicsView {
    constructor(value) {
      super();
      this.value = value;
      this.offset = 0;
      this.tickState = 0;
      this.preserved = true;
    }
    setOffset(offset) {
      this.offset = offset;
    }
    preserve(preserve) {
      if (preserve === void 0) {
        return this.preserved;
      } else {
        this.preserved = preserve;
        return this;
      }
    }
    fadeIn(timing) {
      if (this.tickState === 0 || this.tickState === 3) {
        this.opacity.setState(1, timing);
        this.tickState = 1;
      }
    }
    fadeOut(timing) {
      if (this.tickState === 1 || this.tickState === 2) {
        this.opacity.setState(0, timing);
        this.tickState = 3;
      }
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      const labelView = this.label.view;
      if (labelView !== null) {
        this.layoutLabel(labelView);
      }
    }
    willRender(viewContext) {
      super.willRender(viewContext);
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer) {
        const context = renderer.context;
        TickView.globalAlpha = context.globalAlpha;
        context.globalAlpha = this.opacity.getValue();
      }
    }
    onRender(viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof PaintingRenderer && !this.hidden && !this.culled) {
        this.renderTick(renderer.context, this.viewFrame);
      }
    }
    didRender(viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer) {
        const context = renderer.context;
        context.globalAlpha = TickView.globalAlpha;
        TickView.globalAlpha = NaN;
      }
      super.didRender(viewContext);
    }
    init(init) {
      super.init(init);
      if (init.tickMarkColor !== void 0) {
        this.tickMarkColor(init.tickMarkColor);
      }
      if (init.tickMarkWidth !== void 0) {
        this.tickMarkWidth(init.tickMarkWidth);
      }
      if (init.tickMarkLength !== void 0) {
        this.tickMarkLength(init.tickMarkLength);
      }
      if (init.tickLabelPadding !== void 0) {
        this.tickLabelPadding(init.tickLabelPadding);
      }
      if (init.gridLineColor !== void 0) {
        this.gridLineColor(init.gridLineColor);
      }
      if (init.gridLineWidth !== void 0) {
        this.gridLineWidth(init.gridLineWidth);
      }
      if (init.font !== void 0) {
        this.font(init.font);
      }
      if (init.textColor !== void 0) {
        this.textColor(init.textColor);
      }
      if (init.label !== void 0) {
        this.label(init.label);
      }
    }
    static top(value) {
      return new TopTickView(value);
    }
    static right(value) {
      return new RightTickView(value);
    }
    static bottom(value) {
      return new BottomTickView(value);
    }
    static left(value) {
      return new LeftTickView(value);
    }
    static from(value, orientation) {
      if (orientation === "top") {
        return this.top(value);
      } else if (orientation === "right") {
        return this.right(value);
      } else if (orientation === "bottom") {
        return this.bottom(value);
      } else if (orientation === "left") {
        return this.left(value);
      } else {
        throw new TypeError(orientation);
      }
    }
    static fromInit(init, orientation) {
      if (init.orientation !== void 0) {
        orientation = init.orientation;
      }
      if (orientation === void 0) {
        throw new TypeError;
      }
      const view = this.from(init.value, orientation);
      view.init(init);
      return view;
    }
    static fromAny(value, orientation) {
      if (value === void 0 || value === null) {
        return value;
      } else if (value instanceof View) {
        if (value instanceof this) {
          return value;
        } else {
          throw new TypeError(value + " not an instance of " + this);
        }
      } else {
        return this.fromInit(value, orientation);
      }
    }
  }
  TickView.globalAlpha = NaN;
  __decorate([ component.Animator({
    type: math.R2Point,
    value: math.R2Point.origin(),
    updateFlags: View.NeedsRender
  }) ], TickView.prototype, "anchor", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    value: 1,
    updateFlags: View.NeedsRender
  }) ], TickView.prototype, "opacity", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    inherits: true,
    value: null,
    updateFlags: View.NeedsRender
  }) ], TickView.prototype, "tickMarkColor", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    inherits: true,
    value: 1,
    updateFlags: View.NeedsRender
  }) ], TickView.prototype, "tickMarkWidth", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    inherits: true,
    value: 6,
    updateFlags: View.NeedsRender
  }) ], TickView.prototype, "tickMarkLength", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    inherits: true,
    value: 2,
    updateFlags: View.NeedsRender
  }) ], TickView.prototype, "tickLabelPadding", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    inherits: true,
    value: null,
    updateFlags: View.NeedsRender
  }) ], TickView.prototype, "gridLineColor", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    inherits: true,
    value: 0,
    updateFlags: View.NeedsRender
  }) ], TickView.prototype, "gridLineWidth", void 0);
  __decorate([ ThemeAnimator({
    type: Font,
    inherits: true,
    value: null
  }) ], TickView.prototype, "font", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    inherits: true,
    value: null
  }) ], TickView.prototype, "textColor", void 0);
  __decorate([ ViewRef({
    key: true,
    type: TextRunView,
    binds: true,
    willAttachView(labelView) {
      this.owner.callObservers("viewWillAttachTickLabel", labelView, this.owner);
    },
    didDetachView(labelView) {
      this.owner.callObservers("viewDidDetachTickLabel", labelView, this.owner);
    },
    fromAny(value) {
      if (typeof value === "string") {
        if (this.view instanceof TextRunView) {
          this.view.text(value);
          return this.view;
        } else {
          return TextRunView.fromAny(value);
        }
      } else {
        return GraphicsView.fromAny(value);
      }
    }
  }) ], TickView.prototype, "label", void 0);
  class TopTickView extends TickView {
    constructor(value) {
      super(value);
    }
    get orientation() {
      return "top";
    }
    layoutLabel(labelView) {
      const anchor = this.anchor.getValue();
      const x = Math.round(anchor.x);
      const y0 = Math.round(anchor.y);
      const y1 = y0 - this.tickMarkLength.getValue();
      const y2 = y1 - this.tickLabelPadding.getValue();
      if (TypesetView.is(labelView)) {
        labelView.textAlign.setState("center", component.Affinity.Intrinsic);
        labelView.textBaseline.setState("bottom", component.Affinity.Intrinsic);
        labelView.textOrigin.setState(new math.R2Point(x, y2), component.Affinity.Intrinsic);
      }
    }
    renderTick(context, frame) {
      const anchor = this.anchor.getValue();
      const x = Math.round(anchor.x);
      const y0 = Math.round(anchor.y);
      const tickMarkLength = this.tickMarkLength.getValue();
      const y1 = y0 - tickMarkLength;
      const contextLineWidth = context.lineWidth;
      const contextStrokeStyle = context.strokeStyle;
      const tickMarkColor = this.tickMarkColor.value;
      const tickMarkWidth = this.tickMarkWidth.getValue();
      if (tickMarkColor !== null && tickMarkWidth !== 0 && tickMarkLength !== 0) {
        context.beginPath();
        context.lineWidth = tickMarkWidth;
        context.strokeStyle = tickMarkColor.toString();
        context.moveTo(x, y0);
        context.lineTo(x, y1);
        context.stroke();
      }
      const gridLineColor = this.gridLineColor.value;
      const gridLineWidth = this.gridLineWidth.getValue();
      if (gridLineColor !== null && gridLineWidth !== 0 && frame.xMin < x && x < frame.xMax) {
        context.beginPath();
        context.lineWidth = gridLineWidth;
        context.strokeStyle = gridLineColor.toString();
        context.moveTo(x, y0);
        context.lineTo(x, frame.yMax);
        context.stroke();
      }
      context.lineWidth = contextLineWidth;
      context.strokeStyle = contextStrokeStyle;
    }
  }
  class RightTickView extends TickView {
    constructor(value) {
      super(value);
    }
    get orientation() {
      return "right";
    }
    layoutLabel(labelView) {
      const anchor = this.anchor.getValue();
      const x0 = Math.round(anchor.x);
      const y = Math.round(anchor.y);
      const x1 = x0 + this.tickMarkLength.getValue();
      const x2 = x1 + this.tickLabelPadding.getValue();
      if (TypesetView.is(labelView)) {
        labelView.textAlign.setState("left", component.Affinity.Intrinsic);
        labelView.textBaseline.setState("middle", component.Affinity.Intrinsic);
        labelView.textOrigin.setState(new math.R2Point(x2, y), component.Affinity.Intrinsic);
      }
    }
    renderTick(context, frame) {
      const anchor = this.anchor.getValue();
      const x0 = Math.round(anchor.x);
      const y = Math.round(anchor.y);
      const tickMarkLength = this.tickMarkLength.getValue();
      const x1 = x0 + tickMarkLength;
      const contextLineWidth = context.lineWidth;
      const contextStrokeStyle = context.strokeStyle;
      const tickMarkColor = this.tickMarkColor.value;
      const tickMarkWidth = this.tickMarkWidth.getValue();
      if (tickMarkColor !== null && tickMarkWidth !== 0 && tickMarkLength !== 0) {
        context.beginPath();
        context.lineWidth = tickMarkWidth;
        context.strokeStyle = tickMarkColor.toString();
        context.moveTo(x0, y);
        context.lineTo(x1, y);
        context.stroke();
      }
      const gridLineColor = this.gridLineColor.value;
      const gridLineWidth = this.gridLineWidth.getValue();
      if (gridLineColor !== null && gridLineWidth !== 0 && frame.yMin < y && y < frame.yMax) {
        context.beginPath();
        context.lineWidth = gridLineWidth;
        context.strokeStyle = gridLineColor.toString();
        context.moveTo(x0, y);
        context.lineTo(frame.xMin, y);
        context.stroke();
      }
      context.lineWidth = contextLineWidth;
      context.strokeStyle = contextStrokeStyle;
    }
  }
  class BottomTickView extends TickView {
    constructor(value) {
      super(value);
    }
    get orientation() {
      return "bottom";
    }
    layoutLabel(labelView) {
      const anchor = this.anchor.getValue();
      const x = Math.round(anchor.x);
      const y0 = Math.round(anchor.y);
      const y1 = y0 + this.tickMarkLength.getValue();
      const y2 = y1 + this.tickLabelPadding.getValue();
      if (TypesetView.is(labelView)) {
        labelView.textAlign.setState("center", component.Affinity.Intrinsic);
        labelView.textBaseline.setState("top", component.Affinity.Intrinsic);
        labelView.textOrigin.setState(new math.R2Point(x, y2), component.Affinity.Intrinsic);
      }
    }
    renderTick(context, frame) {
      const anchor = this.anchor.getValue();
      const x = Math.round(anchor.x);
      const y0 = Math.round(anchor.y);
      const tickMarkLength = this.tickMarkLength.getValue();
      const y1 = y0 + tickMarkLength;
      const contextLineWidth = context.lineWidth;
      const contextStrokeStyle = context.strokeStyle;
      const tickMarkColor = this.tickMarkColor.value;
      const tickMarkWidth = this.tickMarkWidth.getValue();
      if (tickMarkColor !== null && tickMarkWidth !== 0 && tickMarkLength !== 0) {
        context.beginPath();
        context.lineWidth = tickMarkWidth;
        context.strokeStyle = tickMarkColor.toString();
        context.moveTo(x, y0);
        context.lineTo(x, y1);
        context.stroke();
      }
      const gridLineColor = this.gridLineColor.value;
      const gridLineWidth = this.gridLineWidth.getValue();
      if (gridLineColor !== null && gridLineWidth !== 0 && frame.xMin < x && x < frame.xMax) {
        context.beginPath();
        context.lineWidth = gridLineWidth;
        context.strokeStyle = gridLineColor.toString();
        context.moveTo(x, y0);
        context.lineTo(x, frame.yMin);
        context.stroke();
      }
      context.lineWidth = contextLineWidth;
      context.strokeStyle = contextStrokeStyle;
    }
  }
  class LeftTickView extends TickView {
    constructor(value) {
      super(value);
    }
    get orientation() {
      return "left";
    }
    layoutLabel(labelView) {
      const anchor = this.anchor.getValue();
      const x0 = Math.round(anchor.x);
      const y = Math.round(anchor.y);
      const x1 = x0 - this.tickMarkLength.getValue();
      const x2 = x1 - this.tickLabelPadding.getValue();
      if (TypesetView.is(labelView)) {
        labelView.textAlign.setState("right", component.Affinity.Intrinsic);
        labelView.textBaseline.setState("middle", component.Affinity.Intrinsic);
        labelView.textOrigin.setState(new math.R2Point(x2, y), component.Affinity.Intrinsic);
      }
    }
    renderTick(context, frame) {
      const anchor = this.anchor.getValue();
      const x0 = Math.round(anchor.x);
      const y = Math.round(anchor.y);
      const tickMarkLength = this.tickMarkLength.getValue();
      const x1 = x0 - tickMarkLength;
      const contextLineWidth = context.lineWidth;
      const contextStrokeStyle = context.strokeStyle;
      const tickMarkColor = this.tickMarkColor.value;
      const tickMarkWidth = this.tickMarkWidth.getValue();
      if (tickMarkColor !== null && tickMarkWidth !== 0 && tickMarkLength !== 0) {
        context.beginPath();
        context.strokeStyle = tickMarkColor.toString();
        context.lineWidth = tickMarkWidth;
        context.moveTo(x0, y);
        context.lineTo(x1, y);
        context.stroke();
      }
      const gridLineColor = this.gridLineColor.value;
      const gridLineWidth = this.gridLineWidth.getValue();
      if (gridLineColor !== null && gridLineWidth !== 0 && frame.yMin < y && y < frame.yMax) {
        context.beginPath();
        context.lineWidth = gridLineWidth;
        context.strokeStyle = gridLineColor.toString();
        context.moveTo(x0, y);
        context.lineTo(frame.xMax, y);
        context.stroke();
      }
      context.lineWidth = contextLineWidth;
      context.strokeStyle = contextStrokeStyle;
    }
  }
  class AxisView extends GraphicsView {
    constructor() {
      super();
      this.ticks = new collections.BTree;
    }
    getTick(value) {
      const tickView = this.ticks.get(value);
      return tickView !== void 0 ? tickView : null;
    }
    insertTick(tickView) {
      return this.insertChild(TickView.fromAny(tickView, this.orientation), null);
    }
    removeTick(value) {
      const tickView = this.getTick(value);
      if (tickView !== null) {
        tickView.remove();
      }
      return tickView;
    }
    updateTicks() {
      const scale = this.scale.value;
      let tickGenerator = this.tickGenerator.value;
      if (scale !== null && tickGenerator !== null) {
        let timing = this.tickTransition.value;
        if (tickGenerator === true) {
          tickGenerator = TickGenerator.fromScale(scale);
          this.tickGenerator.setValue(tickGenerator);
          timing = false;
        }
        this.generateTicks(tickGenerator, scale, timing);
      }
    }
    generateTicks(tickGenerator, scale, timing) {
      const tickMarkSpacing = this.tickMarkSpacing.getValue();
      if (tickMarkSpacing !== 0) {
        const range = scale.range;
        const dy = Math.abs(range[1] - range[0]);
        const n = Math.max(1, Math.floor(dy / tickMarkSpacing));
        tickGenerator.count(n);
      }
      tickGenerator.domain(scale.domain);
      const oldTicks = this.ticks.clone();
      const tickValues = tickGenerator.generate();
      for (let i = 0, n = tickValues.length; i < n; i += 1) {
        const tickValue = tickValues[i];
        const oldTick = oldTicks.get(tickValue);
        if (oldTick !== void 0) {
          oldTicks.delete(tickValue);
          oldTick.fadeIn(timing);
        } else {
          const newTick = this.createTickView(tickValue);
          if (newTick !== null) {
            this.appendChild(newTick);
            newTick.opacity.setInterpolatedValue(0, 0);
            newTick.fadeIn(timing);
          }
        }
      }
      oldTicks.forEachValue((function(oldTick) {
        if (!oldTick.preserved) {
          oldTick.fadeOut(timing);
        }
      }), this);
    }
    createTickView(tickValue) {
      const tickView = TickView.from(tickValue, this.orientation);
      if (tickView !== null) {
        const tickLabel = this.createTickLabel(tickValue, tickView);
        if (tickLabel !== null) {
          tickView.label(tickLabel);
          tickView.preserve(false);
        }
      }
      return tickView;
    }
    createTickLabel(tickValue, tickView) {
      let tickLabel = null;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n && (tickLabel === void 0 || tickLabel === null); i += 1) {
        const observer = observers[i];
        if (observer.createTickLabel !== void 0) {
          tickLabel = observer.createTickLabel(tickValue, tickView, this);
        }
      }
      if (tickLabel === void 0 || tickLabel === null) {
        const tickGenerator = this.tickGenerator.value;
        if (tickGenerator instanceof TickGenerator) {
          tickLabel = tickGenerator.format(tickValue);
        } else {
          tickLabel = "" + tickValue;
        }
      }
      if (typeof tickLabel === "string") {
        tickLabel = this.formatTickLabel(tickLabel, tickView);
      }
      return tickLabel;
    }
    formatTickLabel(tickLabel, tickView) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.formatTickLabel !== void 0) {
          const label = observer.formatTickLabel(tickLabel, tickView, this);
          if (label !== void 0) {
            return label;
          }
        }
      }
      return tickLabel;
    }
    onInsertChild(child, target) {
      super.onInsertChild(child, target);
      if (child instanceof TickView && this.ticks.get(child.value) !== child) {
        this.ticks.set(child.value, child);
      }
    }
    onRemoveChild(child) {
      super.onRemoveChild(child);
      if (child instanceof TickView && this.ticks.get(child.value) === child) {
        this.ticks.delete(child.value);
      }
    }
    needsDisplay(displayFlags, viewContext) {
      if ((this.flags & View.NeedsLayout) === 0) {
        displayFlags &= ~View.NeedsLayout;
      }
      return displayFlags;
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      this.scale.recohere(viewContext.updateTime);
      this.updateTicks();
    }
    displayChild(child, displayFlags, viewContext) {
      if ((displayFlags & View.NeedsLayout) !== 0 && child instanceof TickView) {
        const scale = this.scale.value;
        if (scale !== null) {
          this.layoutTick(child, this.origin.getValue(), this.viewFrame, scale);
        }
      }
      super.displayChild(child, displayFlags, viewContext);
    }
    didRender(viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof PaintingRenderer) {
        this.renderDomain(renderer.context, this.origin.getValue(), this.viewFrame);
      }
      super.didRender(viewContext);
    }
    init(init) {
      super.init(init);
      if (init.scale !== void 0) {
        this.scale(init.scale);
      }
      const ticks = init.ticks;
      if (ticks !== void 0) {
        for (let i = 0, n = ticks.length; i < n; i += 1) {
          this.appendChild(TickView.fromAny(ticks[i]));
        }
      }
      if (init.tickGenerator !== void 0) {
        this.tickGenerator(init.tickGenerator);
      }
      if (init.borderColor !== void 0) {
        this.borderColor(init.borderColor);
      }
      if (init.borderWidth !== void 0) {
        this.borderWidth(init.borderWidth);
      }
      if (init.borderSerif !== void 0) {
        this.borderSerif(init.borderSerif);
      }
      if (init.tickMarkSpacing !== void 0) {
        this.tickMarkSpacing(init.tickMarkSpacing);
      }
      if (init.tickMarkColor !== void 0) {
        this.tickMarkColor(init.tickMarkColor);
      }
      if (init.tickMarkWidth !== void 0) {
        this.tickMarkWidth(init.tickMarkWidth);
      }
      if (init.tickMarkLength !== void 0) {
        this.tickMarkLength(init.tickMarkLength);
      }
      if (init.tickLabelPadding !== void 0) {
        this.tickLabelPadding(init.tickLabelPadding);
      }
      if (init.tickTransition !== void 0) {
        this.tickTransition(init.tickTransition);
      }
      if (init.gridLineColor !== void 0) {
        this.gridLineColor(init.gridLineColor);
      }
      if (init.gridLineWidth !== void 0) {
        this.gridLineWidth(init.gridLineWidth);
      }
      if (init.font !== void 0) {
        this.font(init.font);
      }
      if (init.textColor !== void 0) {
        this.textColor(init.textColor);
      }
    }
  }
  __decorate([ component.Property({
    type: TickGenerator,
    value: true
  }) ], AxisView.prototype, "tickGenerator", void 0);
  __decorate([ ThemeAnimator({
    type: math.R2Point,
    value: math.R2Point.origin(),
    updateFlags: View.NeedsLayout | View.NeedsRender
  }) ], AxisView.prototype, "origin", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    inherits: true,
    value: null,
    updateFlags: View.NeedsRender
  }) ], AxisView.prototype, "borderColor", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    inherits: true,
    value: 1,
    updateFlags: View.NeedsRender
  }) ], AxisView.prototype, "borderWidth", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    inherits: true,
    value: 6,
    updateFlags: View.NeedsRender
  }) ], AxisView.prototype, "borderSerif", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    value: 80,
    updateFlags: View.NeedsRender
  }) ], AxisView.prototype, "tickMarkSpacing", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    inherits: true,
    value: null,
    updateFlags: View.NeedsRender
  }) ], AxisView.prototype, "tickMarkColor", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    inherits: true,
    value: 1,
    updateFlags: View.NeedsRender
  }) ], AxisView.prototype, "tickMarkWidth", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    inherits: true,
    value: 6,
    updateFlags: View.NeedsRender
  }) ], AxisView.prototype, "tickMarkLength", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    inherits: true,
    value: 2,
    updateFlags: View.NeedsRender
  }) ], AxisView.prototype, "tickLabelPadding", void 0);
  __decorate([ component.Property({
    type: util.Timing,
    inherits: true,
    initValue() {
      return util.Easing.cubicOut.withDuration(250);
    }
  }) ], AxisView.prototype, "tickTransition", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    inherits: true,
    value: null,
    updateFlags: View.NeedsRender
  }) ], AxisView.prototype, "gridLineColor", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    inherits: true,
    value: 0,
    updateFlags: View.NeedsRender
  }) ], AxisView.prototype, "gridLineWidth", void 0);
  __decorate([ ThemeAnimator({
    type: Font,
    inherits: true,
    value: null,
    updateFlags: View.NeedsRender
  }) ], AxisView.prototype, "font", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    inherits: true,
    value: null,
    updateFlags: View.NeedsRender
  }) ], AxisView.prototype, "textColor", void 0);
  class TopAxisView extends AxisView {
    get orientation() {
      return "top";
    }
    layoutTick(tick, origin, frame, scale) {
      if (tick.anchor.hasAffinity(component.Affinity.Intrinsic)) {
        const offset = scale(tick.value);
        tick.setOffset(offset);
        tick.anchor.setState(new math.R2Point(frame.xMin + offset, origin.y), component.Affinity.Intrinsic);
      }
    }
    renderDomain(context, origin, frame) {
      const borderColor = this.borderColor.value;
      const borderWidth = this.borderWidth.getValue();
      if (borderColor !== null && borderWidth !== 0) {
        const x0 = frame.xMin;
        const x1 = frame.xMax;
        const y = origin.y;
        const dy = this.borderSerif.getValue();
        const contextLineWidth = context.lineWidth;
        const contextStrokeStyle = context.strokeStyle;
        context.beginPath();
        context.lineWidth = borderWidth;
        context.strokeStyle = borderColor.toString();
        if (dy !== 0) {
          context.moveTo(x0, y - dy);
          context.lineTo(x0, y);
          context.lineTo(x1, y);
          context.lineTo(x1, y - dy);
        } else {
          context.moveTo(x0, y);
          context.lineTo(x1, y);
        }
        context.stroke();
        context.lineWidth = contextLineWidth;
        context.strokeStyle = contextStrokeStyle;
      }
    }
  }
  __decorate([ component.Animator({
    extends: ContinuousScaleAnimator,
    type: util.ContinuousScale,
    inherits: "xScale",
    value: null,
    updateFlags: View.NeedsLayout
  }) ], TopAxisView.prototype, "scale", void 0);
  class RightAxisView extends AxisView {
    get orientation() {
      return "right";
    }
    layoutTick(tick, origin, frame, scale) {
      if (tick.anchor.hasAffinity(component.Affinity.Intrinsic)) {
        const offset = scale(tick.value);
        tick.setOffset(offset);
        tick.anchor.setState(new math.R2Point(origin.x, frame.yMin + offset), component.Affinity.Intrinsic);
      }
    }
    renderDomain(context, origin, frame) {
      const borderColor = this.borderColor.value;
      const borderWidth = this.borderWidth.getValue();
      if (borderColor !== null && borderWidth !== 0) {
        const x = origin.x;
        const dx = this.borderSerif.getValue();
        const y0 = frame.yMin;
        const y1 = frame.yMax;
        const contextLineWidth = context.lineWidth;
        const contextStrokeStyle = context.strokeStyle;
        context.beginPath();
        context.lineWidth = borderWidth;
        context.strokeStyle = borderColor.toString();
        if (dx !== 0) {
          context.moveTo(x + dx, y0);
          context.lineTo(x, y0);
          context.lineTo(x, y1);
          context.lineTo(x + dx, y1);
        } else {
          context.moveTo(x, y0);
          context.lineTo(x, y1);
        }
        context.stroke();
        context.lineWidth = contextLineWidth;
        context.strokeStyle = contextStrokeStyle;
      }
    }
  }
  __decorate([ component.Animator({
    extends: ContinuousScaleAnimator,
    type: util.ContinuousScale,
    inherits: "yScale",
    value: null,
    updateFlags: View.NeedsLayout
  }) ], RightAxisView.prototype, "scale", void 0);
  class BottomAxisView extends AxisView {
    get orientation() {
      return "bottom";
    }
    layoutTick(tick, origin, frame, scale) {
      if (tick.anchor.hasAffinity(component.Affinity.Intrinsic)) {
        const offset = scale(tick.value);
        tick.setOffset(offset);
        tick.anchor.setState(new math.R2Point(frame.xMin + offset, origin.y), component.Affinity.Intrinsic);
      }
    }
    renderDomain(context, origin, frame) {
      const borderColor = this.borderColor.value;
      const borderWidth = this.borderWidth.getValue();
      if (borderColor !== null && borderWidth !== 0) {
        const x0 = frame.xMin;
        const x1 = frame.xMax;
        const y = origin.y;
        const dy = this.borderSerif.getValue();
        const contextLineWidth = context.lineWidth;
        const contextStrokeStyle = context.strokeStyle;
        context.beginPath();
        context.lineWidth = borderWidth;
        context.strokeStyle = borderColor.toString();
        if (dy !== 0) {
          context.moveTo(x0, y + dy);
          context.lineTo(x0, y);
          context.lineTo(x1, y);
          context.lineTo(x1, y + dy);
        } else {
          context.moveTo(x0, y);
          context.lineTo(x1, y);
        }
        context.stroke();
        context.lineWidth = contextLineWidth;
        context.strokeStyle = contextStrokeStyle;
      }
    }
  }
  __decorate([ component.Animator({
    extends: ContinuousScaleAnimator,
    type: util.ContinuousScale,
    inherits: "xScale",
    value: null,
    updateFlags: View.NeedsLayout
  }) ], BottomAxisView.prototype, "scale", void 0);
  class LeftAxisView extends AxisView {
    get orientation() {
      return "left";
    }
    layoutTick(tick, origin, frame, scale) {
      if (tick.anchor.hasAffinity(component.Affinity.Intrinsic)) {
        const offset = scale(tick.value);
        tick.setOffset(offset);
        tick.anchor.setState(new math.R2Point(origin.x, frame.yMin + offset), component.Affinity.Intrinsic);
      }
    }
    renderDomain(context, origin, frame) {
      const borderColor = this.borderColor.value;
      const borderWidth = this.borderWidth.getValue();
      if (borderColor !== null && borderWidth !== 0) {
        const x = origin.x;
        const dx = this.borderSerif.getValue();
        const y0 = frame.yMin;
        const y1 = frame.yMax;
        const contextLineWidth = context.lineWidth;
        const contextStrokeStyle = context.strokeStyle;
        context.beginPath();
        context.lineWidth = borderWidth;
        context.strokeStyle = borderColor.toString();
        if (dx !== 0) {
          context.moveTo(x - dx, y0);
          context.lineTo(x, y0);
          context.lineTo(x, y1);
          context.lineTo(x - dx, y1);
        } else {
          context.moveTo(x, y0);
          context.lineTo(x, y1);
        }
        context.stroke();
        context.lineWidth = contextLineWidth;
        context.strokeStyle = contextStrokeStyle;
      }
    }
  }
  __decorate([ component.Animator({
    extends: ContinuousScaleAnimator,
    type: util.ContinuousScale,
    inherits: "yScale",
    value: null,
    updateFlags: View.NeedsLayout
  }) ], LeftAxisView.prototype, "scale", void 0);
  class AxisTrait extends Trait {}
  class TopAxisTrait extends AxisTrait {}
  class RightAxisTrait extends AxisTrait {}
  class BottomAxisTrait extends AxisTrait {}
  class LeftAxisTrait extends AxisTrait {}
  class AxisController extends Controller {}
  __decorate([ TraitViewRef({
    traitType: AxisTrait,
    willAttachTrait(axisTrait) {
      this.owner.callObservers("controllerWillAttachAxisTrait", axisTrait, this.owner);
    },
    didDetachTrait(axisTrait) {
      this.owner.callObservers("controllerDidDetachAxisTrait", axisTrait, this.owner);
    },
    viewType: AxisView,
    willAttachView(axisView) {
      this.owner.callObservers("controllerWillAttachAxisView", axisView, this.owner);
    },
    didDetachView(axisView) {
      this.owner.callObservers("controllerDidDetachAxisView", axisView, this.owner);
    }
  }) ], AxisController.prototype, "axis", void 0);
  class TopAxisController extends AxisController {}
  __decorate([ TraitViewRef({
    extends: true,
    traitType: TopAxisTrait,
    viewType: TopAxisView
  }) ], TopAxisController.prototype, "axis", void 0);
  class RightAxisController extends AxisController {}
  __decorate([ TraitViewRef({
    extends: true,
    traitType: RightAxisTrait,
    viewType: RightAxisView
  }) ], RightAxisController.prototype, "axis", void 0);
  class BottomAxisController extends AxisController {}
  __decorate([ TraitViewRef({
    extends: true,
    traitType: BottomAxisTrait,
    viewType: BottomAxisView
  }) ], BottomAxisController.prototype, "axis", void 0);
  class LeftAxisController extends AxisController {}
  __decorate([ TraitViewRef({
    extends: true,
    traitType: LeftAxisTrait,
    viewType: LeftAxisView
  }) ], LeftAxisController.prototype, "axis", void 0);
  class ChartView extends ScaledView {
    xRange() {
      const frame = this.viewFrame;
      const gutterLeft = this.gutterLeft.getValue().pxValue(frame.width);
      const gutterRight = this.gutterRight.getValue().pxValue(frame.width);
      const xRangePadding = this.xRangePadding.value;
      const xRangeMin = xRangePadding[0];
      const xRangeMax = this.viewFrame.width - gutterRight - gutterLeft - xRangePadding[1];
      return util.LinearRange(xRangeMin, xRangeMax);
    }
    yRange() {
      const frame = this.viewFrame;
      const gutterTop = this.gutterTop.getValue().pxValue(frame.height);
      const gutterBottom = this.gutterBottom.getValue().pxValue(frame.height);
      const yRangePadding = this.yRangePadding.value;
      const yRangeMin = yRangePadding[0];
      const yRangeMax = this.viewFrame.height - gutterBottom - gutterTop - yRangePadding[1];
      return util.LinearRange(yRangeMax, yRangeMin);
    }
    updateScales() {
      this.layoutChart(this.viewFrame);
      super.updateScales();
    }
    layoutChart(frame) {
      const gutterTop = this.gutterTop.getValue().pxValue(frame.height);
      const gutterRight = this.gutterRight.getValue().pxValue(frame.width);
      const gutterBottom = this.gutterBottom.getValue().pxValue(frame.height);
      const gutterLeft = this.gutterLeft.getValue().pxValue(frame.width);
      const graphTop = frame.yMin + gutterTop;
      const graphRight = frame.xMax - gutterRight;
      const graphBottom = frame.yMax - gutterBottom;
      const graphLeft = frame.xMin + gutterLeft;
      const topAxisView = this.topAxis.view;
      if (topAxisView !== null) {
        topAxisView.setViewFrame(new math.R2Box(graphLeft, frame.yMin, graphRight, graphBottom));
        topAxisView.origin.setState(new math.R2Point(graphLeft, graphTop), component.Affinity.Intrinsic);
      }
      const rightAxisView = this.rightAxis.view;
      if (rightAxisView !== null) {
        rightAxisView.setViewFrame(new math.R2Box(graphLeft, graphTop, frame.xMax, graphBottom));
        rightAxisView.origin.setState(new math.R2Point(Math.max(graphLeft, graphRight), graphBottom), component.Affinity.Intrinsic);
      }
      const bottomAxisView = this.bottomAxis.view;
      if (bottomAxisView !== null) {
        bottomAxisView.setViewFrame(new math.R2Box(graphLeft, graphTop, graphRight, frame.yMax));
        bottomAxisView.origin.setState(new math.R2Point(graphLeft, Math.max(graphTop, graphBottom)), component.Affinity.Intrinsic);
      }
      const leftAxisView = this.leftAxis.view;
      if (leftAxisView !== null) {
        leftAxisView.setViewFrame(new math.R2Box(frame.xMin, graphTop, graphRight, graphBottom));
        leftAxisView.origin.setState(new math.R2Point(graphLeft, graphBottom), component.Affinity.Intrinsic);
      }
      const graphView = this.graph.view;
      if (graphView !== null) {
        graphView.setViewFrame(new math.R2Box(graphLeft, graphTop, graphRight, graphBottom));
      }
    }
    init(init) {
      super.init(init);
      if (init.graph !== void 0) {
        this.graph(init.graph);
      }
      if (init.topAxis !== void 0) {
        this.topAxis(init.topAxis);
      }
      if (init.rightAxis !== void 0) {
        this.rightAxis(init.rightAxis);
      }
      if (init.bottomAxis !== void 0) {
        this.bottomAxis(init.bottomAxis);
      }
      if (init.leftAxis !== void 0) {
        this.leftAxis(init.leftAxis);
      }
      if (init.gutterTop !== void 0) {
        this.gutterTop(init.gutterTop);
      }
      if (init.gutterRight !== void 0) {
        this.gutterRight(init.gutterRight);
      }
      if (init.gutterBottom !== void 0) {
        this.gutterBottom(init.gutterBottom);
      }
      if (init.gutterLeft !== void 0) {
        this.gutterLeft(init.gutterLeft);
      }
      if (init.borderColor !== void 0) {
        this.borderColor(init.borderColor);
      }
      if (init.borderWidth !== void 0) {
        this.borderWidth(init.borderWidth);
      }
      if (init.borderSerif !== void 0) {
        this.borderSerif(init.borderSerif);
      }
      if (init.tickMarkColor !== void 0) {
        this.tickMarkColor(init.tickMarkColor);
      }
      if (init.tickMarkWidth !== void 0) {
        this.tickMarkWidth(init.tickMarkWidth);
      }
      if (init.tickMarkLength !== void 0) {
        this.tickMarkLength(init.tickMarkLength);
      }
      if (init.tickLabelPadding !== void 0) {
        this.tickLabelPadding(init.tickLabelPadding);
      }
      if (init.tickTransition !== void 0) {
        this.tickTransition(init.tickTransition);
      }
      if (init.gridLineColor !== void 0) {
        this.gridLineColor(init.gridLineColor);
      }
      if (init.gridLineWidth !== void 0) {
        this.gridLineWidth(init.gridLineWidth);
      }
      if (init.font !== void 0) {
        this.font(init.font);
      }
      if (init.textColor !== void 0) {
        this.textColor(init.textColor);
      }
    }
  }
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.px(20)
  }) ], ChartView.prototype, "gutterTop", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.px(40)
  }) ], ChartView.prototype, "gutterRight", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.px(20)
  }) ], ChartView.prototype, "gutterBottom", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.px(40)
  }) ], ChartView.prototype, "gutterLeft", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    look: Look.neutralColor
  }) ], ChartView.prototype, "borderColor", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    value: 1
  }) ], ChartView.prototype, "borderWidth", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    value: 6
  }) ], ChartView.prototype, "borderSerif", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    look: Look.neutralColor
  }) ], ChartView.prototype, "tickMarkColor", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    value: 1
  }) ], ChartView.prototype, "tickMarkWidth", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    value: 6
  }) ], ChartView.prototype, "tickMarkLength", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    value: 2
  }) ], ChartView.prototype, "tickLabelPadding", void 0);
  __decorate([ component.Property({
    type: util.Timing,
    initValue() {
      return util.Easing.cubicOut.withDuration(250);
    }
  }) ], ChartView.prototype, "tickTransition", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    look: Look.subduedColor
  }) ], ChartView.prototype, "gridLineColor", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    value: 0
  }) ], ChartView.prototype, "gridLineWidth", void 0);
  __decorate([ ThemeAnimator({
    type: Font,
    value: null,
    inherits: true
  }) ], ChartView.prototype, "font", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    look: Look.mutedColor
  }) ], ChartView.prototype, "textColor", void 0);
  __decorate([ ViewRef({
    key: true,
    type: GraphView,
    binds: true,
    willAttachView(graphView) {
      this.owner.callObservers("viewWillAttachGraph", graphView, this.owner);
    },
    didDetachView(graphView) {
      this.owner.callObservers("viewDidDetachGraph", graphView, this.owner);
    },
    detectView(view) {
      return view instanceof GraphView ? view : null;
    }
  }) ], ChartView.prototype, "graph", void 0);
  __decorate([ ViewRef({
    key: true,
    type: TopAxisView,
    binds: true,
    willAttachView(topAxisView) {
      this.owner.callObservers("viewWillAttachTopAxis", topAxisView, this.owner);
    },
    didDetachView(topAxisView) {
      this.owner.callObservers("viewDidDetachTopAxis", topAxisView, this.owner);
    },
    detectView(view) {
      return view instanceof TopAxisView ? view : null;
    }
  }) ], ChartView.prototype, "topAxis", void 0);
  __decorate([ ViewRef({
    key: true,
    type: RightAxisView,
    binds: true,
    willAttachView(rightAxisView) {
      this.owner.callObservers("viewWillAttachRightAxis", rightAxisView, this.owner);
    },
    didDetachView(rightAxisView) {
      this.owner.callObservers("viewDidDetachRightAxis", rightAxisView, this.owner);
    },
    detectView(view) {
      return view instanceof RightAxisView ? view : null;
    }
  }) ], ChartView.prototype, "rightAxis", void 0);
  __decorate([ ViewRef({
    key: true,
    type: BottomAxisView,
    binds: true,
    willAttachView(bottomAxisView) {
      this.owner.callObservers("viewWillAttachBottomAxis", bottomAxisView, this.owner);
    },
    didDetachView(bottomAxisView) {
      this.owner.callObservers("viewDidDetachBottomAxis", bottomAxisView, this.owner);
    },
    detectView(view) {
      return view instanceof BottomAxisView ? view : null;
    }
  }) ], ChartView.prototype, "bottomAxis", void 0);
  __decorate([ ViewRef({
    key: true,
    type: LeftAxisView,
    binds: true,
    willAttachView(leftAxisView) {
      this.owner.callObservers("viewWillAttachLeftAxis", leftAxisView, this.owner);
    },
    didDetachView(leftAxisView) {
      this.owner.callObservers("viewDidDetachLeftAxis", leftAxisView, this.owner);
    },
    detectView(view) {
      return view instanceof LeftAxisView ? view : null;
    }
  }) ], ChartView.prototype, "leftAxis", void 0);
  class ChartTrait extends Trait {
    onStartConsuming() {
      super.onStartConsuming();
      const graphTrait = this.graph.trait;
      if (graphTrait !== null) {
        graphTrait.consume(this);
      }
      const topAxisTrair = this.topAxis.trait;
      if (topAxisTrair !== null) {
        topAxisTrair.consume(this);
      }
      const rightAxisTrait = this.rightAxis.trait;
      if (rightAxisTrait !== null) {
        rightAxisTrait.consume(this);
      }
      const bottomAxisTrait = this.bottomAxis.trait;
      if (bottomAxisTrait !== null) {
        bottomAxisTrait.consume(this);
      }
      const leftAxisTrait = this.leftAxis.trait;
      if (leftAxisTrait !== null) {
        leftAxisTrait.consume(this);
      }
    }
    onStopConsuming() {
      super.onStopConsuming();
      const graphTrait = this.graph.trait;
      if (graphTrait !== null) {
        graphTrait.unconsume(this);
      }
      const topAxisTrair = this.topAxis.trait;
      if (topAxisTrair !== null) {
        topAxisTrair.unconsume(this);
      }
      const rightAxisTrait = this.rightAxis.trait;
      if (rightAxisTrait !== null) {
        rightAxisTrait.unconsume(this);
      }
      const bottomAxisTrait = this.bottomAxis.trait;
      if (bottomAxisTrait !== null) {
        bottomAxisTrait.unconsume(this);
      }
      const leftAxisTrait = this.leftAxis.trait;
      if (leftAxisTrait !== null) {
        leftAxisTrait.unconsume(this);
      }
    }
  }
  __decorate([ TraitRef({
    type: GraphTrait,
    binds: true,
    willAttachTrait(graphTrait) {
      this.owner.callObservers("traitWillAttachGraph", graphTrait, this.owner);
    },
    didAttachTrait(graphTrait) {
      if (this.owner.consuming) {
        graphTrait.consume(this.owner);
      }
    },
    willDetachTrait(graphTrait) {
      if (this.owner.consuming) {
        graphTrait.unconsume(this.owner);
      }
    },
    didDetachTrait(graphTrait) {
      this.owner.callObservers("traitDidDetachGraph", graphTrait, this.owner);
    },
    detectModel(model) {
      return model.getTrait(GraphTrait);
    },
    detectTrait(trait) {
      return trait instanceof GraphTrait ? trait : null;
    }
  }) ], ChartTrait.prototype, "graph", void 0);
  __decorate([ TraitRef({
    type: TopAxisTrait,
    binds: true,
    willAttachTrait(topAxisTrait) {
      this.owner.callObservers("traitWillAttachTopAxis", topAxisTrait, this.owner);
    },
    didAttachTrait(topAxisTrait) {
      if (this.owner.consuming) {
        topAxisTrait.consume(this.owner);
      }
    },
    willDetachTrait(topAxisTrait) {
      if (this.owner.consuming) {
        topAxisTrait.unconsume(this.owner);
      }
    },
    didDetachTrait(topAxisTrait) {
      this.owner.callObservers("traitDidDetachTopAxis", topAxisTrait, this.owner);
    },
    detectModel(model) {
      return model.getTrait(TopAxisTrait);
    },
    detectTrait(trait) {
      return trait instanceof TopAxisTrait ? trait : null;
    }
  }) ], ChartTrait.prototype, "topAxis", void 0);
  __decorate([ TraitRef({
    type: RightAxisTrait,
    binds: true,
    willAttachTrait(rightAxisTrait) {
      this.owner.callObservers("traitWillAttachRightAxis", rightAxisTrait, this.owner);
    },
    didAttachTrait(rightAxisTrait) {
      if (this.owner.consuming) {
        rightAxisTrait.consume(this.owner);
      }
    },
    willDetachTrait(rightAxisTrait) {
      if (this.owner.consuming) {
        rightAxisTrait.unconsume(this.owner);
      }
    },
    didDetachTrait(rightAxisTrait) {
      this.owner.callObservers("traitDidDetachRightAxis", rightAxisTrait, this.owner);
    },
    detectModel(model) {
      return model.getTrait(RightAxisTrait);
    },
    detectTrait(trait) {
      return trait instanceof RightAxisTrait ? trait : null;
    }
  }) ], ChartTrait.prototype, "rightAxis", void 0);
  __decorate([ TraitRef({
    type: BottomAxisTrait,
    binds: true,
    willAttachTrait(bottomAxisTrait) {
      this.owner.callObservers("traitWillAttachBottomAxis", bottomAxisTrait, this.owner);
    },
    didAttachTrait(bottomAxisTrait) {
      if (this.owner.consuming) {
        bottomAxisTrait.consume(this.owner);
      }
    },
    willDetachTrait(bottomAxisTrait) {
      if (this.owner.consuming) {
        bottomAxisTrait.unconsume(this.owner);
      }
    },
    didDetachTrait(bottomAxisTrait) {
      this.owner.callObservers("traitDidDetachBottomAxis", bottomAxisTrait, this.owner);
    },
    detectModel(model) {
      return model.getTrait(BottomAxisTrait);
    },
    detectTrait(trait) {
      return trait instanceof BottomAxisTrait ? trait : null;
    }
  }) ], ChartTrait.prototype, "bottomAxis", void 0);
  __decorate([ TraitRef({
    type: LeftAxisTrait,
    binds: true,
    willAttachTrait(leftAxisTrait) {
      this.owner.callObservers("traitWillAttachLeftAxis", leftAxisTrait, this.owner);
    },
    didAttachTrait(leftAxisTrait) {
      if (this.owner.consuming) {
        leftAxisTrait.consume(this.owner);
      }
    },
    willDetachTrait(leftAxisTrait) {
      if (this.owner.consuming) {
        leftAxisTrait.unconsume(this.owner);
      }
    },
    didDetachTrait(leftAxisTrait) {
      this.owner.callObservers("traitDidDetachLeftAxis", leftAxisTrait, this.owner);
    },
    detectModel(model) {
      return model.getTrait(LeftAxisTrait);
    },
    detectTrait(trait) {
      return trait instanceof LeftAxisTrait ? trait : null;
    }
  }) ], ChartTrait.prototype, "leftAxis", void 0);
  class ChartController extends GraphController {}
  __decorate([ TraitViewRef({
    traitType: ChartTrait,
    observesTrait: true,
    initTrait(chartTrait) {
      this.owner.graph.setTrait(chartTrait.graph.trait);
      const topAxisTrait = chartTrait.topAxis.trait;
      if (topAxisTrait !== null) {
        this.owner.topAxis.setTrait(topAxisTrait);
      }
      const rightAxisTrait = chartTrait.rightAxis.trait;
      if (rightAxisTrait !== null) {
        this.owner.rightAxis.setTrait(rightAxisTrait);
      }
      const bottomAxisTrait = chartTrait.bottomAxis.trait;
      if (bottomAxisTrait !== null) {
        this.owner.bottomAxis.setTrait(bottomAxisTrait);
      }
      const leftAxisTrait = chartTrait.leftAxis.trait;
      if (leftAxisTrait !== null) {
        this.owner.leftAxis.setTrait(leftAxisTrait);
      }
    },
    deinitTrait(chartTrait) {
      const leftAxisTrait = chartTrait.leftAxis.trait;
      if (leftAxisTrait !== null) {
        this.owner.leftAxis.deleteTrait(leftAxisTrait);
      }
      const bottomAxisTrait = chartTrait.bottomAxis.trait;
      if (bottomAxisTrait !== null) {
        this.owner.bottomAxis.deleteTrait(bottomAxisTrait);
      }
      const rightAxisTrait = chartTrait.rightAxis.trait;
      if (rightAxisTrait !== null) {
        this.owner.rightAxis.deleteTrait(rightAxisTrait);
      }
      const topAxisTrait = chartTrait.topAxis.trait;
      if (topAxisTrait !== null) {
        this.owner.topAxis.deleteTrait(topAxisTrait);
      }
      this.owner.graph.setTrait(null);
    },
    willAttachTrait(newChartTrait) {
      this.owner.callObservers("controllerWillAttachChartTrait", newChartTrait, this.owner);
    },
    didDetachTrait(newChartTrait) {
      this.owner.callObservers("controllerDidDetachChartTrait", newChartTrait, this.owner);
    },
    traitWillAttachTopAxis(topAxisTrait) {
      this.owner.topAxis.setTrait(topAxisTrait);
    },
    traitDidDetachTopAxis(topAxisTrait) {
      this.owner.topAxis.setTrait(null);
    },
    traitWillAttachRightAxis(rightAxisTrait) {
      this.owner.rightAxis.setTrait(rightAxisTrait);
    },
    traitDidDetachRightAxis(rightAxisTrait) {
      this.owner.rightAxis.setTrait(null);
    },
    traitWillAttachBottomAxis(bottomAxisTrait) {
      this.owner.bottomAxis.setTrait(bottomAxisTrait);
    },
    traitDidDetachBottomAxis(bottomAxisTrait) {
      this.owner.bottomAxis.setTrait(null);
    },
    traitWillAttachLeftAxis(leftAxisTrait) {
      this.owner.leftAxis.setTrait(leftAxisTrait);
    },
    traitDidDetachLeftAxis(leftAxisTrait) {
      this.owner.leftAxis.setTrait(null);
    },
    viewType: ChartView,
    initView(chartView) {
      const topAxisController = this.owner.topAxis.controller;
      if (topAxisController !== null) {
        topAxisController.axis.insertView(chartView);
      }
      const rightAxisController = this.owner.rightAxis.controller;
      if (rightAxisController !== null) {
        rightAxisController.axis.insertView(chartView);
      }
      const bottomAxisController = this.owner.bottomAxis.controller;
      if (bottomAxisController !== null) {
        bottomAxisController.axis.insertView(chartView);
      }
      const leftAxisController = this.owner.leftAxis.controller;
      if (leftAxisController !== null) {
        leftAxisController.axis.insertView(chartView);
      }
      if (this.owner.graph.view !== null || this.owner.graph.trait !== null) {
        this.owner.graph.insertView(chartView);
      }
    },
    willAttachView(chartView) {
      this.owner.callObservers("controllerWillAttachChartView", chartView, this.owner);
    },
    didDetachView(chartView) {
      this.owner.callObservers("controllerDidDetachChartView", chartView, this.owner);
    }
  }) ], ChartController.prototype, "chart", void 0);
  __decorate([ TraitViewRef({
    extends: true,
    initTrait(graphTrait) {
      GraphController.graph.prototype.initTrait.call(this, graphTrait);
      const chartView = this.owner.chart.view;
      if (chartView !== null) {
        this.insertView(chartView);
      }
    },
    initView(graphView) {
      GraphController.graph.prototype.initView.call(this, graphView);
      const chartView = this.owner.chart.view;
      if (chartView !== null) {
        this.insertView(chartView);
      }
    },
    deinitView(graphView) {
      GraphController.graph.prototype.deinitView.call(this, graphView);
      graphView.remove();
    }
  }) ], ChartController.prototype, "graph", void 0);
  __decorate([ TraitViewControllerRef({
    implements: true,
    type: TopAxisController,
    binds: true,
    observes: true,
    get parentView() {
      return this.owner.chart.view;
    },
    getTraitViewRef(controller) {
      return controller.axis;
    },
    willAttachController(topAxisController) {
      this.owner.callObservers("controllerWillAttachTopAxis", topAxisController, this.owner);
    },
    didAttachController(topAxisController) {
      const topAxisTrait = topAxisController.axis.trait;
      if (topAxisTrait !== null) {
        this.attachAxisTrait(topAxisTrait);
      }
      const topAxisView = topAxisController.axis.view;
      if (topAxisView !== null) {
        this.attachAxisView(topAxisView);
      }
    },
    willDetachController(topAxisController) {
      const topAxisView = topAxisController.axis.view;
      if (topAxisView !== null) {
        this.detachAxisView(topAxisView);
      }
      const topAxisTrait = topAxisController.axis.trait;
      if (topAxisTrait !== null) {
        this.detachAxisTrait(topAxisTrait);
      }
    },
    didDetachController(topAxisController) {
      this.owner.callObservers("controllerDidDetachTopAxis", topAxisController, this.owner);
    },
    controllerWillAttachAxisTrait(topAxisTrait) {
      this.owner.callObservers("controllerWillAttachTopAxisTrait", topAxisTrait, this.owner);
      this.attachAxisTrait(topAxisTrait);
    },
    controllerDidDetachAxisTrait(topAxisTrait) {
      this.detachAxisTrait(topAxisTrait);
      this.owner.callObservers("controllerDidDetachTopAxisTrait", topAxisTrait, this.owner);
    },
    attachAxisTrait(topAxisTrait) {},
    detachAxisTrait(topAxisTrait) {},
    controllerWillAttachAxisView(topAxisView) {
      this.owner.callObservers("controllerWillAttachTopAxisView", topAxisView, this.owner);
      this.attachAxisView(topAxisView);
    },
    controllerDidDetachAxisView(topAxisView) {
      this.detachAxisView(topAxisView);
      this.owner.callObservers("controllerDidDetachTopAxisView", topAxisView, this.owner);
    },
    attachAxisView(topAxisView) {},
    detachAxisView(topAxisView) {
      topAxisView.remove();
    },
    detectController(controller) {
      return controller instanceof TopAxisController ? controller : null;
    }
  }) ], ChartController.prototype, "topAxis", void 0);
  __decorate([ TraitViewControllerRef({
    implements: true,
    type: RightAxisController,
    binds: true,
    observes: true,
    get parentView() {
      return this.owner.chart.view;
    },
    getTraitViewRef(controller) {
      return controller.axis;
    },
    willAttachController(rightAxisController) {
      this.owner.callObservers("controllerWillAttachRightAxis", rightAxisController, this.owner);
    },
    didAttachController(rightAxisController) {
      const rightAxisTrait = rightAxisController.axis.trait;
      if (rightAxisTrait !== null) {
        this.attachAxisTrait(rightAxisTrait);
      }
      const rightAxisView = rightAxisController.axis.view;
      if (rightAxisView !== null) {
        this.attachAxisView(rightAxisView);
      }
    },
    willDetachController(rightAxisController) {
      const rightAxisView = rightAxisController.axis.view;
      if (rightAxisView !== null) {
        this.detachAxisView(rightAxisView);
      }
      const rightAxisTrait = rightAxisController.axis.trait;
      if (rightAxisTrait !== null) {
        this.detachAxisTrait(rightAxisTrait);
      }
    },
    didDetachController(rightAxisController) {
      this.owner.callObservers("controllerDidDetachRightAxis", rightAxisController, this.owner);
    },
    controllerWillAttachAxisTrait(rightAxisTrait) {
      this.owner.callObservers("controllerWillAttachRightAxisTrait", rightAxisTrait, this.owner);
      this.attachAxisTrait(rightAxisTrait);
    },
    controllerDidDetachAxisTrait(rightAxisTrait) {
      this.detachAxisTrait(rightAxisTrait);
      this.owner.callObservers("controllerDidDetachRightAxisTrait", rightAxisTrait, this.owner);
    },
    attachAxisTrait(rightAxisTrait) {},
    detachAxisTrait(rightAxisTrait) {},
    controllerWillAttachAxisView(rightAxisView) {
      this.owner.callObservers("controllerWillAttachRightAxisView", rightAxisView, this.owner);
      this.attachAxisView(rightAxisView);
    },
    controllerDidDetachAxisView(rightAxisView) {
      this.detachAxisView(rightAxisView);
      this.owner.callObservers("controllerDidDetachRightAxisView", rightAxisView, this.owner);
    },
    attachAxisView(rightAxisView) {},
    detachAxisView(rightAxisView) {
      rightAxisView.remove();
    },
    detectController(controller) {
      return controller instanceof RightAxisController ? controller : null;
    }
  }) ], ChartController.prototype, "rightAxis", void 0);
  __decorate([ TraitViewControllerRef({
    implements: true,
    type: BottomAxisController,
    binds: true,
    observes: true,
    get parentView() {
      return this.owner.chart.view;
    },
    getTraitViewRef(controller) {
      return controller.axis;
    },
    willAttachController(bottomAxisController) {
      this.owner.callObservers("controllerWillAttachBottomAxis", bottomAxisController, this.owner);
    },
    didAttachController(bottomAxisController) {
      const bottomAxisTrait = bottomAxisController.axis.trait;
      if (bottomAxisTrait !== null) {
        this.attachAxisTrait(bottomAxisTrait);
      }
      const bottomAxisView = bottomAxisController.axis.view;
      if (bottomAxisView !== null) {
        this.attachAxisView(bottomAxisView);
      }
    },
    willDetachController(bottomAxisController) {
      const bottomAxisView = bottomAxisController.axis.view;
      if (bottomAxisView !== null) {
        this.detachAxisView(bottomAxisView);
      }
      const bottomAxisTrait = bottomAxisController.axis.trait;
      if (bottomAxisTrait !== null) {
        this.detachAxisTrait(bottomAxisTrait);
      }
    },
    didDetachController(bottomAxisController) {
      this.owner.callObservers("controllerDidDetachBottomAxis", bottomAxisController, this.owner);
    },
    controllerWillAttachAxisTrait(bottomAxisTrait) {
      this.owner.callObservers("controllerWillAttachBottomAxisTrait", bottomAxisTrait, this.owner);
      this.attachAxisTrait(bottomAxisTrait);
    },
    controllerDidDetachAxisTrait(bottomAxisTrait) {
      this.detachAxisTrait(bottomAxisTrait);
      this.owner.callObservers("controllerDidDetachBottomAxisTrait", bottomAxisTrait, this.owner);
    },
    attachAxisTrait(bottomAxisTrait) {},
    detachAxisTrait(bottomAxisTrait) {},
    controllerWillAttachAxisView(bottomAxisView) {
      this.owner.callObservers("controllerWillAttachBottomAxisView", bottomAxisView, this.owner);
      this.attachAxisView(bottomAxisView);
    },
    controllerDidDetachAxisView(bottomAxisView) {
      this.detachAxisView(bottomAxisView);
      this.owner.callObservers("controllerDidDetachBottomAxisView", bottomAxisView, this.owner);
    },
    attachAxisView(bottomAxisView) {},
    detachAxisView(bottomAxisView) {
      bottomAxisView.remove();
    },
    detectController(controller) {
      return controller instanceof BottomAxisController ? controller : null;
    }
  }) ], ChartController.prototype, "bottomAxis", void 0);
  __decorate([ TraitViewControllerRef({
    implements: true,
    type: LeftAxisController,
    binds: true,
    observes: true,
    get parentView() {
      return this.owner.chart.view;
    },
    getTraitViewRef(controller) {
      return controller.axis;
    },
    willAttachController(leftAxisController) {
      this.owner.callObservers("controllerWillAttachLeftAxis", leftAxisController, this.owner);
    },
    didAttachController(leftAxisController) {
      const leftAxisTrait = leftAxisController.axis.trait;
      if (leftAxisTrait !== null) {
        this.attachAxisTrait(leftAxisTrait);
      }
      const leftAxisView = leftAxisController.axis.view;
      if (leftAxisView !== null) {
        this.attachAxisView(leftAxisView);
      }
    },
    willDetachController(leftAxisController) {
      const leftAxisView = leftAxisController.axis.view;
      if (leftAxisView !== null) {
        this.detachAxisView(leftAxisView);
      }
      const leftAxisTrait = leftAxisController.axis.trait;
      if (leftAxisTrait !== null) {
        this.detachAxisTrait(leftAxisTrait);
      }
    },
    didDetachController(leftAxisController) {
      this.owner.callObservers("controllerDidDetachLeftAxis", leftAxisController, this.owner);
    },
    controllerWillAttachAxisTrait(leftAxisTrait) {
      this.owner.callObservers("controllerWillAttachLeftAxisTrait", leftAxisTrait, this.owner);
      this.attachAxisTrait(leftAxisTrait);
    },
    controllerDidDetachAxisTrait(leftAxisTrait) {
      this.detachAxisTrait(leftAxisTrait);
      this.owner.callObservers("controllerDidDetachLeftAxisTrait", leftAxisTrait, this.owner);
    },
    attachAxisTrait(leftAxisTrait) {},
    detachAxisTrait(leftAxisTrait) {},
    controllerWillAttachAxisView(leftAxisView) {
      this.owner.callObservers("controllerWillAttachLeftAxisView", leftAxisView, this.owner);
      this.attachAxisView(leftAxisView);
    },
    controllerDidDetachAxisView(leftAxisView) {
      this.detachAxisView(leftAxisView);
      this.owner.callObservers("controllerDidDetachLeftAxisView", leftAxisView, this.owner);
    },
    attachAxisView(leftAxisView) {},
    detachAxisView(leftAxisView) {
      leftAxisView.remove();
    },
    detectController(controller) {
      return controller instanceof LeftAxisController ? controller : null;
    }
  }) ], ChartController.prototype, "leftAxis", void 0);
  const GeoPerspective = function() {
    const GeoPerspective = {};
    GeoPerspective.fromAny = function(value) {
      if (value === void 0 || value === null) {
        return value;
      } else {
        let geoFrame;
        if (value.geoFrame !== void 0 && value.geoFrame !== null) {
          geoFrame = geo.GeoBox.fromAny(value.geoFrame);
        } else {
          geoFrame = null;
        }
        let geoCenter;
        if (value.geoCenter !== void 0 && value.geoCenter !== null) {
          geoCenter = geo.GeoPoint.fromAny(value.geoCenter);
        } else {
          geoCenter = null;
        }
        const zoom = value.zoom;
        const heading = value.heading;
        const tilt = value.tilt;
        return {
          geoFrame: geoFrame,
          geoCenter: geoCenter,
          zoom: zoom,
          heading: heading,
          tilt: tilt
        };
      }
    };
    GeoPerspective.is = function(object) {
      if (object !== void 0 && object !== null || typeof object === "function") {
        const viewport = object;
        return "geoFrame" in viewport && "geoCenter" in viewport && "zoom" in viewport && "heading" in viewport && "tilt" in viewport;
      }
      return false;
    };
    return GeoPerspective;
  }();
  const GeoViewport = function() {
    const GeoViewport = {};
    GeoViewport.is = function(object) {
      if (geo.GeoProjection.is(object) && GeoPerspective.is(object)) {
        return true;
      }
      return false;
    };
    return GeoViewport;
  }();
  class GeoView extends GraphicsView {
    constructor() {
      super();
      this.geoBounds = geo.GeoBox.undefined();
    }
    didInsertChild(child, target) {
      if (child instanceof GeoView) {
        this.onInsertChildGeoBounds(child, child.geoBounds);
      }
      super.didInsertChild(child, target);
    }
    didRemoveChild(child) {
      if (child instanceof GeoView) {
        this.onRemoveChildGeoBounds(child, child.geoBounds);
      }
      super.didRemoveChild(child);
    }
    onRender(viewContext) {
      super.onRender(viewContext);
      const outlineColor = this.geoBoundsColor.value;
      if (outlineColor !== null) {
        this.renderGeoBounds(viewContext, outlineColor, 1);
      }
    }
    renderGeoBounds(viewContext, outlineColor, outlineWidth) {
      const renderer = viewContext.renderer;
      if (renderer instanceof PaintingRenderer && !this.hidden && !this.culled && !this.unbounded) {
        this.renderGeoOutline(this.geoBounds, viewContext.geoViewport, renderer.context, outlineColor, outlineWidth);
      }
    }
    renderGeoOutline(geoBox, geoProjection, context, outlineColor, outlineWidth) {
      if (geoBox.isDefined()) {
        const contextLineWidth = context.lineWidth;
        const contextStrokeStyle = context.strokeStyle;
        const southWest = geoProjection.project(geoBox.southWest.normalized());
        const northWest = geoProjection.project(geoBox.northWest.normalized());
        const northEast = geoProjection.project(geoBox.northEast.normalized());
        const southEast = geoProjection.project(geoBox.southEast.normalized());
        context.beginPath();
        context.moveTo(southWest.x, southWest.y);
        context.lineTo(northWest.x, northWest.y);
        context.lineTo(northEast.x, northEast.y);
        context.lineTo(southEast.x, southEast.y);
        context.closePath();
        context.lineWidth = outlineWidth;
        context.strokeStyle = outlineColor.toString();
        context.stroke();
        context.lineWidth = contextLineWidth;
        context.strokeStyle = contextStrokeStyle;
      }
    }
    onHide() {
      super.onHide();
      const parent = this.parent;
      if (parent instanceof GeoView) {
        parent.onHideChild(this);
      }
    }
    onUnhide() {
      super.onUnhide();
      const parent = this.parent;
      if (parent instanceof GeoView) {
        parent.onUnhideChild(this);
      }
    }
    onSetUnbounded(unbounded) {
      const parent = this.parent;
      if (parent instanceof GeoView) {
        parent.onSetChildUnbounded(this, unbounded);
      }
    }
    cullGeoFrame(geoFrame = this.geoFrame) {
      this.setCulled(!geoFrame.intersects(this.geoBounds));
    }
    get geoViewport() {
      return this.viewContext.geoViewport;
    }
    get geoFrame() {
      const parent = this.parent;
      return parent instanceof GeoView ? parent.geoFrame : geo.GeoBox.globe();
    }
    setGeoBounds(newGeoBounds) {
      const oldGeoBounds = this.geoBounds;
      if (!oldGeoBounds.equals(newGeoBounds)) {
        this.willSetGeoBounds(newGeoBounds, oldGeoBounds);
        this.geoBounds = newGeoBounds;
        this.onSetGeoBounds(newGeoBounds, oldGeoBounds);
        this.didSetGeoBounds(newGeoBounds, oldGeoBounds);
      }
    }
    willSetGeoBounds(newGeoBounds, oldGeoBounds) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewWillSetGeoBounds !== void 0) {
          observer.viewWillSetGeoBounds(newGeoBounds, oldGeoBounds, this);
        }
      }
    }
    onSetGeoBounds(newGeoBounds, oldGeoBounds) {
      if (!this.unbounded) {
        const parent = this.parent;
        if (parent instanceof GeoView) {
          parent.onSetChildGeoBounds(this, newGeoBounds, oldGeoBounds);
        }
      }
    }
    didSetGeoBounds(newGeoBounds, oldGeoBounds) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.viewDidSetGeoBounds !== void 0) {
          observer.viewDidSetGeoBounds(newGeoBounds, oldGeoBounds, this);
        }
      }
    }
    updateGeoBounds() {
      this.setGeoBounds(this.deriveGeoBounds());
    }
    onInsertChildGeoBounds(child, newGeoBounds) {
      this.updateGeoBounds();
    }
    onRemoveChildGeoBounds(child, oldGeoBounds) {
      this.updateGeoBounds();
    }
    onSetChildGeoBounds(child, newGeoBounds, oldGeoBounds) {
      this.updateGeoBounds();
    }
    onHideChild(child) {
      this.updateGeoBounds();
    }
    onUnhideChild(child) {
      this.updateGeoBounds();
    }
    onSetChildUnbounded(child, unbounded) {
      this.updateGeoBounds();
    }
    get ownGeoBounds() {
      return null;
    }
    deriveGeoBounds() {
      let geoBounds = this.ownGeoBounds;
      let child = this.firstChild;
      while (child !== null) {
        if (child instanceof GeoView && !child.hidden && !child.unbounded) {
          const childGeoBounds = child.geoBounds;
          if (childGeoBounds.isDefined()) {
            if (geoBounds !== null) {
              geoBounds = geoBounds.union(childGeoBounds);
            } else {
              geoBounds = childGeoBounds;
            }
          }
        }
        child = child.nextSibling;
      }
      if (geoBounds === null) {
        geoBounds = this.geoFrame;
      }
      return geoBounds;
    }
    init(init) {
      super.init(init);
    }
  }
  GeoView.MountFlags = GraphicsView.MountFlags | View.NeedsProject;
  GeoView.UncullFlags = GraphicsView.UncullFlags | View.NeedsProject;
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    inherits: true
  }) ], GeoView.prototype, "geoBoundsColor", void 0);
  class GeoTrait extends Trait {}
  class GeoController extends Controller {
    static fromTrait(geoTrait) {
      if (geoTrait instanceof GeoLayerTrait) {
        return new GeoLayerController;
      } else if (geoTrait instanceof GeoIconTrait) {
        return new GeoIconController;
      } else if (geoTrait instanceof GeoAreaTrait) {
        return new GeoAreaController;
      } else if (geoTrait instanceof GeoLineTrait) {
        return new GeoLineController;
      } else {
        throw new Error("Can't create GeoController from " + geoTrait);
      }
    }
  }
  __decorate([ component.Property({
    type: util.Timing,
    inherits: true
  }) ], GeoController.prototype, "geoTiming", void 0);
  class GeoLayerTrait extends GeoTrait {
    constructor() {
      super();
      this.geoBounds = geo.GeoBox.globe();
    }
    setGeoBounds(newGeoBounds) {
      const oldGeoBounds = this.geoBounds;
      if (!newGeoBounds.equals(oldGeoBounds)) {
        this.willSetGeoBounds(newGeoBounds, oldGeoBounds);
        this.geoBounds = newGeoBounds;
        this.onSetGeoBounds(newGeoBounds, oldGeoBounds);
        this.didSetGeoBounds(newGeoBounds, oldGeoBounds);
      }
    }
    willSetGeoBounds(newGeoBounds, oldGeoBounds) {
      this.callObservers("traitWillSetGeoBounds", newGeoBounds, oldGeoBounds, this);
    }
    onSetGeoBounds(newGeoBounds, oldGeoBounds) {}
    didSetGeoBounds(newGeoBounds, oldGeoBounds) {
      this.callObservers("traitDidSetGeoBounds", newGeoBounds, oldGeoBounds, this);
    }
    startConsumingFeatures() {
      const featureTraits = this.features.traits;
      for (const traitId in featureTraits) {
        const featureTrait = featureTraits[traitId];
        featureTrait.consume(this);
      }
    }
    stopConsumingFeatures() {
      const featureTraits = this.features.traits;
      for (const traitId in featureTraits) {
        const featureTrait = featureTraits[traitId];
        featureTrait.unconsume(this);
      }
    }
    onStartConsuming() {
      super.onStartConsuming();
      this.startConsumingFeatures();
    }
    onStopConsuming() {
      super.onStopConsuming();
      this.stopConsumingFeatures();
    }
  }
  __decorate([ TraitSet({
    type: GeoTrait,
    binds: true,
    willAttachTrait(featureTrait) {
      this.owner.callObservers("traitWillAttachFeature", featureTrait, this.owner);
    },
    didAttachTrait(featureTrait) {
      if (this.owner.consuming) {
        featureTrait.consume(this.owner);
      }
    },
    willDetachTrait(featureTrait) {
      if (this.owner.consuming) {
        featureTrait.unconsume(this.owner);
      }
    },
    didDetachTrait(featureTrait) {
      this.owner.callObservers("traitDidDetachFeature", featureTrait, this.owner);
    },
    detectModel(model) {
      return model.getTrait(GeoTrait);
    },
    detectTrait(trait) {
      return null;
    }
  }) ], GeoLayerTrait.prototype, "features", void 0);
  class GeoTree {
    constructor(depth, maxDepth, density, geoFrame, geoBounds, geoCenter, southWest, northWest, southEast, northEast, views, size) {
      this.depth = depth;
      this.maxDepth = maxDepth;
      this.density = density;
      this.geoFrame = geoFrame;
      this.geoBounds = geoBounds;
      this.geoCenter = geoCenter;
      this.southWest = southWest;
      this.northWest = northWest;
      this.southEast = southEast;
      this.northEast = northEast;
      this.views = views;
      this.size = size;
    }
    isEmpty() {
      return this.size === 0;
    }
    contains(bounds) {
      return this.geoFrame.contains(bounds);
    }
    intersects(bounds) {
      return this.geoFrame.intersects(bounds);
    }
    getTree(bounds) {
      if (this.depth < this.maxDepth && this.size > this.density) {
        const geoCenter = this.geoCenter;
        const inWest = bounds.lngMin <= geoCenter.lng;
        const inSouth = bounds.latMin <= geoCenter.lat;
        const inEast = bounds.lngMax > geoCenter.lng;
        const inNorth = bounds.latMax > geoCenter.lat;
        if (inWest !== inEast && inSouth !== inNorth) {
          if (inSouth && inWest) {
            const southWest = this.southWest;
            if (southWest !== null) {
              return southWest.getTree(bounds);
            }
          } else if (inNorth && inWest) {
            const northWest = this.northWest;
            if (northWest !== null) {
              return northWest.getTree(bounds);
            }
          } else if (inSouth && inEast) {
            const southEast = this.southEast;
            if (southEast !== null) {
              return southEast.getTree(bounds);
            }
          } else if (inNorth && inEast) {
            const northEast = this.northEast;
            if (northEast !== null) {
              return northEast.getTree(bounds);
            }
          }
        }
      }
      return this;
    }
    has(view, bounds) {
      if (this.depth < this.maxDepth && this.size > this.density) {
        const contained = this.hasNode(view, bounds);
        if (contained !== void 0) {
          return contained;
        }
      }
      return this.hasLeaf(view, bounds);
    }
    hasNode(view, bounds) {
      const geoCenter = this.geoCenter;
      const inWest = bounds.lngMin <= geoCenter.lng;
      const inSouth = bounds.latMin <= geoCenter.lat;
      const inEast = bounds.lngMax > geoCenter.lng;
      const inNorth = bounds.latMax > geoCenter.lat;
      if (inWest !== inEast && inSouth !== inNorth) {
        if (inSouth && inWest) {
          const southWest = this.southWest;
          if (southWest !== null) {
            return southWest.has(view, bounds);
          }
        } else if (inNorth && inWest) {
          const northWest = this.northWest;
          if (northWest !== null) {
            return northWest.has(view, bounds);
          }
        } else if (inSouth && inEast) {
          const southEast = this.southEast;
          if (southEast !== null) {
            return southEast.has(view, bounds);
          }
        } else if (inNorth && inEast) {
          const northEast = this.northEast;
          if (northEast !== null) {
            return northEast.has(view, bounds);
          }
        }
      }
      return void 0;
    }
    hasLeaf(view, bounds) {
      return this.views.indexOf(view) >= 0;
    }
    inserted(view, bounds) {
      let tree = this;
      if (tree.depth < tree.maxDepth && tree.size > tree.density) {
        const newTree = tree.insertedNode(view, bounds);
        if (newTree !== null) {
          tree = newTree;
          if (this !== tree && tree.size === tree.density + 1) {
            tree = tree.reinsertedNode();
          }
          return tree;
        }
      }
      tree = tree.insertedLeaf(view, bounds);
      if (this !== tree && tree.depth < tree.maxDepth && tree.size === tree.density + 1) {
        tree = tree.reinsertedNode();
      }
      return tree;
    }
    insertedNode(view, bounds) {
      const geoCenter = this.geoCenter;
      const inWest = bounds.lngMin <= geoCenter.lng;
      const inSouth = bounds.latMin <= geoCenter.lat;
      const inEast = bounds.lngMax > geoCenter.lng;
      const inNorth = bounds.latMax > geoCenter.lat;
      if (inWest !== inEast && inSouth !== inNorth) {
        if (inSouth && inWest) {
          const oldSouthWest = this.southWest;
          let newSouthWest = oldSouthWest;
          if (newSouthWest === null) {
            newSouthWest = this.createTree(this.depth + 1, this.maxDepth, this.density, new geo.GeoBox(this.geoFrame.lngMin, this.geoFrame.latMin, this.geoCenter.lng, this.geoCenter.lat));
          }
          newSouthWest = newSouthWest.inserted(view, bounds);
          if (oldSouthWest !== newSouthWest) {
            return this.createTree(this.depth, this.maxDepth, this.density, this.geoFrame, void 0, this.geoCenter, newSouthWest, this.northWest, this.southEast, this.northEast, this.views, this.size + 1);
          } else {
            return this;
          }
        } else if (inNorth && inWest) {
          const oldNorthWest = this.northWest;
          let newNorthWest = oldNorthWest;
          if (newNorthWest === null) {
            newNorthWest = this.createTree(this.depth + 1, this.maxDepth, this.density, new geo.GeoBox(this.geoFrame.lngMin, this.geoCenter.lat, this.geoCenter.lng, this.geoFrame.latMax));
          }
          newNorthWest = newNorthWest.inserted(view, bounds);
          if (oldNorthWest !== newNorthWest) {
            return this.createTree(this.depth, this.maxDepth, this.density, this.geoFrame, void 0, this.geoCenter, this.southWest, newNorthWest, this.southEast, this.northEast, this.views, this.size + 1);
          } else {
            return this;
          }
        } else if (inSouth && inEast) {
          const oldSouthEast = this.southEast;
          let newSouthEast = oldSouthEast;
          if (newSouthEast === null) {
            newSouthEast = this.createTree(this.depth + 1, this.maxDepth, this.density, new geo.GeoBox(this.geoCenter.lng, this.geoFrame.latMin, this.geoFrame.lngMax, this.geoCenter.lat));
          }
          newSouthEast = newSouthEast.inserted(view, bounds);
          if (oldSouthEast !== newSouthEast) {
            return this.createTree(this.depth, this.maxDepth, this.density, this.geoFrame, void 0, this.geoCenter, this.southWest, this.northWest, newSouthEast, this.northEast, this.views, this.size + 1);
          } else {
            return this;
          }
        } else if (inNorth && inEast) {
          const oldNorthEast = this.northEast;
          let newNorthEast = oldNorthEast;
          if (newNorthEast === null) {
            newNorthEast = this.createTree(this.depth + 1, this.maxDepth, this.density, new geo.GeoBox(this.geoCenter.lng, this.geoCenter.lat, this.geoFrame.lngMax, this.geoFrame.latMax));
          }
          newNorthEast = newNorthEast.inserted(view, bounds);
          if (oldNorthEast !== newNorthEast) {
            return this.createTree(this.depth, this.maxDepth, this.density, this.geoFrame, void 0, this.geoCenter, this.southWest, this.northWest, this.southEast, newNorthEast, this.views, this.size + 1);
          } else {
            return this;
          }
        }
      }
      return null;
    }
    insertedLeaf(view, bounds) {
      const oldViews = this.views;
      if (oldViews.indexOf(view) < 0) {
        const newViews = oldViews.slice(0);
        newViews.push(view);
        return this.createTree(this.depth, this.maxDepth, this.density, this.geoFrame, void 0, this.geoCenter, this.southWest, this.northWest, this.southEast, this.northEast, newViews, this.size + 1);
      } else {
        return this;
      }
    }
    removed(view, bounds) {
      let tree = this;
      if (tree.depth < tree.maxDepth && tree.size > tree.density) {
        const newTree = tree.removedNode(view, bounds);
        if (newTree !== null) {
          tree = newTree;
          if (this !== tree && tree.size === tree.density) {
            tree = tree.reinsertedLeaf();
          }
          return tree;
        }
      }
      tree = tree.removedLeaf(view, bounds);
      if (this !== tree && tree.size === tree.density) {
        tree = tree.reinsertedLeaf();
      }
      return tree;
    }
    removedNode(view, bounds) {
      const geoCenter = this.geoCenter;
      const inWest = bounds.lngMin <= geoCenter.lng;
      const inSouth = bounds.latMin <= geoCenter.lat;
      const inEast = bounds.lngMax > geoCenter.lng;
      const inNorth = bounds.latMax > geoCenter.lat;
      if (inWest !== inEast && inSouth !== inNorth) {
        if (inSouth && inWest) {
          const oldSouthWest = this.southWest;
          if (oldSouthWest !== null) {
            let newSouthWest = oldSouthWest.removed(view, bounds);
            if (newSouthWest.isEmpty()) {
              newSouthWest = null;
            }
            return this.createTree(this.depth, this.maxDepth, this.density, this.geoFrame, void 0, this.geoCenter, newSouthWest, this.northWest, this.southEast, this.northEast, this.views, this.size - 1);
          } else {
            return this;
          }
        } else if (inNorth && inWest) {
          const oldNorthWest = this.northWest;
          if (oldNorthWest !== null) {
            let newNorthWest = oldNorthWest.removed(view, bounds);
            if (newNorthWest.isEmpty()) {
              newNorthWest = null;
            }
            return this.createTree(this.depth, this.maxDepth, this.density, this.geoFrame, void 0, this.geoCenter, this.southWest, newNorthWest, this.southEast, this.northEast, this.views, this.size - 1);
          } else {
            return this;
          }
        } else if (inSouth && inEast) {
          const oldSouthEast = this.southEast;
          if (oldSouthEast !== null) {
            let newSouthEast = oldSouthEast.removed(view, bounds);
            if (newSouthEast.isEmpty()) {
              newSouthEast = null;
            }
            return this.createTree(this.depth, this.maxDepth, this.density, this.geoFrame, void 0, this.geoCenter, this.southWest, this.northWest, newSouthEast, this.northEast, this.views, this.size - 1);
          } else {
            return this;
          }
        } else if (inNorth && inEast) {
          const oldNorthEast = this.northEast;
          if (oldNorthEast !== null) {
            let newNorthEast = oldNorthEast.removed(view, bounds);
            if (newNorthEast.isEmpty()) {
              newNorthEast = null;
            }
            return this.createTree(this.depth, this.maxDepth, this.density, this.geoFrame, void 0, this.geoCenter, this.southWest, this.northWest, this.southEast, newNorthEast, this.views, this.size - 1);
          } else {
            return this;
          }
        }
      }
      return null;
    }
    removedLeaf(view, bounds) {
      const oldViews = this.views;
      const index = oldViews.indexOf(view);
      if (index >= 0) {
        const newViews = oldViews.slice(0);
        newViews.splice(index, 1);
        return this.createTree(this.depth, this.maxDepth, this.density, this.geoFrame, void 0, this.geoCenter, this.southWest, this.northWest, this.southEast, this.northEast, newViews, this.size - 1);
      } else {
        return this;
      }
    }
    reinsertedNode() {
      let tree = this.createTree(this.depth, this.maxDepth, this.density, this.geoFrame, void 0, this.geoCenter);
      this.forEach((function(view) {
        const bounds = view.geoBounds;
        const newTree = tree.insertedNode(view, bounds);
        if (newTree !== null) {
          tree = newTree;
        } else {
          tree = tree.insertedLeaf(view, bounds);
        }
      }), this);
      return tree;
    }
    reinsertedLeaf() {
      let tree = this.createTree(this.depth, this.maxDepth, this.density, this.geoFrame, void 0, this.geoCenter);
      this.forEach((function(view) {
        tree = tree.insertedLeaf(view, view.geoBounds);
      }), this);
      return tree;
    }
    moved(view, newBounds, oldBounds) {
      if (this.depth < this.maxDepth && this.size > this.density) {
        const geoCenter = this.geoCenter;
        const newInWest = newBounds.lngMin <= geoCenter.lng;
        const newInSouth = newBounds.latMin <= geoCenter.lat;
        const newInEast = newBounds.lngMax > geoCenter.lng;
        const newInNorth = newBounds.latMax > geoCenter.lat;
        const oldInWest = oldBounds.lngMin <= geoCenter.lng;
        const oldInSouth = oldBounds.latMin <= geoCenter.lat;
        const oldInEast = oldBounds.lngMax > geoCenter.lng;
        const oldInNorth = oldBounds.latMax > geoCenter.lat;
        if (newInWest === oldInWest && newInSouth === oldInSouth && newInEast === oldInEast && newInNorth === oldInNorth) {
          if (newInWest !== newInEast && newInSouth !== newInNorth) {
            if (newInSouth && newInWest) {
              const oldSouthWest = this.southWest;
              const newSouthWest = oldSouthWest.moved(view, newBounds, oldBounds);
              if (oldSouthWest !== newSouthWest) {
                return this.createTree(this.depth, this.maxDepth, this.density, this.geoFrame, void 0, this.geoCenter, newSouthWest, this.northWest, this.southEast, this.northEast, this.views, this.size);
              }
            } else if (newInNorth && newInWest) {
              const oldNorthWest = this.northWest;
              const newNorthWest = oldNorthWest.moved(view, newBounds, oldBounds);
              if (oldNorthWest !== newNorthWest) {
                return this.createTree(this.depth, this.maxDepth, this.density, this.geoFrame, void 0, this.geoCenter, this.southWest, newNorthWest, this.southEast, this.northEast, this.views, this.size);
              }
            } else if (newInSouth && newInEast) {
              const oldSouthEast = this.southEast;
              const newSouthEast = oldSouthEast.moved(view, newBounds, oldBounds);
              if (oldSouthEast !== newSouthEast) {
                return this.createTree(this.depth, this.maxDepth, this.density, this.geoFrame, void 0, this.geoCenter, this.southWest, this.northWest, newSouthEast, this.northEast, this.views, this.size);
              }
            } else if (newInNorth && newInEast) {
              const oldNorthEast = this.northEast;
              const newNorthEast = oldNorthEast.moved(view, newBounds, oldBounds);
              if (oldNorthEast !== newNorthEast) {
                return this.createTree(this.depth, this.maxDepth, this.density, this.geoFrame, void 0, this.geoCenter, this.southWest, this.northWest, this.southEast, newNorthEast, this.views, this.size);
              }
            }
          }
        } else {
          return this.removed(view, oldBounds).inserted(view, newBounds);
        }
      }
      return this;
    }
    forEach(callback, thisArg) {
      if (this.southWest !== null) {
        const result = this.southWest.forEach(callback, thisArg);
        if (result !== void 0) {
          return result;
        }
      }
      if (this.northWest !== null) {
        const result = this.northWest.forEach(callback, thisArg);
        if (result !== void 0) {
          return result;
        }
      }
      if (this.southEast !== null) {
        const result = this.southEast.forEach(callback, thisArg);
        if (result !== void 0) {
          return result;
        }
      }
      if (this.northEast !== null) {
        const result = this.northEast.forEach(callback, thisArg);
        if (result !== void 0) {
          return result;
        }
      }
      const views = this.views;
      for (let i = 0; i < views.length; i += 1) {
        const result = callback.call(thisArg, views[i]);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
    forEachReverse(callback, thisArg) {
      const views = this.views;
      for (let i = views.length - 1; i >= 0; i -= 1) {
        const result = callback.call(thisArg, views[i]);
        if (result !== void 0) {
          return result;
        }
      }
      if (this.northEast !== null) {
        const result = this.northEast.forEachReverse(callback, thisArg);
        if (result !== void 0) {
          return result;
        }
      }
      if (this.southEast !== null) {
        const result = this.southEast.forEachReverse(callback, thisArg);
        if (result !== void 0) {
          return result;
        }
      }
      if (this.northWest !== null) {
        const result = this.northWest.forEachReverse(callback, thisArg);
        if (result !== void 0) {
          return result;
        }
      }
      if (this.southWest !== null) {
        const result = this.southWest.forEachReverse(callback, thisArg);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
    forEachIntersecting(bounds, callback, thisArg) {
      if (this.geoFrame.intersects(bounds)) {
        if (this.southWest !== null) {
          const result = this.southWest.forEachIntersecting(bounds, callback, thisArg);
          if (result !== void 0) {
            return result;
          }
        }
        if (this.northWest !== null) {
          const result = this.northWest.forEachIntersecting(bounds, callback, thisArg);
          if (result !== void 0) {
            return result;
          }
        }
        if (this.southEast !== null) {
          const result = this.southEast.forEachIntersecting(bounds, callback, thisArg);
          if (result !== void 0) {
            return result;
          }
        }
        if (this.northEast !== null) {
          const result = this.northEast.forEachIntersecting(bounds, callback, thisArg);
          if (result !== void 0) {
            return result;
          }
        }
        const views = this.views;
        for (let i = 0; i < views.length; i += 1) {
          const result = callback.call(thisArg, views[i]);
          if (result !== void 0) {
            return result;
          }
        }
      }
      return void 0;
    }
    forEachNonIntersecting(bounds, callback, thisArg) {
      if (!this.geoFrame.intersects(bounds)) {
        if (this.southWest !== null) {
          const result = this.southWest.forEachNonIntersecting(bounds, callback, thisArg);
          if (result !== void 0) {
            return result;
          }
        }
        if (this.northWest !== null) {
          const result = this.northWest.forEachNonIntersecting(bounds, callback, thisArg);
          if (result !== void 0) {
            return result;
          }
        }
        if (this.southEast !== null) {
          const result = this.southEast.forEachNonIntersecting(bounds, callback, thisArg);
          if (result !== void 0) {
            return result;
          }
        }
        if (this.northEast !== null) {
          const result = this.northEast.forEachNonIntersecting(bounds, callback, thisArg);
          if (result !== void 0) {
            return result;
          }
        }
        const views = this.views;
        for (let i = 0; i < views.length; i += 1) {
          const result = callback.call(thisArg, views[i]);
          if (result !== void 0) {
            return result;
          }
        }
      }
      return void 0;
    }
    createTree(depth, maxDepth, density, geoFrame, geoBounds, geoCenter, southWest = null, northWest = null, southEast = null, northEast = null, views = util.Arrays.empty, size = 0) {
      if (geoCenter === void 0) {
        geoCenter = geoFrame.center;
      }
      if (geoBounds === void 0) {
        if (southWest !== null) {
          geoBounds = southWest.geoBounds;
        }
        if (northWest !== null) {
          geoBounds = geoBounds !== void 0 ? geoBounds.union(northWest.geoBounds) : northWest.geoBounds;
        }
        if (southEast !== null) {
          geoBounds = geoBounds !== void 0 ? geoBounds.union(southEast.geoBounds) : southEast.geoBounds;
        }
        if (northEast !== null) {
          geoBounds = geoBounds !== void 0 ? geoBounds.union(northEast.geoBounds) : northEast.geoBounds;
        }
        for (let i = 0; i < views.length; i += 1) {
          const view = views[i];
          geoBounds = geoBounds !== void 0 ? geoBounds.union(view.geoBounds) : view.geoBounds;
        }
        if (geoBounds === void 0) {
          geoBounds = geoFrame;
        }
      }
      return new GeoTree(depth, maxDepth, density, geoFrame, geoBounds, geoCenter, southWest, northWest, southEast, northEast, views, size);
    }
    static empty(geoFrame, depth, maxDepth, density) {
      if (geoFrame === void 0) {
        geoFrame = geo.GeoBox.globe();
      }
      if (depth === void 0) {
        depth = 0;
      }
      if (maxDepth === void 0) {
        maxDepth = 20;
      }
      maxDepth = Math.max(depth, maxDepth);
      if (density === void 0) {
        density = 8;
      }
      return new GeoTree(depth, maxDepth, density, geoFrame, geoFrame, geoFrame.center, null, null, null, null, util.Arrays.empty, 0);
    }
  }
  class GeoTreeView extends GeoView {
    constructor(geoFrame, depth, maxDepth, density) {
      super();
      this.root = GeoTree.empty(geoFrame, depth, maxDepth, density);
      this.stem = null;
    }
    updateRoot(newRoot) {
      this.root = newRoot;
      this.stem = null;
      this.setGeoBounds(newRoot.geoBounds);
    }
    getStem(geoBounds) {
      let stem = this.stem;
      if (stem === null) {
        stem = this.root.getTree(geoBounds);
        this.stem = stem;
      }
      return stem;
    }
    onInsertChild(child, target) {
      super.onInsertChild(child, target);
      if (child instanceof GeoView) {
        this.updateRoot(this.root.inserted(child, child.geoBounds));
      }
    }
    onRemoveChild(child) {
      super.onRemoveChild(child);
      if (child instanceof GeoView) {
        this.updateRoot(this.root.removed(child, child.geoBounds));
      }
    }
    willProject(viewContext) {
      super.willProject(viewContext);
      this.stem = null;
    }
    processChildren(processFlags, viewContext, processChild) {
      const stem = this.getStem(viewContext.geoViewport.geoFrame);
      this.processTree(stem, processFlags, viewContext, processChild);
    }
    processTree(tree, processFlags, viewContext, processChild) {
      if (tree.southWest !== null && tree.southWest.geoFrame.intersects(viewContext.geoViewport.geoFrame)) {
        this.processTree(tree.southWest, processFlags, viewContext, processChild);
      }
      if (tree.northWest !== null && tree.northWest.geoFrame.intersects(viewContext.geoViewport.geoFrame)) {
        this.processTree(tree.northWest, processFlags, viewContext, processChild);
      }
      if (tree.southEast !== null && tree.southEast.geoFrame.intersects(viewContext.geoViewport.geoFrame)) {
        this.processTree(tree.southEast, processFlags, viewContext, processChild);
      }
      if (tree.northEast !== null && tree.northEast.geoFrame.intersects(viewContext.geoViewport.geoFrame)) {
        this.processTree(tree.northEast, processFlags, viewContext, processChild);
      }
      const children = tree.views;
      for (let i = 0; i < children.length; i += 1) {
        const child = children[i];
        processChild.call(this, child, processFlags, viewContext);
        if ((child.flags & View.RemovingFlag) !== 0) {
          child.setFlags(child.flags & ~View.RemovingFlag);
          this.removeChild(child);
        }
      }
    }
    onRender(viewContext) {
      super.onRender(viewContext);
      const outlineColor = this.geoTreeColor.value;
      if (outlineColor !== null) {
        this.renderGeoTree(viewContext, outlineColor);
      }
    }
    renderGeoTree(viewContext, outlineColor) {
      const renderer = viewContext.renderer;
      if (renderer instanceof PaintingRenderer && !this.hidden && !this.culled) {
        this.renderGeoTreeOutline(this.root, viewContext.geoViewport, renderer.context, outlineColor);
      }
    }
    renderGeoTreeOutline(tree, geoProjection, context, outlineColor) {
      if (tree.southWest !== null) {
        this.renderGeoTreeOutline(tree.southWest, geoProjection, context, outlineColor);
      }
      if (tree.northWest !== null) {
        this.renderGeoTreeOutline(tree.northWest, geoProjection, context, outlineColor);
      }
      if (tree.southEast !== null) {
        this.renderGeoTreeOutline(tree.southEast, geoProjection, context, outlineColor);
      }
      if (tree.northEast !== null) {
        this.renderGeoTreeOutline(tree.northEast, geoProjection, context, outlineColor);
      }
      const minDepth = 2;
      if (tree.depth >= minDepth) {
        const u = (tree.depth - minDepth) / (tree.maxDepth - minDepth);
        const outlineWidth = 4 * (1 - u) + .5 * u;
        this.renderGeoOutline(tree.geoFrame, geoProjection, context, outlineColor, outlineWidth);
      }
    }
    displayChildren(displayFlags, viewContext, displayChild) {
      const stem = this.getStem(viewContext.geoViewport.geoFrame);
      this.displayTree(stem, displayFlags, viewContext, displayChild);
    }
    displayTree(tree, displayFlags, viewContext, displayChild) {
      if (tree.southWest !== null && tree.southWest.geoFrame.intersects(viewContext.geoViewport.geoFrame)) {
        this.displayTree(tree.southWest, displayFlags, viewContext, displayChild);
      }
      if (tree.northWest !== null && tree.northWest.geoFrame.intersects(viewContext.geoViewport.geoFrame)) {
        this.displayTree(tree.northWest, displayFlags, viewContext, displayChild);
      }
      if (tree.southEast !== null && tree.southEast.geoFrame.intersects(viewContext.geoViewport.geoFrame)) {
        this.displayTree(tree.southEast, displayFlags, viewContext, displayChild);
      }
      if (tree.northEast !== null && tree.northEast.geoFrame.intersects(viewContext.geoViewport.geoFrame)) {
        this.displayTree(tree.northEast, displayFlags, viewContext, displayChild);
      }
      const children = tree.views;
      for (let i = 0; i < children.length; i += 1) {
        const child = children[i];
        displayChild.call(this, child, displayFlags, viewContext);
        if ((child.flags & View.RemovingFlag) !== 0) {
          child.setFlags(child.flags & ~View.RemovingFlag);
          this.removeChild(child);
        }
      }
    }
    updateGeoBounds() {}
    onSetChildGeoBounds(child, newChildViewGeoBounds, oldChildViewGeoBounds) {
      this.updateRoot(this.root.moved(child, newChildViewGeoBounds, oldChildViewGeoBounds));
    }
    hitTest(x, y, viewContext) {
      const geoViewport = viewContext.geoViewport;
      const geoPoint = geoViewport.unproject(x, y);
      const stem = this.getStem(geoViewport.geoFrame);
      return this.hitTestTree(stem, x, y, geoPoint, viewContext);
    }
    hitTestTree(tree, x, y, geoPoint, viewContext) {
      let hit = null;
      if (tree.southWest !== null && tree.southWest.geoFrame.contains(geoPoint)) {
        hit = this.hitTestTree(tree.southWest, x, y, geoPoint, viewContext);
      }
      if (hit === null && tree.northWest !== null && tree.northWest.geoFrame.contains(geoPoint)) {
        hit = this.hitTestTree(tree.northWest, x, y, geoPoint, viewContext);
      }
      if (hit === null && tree.southEast !== null && tree.southEast.geoFrame.contains(geoPoint)) {
        hit = this.hitTestTree(tree.southEast, x, y, geoPoint, viewContext);
      }
      if (hit === null && tree.northEast !== null && tree.northEast.geoFrame.contains(geoPoint)) {
        hit = this.hitTestTree(tree.northEast, x, y, geoPoint, viewContext);
      }
      if (hit === null) {
        const children = tree.views;
        for (let i = 0; i < children.length; i += 1) {
          const child = children[i];
          hit = child.cascadeHitTest(x, y, viewContext);
          if (hit !== null) {
            break;
          }
        }
      }
      return hit;
    }
    init(init) {
      super.init(init);
      if (init.geoTreeColor !== void 0) {
        this.geoTreeColor(init.geoTreeColor);
      }
    }
  }
  __decorate([ ThemeAnimator({
    type: Color,
    value: null
  }) ], GeoTreeView.prototype, "geoTreeColor", void 0);
  class GeoLayerController extends GeoController {}
  __decorate([ TraitViewRef({
    traitType: GeoLayerTrait,
    observesTrait: true,
    willAttachTrait(geoTrait) {
      this.owner.callObservers("controllerWillAttachGeoTrait", geoTrait, this.owner);
    },
    didAttachTrait(geoTrait) {
      const featureTraits = geoTrait.features.traits;
      for (const traitId in featureTraits) {
        const featureTrait = featureTraits[traitId];
        this.owner.features.addTraitController(featureTrait);
      }
    },
    willDetachTrait(geoTrait) {
      const featureTraits = geoTrait.features.traits;
      for (const traitId in featureTraits) {
        const featureTrait = featureTraits[traitId];
        this.owner.features.deleteTraitController(featureTrait);
      }
    },
    didDetachTrait(geoTrait) {
      this.owner.callObservers("controllerDidDetachGeoTrait", geoTrait, this.owner);
    },
    traitWillSetGeoBounds(newGeoBounds, oldGeoBounds) {
      this.owner.callObservers("controllerWillSetGeoBounds", newGeoBounds, oldGeoBounds, this.owner);
    },
    traitDidSetGeoBounds(newGeoBounds, oldGeoBounds) {
      this.owner.callObservers("controllerDidSetGeoBounds", newGeoBounds, oldGeoBounds, this.owner);
    },
    traitWillAttachFeature(featureTrait, targetTrait) {
      this.owner.features.addTraitController(featureTrait, targetTrait);
    },
    traitDidDetachFeature(featureTrait) {
      this.owner.features.deleteTraitController(featureTrait);
    },
    viewType: GeoTreeView,
    willAttachView(geoView) {
      this.owner.callObservers("controllerWillAttachGeoView", geoView, this.owner);
    },
    didAttachView(geoView) {
      const featureControllers = this.owner.features.controllers;
      for (const controllerId in featureControllers) {
        const featureController = featureControllers[controllerId];
        const featureView = featureController.geo.view;
        if (featureView !== null && featureView.parent === null) {
          featureController.geo.insertView(geoView);
        }
      }
    },
    didDetachView(geoView) {
      this.owner.callObservers("controllerDidDetachGeoView", geoView, this.owner);
    }
  }) ], GeoLayerController.prototype, "geo", void 0);
  __decorate([ TraitViewControllerSet({
    implements: true,
    type: GeoController,
    binds: true,
    observes: true,
    get parentView() {
      return this.owner.geo.view;
    },
    getTraitViewRef(featureController) {
      return featureController.geo;
    },
    willAttachController(featureController) {
      this.owner.callObservers("controllerWillAttachFeature", featureController, this.owner);
    },
    didAttachController(featureController) {
      const featureTrait = featureController.geo.trait;
      if (featureTrait !== null) {
        this.attachFeatureTrait(featureTrait, featureController);
      }
      const featureView = featureController.geo.view;
      if (featureView !== null) {
        this.attachFeatureView(featureView, featureController);
      }
    },
    willDetachController(featureController) {
      const featureView = featureController.geo.view;
      if (featureView !== null) {
        this.detachFeatureView(featureView, featureController);
      }
      const featureTrait = featureController.geo.trait;
      if (featureTrait !== null) {
        this.detachFeatureTrait(featureTrait, featureController);
      }
    },
    didDetachController(featureController) {
      this.owner.callObservers("controllerDidDetachFeature", featureController, this.owner);
    },
    controllerWillAttachGeoTrait(featureTrait, featureController) {
      this.owner.callObservers("controllerWillAttachFeatureTrait", featureTrait, featureController, this.owner);
      this.attachFeatureTrait(featureTrait, featureController);
    },
    controllerDidDetachGeoTrait(featureTrait, featureController) {
      this.detachFeatureTrait(featureTrait, featureController);
      this.owner.callObservers("controllerDidDetachFeatureTrait", featureTrait, featureController, this.owner);
    },
    attachFeatureTrait(featureTrait, featureController) {},
    detachFeatureTrait(featureTrait, featureController) {},
    controllerWillAttachGeoView(featureView, featureController) {
      this.owner.callObservers("controllerWillAttachFeatureView", featureView, featureController, this.owner);
      this.attachFeatureView(featureView, featureController);
    },
    controllerDidDetachGeoView(featureView, featureController) {
      this.detachFeatureView(featureView, featureController);
      this.owner.callObservers("controllerDidDetachFeatureView", featureView, featureController, this.owner);
    },
    attachFeatureView(featureView, featureController) {},
    detachFeatureView(featureView, featureController) {
      featureView.remove();
    },
    controllerWillSetGeoBounds(newGeoBounds, oldGeoBounds, featureController) {
      this.owner.callObservers("controllerWillSetFeatureGeoBounds", newGeoBounds, oldGeoBounds, featureController, this.owner);
    },
    controllerDidSetGeoBounds(newGeoBounds, oldGeoBounds, featureController) {
      this.owner.callObservers("controllerDidSetFeatureGeoBounds", newGeoBounds, oldGeoBounds, featureController, this.owner);
    },
    createController(featureTrait) {
      if (featureTrait !== void 0) {
        return GeoController.fromTrait(featureTrait);
      } else {
        return TraitViewControllerSet.prototype.createController.call(this);
      }
    }
  }) ], GeoLayerController.prototype, "features", void 0);
  class GeoRippleView extends GeoView {
    constructor() {
      super();
      Object.defineProperty(this, "viewBounds", {
        value: math.R2Box.undefined(),
        writable: true,
        enumerable: true,
        configurable: true
      });
      this.setFlags(this.flags | View.UnboundedFlag);
    }
    onProject(viewContext) {
      super.onProject(viewContext);
      this.projectRipple(viewContext);
    }
    projectGeoCenter(geoCenter) {
      if (this.mounted) {
        const viewContext = this.viewContext;
        const viewCenter = geoCenter !== null && geoCenter.isDefined() ? viewContext.geoViewport.project(geoCenter) : null;
        this.viewCenter.setInterpolatedValue(this.viewCenter.value, viewCenter);
        this.projectRipple(viewContext);
      }
    }
    projectRipple(viewContext) {
      if (this.viewCenter.hasAffinity(component.Affinity.Intrinsic)) {
        const geoCenter = this.geoCenter.value;
        const viewCenter = geoCenter !== null && geoCenter.isDefined() ? viewContext.geoViewport.project(geoCenter) : null;
        this.viewCenter.setValue(viewCenter, component.Affinity.Intrinsic);
      }
    }
    onRender(viewContext) {
      super.onRender(viewContext);
      const renderer = viewContext.renderer;
      if (renderer instanceof PaintingRenderer && !this.hidden && !this.culled) {
        this.renderRipple(renderer.context, viewContext.viewFrame);
      }
    }
    renderRipple(context, frame) {
      const viewCenter = this.viewCenter.value;
      if (viewCenter !== null && viewCenter.isDefined()) {
        const size = Math.min(frame.width, frame.height);
        const radius = this.radius.getValue().pxValue(size);
        const stroke = this.stroke.value;
        if (stroke !== null) {
          const contextLineWidth = context.lineWidth;
          const contextStrokeStyle = context.strokeStyle;
          context.beginPath();
          context.arc(viewCenter.x, viewCenter.y, radius, 0, 2 * Math.PI);
          const strokeWidth = this.strokeWidth.value;
          if (strokeWidth !== null) {
            context.lineWidth = strokeWidth.pxValue(size);
          }
          context.strokeStyle = stroke.toString();
          context.stroke();
          context.lineWidth = contextLineWidth;
          context.strokeStyle = contextStrokeStyle;
        }
      }
    }
    renderGeoBounds(viewContext, outlineColor, outlineWidth) {}
    updateGeoBounds() {}
    updateViewBounds() {
      this.viewBounds = this.deriveViewBounds();
    }
    deriveViewBounds() {
      const viewCenter = this.viewCenter.value;
      if (viewCenter !== null && viewCenter.isDefined()) {
        return viewCenter.bounds;
      } else {
        return math.R2Box.undefined();
      }
    }
    ripple(options) {
      let source;
      if (options === void 0 || options.source === void 0) {
        source = null;
      } else {
        source = options.source;
      }
      let center;
      if (options === void 0 || options.center === void 0 || options.center === null) {
        center = null;
      } else {
        center = geo.GeoPoint.fromAny(options.center);
      }
      let width;
      if (options === void 0 || options.width === void 0 || options.width === null) {
        width = null;
      } else {
        width = math.Length.fromAny(options.width);
      }
      let radius;
      if (options === void 0 || options.radius === void 0 || options.radius === null) {
        radius = math.Length.pct(12.5);
      } else {
        radius = math.Length.fromAny(options.radius);
      }
      let color;
      if (options === void 0 || options.color === void 0 || options.color === null) {
        color = this.getLookOr(Look.accentColor, null);
      } else if (options.color instanceof Look) {
        color = this.getLookOr(options.color, null);
      } else {
        color = Color.fromAny(options.color);
      }
      let timing;
      if (options === void 0 || options.timing === void 0 || options.timing === true) {
        timing = this.getLookOr(Look.timing, Mood.ambient, false);
      } else if (typeof options.timing === "number") {
        timing = util.Easing.linear.withDuration(options.timing);
      } else {
        timing = util.Timing.fromAny(options.timing);
      }
      const opacity = options !== void 0 ? options.opacity : void 0;
      if (source !== null) {
        this.source.setView(source);
      }
      if (center !== null) {
        this.geoCenter.setState(center, component.Affinity.Intrinsic);
      }
      if (width !== null) {
        this.strokeWidth.setState(width, component.Affinity.Intrinsic);
      }
      this.radius.setState(radius, timing);
      if (color !== null) {
        this.stroke.setState(opacity !== void 0 ? color.alpha(opacity) : color);
        this.stroke.setState(color.alpha(0), timing);
      }
      return this;
    }
    static ripple(sourceView, options) {
      if (!document.hidden && !sourceView.hidden && !sourceView.culled && sourceView.geoBounds.intersects(sourceView.geoViewport.geoFrame)) {
        const rippleView = GeoRippleView.create();
        rippleView.source.setView(sourceView);
        let containerView = sourceView.getBase(GeoView);
        if (containerView === null) {
          containerView = sourceView;
        }
        containerView.appendChild(rippleView);
        rippleView.ripple(options);
        return rippleView;
      } else {
        return null;
      }
    }
  }
  __decorate([ component.Animator({
    type: geo.GeoPoint,
    value: null,
    didSetState(newGeoCenter, oldGeoCenter) {
      this.owner.projectGeoCenter(newGeoCenter);
    },
    willSetValue(newGeoCenter, oldGeoCenter) {
      this.owner.callObservers("viewWillSetGeoCenter", newGeoCenter, oldGeoCenter, this.owner);
    },
    didSetValue(newGeoCenter, oldGeoCenter) {
      this.owner.setGeoBounds(newGeoCenter !== null ? newGeoCenter.bounds : geo.GeoBox.undefined());
      if (this.mounted) {
        this.owner.projectRipple(this.owner.viewContext);
      }
      this.owner.callObservers("viewDidSetGeoCenter", newGeoCenter, oldGeoCenter, this.owner);
    }
  }) ], GeoRippleView.prototype, "geoCenter", void 0);
  __decorate([ component.Animator({
    type: math.R2Point,
    value: math.R2Point.undefined(),
    updateFlags: View.NeedsRender,
    didSetValue(newViewCenter, oldViewCenter) {
      this.owner.updateViewBounds();
    }
  }) ], GeoRippleView.prototype, "viewCenter", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.zero(),
    updateFlags: View.NeedsRender,
    didTransition() {
      this.owner.source.setView(null);
      this.owner.remove();
    }
  }) ], GeoRippleView.prototype, "radius", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    look: Look.accentColor,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], GeoRippleView.prototype, "stroke", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.px(1),
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], GeoRippleView.prototype, "strokeWidth", void 0);
  __decorate([ ViewRef({
    observes: true,
    didAttachView(sourceView) {
      this.owner.geoCenter.setState(sourceView.geoBounds.center, component.Affinity.Intrinsic);
    },
    viewDidUnmount(sourceView) {
      this.owner.remove();
    },
    viewDidSetGeoBounds(newGeoBounds, oldGeoBounds, sourceView) {
      this.owner.geoCenter.setState(newGeoBounds.center, component.Affinity.Intrinsic);
    }
  }) ], GeoRippleView.prototype, "source", void 0);
  class GeoRasterView extends GeoView {
    constructor() {
      super();
      this.canvas = this.createCanvas();
      Object.defineProperty(this, "renderer", {
        value: this.createRenderer(),
        writable: true,
        enumerable: true,
        configurable: true
      });
      this.ownRasterFrame = null;
    }
    get pixelRatio() {
      return window.devicePixelRatio || 1;
    }
    get compositor() {
      const parent = this.parent;
      if (parent instanceof GraphicsView) {
        return parent.renderer;
      } else {
        return null;
      }
    }
    setRenderer(renderer) {
      if (typeof renderer === "string") {
        renderer = this.createRenderer(renderer);
      }
      this.renderer = renderer;
      this.requireUpdate(View.NeedsRender | View.NeedsComposite);
    }
    createRenderer(rendererType = "canvas") {
      if (rendererType === "canvas") {
        const context = this.canvas.getContext("2d");
        if (context !== null) {
          return new CanvasRenderer(context, math.Transform.identity(), this.pixelRatio);
        } else {
          throw new Error("Failed to create canvas rendering context");
        }
      } else if (rendererType === "webgl") {
        const context = this.canvas.getContext("webgl");
        if (context !== null) {
          return new WebGLRenderer(context, this.pixelRatio);
        } else {
          throw new Error("Failed to create webgl rendering context");
        }
      } else {
        throw new Error("Failed to create " + rendererType + " renderer");
      }
    }
    needsUpdate(updateFlags, immediate) {
      updateFlags = super.needsUpdate(updateFlags, immediate);
      const rasterFlags = updateFlags & (View.NeedsRender | View.NeedsComposite);
      if (rasterFlags !== 0) {
        updateFlags |= View.NeedsComposite;
        this.setFlags(this.flags | View.NeedsDisplay | View.NeedsComposite | rasterFlags);
      }
      return updateFlags;
    }
    needsProcess(processFlags, viewContext) {
      if ((this.flags & View.ProcessMask) === 0 && (processFlags & (View.NeedsResize | View.NeedsProject)) === 0) {
        processFlags = 0;
      }
      return processFlags;
    }
    onResize(viewContext) {
      super.onResize(viewContext);
      this.requireUpdate(View.NeedsRender | View.NeedsComposite);
    }
    onProject(viewContext) {
      super.onProject(viewContext);
      this.projectRaster(viewContext);
    }
    projectGeoAnchor(geoAnchor) {
      if (this.mounted) {
        const viewContext = this.viewContext;
        const viewAnchor = geoAnchor !== null && geoAnchor.isDefined() ? viewContext.geoViewport.project(geoAnchor) : null;
        this.viewAnchor.setInterpolatedValue(this.viewAnchor.value, viewAnchor);
        this.projectRaster(viewContext);
      }
    }
    projectRaster(viewContext) {
      let viewAnchor;
      if (this.viewAnchor.hasAffinity(component.Affinity.Intrinsic)) {
        const geoAnchor = this.geoAnchor.value;
        viewAnchor = geoAnchor !== null && geoAnchor.isDefined() ? viewContext.geoViewport.project(geoAnchor) : null;
        this.viewAnchor.setValue(viewAnchor, component.Affinity.Intrinsic);
      } else {
        viewAnchor = this.viewAnchor.value;
      }
      if (viewAnchor !== null) {
        const viewFrame = viewContext.viewFrame;
        const viewWidth = viewFrame.width;
        const viewHeight = viewFrame.height;
        const viewSize = Math.min(viewWidth, viewHeight);
        let width = this.width.value;
        width = width instanceof math.Length ? width.pxValue(viewSize) : viewWidth;
        let height = this.height.value;
        height = height instanceof math.Length ? height.pxValue(viewSize) : viewHeight;
        const x = viewAnchor.x - width * this.xAlign.getValue();
        const y = viewAnchor.y - height * this.yAlign.getValue();
        const rasterFrame = new math.R2Box(x, y, x + width, y + height);
        this.setRasterFrame(rasterFrame);
        this.setViewFrame(rasterFrame);
        this.setCulled(!viewFrame.intersects(rasterFrame));
      } else {
        this.setCulled(!this.viewFrame.intersects(this.rasterFrame));
      }
    }
    needsDisplay(displayFlags, viewContext) {
      if ((this.flags & View.DisplayMask) !== 0) {
        displayFlags |= View.NeedsComposite;
      } else if ((displayFlags & View.NeedsComposite) !== 0) {
        displayFlags = View.NeedsDisplay | View.NeedsComposite;
      } else {
        displayFlags = 0;
      }
      return displayFlags;
    }
    onRender(viewContext) {
      const rasterFrame = this.rasterFrame;
      this.resizeCanvas(this.canvas, rasterFrame);
      this.resetRenderer(rasterFrame);
      this.clearCanvas(rasterFrame);
      super.onRender(viewContext);
    }
    didComposite(viewContext) {
      this.compositeImage(viewContext);
      super.didComposite(viewContext);
    }
    extendViewContext(viewContext) {
      const rasterViewContext = Object.create(viewContext);
      rasterViewContext.compositor = viewContext.renderer;
      rasterViewContext.renderer = this.renderer;
      return rasterViewContext;
    }
    get rasterFrame() {
      let rasterFrame = this.ownRasterFrame;
      if (rasterFrame === null) {
        rasterFrame = this.deriveRasterFrame();
      }
      return rasterFrame;
    }
    setRasterFrame(rasterFrame) {
      this.ownRasterFrame = rasterFrame;
    }
    deriveRasterFrame() {
      return this.deriveViewBounds();
    }
    createCanvas() {
      return document.createElement("canvas");
    }
    resizeCanvas(canvas, rasterFrame) {
      const pixelRatio = this.pixelRatio;
      const newWidth = rasterFrame.width;
      const newHeight = rasterFrame.height;
      const newCanvasWidth = newWidth * pixelRatio;
      const newCanvasHeight = newHeight * pixelRatio;
      const oldCanvasWidth = canvas.width;
      const oldCanvasHeight = canvas.height;
      if (newCanvasWidth !== oldCanvasWidth || newCanvasHeight !== oldCanvasHeight) {
        canvas.width = newCanvasWidth;
        canvas.height = newCanvasHeight;
        canvas.style.width = newWidth + "px";
        canvas.style.height = newHeight + "px";
      }
    }
    clearCanvas(rasterFrame) {
      const renderer = this.renderer;
      if (renderer instanceof CanvasRenderer) {
        renderer.context.clearRect(0, 0, rasterFrame.xMax, rasterFrame.yMax);
      } else if (renderer instanceof WebGLRenderer) {
        const context = renderer.context;
        context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);
      }
    }
    resetRenderer(rasterFrame) {
      const renderer = this.renderer;
      if (renderer instanceof CanvasRenderer) {
        const pixelRatio = this.pixelRatio;
        const dx = rasterFrame.xMin * pixelRatio;
        const dy = rasterFrame.yMin * pixelRatio;
        renderer.context.setTransform(pixelRatio, 0, 0, pixelRatio, -dx, -dy);
        renderer.setTransform(math.Transform.affine(pixelRatio, 0, 0, pixelRatio, -dx, -dy));
      } else if (renderer instanceof WebGLRenderer) {
        renderer.context.viewport(rasterFrame.x, rasterFrame.y, rasterFrame.xMax, rasterFrame.yMax);
      }
    }
    compositeImage(viewContext) {
      const compositor = viewContext.compositor;
      if (compositor instanceof CanvasRenderer) {
        const context = compositor.context;
        const rasterFrame = this.rasterFrame;
        const canvas = this.canvas;
        if (rasterFrame.isDefined() && rasterFrame.width !== 0 && rasterFrame.height !== 0 && canvas.width !== 0 && canvas.height !== 0) {
          const globalAlpha = context.globalAlpha;
          const globalCompositeOperation = context.globalCompositeOperation;
          context.globalAlpha = this.opacity.getValue();
          context.globalCompositeOperation = this.compositeOperation.getValue();
          context.drawImage(canvas, rasterFrame.x, rasterFrame.y, rasterFrame.width, rasterFrame.height);
          context.globalAlpha = globalAlpha;
          context.globalCompositeOperation = globalCompositeOperation;
        }
      }
    }
    ripple(options) {
      return GeoRippleView.ripple(this, options);
    }
    init(init) {
      super.init(init);
      if (init.geoAnchor !== void 0) {
        this.geoAnchor(init.geoAnchor);
      }
      if (init.viewAnchor !== void 0) {
        this.viewAnchor(init.viewAnchor);
      }
      if (init.xAlign !== void 0) {
        this.xAlign(init.xAlign);
      }
      if (init.yAlign !== void 0) {
        this.yAlign(init.yAlign);
      }
      if (init.width !== void 0) {
        this.width(init.width);
      }
      if (init.height !== void 0) {
        this.height(init.height);
      }
      if (init.opacity !== void 0) {
        this.opacity(init.opacity);
      }
      if (init.compositeOperation !== void 0) {
        this.compositeOperation(init.compositeOperation);
      }
    }
  }
  GeoRasterView.MountFlags = GeoView.MountFlags | View.NeedsComposite;
  GeoRasterView.UncullFlags = GeoView.UncullFlags | View.NeedsComposite;
  GeoRasterView.UnhideFlags = GeoView.UnhideFlags | View.NeedsComposite;
  __decorate([ component.Animator({
    type: geo.GeoPoint,
    value: null,
    didSetState(newGeoCenter, oldGeoCenter) {
      this.owner.projectGeoAnchor(newGeoCenter);
    },
    willSetValue(newGeoAnchor, oldGeoAnchor) {
      this.owner.callObservers("viewWillSetGeoAnchor", newGeoAnchor, oldGeoAnchor, this.owner);
    },
    didSetValue(newGeoAnchor, oldGeoAnchor) {
      this.owner.setGeoBounds(newGeoAnchor !== null ? newGeoAnchor.bounds : geo.GeoBox.undefined());
      if (this.mounted) {
        this.owner.projectRaster(this.owner.viewContext);
      }
      this.owner.callObservers("viewDidSetGeoAnchor", newGeoAnchor, oldGeoAnchor, this.owner);
    }
  }) ], GeoRasterView.prototype, "geoAnchor", void 0);
  __decorate([ component.Animator({
    type: math.R2Point,
    value: math.R2Point.undefined()
  }) ], GeoRasterView.prototype, "viewAnchor", void 0);
  __decorate([ component.Animator({
    type: Number,
    value: .5,
    updateFlags: View.NeedsComposite
  }) ], GeoRasterView.prototype, "xAlign", void 0);
  __decorate([ component.Animator({
    type: Number,
    value: .5,
    updateFlags: View.NeedsComposite
  }) ], GeoRasterView.prototype, "yAlign", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    updateFlags: View.NeedsResize | View.NeedsLayout | View.NeedsRender | View.NeedsComposite
  }) ], GeoRasterView.prototype, "width", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    updateFlags: View.NeedsResize | View.NeedsLayout | View.NeedsRender | View.NeedsComposite
  }) ], GeoRasterView.prototype, "height", void 0);
  __decorate([ ThemeAnimator({
    type: Number,
    value: 1,
    updateFlags: View.NeedsComposite
  }) ], GeoRasterView.prototype, "opacity", void 0);
  __decorate([ component.Animator({
    type: String,
    value: "source-over",
    updateFlags: View.NeedsComposite
  }) ], GeoRasterView.prototype, "compositeOperation", void 0);
  class GeoGridView extends GeoView {
    constructor(geoTile) {
      super();
      this.geoTile = geoTile;
      this.geoBounds = geoTile.bounds;
    }
    setGeoBounds(newGeoBounds) {}
    updateGeoBounds() {}
  }
  class GeoGridTrait extends GeoLayerTrait {
    constructor(geoTile) {
      super();
      this.geoTile = geoTile;
      this.geoBounds = geoTile.bounds;
    }
    setGeoBounds(newGeoBounds) {}
    createTileTrait(geoTile) {
      return new GeoGridTrait(geoTile);
    }
    createTileModel(geoTile) {
      const tileTrait = this.createTileTrait(geoTile);
      if (tileTrait !== null) {
        const tileModel = new Model;
        tileModel.setTrait("tile", tileTrait);
        return tileModel;
      } else {
        return null;
      }
    }
    initTiles() {
      let southWestModel = this.getChild("southWest");
      if (southWestModel === null) {
        southWestModel = this.createTileModel(this.geoTile.southWestTile);
        if (southWestModel !== null) {
          this.setChild("southWest", southWestModel);
        }
      }
      let northWestModel = this.getChild("northWest");
      if (northWestModel === null) {
        northWestModel = this.createTileModel(this.geoTile.northWestTile);
        if (northWestModel !== null) {
          this.setChild("northWest", northWestModel);
        }
      }
      let southEastModel = this.getChild("southEast");
      if (southEastModel === null) {
        southEastModel = this.createTileModel(this.geoTile.southEastTile);
        if (southEastModel !== null) {
          this.setChild("southEast", southEastModel);
        }
      }
      let northEastTile = this.getChild("northEast");
      if (northEastTile === null) {
        northEastTile = this.createTileModel(this.geoTile.northEastTile);
        if (northEastTile !== null) {
          this.setChild("northEast", northEastTile);
        }
      }
    }
    onStartConsuming() {
      super.onStartConsuming();
      this.initTiles();
    }
  }
  __decorate([ TraitSet({
    extends: true,
    detectModel(model) {
      const geoTrait = model.getTrait(GeoTrait);
      return !(geoTrait instanceof GeoGridTrait) ? geoTrait : null;
    }
  }) ], GeoGridTrait.prototype, "features", void 0);
  __decorate([ TraitSet({
    type: GeoGridTrait,
    binds: true,
    willAttachTrait(tileTrait) {
      this.owner.callObservers("traitWillAttachTile", tileTrait, this.owner);
    },
    didDetachTrait(tileTrait) {
      this.owner.callObservers("traitDidDetachTile", tileTrait, this.owner);
    },
    detectModel(model) {
      return model.getTrait(GeoGridTrait);
    },
    detectTrait(trait) {
      return null;
    }
  }) ], GeoGridTrait.prototype, "tiles", void 0);
  class GeoGridController extends GeoLayerController {
    constructor(geoTile) {
      super();
      this.geoTile = geoTile;
    }
    get minCullZoom() {
      return this.geoTile.z;
    }
    get maxCullZoom() {
      return Infinity;
    }
    autoCullGeoView(geoViewport, geoView) {
      const tileIsVisible = this.minCullZoom <= geoViewport.zoom && geoViewport.zoom < this.maxCullZoom && geoViewport.geoFrame.intersects(geoView.geoBounds);
      geoView.setCulled(!tileIsVisible);
    }
    get minConsumeZoom() {
      return this.geoTile.z;
    }
    get maxConsumeZoom() {
      return Infinity;
    }
    autoConsumeGeoView(geoViewport, geoView) {
      const geoTrait = this.geo.trait;
      if (geoTrait !== null) {
        const viewIsVisible = this.minConsumeZoom <= geoViewport.zoom && geoViewport.zoom < this.maxConsumeZoom && geoViewport.geoFrame.intersects(geoView.geoBounds);
        if (viewIsVisible) {
          geoTrait.consume(this);
        } else {
          geoTrait.unconsume(this);
        }
      }
    }
  }
  __decorate([ TraitViewRef({
    extends: true,
    traitType: GeoGridTrait,
    observesTrait: true,
    didAttachTrait(geoTrait, targetTrait) {
      const tileTraits = geoTrait.tiles.traits;
      for (const traitId in tileTraits) {
        const tileTrait = tileTraits[traitId];
        this.owner.tiles.addTraitController(tileTrait);
      }
      const geoView = this.view;
      if (geoView !== null && !geoView.culled) {
        geoTrait.consume(this.owner);
      }
      GeoLayerController.geo.prototype.didAttachTrait.call(this, geoTrait, targetTrait);
    },
    willDetachTrait(geoTrait) {
      GeoLayerController.geo.prototype.willDetachTrait.call(this, geoTrait);
      geoTrait.unconsume(this.owner);
      const tileTraits = geoTrait.tiles.traits;
      for (const traitId in tileTraits) {
        const tileTrait = tileTraits[traitId];
        this.owner.tiles.deleteTraitController(tileTrait);
      }
    },
    traitWillAttachTile(tileTrait, targetTrait) {
      this.owner.tiles.addTraitController(tileTrait, targetTrait);
    },
    traitDidDetachTile(tileTrait) {
      this.owner.tiles.deleteTraitController(tileTrait);
    },
    viewType: GeoGridView,
    observesView: true,
    didAttachView(geoView, targetView) {
      GeoLayerController.geo.prototype.didAttachView.call(this, geoView, targetView);
      geoView.setCulled(true);
      const tileControllers = this.owner.tiles.controllers;
      for (const controllerId in tileControllers) {
        const tileController = tileControllers[controllerId];
        const tileView = tileController.geo.view;
        if (tileView !== null && tileView.parent === null) {
          tileController.geo.insertView(geoView);
        }
      }
    },
    viewDidProject(viewContext, geoView) {
      this.owner.autoCullGeoView(viewContext.geoViewport, geoView);
      this.owner.autoConsumeGeoView(viewContext.geoViewport, geoView);
    },
    createView() {
      return new GeoGridView(this.owner.geoTile);
    }
  }) ], GeoGridController.prototype, "geo", void 0);
  __decorate([ TraitViewControllerSet({
    extends: true,
    detectController(controller) {
      return controller instanceof GeoController && !(controller instanceof GeoGridController) ? controller : null;
    }
  }) ], GeoGridController.prototype, "features", void 0);
  __decorate([ TraitViewControllerSet({
    implements: true,
    type: GeoGridController,
    binds: true,
    observes: true,
    get parentView() {
      return this.owner.geo.view;
    },
    getTraitViewRef(tileController) {
      return tileController.geo;
    },
    willAttachController(tileController) {
      this.owner.callObservers("controllerWillAttachTile", tileController, this.owner);
    },
    didAttachController(tileController) {
      const tileTrait = tileController.geo.trait;
      if (tileTrait !== null) {
        this.attachTileTrait(tileTrait, tileController);
      }
      const tileView = tileController.geo.view;
      if (tileView !== null) {
        this.attachTileView(tileView, tileController);
      }
    },
    willDetachController(tileController) {
      const tileView = tileController.geo.view;
      if (tileView !== null) {
        this.detachTileView(tileView, tileController);
      }
      const tileTrait = tileController.geo.trait;
      if (tileTrait !== null) {
        this.detachTileTrait(tileTrait, tileController);
      }
    },
    didDetachController(tileController) {
      this.owner.callObservers("controllerDidDetachTile", tileController, this.owner);
    },
    controllerWillAttachGeoTrait(tileTrait, tileController) {
      this.owner.callObservers("controllerWillAttachTileTrait", tileTrait, tileController, this.owner);
      this.attachTileTrait(tileTrait, tileController);
    },
    controllerDidDetachGeoTrait(tileTrait, tileController) {
      this.detachTileTrait(tileTrait, tileController);
      this.owner.callObservers("controllerDidDetachTileTrait", tileTrait, tileController, this.owner);
    },
    attachTileTrait(tileTrait, tileController) {},
    detachTileTrait(tileTrait, tileController) {},
    controllerWillAttachGeoView(tileView, tileController) {
      this.owner.callObservers("controllerWillAttachTileView", tileView, tileController, this.owner);
      this.attachTileView(tileView, tileController);
    },
    controllerDidDetachGeoView(tileView, tileController) {
      this.detachTileView(tileView, tileController);
      this.owner.callObservers("controllerDidDetachTileView", tileView, tileController, this.owner);
    },
    attachTileView(tileView, tileController) {},
    detachTileView(tileView, tileController) {
      tileView.remove();
    },
    createController(tileTrait) {
      if (tileTrait !== void 0) {
        return new GeoGridController(tileTrait.geoTile);
      } else {
        return TraitViewControllerSet.prototype.createController.call(this);
      }
    }
  }) ], GeoGridController.prototype, "tiles", void 0);
  class GeoCircleView extends GeoView {
    constructor() {
      super();
      Object.defineProperty(this, "viewBounds", {
        value: math.R2Box.undefined(),
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
    onProject(viewContext) {
      super.onProject(viewContext);
      this.projectCircle(viewContext);
    }
    projectGeoCenter(geoCenter) {
      if (this.mounted) {
        const viewContext = this.viewContext;
        const viewCenter = geoCenter !== null && geoCenter.isDefined() ? viewContext.geoViewport.project(geoCenter) : null;
        this.viewCenter.setInterpolatedValue(this.viewCenter.value, viewCenter);
        this.projectCircle(viewContext);
      }
    }
    projectCircle(viewContext) {
      if (component.Affinity.Intrinsic >= (this.viewCenter.flags & component.Affinity.Mask)) {
        const geoCenter = this.geoCenter.value;
        const viewCenter = geoCenter !== null && geoCenter.isDefined() ? viewContext.geoViewport.project(geoCenter) : null;
        this.viewCenter.value = viewCenter;
      }
      const viewFrame = viewContext.viewFrame;
      const size = Math.min(viewFrame.width, viewFrame.height);
      const r = this.radius.getValue().pxValue(size);
      const p0 = this.viewCenter.value;
      const p1 = this.viewCenter.state;
      if (p0 !== null && p1 !== null && (viewFrame.intersectsCircle(new math.R2Circle(p0.x, p0.y, r)) || viewFrame.intersectsSegment(new math.R2Segment(p0.x, p0.y, p1.x, p1.y)))) {
        this.setCulled(false);
      } else {
        this.setCulled(true);
      }
    }
    onRender(viewContext) {
      super.onRender(viewContext);
      const renderer = viewContext.renderer;
      if (renderer instanceof PaintingRenderer && !this.hidden && !this.culled) {
        this.renderCircle(renderer.context, viewContext.viewFrame);
      }
    }
    renderCircle(context, frame) {
      const viewCenter = this.viewCenter.value;
      if (viewCenter !== null && viewCenter.isDefined()) {
        const contextFillStyle = context.fillStyle;
        const contextLineWidth = context.lineWidth;
        const contextStrokeStyle = context.strokeStyle;
        const size = Math.min(frame.width, frame.height);
        const radius = this.radius.getValue().pxValue(size);
        context.beginPath();
        context.arc(viewCenter.x, viewCenter.y, radius, 0, 2 * Math.PI);
        const fill = this.fill.value;
        if (fill !== null) {
          context.fillStyle = fill.toString();
          context.fill();
        }
        const stroke = this.stroke.value;
        if (stroke !== null) {
          const strokeWidth = this.strokeWidth.value;
          if (strokeWidth !== null) {
            context.lineWidth = strokeWidth.pxValue(size);
          }
          context.strokeStyle = stroke.toString();
          context.stroke();
        }
        context.fillStyle = contextFillStyle;
        context.lineWidth = contextLineWidth;
        context.strokeStyle = contextStrokeStyle;
      }
    }
    renderGeoBounds(viewContext, outlineColor, outlineWidth) {}
    updateGeoBounds() {}
    deriveViewBounds() {
      const viewCenter = this.viewCenter.value;
      if (viewCenter !== null && viewCenter.isDefined()) {
        const viewFrame = this.viewContext.viewFrame;
        const size = Math.min(viewFrame.width, viewFrame.height);
        const radius = this.radius.getValue().pxValue(size);
        return new math.R2Box(viewCenter.x - radius, viewCenter.y - radius, viewCenter.x + radius, viewCenter.y + radius);
      } else {
        return math.R2Box.undefined();
      }
    }
    get popoverFrame() {
      const viewCenter = this.viewCenter.value;
      if (viewCenter !== null && viewCenter.isDefined()) {
        const viewFrame = this.viewContext.viewFrame;
        const size = Math.min(viewFrame.width, viewFrame.height);
        const inversePageTransform = this.pageTransform.inverse();
        const px = inversePageTransform.transformX(viewCenter.x, viewCenter.y);
        const py = inversePageTransform.transformY(viewCenter.x, viewCenter.y);
        const radius = this.radius.getValue().pxValue(size);
        return new math.R2Box(px - radius, py - radius, px + radius, py + radius);
      } else {
        return this.pageBounds;
      }
    }
    get hitBounds() {
      const viewCenter = this.viewCenter.value;
      if (viewCenter !== null && viewCenter.isDefined()) {
        const viewFrame = this.viewContext.viewFrame;
        const size = Math.min(viewFrame.width, viewFrame.height);
        const radius = this.radius.getValue().pxValue(size);
        const hitRadius = Math.max(this.hitRadius.getValueOr(radius), radius);
        return new math.R2Box(viewCenter.x - hitRadius, viewCenter.y - hitRadius, viewCenter.x + hitRadius, viewCenter.y + hitRadius);
      } else {
        return this.viewBounds;
      }
    }
    hitTest(x, y, viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer) {
        return this.hitTestCircle(x, y, renderer.context, viewContext.viewFrame, renderer.transform);
      }
      return null;
    }
    hitTestCircle(x, y, context, frame, transform) {
      const viewCenter = this.viewCenter.value;
      if (viewCenter !== null && viewCenter.isDefined()) {
        const size = Math.min(frame.width, frame.height);
        const radius = this.radius.getValue().pxValue(size);
        if (this.fill.value !== null) {
          const hitRadius = Math.max(this.hitRadius.getValueOr(radius), radius);
          const dx = viewCenter.x - x;
          const dy = viewCenter.y - y;
          if (dx * dx + dy * dy < hitRadius * hitRadius) {
            return this;
          }
        }
        const strokeWidth = this.strokeWidth.value;
        if (this.stroke.value !== null && strokeWidth !== null) {
          const contextLineWidth = context.lineWidth;
          const p = transform.transform(x, y);
          context.beginPath();
          context.arc(viewCenter.x, viewCenter.y, radius, 0, 2 * Math.PI);
          context.lineWidth = strokeWidth.pxValue(size);
          const pointInStroke = context.isPointInStroke(p.x, p.y);
          context.lineWidth = contextLineWidth;
          if (pointInStroke) {
            return this;
          }
        }
      }
      return null;
    }
    ripple(options) {
      return GeoRippleView.ripple(this, options);
    }
    init(init) {
      super.init(init);
      if (init.geoCenter !== void 0) {
        this.geoCenter(init.geoCenter);
      }
      if (init.viewCenter !== void 0) {
        this.viewCenter(init.viewCenter);
      }
      if (init.radius !== void 0) {
        this.radius(init.radius);
      }
      if (init.hitRadius !== void 0) {
        this.hitRadius(init.hitRadius);
      }
      if (init.fill !== void 0) {
        this.fill(init.fill);
      }
      if (init.stroke !== void 0) {
        this.stroke(init.stroke);
      }
      if (init.strokeWidth !== void 0) {
        this.strokeWidth(init.strokeWidth);
      }
    }
  }
  __decorate([ component.Animator({
    type: geo.GeoPoint,
    value: null,
    didSetState(newGeoCenter, oldGeoCenter) {
      this.owner.projectGeoCenter(newGeoCenter);
    },
    willSetValue(newGeoCenter, oldGeoCenter) {
      this.owner.callObservers("viewWillSetGeoCenter", newGeoCenter, oldGeoCenter, this.owner);
    },
    didSetValue(newGeoCenter, oldGeoCenter) {
      this.owner.setGeoBounds(newGeoCenter !== null ? newGeoCenter.bounds : geo.GeoBox.undefined());
      if (this.mounted) {
        this.owner.projectCircle(this.owner.viewContext);
      }
      this.owner.callObservers("viewDidSetGeoCenter", newGeoCenter, oldGeoCenter, this.owner);
    }
  }) ], GeoCircleView.prototype, "geoCenter", void 0);
  __decorate([ component.Animator({
    type: math.R2Point,
    value: math.R2Point.undefined(),
    updateFlags: View.NeedsRender
  }) ], GeoCircleView.prototype, "viewCenter", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.zero(),
    updateFlags: View.NeedsRender
  }) ], GeoCircleView.prototype, "radius", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], GeoCircleView.prototype, "fill", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], GeoCircleView.prototype, "stroke", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], GeoCircleView.prototype, "strokeWidth", void 0);
  __decorate([ component.Property({
    type: Number
  }) ], GeoCircleView.prototype, "hitRadius", void 0);
  class GeoArcView extends GeoView {
    constructor() {
      super();
      Object.defineProperty(this, "viewBounds", {
        value: math.R2Box.undefined(),
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
    get value() {
      const viewCenter = this.viewCenter.value;
      if (viewCenter !== null && viewCenter.isDefined()) {
        return new Arc(viewCenter, this.innerRadius.value, this.outerRadius.value, this.startAngle.value, this.sweepAngle.value, this.padAngle.value, this.padRadius.value, this.cornerRadius.value);
      } else {
        return null;
      }
    }
    get state() {
      const viewCenter = this.viewCenter.state;
      if (viewCenter !== null && viewCenter.isDefined()) {
        return new Arc(viewCenter, this.innerRadius.state, this.outerRadius.state, this.startAngle.state, this.sweepAngle.state, this.padAngle.state, this.padRadius.state, this.cornerRadius.state);
      } else {
        return null;
      }
    }
    onProject(viewContext) {
      super.onProject(viewContext);
      this.projectArc(viewContext);
    }
    projectGeoCenter(geoCenter) {
      if (this.mounted) {
        const viewContext = this.viewContext;
        const viewCenter = geoCenter !== null && geoCenter.isDefined() ? viewContext.geoViewport.project(geoCenter) : null;
        this.viewCenter.setInterpolatedValue(this.viewCenter.value, viewCenter);
        this.projectArc(viewContext);
      }
    }
    projectArc(viewContext) {
      if (component.Affinity.Intrinsic >= (this.viewCenter.flags & component.Affinity.Mask)) {
        const geoCenter = this.geoCenter.value;
        const viewCenter = geoCenter !== null && geoCenter.isDefined() ? viewContext.geoViewport.project(geoCenter) : null;
        this.viewCenter.value = viewCenter;
      }
      const viewFrame = viewContext.viewFrame;
      const size = Math.min(viewFrame.width, viewFrame.height);
      const r = this.outerRadius.getValue().pxValue(size);
      const p0 = this.viewCenter.value;
      const p1 = this.viewCenter.state;
      if (p0 !== null && p1 !== null && (viewFrame.intersectsCircle(new math.R2Circle(p0.x, p0.y, r)) || viewFrame.intersectsSegment(new math.R2Segment(p0.x, p0.y, p1.x, p1.y)))) {
        this.setCulled(false);
      } else {
        this.setCulled(true);
      }
    }
    onRender(viewContext) {
      super.onRender(viewContext);
      const renderer = viewContext.renderer;
      if (renderer instanceof PaintingRenderer && !this.hidden && !this.culled) {
        this.renderArc(renderer.context, viewContext.viewFrame);
      }
    }
    renderArc(context, frame) {
      const arc = this.value;
      if (arc !== null && frame.isDefined()) {
        const contextFillStyle = context.fillStyle;
        const contextLineWidth = context.lineWidth;
        const contextStrokeStyle = context.strokeStyle;
        context.beginPath();
        arc.draw(context, frame);
        const fill = this.fill.value;
        if (fill !== null) {
          context.fillStyle = fill.toString();
          context.fill();
        }
        const stroke = this.stroke.value;
        if (stroke !== null) {
          const strokeWidth = this.strokeWidth.value;
          if (strokeWidth !== null) {
            const size = Math.min(frame.width, frame.height);
            context.lineWidth = strokeWidth.pxValue(size);
          }
          context.strokeStyle = stroke.toString();
          context.stroke();
        }
        context.fillStyle = contextFillStyle;
        context.lineWidth = contextLineWidth;
        context.strokeStyle = contextStrokeStyle;
      }
    }
    renderGeoBounds(viewContext, outlineColor, outlineWidth) {}
    updateGeoBounds() {}
    deriveViewBounds() {
      const viewCenter = this.viewCenter.value;
      if (viewCenter !== null && viewCenter.isDefined()) {
        const viewFrame = this.viewContext.viewFrame;
        const size = Math.min(viewFrame.width, viewFrame.height);
        const radius = this.outerRadius.getValue().pxValue(size);
        return new math.R2Box(viewCenter.x - radius, viewCenter.y - radius, viewCenter.x + radius, viewCenter.y + radius);
      } else {
        return math.R2Box.undefined();
      }
    }
    get popoverFrame() {
      const viewCenter = this.viewCenter.value;
      if (viewCenter !== null && viewCenter.isDefined()) {
        const viewFrame = this.viewContext.viewFrame;
        const size = Math.min(viewFrame.width, viewFrame.height);
        const inversePageTransform = this.pageTransform.inverse();
        const px = inversePageTransform.transformX(viewCenter.x, viewCenter.y);
        const py = inversePageTransform.transformY(viewCenter.x, viewCenter.y);
        const r = (this.innerRadius.getValue().pxValue(size) + this.outerRadius.getValue().pxValue(size)) / 2;
        const a = this.startAngle.getValue().radValue() + this.sweepAngle.getValue().radValue() / 2;
        const x = px + r * Math.cos(a);
        const y = py + r * Math.sin(a);
        return new math.R2Box(x, y, x, y);
      } else {
        return this.pageBounds;
      }
    }
    hitTest(x, y, viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer) {
        const p = renderer.transform.transform(x, y);
        return this.hitTestArc(p.x, p.y, renderer.context, viewContext.viewFrame);
      }
      return null;
    }
    hitTestArc(x, y, context, frame) {
      const arc = this.value;
      if (arc !== null) {
        context.beginPath();
        arc.draw(context, frame);
        if (this.fill.value !== null && context.isPointInPath(x, y)) {
          return this;
        } else if (this.stroke.value !== void 0) {
          const strokeWidth = this.strokeWidth.value;
          if (strokeWidth !== null) {
            const contextLineWidth = context.lineWidth;
            const size = Math.min(frame.width, frame.height);
            context.lineWidth = strokeWidth.pxValue(size);
            const pointInStroke = context.isPointInStroke(x, y);
            context.lineWidth = contextLineWidth;
            if (pointInStroke) {
              return this;
            }
          }
        }
      }
      return null;
    }
    ripple(options) {
      return GeoRippleView.ripple(this, options);
    }
    init(init) {
      super.init(init);
      if (init.geoCenter !== void 0) {
        this.geoCenter(init.geoCenter);
      }
      if (init.viewCenter !== void 0) {
        this.viewCenter(init.viewCenter);
      }
      if (init.innerRadius !== void 0) {
        this.innerRadius(init.innerRadius);
      }
      if (init.outerRadius !== void 0) {
        this.outerRadius(init.outerRadius);
      }
      if (init.startAngle !== void 0) {
        this.startAngle(init.startAngle);
      }
      if (init.sweepAngle !== void 0) {
        this.sweepAngle(init.sweepAngle);
      }
      if (init.padAngle !== void 0) {
        this.padAngle(init.padAngle);
      }
      if (init.padRadius !== void 0) {
        this.padRadius(init.padRadius);
      }
      if (init.cornerRadius !== void 0) {
        this.cornerRadius(init.cornerRadius);
      }
      if (init.fill !== void 0) {
        this.fill(init.fill);
      }
      if (init.stroke !== void 0) {
        this.stroke(init.stroke);
      }
      if (init.strokeWidth !== void 0) {
        this.strokeWidth(init.strokeWidth);
      }
    }
  }
  __decorate([ component.Animator({
    type: geo.GeoPoint,
    value: null,
    didSetState(newGeoCenter, oldGeoCenter) {
      this.owner.projectGeoCenter(newGeoCenter);
    },
    willSetValue(newGeoCenter, oldGeoCenter) {
      this.owner.callObservers("viewWillSetGeoCenter", newGeoCenter, oldGeoCenter, this.owner);
    },
    didSetValue(newGeoCenter, oldGeoCenter) {
      this.owner.setGeoBounds(newGeoCenter !== null ? newGeoCenter.bounds : geo.GeoBox.undefined());
      if (this.mounted) {
        this.owner.projectArc(this.owner.viewContext);
      }
      this.owner.callObservers("viewDidSetGeoCenter", newGeoCenter, oldGeoCenter, this.owner);
    }
  }) ], GeoArcView.prototype, "geoCenter", void 0);
  __decorate([ component.Animator({
    type: math.R2Point,
    value: math.R2Point.undefined(),
    updateFlags: View.NeedsRender
  }) ], GeoArcView.prototype, "viewCenter", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.zero(),
    updateFlags: View.NeedsRender
  }) ], GeoArcView.prototype, "innerRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.zero(),
    updateFlags: View.NeedsRender
  }) ], GeoArcView.prototype, "outerRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Angle,
    value: math.Angle.zero(),
    updateFlags: View.NeedsRender
  }) ], GeoArcView.prototype, "startAngle", void 0);
  __decorate([ ThemeAnimator({
    type: math.Angle,
    value: math.Angle.zero(),
    updateFlags: View.NeedsRender
  }) ], GeoArcView.prototype, "sweepAngle", void 0);
  __decorate([ ThemeAnimator({
    type: math.Angle,
    value: math.Angle.zero(),
    updateFlags: View.NeedsRender
  }) ], GeoArcView.prototype, "padAngle", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    updateFlags: View.NeedsRender
  }) ], GeoArcView.prototype, "padRadius", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: math.Length.zero(),
    updateFlags: View.NeedsRender
  }) ], GeoArcView.prototype, "cornerRadius", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], GeoArcView.prototype, "fill", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], GeoArcView.prototype, "stroke", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], GeoArcView.prototype, "strokeWidth", void 0);
  class GeoPathView extends GeoView {
    constructor() {
      super();
      Object.defineProperty(this, "viewBounds", {
        value: math.R2Box.undefined(),
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
    onProject(viewContext) {
      super.onProject(viewContext);
      this.projectPath(viewContext);
    }
    projectPath(viewContext) {
      const geoViewport = viewContext.geoViewport;
      let viewPath;
      if (this.viewPath.hasAffinity(component.Affinity.Intrinsic)) {
        const geoPath = this.geoPath.value;
        viewPath = geoPath !== null && geoPath.isDefined() ? geoPath.project(geoViewport) : null;
        this.viewPath.setState(viewPath, component.Affinity.Intrinsic);
      } else {
        viewPath = this.viewPath.value;
      }
      if (this.viewCentroid.hasAffinity(component.Affinity.Intrinsic)) {
        const geoCentroid = this.geoCentroid.value;
        const viewCentroid = geoCentroid !== null && geoCentroid.isDefined() ? geoViewport.project(geoCentroid) : null;
        this.viewCentroid.setState(viewCentroid, component.Affinity.Intrinsic);
      }
      this.viewBounds = viewPath !== null ? viewPath.bounds : viewContext.viewFrame;
      this.cullGeoFrame(viewContext.geoViewport.geoFrame);
    }
    updateGeoBounds() {}
    get popoverFrame() {
      const inversePageTransform = this.pageTransform.inverse();
      const viewCentroid = this.viewCentroid.value;
      if (viewCentroid !== null && viewCentroid.isDefined()) {
        const px = inversePageTransform.transformX(viewCentroid.x, viewCentroid.y);
        const py = inversePageTransform.transformY(viewCentroid.x, viewCentroid.y);
        return new math.R2Box(px, py, px, py);
      } else {
        return this.viewBounds.transform(inversePageTransform);
      }
    }
    ripple(options) {
      return GeoRippleView.ripple(this, options);
    }
    init(init) {
      super.init(init);
      if (init.geoPath !== void 0) {
        this.geoPath(init.geoPath);
      }
    }
  }
  __decorate([ component.Animator({
    type: geo.GeoPath,
    value: null,
    willSetValue(newGeoPath, oldGeoPath) {
      this.owner.callObservers("viewWillSetGeoPath", newGeoPath, oldGeoPath, this.owner);
    },
    didSetValue(newGeoPath, oldGeoPath) {
      this.owner.setGeoBounds(newGeoPath !== null ? newGeoPath.bounds : geo.GeoBox.undefined());
      if (this.mounted) {
        this.owner.projectPath(this.owner.viewContext);
      }
      this.owner.callObservers("viewDidSetGeoPath", newGeoPath, oldGeoPath, this.owner);
    }
  }) ], GeoPathView.prototype, "geoPath", void 0);
  __decorate([ component.Animator({
    type: math.R2Path,
    value: null
  }) ], GeoPathView.prototype, "viewPath", void 0);
  __decorate([ component.Animator({
    type: geo.GeoPoint,
    value: null
  }) ], GeoPathView.prototype, "geoCentroid", void 0);
  __decorate([ component.Animator({
    type: math.R2Point,
    value: null
  }) ], GeoPathView.prototype, "viewCentroid", void 0);
  class GeoLineView extends GeoPathView {
    onRender(viewContext) {
      super.onRender(viewContext);
      const renderer = viewContext.renderer;
      if (renderer instanceof PaintingRenderer && !this.hidden && !this.culled) {
        this.renderLine(renderer.context, viewContext.viewFrame);
      }
    }
    renderLine(context, frame) {
      const viewPath = this.viewPath.value;
      if (viewPath !== null && viewPath.isDefined()) {
        const stroke = this.stroke.value;
        const strokeWidth = this.strokeWidth.value;
        if (stroke !== null && strokeWidth !== null) {
          const contextLineWidth = context.lineWidth;
          const contextStrokeStyle = context.strokeStyle;
          context.beginPath();
          viewPath.draw(context);
          const size = Math.min(frame.width, frame.height);
          context.lineWidth = strokeWidth.pxValue(size);
          context.strokeStyle = stroke.toString();
          context.stroke();
          context.lineWidth = contextLineWidth;
          context.strokeStyle = contextStrokeStyle;
        }
      }
    }
    hitTest(x, y, viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer) {
        const p = renderer.transform.transform(x, y);
        return this.hitTestLine(p.x, p.y, renderer.context, viewContext.viewFrame);
      }
      return null;
    }
    hitTestLine(x, y, context, frame) {
      const viewPath = this.viewPath.value;
      if (viewPath !== null && viewPath.isDefined()) {
        if (this.stroke.value !== null) {
          const contextLineWidth = context.lineWidth;
          context.beginPath();
          viewPath.draw(context);
          let hitWidth = this.hitWidth.getValueOr(0);
          const strokeWidth = this.strokeWidth.value;
          if (strokeWidth !== null) {
            const size = Math.min(frame.width, frame.height);
            hitWidth = Math.max(hitWidth, strokeWidth.pxValue(size));
          }
          context.lineWidth = hitWidth;
          const pointInStroke = context.isPointInStroke(x, y);
          context.lineWidth = contextLineWidth;
          if (pointInStroke) {
            return this;
          }
        }
      }
      return null;
    }
    init(init) {
      super.init(init);
      if (init.stroke !== void 0) {
        this.stroke(init.stroke);
      }
      if (init.strokeWidth !== void 0) {
        this.strokeWidth(init.strokeWidth);
      }
      if (init.hitWidth !== void 0) {
        this.hitWidth(init.hitWidth);
      }
    }
  }
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender,
    willSetValue(newStroke, oldStroke) {
      this.owner.callObservers("viewWillSetStroke", newStroke, oldStroke, this.owner);
    },
    didSetValue(newStroke, oldStroke) {
      this.owner.callObservers("viewDidSetStroke", newStroke, oldStroke, this.owner);
    }
  }) ], GeoLineView.prototype, "stroke", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender,
    willSetValue(newStrokeWidth, oldStrokeWidth) {
      this.owner.callObservers("viewWillSetStrokeWidth", newStrokeWidth, oldStrokeWidth, this.owner);
    },
    didSetValue(newStrokeWidth, oldStrokeWidth) {
      this.owner.callObservers("viewDidSetStrokeWidth", newStrokeWidth, oldStrokeWidth, this.owner);
    }
  }) ], GeoLineView.prototype, "strokeWidth", void 0);
  __decorate([ component.Property({
    type: Number
  }) ], GeoLineView.prototype, "hitWidth", void 0);
  class GeoAreaView extends GeoPathView {
    cullGeoFrame(geoFrame = this.geoFrame) {
      let culled;
      if (geoFrame.intersects(this.geoBounds)) {
        const viewFrame = this.viewContext.viewFrame;
        const bounds = this.viewBounds;
        const contained = !this.clipViewport.value || viewFrame.xMin - 4 * viewFrame.width <= bounds.xMin && bounds.xMax <= viewFrame.xMax + 4 * viewFrame.width && viewFrame.yMin - 4 * viewFrame.height <= bounds.yMin && bounds.yMax <= viewFrame.yMax + 4 * viewFrame.height;
        culled = !contained || !viewFrame.intersects(bounds);
      } else {
        culled = true;
      }
      this.setCulled(culled);
    }
    onRender(viewContext) {
      super.onRender(viewContext);
      const renderer = viewContext.renderer;
      if (renderer instanceof PaintingRenderer && !this.hidden && !this.culled) {
        this.renderArea(renderer.context, viewContext.viewFrame);
      }
    }
    renderArea(context, frame) {
      const viewPath = this.viewPath.value;
      if (viewPath !== null && viewPath.isDefined()) {
        const contextFillStyle = context.fillStyle;
        const contextLineWidth = context.lineWidth;
        const contextStrokeStyle = context.strokeStyle;
        context.beginPath();
        viewPath.draw(context);
        const fill = this.fill.value;
        if (fill !== null) {
          context.fillStyle = fill.toString();
          context.fill();
        }
        const stroke = this.stroke.value;
        const strokeWidth = this.strokeWidth.value;
        if (stroke !== null && strokeWidth !== null) {
          const size = Math.min(frame.width, frame.height);
          context.lineWidth = strokeWidth.pxValue(size);
          context.strokeStyle = stroke.toString();
          context.stroke();
        }
        context.fillStyle = contextFillStyle;
        context.lineWidth = contextLineWidth;
        context.strokeStyle = contextStrokeStyle;
      }
    }
    hitTest(x, y, viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer) {
        const p = renderer.transform.transform(x, y);
        return this.hitTestArea(p.x, p.y, renderer.context, viewContext.viewFrame);
      }
      return null;
    }
    hitTestArea(x, y, context, frame) {
      const viewPath = this.viewPath.value;
      if (viewPath !== null && viewPath.isDefined()) {
        context.beginPath();
        viewPath.draw(context);
        if (this.fill.value !== null && context.isPointInPath(x, y)) {
          return this;
        }
        if (this.stroke.value !== null) {
          const strokeWidth = this.strokeWidth.value;
          if (strokeWidth !== null) {
            const contextLineWidth = context.lineWidth;
            const size = Math.min(frame.width, frame.height);
            context.lineWidth = strokeWidth.pxValue(size);
            const pointInStroke = context.isPointInStroke(x, y);
            context.lineWidth = contextLineWidth;
            if (pointInStroke) {
              return this;
            }
          }
        }
      }
      return null;
    }
    init(init) {
      super.init(init);
      if (init.fill !== void 0) {
        this.fill(init.fill);
      }
      if (init.stroke !== void 0) {
        this.stroke(init.stroke);
      }
      if (init.strokeWidth !== void 0) {
        this.strokeWidth(init.strokeWidth);
      }
      if (init.clipViewport !== void 0) {
        this.clipViewport(init.clipViewport);
      }
    }
  }
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender,
    willSetValue(newFill, oldFill) {
      this.owner.callObservers("viewWillSetFill", newFill, oldFill, this.owner);
    },
    didSetValue(newFill, oldFill) {
      this.owner.callObservers("viewDidSetFill", newFill, oldFill, this.owner);
    }
  }) ], GeoAreaView.prototype, "fill", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender,
    willSetValue(newStroke, oldStroke) {
      this.owner.callObservers("viewWillSetStroke", newStroke, oldStroke, this.owner);
    },
    didSetValue(newStroke, oldStroke) {
      this.owner.callObservers("viewDidSetStroke", newStroke, oldStroke, this.owner);
    }
  }) ], GeoAreaView.prototype, "stroke", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender,
    willSetValue(newStrokeWidth, oldStrokeWidth) {
      this.owner.callObservers("viewWillSetStrokeWidth", newStrokeWidth, oldStrokeWidth, this.owner);
    },
    didSetValue(newStrokeWidth, oldStrokeWidth) {
      this.owner.callObservers("viewDidSetStrokeWidth", newStrokeWidth, oldStrokeWidth, this.owner);
    }
  }) ], GeoAreaView.prototype, "strokeWidth", void 0);
  __decorate([ component.Property({
    type: Boolean,
    value: true
  }) ], GeoAreaView.prototype, "clipViewport", void 0);
  class GeoPathTrait extends GeoTrait {
    get geoBounds() {
      const geoPath = this.geoPath.value;
      return geoPath !== null ? geoPath.bounds : geo.GeoBox.undefined();
    }
  }
  __decorate([ component.Property({
    type: geo.GeoPath,
    value: null,
    willSetValue(newGeoPath, oldGeoPath) {
      this.owner.callObservers("traitWillSetGeoPath", newGeoPath, oldGeoPath, this.owner);
    },
    didSetValue(newGeoPath, oldGeoPath) {
      this.owner.callObservers("traitDidSetGeoPath", newGeoPath, oldGeoPath, this.owner);
    }
  }) ], GeoPathTrait.prototype, "geoPath", void 0);
  class GeoLineTrait extends GeoPathTrait {}
  __decorate([ component.Property({
    value: null,
    willSetValue(newStroke, oldStroke) {
      this.owner.callObservers("traitWillSetStroke", newStroke, oldStroke, this.owner);
    },
    didSetValue(newStroke, oldStroke) {
      this.owner.callObservers("traitDidSetStroke", newStroke, oldStroke, this.owner);
    },
    fromAny(stroke) {
      if (stroke !== null && !(stroke instanceof Look)) {
        stroke = Color.fromAny(stroke);
      }
      return stroke;
    }
  }) ], GeoLineTrait.prototype, "stroke", void 0);
  __decorate([ component.Property({
    type: math.Length,
    value: null,
    willSetValue(newStrokeWidth, oldStrokeWidth) {
      this.owner.callObservers("traitWillSetStrokeWidth", newStrokeWidth, oldStrokeWidth, this.owner);
    },
    didSetValue(newStrokeWidth, oldStrokeWidth) {
      this.owner.callObservers("traitDidSetStrokeWidth", newStrokeWidth, oldStrokeWidth, this.owner);
    }
  }) ], GeoLineTrait.prototype, "strokeWidth", void 0);
  class GeoAreaTrait extends GeoPathTrait {}
  __decorate([ component.Property({
    value: null,
    willSetValue(newFill, oldFill) {
      this.owner.callObservers("traitWillSetFill", newFill, oldFill, this.owner);
    },
    didSetValue(newFill, oldFill) {
      this.owner.callObservers("traitDidSetFill", newFill, oldFill, this.owner);
    },
    fromAny(fill) {
      if (fill !== null && !(fill instanceof Look)) {
        fill = Color.fromAny(fill);
      }
      return fill;
    }
  }) ], GeoAreaTrait.prototype, "fill", void 0);
  __decorate([ component.Property({
    value: null,
    willSetValue(newStroke, oldStroke) {
      this.owner.callObservers("traitWillSetStroke", newStroke, oldStroke, this.owner);
    },
    didSetValue(newStroke, oldStroke) {
      this.owner.callObservers("traitDidSetStroke", newStroke, oldStroke, this.owner);
    },
    fromAny(stroke) {
      if (stroke !== null && !(stroke instanceof Look)) {
        stroke = Color.fromAny(stroke);
      }
      return stroke;
    }
  }) ], GeoAreaTrait.prototype, "stroke", void 0);
  __decorate([ component.Property({
    type: math.Length,
    value: null,
    willSetValue(newStrokeWidth, oldStrokeWidth) {
      this.owner.callObservers("traitWillSetStrokeWidth", newStrokeWidth, oldStrokeWidth, this.owner);
    },
    didSetValue(newStrokeWidth, oldStrokeWidth) {
      this.owner.callObservers("traitDidSetStrokeWidth", newStrokeWidth, oldStrokeWidth, this.owner);
    }
  }) ], GeoAreaTrait.prototype, "strokeWidth", void 0);
  class GeoPathController extends GeoController {}
  class GeoLineController extends GeoPathController {
    setGeoPath(geoPath, geoTrait, timing) {
      const geoView = this.geo.view;
      if (geoView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.geoTiming.value;
          if (timing === true) {
            timing = geoView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        geoView.geoPath.setState(geoPath, timing, component.Affinity.Intrinsic);
      }
    }
    setStroke(stroke, geoTrait, timing) {
      const geoView = this.geo.view;
      if (geoView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.geoTiming.value;
          if (timing === true) {
            timing = geoView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        if (stroke instanceof Look) {
          geoView.stroke.setLook(stroke, timing, component.Affinity.Intrinsic);
        } else {
          geoView.stroke.setState(stroke, timing, component.Affinity.Intrinsic);
        }
      }
    }
    setStrokeWidth(strokeWidth, geoTrait, timing) {
      const geoView = this.geo.view;
      if (geoView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.geoTiming.value;
          if (timing === true) {
            timing = geoView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        geoView.strokeWidth.setState(strokeWidth, timing, component.Affinity.Intrinsic);
      }
    }
  }
  __decorate([ TraitViewRef({
    traitType: GeoLineTrait,
    observesTrait: true,
    willAttachTrait(geoTrait) {
      this.owner.callObservers("controllerWillAttachGeoTrait", geoTrait, this.owner);
    },
    didAttachTrait(geoTrait) {
      const geoView = this.view;
      if (geoView !== null) {
        this.owner.setGeoPath(geoTrait.geoPath.value, geoTrait);
        const stroke = geoTrait.stroke.value;
        if (stroke !== null) {
          this.owner.setStroke(stroke, geoTrait);
        }
        const strokeWidth = geoTrait.strokeWidth.value;
        if (strokeWidth !== null) {
          this.owner.setStrokeWidth(strokeWidth, geoTrait);
        }
      }
    },
    didDetachTrait(geoTrait) {
      this.owner.callObservers("controllerDidDetachGeoTrait", geoTrait, this.owner);
    },
    traitDidSetGeoPath(newGeoPath, oldGeoPath, geoTrait) {
      this.owner.setGeoPath(newGeoPath, geoTrait);
    },
    traitDidSetStroke(newStroke, oldStroke, geoTrait) {
      this.owner.setStroke(newStroke, geoTrait);
    },
    traitDidSetStrokeWidth(newStrokeWidth, oldStrokeWidth, geoTrait) {
      this.owner.setStrokeWidth(newStrokeWidth, geoTrait);
    },
    viewType: GeoLineView,
    observesView: true,
    willAttachView(geoView) {
      this.owner.callObservers("controllerWillAttachGeoView", geoView, this.owner);
    },
    didAttachView(geoView) {
      const geoTrait = this.trait;
      if (geoTrait !== null) {
        this.owner.setGeoPath(geoTrait.geoPath.value, geoTrait);
        const stroke = geoTrait.stroke.value;
        if (stroke !== null) {
          this.owner.setStroke(stroke, geoTrait);
        }
        const strokeWidth = geoTrait.strokeWidth.value;
        if (strokeWidth !== null) {
          this.owner.setStrokeWidth(strokeWidth, geoTrait);
        }
      }
    },
    didDetachView(geoView) {
      this.owner.callObservers("controllerDidDetachGeoView", geoView, this.owner);
    },
    viewWillSetGeoPath(newGeoPath, oldGeoPath) {
      this.owner.callObservers("controllerWillSetGeoPath", newGeoPath, oldGeoPath, this.owner);
    },
    viewDidSetGeoPath(newGeoPath, oldGeoPath) {
      this.owner.callObservers("controllerDidSetGeoPath", newGeoPath, oldGeoPath, this.owner);
    },
    viewWillSetStroke(newStroke, oldStroke) {
      this.owner.callObservers("controllerWillSetStroke", newStroke, oldStroke, this.owner);
    },
    viewDidSetStroke(newStroke, oldStroke) {
      this.owner.callObservers("controllerDidSetStroke", newStroke, oldStroke, this.owner);
    },
    viewWillSetStrokeWidth(newStrokeWidth, oldStrokeWidth) {
      this.owner.callObservers("controllerWillSetStrokeWidth", newStrokeWidth, oldStrokeWidth, this.owner);
    },
    viewDidSetStrokeWidth(newStrokeWidth, oldStrokeWidth) {
      this.owner.callObservers("controllerDidSetStrokeWidth", newStrokeWidth, oldStrokeWidth, this.owner);
    }
  }) ], GeoLineController.prototype, "geo", void 0);
  class GeoAreaController extends GeoPathController {
    setGeoPath(geoPath, geoTrait, timing) {
      const geoView = this.geo.view;
      if (geoView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.geoTiming.value;
          if (timing === true) {
            timing = geoView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        geoView.geoPath.setState(geoPath, timing, component.Affinity.Intrinsic);
      }
    }
    setFill(fill, geoTrait, timing) {
      const geoView = this.geo.view;
      if (geoView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.geoTiming.value;
          if (timing === true) {
            timing = geoView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        if (fill instanceof Look) {
          geoView.fill.setLook(fill, timing, component.Affinity.Intrinsic);
        } else {
          geoView.fill.setState(fill, timing, component.Affinity.Intrinsic);
        }
      }
    }
    setStroke(stroke, geoTrait, timing) {
      const geoView = this.geo.view;
      if (geoView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.geoTiming.value;
          if (timing === true) {
            timing = geoView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        if (stroke instanceof Look) {
          geoView.stroke.setLook(stroke, timing, component.Affinity.Intrinsic);
        } else {
          geoView.stroke.setState(stroke, timing, component.Affinity.Intrinsic);
        }
      }
    }
    setStrokeWidth(strokeWidth, geoTrait, timing) {
      const geoView = this.geo.view;
      if (geoView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.geoTiming.value;
          if (timing === true) {
            timing = geoView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        geoView.strokeWidth.setState(strokeWidth, timing, component.Affinity.Intrinsic);
      }
    }
  }
  __decorate([ TraitViewRef({
    traitType: GeoAreaTrait,
    observesTrait: true,
    willAttachTrait(geoTrait) {
      this.owner.callObservers("controllerWillAttachGeoTrait", geoTrait, this.owner);
    },
    didAttachTrait(geoTrait) {
      const geoView = this.view;
      if (geoView !== null) {
        this.owner.setGeoPath(geoTrait.geoPath.value, geoTrait);
        const fill = geoTrait.fill.value;
        if (fill !== null) {
          this.owner.setFill(fill, geoTrait);
        }
        const stroke = geoTrait.stroke.value;
        if (stroke !== null) {
          this.owner.setStroke(stroke, geoTrait);
        }
        const strokeWidth = geoTrait.strokeWidth.value;
        if (strokeWidth !== null) {
          this.owner.setStrokeWidth(strokeWidth, geoTrait);
        }
      }
    },
    didDetachTrait(geoTrait) {
      this.owner.callObservers("controllerDidDetachGeoTrait", geoTrait, this.owner);
    },
    traitDidSetGeoPath(newGeoPath, oldGeoPath, geoTrait) {
      this.owner.setGeoPath(newGeoPath, geoTrait);
    },
    traitDidSetFill(newFill, oldFill, geoTrait) {
      this.owner.setFill(newFill, geoTrait);
    },
    traitDidSetStroke(newStroke, oldStroke, geoTrait) {
      this.owner.setStroke(newStroke, geoTrait);
    },
    traitDidSetStrokeWidth(newStrokeWidth, oldStrokeWidth, geoTrait) {
      this.owner.setStrokeWidth(newStrokeWidth, geoTrait);
    },
    viewType: GeoAreaView,
    observesView: true,
    willAttachView(geoView) {
      this.owner.callObservers("controllerWillAttachGeoView", geoView, this.owner);
    },
    didAttachView(geoView) {
      const geoTrait = this.trait;
      if (geoTrait !== null) {
        this.owner.setGeoPath(geoTrait.geoPath.value, geoTrait);
        const fill = geoTrait.fill.value;
        if (fill !== null) {
          this.owner.setFill(fill, geoTrait);
        }
        const stroke = geoTrait.stroke.value;
        if (stroke !== null) {
          this.owner.setStroke(stroke, geoTrait);
        }
        const strokeWidth = geoTrait.strokeWidth.value;
        if (strokeWidth !== null) {
          this.owner.setStrokeWidth(strokeWidth, geoTrait);
        }
      }
    },
    didDetachView(geoView) {
      this.owner.callObservers("controllerDidDetachGeoView", geoView, this.owner);
    },
    viewWillSetGeoPath(newGeoPath, oldGeoPath) {
      this.owner.callObservers("controllerWillSetGeoPath", newGeoPath, oldGeoPath, this.owner);
    },
    viewDidSetGeoPath(newGeoPath, oldGeoPath) {
      this.owner.callObservers("controllerDidSetGeoPath", newGeoPath, oldGeoPath, this.owner);
    },
    viewWillSetFill(newFill, oldFill) {
      this.owner.callObservers("controllerWillSetFill", newFill, oldFill, this.owner);
    },
    viewDidSetFill(newFill, oldFill) {
      this.owner.callObservers("controllerDidSetFill", newFill, oldFill, this.owner);
    },
    viewWillSetStroke(newStroke, oldStroke) {
      this.owner.callObservers("controllerWillSetStroke", newStroke, oldStroke, this.owner);
    },
    viewDidSetStroke(newStroke, oldStroke) {
      this.owner.callObservers("controllerDidSetStroke", newStroke, oldStroke, this.owner);
    },
    viewWillSetStrokeWidth(newStrokeWidth, oldStrokeWidth) {
      this.owner.callObservers("controllerWillSetStrokeWidth", newStrokeWidth, oldStrokeWidth, this.owner);
    },
    viewDidSetStrokeWidth(newStrokeWidth, oldStrokeWidth) {
      this.owner.callObservers("controllerDidSetStrokeWidth", newStrokeWidth, oldStrokeWidth, this.owner);
    }
  }) ], GeoAreaController.prototype, "geo", void 0);
  class GeoPointView extends GeoView {
    isGradientStop() {
      return this.color.value !== null || this.opacity.value !== void 0;
    }
    setState(point, timing) {
      let init;
      if (point instanceof GeoPointView) {
        init = point.toAny();
      } else if (point instanceof geo.GeoPoint) {
        init = point.toAny();
      } else if (geo.GeoPoint.isTuple(point)) {
        init = {
          lng: point[0],
          lat: point[1]
        };
      } else {
        init = point;
      }
      if (init.lng !== void 0 && init.lat !== void 0) {
        this.geoPoint(new geo.GeoPoint(init.lng, init.lat), timing);
      } else if (init.x !== void 0 && init.y !== void 0) {
        this.viewPoint(new math.R2Point(init.x, init.y), timing);
      }
      if (init.radius !== void 0) {
        this.radius(init.radius, timing);
      }
      if (init.hitRadius !== void 0) {
        this.hitRadius(init.hitRadius);
      }
      if (init.color !== void 0) {
        this.color(init.color, timing);
      }
      if (init.opacity !== void 0) {
        this.opacity(init.opacity, timing);
      }
      if (init.labelPadding !== void 0) {
        this.labelPadding(init.labelPadding, timing);
      }
      if (init.labelPlacement !== void 0) {
        this.labelPlacement(init.labelPlacement);
      }
      if (init.font !== void 0) {
        this.font(init.font, timing);
      }
      if (init.textColor !== void 0) {
        this.textColor(init.textColor, timing);
      }
      if (init.label !== void 0) {
        this.label(init.label);
      }
    }
    needsProcess(processFlags, viewContext) {
      if ((processFlags & View.NeedsProject) !== 0 && this.label.view !== null) {
        this.requireUpdate(View.NeedsLayout);
      }
      return processFlags;
    }
    onProject(viewContext) {
      super.onProject(viewContext);
      if (this.viewPoint.hasAffinity(component.Affinity.Intrinsic)) {
        const viewPoint = viewContext.geoViewport.project(this.geoPoint.getValue());
        this.viewPoint.setInterpolatedValue(viewPoint, viewPoint);
      }
    }
    onLayout(viewContext) {
      super.onLayout(viewContext);
      const labelView = this.label.view;
      if (labelView !== null) {
        this.layoutLabel(labelView, viewContext.viewFrame);
      }
    }
    layoutLabel(labelView, frame) {
      const placement = this.labelPlacement.value;
      const size = Math.min(frame.width, frame.height);
      const padding = this.labelPadding.getValue().pxValue(size);
      const {x: x, y: y} = this.viewPoint.getValue();
      let y1 = y;
      if (placement === "top") {
        y1 -= padding;
      } else if (placement === "bottom") {
        y1 += padding;
      }
      if (TypesetView.is(labelView)) {
        labelView.textAlign.setState("center", component.Affinity.Intrinsic);
        labelView.textBaseline.setState("bottom", component.Affinity.Intrinsic);
        labelView.textOrigin.setState(new math.R2Point(x, y1), component.Affinity.Intrinsic);
      }
    }
    updateGeoBounds() {}
    get hitBounds() {
      const {x: x, y: y} = this.viewPoint.getValue();
      const hitRadius = this.hitRadius.getValueOr(0);
      return new math.R2Box(x - hitRadius, y - hitRadius, x + hitRadius, y + hitRadius);
    }
    hitTest(x, y, viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer) {
        return this.hitTestPoint(x, y, renderer.context, viewContext.viewFrame);
      }
      return null;
    }
    hitTestPoint(hx, hy, context, frame) {
      const {x: x, y: y} = this.viewPoint.getValue();
      const radius = this.radius.value;
      let hitRadius = this.hitRadius.getValueOr(0);
      if (radius !== null) {
        const size = Math.min(frame.width, frame.height);
        hitRadius = Math.max(hitRadius, radius.pxValue(size));
      }
      const dx = x - hx;
      const dy = y - hy;
      if (dx * dx + dy * dy < hitRadius * hitRadius) {
        return this;
      }
      return null;
    }
    ripple(options) {
      return GeoRippleView.ripple(this, options);
    }
    toAny() {
      const init = {};
      init.lng = this.geoPoint.value.lng;
      init.lat = this.geoPoint.value.lat;
      if (!this.viewPoint.hasAffinity(component.Affinity.Intrinsic)) {
        init.x = this.viewPoint.value.x;
        init.y = this.viewPoint.value.y;
      }
      if (this.radius.value !== null) {
        init.radius = this.radius.value;
      }
      if (this.hitRadius.value !== void 0) {
        init.hitRadius = this.hitRadius.value;
      }
      if (this.color.value !== null) {
        init.color = this.color.value;
      }
      if (this.opacity.value !== void 0) {
        init.opacity = this.opacity.value;
      }
      if (this.labelPadding.value !== null) {
        init.labelPadding = this.labelPadding.value;
      }
      if (this.labelPlacement.value !== void 0) {
        init.labelPlacement = this.labelPlacement.value;
      }
      return init;
    }
    init(init) {
      if (init instanceof geo.GeoPoint || geo.GeoPoint.isTuple(init)) {
        this.setState(init);
      } else {
        super.init(init);
      }
    }
  }
  __decorate([ component.Animator({
    type: geo.GeoPoint,
    value: geo.GeoPoint.origin(),
    updateFlags: View.NeedsProject,
    willSetValue(newGeoPoint, oldGeoPoint) {
      this.owner.callObservers("viewWillSetGeoPoint", newGeoPoint, oldGeoPoint, this.owner);
    },
    didSetValue(newGeoPoint, oldGeoPoint) {
      this.owner.setGeoBounds(newGeoPoint.bounds);
      this.owner.callObservers("viewDidSetGeoPoint", newGeoPoint, oldGeoPoint, this.owner);
    }
  }) ], GeoPointView.prototype, "geoPoint", void 0);
  __decorate([ component.Animator({
    type: math.R2Point,
    value: math.R2Point.origin()
  }) ], GeoPointView.prototype, "viewPoint", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null
  }) ], GeoPointView.prototype, "radius", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null
  }) ], GeoPointView.prototype, "color", void 0);
  __decorate([ ThemeAnimator({
    type: Number
  }) ], GeoPointView.prototype, "opacity", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null
  }) ], GeoPointView.prototype, "labelPadding", void 0);
  __decorate([ ThemeAnimator({
    type: Font,
    value: null,
    inherits: true
  }) ], GeoPointView.prototype, "font", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    inherits: true
  }) ], GeoPointView.prototype, "textColor", void 0);
  __decorate([ component.Property({
    type: Number
  }) ], GeoPointView.prototype, "hitRadius", void 0);
  __decorate([ ViewRef({
    key: true,
    type: TextRunView,
    binds: true,
    willAttachView(labelView) {
      this.owner.callObservers("viewWillAttachGeoLabel", labelView, this.owner);
    },
    didDetachView(labelView) {
      this.owner.callObservers("viewDidDetachGeoLabel", labelView, this.owner);
    },
    fromAny(value) {
      if (typeof value === "string") {
        if (this.view instanceof TextRunView) {
          this.view.text(value);
          return this.view;
        } else {
          return TextRunView.fromAny(value);
        }
      } else {
        return GraphicsView.fromAny(value);
      }
    }
  }) ], GeoPointView.prototype, "label", void 0);
  __decorate([ component.Property({
    type: String,
    value: "auto"
  }) ], GeoPointView.prototype, "labelPlacement", void 0);
  Object.defineProperty(GeoPointView.prototype, "viewBounds", {
    get() {
      const {x: x, y: y} = this.viewPoint.getValue();
      return new math.R2Box(x, y, x, y);
    },
    configurable: true
  });
  class GeoPlotView extends GeoView {
    constructor() {
      super();
      this.gradientStops = 0;
      Object.defineProperty(this, "viewBounds", {
        value: math.R2Box.undefined(),
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
    points(points, timing) {
      let child;
      if (points === void 0) {
        const points = [];
        child = this.firstChild;
        while (child !== null) {
          if (child instanceof GeoPointView) {
            points.push(child);
          }
          child = child.nextSibling;
        }
        return points;
      } else {
        const oldGeoBounds = this.geoBounds;
        let lngMin = Infinity;
        let latMin = Infinity;
        let lngMax = -Infinity;
        let latMax = -Infinity;
        let lngMid = 0;
        let latMid = 0;
        let invalid = false;
        let i = 0;
        child = this.firstChild;
        while (child !== null && i < points.length) {
          if (child instanceof GeoPointView) {
            const point = points[i];
            child.setState(point);
            const {lng: lng, lat: lat} = child.geoPoint.getValue();
            lngMid += lng;
            latMid += lat;
            lngMin = Math.min(lngMin, lng);
            latMin = Math.min(latMin, lat);
            lngMax = Math.max(lng, lngMax);
            latMax = Math.max(lat, latMax);
            invalid = invalid || !isFinite(lng) || !isFinite(lat);
            i += 1;
          }
        }
        while (i < points.length) {
          const point = GeoPointView.fromAny(points[i]);
          this.appendChild(point);
          const {lng: lng, lat: lat} = point.geoPoint.getValue();
          lngMid += lng;
          latMid += lat;
          lngMin = Math.min(lngMin, lng);
          latMin = Math.min(latMin, lat);
          lngMax = Math.max(lng, lngMax);
          latMax = Math.max(lat, latMax);
          invalid = invalid || !isFinite(lng) || !isFinite(lat);
          i += 1;
        }
        while (child !== null) {
          const next = child.nextSibling;
          if (child instanceof GeoPointView) {
            this.removeChild(child);
          }
          child = next;
        }
        if (!invalid && i !== 0) {
          lngMid /= i;
          latMid /= i;
          this.geoCentroid.setValue(new geo.GeoPoint(lngMid, latMid), component.Affinity.Intrinsic);
          this.geoBounds = new geo.GeoBox(lngMin, latMin, lngMax, latMax);
        } else {
          this.geoCentroid.setValue(geo.GeoPoint.origin(), component.Affinity.Intrinsic);
          this.geoBounds = geo.GeoBox.undefined();
        }
        const newGeoBounds = this.geoBounds;
        if (!oldGeoBounds.equals(newGeoBounds)) {
          this.willSetGeoBounds(newGeoBounds, oldGeoBounds);
          this.onSetGeoBounds(newGeoBounds, oldGeoBounds);
          this.didSetGeoBounds(newGeoBounds, oldGeoBounds);
        }
        return this;
      }
    }
    appendPoint(point, key) {
      point = GeoPointView.fromAny(point);
      this.appendChild(point, key);
      return point;
    }
    setPoint(key, point) {
      point = GeoPointView.fromAny(point);
      this.setChild(key, point);
      return point;
    }
    onInsertChild(childView, targetView) {
      super.onInsertChild(childView, targetView);
      if (childView instanceof GeoPointView) {
        this.onInsertPoint(childView);
      }
    }
    onInsertPoint(childView) {
      childView.requireUpdate(View.NeedsAnimate | View.NeedsProject);
    }
    didProject(viewContext) {
      const oldGeoBounds = this.geoBounds;
      let lngMin = Infinity;
      let latMin = Infinity;
      let lngMax = -Infinity;
      let latMax = -Infinity;
      let lngMid = 0;
      let latMid = 0;
      let xMin = Infinity;
      let yMin = Infinity;
      let xMax = -Infinity;
      let yMax = -Infinity;
      let xMid = 0;
      let yMid = 0;
      let invalid = false;
      let gradientStops = 0;
      let pointCount = 0;
      let child = this.firstChild;
      while (child !== null) {
        if (child instanceof GeoPointView) {
          const {lng: lng, lat: lat} = child.geoPoint.getValue();
          lngMid += lng;
          latMid += lat;
          lngMin = Math.min(lngMin, lng);
          latMin = Math.min(latMin, lat);
          lngMax = Math.max(lng, lngMax);
          latMax = Math.max(lat, latMax);
          invalid = invalid || !isFinite(lng) || !isFinite(lat);
          const {x: x, y: y} = child.viewPoint.getValue();
          xMin = Math.min(xMin, x);
          yMin = Math.min(yMin, y);
          xMax = Math.max(x, xMax);
          yMax = Math.max(y, yMax);
          xMid += x;
          yMid += y;
          invalid = invalid || !isFinite(x) || !isFinite(y);
          if (child.isGradientStop()) {
            gradientStops += 1;
          }
          pointCount += 1;
        }
        child = child.nextSibling;
      }
      if (!invalid && pointCount !== 0) {
        lngMid /= pointCount;
        latMid /= pointCount;
        this.geoCentroid.setValue(new geo.GeoPoint(lngMid, latMid), component.Affinity.Intrinsic);
        this.geoBounds = new geo.GeoBox(lngMin, latMin, lngMax, latMax);
        xMid /= pointCount;
        yMid /= pointCount;
        this.viewCentroid.setValue(new math.R2Point(xMid, yMid), component.Affinity.Intrinsic);
        this.viewBounds = new math.R2Box(xMin, yMin, xMax, yMax);
        this.cullGeoFrame(viewContext.geoViewport.geoFrame);
      } else {
        this.geoCentroid.setValue(geo.GeoPoint.origin(), component.Affinity.Intrinsic);
        this.geoBounds = geo.GeoBox.undefined();
        this.viewCentroid.setValue(math.R2Point.origin(), component.Affinity.Intrinsic);
        this.viewBounds = math.R2Box.undefined();
        this.setCulled(true);
      }
      this.gradientStops = gradientStops;
      const newGeoBounds = this.geoBounds;
      if (!oldGeoBounds.equals(newGeoBounds)) {
        this.willSetGeoBounds(newGeoBounds, oldGeoBounds);
        this.onSetGeoBounds(newGeoBounds, oldGeoBounds);
        this.didSetGeoBounds(newGeoBounds, oldGeoBounds);
      }
      super.didProject(viewContext);
    }
    onRender(viewContext) {
      super.onRender(viewContext);
      const renderer = viewContext.renderer;
      if (renderer instanceof PaintingRenderer && !this.hidden && !this.culled) {
        if (this.gradientStops !== 0 && renderer instanceof CanvasRenderer) {
          this.renderPlotGradient(renderer.context, viewContext.viewFrame);
        } else {
          this.renderPlotStroke(renderer.context, viewContext.viewFrame);
        }
      }
    }
    renderPlotStroke(context, frame) {
      const stroke = this.stroke.value;
      if (stroke !== null) {
        let pointCount = 0;
        context.beginPath();
        let child = this.firstChild;
        while (child !== null) {
          if (child instanceof GeoPointView) {
            const {x: x, y: y} = child.viewPoint.getValue();
            if (pointCount === 0) {
              context.moveTo(x, y);
            } else {
              context.lineTo(x, y);
            }
            pointCount += 1;
          }
          child = child.nextSibling;
        }
        if (pointCount !== 0) {
          const contextLineWidth = context.lineWidth;
          const contextStrokeStyle = context.strokeStyle;
          const size = Math.min(frame.width, frame.height);
          const strokeWidth = this.strokeWidth.getValue().pxValue(size);
          context.lineWidth = strokeWidth;
          context.strokeStyle = stroke.toString();
          context.stroke();
          context.lineWidth = contextLineWidth;
          context.strokeStyle = contextStrokeStyle;
        }
      }
    }
    renderPlotGradient(context, frame) {
      const stroke = this.stroke.getValue();
      const size = Math.min(frame.width, frame.height);
      const strokeWidth = this.strokeWidth.getValue().pxValue(size);
      const contextLineWidth = context.lineWidth;
      const contextStrokeStyle = context.strokeStyle;
      let p0;
      let p1 = this.firstChild;
      while (p1 !== null) {
        if (p1 instanceof GeoPointView) {
          if (p0 !== void 0) {
            const x0 = p0.viewPoint.getValue().x;
            const y0 = p0.viewPoint.getValue().y;
            const x1 = p1.viewPoint.getValue().x;
            const y1 = p1.viewPoint.getValue().y;
            const gradient = context.createLinearGradient(x0, y0, x1, y1);
            let color = p0.color.getValueOr(stroke);
            let opacity = p0.opacity.value;
            if (typeof opacity === "number") {
              color = color.alpha(opacity);
            }
            gradient.addColorStop(0, color.toString());
            color = p1.color.getValueOr(stroke);
            opacity = p1.opacity.value;
            if (typeof opacity === "number") {
              color = color.alpha(opacity);
            }
            gradient.addColorStop(1, color.toString());
            context.beginPath();
            context.moveTo(x0, y0);
            context.lineTo(x1, y1);
            context.lineWidth = strokeWidth;
            context.strokeStyle = gradient;
            context.stroke();
          }
          p0 = p1;
        }
        p1 = p1.nextSibling;
      }
      context.lineWidth = contextLineWidth;
      context.strokeStyle = contextStrokeStyle;
    }
    updateGeoBounds() {}
    get popoverFrame() {
      const viewCentroid = this.viewCentroid.value;
      const inversePageTransform = this.pageTransform.inverse();
      const px = inversePageTransform.transformX(viewCentroid.x, viewCentroid.y);
      const py = inversePageTransform.transformY(viewCentroid.x, viewCentroid.y);
      return new math.R2Box(px, py, px, py);
    }
    hitTest(x, y, viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer) {
        const p = renderer.transform.transform(x, y);
        return this.hitTestPlot(p.x, p.y, renderer.context, viewContext.viewFrame);
      }
      return null;
    }
    hitTestPlot(x, y, context, frame) {
      let pointCount = 0;
      context.beginPath();
      let child = this.firstChild;
      while (child !== null) {
        if (child instanceof GeoPointView) {
          const {x: x, y: y} = child.viewPoint.getValue();
          if (pointCount === 0) {
            context.moveTo(x, y);
          } else {
            context.lineTo(x, y);
          }
          pointCount += 1;
        }
        child = child.nextSibling;
      }
      if (pointCount !== 0) {
        const contextLineWidth = context.lineWidth;
        let hitWidth = this.hitWidth.getValueOr(0);
        const strokeWidth = this.strokeWidth.value;
        if (strokeWidth !== null) {
          const size = Math.min(frame.width, frame.height);
          hitWidth = Math.max(hitWidth, strokeWidth.pxValue(size));
        }
        context.lineWidth = hitWidth;
        const pointInStroke = context.isPointInStroke(x, y);
        context.lineWidth = contextLineWidth;
        if (pointInStroke) {
          return this;
        }
      }
      return null;
    }
    ripple(options) {
      return GeoRippleView.ripple(this, options);
    }
    init(init) {
      super.init(init);
      if (init.stroke !== void 0) {
        this.stroke(init.stroke);
      }
      if (init.strokeWidth !== void 0) {
        this.strokeWidth(init.strokeWidth);
      }
      if (init.hitWidth !== void 0) {
        this.hitWidth(init.hitWidth);
      }
      if (init.font !== void 0) {
        this.font(init.font);
      }
      if (init.textColor !== void 0) {
        this.textColor(init.textColor);
      }
      const points = init.points;
      if (points !== void 0) {
        this.points(points);
      }
    }
  }
  __decorate([ component.Property({
    type: geo.GeoPoint,
    value: geo.GeoPoint.origin()
  }) ], GeoPlotView.prototype, "geoCentroid", void 0);
  __decorate([ component.Property({
    type: math.R2Point,
    value: math.R2Point.origin()
  }) ], GeoPlotView.prototype, "viewCentroid", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], GeoPlotView.prototype, "stroke", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    inherits: true,
    updateFlags: View.NeedsRender
  }) ], GeoPlotView.prototype, "strokeWidth", void 0);
  __decorate([ ThemeAnimator({
    type: Font,
    value: null,
    inherits: true
  }) ], GeoPlotView.prototype, "font", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    inherits: true
  }) ], GeoPlotView.prototype, "textColor", void 0);
  __decorate([ component.Property({
    type: Number
  }) ], GeoPlotView.prototype, "hitWidth", void 0);
  class GeoIconView extends GeoView {
    constructor() {
      super();
      this.sprite = null;
      Object.defineProperty(this, "viewBounds", {
        value: math.R2Box.undefined(),
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
    onApplyTheme(theme, mood, timing) {
      super.onApplyTheme(theme, mood, timing);
      if (!this.graphics.inherited) {
        const oldGraphics = this.graphics.value;
        if (oldGraphics instanceof Icon) {
          const newGraphics = oldGraphics.withTheme(theme, mood);
          this.graphics.setState(newGraphics, oldGraphics.isThemed() ? timing : false, component.Affinity.Reflexive);
        }
      }
    }
    onProject(viewContext) {
      super.onProject(viewContext);
      this.projectIcon(viewContext);
    }
    projectGeoCenter(geoCenter) {
      if (this.mounted) {
        const viewContext = this.viewContext;
        const viewCenter = geoCenter !== null && geoCenter.isDefined() ? viewContext.geoViewport.project(geoCenter) : null;
        this.viewCenter.setInterpolatedValue(this.viewCenter.value, viewCenter);
        this.projectIcon(viewContext);
      }
    }
    projectIcon(viewContext) {
      if (component.Affinity.Intrinsic >= (this.viewCenter.flags & component.Affinity.Mask)) {
        const geoCenter = this.geoCenter.value;
        const viewCenter = geoCenter !== null && geoCenter.isDefined() ? viewContext.geoViewport.project(geoCenter) : null;
        this.viewCenter.value = viewCenter;
      }
      const viewFrame = viewContext.viewFrame;
      this.viewBounds = this.deriveViewBounds(viewFrame);
      const p0 = this.viewCenter.value;
      const p1 = this.viewCenter.state;
      if (p0 !== null && p1 !== null && (viewFrame.intersectsBox(this.viewBounds) || viewFrame.intersectsSegment(new math.R2Segment(p0.x, p0.y, p1.x, p1.y)))) {
        this.setCulled(false);
      } else {
        this.setCulled(true);
      }
    }
    onRasterize(viewContext) {
      super.onRasterize(viewContext);
      if (!this.hidden && !this.culled) {
        this.rasterizeIcon(this.viewBounds);
      }
    }
    rasterizeIcon(frame) {
      let sprite = this.sprite;
      const graphics = this.graphics.value;
      if (graphics !== null && frame.isDefined()) {
        const width = frame.width;
        const height = frame.height;
        if (sprite !== null && (sprite.width < width || sprite.height < height || width < sprite.width / 2 && height < sprite.height / 2)) {
          this.sprite = null;
          sprite.release();
          sprite = null;
        }
        if (sprite === null) {
          sprite = this.spriteProvider.service.acquireSprite(width, height);
          this.sprite = sprite;
        }
        const renderer = sprite.getRenderer();
        const context = renderer.context;
        context.clearRect(0, 0, sprite.width, sprite.height);
        context.beginPath();
        graphics.render(renderer, new math.R2Box(0, 0, width, height));
      } else if (sprite !== null) {
        this.sprite = null;
        sprite.release();
      }
    }
    onComposite(viewContext) {
      super.onComposite(viewContext);
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer && !this.hidden && !this.culled) {
        this.compositeIcon(renderer, this.viewBounds);
      }
    }
    compositeIcon(renderer, frame) {
      const sprite = this.sprite;
      if (sprite !== null) {
        sprite.draw(renderer.context, frame);
      }
    }
    renderGeoBounds(viewContext, outlineColor, outlineWidth) {}
    updateGeoBounds() {}
    deriveViewBounds(viewFrame) {
      const viewCenter = this.viewCenter.value;
      if (viewCenter !== null && viewCenter.isDefined()) {
        if (viewFrame === void 0) {
          viewFrame = this.viewContext.viewFrame;
        }
        const viewSize = Math.min(viewFrame.width, viewFrame.height);
        let iconWidth = this.iconWidth.value;
        iconWidth = iconWidth instanceof math.Length ? iconWidth.pxValue(viewSize) : viewSize;
        let iconHeight = this.iconHeight.value;
        iconHeight = iconHeight instanceof math.Length ? iconHeight.pxValue(viewSize) : viewSize;
        const x = viewCenter.x - iconWidth * this.xAlign.value;
        const y = viewCenter.y - iconHeight * this.yAlign.value;
        return new math.R2Box(x, y, x + iconWidth, y + iconHeight);
      } else {
        return math.R2Box.undefined();
      }
    }
    get popoverFrame() {
      const viewCenter = this.viewCenter.value;
      if (viewCenter !== null && viewCenter.isDefined()) {
        const viewFrame = this.viewContext.viewFrame;
        const viewSize = Math.min(viewFrame.width, viewFrame.height);
        const inversePageTransform = this.pageTransform.inverse();
        const px = inversePageTransform.transformX(viewCenter.x, viewCenter.y);
        const py = inversePageTransform.transformY(viewCenter.x, viewCenter.y);
        let iconWidth = this.iconWidth.value;
        iconWidth = iconWidth instanceof math.Length ? iconWidth.pxValue(viewSize) : viewSize;
        let iconHeight = this.iconHeight.value;
        iconHeight = iconHeight instanceof math.Length ? iconHeight.pxValue(viewSize) : viewSize;
        const x = px - iconWidth * this.xAlign.getValue();
        const y = py - iconHeight * this.yAlign.getValue();
        return new math.R2Box(x, y, x + iconWidth, y + iconHeight);
      } else {
        return this.pageBounds;
      }
    }
    hitTest(x, y, viewContext) {
      const renderer = viewContext.renderer;
      if (renderer instanceof CanvasRenderer) {
        return this.hitTestIcon(x, y, renderer, this.viewBounds);
      }
      return null;
    }
    hitTestIcon(x, y, renderer, frame) {
      if (this.hitBounds.contains(x, y)) {
        return this;
      }
      return null;
    }
    ripple(options) {
      return GeoRippleView.ripple(this, options);
    }
    onUnmount() {
      super.onUnmount();
      const sprite = this.sprite;
      if (sprite !== null) {
        this.sprite = null;
        sprite.release();
      }
    }
    init(init) {
      super.init(init);
      IconView.init(this, init);
      if (init.geoCenter !== void 0) {
        this.geoCenter(init.geoCenter);
      }
      if (init.viewCenter !== void 0) {
        this.viewCenter(init.viewCenter);
      }
    }
  }
  GeoIconView.MountFlags = GeoView.MountFlags | View.NeedsRasterize;
  GeoIconView.UncullFlags = GeoView.UncullFlags | View.NeedsRasterize;
  __decorate([ component.Animator({
    type: geo.GeoPoint,
    value: null,
    didSetState(newGeoCenter, oldGeoCenter) {
      this.owner.projectGeoCenter(newGeoCenter);
    },
    willSetValue(newGeoCenter, oldGeoCenter) {
      this.owner.callObservers("viewWillSetGeoCenter", newGeoCenter, oldGeoCenter, this.owner);
    },
    didSetValue(newGeoCenter, oldGeoCenter) {
      this.owner.setGeoBounds(newGeoCenter !== null ? newGeoCenter.bounds : geo.GeoBox.undefined());
      if (this.mounted) {
        this.owner.projectIcon(this.owner.viewContext);
      }
      this.owner.callObservers("viewDidSetGeoCenter", newGeoCenter, oldGeoCenter, this.owner);
    }
  }) ], GeoIconView.prototype, "geoCenter", void 0);
  __decorate([ component.Animator({
    type: math.R2Point,
    value: math.R2Point.undefined(),
    updateFlags: View.NeedsComposite
  }) ], GeoIconView.prototype, "viewCenter", void 0);
  __decorate([ component.Animator({
    type: Number,
    value: .5,
    updateFlags: View.NeedsProject | View.NeedsRender | View.NeedsRasterize | View.NeedsComposite
  }) ], GeoIconView.prototype, "xAlign", void 0);
  __decorate([ component.Animator({
    type: Number,
    value: .5,
    updateFlags: View.NeedsProject | View.NeedsRender | View.NeedsRasterize | View.NeedsComposite
  }) ], GeoIconView.prototype, "yAlign", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    updateFlags: View.NeedsProject | View.NeedsRender | View.NeedsRasterize | View.NeedsComposite
  }) ], GeoIconView.prototype, "iconWidth", void 0);
  __decorate([ ThemeAnimator({
    type: math.Length,
    value: null,
    updateFlags: View.NeedsProject | View.NeedsRender | View.NeedsRasterize | View.NeedsComposite
  }) ], GeoIconView.prototype, "iconHeight", void 0);
  __decorate([ ThemeAnimator({
    type: Color,
    value: null,
    updateFlags: View.NeedsRender | View.NeedsRasterize | View.NeedsComposite,
    didSetValue(newIconColor, oldIconColor) {
      if (newIconColor !== null) {
        const oldGraphics = this.owner.graphics.value;
        if (oldGraphics instanceof FilledIcon) {
          const newGraphics = oldGraphics.withFillColor(newIconColor);
          this.owner.graphics.setState(newGraphics, component.Affinity.Reflexive);
        }
      }
    }
  }) ], GeoIconView.prototype, "iconColor", void 0);
  __decorate([ ThemeAnimator({
    extends: IconGraphicsAnimator,
    type: Object,
    updateFlags: View.NeedsRender | View.NeedsRasterize | View.NeedsComposite,
    willSetValue(newGraphics, oldGraphics) {
      this.owner.callObservers("viewWillSetGraphics", newGraphics, oldGraphics, this.owner);
    },
    didSetValue(newGraphics, oldGraphics) {
      this.owner.callObservers("viewDidSetGraphics", newGraphics, oldGraphics, this.owner);
    }
  }) ], GeoIconView.prototype, "graphics", void 0);
  class GeoIconTrait extends GeoTrait {
    get geoBounds() {
      const geoCenter = this.geoCenter.value;
      return geoCenter !== null ? geoCenter.bounds : geo.GeoBox.undefined();
    }
  }
  __decorate([ component.Property({
    type: geo.GeoPoint,
    value: null,
    willSetValue(newGeoCenter, oldGeoCenter) {
      this.owner.callObservers("traitWillSetGeoCenter", newGeoCenter, oldGeoCenter, this.owner);
    },
    didSetValue(newGeoCenter, oldGeoCenter) {
      this.owner.callObservers("traitDidSetGeoCenter", newGeoCenter, oldGeoCenter, this.owner);
    }
  }) ], GeoIconTrait.prototype, "geoCenter", void 0);
  __decorate([ component.Property({
    type: IconLayout,
    value: null,
    willSetValue(newIconLayout, oldIconLayout) {
      this.owner.callObservers("traitWillSetIconLayout", newIconLayout, oldIconLayout, this.owner);
    },
    didSetValue(newIconLayout, oldIconLayout) {
      this.owner.callObservers("traitDidSetIconLayout", newIconLayout, oldIconLayout, this.owner);
    }
  }) ], GeoIconTrait.prototype, "iconLayout", void 0);
  __decorate([ component.Property({
    value: null,
    willSetValue(newGraphics, oldGraphics) {
      this.owner.callObservers("traitWillSetGraphics", newGraphics, oldGraphics, this.owner);
    },
    didSetValue(newGraphics, oldGraphics) {
      this.owner.callObservers("traitDidSetGraphics", newGraphics, oldGraphics, this.owner);
    }
  }) ], GeoIconTrait.prototype, "graphics", void 0);
  class GeoIconController extends GeoController {
    setGeoCenter(geoCenter, geoTrait, timing) {
      const geoView = this.geo.view;
      if (geoView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.geoTiming.value;
          if (timing === true) {
            timing = geoView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        geoView.geoCenter.setState(geoCenter, timing, component.Affinity.Intrinsic);
      }
    }
    setIconLayout(iconLayout, geoTrait, timing) {
      const geoView = this.geo.view;
      if (geoView !== null && iconLayout !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.geoTiming.value;
          if (timing === true) {
            timing = geoView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        geoView.iconWidth.setState(iconLayout.iconWidth, timing, component.Affinity.Intrinsic);
        geoView.iconHeight.setState(iconLayout.iconHeight, timing, component.Affinity.Intrinsic);
        if (iconLayout.xAlign !== void 0) {
          geoView.xAlign.setState(iconLayout.xAlign, timing, component.Affinity.Intrinsic);
        }
        if (iconLayout.yAlign !== void 0) {
          geoView.yAlign.setState(iconLayout.yAlign, timing, component.Affinity.Intrinsic);
        }
      }
    }
    setGraphics(graphics, geoTrait, timing) {
      const geoView = this.geo.view;
      if (geoView !== null) {
        if (timing === void 0 || timing === true) {
          timing = this.geoTiming.value;
          if (timing === true) {
            timing = geoView.getLook(Look.timing, Mood.ambient);
          }
        } else {
          timing = util.Timing.fromAny(timing);
        }
        geoView.graphics.setState(graphics, timing, component.Affinity.Intrinsic);
      }
    }
  }
  __decorate([ TraitViewRef({
    traitType: GeoIconTrait,
    observesTrait: true,
    willAttachTrait(geoTrait) {
      this.owner.callObservers("controllerWillAttachGeoTrait", geoTrait, this.owner);
    },
    didAttachTrait(geoTrait) {
      const geoView = this.view;
      if (geoView !== null) {
        this.owner.setGeoCenter(geoTrait.geoCenter.value, geoTrait);
        this.owner.setIconLayout(geoTrait.iconLayout.value, geoTrait);
        this.owner.setGraphics(geoTrait.graphics.value, geoTrait);
      }
    },
    didDetachTrait(geoTrait) {
      this.owner.callObservers("controllerDidDetachGeoTrait", geoTrait, this.owner);
    },
    traitDidSetGeoCenter(newGeoCenter, oldGeoCenter, geoTrait) {
      this.owner.setGeoCenter(newGeoCenter, geoTrait);
    },
    traitDidSetIconLayout(newIconLayout, oldIconLayout, geoTrait) {
      this.owner.setIconLayout(newIconLayout, geoTrait);
    },
    traitDidSetGraphics(newGraphics, oldGraphics, geoTrait) {
      this.owner.setGraphics(newGraphics, geoTrait);
    },
    viewType: GeoIconView,
    observesView: true,
    willAttachView(geoView) {
      this.owner.callObservers("controllerWillAttachGeoView", geoView, this.owner);
    },
    didAttachView(geoView) {
      const geoTrait = this.trait;
      if (geoTrait !== null) {
        this.owner.setGeoCenter(geoTrait.geoCenter.value, geoTrait);
        this.owner.setIconLayout(geoTrait.iconLayout.value, geoTrait);
        this.owner.setGraphics(geoTrait.graphics.value, geoTrait);
      }
    },
    didDetachView(geoView) {
      this.owner.callObservers("controllerDidDetachGeoView", geoView, this.owner);
    },
    viewWillSetGeoCenter(newGeoCenter, oldGeoCenter) {
      this.owner.callObservers("controllerWillSetGeoCenter", newGeoCenter, oldGeoCenter, this.owner);
    },
    viewDidSetGeoCenter(newGeoCenter, oldGeoCenter) {
      this.owner.callObservers("controllerDidSetGeoCenter", newGeoCenter, oldGeoCenter, this.owner);
    },
    viewWillSetGraphics(newGraphics, oldGraphics) {
      this.owner.callObservers("controllerWillSetGraphics", newGraphics, oldGraphics, this.owner);
    },
    viewDidSetGraphics(newGraphics, oldGraphics) {
      this.owner.callObservers("controllerDidSetGraphics", newGraphics, oldGraphics, this.owner);
    }
  }) ], GeoIconController.prototype, "geo", void 0);
  class MapView extends GeoView {
    needsProcess(processFlags, viewContext) {
      if ((processFlags & View.NeedsResize) !== 0) {
        processFlags |= View.NeedsProject;
      }
      return processFlags;
    }
    extendViewContext(viewContext) {
      const mapViewContext = Object.create(viewContext);
      mapViewContext.geoViewport = this.geoViewport;
      return mapViewContext;
    }
    get geoFrame() {
      return this.geoViewport.geoFrame;
    }
  }
  __decorate([ ViewRef({
    type: CanvasView,
    willAttachView(canvasView) {
      this.owner.callObservers("viewWillAttachMapCanvas", canvasView, this.owner);
    },
    didDetachView(canvasView) {
      this.owner.callObservers("viewDidDetachMapCanvas", canvasView, this.owner);
    }
  }) ], MapView.prototype, "canvas", void 0);
  __decorate([ ViewRef({
    type: HtmlView,
    willAttachView(containerView) {
      this.owner.callObservers("viewWillAttachMapContainer", containerView, this.owner);
    },
    didDetachView(containerView) {
      this.owner.callObservers("viewDidDetachMapContainer", containerView, this.owner);
    }
  }) ], MapView.prototype, "container", void 0);
  class MapTrait extends GeoTrait {
    get geoBounds() {
      return geo.GeoBox.globe();
    }
    startConsumingLayers() {
      const layerTraits = this.layers.traits;
      for (const traitId in layerTraits) {
        const layerTrait = layerTraits[traitId];
        layerTrait.consume(this);
      }
    }
    stopConsumingLayers() {
      const layerTraits = this.layers.traits;
      for (const traitId in layerTraits) {
        const layerTrait = layerTraits[traitId];
        layerTrait.unconsume(this);
      }
    }
    onStartConsuming() {
      super.onStartConsuming();
      this.startConsumingLayers();
    }
    onStopConsuming() {
      super.onStopConsuming();
      this.stopConsumingLayers();
    }
  }
  __decorate([ component.Property({
    type: GeoPerspective,
    value: null,
    willSetValue(newGeoPerspective, oldGeoPerspective) {
      this.owner.callObservers("traitWillSetGeoPerspective", newGeoPerspective, oldGeoPerspective, this.owner);
    },
    didSetValue(newGeoPerspective, oldGeoPerspective) {
      this.owner.callObservers("traitDidSetGeoPerspective", newGeoPerspective, oldGeoPerspective, this.owner);
    }
  }) ], MapTrait.prototype, "geoPerspective", void 0);
  __decorate([ TraitSet({
    type: GeoTrait,
    binds: true,
    willAttachTrait(newLayerTrait, targetTrait) {
      this.owner.callObservers("traitWillAttachLayer", newLayerTrait, targetTrait, this.owner);
    },
    didAttachTrait(layerTrait) {
      if (this.owner.consuming) {
        layerTrait.consume(this.owner);
      }
    },
    willDetachTrait(layerTrait) {
      if (this.owner.consuming) {
        layerTrait.unconsume(this.owner);
      }
    },
    didDetachTrait(newLayerTrait) {
      this.owner.callObservers("traitDidDetachLayer", newLayerTrait, this.owner);
    },
    detectModel(model) {
      return model.getTrait(GeoTrait);
    },
    detectTrait(trait) {
      return null;
    }
  }) ], MapTrait.prototype, "layers", void 0);
  class MapController extends Controller {
    setGeoPerspective(geoPerspective) {
      if (geoPerspective !== null) {
        const mapView = this.map.view;
        if (mapView !== null) {
          mapView.moveTo(geoPerspective);
        }
      }
    }
  }
  __decorate([ TraitViewRef({
    traitType: MapTrait,
    observesTrait: true,
    willAttachTrait(mapTrait) {
      this.owner.callObservers("controllerWillAttachMapTrait", mapTrait, this.owner);
    },
    didAttachTrait(mapTrait) {
      const mapView = this.view;
      if (mapView !== null) {
        this.owner.setGeoPerspective(mapTrait.geoPerspective.value);
      }
      const layerTraits = mapTrait.layers.traits;
      for (const traitId in layerTraits) {
        const layerTrait = layerTraits[traitId];
        this.owner.layers.addTraitController(layerTrait);
      }
    },
    willDetachTrait(mapTrait) {
      const layerTraits = mapTrait.layers.traits;
      for (const traitId in layerTraits) {
        const layerTrait = layerTraits[traitId];
        this.owner.layers.deleteTraitController(layerTrait);
      }
    },
    didDetachTrait(mapTrait) {
      this.owner.callObservers("controllerDidDetachMapTrait", mapTrait, this.owner);
    },
    traitDidSetGeoPerspective(newGeoPerspective, oldGeoPerspective) {
      this.owner.setGeoPerspective(newGeoPerspective);
    },
    traitWillAttachLayer(layerTrait, targetTrait) {
      this.owner.layers.addTraitController(layerTrait, targetTrait);
    },
    traitDidDetachLayer(layerTrait) {
      this.owner.layers.deleteTraitController(layerTrait);
    },
    viewType: MapView,
    observesView: true,
    willAttachView(mapView) {
      this.owner.callObservers("controllerWillAttachMapView", mapView, this.owner);
    },
    didAttachView(mapView) {
      this.owner.canvas.setView(mapView.canvas.view);
      this.owner.container.setView(mapView.container.view);
      const mapTrait = this.trait;
      if (mapTrait !== null) {
        this.owner.setGeoPerspective(mapTrait.geoPerspective.value);
      }
      const layerControllers = this.owner.layers.controllers;
      for (const controllerId in layerControllers) {
        const layerController = layerControllers[controllerId];
        const layerView = layerController.geo.view;
        if (layerView !== null && layerView.parent === null) {
          layerController.geo.insertView(mapView);
        }
      }
    },
    willDetachView(mapView) {
      this.owner.canvas.setView(null);
      this.owner.container.setView(null);
    },
    didDetachView(mapView) {
      this.owner.callObservers("controllerDidDetachMapView", mapView, this.owner);
    },
    viewWillSetGeoViewport(newGeoViewport, oldGeoViewport) {
      this.owner.callObservers("controllerWillSetGeoViewport", newGeoViewport, oldGeoViewport, this.owner);
    },
    viewDidSetGeoViewport(newGeoViewport, oldGeoViewport) {
      this.owner.callObservers("controllerDidSetGeoViewport", newGeoViewport, oldGeoViewport, this.owner);
    },
    viewWillAttachMapCanvas(mapCanvasView) {
      this.owner.canvas.setView(mapCanvasView);
    },
    viewDidDetachMapCanvas(mapCanvasView) {
      this.owner.canvas.setView(null);
    },
    viewWillAttachMapContainer(mapContainerView) {
      this.owner.container.setView(mapContainerView);
    },
    viewDidDetachMapContainer(mapContainerView) {
      this.owner.container.setView(null);
    }
  }) ], MapController.prototype, "map", void 0);
  __decorate([ ViewRef({
    type: CanvasView,
    willAttachView(mapCanvasView) {
      this.owner.callObservers("controllerWillAttachMapCanvasView", mapCanvasView, this.owner);
    },
    didDetachView(mapCanvasView) {
      this.owner.callObservers("controllerDidDetachMapCanvasView", mapCanvasView, this.owner);
    }
  }) ], MapController.prototype, "canvas", void 0);
  __decorate([ ViewRef({
    type: HtmlView,
    willAttachView(mapContainerView) {
      this.owner.callObservers("controllerWillAttachMapContainerView", mapContainerView, this.owner);
    },
    didAttachView(containerView) {
      const mapView = this.owner.createMapView(containerView);
      mapView.container.setView(containerView);
      this.owner.map.setView(mapView);
    },
    didDetachView(mapContainerView) {
      this.owner.callObservers("controllerDidDetachMapContainerView", mapContainerView, this.owner);
    }
  }) ], MapController.prototype, "container", void 0);
  __decorate([ component.Property({
    type: util.Timing,
    value: true
  }) ], MapController.prototype, "geoTiming", void 0);
  __decorate([ TraitViewControllerSet({
    implements: true,
    type: GeoController,
    binds: true,
    observes: true,
    get parentView() {
      return this.owner.map.view;
    },
    getTraitViewRef(layerController) {
      return layerController.geo;
    },
    willAttachController(layerController) {
      this.owner.callObservers("controllerWillAttachLayer", layerController, this.owner);
    },
    didAttachController(layerController) {
      const layerTrait = layerController.geo.trait;
      if (layerTrait !== null) {
        this.attachLayerTrait(layerTrait, layerController);
      }
      const layerView = layerController.geo.view;
      if (layerView !== null) {
        this.attachLayerView(layerView, layerController);
      }
    },
    willDetachController(layerController) {
      const layerView = layerController.geo.view;
      if (layerView !== null) {
        this.detachLayerView(layerView, layerController);
      }
      const layerTrait = layerController.geo.trait;
      if (layerTrait !== null) {
        this.detachLayerTrait(layerTrait, layerController);
      }
    },
    didDetachController(layerController) {
      this.owner.callObservers("controllerDidDetachLayer", layerController, this.owner);
    },
    controllerWillAttachGeoTrait(layerTrait, layerController) {
      this.owner.callObservers("controllerWillAttachLayerTrait", layerTrait, layerController, this.owner);
      this.attachLayerTrait(layerTrait, layerController);
    },
    controllerDidDetachGeoTrait(layerTrait, layerController) {
      this.detachLayerTrait(layerTrait, layerController);
      this.owner.callObservers("controllerDidDetachLayerTrait", layerTrait, layerController, this.owner);
    },
    attachLayerTrait(layerTrait, layerController) {},
    detachLayerTrait(layerTrait, layerController) {},
    controllerWillAttachGeoView(layerView, layerController) {
      this.owner.callObservers("controllerWillAttachLayerView", layerView, layerController, this.owner);
      this.attachLayerView(layerView, layerController);
    },
    controllerDidDetachGeoView(layerView, layerController) {
      this.detachLayerView(layerView, layerController);
      this.owner.callObservers("controllerDidDetachLayerView", layerView, layerController, this.owner);
    },
    attachLayerView(layerView, layerController) {},
    detachLayerView(layerView, layerController) {
      layerView.remove();
    },
    controllerWillSetGeoBounds(newGeoBounds, oldGeoBounds, layerController) {
      this.owner.callObservers("controllerWillSetLayerGeoBounds", newGeoBounds, oldGeoBounds, layerController, this.owner);
    },
    controllerDidSetGeoBounds(newGeoBounds, oldGeoBounds, layerController) {
      this.owner.callObservers("controllerDidSetLayerGeoBounds", newGeoBounds, oldGeoBounds, layerController, this.owner);
    },
    createController(layerTrait) {
      if (layerTrait !== void 0) {
        return GeoController.fromTrait(layerTrait);
      } else {
        return TraitViewControllerSet.prototype.createController.call(this);
      }
    }
  }) ], MapController.prototype, "layers", void 0);
  class WorldMapViewport {
    get geoFrame() {
      return geo.GeoBox.globe();
    }
    get geoCenter() {
      return geo.GeoPoint.origin();
    }
    get zoom() {
      return 0;
    }
    get heading() {
      return 0;
    }
    get tilt() {
      return 0;
    }
    canEqual(that) {
      return that instanceof WorldMapViewport && this.constructor === that.constructor;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof WorldMapViewport) {
        return that.canEqual(this) && this.viewFrame.equals(that.viewFrame);
      }
      return false;
    }
  }
  class EquirectangularMapViewport extends WorldMapViewport {
    constructor(viewFrame) {
      super();
      this.viewFrame = viewFrame;
    }
    withViewFrame(viewFrame) {
      let xMin = viewFrame.xMin;
      let yMin = viewFrame.yMin;
      let xMax = viewFrame.xMax;
      let yMax = viewFrame.yMax;
      const width = xMax - xMin;
      const height = yMax - yMin;
      const frameRatio = width / height;
      const mapRatio = 2;
      if (frameRatio < mapRatio) {
        const dy = (height - width / mapRatio) / 2;
        yMin += dy;
        yMax -= dy;
        viewFrame = new math.R2Box(xMin, yMin, xMax, yMax);
      } else if (frameRatio > mapRatio) {
        const dx = (width - height * mapRatio) / 2;
        xMin += dx;
        xMax -= dx;
        viewFrame = new math.R2Box(xMin, yMin, xMax, yMax);
      }
      return new EquirectangularMapViewport(viewFrame);
    }
    project(lng, lat) {
      if (arguments.length === 1) {
        if (Array.isArray(lng)) {
          lat = lng[1];
          lng = lng[0];
        } else {
          lat = lng.lat;
          lng = lng.lng;
        }
      }
      const viewFrame = this.viewFrame;
      const x = viewFrame.xMin + (180 + lng) / 360 * viewFrame.width;
      const y = viewFrame.yMax - (90 + lat) / 180 * viewFrame.height;
      return new math.R2Point(x, y);
    }
    unproject(x, y) {
      if (arguments.length === 1) {
        if (Array.isArray(x)) {
          y = x[1];
          x = x[0];
        } else {
          y = x.y;
          x = x.x;
        }
      }
      const viewFrame = this.viewFrame;
      const lng = 360 * (x - viewFrame.xMin) / viewFrame.width - 180;
      const lat = 180 * (viewFrame.yMax - y) / viewFrame.height - 90;
      return new geo.GeoPoint(lng, lat);
    }
  }
  class WorldMapView extends MapView {
    constructor(geoViewport) {
      super();
      Object.defineProperty(this, "geoViewport", {
        value: geoViewport,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
    willSetGeoViewport(newGeoViewport, oldGeoViewport) {
      this.callObservers("viewWillSetGeoViewport", newGeoViewport, oldGeoViewport, this);
    }
    onSetGeoViewport(newGeoViewport, oldGeoViewport) {}
    didSetGeoViewport(newGeoViewport, oldGeoViewport) {
      this.callObservers("viewDidSetGeoViewport", newGeoViewport, oldGeoViewport, this);
    }
    updateGeoViewport() {
      const oldGeoViewport = this.geoViewport;
      const newGeoViewport = oldGeoViewport.withViewFrame(this.viewFrame);
      if (!newGeoViewport.equals(oldGeoViewport)) {
        this.willSetGeoViewport(newGeoViewport, oldGeoViewport);
        this.geoViewport = newGeoViewport;
        this.onSetGeoViewport(newGeoViewport, oldGeoViewport);
        this.didSetGeoViewport(newGeoViewport, oldGeoViewport);
        return true;
      }
      return false;
    }
    willProcess(processFlags, viewContext) {
      if ((processFlags & View.NeedsProject) !== 0) {
        this.updateGeoViewport();
        viewContext.geoViewport = this.geoViewport;
      }
      super.willProcess(processFlags, viewContext);
    }
    moveTo(geoPerspective, timing) {}
    static create(geoViewport) {
      if (geoViewport === void 0) {
        geoViewport = new EquirectangularMapViewport(math.R2Box.undefined());
      }
      return new WorldMapView(geoViewport);
    }
  }
  __decorate([ ViewRef({
    extends: true,
    didAttachView(canvasView, targetView) {
      if (this.owner.parent === null) {
        canvasView.appendChild(this.owner);
      }
      MapView.canvas.prototype.didAttachView.call(this, canvasView, targetView);
    },
    willDetachView(canvasView) {
      MapView.canvas.prototype.willDetachView.call(this, canvasView);
      if (this.owner.parent === canvasView) {
        canvasView.removeChild(this.owner);
      }
    }
  }) ], WorldMapView.prototype, "canvas", void 0);
  __decorate([ ViewRef({
    extends: true,
    didAttachView(containerView, targetView) {
      this.owner.canvas.insertView(containerView);
      MapView.container.prototype.didAttachView.call(this, containerView, targetView);
    },
    willDetachView(containerView) {
      MapView.container.prototype.willDetachView.call(this, containerView);
      const canvasView = this.owner.canvas.view;
      if (canvasView !== null && canvasView.parent === containerView) {
        containerView.removeChild(canvasView);
      }
    }
  }) ], WorldMapView.prototype, "container", void 0);
  class MapboxViewport {
    constructor(map, geoFrame, geoCenter, zoom, heading, tilt) {
      this.map = map;
      this.geoFrame = geoFrame;
      this.geoCenter = geoCenter;
      this.zoom = zoom;
      this.heading = heading;
      this.tilt = tilt;
    }
    project(lng, lat) {
      let geoPoint;
      if (typeof lng === "number") {
        geoPoint = new mapboxgl.LngLat(lng, lat);
      } else {
        geoPoint = lng;
      }
      const point = this.map.project(geoPoint);
      return new math.R2Point(point.x, point.y);
    }
    unproject(x, y) {
      let viewPoint;
      if (typeof x === "number") {
        viewPoint = new mapboxgl.Point(x, y);
      } else if (Array.isArray(x)) {
        viewPoint = x;
      } else {
        viewPoint = new mapboxgl.Point(x.x, x.y);
      }
      const point = this.map.unproject(viewPoint);
      return new geo.GeoPoint(point.lng, point.lat);
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof MapboxViewport) {
        return this.map === that.map && this.geoFrame.equals(that.geoFrame) && this.geoCenter.equals(that.geoCenter) && this.zoom === that.zoom && this.heading === that.heading && this.tilt === that.tilt;
      }
      return false;
    }
    static create(map) {
      const mapFrame = map.getBounds();
      const geoFrame = new geo.GeoBox(mapFrame.getWest(), mapFrame.getSouth(), mapFrame.getEast(), mapFrame.getNorth());
      const mapCenter = map.getCenter();
      const geoCenter = new geo.GeoPoint(mapCenter.lng, mapCenter.lat);
      const zoom = map.getZoom();
      const heading = map.getBearing();
      const tilt = map.getPitch();
      return new MapboxViewport(map, geoFrame, geoCenter, zoom, heading, tilt);
    }
  }
  class MapboxView extends MapView {
    constructor(map) {
      super();
      this.map = map;
      Object.defineProperty(this, "geoViewport", {
        value: MapboxViewport.create(map),
        writable: true,
        enumerable: true,
        configurable: true
      });
      this.onMapRender = this.onMapRender.bind(this);
      this.onMoveStart = this.onMoveStart.bind(this);
      this.onMoveEnd = this.onMoveEnd.bind(this);
      this.initMap(map);
    }
    initMap(map) {
      map.on("render", this.onMapRender);
      map.on("movestart", this.onMoveStart);
      map.on("moveend", this.onMoveEnd);
    }
    willSetGeoViewport(newGeoViewport, oldGeoViewport) {
      this.callObservers("viewWillSetGeoViewport", newGeoViewport, oldGeoViewport, this);
    }
    onSetGeoViewport(newGeoViewport, oldGeoViewport) {}
    didSetGeoViewport(newGeoViewport, oldGeoViewport) {
      this.callObservers("viewDidSetGeoViewport", newGeoViewport, oldGeoViewport, this);
    }
    updateGeoViewport() {
      const oldGeoViewport = this.geoViewport;
      const newGeoViewport = MapboxViewport.create(this.map);
      if (!newGeoViewport.equals(oldGeoViewport)) {
        this.willSetGeoViewport(newGeoViewport, oldGeoViewport);
        this.geoViewport = newGeoViewport;
        this.onSetGeoViewport(newGeoViewport, oldGeoViewport);
        this.didSetGeoViewport(newGeoViewport, oldGeoViewport);
        return true;
      }
      return false;
    }
    onMapRender() {
      if (this.updateGeoViewport()) {
        const immediate = !this.hidden && !this.culled;
        this.requireUpdate(View.NeedsProject, immediate);
      }
    }
    onMoveStart() {
      this.willMoveMap();
    }
    onMoveEnd() {
      this.didMoveMap();
    }
    moveTo(geoPerspective, timing) {
      const options = {};
      const geoViewport = this.geoViewport;
      let geoCenter = geoPerspective.geoCenter;
      if (geoCenter !== void 0 && geoCenter !== null) {
        geoCenter = geo.GeoPoint.fromAny(geoCenter);
        if (!geoViewport.geoCenter.equivalentTo(geoCenter, 1e-5)) {
          options.center = geoCenter;
        }
      }
      const zoom = geoPerspective.zoom;
      if (zoom !== void 0 && !util.Equivalent(geoViewport.zoom, zoom, 1e-5)) {
        options.zoom = zoom;
      }
      const heading = geoPerspective.heading;
      if (heading !== void 0 && !util.Equivalent(geoViewport.heading, heading, 1e-5)) {
        options.bearing = heading;
      }
      const tilt = geoPerspective.tilt;
      if (tilt !== void 0 && !util.Equivalent(geoViewport.tilt, tilt, 1e-5)) {
        options.pitch = tilt;
      }
      if (timing === void 0 || timing === true) {
        timing = this.getLookOr(Look.timing, Mood.ambient, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      if (timing instanceof util.Timing) {
        options.duration = timing.duration;
      }
      this.map.flyTo(options);
    }
    willMoveMap() {
      this.callObservers("viewWillMoveMap", this);
    }
    didMoveMap() {
      this.callObservers("viewDidMoveMap", this);
    }
  }
  __decorate([ ViewRef({
    extends: true,
    didAttachView(canvasView, targetView) {
      if (this.owner.parent === null) {
        canvasView.appendChild(this.owner);
        canvasView.setEventNode(this.owner.map.getCanvasContainer());
      }
      MapView.canvas.prototype.didAttachView.call(this, canvasView, targetView);
    },
    willDetachView(canvasView) {
      MapView.canvas.prototype.willDetachView.call(this, canvasView);
      if (this.owner.parent === canvasView) {
        canvasView.removeChild(this.owner);
      }
    }
  }) ], MapboxView.prototype, "canvas", void 0);
  __decorate([ ViewRef({
    extends: true,
    didAttachView(containerView, targetView) {
      HtmlView.fromNode(this.owner.map.getContainer());
      const canvasContainerView = HtmlView.fromNode(this.owner.map.getCanvasContainer());
      this.owner.canvas.insertView(canvasContainerView);
      MapView.container.prototype.didAttachView.call(this, containerView, targetView);
    },
    willDetachView(containerView) {
      MapView.container.prototype.willDetachView.call(this, containerView);
      const canvasView = this.owner.canvas.view;
      const canvasContainerView = HtmlView.fromNode(this.owner.map.getCanvasContainer());
      if (canvasView !== null && canvasView.parent === canvasContainerView) {
        canvasContainerView.removeChild(containerView);
      }
    }
  }) ], MapboxView.prototype, "container", void 0);
  class LeafletViewport {
    constructor(map, geoFrame, geoCenter, viewOrigin, zoom, heading, tilt) {
      this.map = map;
      this.geoFrame = geoFrame;
      this.geoCenter = geoCenter;
      this.viewOrigin = viewOrigin;
      this.zoom = zoom;
      this.heading = heading;
      this.tilt = tilt;
    }
    project(lng, lat) {
      const origin = this.viewOrigin;
      let geoPoint;
      if (typeof lng === "number") {
        geoPoint = new L.LatLng(lat, lng);
      } else if (Array.isArray(lng)) {
        geoPoint = new L.LatLng(lng[1], lng[0]);
      } else {
        geoPoint = lng;
      }
      const point = this.map.project(geoPoint, this.zoom);
      return new math.R2Point(point.x - origin.x, point.y - origin.y);
    }
    unproject(x, y) {
      const origin = this.viewOrigin;
      let viewPoint;
      if (typeof x === "number") {
        viewPoint = new L.Point(x + origin.x, y + origin.y);
      } else if (Array.isArray(x)) {
        viewPoint = new L.Point(x[0] + origin.x, x[1] + origin.y);
      } else {
        viewPoint = new L.Point(x.x + origin.x, x.y + origin.y);
      }
      const point = this.map.unproject(viewPoint, this.zoom);
      return new geo.GeoPoint(point.lng, point.lat);
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof LeafletViewport) {
        return this.map === that.map && this.geoFrame.equals(that.geoFrame) && this.geoCenter.equals(that.geoCenter) && this.viewOrigin.equals(that.viewOrigin) && this.zoom === that.zoom && this.heading === that.heading && this.tilt === that.tilt;
      }
      return false;
    }
    static create(map) {
      const mapFrame = map.getBounds();
      const geoFrame = new geo.GeoBox(mapFrame.getWest(), mapFrame.getSouth(), mapFrame.getEast(), mapFrame.getNorth());
      const mapCenter = map.getCenter();
      const geoCenter = new geo.GeoPoint(mapCenter.lng, mapCenter.lat);
      let {x: x, y: y} = map.getPixelOrigin();
      try {
        const mapTransform = math.Transform.parse(map.getPane("mapPane").style.transform);
        if (mapTransform instanceof math.TranslateTransform) {
          x -= mapTransform.x.pxValue();
          y -= mapTransform.y.pxValue();
        }
      } catch (e) {}
      const viewOrigin = new math.R2Point(x, y);
      const zoom = map.getZoom();
      const heading = 0;
      const tilt = 0;
      return new LeafletViewport(map, geoFrame, geoCenter, viewOrigin, zoom, heading, tilt);
    }
  }
  class LeafletView extends MapView {
    constructor(map) {
      super();
      this.map = map;
      Object.defineProperty(this, "geoViewport", {
        value: LeafletViewport.create(map),
        writable: true,
        enumerable: true,
        configurable: true
      });
      this.onMapRender = this.onMapRender.bind(this);
      this.onMoveStart = this.onMoveStart.bind(this);
      this.onMoveEnd = this.onMoveEnd.bind(this);
      this.initMap(map);
    }
    initMap(map) {
      map.on("move", this.onMapRender);
      map.on("movestart", this.onMoveStart);
      map.on("moveend", this.onMoveEnd);
    }
    willSetGeoViewport(newGeoViewport, oldGeoViewport) {
      this.callObservers("viewWillSetGeoViewport", newGeoViewport, oldGeoViewport, this);
    }
    onSetGeoViewport(newGeoViewport, oldGeoViewport) {}
    didSetGeoViewport(newGeoViewport, oldGeoViewport) {
      this.callObservers("viewDidSetGeoViewport", newGeoViewport, oldGeoViewport, this);
    }
    updateGeoViewport() {
      const oldGeoViewport = this.geoViewport;
      const newGeoViewport = LeafletViewport.create(this.map);
      if (!newGeoViewport.equals(oldGeoViewport)) {
        this.willSetGeoViewport(newGeoViewport, oldGeoViewport);
        this.geoViewport = newGeoViewport;
        this.onSetGeoViewport(newGeoViewport, oldGeoViewport);
        this.didSetGeoViewport(newGeoViewport, oldGeoViewport);
        return true;
      }
      return false;
    }
    onMapRender() {
      if (this.updateGeoViewport()) {
        const immediate = !this.hidden && !this.culled;
        this.requireUpdate(View.NeedsProject, immediate);
      }
    }
    onMoveStart() {
      this.willMoveMap();
    }
    onMoveEnd() {
      this.didMoveMap();
    }
    moveTo(geoPerspective, timing) {
      const options = {};
      const geoViewport = this.geoViewport;
      let geoCenter = geoPerspective.geoCenter;
      if (geoCenter !== void 0 && geoCenter !== null) {
        geoCenter = geo.GeoPoint.fromAny(geoCenter);
      } else {
        geoCenter = geoViewport.geoCenter;
      }
      const zoom = geoPerspective.zoom;
      if (timing === void 0 || timing === true) {
        timing = this.getLookOr(Look.timing, Mood.ambient, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      if (timing instanceof util.Timing) {
        options.animate = true;
        options.duration = timing.duration;
      }
      this.map.flyTo(geoCenter, zoom, options);
    }
    willMoveMap() {
      this.callObservers("viewWillMoveMap", this);
    }
    didMoveMap() {
      this.callObservers("viewDidMoveMap", this);
    }
  }
  __decorate([ ViewRef({
    extends: true,
    didAttachView(canvasView, targetView) {
      if (this.owner.parent === null) {
        canvasView.appendChild(this.owner);
      }
      MapView.canvas.prototype.didAttachView.call(this, canvasView, targetView);
    },
    willDetachView(canvasView) {
      MapView.canvas.prototype.willDetachView.call(this, canvasView);
      if (this.owner.parent === canvasView) {
        canvasView.removeChild(this.owner);
      }
    }
  }) ], LeafletView.prototype, "canvas", void 0);
  __decorate([ ViewRef({
    extends: true,
    didAttachView(containerView, targetView) {
      const controlContainerView = HtmlView.fromNode(containerView.node.querySelector(".leaflet-control-container"));
      const canvasView = this.owner.canvas.insertView(containerView, void 0, controlContainerView);
      if (canvasView !== null) {
        canvasView.zIndex.setState(500, component.Affinity.Intrinsic);
      }
      MapView.container.prototype.didAttachView.call(this, containerView, targetView);
    },
    willDetachView(containerView) {
      MapView.container.prototype.willDetachView.call(this, containerView);
      const canvasView = this.owner.canvas.view;
      if (canvasView !== null && canvasView.parent === containerView) {
        containerView.removeChild(containerView);
      }
    }
  }) ], LeafletView.prototype, "container", void 0);
  class GoogleMapViewport {
    constructor(projection, geoFrame, geoCenter, zoom, heading, tilt) {
      this.projection = projection;
      this.geoFrame = geoFrame;
      this.geoCenter = geoCenter;
      this.zoom = zoom;
      this.heading = heading;
      this.tilt = tilt;
    }
    project(lng, lat) {
      const projection = this.projection;
      if (projection !== null) {
        let geoPoint;
        if (typeof lng === "number") {
          geoPoint = new google.maps.LatLng(lat, lng);
        } else if (Array.isArray(lng)) {
          geoPoint = new google.maps.LatLng(lng[1], lng[0]);
        } else {
          geoPoint = new google.maps.LatLng(lng.lat, lng.lng);
        }
        const point = projection.fromLatLngToContainerPixel(geoPoint);
        if (point !== null) {
          return new math.R2Point(point.x, point.y);
        }
      }
      return math.R2Point.undefined();
    }
    unproject(x, y) {
      const projection = this.projection;
      if (projection !== null) {
        let viewPoint;
        if (typeof x === "number") {
          viewPoint = new google.maps.Point(x, y);
        } else if (Array.isArray(x)) {
          viewPoint = new google.maps.Point(x[0], x[1]);
        } else {
          viewPoint = new google.maps.Point(x.x, x.y);
        }
        const point = projection.fromContainerPixelToLatLng(viewPoint);
        if (point !== null) {
          return new geo.GeoPoint(point.lng(), point.lat());
        }
      }
      return geo.GeoPoint.undefined();
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof GoogleMapViewport) {
        return this.projection === that.projection && this.geoFrame.equals(that.geoFrame) && this.geoCenter.equals(that.geoCenter) && this.zoom === that.zoom && this.heading === that.heading && this.tilt === that.tilt;
      }
      return false;
    }
    static create(map, projection) {
      if (projection === void 0) {
        projection = null;
      }
      const mapFrame = map.getBounds();
      let geoFrame;
      if (mapFrame !== void 0 && mapFrame !== null) {
        const sw = mapFrame.getSouthWest();
        const ne = mapFrame.getNorthEast();
        geoFrame = new geo.GeoBox(sw.lng(), sw.lat(), ne.lng(), ne.lat());
      } else {
        geoFrame = geo.GeoBox.undefined();
      }
      const mapCenter = map.getCenter();
      const geoCenter = mapCenter !== void 0 ? new geo.GeoPoint(mapCenter.lng(), mapCenter.lat()) : geo.GeoPoint.origin();
      let zoom = map.getZoom();
      if (zoom === void 0) {
        zoom = 0;
      }
      let heading = map.getHeading();
      if (heading === void 0) {
        heading = 0;
      }
      let tilt = map.getTilt();
      if (tilt === void 0) {
        tilt = 0;
      }
      return new GoogleMapViewport(projection, geoFrame, geoCenter, zoom, heading, tilt);
    }
  }
  class GoogleMapView extends MapView {
    constructor(map) {
      super();
      this.map = map;
      this.mapOverlay = this.createMapOverlay(map);
      Object.defineProperty(this, "geoViewport", {
        value: GoogleMapViewport.create(this.map, this.mapOverlay.getProjection()),
        writable: true,
        enumerable: true,
        configurable: true
      });
      this.onMapDraw = this.onMapDraw.bind(this);
      this.onMapIdle = this.onMapIdle.bind(this);
      this.initMap(map);
    }
    initMap(map) {
      map.addListener("idle", this.onMapIdle);
    }
    createMapOverlay(map) {
      const mapOverlay = new GoogleMapView.MapOverlay(this);
      mapOverlay.setMap(map);
      return mapOverlay;
    }
    static get MapOverlay() {
      return class GoogleMapOverlayView extends google.maps.OverlayView {
        constructor(owner) {
          super();
          this.owner = owner;
        }
        onAdd() {
          const containerView = this.owner.container.view;
          if (containerView !== null) {
            this.owner.container.materializeView(containerView);
          }
        }
        onRemove() {
          this.owner.canvas.removeView();
        }
        draw() {
          this.owner.onMapDraw();
        }
      };
    }
    willSetGeoViewport(newGeoViewport, oldGeoViewport) {
      this.callObservers("viewWillSetGeoViewport", newGeoViewport, oldGeoViewport, this);
    }
    onSetGeoViewport(newGeoViewport, oldGeoViewport) {}
    didSetGeoViewport(newGeoViewport, oldGeoViewport) {
      this.callObservers("viewDidSetGeoViewport", newGeoViewport, oldGeoViewport, this);
    }
    updateGeoViewport() {
      const oldGeoViewport = this.geoViewport;
      const newGeoViewport = GoogleMapViewport.create(this.map, this.mapOverlay.getProjection());
      if (!newGeoViewport.equals(oldGeoViewport)) {
        this.willSetGeoViewport(newGeoViewport, oldGeoViewport);
        this.geoViewport = newGeoViewport;
        this.onSetGeoViewport(newGeoViewport, oldGeoViewport);
        this.didSetGeoViewport(newGeoViewport, oldGeoViewport);
        return true;
      }
      return false;
    }
    willProcess(processFlags, viewContext) {
      if ((this.flags & View.NeedsProject) !== 0 && this.updateGeoViewport()) {
        viewContext.geoViewport = this.geoViewport;
      }
      super.willProcess(processFlags, viewContext);
    }
    onMapDraw() {
      if (this.updateGeoViewport()) {
        const immediate = !this.hidden && !this.culled;
        this.requireUpdate(View.NeedsProject, immediate);
      }
    }
    onMapIdle() {
      this.requireUpdate(View.NeedsProject);
    }
    moveTo(geoPerspective, timing) {
      const geoViewport = this.geoViewport;
      let geoCenter = geoPerspective.geoCenter;
      if (geoCenter !== void 0 && geoCenter !== null) {
        geoCenter = geo.GeoPoint.fromAny(geoCenter);
        if (!geoViewport.geoCenter.equivalentTo(geoCenter, 1e-5)) {
          this.map.panTo(geoCenter);
        }
      }
      const zoom = geoPerspective.zoom;
      if (zoom !== void 0 && !util.Equivalent(geoViewport.zoom, zoom, 1e-5)) {
        this.map.setZoom(zoom);
      }
      const heading = geoPerspective.heading;
      if (heading !== void 0 && !util.Equivalent(geoViewport.heading, heading, 1e-5)) {
        this.map.setHeading(heading);
      }
      const tilt = geoPerspective.tilt;
      if (tilt !== void 0 && !util.Equivalent(geoViewport.tilt, tilt, 1e-5)) {
        this.map.setTilt(tilt);
      }
    }
  }
  __decorate([ ViewRef({
    extends: true,
    didAttachView(canvasView, targetView) {
      if (this.owner.parent === null) {
        canvasView.appendChild(this.owner);
      }
      MapView.canvas.prototype.didAttachView.call(this, canvasView, targetView);
    },
    willDetachView(canvasView) {
      MapView.canvas.prototype.willDetachView.call(this, canvasView);
      if (this.owner.parent === canvasView) {
        canvasView.removeChild(this.owner);
      }
    }
  }) ], GoogleMapView.prototype, "canvas", void 0);
  __decorate([ ViewRef({
    extends: true,
    implements: true,
    materializeView(containerView) {
      function materializeAncestors(node) {
        const parentNode = node.parentNode;
        if (parentNode instanceof HTMLElement && parentNode.view === void 0) {
          materializeAncestors(parentNode);
        }
        return HtmlView.fromNode(node);
      }
      const mapPanes = this.owner.mapOverlay.getPanes();
      if (mapPanes !== void 0 && mapPanes !== null) {
        materializeAncestors(mapPanes.overlayMouseTarget);
        const overlayMouseTargetView = mapPanes.overlayMouseTarget.view;
        const overlayContainerView = overlayMouseTargetView.parent;
        const canvasContainerView = overlayContainerView.parent;
        this.owner.canvas.insertView(canvasContainerView);
      } else if (this.owner.canvas.view === null) {
        this.owner.canvas.attachView();
      }
    },
    didAttachView(containerView, targetView) {
      this.materializeView(containerView);
      MapView.container.prototype.didAttachView.call(this, containerView, targetView);
    },
    willDetachView(containerView) {
      MapView.container.prototype.willDetachView.call(this, containerView);
      const canvasView = this.owner.canvas.view;
      const mapPanes = this.owner.mapOverlay.getPanes();
      if (mapPanes !== void 0 && mapPanes !== null) {
        const overlayMouseTargetView = mapPanes.overlayMouseTarget.view;
        const overlayContainerView = overlayMouseTargetView.parent;
        const canvasContainerView = overlayContainerView.parent;
        if (canvasView !== null && canvasView.parent === canvasContainerView) {
          canvasContainerView.removeChild(containerView);
        }
      }
    }
  }) ], GoogleMapView.prototype, "container", void 0);
  __decorate([ util.Lazy ], GoogleMapView, "MapOverlay", null);
  class EsriViewport {
    constructor(map, geoFrame, geoCenter, zoom, heading, tilt) {
      this.map = map;
      this.geoFrame = geoFrame;
      this.geoCenter = geoCenter;
      this.zoom = zoom;
      this.heading = heading;
      this.tilt = tilt;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof EsriViewport) {
        return this.map === that.map && this.geoFrame.equals(that.geoFrame) && this.geoCenter.equals(that.geoCenter) && this.zoom === that.zoom && this.heading === that.heading && this.tilt === that.tilt;
      }
      return false;
    }
    static init() {
      if (EsriViewport.webMercatorUtils === void 0) {
        window.require([ "esri/geometry/support/webMercatorUtils" ], (function(webMercatorUtils) {
          EsriViewport.webMercatorUtils = webMercatorUtils;
        }));
      }
    }
  }
  EsriViewport.webMercatorUtils = void 0;
  class EsriView extends MapView {
    constructor() {
      super();
      EsriViewport.init();
    }
  }
  class EsriMapViewport extends EsriViewport {
    constructor(map, geoFrame, geoCenter, zoom, heading, tilt) {
      super(map, geoFrame, geoCenter, zoom, heading, tilt);
    }
    project(lng, lat) {
      let geoPoint;
      if (typeof lng === "number") {
        geoPoint = {
          x: lng,
          y: lat,
          spatialReference: {
            wkid: 4326
          }
        };
      } else if (Array.isArray(lng)) {
        geoPoint = {
          x: lng[0],
          y: lng[1],
          spatialReference: {
            wkid: 4326
          }
        };
      } else {
        geoPoint = {
          x: lng.lng,
          y: lng.lat,
          spatialReference: {
            wkid: 4326
          }
        };
      }
      const point = this.map.toScreen(geoPoint);
      return point !== null ? new math.R2Point(point.x, point.y) : math.R2Point.origin();
    }
    unproject(x, y) {
      let viewPoint;
      if (typeof x === "number") {
        viewPoint = {
          x: x,
          y: y
        };
      } else if (Array.isArray(x)) {
        viewPoint = {
          x: x[0],
          y: x[1]
        };
      } else {
        viewPoint = x;
      }
      const point = this.map.toMap(viewPoint);
      return point !== null ? new geo.GeoPoint(point.longitude, point.latitude) : geo.GeoPoint.origin();
    }
    static create(map) {
      let mapFrame = map.extent;
      let geoFrame;
      if (mapFrame !== null) {
        mapFrame = EsriViewport.webMercatorUtils.webMercatorToGeographic(mapFrame);
        geoFrame = new geo.GeoBox(mapFrame.xmin, mapFrame.ymin, mapFrame.xmax, mapFrame.ymax);
      } else {
        geoFrame = geo.GeoBox.undefined();
      }
      const mapCenter = map.center;
      const geoCenter = new geo.GeoPoint(mapCenter.longitude, mapCenter.latitude);
      const zoom = map.zoom;
      const heading = map.rotation;
      const tilt = 0;
      return new EsriMapViewport(map, geoFrame, geoCenter, zoom, heading, tilt);
    }
  }
  class EsriMapView extends EsriView {
    constructor(map) {
      super();
      this.map = map;
      Object.defineProperty(this, "geoViewport", {
        value: EsriMapViewport.create(map),
        writable: true,
        enumerable: true,
        configurable: true
      });
      this.onMapRender = this.onMapRender.bind(this);
      this.initMap(map);
    }
    initMap(map) {
      map.watch("extent", this.onMapRender);
    }
    willSetGeoViewport(newGeoViewport, oldGeoViewport) {
      this.callObservers("viewWillSetGeoViewport", newGeoViewport, oldGeoViewport, this);
    }
    onSetGeoViewport(newGeoViewport, oldGeoViewport) {}
    didSetGeoViewport(newGeoViewport, oldGeoViewport) {
      this.callObservers("viewDidSetGeoViewport", newGeoViewport, oldGeoViewport, this);
    }
    updateGeoViewport() {
      const oldGeoViewport = this.geoViewport;
      const newGeoViewport = EsriMapViewport.create(this.map);
      if (!newGeoViewport.equals(oldGeoViewport)) {
        this.willSetGeoViewport(newGeoViewport, oldGeoViewport);
        this.geoViewport = newGeoViewport;
        this.onSetGeoViewport(newGeoViewport, oldGeoViewport);
        this.didSetGeoViewport(newGeoViewport, oldGeoViewport);
        return true;
      }
      return false;
    }
    onMapRender() {
      if (this.updateGeoViewport()) {
        const immediate = !this.hidden && !this.culled;
        this.requireUpdate(View.NeedsProject, immediate);
      }
    }
    moveTo(geoPerspective, timing) {
      const target = {};
      const options = {};
      const geoViewport = this.geoViewport;
      let geoCenter = geoPerspective.geoCenter;
      if (geoCenter !== void 0 && geoCenter !== null) {
        geoCenter = geo.GeoPoint.fromAny(geoCenter);
        if (!geoViewport.geoCenter.equivalentTo(geoCenter, 1e-5)) {
          target.center = [ geoCenter.lng, geoCenter.lat ];
        }
      }
      const zoom = geoPerspective.zoom;
      if (zoom !== void 0 && !util.Equivalent(geoViewport.zoom, zoom, 1e-5)) {
        target.zoom = zoom;
      }
      const heading = geoPerspective.heading;
      if (heading !== void 0 && !util.Equivalent(geoViewport.heading, heading, 1e-5)) {
        target.heading = heading;
      }
      const tilt = geoPerspective.tilt;
      if (tilt !== void 0 && !util.Equivalent(geoViewport.tilt, tilt, 1e-5)) {
        target.tilt = tilt;
      }
      if (timing === void 0 || timing === true) {
        timing = this.getLookOr(Look.timing, Mood.ambient, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      if (timing instanceof util.Timing) {
        options.duration = timing.duration;
      }
      this.map.goTo(target, options);
    }
  }
  __decorate([ ViewRef({
    extends: true,
    didAttachView(canvasView, targetView) {
      if (this.owner.parent === null) {
        canvasView.appendChild(this.owner);
        canvasView.setEventNode(this.owner.map.container.querySelector(".esri-view-root"));
      }
      EsriView.canvas.prototype.didAttachView.call(this, canvasView, targetView);
    },
    willDetachView(canvasView) {
      EsriView.canvas.prototype.willDetachView.call(this, canvasView);
      if (this.owner.parent === canvasView) {
        canvasView.removeChild(this.owner);
      }
    }
  }) ], EsriMapView.prototype, "canvas", void 0);
  __decorate([ ViewRef({
    extends: true,
    didAttachView(containerView, targetView) {
      const esriContainerView = HtmlView.fromNode(this.owner.map.container);
      const esriRootView = HtmlView.fromNode(esriContainerView.node.querySelector(".esri-view-root"));
      const esriSurfaceView = HtmlView.fromNode(esriRootView.node.querySelector(".esri-overlay-surface"));
      this.owner.canvas.insertView(esriSurfaceView);
      EsriView.container.prototype.didAttachView.call(this, containerView, targetView);
    },
    willDetachView(containerView) {
      EsriView.container.prototype.willDetachView.call(this, containerView);
      const canvasView = this.owner.canvas.view;
      const esriContainerView = HtmlView.fromNode(this.owner.map.container);
      const esriRootView = HtmlView.fromNode(esriContainerView.node.querySelector(".esri-view-root"));
      const esriSurfaceView = HtmlView.fromNode(esriRootView.node.querySelector(".esri-overlay-surface"));
      if (canvasView !== null && canvasView.parent === esriSurfaceView) {
        esriSurfaceView.removeChild(containerView);
      }
    }
  }) ], EsriMapView.prototype, "container", void 0);
  class EsriSceneViewport extends EsriViewport {
    constructor(map, geoFrame, geoCenter, zoom, heading, tilt) {
      super(map, geoFrame, geoCenter, zoom, heading, tilt);
    }
    project(lng, lat) {
      let geoPoint;
      if (typeof lng === "number") {
        geoPoint = {
          x: lng,
          y: lat,
          spatialReference: {
            wkid: 4326
          }
        };
      } else if (Array.isArray(lng)) {
        geoPoint = {
          x: lng[0],
          y: lng[1],
          spatialReference: {
            wkid: 4326
          }
        };
      } else {
        geoPoint = {
          x: lng.lng,
          y: lng.lat,
          spatialReference: {
            wkid: 4326
          }
        };
      }
      const point = this.map.toScreen(geoPoint);
      return point !== null ? new math.R2Point(point.x, point.y) : math.R2Point.origin();
    }
    unproject(x, y) {
      let viewPoint;
      if (typeof x === "number") {
        viewPoint = {
          x: x,
          y: y
        };
      } else if (Array.isArray(x)) {
        viewPoint = {
          x: x[0],
          y: x[1]
        };
      } else {
        viewPoint = x;
      }
      const point = this.map.toMap(viewPoint);
      return point !== null ? new geo.GeoPoint(point.longitude, point.latitude) : geo.GeoPoint.origin();
    }
    static create(map) {
      let mapFrame = map.extent;
      let geoFrame;
      if (mapFrame !== null) {
        mapFrame = EsriViewport.webMercatorUtils.webMercatorToGeographic(mapFrame);
        geoFrame = new geo.GeoBox(mapFrame.xmin, mapFrame.ymin, mapFrame.xmax, mapFrame.ymax);
      } else {
        geoFrame = geo.GeoBox.undefined();
      }
      const mapCenter = map.center;
      const geoCenter = new geo.GeoPoint(mapCenter.longitude, mapCenter.latitude);
      const zoom = map.zoom;
      const heading = map.camera.heading;
      const tilt = map.camera.tilt;
      return new EsriSceneViewport(map, geoFrame, geoCenter, zoom, heading, tilt);
    }
  }
  class EsriSceneView extends EsriView {
    constructor(map) {
      super();
      this.map = map;
      Object.defineProperty(this, "geoViewport", {
        value: EsriSceneViewport.create(map),
        writable: true,
        enumerable: true,
        configurable: true
      });
      this.onMapRender = this.onMapRender.bind(this);
      this.initMap(map);
    }
    initMap(map) {
      map.watch("extent", this.onMapRender);
    }
    willSetGeoViewport(newGeoViewport, oldGeoViewport) {
      this.callObservers("viewWillSetGeoViewport", newGeoViewport, oldGeoViewport, this);
    }
    onSetGeoViewport(newGeoViewport, oldGeoViewport) {}
    didSetGeoViewport(newGeoViewport, oldGeoViewport) {
      this.callObservers("viewDidSetGeoViewport", newGeoViewport, oldGeoViewport, this);
    }
    updateGeoViewport() {
      const oldGeoViewport = this.geoViewport;
      const newGeoViewport = EsriSceneViewport.create(this.map);
      if (!newGeoViewport.equals(oldGeoViewport)) {
        this.willSetGeoViewport(newGeoViewport, oldGeoViewport);
        this.geoViewport = newGeoViewport;
        this.onSetGeoViewport(newGeoViewport, oldGeoViewport);
        this.didSetGeoViewport(newGeoViewport, oldGeoViewport);
        return true;
      }
      return false;
    }
    onMapRender() {
      if (this.updateGeoViewport()) {
        const immediate = !this.hidden && !this.culled;
        this.requireUpdate(View.NeedsProject, immediate);
      }
    }
    moveTo(geoPerspective, timing) {
      const target = {};
      const options = {};
      const geoViewport = this.geoViewport;
      let geoCenter = geoPerspective.geoCenter;
      if (geoCenter !== void 0 && geoCenter !== null) {
        geoCenter = geo.GeoPoint.fromAny(geoCenter);
        if (!geoViewport.geoCenter.equivalentTo(geoCenter, 1e-5)) {
          target.center = [ geoCenter.lng, geoCenter.lat ];
        }
      }
      const zoom = geoPerspective.zoom;
      if (zoom !== void 0 && !util.Equivalent(geoViewport.zoom, zoom, 1e-5)) {
        target.zoom = zoom;
      }
      const heading = geoPerspective.heading;
      if (heading !== void 0 && !util.Equivalent(geoViewport.heading, heading, 1e-5)) {
        target.heading = heading;
      }
      const tilt = geoPerspective.tilt;
      if (tilt !== void 0 && !util.Equivalent(geoViewport.tilt, tilt, 1e-5)) {
        target.tilt = tilt;
      }
      if (timing === void 0 || timing === true) {
        timing = this.getLookOr(Look.timing, Mood.ambient, false);
      } else {
        timing = util.Timing.fromAny(timing);
      }
      if (timing instanceof util.Timing) {
        options.duration = timing.duration;
      }
      this.map.goTo(target, options);
    }
  }
  __decorate([ ViewRef({
    extends: true,
    didAttachView(canvasView, targetView) {
      if (this.owner.parent === null) {
        canvasView.appendChild(this.owner);
        canvasView.setEventNode(this.owner.map.container.querySelector(".esri-view-root"));
      }
      EsriView.canvas.prototype.didAttachView.call(this, canvasView, targetView);
    },
    willDetachView(canvasView) {
      EsriView.canvas.prototype.willDetachView.call(this, canvasView);
      if (this.owner.parent === canvasView) {
        canvasView.removeChild(this.owner);
      }
    }
  }) ], EsriSceneView.prototype, "canvas", void 0);
  __decorate([ ViewRef({
    extends: true,
    didAttachView(containerView, targetView) {
      const esriContainerView = HtmlView.fromNode(this.owner.map.container);
      const esriRootView = HtmlView.fromNode(esriContainerView.node.querySelector(".esri-view-root"));
      const esriOverlayView = HtmlView.fromNode(esriRootView.node.querySelector(".esri-view-surface"));
      this.owner.canvas.insertView(esriOverlayView);
      EsriView.container.prototype.didAttachView.call(this, containerView, targetView);
    },
    willDetachView(containerView) {
      EsriView.container.prototype.willDetachView.call(this, containerView);
      const canvasView = this.owner.canvas.view;
      const esriContainerView = HtmlView.fromNode(this.owner.map.container);
      const esriRootView = HtmlView.fromNode(esriContainerView.node.querySelector(".esri-view-root"));
      const esriSurfaceView = HtmlView.fromNode(esriRootView.node.querySelector(".esri-view-surface"));
      if (canvasView !== null && canvasView.parent === esriSurfaceView) {
        esriSurfaceView.removeChild(containerView);
      }
    }
  }) ], EsriSceneView.prototype, "container", void 0);
  exports.AngleThemeAnimator = AngleThemeAnimator;
  exports.Arc = Arc;
  exports.ArcView = ArcView;
  exports.AreaPlotController = AreaPlotController;
  exports.AreaPlotTrait = AreaPlotTrait;
  exports.AreaPlotView = AreaPlotView;
  exports.AttributeAnimator = AttributeAnimator;
  exports.AxisController = AxisController;
  exports.AxisTrait = AxisTrait;
  exports.AxisView = AxisView;
  exports.BooleanAttributeAnimator = BooleanAttributeAnimator;
  exports.BooleanThemeAnimator = BooleanThemeAnimator;
  exports.BottomAxisController = BottomAxisController;
  exports.BottomAxisTrait = BottomAxisTrait;
  exports.BottomAxisView = BottomAxisView;
  exports.BottomTickView = BottomTickView;
  exports.BoxShadow = BoxShadow;
  exports.BoxShadowForm = BoxShadowForm;
  exports.BoxShadowInterpolator = BoxShadowInterpolator;
  exports.BoxShadowParser = BoxShadowParser;
  exports.BoxShadowStyleAnimator = BoxShadowStyleAnimator;
  exports.BrightnessFeel = BrightnessFeel;
  exports.BubblePlotController = BubblePlotController;
  exports.BubblePlotTrait = BubblePlotTrait;
  exports.BubblePlotView = BubblePlotView;
  exports.ButtonGlow = ButtonGlow;
  exports.ButtonItem = ButtonItem;
  exports.ButtonMembrane = ButtonMembrane;
  exports.ButtonStack = ButtonStack;
  exports.CanvasRenderer = CanvasRenderer;
  exports.CanvasView = CanvasView;
  exports.CellController = CellController;
  exports.CellTrait = CellTrait;
  exports.CellView = CellView;
  exports.ChartController = ChartController;
  exports.ChartTrait = ChartTrait;
  exports.ChartView = ChartView;
  exports.CircleIcon = CircleIcon;
  exports.CircleIconInterpolator = CircleIconInterpolator;
  exports.ColController = ColController;
  exports.ColLayout = ColLayout;
  exports.ColTrait = ColTrait;
  exports.ColView = ColView;
  exports.Color = Color;
  exports.ColorAttributeAnimator = ColorAttributeAnimator;
  exports.ColorChannel = ColorChannel;
  exports.ColorChannelParser = ColorChannelParser;
  exports.ColorForm = ColorForm;
  exports.ColorLook = ColorLook;
  exports.ColorParser = ColorParser;
  exports.ColorStop = ColorStop;
  exports.ColorStopInterpolator = ColorStopInterpolator;
  exports.ColorStopListParser = ColorStopListParser;
  exports.ColorStopParser = ColorStopParser;
  exports.ColorStyleAnimator = ColorStyleAnimator;
  exports.ColorThemeAnimator = ColorThemeAnimator;
  exports.ContinuousScaleAnimator = ContinuousScaleAnimator;
  exports.Controller = Controller;
  exports.ControllerContext = ControllerContext;
  exports.ControllerRef = ControllerRef;
  exports.ControllerRelation = ControllerRelation;
  exports.ControllerSet = ControllerSet;
  exports.CssContext = CssContext;
  exports.CssRule = CssRule;
  exports.DataPointController = DataPointController;
  exports.DataPointTrait = DataPointTrait;
  exports.DataPointView = DataPointView;
  exports.DataSetController = DataSetController;
  exports.DataSetTrait = DataSetTrait;
  exports.DeckBar = DeckBar;
  exports.DeckButton = DeckButton;
  exports.DeckButtonBackIcon = DeckButtonBackIcon;
  exports.DeckButtonCloseIcon = DeckButtonCloseIcon;
  exports.DeckButtonLabel = DeckButtonLabel;
  exports.DeckCard = DeckCard;
  exports.DeckPost = DeckPost;
  exports.DeckRail = DeckRail;
  exports.DeckSlider = DeckSlider;
  exports.DeckSliderItem = DeckSliderItem;
  exports.DeckSlot = DeckSlot;
  exports.DeckView = DeckView;
  exports.DeckViewBar = DeckViewBar;
  exports.DeckViewCard = DeckViewCard;
  exports.DialController = DialController;
  exports.DialTrait = DialTrait;
  exports.DialView = DialView;
  exports.DisclosureButton = DisclosureButton;
  exports.DisclosureCellView = DisclosureCellView;
  exports.DisplayProvider = DisplayProvider;
  exports.DisplayService = DisplayService;
  exports.DomProvider = DomProvider;
  exports.DomService = DomService;
  exports.DownlinkTrait = DownlinkTrait;
  exports.DrawerButton = DrawerButton;
  exports.DrawerView = DrawerView;
  exports.DrawingRenderer = DrawingRenderer;
  exports.ElementView = ElementView;
  exports.EnclosedIcon = EnclosedIcon;
  exports.EnclosedIconInterpolator = EnclosedIconInterpolator;
  exports.EphemeralStorageService = EphemeralStorageService;
  exports.EquirectangularMapViewport = EquirectangularMapViewport;
  exports.EsriMapView = EsriMapView;
  exports.EsriMapViewport = EsriMapViewport;
  exports.EsriSceneView = EsriSceneView;
  exports.EsriSceneViewport = EsriSceneViewport;
  exports.EsriView = EsriView;
  exports.EsriViewport = EsriViewport;
  exports.ExecuteProvider = ExecuteProvider;
  exports.ExecuteService = ExecuteService;
  exports.Expansion = Expansion;
  exports.ExpansionInterpolator = ExpansionInterpolator;
  exports.ExpansionThemeAnimator = ExpansionThemeAnimator;
  exports.Feel = Feel;
  exports.FeelVector = FeelVector;
  exports.FeelVectorInterpolator = FeelVectorInterpolator;
  exports.FillView = FillView;
  exports.FilledIcon = FilledIcon;
  exports.FloatingButton = FloatingButton;
  exports.Focus = Focus;
  exports.FocusInterpolator = FocusInterpolator;
  exports.FocusThemeAnimator = FocusThemeAnimator;
  exports.Font = Font;
  exports.FontFamily = FontFamily;
  exports.FontFamilyParser = FontFamilyParser;
  exports.FontFamilyStyleAnimator = FontFamilyStyleAnimator;
  exports.FontForm = FontForm;
  exports.FontInterpolator = FontInterpolator;
  exports.FontLook = FontLook;
  exports.FontParser = FontParser;
  exports.FontSize = FontSize;
  exports.FontThemeAnimator = FontThemeAnimator;
  exports.GaugeController = GaugeController;
  exports.GaugeTrait = GaugeTrait;
  exports.GaugeView = GaugeView;
  exports.GeoArcView = GeoArcView;
  exports.GeoAreaController = GeoAreaController;
  exports.GeoAreaTrait = GeoAreaTrait;
  exports.GeoAreaView = GeoAreaView;
  exports.GeoCircleView = GeoCircleView;
  exports.GeoController = GeoController;
  exports.GeoGridController = GeoGridController;
  exports.GeoGridTrait = GeoGridTrait;
  exports.GeoGridView = GeoGridView;
  exports.GeoIconController = GeoIconController;
  exports.GeoIconTrait = GeoIconTrait;
  exports.GeoIconView = GeoIconView;
  exports.GeoLayerController = GeoLayerController;
  exports.GeoLayerTrait = GeoLayerTrait;
  exports.GeoLineController = GeoLineController;
  exports.GeoLineTrait = GeoLineTrait;
  exports.GeoLineView = GeoLineView;
  exports.GeoPathController = GeoPathController;
  exports.GeoPathTrait = GeoPathTrait;
  exports.GeoPathView = GeoPathView;
  exports.GeoPerspective = GeoPerspective;
  exports.GeoPlotView = GeoPlotView;
  exports.GeoPointView = GeoPointView;
  exports.GeoRasterView = GeoRasterView;
  exports.GeoRippleView = GeoRippleView;
  exports.GeoTrait = GeoTrait;
  exports.GeoTree = GeoTree;
  exports.GeoTreeView = GeoTreeView;
  exports.GeoView = GeoView;
  exports.GeoViewport = GeoViewport;
  exports.Gesture = Gesture;
  exports.GestureInput = GestureInput;
  exports.GoogleMapView = GoogleMapView;
  exports.GoogleMapViewport = GoogleMapViewport;
  exports.GraphController = GraphController;
  exports.GraphTrait = GraphTrait;
  exports.GraphView = GraphView;
  exports.GraphicsIconView = GraphicsIconView;
  exports.GraphicsRenderer = GraphicsRenderer;
  exports.GraphicsView = GraphicsView;
  exports.HeaderController = HeaderController;
  exports.HeaderTrait = HeaderTrait;
  exports.HeaderView = HeaderView;
  exports.HexColorParser = HexColorParser;
  exports.HistoryProvider = HistoryProvider;
  exports.HistoryService = HistoryService;
  exports.HistoryState = HistoryState;
  exports.HslColor = HslColor;
  exports.HslColorInterpolator = HslColorInterpolator;
  exports.HslColorParser = HslColorParser;
  exports.HtmlIconView = HtmlIconView;
  exports.HtmlView = HtmlView;
  exports.HtmlViewTagFactory = HtmlViewTagFactory;
  exports.Icon = Icon;
  exports.IconButton = IconButton;
  exports.IconCellController = IconCellController;
  exports.IconCellTrait = IconCellTrait;
  exports.IconCellView = IconCellView;
  exports.IconGraphicsAnimator = IconGraphicsAnimator;
  exports.IconLayout = IconLayout;
  exports.IconView = IconView;
  exports.InputTokenView = InputTokenView;
  exports.InterpolatedFeel = InterpolatedFeel;
  exports.LayoutProvider = LayoutProvider;
  exports.LayoutService = LayoutService;
  exports.LeafController = LeafController;
  exports.LeafTrait = LeafTrait;
  exports.LeafView = LeafView;
  exports.LeafletView = LeafletView;
  exports.LeafletViewport = LeafletViewport;
  exports.LeftAxisController = LeftAxisController;
  exports.LeftAxisTrait = LeftAxisTrait;
  exports.LeftAxisView = LeftAxisView;
  exports.LeftTickView = LeftTickView;
  exports.LengthAttributeAnimator = LengthAttributeAnimator;
  exports.LengthLook = LengthLook;
  exports.LengthStyleAnimator = LengthStyleAnimator;
  exports.LengthStyleConstraintAnimator = LengthStyleConstraintAnimator;
  exports.LengthThemeAnimator = LengthThemeAnimator;
  exports.LengthThemeConstraintAnimator = LengthThemeConstraintAnimator;
  exports.LineHeight = LineHeight;
  exports.LinePlotController = LinePlotController;
  exports.LinePlotTrait = LinePlotTrait;
  exports.LinePlotView = LinePlotView;
  exports.LinearGradient = LinearGradient;
  exports.LinearGradientAngleParser = LinearGradientAngleParser;
  exports.LinearGradientInterpolator = LinearGradientInterpolator;
  exports.LinearGradientParser = LinearGradientParser;
  exports.Look = Look;
  exports.LookVector = LookVector;
  exports.MapController = MapController;
  exports.MapDownlinkTrait = MapDownlinkTrait;
  exports.MapTrait = MapTrait;
  exports.MapView = MapView;
  exports.MapboxView = MapboxView;
  exports.MapboxViewport = MapboxViewport;
  exports.MediaRule = MediaRule;
  exports.Modal = Modal;
  exports.ModalProvider = ModalProvider;
  exports.ModalService = ModalService;
  exports.Model = Model;
  exports.ModelContext = ModelContext;
  exports.ModelRef = ModelRef;
  exports.ModelRelation = ModelRelation;
  exports.ModelSet = ModelSet;
  exports.MomentumGesture = MomentumGesture;
  exports.MomentumGestureInput = MomentumGestureInput;
  exports.Mood = Mood;
  exports.MoodMatrix = MoodMatrix;
  exports.MoodVector = MoodVector;
  exports.MouseMomentumGesture = MouseMomentumGesture;
  exports.MousePositionGesture = MousePositionGesture;
  exports.MouseScaleGesture = MouseScaleGesture;
  exports.NodeView = NodeView;
  exports.NumberAttributeAnimator = NumberAttributeAnimator;
  exports.NumberLook = NumberLook;
  exports.NumberStyleAnimator = NumberStyleAnimator;
  exports.NumberStyleConstraintAnimator = NumberStyleConstraintAnimator;
  exports.NumberThemeAnimator = NumberThemeAnimator;
  exports.NumberThemeConstraintAnimator = NumberThemeConstraintAnimator;
  exports.NumberTickGenerator = NumberTickGenerator;
  exports.OpacityFeel = OpacityFeel;
  exports.PaintingRenderer = PaintingRenderer;
  exports.PathContext = PathContext;
  exports.PathRenderer = PathRenderer;
  exports.PieController = PieController;
  exports.PieTrait = PieTrait;
  exports.PieView = PieView;
  exports.PlotController = PlotController;
  exports.PlotTrait = PlotTrait;
  exports.PointerMomentumGesture = PointerMomentumGesture;
  exports.PointerPositionGesture = PointerPositionGesture;
  exports.PointerScaleGesture = PointerScaleGesture;
  exports.PolygonIcon = PolygonIcon;
  exports.PolygonIconInterpolator = PolygonIconInterpolator;
  exports.PopoverView = PopoverView;
  exports.PositionGesture = PositionGesture;
  exports.PositionGestureInput = PositionGestureInput;
  exports.Presence = Presence;
  exports.PresenceInterpolator = PresenceInterpolator;
  exports.PresenceThemeAnimator = PresenceThemeAnimator;
  exports.RasterView = RasterView;
  exports.Rect = Rect;
  exports.RectView = RectView;
  exports.RefreshProvider = RefreshProvider;
  exports.RefreshService = RefreshService;
  exports.RgbColor = RgbColor;
  exports.RgbColorInterpolator = RgbColorInterpolator;
  exports.RgbColorParser = RgbColorParser;
  exports.RightAxisController = RightAxisController;
  exports.RightAxisTrait = RightAxisTrait;
  exports.RightAxisView = RightAxisView;
  exports.RightTickView = RightTickView;
  exports.RowController = RowController;
  exports.RowTrait = RowTrait;
  exports.RowView = RowView;
  exports.ScaleGesture = ScaleGesture;
  exports.ScaleGestureInput = ScaleGestureInput;
  exports.ScaledView = ScaledView;
  exports.ScaledXView = ScaledXView;
  exports.ScaledXYView = ScaledXYView;
  exports.ScaledYView = ScaledYView;
  exports.ScatterPlotController = ScatterPlotController;
  exports.ScatterPlotTrait = ScatterPlotTrait;
  exports.ScatterPlotView = ScatterPlotView;
  exports.ScrimView = ScrimView;
  exports.SelectableTrait = SelectableTrait;
  exports.SelectionProvider = SelectionProvider;
  exports.SelectionService = SelectionService;
  exports.SeriesPlotController = SeriesPlotController;
  exports.SeriesPlotTrait = SeriesPlotTrait;
  exports.SeriesPlotView = SeriesPlotView;
  exports.ShadowLook = ShadowLook;
  exports.SliceController = SliceController;
  exports.SliceTrait = SliceTrait;
  exports.SliceView = SliceView;
  exports.Sprite = Sprite;
  exports.SpriteService = SpriteService;
  exports.SpriteSheet = SpriteSheet;
  exports.StorageProvider = StorageProvider;
  exports.StorageService = StorageService;
  exports.StringAttributeAnimator = StringAttributeAnimator;
  exports.StringStyleAnimator = StringStyleAnimator;
  exports.StringThemeAnimator = StringThemeAnimator;
  exports.StrokeView = StrokeView;
  exports.StyleAnimator = StyleAnimator;
  exports.StyleConstraintAnimator = StyleConstraintAnimator;
  exports.StyleContext = StyleContext;
  exports.StyleMap = StyleMap;
  exports.StyleRule = StyleRule;
  exports.StyleSheet = StyleSheet;
  exports.StyleValue = StyleValue;
  exports.StyleValueForm = StyleValueForm;
  exports.StyleValueParser = StyleValueParser;
  exports.StyleView = StyleView;
  exports.SvgContext = SvgContext;
  exports.SvgIconView = SvgIconView;
  exports.SvgRenderer = SvgRenderer;
  exports.SvgView = SvgView;
  exports.SvgViewTagFactory = SvgViewTagFactory;
  exports.TableController = TableController;
  exports.TableLayout = TableLayout;
  exports.TableTrait = TableTrait;
  exports.TableView = TableView;
  exports.TextCellController = TextCellController;
  exports.TextCellTrait = TextCellTrait;
  exports.TextCellView = TextCellView;
  exports.TextRun = TextRun;
  exports.TextRunView = TextRunView;
  exports.TextView = TextView;
  exports.Theme = Theme;
  exports.ThemeAnimator = ThemeAnimator;
  exports.ThemeConstraintAnimator = ThemeConstraintAnimator;
  exports.ThemeContext = ThemeContext;
  exports.ThemeMatrix = ThemeMatrix;
  exports.ThemeProvider = ThemeProvider;
  exports.ThemeService = ThemeService;
  exports.TickGenerator = TickGenerator;
  exports.TickView = TickView;
  exports.TimeTickGenerator = TimeTickGenerator;
  exports.TimingLook = TimingLook;
  exports.TitleDeckBar = TitleDeckBar;
  exports.TitleDeckView = TitleDeckView;
  exports.ToAttributeString = ToAttributeString;
  exports.ToCssValue = ToCssValue;
  exports.ToStyleString = ToStyleString;
  exports.TokenView = TokenView;
  exports.TopAxisController = TopAxisController;
  exports.TopAxisTrait = TopAxisTrait;
  exports.TopAxisView = TopAxisView;
  exports.TopTickView = TopTickView;
  exports.TouchMomentumGesture = TouchMomentumGesture;
  exports.TouchPositionGesture = TouchPositionGesture;
  exports.TouchScaleGesture = TouchScaleGesture;
  exports.Trait = Trait;
  exports.TraitControllerRef = TraitControllerRef;
  exports.TraitControllerSet = TraitControllerSet;
  exports.TraitRef = TraitRef;
  exports.TraitRelation = TraitRelation;
  exports.TraitSet = TraitSet;
  exports.TraitViewControllerRef = TraitViewControllerRef;
  exports.TraitViewControllerSet = TraitViewControllerSet;
  exports.TraitViewRef = TraitViewRef;
  exports.TransformAttributeAnimator = TransformAttributeAnimator;
  exports.TransformStyleAnimator = TransformStyleAnimator;
  exports.TransformThemeAnimator = TransformThemeAnimator;
  exports.TypesetView = TypesetView;
  exports.ValueDownlinkTrait = ValueDownlinkTrait;
  exports.VectorIcon = VectorIcon;
  exports.VectorIconInterpolator = VectorIconInterpolator;
  exports.View = View;
  exports.ViewContext = ViewContext;
  exports.ViewRef = ViewRef;
  exports.ViewRelation = ViewRelation;
  exports.ViewSet = ViewSet;
  exports.Viewport = Viewport;
  exports.ViewportProvider = ViewportProvider;
  exports.ViewportService = ViewportService;
  exports.WebGLRenderer = WebGLRenderer;
  exports.WebStorageService = WebStorageService;
  exports.WorldMapView = WorldMapView;
  exports.WorldMapViewport = WorldMapViewport;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
}));
//# sourceMappingURL=swim-toolkit.js.map
