/// <reference types="mapbox-gl" />

import { Animator } from '@swim/runtime';
import { AnyColor } from '@swim/toolkit';
import { AnyDateTime } from '@swim/runtime';
import { AnyExpansion } from '@swim/toolkit';
import { AnyGeoPath } from '@swim/runtime';
import { AnyGeoPoint } from '@swim/runtime';
import { AnyLength } from '@swim/runtime';
import { AnyTiming } from '@swim/runtime';
import { AnyUri } from '@swim/runtime';
import { AnyUriPath } from '@swim/runtime';
import { AnyValue } from '@swim/runtime';
import { AreaPlotController } from '@swim/toolkit';
import { AreaPlotTrait } from '@swim/toolkit';
import { AreaPlotView } from '@swim/toolkit';
import { BubblePlotController } from '@swim/toolkit';
import { BubblePlotTrait } from '@swim/toolkit';
import { BubblePlotView } from '@swim/toolkit';
import { ButtonMembrane } from '@swim/toolkit';
import { CanvasView } from '@swim/toolkit';
import { CellController } from '@swim/toolkit';
import { CellTrait } from '@swim/toolkit';
import { CellView } from '@swim/toolkit';
import { ChartController } from '@swim/toolkit';
import type { ChartControllerObserver } from '@swim/toolkit';
import { ChartTrait } from '@swim/toolkit';
import { ChartView } from '@swim/toolkit';
import { Class } from '@swim/runtime';
import { ColLayout } from '@swim/toolkit';
import { Color } from '@swim/toolkit';
import { ColView } from '@swim/toolkit';
import { ConstraintGroup } from '@swim/runtime';
import { ConstraintProperty } from '@swim/runtime';
import { Controller } from '@swim/toolkit';
import { ControllerContextType } from '@swim/toolkit';
import { ControllerFlags } from '@swim/toolkit';
import { ControllerInit } from '@swim/toolkit';
import type { ControllerObserver } from '@swim/toolkit';
import { ControllerRef } from '@swim/toolkit';
import { ControllerRefFactory } from '@swim/toolkit';
import { ControllerSet } from '@swim/toolkit';
import { DateTime } from '@swim/runtime';
import { Debug } from '@swim/runtime';
import { DeckCard } from '@swim/toolkit';
import { DeckView } from '@swim/toolkit';
import { DialController } from '@swim/toolkit';
import { DialTrait } from '@swim/toolkit';
import { DialView } from '@swim/toolkit';
import { DisclosureCellView } from '@swim/toolkit';
import { DrawerButton } from '@swim/toolkit';
import { DrawerView } from '@swim/toolkit';
import { Equals } from '@swim/runtime';
import { EventDownlinkFastener } from '@swim/runtime';
import { Expansion } from '@swim/toolkit';
import { ExpansionThemeAnimator } from '@swim/toolkit';
import { FilledIcon } from '@swim/toolkit';
import { GaugeController } from '@swim/toolkit';
import { GaugeControllerDialExt } from '@swim/toolkit';
import type { GaugeControllerObserver } from '@swim/toolkit';
import { GaugeTrait } from '@swim/toolkit';
import { GaugeView } from '@swim/toolkit';
import { GeoAreaView } from '@swim/toolkit';
import { GeoGroup } from '@swim/runtime';
import { GeoIconView } from '@swim/toolkit';
import { GeoJson } from '@swim/runtime';
import { GeoJsonFeature } from '@swim/runtime';
import { GeoJsonFeatureCollection } from '@swim/runtime';
import { GeoJsonGeometry } from '@swim/runtime';
import { GeoJsonGeometryCollection } from '@swim/runtime';
import { GeoJsonLineString } from '@swim/runtime';
import { GeoJsonMultiLineString } from '@swim/runtime';
import { GeoJsonMultiPoint } from '@swim/runtime';
import { GeoJsonMultiPolygon } from '@swim/runtime';
import { GeoJsonPoint } from '@swim/runtime';
import { GeoJsonPolygon } from '@swim/runtime';
import { GeoJsonProperties } from '@swim/runtime';
import { GeoLineView } from '@swim/toolkit';
import { GeoPath } from '@swim/runtime';
import { GeoPoint } from '@swim/runtime';
import { GeoShape } from '@swim/runtime';
import { GeoView } from '@swim/toolkit';
import { GeoViewContext } from '@swim/toolkit';
import type { GeoViewObserver } from '@swim/toolkit';
import type { GestureInput } from '@swim/toolkit';
import { GraphControllerPlotExt } from '@swim/toolkit';
import { Graphics } from '@swim/toolkit';
import { GraphicsView } from '@swim/toolkit';
import { HeaderView } from '@swim/toolkit';
import { HistoryProvider } from '@swim/toolkit';
import { HistoryState } from '@swim/toolkit';
import { HtmlIconView } from '@swim/toolkit';
import { HtmlView } from '@swim/toolkit';
import { HtmlViewInit } from '@swim/toolkit';
import type { HtmlViewObserver } from '@swim/toolkit';
import { Icon } from '@swim/toolkit';
import { IconButton } from '@swim/toolkit';
import { IconCellController } from '@swim/toolkit';
import { IconCellTrait } from '@swim/toolkit';
import { IconCellView } from '@swim/toolkit';
import type { Initable } from '@swim/runtime';
import { InputTokenView } from '@swim/toolkit';
import { LeafView } from '@swim/toolkit';
import { Length } from '@swim/toolkit';
import { LinePlotController } from '@swim/toolkit';
import { LinePlotTrait } from '@swim/toolkit';
import { LinePlotView } from '@swim/toolkit';
import { ListDownlinkFastener } from '@swim/toolkit';
import { MapboxView } from '@swim/toolkit';
import { MapDownlinkFastener } from '@swim/toolkit';
import type { MapView } from '@swim/toolkit';
import { MemberFastenerClass } from '@swim/runtime';
import { Model } from '@swim/toolkit';
import { ModelContextType } from '@swim/toolkit';
import { ModelFlags } from '@swim/toolkit';
import type { ModelObserver } from '@swim/toolkit';
import { ModelRef } from '@swim/toolkit';
import { MoodVector } from '@swim/toolkit';
import { Output } from '@swim/runtime';
import { PieController } from '@swim/toolkit';
import type { PieControllerObserver } from '@swim/toolkit';
import { PieControllerSliceExt } from '@swim/toolkit';
import { PieTrait } from '@swim/toolkit';
import { PieView } from '@swim/toolkit';
import { PlotController } from '@swim/toolkit';
import { PlotTrait } from '@swim/toolkit';
import { PlotView } from '@swim/toolkit';
import { PopoverView } from '@swim/toolkit';
import { PositionGesture } from '@swim/toolkit';
import { PositionGestureInput } from '@swim/toolkit';
import { Property } from '@swim/runtime';
import { Provider } from '@swim/runtime';
import { ProviderClass } from '@swim/runtime';
import { RowController } from '@swim/toolkit';
import { RowTrait } from '@swim/toolkit';
import { RowView } from '@swim/toolkit';
import { ScrimView } from '@swim/toolkit';
import { SelectableTrait } from '@swim/toolkit';
import { Service } from '@swim/runtime';
import type { ServiceObserver } from '@swim/runtime';
import { SliceController } from '@swim/toolkit';
import { SliceTrait } from '@swim/toolkit';
import { SliceView } from '@swim/toolkit';
import { TableController } from '@swim/toolkit';
import type { TableControllerObserver } from '@swim/toolkit';
import { TableLayout } from '@swim/toolkit';
import { TableTrait } from '@swim/toolkit';
import { TableView } from '@swim/toolkit';
import { TextCellController } from '@swim/toolkit';
import { TextCellTrait } from '@swim/toolkit';
import { TextCellView } from '@swim/toolkit';
import { ThemeMatrix } from '@swim/toolkit';
import { Timing } from '@swim/runtime';
import { Trait } from '@swim/toolkit';
import { TraitContextType } from '@swim/toolkit';
import { TraitControllerSet } from '@swim/toolkit';
import { TraitModelType } from '@swim/toolkit';
import type { TraitObserver } from '@swim/toolkit';
import { TraitRef } from '@swim/toolkit';
import { TraitSet } from '@swim/toolkit';
import { TraitViewControllerSet } from '@swim/toolkit';
import { TraitViewRef } from '@swim/toolkit';
import { Uri } from '@swim/runtime';
import { UriPath } from '@swim/runtime';
import { Value } from '@swim/runtime';
import { ValueDownlinkFastener } from '@swim/runtime';
import type { View } from '@swim/toolkit';
import { ViewContext } from '@swim/toolkit';
import { ViewContextType } from '@swim/toolkit';
import { ViewportIdiom } from '@swim/toolkit';
import { ViewportInsets } from '@swim/toolkit';
import { ViewportProvider } from '@swim/toolkit';
import { ViewRef } from '@swim/toolkit';
import { ViewSet } from '@swim/toolkit';
import { WorldMapView } from '@swim/toolkit';

/** @public */
export declare abstract class ActivityController extends Controller {
    abstract readonly window: ViewRef<this, HtmlView>;
    abstract readonly entity: TraitRef<this, EntityTrait>;
}

/** @public */
export declare abstract class ActivityPlugin extends PrismPlugin {
    abstract createActivity(entityTrait: EntityTrait): ActivityController | null;
}

/** @public */
export declare class ActivityWindow extends PopoverView {
    constructor(node: HTMLElement);
    protected initWindow(): void;
    protected initTheme(): void;
}

/** @public */
export declare class AgentsEntity extends EntityTrait {
    constructor(uri: Uri);
    protected onAttachModel(model: TraitModelType<this>): void;
    readonly subentities: ModelRef<this, EntityGroup>;
    static readonly subentities: MemberFastenerClass<AgentsEntity, "subentities">;
}

/** @public */
export declare type AnyGeographicArea = GeographicArea | GeographicAreaInit;

/** @public */
export declare type AnyGeographicLine = GeographicLine | GeographicLineInit;

/** @public */
export declare type AnyGeographicPoint = GeographicPoint | GeographicPointInit;

/** @public */
export declare type AnyStatusFactor = StatusFactor | StatusFactorInit;

/** @public */
export declare type AnyStatusVector = StatusVector | StatusVectorArray;

/** @public */
export declare class AtlasController<M extends AtlasMap = AtlasMap> extends MirrorController {
    isFullBleed(): boolean;
    readonly root: ControllerRef<this, AtlasEntityDistrict>;
    readonly layers: ControllerRef<this, AtlasLayers>;
    readonly map: ControllerRef<this, M>;
    readonly surface: ViewRef<this, SurfaceView>;
    readonly toolbar: ViewRef<this, HtmlView>;
    readonly drawer: ViewRef<this, DrawerView>;
    readonly domains: ModelRef<this, DomainGroup>;
}

/** @public */
export declare class AtlasEntityDistrict extends Controller {
    protected onInsertLocation(locationController: AtlasEntityLocation): void;
    readonly layer: ViewRef<this, GeoView>;
    readonly locations: TraitControllerSet<this, EntityTrait, AtlasEntityLocation>;
    readonly entities: ModelRef<this, EntityGroup>;
    protected onUnmount(): void;
}

/** @public */
export declare class AtlasEntityLocation extends Controller {
    protected updateLevelOfDetail(viewContext: GeoViewContext): void;
    protected reviseLevelOfDetail(): void;
    protected onRevise(controllerContext: ControllerContextType<this>): void;
    readonly layer: ViewRef<this, GeoView>;
    readonly geographic: ViewRef<this, GeographicView>;
    readonly subdistrict: ControllerRef<this, AtlasEntityDistrict>;
    readonly entity: TraitRef<this, EntityTrait>;
    readonly selectable: TraitRef<this, SelectableTrait>;
    readonly status: TraitRef<this, StatusTrait>;
    protected applyStatus(newStatusVector: StatusVector, oldStatusVector: StatusVector): void;
    ripple(color: Color, width: number, timing: number): void;
    readonly district: TraitRef<this, DistrictTrait>;
    protected onSetGeographic(geographic: Geographic | null): void;
    readonly location: TraitRef<this, LocationTrait>;
    readonly subentities: ModelRef<this, EntityGroup>;
    protected onUnmount(): void;
}

/** @public */
export declare class AtlasLayers extends Controller {
    get layersIcon(): Graphics;
    protected onPressLayersButton(layersButton: IconButton): void;
    readonly toolbar: ViewRef<this, HtmlView>;
    readonly layersButton: ViewRef<this, IconButton>;
    readonly drawer: ViewRef<this, DrawerView>;
    readonly deck: ViewRef<this, DeckView>;
    readonly card: ViewRef<this, DeckCard>;
    readonly layerList: ViewRef<this, TableView>;
    static get layersListLayout(): TableLayout;
    static get layersIcon(): Graphics;
}

/** @public */
export declare abstract class AtlasMap<V extends MapView = MapView> extends Controller {
    abstract readonly base: ViewRef<this, V>;
    abstract readonly surface: ViewRef<this, SurfaceView>;
}

/** @public */
export declare class AtlasMapbox extends AtlasMap<MapboxView> {
    constructor();
    /** @internal */
    logoControl: HTMLElement | null;
    /** @internal */
    navigationControl: mapboxgl.NavigationControl | null;
    get darkMapStyle(): mapboxgl.Style | string;
    get lightMapStyle(): mapboxgl.Style | string;
    get mapStyle(): mapboxgl.Style | string;
    protected onMapMove(mapCenter: GeoPoint, mapZoom: number, mapView: MapboxView): void;
    protected resizeSurface(surfaceView: SurfaceView, viewContext: ViewContext): void;
    protected layoutSurface(surfaceView: SurfaceView, viewContext: ViewContext): void;
    themeSurface(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean, surfaceView: SurfaceView): void;
    readonly base: ViewRef<this, MapboxView>;
    readonly container: ViewRef<this, HtmlView>;
    readonly surface: ViewRef<this, SurfaceView>;
    protected onMapLoad(event: mapboxgl.MapDataEvent): void;
    readonly historyProvider: HistoryProvider<this>;
    protected updateHistoryState(historyState: HistoryState): void;
}

/** @public */
export declare type AtlasMapType = "equirectangular" | "mapbox";

/** @public */
export declare class AtlasPlugin extends MirrorPlugin {
    constructor(mapType?: AtlasMapType);
    get id(): string;
    get title(): string;
    get icon(): Graphics;
    readonly mapType: AtlasMapType;
    protected createMap(): AtlasMap<any>;
    createController(): MirrorController;
    static get icon(): Graphics;
    static getMapType(mapType?: AtlasMapType): AtlasMapType;
}

/** @public */
export declare class AtlasWorldMap extends AtlasMap<WorldMapView> {
    protected createWorld(): GeoView;
    readonly base: ViewRef<this, WorldMapView>;
    readonly world: ViewRef<this, GeoView>;
    readonly canvas: ViewRef<this, CanvasView>;
    readonly surface: ViewRef<this, SurfaceView>;
}

/** @public */
export declare class BeamView extends HtmlView {
    constructor(node: HTMLElement);
    protected initBeam(): void;
}

/** @public */
export declare class CatalogController extends MirrorController {
    isFullBleed(): boolean;
    protected initTree(treeView: TableView): void;
    readonly root: ControllerRef<this, CatalogEntityTree>;
    readonly surface: ViewRef<this, SurfaceView>;
    readonly toolbar: ViewRef<this, HtmlView>;
    readonly drawer: ViewRef<this, DrawerView>;
    readonly domains: ModelRef<this, DomainGroup>;
}

/** @public */
export declare class CatalogEntityLimb extends Controller {
    protected startConsumingSubentities(): void;
    protected stopConsumingSubentities(): void;
    protected startConsumingIndicators(): void;
    protected stopConsumingIndicators(): void;
    protected onMountLimb(rowView: RowView): void;
    protected onUnmountLimb(rowView: RowView): void;
    protected onExpandLimb(rowView: RowView): void;
    protected onCollapseLimb(rowView: RowView): void;
    readonly row: ViewRef<this, RowView>;
    readonly leaf: ViewRef<this, LeafView>;
    readonly iconCell: ViewRef<this, IconCellView>;
    readonly titleCell: ViewRef<this, TextCellView>;
    protected onInsertIndicatorCell(indicatorCell: CatalogIndicatorCell): void;
    protected onRemoveIndicatorCell(indicatorCell: CatalogIndicatorCell): void;
    static IndicatorFastener: ControllerRefFactory<ControllerRef<any, CatalogIndicatorCell>>;
    readonly disclosureCell: ViewRef<this, DisclosureCellView>;
    readonly subtree: ControllerRef<this, CatalogEntityTree>;
    readonly entity: TraitRef<this, EntityTrait>;
    readonly selectable: TraitRef<this, SelectableTrait>;
    readonly status: TraitRef<this, StatusTrait>;
    protected applyStatus(statusVector: StatusVector): void;
    readonly subentities: ModelRef<this, EntityGroup>;
    protected onInsertIndicator(childIndicator: IndicatorTrait, targetIndicator: IndicatorTrait | null): void;
    protected onRemoveIndicator(childIndicator: IndicatorTrait): void;
    readonly indicators: ModelRef<this, IndicatorGroup>;
}

/** @public */
export declare class CatalogEntityTree extends Controller {
    protected createLayout(indicatorTypes?: ReadonlyArray<IndicatorType>): TableLayout;
    protected createIndicatorRoot(indicatorType: IndicatorType): ColLayout | null;
    protected updateHeader(headerView: HeaderView, indicatorTypes?: ReadonlyArray<IndicatorType>): void;
    protected createNameColView(): ColView | null;
    protected createIndicatorColView(indicatorType: IndicatorType): ColView | null;
    protected onInsertEntity(childEntity: EntityTrait, targetEntity: EntityTrait | null): void;
    protected onRemoveEntity(childEntity: EntityTrait): void;
    protected onInsertBranch(branchController: CatalogEntityLimb): void;
    protected onRemoveBranch(branchController: CatalogEntityLimb): void;
    protected lookupBranch(treeView: TableView, key: unknown): number;
    protected onReconcileEntities(entityGroup: EntityGroup): void;
    readonly tree: ViewRef<this, TableView>;
    static BranchRef: ControllerRefFactory<ControllerRef<any, CatalogEntityLimb>>;
    readonly entities: ModelRef<this, EntityGroup>;
    /** @internal */
    protected bindChildFasteners(child: Controller, target: Controller | null): void;
    /** @internal */
    protected unbindChildFasteners(child: Controller): void;
}

/** @public */
export declare class CatalogIndicatorCell extends Controller {
    /** @internal */
    protected startConsumingIndicator(): void;
    /** @internal */
    protected stopConsumingIndicator(): void;
    readonly cell: ViewRef<this, TextCellView>;
    readonly indicator: TraitRef<this, IndicatorTrait>;
    readonly status: TraitRef<this, StatusTrait>;
    protected applyStatus(statusVector: StatusVector): void;
}

/** @public */
export declare class CatalogPlugin extends MirrorPlugin {
    get id(): string;
    get title(): string;
    get icon(): Graphics;
    createController(): MirrorController;
    static get icon(): Graphics;
}

/** @public */
export declare class ChartGadgetAreaPlotController<X = unknown, Y = unknown> extends AreaPlotController<X, Y> {
    readonly plot: TraitViewRef<this, AreaPlotTrait<X, Y>, AreaPlotView<X, Y>>;
    static readonly plot: MemberFastenerClass<ChartGadgetAreaPlotController, "plot">;
    readonly status: TraitRef<this, StatusTrait>;
    static readonly status: MemberFastenerClass<ChartGadgetAreaPlotController, "status">;
    protected applyStatusVector(statusVector: StatusVector, plotView: AreaPlotView<X, Y>): void;
}

/** @public */
export declare class ChartGadgetBubblePlotController<X = unknown, Y = unknown> extends BubblePlotController<X, Y> {
    readonly plot: TraitViewRef<this, BubblePlotTrait<X, Y>, BubblePlotView<X, Y>>;
    static readonly plot: MemberFastenerClass<ChartGadgetBubblePlotController, "plot">;
    readonly status: TraitRef<this, StatusTrait>;
    static readonly status: MemberFastenerClass<ChartGadgetBubblePlotController, "status">;
    protected applyStatusVector(statusVector: StatusVector, plotView: BubblePlotView<X, Y>): void;
}

/** @public */
export declare class ChartGadgetController<X = unknown, Y = unknown> extends ChartController<X, Y> implements GadgetController {
    readonly observerType?: Class<ChartGadgetControllerObserver<X, Y>>;
    readonly chart: TraitViewRef<this, ChartTrait<X, Y>, ChartView<X, Y>>;
    static readonly chart: MemberFastenerClass<ChartGadgetController, "chart">;
    readonly plots: TraitViewControllerSet<this, PlotTrait<X, Y>, PlotView<X, Y>, PlotController<X, Y>> & GraphControllerPlotExt<X, Y>;
    static readonly plots: MemberFastenerClass<ChartGadgetController, "plots">;
    readonly canvas: ViewRef<this, CanvasView>;
    static readonly canvas: MemberFastenerClass<ChartGadgetController, "canvas">;
    readonly gadget: TraitViewRef<this, Trait, HtmlView>;
    static readonly gadget: MemberFastenerClass<ChartGadgetController, "gadget">;
}

/** @public */
export declare interface ChartGadgetControllerObserver<X = unknown, Y = unknown, C extends ChartGadgetController<X, Y> = ChartGadgetController<X, Y>> extends ChartControllerObserver<X, Y, C>, GadgetControllerObserver<C> {
}

/** @public */
export declare class ChartGadgetLinePlotController<X = unknown, Y = unknown> extends LinePlotController<X, Y> {
    readonly plot: TraitViewRef<this, LinePlotTrait<X, Y>, LinePlotView<X, Y>>;
    static readonly plot: MemberFastenerClass<ChartGadgetLinePlotController, "plot">;
    readonly status: TraitRef<this, StatusTrait>;
    static readonly status: MemberFastenerClass<ChartGadgetLinePlotController, "status">;
    protected applyStatusVector(statusVector: StatusVector, plotView: LinePlotView<X, Y>): void;
}

/** @public */
export declare class CollectionController extends Controller {
    readonly observerType?: Class<CollectionControllerObserver>;
    get domainIcon(): Graphics;
    protected injectEntities(model: Model, domainTrait: DomainTrait): void;
    protected injectEntity(entityTrait: EntityTrait, domainTrait: DomainTrait): void;
    protected activate(): void;
    readonly fullBleed: Property<this, boolean>;
    readonly row: ViewRef<this, RowView>;
    readonly domain: TraitRef<this, DomainTrait>;
    readonly entity: TraitRef<this, EntityTrait>;
    readonly status: TraitRef<this, StatusTrait>;
    protected applyStatus(statusVector: StatusVector): void;
    readonly prismProvider: PrismProvider<this>;
    static get domainIcon(): Graphics;
}

/** @public */
export declare interface CollectionControllerObserver<C extends CollectionController = CollectionController> extends ControllerObserver<C> {
}

/** @public */
export declare class CollectorController extends Controller {
    get searchIcon(): Graphics;
    get plusIcon(): Graphics;
    protected setFullBleed(fullBleed: boolean): void;
    readonly fullBleed: Property<this, boolean>;
    createDomain(query: string): DomainTrait | null;
    readonly search: ViewRef<this, InputTokenView>;
    readonly searchDropdown: ViewRef<this, PopoverView>;
    protected insertSuggestionRow(suggestionController: SuggestionController): void;
    protected removeSuggestionRow(suggestionController: SuggestionController): void;
    readonly suggestionsList: ViewRef<this, TableView>;
    readonly suggestions: TraitControllerSet<this, EntityTrait, SuggestionController>;
    protected insertCollectionRow(collectionController: CollectionController): void;
    protected removeCollectionRow(collectionController: CollectionController): void;
    readonly collections: TraitControllerSet<this, EntityTrait, CollectionController>;
    readonly domainList: ViewRef<this, TableView>;
    readonly domains: ModelRef<this, DomainGroup>;
    readonly prismService: PrismProvider<this>;
    static get searchIcon(): Graphics;
    static get plusIcon(): Graphics;
}

/** @public */
export declare class DiagramController extends MirrorController {
    isFullBleed(): boolean;
    readonly surface: ViewRef<this, SurfaceView>;
    readonly toolbar: ViewRef<this, HtmlView>;
    readonly drawer: ViewRef<this, DrawerView>;
    protected onInsertDomain(childDomain: DomainTrait, targetDomain: DomainTrait | null): void;
    protected onRemoveDomain(childDomain: DomainTrait): void;
    readonly domains: ModelRef<this, DomainGroup>;
}

/** @public */
export declare class DiagramPlugin extends MirrorPlugin {
    get id(): string;
    get title(): string;
    get icon(): Graphics;
    createController(): MirrorController;
    static get icon(): Graphics;
}

/** @public */
export declare class DistrictTrait extends Trait {
    constructor();
    readonly observerType: Class<DistrictTraitObserver>;
    readonly minZoom: number;
    readonly maxZoom: number;
    setZoomRange(minZoom: number, maxZoom: number): void;
    protected willSetZoomRange(minZoom: number, maxZoom: number): void;
    protected onSetZoomRange(minZoom: number, maxZoom: number): void;
    protected didSetZoomRange(minZoom: number, maxZoom: number): void;
    readonly boundary: GeoShape | null;
    setBoundary(newBoundary: GeoShape | null): void;
    protected willSetBoundary(newBoundary: GeoShape | null, oldBoundary: GeoShape | null): void;
    protected onSetBoundary(newBoundary: GeoShape | null, oldBoundary: GeoShape | null): void;
    protected didSetBoundary(newBoundary: GeoShape | null, oldBoundary: GeoShape | null): void;
    readonly subdistricts: ModelRef<this, EntityGroup>;
}

/** @public */
export declare interface DistrictTraitObserver<T extends DistrictTrait = DistrictTrait> extends TraitObserver<T> {
    districtWillSetZoomRange?(minZoom: number, maxZoom: number, trait: T): void;
    districtDidSetZoomRange?(minZoom: number, maxZoom: number, trait: T): void;
    districtWillSetBoundary?(newBoundary: GeoShape | null, oldBoundary: GeoShape | null, trait: T): void;
    districtDidSetBoundary?(newBoundary: GeoShape | null, oldBoundary: GeoShape | null, trait: T): void;
}

/** @public */
export declare class DomainGroup extends EntityGroup {
}

/** @public */
export declare abstract class DomainPlugin extends PrismPlugin {
    abstract createDomain(uri: AnyUri): DomainTrait | null;
    abstract queryDomain(query: string): DomainTrait | null;
}

/** @public */
export declare class DomainTrait extends Trait {
    readonly observerType?: Class<DomainTraitObserver>;
    injectEntity(entityTrait: EntityTrait): void;
    protected willInjectEntity(entityTrait: EntityTrait): void;
    protected onInjectEntity(entityTrait: EntityTrait): void;
    protected didInjectEntity(entityTrait: EntityTrait): void;
}

/** @public */
export declare interface DomainTraitObserver<T extends DomainTrait = DomainTrait> extends TraitObserver<T> {
    domainWillInjectEntity?(entityTrait: EntityTrait, model: T): void;
    domainDidInjectEntity?(entityTrait: EntityTrait, model: T): void;
}

/** @public */
export declare class DownlinkDistrictTrait extends DistrictTrait {
    protected downlinkDidSet(newValue: Value, oldValue: Value): void;
    readonly downlink: ValueDownlinkFastener<this, Value, AnyValue>;
}

/** @public */
export declare class DownlinkLocationTrait extends LocationTrait {
    protected downlinkDidSet(value: Value, oldValue: Value): void;
    readonly downlink: ValueDownlinkFastener<this, Value, AnyValue>;
}

/** @public */
export declare class DownlinkNodeGroup extends NodeGroup {
    constructor(metaHostUri?: Uri);
    protected getNodePath(key: Value, value: Value): string;
    protected updateNodeModel(nodeModel: Model, value: Value): void;
    protected didUpdateNode(key: Value, value: Value): void;
    protected didRemoveNode(key: Value, value: Value): void;
    readonly downlink: MapDownlinkFastener<this, Value, Value, AnyValue, AnyValue>;
}

/** @public */
export declare class EntityGroup extends IndicatedGroup {
    constructor();
    /** @internal */
    readonly sorted: boolean;
    isSorted(): boolean;
    isSorted(isSorted: boolean): this;
    /** @internal */
    protected aggregateStatus(statusVector: StatusVector): void;
    protected onStopConsuming(): void;
}

/** @public */
export declare abstract class EntityPlugin extends PrismPlugin {
    abstract injectEntity(entityTrait: EntityTrait, domainTrait: DomainTrait): void;
}

/** @public */
export declare class EntityTrait extends Trait {
    constructor(uri: Uri);
    readonly observerType?: Class<EntityTraitObserver>;
    readonly uri: Uri;
    readonly title: Property<this, string | undefined>;
    readonly icon: Property<this, Graphics | null>;
    /** @internal */
    protected aggregateStatus(statusFactors: {
        [statusName: string]: StatusFactor | undefined;
    }): void;
    /** @internal */
    protected aggregateIndicatorsStatus(indicatorGroup: IndicatorGroup, statusVector: StatusVector, statusFactors: {
        [statusName: string]: StatusFactor | undefined;
    }): void;
    /** @internal */
    protected aggregateSubentitiesStatus(entityGroup: EntityGroup, statusVector: StatusVector, statusFactors: {
        [statusName: string]: StatusFactor | undefined;
    }): void;
    protected aggregatedChildModelStatus(child: Model, statusFactors: {
        [statusName: string]: StatusFactor | undefined;
    }): void;
    /** @protected */
    analyzeChildren(analyzeFlags: ModelFlags, modelContext: TraitContextType<this>, analyzeChildModel: (this: TraitModelType<this>, child: Model, analyzeFlags: ModelFlags, modelContext: TraitContextType<this>) => void, analyzeChildren: (this: TraitModelType<this>, analyzeFlags: ModelFlags, modelContext: TraitContextType<this>, analyzeChildModel: (this: TraitModelType<this>, child: Model, analyzeFlags: ModelFlags, modelContext: TraitContextType<this>) => void) => void): void;
    protected aggregateChildStatuses(analyzeFlags: ModelFlags, modelContext: TraitContextType<this>, analyzeChildModel: (this: TraitModelType<this>, child: Model, analyzeFlags: ModelFlags, modelContext: TraitContextType<this>) => void, analyzeChildren: (this: TraitModelType<this>, analyzeFlags: ModelFlags, modelContext: TraitContextType<this>, analyzeChildModel: (this: TraitModelType<this>, child: Model, analyzeFlags: ModelFlags, modelContext: TraitContextType<this>) => void) => void): void;
    readonly subentities: ModelRef<this, EntityGroup>;
    static readonly subentities: MemberFastenerClass<EntityTrait, "subentities">;
    protected onMount(): void;
}

/** @public */
export declare interface EntityTraitObserver<T extends EntityTrait = EntityTrait> extends TraitObserver<T> {
    entityWillSetTitle?(title: string | undefined, trait: T): void;
    entityDidSetTitle?(title: string | undefined, trait: T): void;
    entityWillSetIcon?(icon: Graphics | null, trait: T): void;
    entityDidSetIcon?(icon: Graphics | null, trait: T): void;
}

/** @public */
export declare class EventLaneModel extends LaneModel {
    readonly data: EventDownlinkFastener<this>;
}

/** @public */
export declare class FabricEntity extends EntityTrait {
    constructor(uri: Uri);
    protected onAttachModel(model: TraitModelType<this>): void;
    readonly subentities: ModelRef<this, EntityGroup>;
    static readonly subentities: MemberFastenerClass<FabricEntity, "subentities">;
}

/** @public */
export declare class FabricGroup extends EntityGroup {
    constructor();
    protected initGroup(): void;
    readonly mesh: ModelRef<this, Model>;
    readonly edge: ModelRef<this, Model>;
}

/** @public */
export declare class FabricPlugin extends DomainPlugin {
    get id(): string;
    get title(): string;
    createDomain(hostUri: AnyUri): DomainTrait | null;
    queryDomain(query: string): DomainTrait | null;
}

/** @public */
export declare interface GadgetController extends Controller {
    readonly observerType?: Class<GadgetControllerObserver>;
    readonly gadget: TraitViewRef<this, Trait, HtmlView>;
}

/** @public */
export declare interface GadgetControllerObserver<C extends GadgetController = GadgetController> extends ControllerObserver<C> {
    controllerWillAttachGadgetTrait?(gadgetTrait: Trait, controller: C): void;
    controllerDidDetachGadgetTrait?(gadgetTrait: Trait, controller: C): void;
    controllerWillAttachGadgetView?(gadgetView: HtmlView, controller: C): void;
    controllerDidDetachGadgetView?(gadgetView: HtmlView, controller: C): void;
}

/** @public */
export declare abstract class GadgetPlugin extends PrismPlugin {
    abstract createGadget(gadgetTrait: Trait): GadgetController | null;
    abstract detectGadgetModel(model: Model): Trait | null;
    abstract detectGadgetController(controller: Controller): GadgetController | null;
}

/** @public */
export declare class GaugeGadgetController extends GaugeController implements GadgetController {
    readonly observerType?: Class<GaugeGadgetControllerObserver>;
    protected layoutGauge(hasLegend?: boolean): void;
    readonly gauge: TraitViewRef<this, GaugeTrait, GaugeView>;
    static readonly gauge: MemberFastenerClass<GaugeGadgetController, "gauge">;
    readonly title: ViewRef<this, GraphicsView>;
    static readonly title: MemberFastenerClass<GaugeController, "title">;
    readonly dials: TraitViewControllerSet<this, DialTrait, DialView, DialController> & GaugeControllerDialExt;
    static readonly dials: MemberFastenerClass<GaugeGadgetController, "dials">;
    readonly canvas: ViewRef<this, CanvasView>;
    static readonly canvas: MemberFastenerClass<GaugeGadgetController, "canvas">;
    readonly gadget: TraitViewRef<this, Trait, HtmlView>;
    static readonly gadget: MemberFastenerClass<GaugeGadgetController, "gadget">;
}

/** @public */
export declare interface GaugeGadgetControllerObserver<C extends GaugeGadgetController = GaugeGadgetController> extends GaugeControllerObserver<C>, GadgetControllerObserver<C> {
}

/** @public */
export declare class GaugeGadgetDialController extends DialController {
    readonly dial: TraitViewRef<this, DialTrait, DialView>;
    static readonly dial: MemberFastenerClass<GaugeGadgetDialController, "dial">;
    readonly label: ViewRef<this, GraphicsView>;
    static readonly label: MemberFastenerClass<GaugeGadgetDialController, "label">;
    readonly legend: ViewRef<this, GraphicsView>;
    static readonly legend: MemberFastenerClass<GaugeGadgetDialController, "legend">;
    readonly status: TraitRef<this, StatusTrait>;
    static readonly status: MemberFastenerClass<GaugeGadgetDialController, "status">;
    protected applyStatusVector(statusVector: StatusVector, dialView: DialView): void;
}

/** @public */
export declare abstract class Geographic implements Equals {
    abstract readonly geometry: GeoShape;
    abstract equals(that: unknown): boolean;
    static fromGeoJson(object: GeoJson): Geographic | null;
    static fromGeoJsonGeometry(object: GeoJsonGeometry, properties?: GeoJsonProperties): Geographic;
    /** @internal */
    static fromGeoJsonPoint(object: GeoJsonPoint, properties?: GeoJsonProperties): GeographicPoint;
    /** @internal */
    static fromGeoJsonMultiPoint(object: GeoJsonMultiPoint, properties?: GeoJsonProperties): GeographicGroup<GeographicPoint>;
    /** @internal */
    static fromGeoJsonLineString(object: GeoJsonLineString, properties?: GeoJsonProperties): GeographicLine;
    /** @internal */
    static fromGeoJsonMultiLineString(object: GeoJsonMultiLineString, properties?: GeoJsonProperties): GeographicGroup<GeographicLine>;
    /** @internal */
    static fromGeoJsonPolygon(object: GeoJsonPolygon, properties?: GeoJsonProperties): GeographicArea;
    /** @internal */
    static fromGeoJsonMultiPolygon(object: GeoJsonMultiPolygon, properties?: GeoJsonProperties): GeographicGroup<GeographicArea>;
    /** @internal */
    static fromGeoJsonGeometryCollection(object: GeoJsonGeometryCollection, properties?: GeoJsonProperties): GeographicGroup;
    /** @internal */
    static fromGeoJsonFeature(object: GeoJsonFeature): Geographic | null;
    /** @internal */
    static fromGeoJsonFeatureCollection(object: GeoJsonFeatureCollection): GeographicGroup;
}

/** @public */
export declare class GeographicArea extends Geographic {
    constructor(geometry: GeoPath, fill: Color | null, stroke: Color | null, strokeWidth: Length | null);
    readonly geometry: GeoPath;
    readonly fill: Color | null;
    readonly stroke: Color | null;
    readonly strokeWidth: Length | null;
    equals(that: unknown): boolean;
    static fromInit(init: GeographicAreaInit): GeographicArea;
    static fromAny(value: AnyGeographicArea): GeographicArea;
}

/** @public */
export declare interface GeographicAreaInit {
    geometry: AnyGeoPath;
    fill?: AnyColor | null;
    stroke?: AnyColor | null;
    strokeWidth?: AnyLength | null;
}

/** @public */
export declare class GeographicAreaView extends GeoAreaView implements GeographicView {
    readonly observerType?: Class<GeographicViewObserver<GeographicAreaView>>;
    readonly highlighted: Property<this, boolean>;
    highlight(timing?: AnyTiming | boolean): void;
    protected willHighlight(timing: Timing | boolean): void;
    protected onHighlight(timing: Timing | boolean): void;
    protected didHighlight(timing: Timing | boolean): void;
    unhighlight(timing?: AnyTiming | boolean): void;
    protected willUnhighlight(timing: Timing | boolean): void;
    protected onUnhighlight(timing: Timing | boolean): void;
    protected didUnhighlight(timing: Timing | boolean): void;
    setState(geographic: Geographic, timing?: AnyTiming | boolean): void;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    readonly gesture: PositionGesture<GeographicAreaView, GeographicAreaView>;
    static fromGeographic(geographic: GeographicArea): GeographicAreaView;
    /** @internal */
    static FillOpacity: number;
    /** @internal */
    static StrokeOpacity: number;
    /** @internal */
    static HighlightedFillOpacity: number;
    /** @internal */
    static HighlightedStrokeOpacity: number;
}

/** @public */
export declare class GeographicGroup<G extends Geographic = Geographic> extends Geographic {
    constructor(geographics: ReadonlyArray<G>, geometry?: GeoGroup | null);
    readonly geographics: ReadonlyArray<G>;
    /** @internal */
    readonly geometries: GeoGroup | null;
    get geometry(): GeoGroup;
    equals(that: unknown): boolean;
}

/** @public */
export declare class GeographicGroupView extends GeoView implements GeographicView {
    readonly observerType?: Class<GeographicViewObserver<GeographicGroupView>>;
    readonly highlighted: Property<this, boolean>;
    highlight(timing?: AnyTiming | boolean): void;
    protected willHighlight(timing: Timing | boolean): void;
    protected onHighlight(timing: Timing | boolean): void;
    protected didHighlight(timing: Timing | boolean): void;
    protected highlightChildren(timing: Timing | boolean): void;
    unhighlight(timing?: AnyTiming | boolean): void;
    protected willUnhighlight(timing: Timing | boolean): void;
    protected onUnhighlight(timing: Timing | boolean): void;
    protected didUnhighlight(timing: Timing | boolean): void;
    protected unhighlightChildren(timing: Timing | boolean): void;
    setState(geographic: Geographic, timing?: AnyTiming | boolean): void;
    readonly gesture: PositionGesture<GeographicGroupView, GeographicGroupView>;
    static fromGeographic(geographic: GeographicGroup): GeographicGroupView;
}

/** @public */
export declare class GeographicLine extends Geographic {
    constructor(geometry: GeoPath, stroke: Color | null, strokeWidth: Length | null);
    readonly geometry: GeoPath;
    readonly stroke: Color | null;
    readonly strokeWidth: Length | null;
    equals(that: unknown): boolean;
    static fromInit(init: GeographicLineInit): GeographicLine;
    static fromAny(value: AnyGeographicLine): GeographicLine;
}

/** @public */
export declare interface GeographicLineInit {
    geometry: AnyGeoPath;
    stroke?: AnyColor | null;
    strokeWidth?: AnyLength | null;
}

/** @public */
export declare class GeographicLineView extends GeoLineView implements GeographicView {
    readonly observerType?: Class<GeographicViewObserver<GeographicLineView>>;
    readonly highlighted: Property<this, boolean>;
    highlight(timing?: AnyTiming | boolean): void;
    protected willHighlight(timing: Timing | boolean): void;
    protected onHighlight(timing: Timing | boolean): void;
    protected didHighlight(timing: Timing | boolean): void;
    unhighlight(timing?: AnyTiming | boolean): void;
    protected willUnhighlight(timing: Timing | boolean): void;
    protected onUnhighlight(timing: Timing | boolean): void;
    protected didUnhighlight(timing: Timing | boolean): void;
    setState(geographic: Geographic, timing?: AnyTiming | boolean): void;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    readonly gesture: PositionGesture<GeographicLineView, GeographicLineView>;
    static fromGeographic(geographic: GeographicLine): GeographicLineView;
    /** @internal */
    static StrokeOpacity: number;
    /** @internal */
    static HighlightedStrokeOpacity: number;
}

/** @public */
export declare class GeographicPoint extends Geographic {
    constructor(geometry: GeoPoint, width: Length | null, height: Length | null, graphics: Graphics | null, fill: Color | null);
    readonly geometry: GeoPoint;
    readonly width: Length | null;
    readonly height: Length | null;
    readonly graphics: Graphics | null;
    readonly fill: Color | null;
    equals(that: unknown): boolean;
    static fromInit(init: GeographicPointInit): GeographicPoint;
    static fromAny(value: AnyGeographicPoint): GeographicPoint;
}

/** @public */
export declare interface GeographicPointInit {
    geometry: AnyGeoPoint;
    width?: AnyLength | null;
    height?: AnyLength | null;
    graphics?: Graphics | null;
    fill?: AnyColor | null;
}

/** @public */
export declare class GeographicPointView extends GeoIconView implements GeographicView {
    readonly observerType?: Class<GeographicViewObserver<GeographicPointView>>;
    get icon(): Icon | null;
    setIcon(inner: Graphics | null): void;
    protected createOuterIcon(): FilledIcon;
    protected createIcon(inner: Icon | null): Icon;
    readonly width: Animator<this, Length | null, AnyLength | null>;
    readonly height: Animator<this, Length | null, AnyLength | null>;
    readonly highlighted: Property<this, boolean>;
    highlight(timing?: AnyTiming | boolean): void;
    protected willHighlight(timing: Timing | boolean): void;
    protected onHighlight(timing: Timing | boolean): void;
    protected didHighlight(timing: Timing | boolean): void;
    unhighlight(timing?: AnyTiming | boolean): void;
    protected willUnhighlight(timing: Timing | boolean): void;
    protected onUnhighlight(timing: Timing | boolean): void;
    protected didUnhighlight(timing: Timing | boolean): void;
    setState(geographic: Geographic, timing?: AnyTiming | boolean): void;
    readonly gesture: PositionGesture<GeographicPointView, GeographicPointView>;
    /** @internal */
    static SelectionScale: number;
    static fromGeographic(geographic: GeographicPoint): GeographicPointView;
}

/** @public */
export declare interface GeographicView extends GeoView {
    readonly observerType?: Class<GeographicViewObserver>;
    highlight(timing?: AnyTiming | boolean): void;
    unhighlight(timing?: AnyTiming | boolean): void;
    setState(geographic: Geographic, timing?: AnyTiming | boolean): void;
}

/** @public */
export declare const GeographicView: {
    fromGeographic(geographic: Geographic): GeographicView;
    is(object: unknown): object is GeographicView;
};

/** @public */
export declare interface GeographicViewObserver<V extends GeographicView = GeographicView> extends GeoViewObserver<V> {
    geographicDidPress?(input: GestureInput, event: Event | null, view: V): void;
    geographicDidLongPress?(input: GestureInput, view: V): void;
    geographicWillHighlight?(timing: AnyTiming | boolean, view: V): void;
    geographicDidHighlight?(timing: AnyTiming | boolean, view: V): void;
    geographicWillUnhighlight?(timing: AnyTiming | boolean, view: V): void;
    geographicDidUnhighlight?(timing: AnyTiming | boolean, view: V): void;
}

/** @public */
export declare class IndicatedGroup extends StatusGroup {
    constructor();
    readonly indicatorMap: IndicatorMap;
    /** @internal */
    protected setIndicatorMap(indicatorMap: IndicatorMap): void;
    protected needsUpdate(updateFlags: ModelFlags, immediate: boolean): ModelFlags;
    protected needsRefresh(refreshFlags: ModelFlags, modelContext: ModelContextType<this>): ModelFlags;
    protected refreshChildren(refreshFlags: ModelFlags, modelContext: ModelContextType<this>, refreshChild: (this: this, child: Model, refreshFlags: ModelFlags, modelContext: ModelContextType<this>) => void): void;
    protected reconcileChildIndicatorMaps(refreshFlags: ModelFlags, modelContext: ModelContextType<this>, refreshChild: (this: this, child: Model, refreshFlags: ModelFlags, modelContext: ModelContextType<this>) => void): void;
    static MountFlags: ModelFlags;
    static InsertChildFlags: ModelFlags;
    static RemoveChildFlags: ModelFlags;
}

/** @public */
export declare class IndicatedTrait extends Trait {
    get indicatorMap(): IndicatorMap;
    readonly indicators: ModelRef<this, IndicatorGroup>;
    static readonly indicators: MemberFastenerClass<IndicatedTrait, "indicators">;
    /** @protected */
    needsUpdate(updateFlags: ModelFlags, immediate: boolean): ModelFlags;
    /** @protected */
    needsAnalyze(analyzeFlags: ModelFlags, modelContext: TraitContextType<this>): ModelFlags;
    /** @protected */
    needsRefresh(refreshFlags: ModelFlags, modelContext: TraitContextType<this>): ModelFlags;
    static MountFlags: ModelFlags;
}

/** @public */
export declare class IndicatorGroup extends StatusGroup {
    constructor();
    readonly indicatorMap: IndicatorMap;
    /** @internal */
    protected setIndicatorMap(indicatorMap: IndicatorMap): void;
    /** @internal */
    protected aggregateStatus(statusVector: StatusVector): void;
    protected needsUpdate(updateFlags: ModelFlags, immediate: boolean): ModelFlags;
    protected needsRefresh(refreshFlags: ModelFlags, modelContext: ModelContextType<this>): ModelFlags;
    protected refreshChildren(refreshFlags: ModelFlags, modelContext: ModelContextType<this>, refreshChild: (this: this, child: Model, refreshFlags: ModelFlags, modelContext: ModelContextType<this>) => void): void;
    protected reconcileChildIndicatorTypes(refreshFlags: ModelFlags, modelContext: ModelContextType<this>, refreshChild: (this: this, child: Model, refreshFlags: ModelFlags, modelContext: ModelContextType<this>) => void): void;
    static MountFlags: ModelFlags;
    static InsertChildFlags: ModelFlags;
    static RemoveChildFlags: ModelFlags;
}

/** @public */
export declare class IndicatorMap {
    constructor(indicatorTypeMap: {
        readonly [key: string]: IndicatorType | undefined;
    }, indicatorTypeArray?: ReadonlyArray<IndicatorType> | null);
    /** @internal */
    readonly indicatorTypeMap: {
        readonly [key: string]: IndicatorType | undefined;
    };
    get size(): number;
    has(key: string): boolean;
    get(key: string): IndicatorType | null;
    updated(newIndicatorType: IndicatorType): IndicatorMap;
    merged(that: IndicatorMap): IndicatorMap;
    /** @internal */
    readonly indicatorTypeArray: ReadonlyArray<IndicatorType> | null;
    get indicatorTypes(): ReadonlyArray<IndicatorType>;
    protected arrangedIndicatorTypes(): ReadonlyArray<IndicatorType>;
    static empty(): IndicatorMap;
}

/** @public */
export declare class IndicatorTrait extends Trait {
    constructor(indicatorType: IndicatorType);
    readonly observerType?: Class<IndicatorTraitObserver>;
    readonly indicatorType: IndicatorType;
}

/** @public */
export declare interface IndicatorTraitObserver<T extends IndicatorTrait = IndicatorTrait> extends TraitObserver<T> {
}

/** @public */
export declare class IndicatorType {
    constructor(key: string, name: string);
    readonly key: string;
    readonly name: string;
}

/** @public */
export declare class InventoryController extends ActivityController {
    constructor();
    /** @internal */
    readonly selectedItem: LaneController | null;
    readonly root: ViewRef<this, InventoryView>;
    protected createMasterLayout(): TableLayout;
    protected updateMasterHeader(headerView: HeaderView): void;
    readonly masterTree: ViewRef<this, TableView>;
    readonly detail: ViewRef<this, HtmlView>;
    readonly closeButton: ViewRef<this, IconButton>;
    protected onInsertItem(item: LaneController): void;
    protected onRemoveItem(item: LaneController): void;
    protected selectItem(newItem: LaneController): void;
    static ItemRef: ControllerRefFactory<ControllerRef<any, LaneController>>;
    readonly window: ViewRef<this, HtmlView>;
    readonly entity: TraitRef<this, EntityTrait>;
    protected onInsertLane(childEntity: LaneModel, targetEntity: LaneModel | null): void;
    protected onRemoveLane(childEntity: LaneModel): void;
    readonly manifest: ModelRef<this, ManifestModel>;
    static get closeIcon(): Graphics;
}

/** @public */
export declare class InventoryPlugin extends ActivityPlugin {
    get id(): string;
    get title(): string;
    createActivity(entityTrait: EntityTrait): ActivityController | null;
}

/** @public */
export declare class InventoryView extends HtmlView {
    constructor(node: HTMLElement);
    protected initInventory(): void;
    /** @internal */
    readonly masterLayout: ConstraintGroup;
    protected initMasterLayout(layout: ConstraintGroup): void;
    /** @internal */
    readonly mobileLayout: ConstraintGroup;
    protected initMobileLayout(layout: ConstraintGroup): void;
    /** @internal */
    readonly desktopLayout: ConstraintGroup;
    protected initDesktopLayout(layout: ConstraintGroup): void;
    readonly barHeight: ConstraintProperty<this, number>;
    readonly masterWidth: ConstraintProperty<this, number>;
    readonly masterBar: ViewRef<this, HtmlView>;
    readonly masterPane: ViewRef<this, HtmlView>;
    readonly masterTree: ViewRef<this, TableView>;
    readonly detail: ViewRef<this, HtmlView>;
    protected onMasterPaneScroll(event: Event): void;
    static BarHeight: number;
    static MasterWidth: number;
}

/** @public */
export declare class LaneController extends Controller {
    readonly observerType?: Class<LaneControllerObserver>;
    select(): void;
    unselect(): void;
    readonly row: ViewRef<this, RowView>;
    readonly leaf: ViewRef<this, LeafView>;
    readonly iconCell: ViewRef<this, IconCellView>;
    readonly nameCell: ViewRef<this, TextCellView>;
    readonly kindCell: ViewRef<this, TextCellView>;
    readonly detail: ViewRef<this, HtmlView>;
    readonly lane: ModelRef<this, LaneModel>;
}

/** @public */
export declare interface LaneControllerObserver<C extends LaneController = LaneController> extends ControllerObserver<C> {
    controllerDidActivateLane?(laneController: C): void;
}

/** @public */
export declare abstract class LaneModel extends Model {
    /** @internal */
    ownNodeUri: Uri;
    /** @internal */
    ownLaneUri: Uri;
    /** @internal */
    info: Value;
    constructor(nodeUri: Uri, laneUri: Uri, info: Value);
    readonly observerType?: Class<LaneModelObserver>;
    setInfo(info: Value): void;
    protected onEvent(value: Value): void;
}

/** @public */
export declare interface LaneModelObserver<M extends LaneModel = LaneModel> extends ModelObserver<M> {
    onLaneEvent?(value: Value, model: M): void;
}

/** @public */
export declare class ListLaneModel extends LaneModel {
    readonly data: ListDownlinkFastener<this>;
}

/** @public */
export declare class LocationTrait extends Trait {
    constructor();
    readonly observerType: Class<LocationTraitObserver>;
    readonly minZoom: number;
    readonly maxZoom: number;
    setZoomRange(minZoom: number, maxZoom: number): void;
    protected willSetZoomRange(minZoom: number, maxZoom: number): void;
    protected onSetZoomRange(minZoom: number, maxZoom: number): void;
    protected didSetZoomRange(minZoom: number, maxZoom: number): void;
    readonly geographic: Geographic | null;
    setGeographic(newGeographic: Geographic | null): void;
    protected willSetGeographic(newGeographic: Geographic | null, oldGeographic: Geographic | null): void;
    protected onSetGeographic(newGeographic: Geographic | null, oldGeographic: Geographic | null): void;
    protected didSetGeographic(newGeographic: Geographic | null, oldGeographic: Geographic | null): void;
}

/** @public */
export declare interface LocationTraitObserver<T extends LocationTrait = LocationTrait> extends TraitObserver<T> {
    locationWillSetZoomRange?(minZoom: number, maxZoom: number, trait: T): void;
    locationDidSetZoomRange?(minZoom: number, maxZoom: number, trait: T): void;
    locationWillSetGeographic?(newGeographic: Geographic | null, oldGeographic: Geographic | null, trait: T): void;
    locationDidSetGeographic?(newGeographic: Geographic | null, oldGeographic: Geographic | null, trait: T): void;
}

/** @public */
export declare class MagnifierController extends Controller {
    constructor();
    readonly panel: ViewRef<this, DrawerView>;
    readonly handle: ViewRef<this, MagnifierHandle>;
    readonly fixtures: ViewRef<this, HtmlView>;
    readonly refractor: ControllerRef<this, RefractorController>;
    readonly entity: TraitRef<this, EntityTrait>;
    readonly status: TraitRef<this, StatusTrait>;
    protected applyStatus(statusVector: StatusVector): void;
    readonly session: ModelRef<this, SessionModel>;
    protected onClickCollapse(event: MouseEvent): void;
    static get collapseIcon(): Graphics;
}

/** @public */
export declare class MagnifierHandle extends ButtonMembrane {
    constructor(node: HTMLElement);
    protected initHandle(): void;
    readonly observerType?: Class<MagnifierHandleObserver>;
    readonly collapsedWidth: Animator<this, Length | undefined, AnyLength | undefined>;
    readonly stretch: ExpansionThemeAnimator<this, Expansion, AnyExpansion>;
    readonly icon: ViewRef<this, HtmlView & Initable<HtmlViewInit | Graphics>>;
    readonly label: ViewRef<this, HtmlView & Initable<HtmlViewInit | string | undefined>>;
    readonly accessory: ViewRef<this, HtmlView & Initable<HtmlViewInit | Graphics>>;
    protected onMount(): void;
    protected onUnmount(): void;
    protected onAnimate(viewContext: ViewContextType<this>): void;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected glow(input: PositionGestureInput): void;
    protected onClick(event: MouseEvent): void;
}

/** @public */
export declare interface MagnifierHandleObserver<V extends MagnifierHandle = MagnifierHandle> extends HtmlViewObserver<V> {
    viewDidPressMagnifierHandle?(view: V): void;
}

/** @public */
export declare class ManifestModel extends Model {
    /** @internal */
    metaNodeUri: Uri;
    /** @internal */
    ownNodeUri: Uri;
    constructor(metaNodeUri: Uri);
    readonly observerType?: Class<ManifestModelObserver>;
    protected createLaneModel(nodeUri: Uri, laneUri: Uri, info: Value): LaneModel;
    protected didUpdateLane(laneUri: Uri, newInfo: Value, oldInfo: Value): void;
    protected didRemoveLane(laneUri: Uri, oldInfo: Value): void;
    readonly lanes: MapDownlinkFastener<this, Uri, Value, AnyUri, AnyValue>;
    protected onMount(): void;
    protected onUnmount(): void;
}

/** @public */
export declare interface ManifestModelObserver<M extends ManifestModel = ManifestModel> extends ModelObserver<M> {
    manifestDidUpdateLane?(laneUri: Uri, newInfo: Value, oldInfo: Value, model: M): void;
    manifestDidRemoveLane?(laneUri: Uri, oldInfo: Value, model: M): void;
}

/** @public */
export declare class MapLaneModel extends LaneModel {
    readonly data: MapDownlinkFastener<this>;
}

/** @public */
export declare class MetaEdgeEntity extends EntityTrait {
    constructor(uri: Uri);
    protected onAttachModel(model: TraitModelType<this>): void;
    readonly subentities: ModelRef<this, EntityGroup>;
    static readonly subentities: MemberFastenerClass<MetaEdgeEntity, "subentities">;
}

/** @public */
export declare class MetaHostEntity extends EntityTrait {
    constructor(uri: Uri);
    protected onAttachModel(model: TraitModelType<this>): void;
    readonly subentities: ModelRef<this, EntityGroup>;
    static readonly subentities: MemberFastenerClass<MetaHostEntity, "subentities">;
}

/** @public */
export declare class MetaHostGroup extends EntityGroup {
    constructor(metaPartUri: Uri);
    readonly metaPartUri: Uri;
    protected createHost(hostKey: string, metaHostUri: Uri): Model | null;
    protected didUpdateHost(key: Value, value: Value): void;
    protected didRemoveHost(key: Value): void;
    readonly hosts: MapDownlinkFastener<this, Value, Value, AnyValue, AnyValue>;
}

/** @public */
export declare class MetaMeshEntity extends EntityTrait {
    constructor(uri: Uri);
    protected onAttachModel(model: TraitModelType<this>): void;
    readonly subentities: ModelRef<this, EntityGroup>;
    static readonly subentities: MemberFastenerClass<MetaMeshEntity, "subentities">;
}

/** @public */
export declare class MetaMeshGroup extends EntityGroup {
    constructor(metaEdgeUri: Uri);
    readonly metaEdgeUri: Uri;
    protected createMesh(meshKey: string, metaMeshUri: Uri): Model | null;
    protected didUpdateMesh(key: Value, value: Value): void;
    protected didRemoveMesh(key: Value): void;
    readonly meshes: MapDownlinkFastener<this, Value, Value, AnyValue, AnyValue>;
}

/** @public */
export declare class MetaNodeEntity extends EntityTrait {
    constructor(nodeUri: Uri, metaNodeUri: Uri, metaHostUri: Uri);
    get nodeUri(): Uri;
    get nodePath(): UriPath;
    readonly metaNodeUri: Uri;
    readonly metaHostUri: Uri;
    readonly subentities: ModelRef<this, EntityGroup>;
    static readonly subentities: MemberFastenerClass<MetaNodeEntity, "subentities">;
}

/** @public */
export declare class MetaNodeGroup extends EntityGroup {
    constructor(nodeUri: Uri, metaHostUri: Uri);
    readonly nodeUri: Uri;
    get nodePath(): UriPath;
    readonly metaHostUri: Uri;
    protected createNode(nodeKey: string, nodeUri: Uri, metaNodeUri: Uri): Model | null;
    protected didUpdateNode(key: Value, value: Value): void;
    protected didRemoveNode(key: Value): void;
    readonly nodes: MapDownlinkFastener<this, Value, Value, AnyValue, AnyValue>;
}

/** @public */
export declare class MetaPartEntity extends EntityTrait {
    constructor(uri: Uri);
    protected onAttachModel(model: TraitModelType<this>): void;
    readonly subentities: ModelRef<this, EntityGroup>;
    static readonly subentities: MemberFastenerClass<MetaPartEntity, "subentities">;
}

/** @public */
export declare class MetaPartGroup extends EntityGroup {
    constructor(metaMeshUri: Uri);
    readonly metaMeshUri: Uri;
    protected createPart(partKey: string, metaPartUri: Uri): Model | null;
    protected didUpdatePart(key: Value, value: Value): void;
    protected didRemovePart(key: Value): void;
    readonly parts: MapDownlinkFastener<this, Value, Value, AnyValue, AnyValue>;
}

/** @public */
export declare abstract class MirrorController extends Controller {
    abstract isFullBleed(): boolean;
    abstract readonly surface: ViewRef<this, SurfaceView>;
    abstract readonly toolbar: ViewRef<this, HtmlView>;
    abstract readonly drawer: ViewRef<this, DrawerView>;
    abstract readonly domains: ModelRef<this, DomainGroup>;
}

/** @public */
export declare abstract class MirrorPlugin extends PrismPlugin {
    abstract readonly icon: Graphics | null;
    abstract createController(): MirrorController;
}

/** @public */
export declare class NodeGroup extends EntityGroup {
    constructor(metaHostUri?: Uri);
    readonly metaHostUri: Uri;
    protected initNodeModel(nodeModel: Model): void;
    protected createNodeModel(nodePath: AnyUriPath, nodeUri?: Uri, metaNodeUri?: Uri): Model;
    protected initNodeTraits(nodeModel: Model, nodeUri: Uri, metaNodeUri: Uri): void;
    protected getOrCreateNodeModel(nodePath: AnyUriPath): Model;
    protected removeNodeModel(nodePath: AnyUriPath): void;
    static get metaHostUri(): Uri;
}

/** @public */
export declare class PieGadgetController extends PieController implements GadgetController {
    readonly observerType?: Class<PieGadgetControllerObserver>;
    protected layoutPie(hasLegend?: boolean): void;
    readonly pie: TraitViewRef<this, PieTrait, PieView>;
    static readonly pie: MemberFastenerClass<PieGadgetController, "pie">;
    readonly title: ViewRef<this, GraphicsView>;
    static readonly title: MemberFastenerClass<PieController, "title">;
    readonly slices: TraitViewControllerSet<this, SliceTrait, SliceView, SliceController> & PieControllerSliceExt;
    static readonly slices: MemberFastenerClass<PieGadgetController, "slices">;
    readonly canvas: ViewRef<this, CanvasView>;
    static readonly canvas: MemberFastenerClass<PieGadgetController, "canvas">;
    readonly gadget: TraitViewRef<this, Trait, HtmlView>;
    static readonly gadget: MemberFastenerClass<PieGadgetController, "gadget">;
}

/** @public */
export declare interface PieGadgetControllerObserver<C extends PieGadgetController = PieGadgetController> extends PieControllerObserver<C>, GadgetControllerObserver<C> {
}

/** @public */
export declare class PieGadgetSliceController extends SliceController {
    readonly slice: TraitViewRef<this, SliceTrait, SliceView>;
    static readonly slice: MemberFastenerClass<PieGadgetSliceController, "slice">;
    readonly label: ViewRef<this, GraphicsView>;
    static readonly label: MemberFastenerClass<PieGadgetSliceController, "label">;
    readonly legend: ViewRef<this, GraphicsView>;
    static readonly legend: MemberFastenerClass<PieGadgetSliceController, "legend">;
    readonly status: TraitRef<this, StatusTrait>;
    static readonly status: MemberFastenerClass<PieGadgetSliceController, "status">;
    protected applyStatusVector(statusVector: StatusVector, sliceView: SliceView): void;
}

/** @public */
export declare class PlaneEntity extends EntityTrait {
    constructor(hostUri: Uri);
    protected onAttachModel(model: TraitModelType<this>): void;
    readonly subentities: ModelRef<this, EntityGroup>;
    static readonly subentities: MemberFastenerClass<PlaneEntity, "subentities">;
}

/** @public */
export declare class PlaneGroup extends EntityGroup {
    constructor();
    protected initGroup(): void;
    readonly agents: ModelRef<this, Model>;
    readonly fabric: ModelRef<this, Model>;
}

/** @public */
export declare class PortalController extends MirrorController {
    isFullBleed(): boolean;
    readonly surface: ViewRef<this, SurfaceView>;
    readonly toolbar: ViewRef<this, HtmlView>;
    readonly drawer: ViewRef<this, DrawerView>;
    protected onInsertDomain(childDomain: DomainTrait, targetDomain: DomainTrait | null): void;
    protected onRemoveDomain(childDomain: DomainTrait): void;
    readonly domains: ModelRef<this, DomainGroup>;
}

/** @public */
export declare class PortalPlugin extends MirrorPlugin {
    get id(): string;
    get title(): string;
    get icon(): Graphics;
    createController(): MirrorController;
    static get icon(): Graphics;
}

/** @public */
export declare abstract class PrismPlugin {
    abstract readonly id: string;
    abstract readonly title: string;
}

/** @public */
export declare interface PrismProvider<C extends Controller, S extends PrismService<C> | null | undefined = PrismService<C>> extends Provider<C, S> {
    get plugins(): ReadonlyArray<PrismPlugin>;
    createService(): S;
}

/** @public */
export declare const PrismProvider: ProviderClass<PrismProvider<any, any>>;

/** @public */
export declare class PrismService<C extends Controller = Controller> extends Service<C> {
    constructor();
    readonly observerType?: Class<PrismServiceObserver<C>>;
    readonly plugins: ReadonlyArray<PrismPlugin>;
    insertPlugin(plugin: PrismPlugin, index?: number): void;
    protected willInsertPlugin(plugin: PrismPlugin, index: number): void;
    protected onInsertPlugin(plugin: PrismPlugin, index: number): void;
    protected didInsertPlugin(plugin: PrismPlugin, index: number): void;
    removePlugin(plugin: PrismPlugin): void;
    protected willRemovePlugin(plugin: PrismPlugin): void;
    protected onRemovePlugin(plugin: PrismPlugin): void;
    protected didRemovePlugin(plugin: PrismPlugin): void;
    static global<C extends Controller>(): PrismService<C>;
    static get plugins(): ReadonlyArray<PrismPlugin>;
    static insertPlugin(plugin: PrismPlugin, index?: number): void;
    static removePlugin(plugin: PrismPlugin): void;
}

/** @public */
export declare interface PrismServiceObserver<C extends Controller = Controller, S extends PrismService<C> = PrismService<C>> extends ServiceObserver<C, S> {
    serviceWillInsertPlugin?(plugin: PrismPlugin, index: number, service: S): void;
    serviceDidInsertPlugin?(plugin: PrismPlugin, index: number, service: S): void;
    serviceWillRemovePlugin?(plugin: PrismPlugin, service: S): void;
    serviceDidRemovePlugin?(plugin: PrismPlugin, service: S): void;
}

/** @public */
export declare class PulseTrait extends Trait {
    constructor(metaNodeUri: Uri);
    /** @protected */
    didAttachModel(model: TraitModelType<this>): void;
    readonly metaNodeUri: Uri;
    /** @internal */
    fabricIndicators: boolean;
    readonly indicators: ModelRef<this, IndicatorGroup>;
    readonly partCountIndicator: TraitRef<this, ValueIndicatorTrait<number>>;
    readonly hostCountIndicator: TraitRef<this, ValueIndicatorTrait<number>>;
    readonly nodeCountIndicator: TraitRef<this, ValueIndicatorTrait<number>>;
    readonly agentCountIndicator: TraitRef<this, ValueIndicatorTrait<number>>;
    readonly linkCountIndicator: TraitRef<this, ValueIndicatorTrait<number>>;
    readonly messageRateIndicator: TraitRef<this, ValueIndicatorTrait<number>>;
    readonly execRateIndicator: TraitRef<this, ValueIndicatorTrait<number>>;
    readonly timerRateIndicator: TraitRef<this, ValueIndicatorTrait<number>>;
    readonly pulse: ValueDownlinkFastener<this, Value, AnyValue>;
    /** @internal */
    static PartCountIndicatorType: IndicatorType;
    /** @internal */
    static HostCountIndicatorType: IndicatorType;
    /** @internal */
    static NodeCountIndicatorType: IndicatorType;
    /** @internal */
    static AgentCountIndicatorType: IndicatorType;
    /** @internal */
    static LinkCountIndicatorType: IndicatorType;
    /** @internal */
    static MessageRateIndicatorType: IndicatorType;
    /** @internal */
    static ExecRateIndicatorType: IndicatorType;
    /** @internal */
    static TimerRateIndicatorType: IndicatorType;
}

/** @public */
export declare class ReflectionController extends Controller {
    constructor(plugin: MirrorPlugin);
    readonly observerType?: Class<ReflectionControllerObserver>;
    readonly plugin: MirrorPlugin;
    activate(): void;
    protected willActivate(): void;
    protected onActivate(): void;
    protected didActivate(): void;
    readonly mirror: ControllerRef<this, MirrorController>;
    readonly row: ViewRef<this, RowView>;
    readonly surface: ViewRef<this, SurfaceView>;
    readonly toolbar: ViewRef<this, HtmlView>;
    readonly drawer: ViewRef<this, DrawerView>;
    readonly domains: ModelRef<this, DomainGroup>;
}

/** @public */
export declare interface ReflectionControllerObserver<C extends ReflectionController = ReflectionController> extends ControllerObserver<C> {
    controllerWillActivateReflection?(reflectionController: C): void;
    controllerDidActivateReflection?(reflectionController: C): void;
}

/** @public */
export declare class ReflectorController extends Controller {
    readonly active: ControllerRef<this, ReflectionController>;
    readonly surface: ViewRef<this, SurfaceView>;
    readonly toolbar: ViewRef<this, HtmlView>;
    readonly drawer: ViewRef<this, DrawerView>;
    protected insertPlugin(plugin: MirrorPlugin): void;
    protected removePlugin(plugin: MirrorPlugin): void;
    readonly mirrorList: ViewRef<this, TableView>;
    readonly reflections: ControllerSet<this, ReflectionController & Initable<ControllerInit | MirrorPlugin>> & ReflectorControllerReflectionsExt;
    readonly domains: ModelRef<this, DomainGroup>;
    readonly prismProvider: PrismProvider<this>;
    readonly historyProvider: HistoryProvider<this>;
    protected onMount(): void;
    protected updateHistoryState(historyState: HistoryState): void;
}

/** @public */
export declare interface ReflectorControllerReflectionsExt {
    getPluginController(pluginId: string): ReflectionController | null;
    createController(plugin?: MirrorPlugin): ReflectionController;
}

/** @public */
export declare class RefractionController extends WidgetController {
    readonly observerType?: Class<RefractionControllerObserver>;
    readonly widget: TraitViewRef<this, WidgetTrait, WidgetView>;
    static readonly widget: MemberFastenerClass<RefractionController, "widget">;
    readonly gadgets: TraitViewControllerSet<this, Trait, HtmlView, GadgetController>;
    static readonly gadgets: MemberFastenerClass<RefractionController, "gadgets">;
    readonly entity: TraitRef<this, EntityTrait>;
    protected willUnmount(): void;
}

/** @public */
export declare interface RefractionControllerObserver<C extends RefractionController = RefractionController> extends ControllerObserver<C> {
}

/** @public */
export declare class RefractorController extends Controller {
    readonly refractions: TraitViewControllerSet<this, WidgetTrait, WidgetView, RefractionController>;
    readonly fixtures: ViewRef<this, HtmlView>;
    readonly entity: TraitRef<this, EntityTrait>;
    readonly widgets: TraitRef<this, WidgetGroup>;
    readonly prismProvider: PrismProvider<this>;
    protected willUnmount(): void;
}

/** @public */
export declare class SessionModel extends StatusGroup {
    constructor();
    readonly domains: ModelRef<this, DomainGroup>;
    static readonly domains: MemberFastenerClass<SessionModel, "domains">;
    /** @internal */
    protected aggregateStatus(statusVector: StatusVector): void;
    protected needsUpdate(updateFlags: ModelFlags, immediate: boolean): ModelFlags;
    protected needsAnalyze(analyzeFlags: ModelFlags, modelContext: ModelContextType<this>): ModelFlags;
}

/** @public */
export declare class ShellController extends Controller {
    constructor();
    protected initShell(): void;
    get brandIcon(): Graphics;
    get settingsIcon(): Graphics;
    get inventoryIcon(): Graphics;
    readonly fullBleed: Property<this, boolean>;
    readonly root: ViewRef<this, ShellView>;
    readonly beam: ViewRef<this, BeamView>;
    readonly surface: ViewRef<this, SurfaceView>;
    readonly topLeftBar: ViewRef<this, HtmlView>;
    readonly topRightBar: ViewRef<this, HtmlView>;
    readonly searchBar: ViewRef<this, HtmlView>;
    readonly search: ViewRef<this, HtmlView>;
    readonly brand: ViewRef<this, HtmlIconView>;
    readonly rightPanel: ViewRef<this, DrawerView>;
    readonly leftDrawer: ViewRef<this, DrawerView>;
    readonly leftDrawerButton: ViewRef<this, DrawerButton>;
    readonly rightDrawer: ViewRef<this, DrawerView>;
    readonly inventoryButton: ViewRef<this, IconButton>;
    readonly brandItem: ViewRef<this, RowView>;
    readonly mirrorList: ViewRef<this, TableView>;
    readonly domainList: ViewRef<this, TableView>;
    readonly settingsItem: ViewRef<this, RowView>;
    protected getActivityController(entityTrait: EntityTrait): ActivityController | null;
    protected showActivity(activityWindow: ActivityWindow): void;
    readonly activityWindow: ViewRef<this, ActivityWindow>;
    readonly reflector: ControllerRef<this, ReflectorController>;
    readonly collector: ControllerRef<this, CollectorController>;
    readonly magnifier: ControllerRef<this, MagnifierController>;
    readonly activity: ControllerRef<this, ActivityController>;
    readonly session: ModelRef<this, SessionModel>;
    readonly status: TraitRef<this, StatusTrait>;
    addDomain(query: string): DomainTrait | null;
    readonly domains: ModelRef<this, DomainGroup>;
    readonly prismProvider: PrismProvider<this>;
    readonly historyProvider: HistoryProvider<this>;
    protected onMount(): void;
    protected updateHistoryState(historyState: HistoryState): void;
    protected applyStatus(statusVector: StatusVector): void;
    static get leftListLayout(): TableLayout;
    static get brandIcon(): Graphics;
    static get settingsIcon(): Graphics;
    static get inventoryIcon(): Graphics;
    static readonly MountFlags: ControllerFlags;
}

/** @public */
export declare class ShellView extends HtmlView {
    constructor(node: HTMLElement);
    protected initShell(): void;
    /** @internal */
    readonly masterLayout: ConstraintGroup;
    protected initMasterLayout(layout: ConstraintGroup): void;
    /** @internal */
    readonly mobileLayout: ConstraintGroup;
    protected initMobileLayout(layout: ConstraintGroup): void;
    /** @internal */
    readonly desktopLayout: ConstraintGroup;
    protected initDesktopLayout(layout: ConstraintGroup): void;
    protected updateViewportIdiom(viewportIdiom: ViewportIdiom): void;
    protected setFullBleed(fullBleed: boolean, surfaceView: SurfaceView, timing?: Timing | boolean): void;
    protected updateTopBarBleed(topBar: HtmlView, timing?: Timing | boolean): void;
    protected updateSearchBarBleed(searchBar: HtmlView, timing?: Timing | boolean): void;
    protected willResize(viewContext: ViewContextType<this>): void;
    readonly visualViewportWidth: ConstraintProperty<this, number>;
    readonly visualViewportHeight: ConstraintProperty<this, number>;
    readonly visualViewportPageLeft: ConstraintProperty<this, number>;
    readonly visualViewportPageTop: ConstraintProperty<this, number>;
    readonly safeAreaInsetTop: ConstraintProperty<this, number>;
    readonly safeAreaInsetRight: ConstraintProperty<this, number>;
    readonly safeAreaInsetBottom: ConstraintProperty<this, number>;
    readonly safeAreaInsetLeft: ConstraintProperty<this, number>;
    readonly beamHeight: ConstraintProperty<this, number>;
    readonly topBarTop: ConstraintProperty<this, number>;
    readonly topBarLeft: ConstraintProperty<this, number>;
    readonly topBarRight: ConstraintProperty<this, number>;
    readonly topBarHeight: ConstraintProperty<this, number>;
    readonly topBarPaddingLeft: ConstraintProperty<this, number>;
    readonly topBarPaddingRight: ConstraintProperty<this, number>;
    readonly searchBarTop: ConstraintProperty<this, number>;
    readonly searchBarLeft: ConstraintProperty<this, number>;
    readonly searchBarRight: ConstraintProperty<this, number>;
    readonly searchBarHeight: ConstraintProperty<this, number>;
    readonly searchBarPaddingLeft: ConstraintProperty<this, number>;
    readonly searchBarPaddingRight: ConstraintProperty<this, number>;
    readonly searchBarPaddingBottom: ConstraintProperty<this, number>;
    readonly searchFieldHeight: ConstraintProperty<this, number>;
    readonly surfacePaddingTop: ConstraintProperty<this, number>;
    readonly surfacePaddingRight: ConstraintProperty<this, number>;
    readonly surfacePaddingBottom: ConstraintProperty<this, number>;
    readonly surfacePaddingLeft: ConstraintProperty<this, number>;
    readonly leftDrawerWidth: ConstraintProperty<this, number>;
    readonly rightPanelWidth: ConstraintProperty<this, number>;
    readonly drawerWidth: ConstraintProperty<this, number>;
    readonly activityHeight: ConstraintProperty<this, number>;
    readonly edgeInsets: Property<this, ViewportInsets>;
    readonly beam: ViewRef<this, BeamView>;
    readonly surface: ViewRef<this, SurfaceView>;
    readonly topBar: ViewRef<this, HtmlView>;
    readonly topLeftBar: ViewRef<this, HtmlView>;
    readonly topRightBar: ViewRef<this, HtmlView>;
    readonly searchBar: ViewRef<this, HtmlView>;
    readonly search: ViewRef<this, InputTokenView>;
    readonly brand: ViewRef<this, HtmlIconView>;
    readonly rightPanel: ViewRef<this, DrawerView>;
    readonly scrim: ViewRef<this, ScrimView>;
    readonly leftDrawer: ViewRef<this, DrawerView>;
    readonly leftDrawerButton: ViewRef<this, DrawerButton>;
    readonly rightDrawer: ViewRef<this, DrawerView>;
    readonly activityWindow: ViewRef<this, ActivityWindow>;
    readonly viewportProvider: ViewportProvider<this>;
    protected didMount(): void;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected onSurfaceScroll(event: Event): void;
}

/** @public */
export declare class Status {
    constructor(name: string);
    readonly name: string;
    toString(): string;
    static normal: Status;
    static inactive: Status;
    static warning: Status;
    static alert: Status;
}

/** @public */
export declare class StatusFactor implements Equals, Debug {
    constructor(name: string, vector: StatusVector, weight: number, since: DateTime);
    readonly name: string;
    readonly vector: StatusVector;
    readonly weight: number;
    readonly since: DateTime;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static create(name: string, vector: AnyStatusVector, weight?: number, since?: AnyDateTime): StatusFactor;
    static fromInit(init: StatusFactorInit): StatusFactor;
    static fromAny(value: AnyStatusFactor): StatusFactor;
    /** @internal */
    static isInit(value: unknown): value is StatusFactorInit;
    /** @internal */
    static isAny(value: unknown): value is AnyStatusFactor;
}

/** @public */
export declare interface StatusFactorInit {
    name: string;
    vector: AnyStatusVector;
    weight?: number;
    since?: AnyDateTime;
}

/** @public */
export declare class StatusGroup extends Model {
    /** @internal */
    protected aggregateStatus(statusVector: StatusVector): void;
    protected needsAnalyze(analyzeFlags: ModelFlags, modelContext: ModelContextType<this>): ModelFlags;
    protected analyzeChildren(analyzeFlags: ModelFlags, modelContext: ModelContextType<this>, analyzeChild: (this: this, child: Model, analyzeFlags: ModelFlags, modelContext: ModelContextType<this>) => void): void;
    protected aggregateChildStatuses(analyzeFlags: ModelFlags, modelContext: ModelContextType<this>, analyzeChild: (this: this, child: Model, analyzeFlags: ModelFlags, modelContext: ModelContextType<this>) => void): void;
    static MountFlags: ModelFlags;
    static InsertChildFlags: ModelFlags;
    static RemoveChildFlags: ModelFlags;
}

/** @public */
export declare class StatusTrait extends Trait {
    constructor();
    readonly observerType?: Class<StatusTraitObserver>;
    /** @internal */
    readonly statusFactors: {
        [statusName: string]: StatusFactor | undefined;
    } | null;
    getStatusFactor(statusName: string): StatusFactor | null;
    setStatusFactor(statusName: string, newStatusFactor: StatusFactor | null): void;
    protected willSetStatusFactor(statusName: string, newStatusFactor: StatusFactor | null, oldStatusFactor: StatusFactor | null): void;
    protected onSetStatusFactor(statusName: string, newStatusFactor: StatusFactor | null, oldStatusFactor: StatusFactor | null): void;
    protected didSetStatusFactor(statusName: string, newStatusFactor: StatusFactor | null, oldStatusFactor: StatusFactor | null): void;
    readonly statusVector: StatusVector;
    setStatusVector(newStatusVector: StatusVector): void;
    protected willSetStatusVector(newStatusVector: StatusVector, oldStatusVector: StatusVector): void;
    protected onSetStatusVector(newStatusVector: StatusVector, oldStatusVector: StatusVector): void;
    protected didSetStatusVector(newStatusVector: StatusVector, oldStatusVector: StatusVector): void;
    /** @internal */
    combinedStatus(): StatusVector;
    /** @internal */
    aggregateStatus(): void;
    /** @protected */
    needsUpdate(updateFlags: ModelFlags, immediate: boolean): ModelFlags;
    /** @protected */
    needsAnalyze(analyzeFlags: ModelFlags, modelContext: TraitContextType<this>): ModelFlags;
    /** @protected */
    didAggregate(modelContext: TraitContextType<this>): void;
    static readonly MountFlags: ModelFlags;
}

/** @public */
export declare interface StatusTraitObserver<T extends Trait = Trait> extends TraitObserver<T> {
    traitWillSetStatusFactor?(statusName: string, newStatusFactor: StatusFactor | null, oldStatusFactor: StatusFactor | null, trait: T): void;
    traitDidSetStatusFactor?(statusName: string, newStatusFactor: StatusFactor | null, oldStatusFactor: StatusFactor | null, trait: T): void;
    traitWillSetStatusVector?(newStatusVector: StatusVector, oldStatusVector: StatusVector, trait: T): void;
    traitDidSetStatusVector?(newStatusVector: StatusVector, oldStatusVector: StatusVector, trait: T): void;
}

/** @public */
export declare class StatusVector implements Equals, Debug {
    constructor(array: ReadonlyArray<[Status, number]>, index: {
        readonly [name: string]: number | undefined;
    });
    /** @internal */
    readonly array: ReadonlyArray<[Status, number]>;
    /** @internal */
    readonly index: {
        readonly [name: string]: number | undefined;
    };
    get size(): number;
    isDefined(): boolean;
    isEmpty(): boolean;
    has(key: Status): boolean;
    has(name: string): boolean;
    get(key: Status): number | undefined;
    get(name: string): number | undefined;
    get(index: number): number | undefined;
    updated(key: Status, value: number | undefined): StatusVector;
    plus(that: StatusVector): StatusVector;
    negative(): StatusVector;
    minus(that: StatusVector): StatusVector;
    times(scalar: number): StatusVector;
    dot(that: StatusVector): number | undefined;
    protected copy(array: ReadonlyArray<[Status, number]>, index?: {
        readonly [name: string]: number | undefined;
    }): StatusVector;
    forEach<R>(callback: (value: number, key: Status) => R | void): R | undefined;
    forEach<R, S>(callback: (this: S, value: number, key: Status) => R | void, thisArg: S): R | undefined;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static empty(): StatusVector;
    static of(...keys: [Status, number][]): StatusVector;
    static fromArray(array: ReadonlyArray<[Status, number]>, index?: {
        [name: string]: number | undefined;
    }): StatusVector;
    static fromAny(value: AnyStatusVector): StatusVector;
    /** @internal */
    static index(array: ReadonlyArray<[Status, unknown]>): {
        readonly [name: string]: number | undefined;
    };
}

/** @public */
export declare type StatusVectorArray = ReadonlyArray<[Status, number]>;

/** @public */
export declare class SuggestionController extends Controller {
    readonly row: ViewRef<this, RowView>;
    static readonly row: MemberFastenerClass<SuggestionController, "row">;
    readonly entity: TraitRef<this, EntityTrait>;
    static readonly entity: MemberFastenerClass<SuggestionController, "entity">;
}

/** @public */
export declare class SurfaceView extends HtmlView {
    readonly observerType?: Class<SurfaceViewObserver>;
    readonly edgeInsets: Property<this, ViewportInsets | null>;
    readonly fullBleed: Property<this, boolean>;
}

/** @public */
export declare interface SurfaceViewObserver<V extends SurfaceView = SurfaceView> extends HtmlViewObserver<V> {
    viewWillSetFullBleed?(fullBleed: boolean, view: V): void;
    viewDidSetFullBleed?(fullBleed: boolean, view: V): void;
}

/** @public */
export declare class TableGadgetController extends TableController implements GadgetController {
    constructor();
    readonly observerType?: Class<TableGadgetControllerObserver>;
    readonly table: TraitViewRef<this, TableTrait, TableView>;
    static readonly table: MemberFastenerClass<TableGadgetController, "table">;
    readonly rows: TraitViewControllerSet<this, RowTrait, RowView, RowController>;
    static readonly rows: MemberFastenerClass<TableGadgetController, "rows">;
    readonly gadget: TraitViewRef<this, Trait, HtmlView>;
    static readonly gadget: MemberFastenerClass<TableGadgetController, "gadget">;
    protected onGadgetScroll(event: Event): void;
}

/** @public */
export declare interface TableGadgetControllerObserver<C extends TableGadgetController = TableGadgetController> extends TableControllerObserver<C>, GadgetControllerObserver<C> {
}

/** @public */
export declare class TableGadgetIconCellController extends IconCellController {
    readonly cell: TraitViewRef<this, IconCellTrait, IconCellView>;
    static readonly cell: MemberFastenerClass<TableGadgetIconCellController, "cell">;
    readonly status: TraitRef<this, StatusTrait>;
    static readonly status: MemberFastenerClass<TableGadgetIconCellController, "status">;
    protected applyStatusVector(statusVector: StatusVector, cellView: IconCellView): void;
}

/** @public */
export declare class TableGadgetRowController extends RowController {
    readonly row: TraitViewRef<this, RowTrait, RowView>;
    static readonly row: MemberFastenerClass<TableGadgetRowController, "row">;
    readonly cells: TraitViewControllerSet<this, CellTrait, CellView, CellController>;
    static readonly cells: MemberFastenerClass<TableGadgetRowController, "cells">;
    readonly status: TraitRef<this, StatusTrait>;
    static readonly status: MemberFastenerClass<TableGadgetRowController, "status">;
    protected applyStatusVector(statusVector: StatusVector, rowView: RowView): void;
}

/** @public */
export declare class TableGadgetTextCellController extends TextCellController {
    readonly cell: TraitViewRef<this, TextCellTrait, TextCellView>;
    static readonly cell: MemberFastenerClass<TableGadgetTextCellController, "cell">;
    readonly status: TraitRef<this, StatusTrait>;
    static readonly status: MemberFastenerClass<TableGadgetTextCellController, "status">;
    protected applyStatusVector(statusVector: StatusVector, cellView: TextCellView): void;
}

/** @public */
export declare class ValueIndicatorTrait<T = unknown> extends IndicatorTrait {
    constructor(indicatorType: IndicatorType);
    readonly observerType?: Class<ValueIndicatorTraitObserver>;
    readonly value: T | undefined;
    setValue(newValue: T | undefined): void;
    protected willSetValue(newValue: T | undefined, oldValue: T | undefined): void;
    protected onSetValue(newValue: T | undefined, oldValue: T | undefined): void;
    protected didSetValue(newValue: T | undefined, oldValue: T | undefined): void;
    get formattedValue(): string;
}

/** @public */
export declare interface ValueIndicatorTraitObserver<T = unknown, R extends ValueIndicatorTrait<T> = ValueIndicatorTrait<T>> extends IndicatorTraitObserver<R> {
    indicatorWillSetValue?(newValue: T | undefined, oldValue: T | undefined, trait: R): void;
    indicatorDidSetValue?(newValue: T | undefined, oldValue: T | undefined, trait: R): void;
    formatIndicator?(value: T | undefined, trait: R): string | void;
}

/** @public */
export declare class ValueLaneModel extends LaneModel {
    readonly data: ValueDownlinkFastener<this>;
}

/** @public */
export declare class WidgetCard extends WidgetView {
    constructor(node: HTMLElement);
    protected initWidget(): void;
    protected initTheme(): void;
    readonly header: ViewRef<this, HtmlView>;
    static readonly header: MemberFastenerClass<WidgetCard, "header">;
    readonly headerTitle: ViewRef<this, HtmlView> & {
        create(value?: string): HtmlView;
    };
    static readonly headerTitle: MemberFastenerClass<WidgetCard, "headerTitle">;
    readonly headerSubtitle: ViewRef<this, HtmlView> & {
        create(value?: string): HtmlView;
    };
    static readonly headerSubtitle: MemberFastenerClass<WidgetCard, "headerSubtitle">;
    readonly footer: ViewRef<this, HtmlView>;
    static readonly footer: MemberFastenerClass<WidgetCard, "footer">;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
}

/** @public */
export declare abstract class WidgetController extends Controller {
    readonly observerType?: Class<WidgetControllerObserver>;
    setTitle(title: WidgetTitle | null): void;
    setSubtitle(subtitle: WidgetSubtitle | null): void;
    readonly widget: TraitViewRef<this, WidgetTrait, WidgetView>;
    static readonly widget: MemberFastenerClass<WidgetController, "widget">;
    readonly header: ViewRef<this, HtmlView>;
    static readonly header: MemberFastenerClass<WidgetController, "header">;
    protected createHeaderTitleView(title: WidgetTitle, widgetTrait: WidgetTrait): HtmlView | string | null;
    protected setHeaderTitleView(title: WidgetTitle | null, widgetTrait: WidgetTrait): void;
    readonly headerTitle: ViewRef<this, HtmlView>;
    static readonly headerTitle: MemberFastenerClass<WidgetController, "headerTitle">;
    protected createHeaderSubtitleView(subtitle: WidgetSubtitle, widgetTrait: WidgetTrait): HtmlView | string | null;
    protected setHeaderSubtitleView(subtitle: WidgetSubtitle | null, widgetTrait: WidgetTrait): void;
    readonly headerSubtitle: ViewRef<this, HtmlView>;
    static readonly headerSubtitle: MemberFastenerClass<WidgetController, "headerSubtitle">;
    readonly footer: ViewRef<this, HtmlView>;
    static readonly footer: MemberFastenerClass<WidgetController, "footer">;
    readonly gadgets: TraitViewControllerSet<this, Trait, HtmlView, GadgetController>;
    static readonly gadgets: MemberFastenerClass<WidgetController, "gadgets">;
    protected didMount(): void;
    protected willUnmount(): void;
}

/** @public */
export declare interface WidgetControllerGadgetExt {
    attachGadgetTrait(gadgetTrait: Trait, gadgetController: GadgetController): void;
    detachGadgetTrait(gadgetTrait: Trait, gadgetController: GadgetController): void;
    attachGadgetView(gadgetView: HtmlView, gadgetController: GadgetController): void;
    detachGadgetView(gadgetView: HtmlView, gadgetController: GadgetController): void;
}

/** @public */
export declare interface WidgetControllerObserver<C extends WidgetController = WidgetController> extends ControllerObserver<C> {
    controllerWillAttachWidgetTrait?(widgetTrait: WidgetTrait, controller: C): void;
    controllerDidDetachWidgetTrait?(widgetTrait: WidgetTrait, controller: C): void;
    controllerWillAttachWidgetView?(widgetView: WidgetView, controller: C): void;
    controllerDidDetachWidgetView?(widgetView: WidgetView, controller: C): void;
    controllerWillAttachHeaderView?(headerView: HtmlView, controller: C): void;
    controllerDidDetachHeaderView?(headerView: HtmlView, controller: C): void;
    controllerWillAttachHeaderTitleView?(titleView: HtmlView, controller: C): void;
    controllerDidDetachHeaderTitleView?(titleView: HtmlView, controller: C): void;
    controllerWillAttachHeaderSubtitleView?(subtitleView: HtmlView, controller: C): void;
    controllerDidDetachHeaderSubtitleView?(subtitleView: HtmlView, controller: C): void;
    controllerWillAttachFooterView?(footerView: HtmlView, controller: C): void;
    controllerDidDetachFooterView?(footerView: HtmlView, controller: C): void;
    controllerWillAttachGadget?(gadgetController: GadgetController, controller: C): void;
    controllerDidDetachGadget?(gadgetController: GadgetController, controller: C): void;
    controllerWillAttachGadgetTrait?(gadgetTrait: Trait, gadgetController: GadgetController, controller: C): void;
    controllerDidDetachGadgetTrait?(gadgetTrait: Trait, gadgetController: GadgetController, controller: C): void;
    controllerWillAttachGadgetView?(gadgetView: HtmlView, gadgetController: GadgetController, controller: C): void;
    controllerDidDetachGadgetView?(gadgetView: HtmlView, gadgetController: GadgetController, controller: C): void;
}

/** @public */
export declare class WidgetGroup extends Trait {
    readonly observerType?: Class<WidgetGroupObserver>;
    readonly widgets: TraitSet<this, WidgetTrait>;
    static readonly widgets: MemberFastenerClass<WidgetGroup, "widgets">;
}

/** @public */
export declare interface WidgetGroupObserver<T extends WidgetGroup = WidgetGroup> extends TraitObserver<T> {
    traitWillAttachWidget?(widgetTrait: WidgetTrait, targetTrait: Trait | null, trait: T): void;
    traitDidDetachWidget?(widgetTrait: WidgetTrait, trait: T): void;
}

/** @public */
export declare type WidgetSubtitle = WidgetSubtitleFunction | string;

/** @public */
export declare type WidgetSubtitleFunction = (widgetTrait: WidgetTrait) => HtmlView | string | null;

/** @public */
export declare type WidgetTitle = WidgetTitleFunction | string;

/** @public */
export declare type WidgetTitleFunction = (widgetTrait: WidgetTrait) => HtmlView | string | null;

/** @public */
export declare class WidgetTrait extends Trait {
    readonly observerType?: Class<WidgetTraitObserver>;
    readonly title: Property<this, WidgetTitle | null>;
    readonly subtitle: Property<this, WidgetTitle | null>;
    readonly gadgets: TraitSet<this, Trait>;
    /** @internal */
    protected startConsumingGadgets(): void;
    /** @internal */
    protected stopConsumingGadgets(): void;
    protected onStartConsuming(): void;
    protected onStopConsuming(): void;
}

/** @public */
export declare interface WidgetTraitObserver<T extends WidgetTrait = WidgetTrait> extends TraitObserver<T> {
    traitWillSetTitle?(newTitle: WidgetTitle | null, oldTitle: WidgetTitle | null, trait: T): void;
    traitDidSetTitle?(newTitle: WidgetTitle | null, oldTitle: WidgetTitle | null, trait: T): void;
    traitWillSetSubtitle?(newSubtitle: WidgetSubtitle | null, oldSubtitle: WidgetSubtitle | null, trait: T): void;
    traitDidSetSubtitle?(newSubtitle: WidgetSubtitle | null, oldSubtitle: WidgetSubtitle | null, trait: T): void;
    traitWillAttachGadget?(gadgetTrait: Trait, targetTrait: Trait | null, trait: T): void;
    traitDidDetachGadget?(gadgetTrait: Trait, trait: T): void;
    detectGadgetModel?(model: Model, trait: T): Trait | null;
}

/** @public */
export declare class WidgetView extends HtmlView {
    readonly observerType?: Class<WidgetViewObserver>;
    readonly edgeInsets: Property<this, ViewportInsets | null>;
    readonly header: ViewRef<this, HtmlView>;
    static readonly header: MemberFastenerClass<WidgetView, "header">;
    protected createHeaderTitle(text?: string): HtmlView | null;
    readonly headerTitle: ViewRef<this, HtmlView & Initable<HtmlViewInit | string>> & {
        create(value?: string): HtmlView;
    };
    static readonly headerTitle: MemberFastenerClass<WidgetView, "headerTitle">;
    readonly headerSubtitle: ViewRef<this, HtmlView & Initable<HtmlViewInit | string>> & {
        create(value?: string): HtmlView;
    };
    static readonly headerSubtitle: MemberFastenerClass<WidgetView, "headerSubtitle">;
    readonly footer: ViewRef<this, HtmlView>;
    static readonly footer: MemberFastenerClass<WidgetView, "footer">;
    readonly gadgets: ViewSet<this, HtmlView>;
}

/** @public */
export declare interface WidgetViewObserver<V extends WidgetView = WidgetView> extends HtmlViewObserver<V> {
    viewWillAttachHeader?(headerView: HtmlView, view: V): void;
    viewDidDetachHeader?(headerView: HtmlView, view: V): void;
    viewWillAttachHeaderTitle?(titleView: HtmlView, view: V): void;
    viewDidDetachHeaderTitle?(titleView: HtmlView, view: V): void;
    viewWillAttachHeaderSubtitle?(subtitleView: HtmlView, view: V): void;
    viewDidDetachHeaderSubtitle?(subtitleView: HtmlView, view: V): void;
    viewWillAttachFooter?(footerView: HtmlView, view: V): void;
    viewDidDetachFooter?(footerView: HtmlView, view: V): void;
    viewWillAttachGadget?(gadgetView: HtmlView, targetView: View | null, view: V): void;
    viewDidDetachGadget?(gadgetView: HtmlView, view: V): void;
}

export { }
