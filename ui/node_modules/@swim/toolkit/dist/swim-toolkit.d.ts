/// <reference types="arcgis-js-api" />
/// <reference types="google.maps" />
/// <reference types="mapbox-gl" />
/// <reference types="w3c-css-typed-object-model-level-1" />

import { Affinity } from '@swim/runtime';
import { Angle } from '@swim/runtime';
import { Animator } from '@swim/runtime';
import { AnimatorClass } from '@swim/runtime';
import { AnimatorFactory } from '@swim/runtime';
import { AnimatorInit } from '@swim/runtime';
import { AnyAngle } from '@swim/runtime';
import { AnyConstraintExpression } from '@swim/runtime';
import { AnyConstraintStrength } from '@swim/runtime';
import { AnyDateTime } from '@swim/runtime';
import { AnyDomain } from '@swim/runtime';
import { AnyGeoBox } from '@swim/runtime';
import { AnyGeoPath } from '@swim/runtime';
import { AnyGeoPoint } from '@swim/runtime';
import { AnyLength } from '@swim/runtime';
import { AnyR2Box } from '@swim/runtime';
import { AnyR2Path } from '@swim/runtime';
import { AnyR2Point } from '@swim/runtime';
import { AnyTiming } from '@swim/runtime';
import { AnyTransform } from '@swim/runtime';
import { AnyUri } from '@swim/runtime';
import { AnyUriFragment } from '@swim/runtime';
import type { AnyValue } from '@swim/runtime';
import { BTree } from '@swim/runtime';
import { Class } from '@swim/runtime';
import { Comparator } from '@swim/runtime';
import { Component } from '@swim/runtime';
import { ComponentFlags } from '@swim/runtime';
import { ComponentInit } from '@swim/runtime';
import type { ComponentObserver } from '@swim/runtime';
import { Constraint } from '@swim/runtime';
import { ConstraintContext } from '@swim/runtime';
import { ConstraintExpression } from '@swim/runtime';
import { ConstraintMap } from '@swim/runtime';
import { ConstraintProperty } from '@swim/runtime';
import { ConstraintRelation } from '@swim/runtime';
import { ConstraintScope } from '@swim/runtime';
import { ConstraintSolver } from '@swim/runtime';
import { ConstraintStrength } from '@swim/runtime';
import { ConstraintTerm } from '@swim/runtime';
import { ConstraintVariable } from '@swim/runtime';
import { Consumable } from '@swim/runtime';
import { Consumer } from '@swim/runtime';
import { ConsumerType } from '@swim/runtime';
import { ContinuousScale } from '@swim/runtime';
import { Creatable } from '@swim/runtime';
import { DateTime } from '@swim/runtime';
import { Debug } from '@swim/runtime';
import { Dictionary } from '@swim/runtime';
import { Domain } from '@swim/runtime';
import { Equals } from '@swim/runtime';
import { Equivalent } from '@swim/runtime';
import { Fastener } from '@swim/runtime';
import { FastenerClass } from '@swim/runtime';
import { FastenerContext } from '@swim/runtime';
import { FastenerFlags } from '@swim/runtime';
import { FastenerInit } from '@swim/runtime';
import { Form } from '@swim/runtime';
import { FromAny } from '@swim/runtime';
import { GeoBox } from '@swim/runtime';
import { GeoPath } from '@swim/runtime';
import { GeoPoint } from '@swim/runtime';
import { GeoPointInit } from '@swim/runtime';
import { GeoPointTuple } from '@swim/runtime';
import { GeoProjection } from '@swim/runtime';
import type { GeoTile } from '@swim/runtime';
import { HashCode } from '@swim/runtime';
import { Initable } from '@swim/runtime';
import { InitType } from '@swim/runtime';
import { Input } from '@swim/runtime';
import { Interpolate } from '@swim/runtime';
import { Interpolator } from '@swim/runtime';
import { Item } from '@swim/runtime';
import { Length } from '@swim/runtime';
import { MapDownlinkFastener } from '@swim/runtime';
import { MemberAnimatorInit } from '@swim/runtime';
import { MemberFastenerClass } from '@swim/runtime';
import { MemberPropertyInitMap } from '@swim/runtime';
import { Observable } from '@swim/runtime';
import type { Observer } from '@swim/runtime';
import { ObserverMethods } from '@swim/runtime';
import { ObserverParameters } from '@swim/runtime';
import { ObserverType } from '@swim/runtime';
import { Output } from '@swim/runtime';
import { Parser } from '@swim/runtime';
import { Property } from '@swim/runtime';
import { Proto } from '@swim/runtime';
import { Provider } from '@swim/runtime';
import { ProviderClass } from '@swim/runtime';
import { R2Box } from '@swim/runtime';
import { R2Path } from '@swim/runtime';
import type { R2PathContext } from '@swim/runtime';
import { R2Point } from '@swim/runtime';
import { Range as Range_2 } from '@swim/runtime';
import { Service } from '@swim/runtime';
import type { ServiceObserver } from '@swim/runtime';
import { TimeInterval } from '@swim/runtime';
import { TimeZone } from '@swim/runtime';
import { Timing } from '@swim/runtime';
import { Transform } from '@swim/runtime';
import { Uri } from '@swim/runtime';
import { Value } from '@swim/runtime';
import { ValueDownlinkFastener } from '@swim/runtime';
import { WarpProvider } from '@swim/runtime';
import { WarpRef } from '@swim/runtime';

/** @public */
export declare type AlignContent = "baseline" | "center" | "end" | "first baseline" | "flex-end" | "flex-start" | "last baseline" | "left" | "right" | "safe center" | "space-around" | "space-between" | "space-evenly" | "start" | "stretch" | "unsafe center";

/** @public */
export declare type AlignItems = "baseline" | "center" | "end" | "first baseline" | "flex-end" | "flex-start" | "last baseline" | "left" | "normal" | "right" | "safe center" | "self-end" | "self-start" | "start" | "stretch" | "unsafe center";

/** @public */
export declare type AlignmentBaseline = "after-edge" | "alphabetic" | "auto" | "baseline" | "before-edge" | "central" | "hanging" | "ideographic" | "inherit" | "mathematical" | "middle" | "text-after-edge" | "text-before-edge";

/** @public */
export declare type AlignSelf = "auto" | "baseline" | "center" | "end" | "first baseline" | "flex-end" | "flex-start" | "last baseline" | "left" | "normal" | "right" | "safe center" | "self-end" | "self-start" | "start" | "stretch" | "unsafe center";

/** @internal */
export declare const AngleThemeAnimator: ThemeAnimatorFactory<ThemeAnimator<any, Angle | null | undefined, AnyAngle | null | undefined>>;

/** @public */
export declare type AnyArc = Arc | ArcInit;

/** @public */
export declare type AnyArcView = ArcView | Arc | ArcViewInit;

/** @public */
export declare type AnyAreaPlotView<X = unknown, Y = unknown> = AreaPlotView<X, Y> | AreaPlotViewInit<X, Y>;

/** @public */
export declare type AnyAxisView<D = unknown> = AxisView<D> | AxisViewInit<D>;

/** @public */
export declare type AnyBoxShadow = BoxShadow | BoxShadowInit | string | ReadonlyArray<AnyBoxShadow>;

/** @public */
export declare type AnyBubblePlotView<X = unknown, Y = unknown> = BubblePlotView<X, Y> | BubblePlotViewInit<X, Y>;

/** @public */
export declare type AnyChartView<X = unknown, Y = unknown> = ChartView<X, Y> | ChartViewInit<X, Y>;

/** @public */
export declare type AnyColLayout = ColLayout | ColLayoutInit;

/** @public */
export declare type AnyColor = Color | ColorInit | string;

/** @public */
export declare type AnyColorStop = ColorStop | ColorStopInit | ColorStopTuple | string;

/** @public */
export declare type AnyController<C extends Controller = Controller> = C | ControllerFactory<C> | InitType<C>;

/** @public */
export declare type AnyDataPointView<X = unknown, Y = unknown> = DataPointView<X, Y> | DataPointViewInit<X, Y>;

/** @public */
export declare type AnyDeckPost = DeckPost | DeckPostInit;

/** @public */
export declare type AnyDeckRail = DeckRail | DeckRailInit;

/** @public */
export declare type AnyDialView = DialView | DialViewInit;

/** @public */
export declare type AnyElementView<V extends ElementView = ElementView> = AnyNodeView<V>;

/** @public */
export declare type AnyExpansion = Expansion | ExpansionInit;

/** @public */
export declare type AnyFeelVector = FeelVector | FeelVectorArray;

/** @public */
export declare type AnyFocus = Focus | FocusInit;

/** @public */
export declare type AnyFont = Font | FontInit | string;

/** @public */
export declare type AnyFontSize = AnyLength | FontSize;

/** @public */
export declare type AnyGaugeView = GaugeView | GaugeViewInit;

/** @public */
export declare type AnyGeoArcView = GeoArcView | GeoArcViewInit;

/** @public */
export declare type AnyGeoCircleView = GeoCircleView | GeoCircleViewInit;

/** @public */
export declare type AnyGeoIconView = GeoIconView | GeoIconViewInit;

/** @public */
export declare type AnyGeoPerspective = GeoPerspective | GeoPerspectiveInit;

/** @public */
export declare type AnyGeoPlotView = GeoPlotView | GeoPlotViewInit;

/** @public */
export declare type AnyGeoPointView = GeoPointView | GeoPointViewInit | GeoPoint | GeoPointInit | GeoPointTuple;

/** @public */
export declare type AnyGraphicsRenderer = GraphicsRenderer | GraphicsRendererType;

/** @public */
export declare type AnyGraphView<X = unknown, Y = unknown> = GraphView<X, Y> | GraphViewInit<X, Y>;

/** @public */
export declare type AnyHslColor = HslColor | HslColorInit | string;

/** @public */
export declare type AnyHtmlView<V extends HtmlView = HtmlView> = AnyElementView<V> | keyof HtmlViewTagMap;

/** @public */
export declare type AnyIconLayout = IconLayout | IconLayoutInit;

/** @public */
export declare type AnyLinearGradient = LinearGradient | LinearGradientInit | string;

/** @public */
export declare type AnyLinearGradientAngle = LinearGradientAngle | number;

/** @public */
export declare type AnyLineHeight = AnyLength | LineHeight;

/** @public */
export declare type AnyLinePlotView<X = unknown, Y = unknown> = LinePlotView<X, Y> | LinePlotViewInit<X, Y>;

/** @public */
export declare type AnyLookVector<T> = LookVector<T> | LookVectorArray<T>;

/** @public */
export declare type AnyModel<M extends Model = Model> = M | ModelFactory<M> | InitType<M>;

/** @public */
export declare type AnyMoodVector<M extends Mood = Feel> = MoodVector<M> | MoodVectorArray<M>;

/** @public */
export declare type AnyNodeView<V extends NodeView = NodeView> = AnyView<V> | ViewNodeType<V>;

/** @public */
export declare type AnyPieView = PieView | PieViewInit;

/** @public */
export declare type AnyPlotView<X = unknown, Y = unknown> = PlotView<X, Y> | PlotViewInit<X, Y>;

/** @public */
export declare type AnyPresence = Presence | PresenceInit;

/** @public */
export declare type AnyRect = Rect | RectInit;

/** @public */
export declare type AnyRectView = RectView | Rect | RectViewInit;

/** @public */
export declare type AnyRgbColor = RgbColor | RgbColorInit | string;

/** @public */
export declare type AnyScatterPlotView<X = unknown, Y = unknown> = ScatterPlotView<X, Y> | ScatterPlotViewInit<X, Y>;

/** @public */
export declare type AnySeriesPlotView<X = unknown, Y = unknown> = SeriesPlotView<X, Y> | SeriesPlotViewInit<X, Y>;

/** @public */
export declare type AnySliceView = SliceView | SliceViewInit;

/** @public */
export declare type AnyStyleValue = AnyDateTime | AnyAngle | AnyLength | AnyFont | AnyColor | RgbColorInit | HslColorInit | AnyLinearGradient | AnyBoxShadow | BoxShadowInit | AnyTransform | Interpolator<any> | number | boolean;

/** @public */
export declare type AnySvgView<V extends SvgView = SvgView> = AnyElementView<V> | keyof SvgViewTagMap;

/** @public */
export declare type AnyTableLayout = TableLayout | TableLayoutInit;

/** @public */
export declare type AnyTextRun = TextRun | TextRunInit | string;

/** @public */
export declare type AnyTextRunView = TextRunView | TextRun | TextRunViewInit | string;

/** @public */
export declare type AnyTextView<V extends TextView = TextView> = AnyNodeView<V> | string;

/** @public */
export declare type AnyTickView<D = unknown> = TickView<D> | TickViewInit<D>;

/** @public */
export declare type AnyTrait<T extends Trait = Trait> = T | TraitFactory<T> | InitType<T>;

/** @public */
export declare type AnyView<V extends View = View> = V | ViewFactory<V> | InitType<V>;

/** @public */
export declare type Appearance = "button" | "checkbox" | "none" | "scrollbarbutton-up";

/** @public */
export declare class Arc implements Graphics, Equals, Debug {
    constructor(center: R2Point, innerRadius: Length, outerRadius: Length, startAngle: Angle, sweepAngle: Angle, padAngle: Angle, padRadius: Length | null, cornerRadius: Length);
    readonly center: R2Point;
    withCenter(center: AnyR2Point): Arc;
    readonly innerRadius: Length;
    withInnerRadius(innerRadius: AnyLength): Arc;
    readonly outerRadius: Length;
    withOuterRadius(outerRadius: AnyLength): Arc;
    readonly startAngle: Angle;
    withStartAngle(startAngle: AnyAngle): Arc;
    readonly sweepAngle: Angle;
    withSweepAngle(sweepAngle: AnyAngle): Arc;
    readonly padAngle: Angle;
    withPadAngle(padAngle: AnyAngle): Arc;
    readonly padRadius: Length | null;
    withPadRadius(padRadius: AnyLength | null): Arc;
    readonly cornerRadius: Length;
    withCornerRadius(cornerRadius: AnyLength): Arc;
    render(): string;
    render(renderer: GraphicsRenderer, frame?: R2Box): void;
    draw(context: DrawingContext, frame?: R2Box): void;
    protected renderArc(context: DrawingContext, frame: R2Box | undefined): void;
    protected copy(center: R2Point, innerRadius: Length, outerRadius: Length, startAngle: Angle, sweepAngle: Angle, padAngle: Angle, padRadius: Length | null, cornerRadius: Length): Arc;
    toAny(): ArcInit;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static create(center?: AnyR2Point, innerRadius?: AnyLength, outerRadius?: AnyLength, startAngle?: AnyAngle, sweepAngle?: AnyAngle, padAngle?: AnyAngle, padRadius?: AnyLength | null, cornerRadius?: AnyLength): Arc;
    static fromAny(value: AnyArc): Arc;
    private static intersect;
    private static cornerTangents;
    /** @internal */
    static Epsilon: number;
}

/** @public */
export declare interface ArcInit {
    center?: R2Point;
    innerRadius?: AnyLength;
    outerRadius?: AnyLength;
    startAngle?: AnyAngle;
    sweepAngle?: AnyAngle;
    padAngle?: AnyAngle;
    padRadius?: AnyLength | null;
    cornerRadius?: AnyLength;
}

/** @public */
export declare class ArcView extends GraphicsView implements FillView, StrokeView {
    readonly xAlign: Animator<this, number>;
    readonly yAlign: Animator<this, number>;
    readonly center: Animator<this, R2Point, AnyR2Point>;
    readonly innerRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly outerRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly startAngle: ThemeAnimator<this, Angle, AnyAngle>;
    readonly sweepAngle: ThemeAnimator<this, Angle, AnyAngle>;
    readonly padAngle: ThemeAnimator<this, Angle, AnyAngle>;
    readonly padRadius: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly cornerRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly fill: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly stroke: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly strokeWidth: ThemeAnimator<this, Length | null, AnyLength | null>;
    get value(): Arc;
    get state(): Arc;
    setState(arc: Arc | ArcViewInit, timing?: AnyTiming | boolean): void;
    protected layoutArc(): void;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected renderArc(context: PaintingContext, frame: R2Box): void;
    get popoverFrame(): R2Box;
    readonly viewBounds: R2Box;
    protected hitTest(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestArc(x: number, y: number, context: CanvasContext, frame: R2Box): GraphicsView | null;
    init(init: Arc | ArcViewInit): void;
    static fromArc(arc: Arc): ArcView;
}

/** @public */
export declare interface ArcViewInit extends FillViewInit, StrokeViewInit, ArcInit {
}

/** @public */
export declare class AreaPlotController<X = unknown, Y = unknown> extends SeriesPlotController<X, Y> {
    readonly observerType?: Class<AreaPlotControllerObserver<X, Y>>;
    readonly dataPoints: TraitViewControllerSet<this, DataPointTrait<X, Y>, DataPointView<X, Y>, DataPointController<X, Y>> & DataSetControllerDataPointExt<X, Y>;
    static readonly dataPoints: MemberFastenerClass<AreaPlotController, "dataPoints">;
    protected setPlotFill(fill: Look<Color> | Color | null, timing?: AnyTiming | boolean): void;
    protected willSetPlotFill(newFill: Color | null, oldFill: Color | null, plotView: AreaPlotView<X, Y>): void;
    protected onSetPlotFill(newFill: Color | null, oldFill: Color | null, plotView: AreaPlotView<X, Y>): void;
    protected didSetPlotFill(newFill: Color | null, oldFill: Color | null, plotView: AreaPlotView<X, Y>): void;
    readonly plot: TraitViewRef<this, AreaPlotTrait<X, Y>, AreaPlotView<X, Y>>;
    static readonly plot: MemberFastenerClass<AreaPlotController, "plot">;
}

/** @public */
export declare interface AreaPlotControllerObserver<X = unknown, Y = unknown, C extends AreaPlotController<X, Y> = AreaPlotController<X, Y>> extends SeriesPlotControllerObserver<X, Y, C> {
    controllerWillAttachPlotTrait?(plotTrait: AreaPlotTrait<X, Y>, controller: C): void;
    controllerDidDetachPlotTrait?(plotTrait: AreaPlotTrait<X, Y>, controller: C): void;
    controllerWillAttachPlotView?(plotView: AreaPlotView<X, Y>, controller: C): void;
    controllerDidDetachPlotView?(plotView: AreaPlotView<X, Y>, controller: C): void;
    controllerWillSetPlotFill?(newFill: Color | null, oldFill: Color | null, controller: C): void;
    controllerDidSetPlotFill?(newFill: Color | null, oldFill: Color | null, controller: C): void;
}

/** @public */
export declare class AreaPlotTrait<X = unknown, Y = unknown> extends SeriesPlotTrait<X, Y> {
    readonly observerType?: Class<AreaPlotTraitObserver<X, Y>>;
    readonly fill: Property<this, Look<Color> | Color | null, Look<Color> | AnyColor | null>;
}

/** @public */
export declare interface AreaPlotTraitObserver<X = unknown, Y = unknown, R extends AreaPlotTrait<X, Y> = AreaPlotTrait<X, Y>> extends SeriesPlotTraitObserver<X, Y, R> {
    traitWillSetPlotFill?(newFill: Look<Color> | Color | null, oldFill: Look<Color> | Color | null, trait: R): void;
    traitDidSetPlotFill?(newFill: Look<Color> | Color | null, oldFill: Look<Color> | Color | null, trait: R): void;
}

/** @public */
export declare class AreaPlotView<X = unknown, Y = unknown> extends SeriesPlotView<X, Y> implements FillView {
    readonly observerType?: Class<AreaPlotViewObserver<X, Y>>;
    readonly fill: ThemeAnimator<this, Color | null, AnyColor | null>;
    protected renderPlot(context: CanvasContext, frame: R2Box): void;
    protected hitTestPlot(x: number, y: number, renderer: CanvasRenderer): GraphicsView | null;
    init(init: AreaPlotViewInit<X, Y>): void;
}

/** @public */
export declare interface AreaPlotViewInit<X = unknown, Y = unknown> extends SeriesPlotViewInit<X, Y>, FillViewInit {
}

/** @public */
export declare interface AreaPlotViewObserver<X = unknown, Y = unknown, V extends AreaPlotView<X, Y> = AreaPlotView<X, Y>> extends SeriesPlotViewObserver<X, Y, V> {
    viewWillSetPlotFill?(newFill: Color | null, oldFill: Color | null, view: V): void;
    viewDidSetPlotFill?(newFill: Color | null, oldFill: Color | null, view: V): void;
}

/** @public */
export declare interface AttributeAnimator<O = unknown, T = unknown, U = never> extends ThemeAnimator<O, T, U> {
    get attributeName(): string;
    get attributeValue(): T | undefined;
    /** @internal */
    readonly ownValue: T;
    get value(): T;
    set value(value: T);
    /** @override @protected */
    onSetValue(newValue: T, oldValue: T): void;
    parse(value: string): T;
}

/** @public */
export declare const AttributeAnimator: AttributeAnimatorFactory<AttributeAnimator<any, any, any>>;

/** @public */
export declare interface AttributeAnimatorClass<A extends AttributeAnimator<any, any> = AttributeAnimator<any, any, any>> extends ThemeAnimatorClass<A> {
}

/** @public */
export declare type AttributeAnimatorDescriptor<O = unknown, T = unknown, U = never, I = {}> = ThisType<AttributeAnimator<O, T, U> & I> & AttributeAnimatorInit<T, U> & Partial<I>;

/** @public */
export declare interface AttributeAnimatorFactory<A extends AttributeAnimator<any, any> = AttributeAnimator<any, any, any>> extends AttributeAnimatorClass<A> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): AttributeAnimatorFactory<A> & I;
    specialize(type: unknown): AttributeAnimatorFactory | null;
    define<O, T, U = never>(className: string, descriptor: AttributeAnimatorDescriptor<O, T, U>): AttributeAnimatorFactory<AttributeAnimator<any, T, U>>;
    define<O, T, U = never, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & AttributeAnimatorDescriptor<O, T, U, I>): AttributeAnimatorFactory<AttributeAnimator<any, T, U> & I>;
    <O, T extends Length | undefined = Length | undefined, U extends AnyLength | undefined = AnyLength | undefined>(descriptor: {
        type: typeof Length;
    } & AttributeAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends Color | undefined = Color | undefined, U extends AnyColor | undefined = AnyColor | undefined>(descriptor: {
        type: typeof Color;
    } & AttributeAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends Transform | undefined = Transform | undefined, U extends AnyTransform | undefined = AnyTransform | undefined>(descriptor: {
        type: typeof Transform;
    } & AttributeAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends string | undefined = string | undefined, U extends string | undefined = string | undefined>(descriptor: {
        type: typeof String;
    } & AttributeAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends number | undefined = number | undefined, U extends number | string | undefined = number | string | undefined>(descriptor: {
        type: typeof Number;
    } & AttributeAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends boolean | undefined = boolean | undefined, U extends boolean | string | undefined = boolean | string | undefined>(descriptor: {
        type: typeof Boolean;
    } & AttributeAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = never>(descriptor: ({
        type: FromAny<T, U>;
    } | {
        fromAny(value: T | U): T;
    }) & AttributeAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = never>(descriptor: AttributeAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = never, I = {}>(descriptor: {
        implements: unknown;
    } & AttributeAnimatorDescriptor<O, T, U, I>): PropertyDecorator;
}

/** @public */
export declare interface AttributeAnimatorInit<T = unknown, U = never> extends ThemeAnimatorInit<T, U> {
    extends?: {
        prototype: AttributeAnimator<any, any>;
    } | string | boolean | null;
    attributeName: string;
    parse?(value: string): T;
}

/** @public */
export declare abstract class AxisController<D = unknown> extends Controller {
    readonly observerType?: Class<AxisControllerObserver<D>>;
    readonly axis: TraitViewRef<this, AxisTrait<D>, AxisView<D>>;
    static readonly axis: MemberFastenerClass<AxisController, "axis">;
}

/** @public */
export declare interface AxisControllerObserver<D = unknown, C extends AxisController<D> = AxisController<D>> extends ControllerObserver<C> {
    controllerWillAttachAxisTrait?(axisTrait: AxisTrait<D>, controller: C): void;
    controllerDidDetachAxisTrait?(axisTrait: AxisTrait<D>, controller: C): void;
    controllerWillAttachAxisView?(axisView: AxisView<D>, controller: C): void;
    controllerDidDetachAxisView?(axisView: AxisView<D>, controller: C): void;
}

/** @public */
export declare type AxisOrientation = "top" | "right" | "bottom" | "left";

/** @public */
export declare abstract class AxisTrait<D = unknown> extends Trait {
    readonly observerType?: Class<AxisTraitObserver<D>>;
}

/** @public */
export declare interface AxisTraitObserver<D = unknown, R extends AxisTrait<D> = AxisTrait<D>> extends TraitObserver<R> {
}

/** @public */
export declare abstract class AxisView<D = unknown> extends GraphicsView {
    constructor();
    readonly observerType?: Class<AxisViewObserver<D>>;
    abstract readonly orientation: AxisOrientation;
    abstract readonly scale: ContinuousScaleAnimator<this, D, number>;
    /** @internal */
    readonly ticks: BTree<D, TickView<D>>;
    getTick(value: D): TickView<D> | null;
    insertTick(tickView: AnyTickView<D>): TickView<D>;
    removeTick(value: D): TickView<D> | null;
    readonly tickGenerator: Property<this, TickGenerator<D> | true | null>;
    readonly origin: ThemeAnimator<this, R2Point, AnyR2Point>;
    readonly borderColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly borderWidth: ThemeAnimator<this, number>;
    readonly borderSerif: ThemeAnimator<this, number>;
    readonly tickMarkSpacing: ThemeAnimator<this, number>;
    readonly tickMarkColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly tickMarkWidth: ThemeAnimator<this, number>;
    readonly tickMarkLength: ThemeAnimator<this, number>;
    readonly tickLabelPadding: ThemeAnimator<this, number>;
    readonly tickTransition: Property<this, Timing, AnyTiming>;
    readonly gridLineColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly gridLineWidth: ThemeAnimator<this, number>;
    readonly font: ThemeAnimator<this, Font | null, AnyFont | null>;
    readonly textColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    protected updateTicks(): void;
    protected generateTicks(tickGenerator: TickGenerator<D>, scale: ContinuousScale<D, number>, timing: Timing | boolean): void;
    protected createTickView(tickValue: D): TickView<D> | null;
    protected createTickLabel(tickValue: D, tickView: TickView<D>): GraphicsView | string | null;
    protected formatTickLabel(tickLabel: string, tickView: TickView<D>): string | null;
    protected onInsertChild(child: View, target: View | null): void;
    protected onRemoveChild(child: View): void;
    protected needsDisplay(displayFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected displayChild(child: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>): void;
    protected abstract layoutTick(tick: TickView<D>, origin: R2Point, frame: R2Box, scale: ContinuousScale<D, number>): void;
    protected didRender(viewContext: ViewContextType<this>): void;
    protected abstract renderDomain(context: PaintingContext, origin: R2Point, frame: R2Box): void;
    init(init: AxisViewInit<D>): void;
}

/** @public */
export declare interface AxisViewInit<D = unknown> extends GraphicsViewInit {
    scale?: ContinuousScale<D, number> | string;
    ticks?: AnyTickView<D>[];
    tickGenerator?: TickGenerator<D> | true | null;
    borderColor?: AnyColor;
    borderWidth?: number;
    borderSerif?: number;
    tickMarkSpacing?: number;
    tickMarkColor?: AnyColor;
    tickMarkWidth?: number;
    tickMarkLength?: number;
    tickLabelPadding?: number;
    tickTransition?: AnyTiming;
    gridLineColor?: AnyColor;
    gridLineWidth?: number;
    font?: AnyFont;
    textColor?: AnyColor;
}

/** @public */
export declare interface AxisViewObserver<D = unknown, V extends AxisView<D> = AxisView<D>> extends GraphicsViewObserver<V> {
    createTickLabel?(tickValue: D, tickView: TickView<D>, view: V): GraphicsView | string | null;
    formatTickLabel?(tickLabel: string, tickView: TickView<D>, view: V): string | null;
}

/** @public */
export declare type BackgroundClip = "border-box" | "padding-box" | "content-box" | "text";

/** @internal */
export declare const BooleanAttributeAnimator: AttributeAnimatorFactory<AttributeAnimator<any, boolean | undefined, string>>;

/** @internal */
export declare const BooleanThemeAnimator: ThemeAnimatorFactory<ThemeAnimator<any, boolean | null | undefined, string | boolean | null | undefined>>;

/** @public */
export declare type BorderCollapse = "collapse" | "separate";

/** @public */
export declare type BorderStyle = "dashed" | "dotted" | "double" | "groove" | "hidden" | "inset" | "none" | "outset" | "ridge" | "solid";

/** @public */
export declare type BorderWidth = Length | "medium" | "thick" | "thin";

/** @public */
export declare class BottomAxisController<X = unknown> extends AxisController<X> {
    readonly axis: TraitViewRef<this, BottomAxisTrait<X>, BottomAxisView<X>>;
    static readonly axis: MemberFastenerClass<BottomAxisController, "axis">;
}

/** @public */
export declare abstract class BottomAxisTrait<X = unknown> extends AxisTrait<X> {
    readonly observerType?: Class<AxisTraitObserver<X, BottomAxisTrait<X>>>;
}

/** @public */
export declare class BottomAxisView<X = unknown> extends AxisView<X> {
    get orientation(): AxisOrientation;
    readonly scale: ContinuousScaleAnimator<this, X, number>;
    protected layoutTick(tick: TickView<X>, origin: R2Point, frame: R2Box, scale: ContinuousScale<X, number>): void;
    protected renderDomain(context: PaintingContext, origin: R2Point, frame: R2Box): void;
}

/** @public */
export declare class BottomTickView<X = unknown> extends TickView<X> {
    constructor(value: X);
    get orientation(): TickOrientation;
    protected layoutLabel(labelView: GraphicsView): void;
    protected renderTick(context: PaintingContext, frame: R2Box): void;
}

/** @public */
export declare class BoxShadow implements Interpolate<BoxShadow>, Equals, Equivalent {
    constructor(inset: boolean, offsetX: Length, offsetY: Length, blurRadius: Length, spreadRadius: Length, color: Color, next: BoxShadow | null);
    readonly inset: boolean;
    withInset(inset: boolean): BoxShadow;
    readonly offsetX: Length;
    withOffsetX(offsetX: AnyLength): BoxShadow;
    readonly offsetY: Length;
    withOffsetY(offsetY: AnyLength): BoxShadow;
    readonly blurRadius: Length;
    withBlurRadius(blurRadius: AnyLength): BoxShadow;
    readonly spreadRadius: Length;
    withSpreadRadius(spreadRadius: AnyLength): BoxShadow;
    readonly color: Color;
    withColor(color: AnyColor): BoxShadow;
    readonly next: BoxShadow | null;
    and(value: AnyBoxShadow): BoxShadow;
    and(offsetX: AnyLength, offsetY: AnyLength, color: AnyColor): BoxShadow;
    and(offsetX: AnyLength, offsetY: AnyLength, blurRadius: AnyLength, color: AnyColor): BoxShadow;
    and(offsetX: AnyLength, offsetY: AnyLength, blurRadius: AnyLength, spreadRadius: AnyLength, color: AnyColor): BoxShadow;
    and(inset: boolean, offsetX: AnyLength, offsetY: AnyLength, color: AnyColor): BoxShadow;
    and(inset: boolean, offsetX: AnyLength, offsetY: AnyLength, blurRadius: AnyLength, color: AnyColor): BoxShadow;
    and(inset: boolean, offsetX: AnyLength, offsetY: AnyLength, blurRadius: AnyLength, spreadRadius: AnyLength, color: AnyColor): BoxShadow;
    interpolateTo(that: BoxShadow): Interpolator<BoxShadow>;
    interpolateTo(that: unknown): Interpolator<BoxShadow> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    /** @internal */
    readonly stringValue: string | undefined;
    toString(): string;
    static create(value: AnyBoxShadow): BoxShadow;
    static create(offsetX: AnyLength, offsetY: AnyLength, color: AnyColor): BoxShadow;
    static create(offsetX: AnyLength, offsetY: AnyLength, blurRadius: AnyLength, color: AnyColor): BoxShadow;
    static create(offsetX: AnyLength, offsetY: AnyLength, blurRadius: AnyLength, spreadRadius: AnyLength, color: AnyColor): BoxShadow;
    static create(inset: boolean, offsetX: AnyLength, offsetY: AnyLength, color: AnyColor): BoxShadow;
    static create(inset: boolean, offsetX: AnyLength, offsetY: AnyLength, blurRadius: AnyLength, color: AnyColor): BoxShadow;
    static create(inset: boolean, offsetX: AnyLength, offsetY: AnyLength, blurRadius: AnyLength, spreadRadius: AnyLength, color: AnyColor): BoxShadow;
    static fromInit(init: BoxShadowInit): BoxShadow;
    static fromArray(array: ReadonlyArray<BoxShadow>): BoxShadow;
    static fromAny(...values: AnyBoxShadow[]): BoxShadow | null;
    static fromValue(value: Value): BoxShadow | null;
    static parse(string: string): BoxShadow | null;
    /** @internal */
    static isInit(value: unknown): value is BoxShadowInit;
    /** @internal */
    static isArray(value: unknown): value is ReadonlyArray<BoxShadow>;
    /** @internal */
    static isAny(value: unknown): value is AnyBoxShadow;
    static form(): Form<BoxShadow | null, AnyBoxShadow>;
}

/** @internal */
export declare class BoxShadowForm extends Form<BoxShadow | null, AnyBoxShadow> {
    constructor(unit: BoxShadow | null | undefined);
    readonly unit: BoxShadow | null | undefined;
    withUnit(unit: BoxShadow | null | undefined): Form<BoxShadow | null, AnyBoxShadow>;
    mold(boxShadow: AnyBoxShadow): Item;
    cast(item: Item): BoxShadow | null | undefined;
}

/** @public */
export declare interface BoxShadowInit {
    inset?: boolean;
    offsetX?: AnyLength;
    offsetY?: AnyLength;
    blurRadius?: AnyLength;
    spreadRadius?: AnyLength;
    color?: AnyColor;
}

/** @internal */
export declare interface BoxShadowInterpolator extends Interpolator<BoxShadow> {
    /** @internal */
    readonly insetInterpolator: Interpolator<boolean>;
    /** @internal */
    readonly offsetXInterpolator: Interpolator<Length>;
    /** @internal */
    readonly offsetYInterpolator: Interpolator<Length>;
    /** @internal */
    readonly blurRadiusInterpolator: Interpolator<Length>;
    /** @internal */
    readonly spreadRadiusInterpolator: Interpolator<Length>;
    /** @internal */
    readonly colorInterpolator: Interpolator<Color>;
    /** @internal */
    readonly nextInterpolator: Interpolator<BoxShadow | null>;
    get 0(): BoxShadow;
    get 1(): BoxShadow;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const BoxShadowInterpolator: {
    (b0: BoxShadow, b1: BoxShadow): BoxShadowInterpolator;
    /** @internal */
    prototype: BoxShadowInterpolator;
};

/** @internal */
export declare class BoxShadowParser extends Parser<BoxShadow | null> {
    private readonly boxShadow;
    private readonly identOutput;
    private readonly offsetXParser;
    private readonly offsetYParser;
    private readonly blurRadiusParser;
    private readonly spreadRadiusParser;
    private readonly colorParser;
    private readonly step;
    constructor(boxShadow?: BoxShadow, identOutput?: Output<string>, offsetXParser?: Parser<Length>, offsetYParser?: Parser<Length>, blurRadiusParser?: Parser<Length>, spreadRadiusParser?: Parser<Length>, colorParser?: Parser<Color>, step?: number);
    feed(input: Input): Parser<BoxShadow | null>;
    static parse(input: Input, boxShadow?: BoxShadow, identOutput?: Output<string>, offsetXParser?: Parser<Length>, offsetYParser?: Parser<Length>, blurRadiusParser?: Parser<Length>, spreadRadiusParser?: Parser<Length>, colorParser?: Parser<Color>, step?: number): Parser<BoxShadow | null>;
}

/** @internal */
export declare const BoxShadowStyleAnimator: StyleAnimatorFactory<StyleAnimator<any, BoxShadow | null, AnyBoxShadow | null>>;

/** @public */
export declare type BoxSizing = "border-box" | "content-box";

/** @public */
export declare class BrightnessFeel extends Feel {
    combine<T>(look: Look<T, any>, combination: T | undefined, value: T, weight?: number): T;
}

/** @public */
export declare class BubblePlotController<X = unknown, Y = unknown> extends ScatterPlotController<X, Y> {
    readonly observerType?: Class<BubblePlotControllerObserver<X, Y>>;
    readonly dataPoints: TraitViewControllerSet<this, DataPointTrait<X, Y>, DataPointView<X, Y>, DataPointController<X, Y>> & DataSetControllerDataPointExt<X, Y>;
    static readonly dataPoints: MemberFastenerClass<BubblePlotController, "dataPoints">;
    protected setPlotRadius(radius: Length | null, timing?: AnyTiming | boolean): void;
    protected setPlotFill(fill: Look<Color> | Color | null, timing?: AnyTiming | boolean): void;
    readonly plot: TraitViewRef<this, BubblePlotTrait<X, Y>, BubblePlotView<X, Y>>;
    static readonly plot: MemberFastenerClass<BubblePlotController, "plot">;
}

/** @public */
export declare interface BubblePlotControllerObserver<X = unknown, Y = unknown, C extends BubblePlotController<X, Y> = BubblePlotController<X, Y>> extends ScatterPlotControllerObserver<X, Y, C> {
    controllerWillAttachPlotTrait?(plotTrait: BubblePlotTrait<X, Y>, controller: C): void;
    controllerDidDetachPlotTrait?(plotTrait: BubblePlotTrait<X, Y>, controller: C): void;
    controllerWillAttachPlotView?(plotView: BubblePlotView<X, Y>, controller: C): void;
    controllerDidDetachPlotView?(plotView: BubblePlotView<X, Y>, controller: C): void;
    controllerWillSetPlotRadius?(newRadius: Length | null, oldRadius: Length | null, controller: C): void;
    controllerDidSetPlotRadius?(newRadius: Length | null, oldRadius: Length | null, controller: C): void;
    controllerWillSetPlotFill?(newFill: Color | null, oldFill: Color | null, controller: C): void;
    controllerDidSetPlotFill?(newFill: Color | null, oldFill: Color | null, controller: C): void;
}

/** @public */
export declare class BubblePlotTrait<X = unknown, Y = unknown> extends ScatterPlotTrait<X, Y> {
    readonly observerType?: Class<BubblePlotTraitObserver<X, Y>>;
    readonly radius: Property<this, Length | null, AnyLength | null>;
    readonly fill: Property<this, Look<Color> | Color | null, Look<Color> | AnyColor | null>;
}

/** @public */
export declare interface BubblePlotTraitObserver<X = unknown, Y = unknown, R extends BubblePlotTrait<X, Y> = BubblePlotTrait<X, Y>> extends ScatterPlotTraitObserver<X, Y, R> {
    traitWillSetPlotRadius?(newRadius: Length | null, oldRadius: Length | null, trait: R): void;
    traitDidSetPlotRadius?(newRadius: Length | null, oldRadius: Length | null, trait: R): void;
    traitWillSetPlotFill?(newFill: Look<Color> | Color | null, oldFill: Look<Color> | Color | null, trait: R): void;
    traitDidSetPlotFill?(newFill: Look<Color> | Color | null, oldFill: Look<Color> | Color | null, trait: R): void;
}

/** @public */
export declare class BubblePlotView<X = unknown, Y = unknown> extends ScatterPlotView<X, Y> implements FillView, StrokeView {
    readonly observerType?: Class<BubblePlotViewObserver<X, Y>>;
    readonly radius: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly fill: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly stroke: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly strokeWidth: ThemeAnimator<this, Length | null, AnyLength | null>;
    protected renderPlot(context: CanvasContext, frame: R2Box): void;
    init(init: BubblePlotViewInit<X, Y>): void;
}

/** @public */
export declare interface BubblePlotViewInit<X = unknown, Y = unknown> extends ScatterPlotViewInit<X, Y>, FillViewInit, StrokeViewInit {
    radius?: AnyLength;
}

/** @public */
export declare interface BubblePlotViewObserver<X = unknown, Y = unknown, V extends BubblePlotView<X, Y> = BubblePlotView<X, Y>> extends ScatterPlotViewObserver<X, Y, V> {
    viewWillSetPlotRadius?(newRadius: Length | null, oldRadius: Length | null, view: V): void;
    viewDidSetPlotRadius?(newRadius: Length | null, oldRadius: Length | null, view: V): void;
    viewWillSetPlotFill?(newFill: Color | null, oldFill: Color | null, view: V): void;
    viewDidSetPlotFill?(newFill: Color | null, oldFill: Color | null, view: V): void;
}

/** @public */
export declare class ButtonGlow extends HtmlView {
    constructor(node: HTMLElement);
    protected initGlow(): void;
    readonly glowState: ButtonGlowState;
    /** @internal */
    glowTimer: number;
    readonly left: StyleConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly opacity: StyleAnimator<this, number | undefined>;
    protected didMount(): void;
    protected onUnmount(): void;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    glow(clientX: number, clientY: number, timing?: AnyTiming | boolean, delay?: number): void;
    protected willGlow(): void;
    protected didGlow(): void;
    cancelGlow(): void;
    pulse(clientX: number, clientY: number, timing?: AnyTiming | boolean): void;
    protected willPulse(): void;
    protected didPulse(): void;
    fade(clientX: number, clientY: number, timing?: AnyTiming | boolean): void;
    protected willFade(): void;
    protected didFade(): void;
}

/** @public */
export declare type ButtonGlowState = "ready" | "glowing" | "pulsing" | "fading";

/** @public */
export declare class ButtonItem extends HtmlView {
    constructor(node: HTMLElement);
    protected initButtonItem(): void;
    protected createButton(): FloatingButton | null;
    get button(): FloatingButton | null;
    get icon(): HtmlIconView | null;
    get label(): HtmlView | null;
    readonly disclosure: ExpansionThemeAnimator<this, Expansion | undefined, AnyExpansion | undefined>;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected onInsertChild(childView: View, targetView: View | null): void;
    protected onRemoveChild(childView: View): void;
    protected onInsertButton(button: FloatingButton): void;
    protected onRemoveButton(button: FloatingButton): void;
    protected onInsertLabel(label: HtmlView): void;
    protected onRemoveLabel(label: HtmlView): void;
}

/** @public */
export declare class ButtonMembrane extends HtmlView {
    constructor(node: HTMLElement);
    protected initMembrane(node: HTMLElement): void;
    readonly glows: Property<this, boolean>;
    protected glow(input: PositionGestureInput): void;
    readonly gesture: PositionGesture<this, HtmlView>;
    static readonly gesture: MemberFastenerClass<ButtonMembrane, "gesture">;
    init(init: ButtonMembraneInit): void;
}

/** @public */
export declare interface ButtonMembraneInit extends HtmlViewInit {
}

/** @public */
export declare interface ButtonObserver<V extends View = View> extends ViewObserver<V> {
    buttonDidPress?(view: V): void;
}

/** @public */
export declare class ButtonStack extends HtmlView implements Modal {
    constructor(node: HTMLElement);
    protected initButtonStack(): void;
    protected initButton(): void;
    readonly observerType?: Class<ButtonStackObserver>;
    /** @internal */
    readonly stackHeight: number;
    protected createButton(): HtmlView | null;
    readonly gesture: PositionGesture<this, HtmlView>;
    static readonly gesture: MemberFastenerClass<ButtonStack, "gesture">;
    readonly disclosure: ExpansionThemeAnimator<this>;
    readonly buttonSpacing: ThemeAnimator<this, number>;
    readonly itemSpacing: ThemeAnimator<this, number>;
    readonly opacity: StyleAnimator<this, number | undefined>;
    get modalView(): View | null;
    get modalState(): ModalState;
    get modality(): boolean | number;
    showModal(options: ModalOptions, timing?: AnyTiming | boolean): void;
    hideModal(timing?: AnyTiming | boolean): void;
    get button(): HtmlView | null;
    get closeIcon(): Graphics;
    get items(): ReadonlyArray<ButtonItem>;
    insertItem(item: ButtonItem, index?: number, key?: string): void;
    removeItems(): void;
    protected onMount(): void;
    protected onUnmount(): void;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected layoutStack(): void;
    protected onInsertChild(childView: View, targetView: View | null): void;
    protected onRemoveChild(childView: View): void;
    protected onInsertButton(button: HtmlView): void;
    protected onRemoveButton(button: HtmlView): void;
    protected onInsertItem(item: ButtonItem): void;
    protected onRemoveItem(item: ButtonItem): void;
    protected willExpand(): void;
    protected onExpand(): void;
    protected didExpand(): void;
    protected willCollapse(): void;
    protected onCollapse(): void;
    protected didCollapse(): void;
    show(timing?: AnyTiming | boolean): void;
    protected willShowStack(): void;
    protected didShowStack(): void;
    hide(timing?: AnyTiming | boolean): void;
    protected willHideStack(): void;
    protected didHideStack(): void;
    protected onClick(event: MouseEvent): void;
    protected onContextMenu(event: MouseEvent): void;
    static get closeIcon(): Graphics;
}

/** @public */
export declare interface ButtonStackObserver<V extends ButtonStack = ButtonStack> extends HtmlViewObserver<V> {
    buttonStackWillExpand?(view: V): void;
    buttonStackDidExpand?(view: V): void;
    buttonStackWillCollapse?(view: V): void;
    buttonStackDidCollapse?(view: V): void;
    buttonStackWillShow?(view: V): void;
    buttonStackDidShow?(view: V): void;
    buttonStackWillHide?(view: V): void;
    buttonStackDidHide?(view: V): void;
}

/** @public */
export declare type CanvasCompositeOperation = "source-over" | "source-in" | "source-out" | "source-atop" | "destination-over" | "destination-in" | "destination-out" | "destination-atop" | "lighter" | "copy" | "xor" | "multiply" | "screen" | "overlay" | "darken" | "lighten" | "color-dodge" | "color-burn" | "hard-light" | "soft-light" | "difference" | "exclusion" | "hue" | "saturation" | "color" | "luminosity";

/** @public */
export declare interface CanvasContext extends PaintingContext {
    save(): void;
    restore(): void;
    rotate(angle: number): void;
    scale(x: number, y: number): void;
    setTransform(x0: number, y0: number, x1: number, y1: number, tx: number, ty: number): void;
    setTransform(transform?: DOMMatrix2DInit): void;
    transform(x0: number, y0: number, x1: number, y1: number, tx: number, ty: number): void;
    translate(x: number, y: number): void;
    globalAlpha: number;
    globalCompositeOperation: string;
    imageSmoothingEnabled: boolean;
    imageSmoothingQuality: ImageSmoothingQuality;
    fillStyle: string | CanvasGradient | CanvasPattern;
    strokeStyle: string | CanvasGradient | CanvasPattern;
    createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient;
    createPattern(image: CanvasImageSource, repetition: string): CanvasPattern | null;
    createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient;
    shadowBlur: number;
    shadowColor: string;
    shadowOffsetX: number;
    shadowOffsetY: number;
    filter: string;
    clearRect(x: number, y: number, w: number, h: number): void;
    fillRect(x: number, y: number, w: number, h: number): void;
    strokeRect(x: number, y: number, w: number, h: number): void;
    beginPath(): void;
    clip(fillRule?: CanvasFillRule): void;
    fill(fillRule?: CanvasFillRule): void;
    isPointInPath(x: number, y: number, fillRule?: CanvasFillRule): boolean;
    isPointInStroke(x: number, y: number): boolean;
    stroke(): void;
    fillText(text: string, x: number, y: number, maxWidth?: number): void;
    measureText(text: string): TextMetrics;
    strokeText(text: string, x: number, y: number, maxWidth?: number): void;
    drawImage(image: CanvasImageSource, dx: number, dy: number): void;
    drawImage(image: CanvasImageSource, dx: number, dy: number, dw: number, dh: number): void;
    drawImage(image: CanvasImageSource, sx: number, sy: number, sw: number, sh: number, dx: number, dy: number, dw: number, dh: number): void;
    createImageData(sw: number, sh: number): ImageData;
    createImageData(imagedata: ImageData): ImageData;
    getImageData(sx: number, sy: number, sw: number, sh: number): ImageData;
    putImageData(imagedata: ImageData, dx: number, dy: number): void;
    putImageData(imagedata: ImageData, dx: number, dy: number, dirtyX: number, dirtyY: number, dirtyWidth: number, dirtyHeight: number): void;
    lineCap: CanvasLineCap;
    lineDashOffset: number;
    lineJoin: CanvasLineJoin;
    lineWidth: number;
    miterLimit: number;
    getLineDash(): number[];
    setLineDash(segments: number[]): void;
    direction: CanvasDirection;
    font: string;
    textAlign: CanvasTextAlign;
    textBaseline: CanvasTextBaseline;
    arc(cx: number, cy: number, r: number, a0: number, a1: number, ccw?: boolean): void;
    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;
    bezierCurveTo(x1: number, y1: number, x2: number, y2: number, x: number, y: number): void;
    closePath(): void;
    ellipse(cx: number, cy: number, rx: number, ry: number, phi: number, a0: number, a1: number, ccw?: boolean): void;
    lineTo(x: number, y: number): void;
    moveTo(x: number, y: number): void;
    quadraticCurveTo(x1: number, y1: number, x: number, y: number): void;
    rect(x: number, y: number, w: number, h: number): void;
}

/** @internal */
export declare type CanvasFlags = number;

/** @public */
export declare class CanvasRenderer extends PaintingRenderer {
    constructor(context: CanvasContext, transform: Transform, pixelRatio: number);
    readonly context: CanvasContext;
    readonly transform: Transform;
    setTransform(transform: Transform): void;
    readonly pixelRatio: number;
}

/** @public */
export declare class CanvasView extends HtmlView {
    constructor(node: HTMLCanvasElement);
    readonly observerType?: Class<CanvasViewObserver>;
    readonly contextType?: Class<GraphicsViewContext>;
    readonly node: HTMLCanvasElement;
    protected initCanvas(): void;
    protected onMount(): void;
    protected onUnmount(): void;
    protected needsUpdate(updateFlags: ViewFlags, immediate: boolean): ViewFlags;
    protected needsProcess(processFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    protected onResize(viewContext: ViewContextType<this>): void;
    protected onScroll(viewContext: ViewContextType<this>): void;
    protected didDisplay(displayFlags: ViewFlags, viewContext: ViewContextType<this>): void;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected needsDisplay(displayFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    readonly spriteProvider: Provider<this, SpriteService>;
    get pixelRatio(): number;
    readonly renderer: GraphicsRenderer | null;
    setRenderer(renderer: AnyGraphicsRenderer | null): void;
    protected createRenderer(rendererType?: GraphicsRendererType): GraphicsRenderer | null;
    /** @internal */
    readonly canvasFlags: CanvasFlags;
    /** @internal */
    setCanvasFlags(canvasFlags: CanvasFlags): void;
    extendViewContext(viewContext: ViewContext): ViewContextType<this>;
    /** @internal */
    readonly viewFrame: R2Box;
    setViewFrame(viewFrame: R2Box | null): void;
    get viewBounds(): R2Box;
    get hitBounds(): R2Box;
    cascadeHitTest(x: number, y: number, baseViewContext?: ViewContext): GraphicsView | null;
    protected hitTest(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestChildren(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestChild(childView: GraphicsView, x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    /** @internal */
    protected detectHitTargets(clientBounds?: R2Box): void;
    readonly eventNode: HTMLElement;
    setEventNode(newEventNode: HTMLElement | null): void;
    clickEventsEnabled(): boolean;
    clickEventsEnabled(clickEvents: boolean): this;
    wheelEventsEnabled(): boolean;
    wheelEventsEnabled(wheelEvents: boolean): this;
    mouseEventsEnabled(): boolean;
    mouseEventsEnabled(mouseEvents: boolean): this;
    pointerEventsEnabled(): boolean;
    pointerEventsEnabled(pointerEvents: boolean): this;
    touchEventsEnabled(): boolean;
    touchEventsEnabled(touchEvents: boolean): this;
    /** @internal */
    handleEvent(event: ViewEvent): void;
    /** @internal */
    bubbleEvent(event: ViewEvent): View | null;
    /** @internal */
    protected attachEvents(eventNode: HTMLElement): void;
    /** @internal */
    protected detachEvents(eventNode: HTMLElement): void;
    /** @internal */
    fireEvent(event: ViewEvent, clientX: number, clientY: number): GraphicsView | null;
    /** @internal */
    protected attachClickEvents(eventNode: HTMLElement): void;
    /** @internal */
    protected detachClickEvents(eventNode: HTMLElement): void;
    /** @internal */
    protected attachWheelEvents(eventNode: HTMLElement): void;
    /** @internal */
    protected detachWheelEvents(eventNode: HTMLElement): void;
    /** @internal */
    protected attachPassiveMouseEvents(eventNode: HTMLElement): void;
    /** @internal */
    protected detachPassiveMouseEvents(eventNode: HTMLElement): void;
    /** @internal */
    protected attachActiveMouseEvents(eventNode: HTMLElement): void;
    /** @internal */
    protected detachActiveMouseEvents(eventNode: HTMLElement): void;
    /** @internal */
    readonly mouse: ViewMouseEventInit | null;
    /** @internal */
    protected updateMouse(mouse: ViewMouseEventInit, event: MouseEvent): void;
    /** @internal */
    protected fireMouseEvent(event: MouseEvent): GraphicsView | null;
    /** @internal */
    protected onClick(event: MouseEvent): void;
    /** @internal */
    protected onDblClick(event: MouseEvent): void;
    /** @internal */
    protected onContextMenu(event: MouseEvent): void;
    /** @internal */
    protected onWheel(event: WheelEvent): void;
    /** @internal */
    protected onMouseEnter(event: MouseEvent): void;
    /** @internal */
    protected onMouseLeave(event: MouseEvent): void;
    /** @internal */
    protected onMouseDown(event: MouseEvent): void;
    /** @internal */
    protected onMouseMove(event: MouseEvent): void;
    /** @internal */
    protected onMouseUp(event: MouseEvent): void;
    /** @internal */
    protected onMouseTargetChange(mouse: ViewMouseEventInit, newTargetView: GraphicsView | undefined, oldTargetView: GraphicsView | undefined): void;
    /** @internal */
    protected detectMouseTarget(mouse: ViewMouseEventInit, clientBounds: R2Box): void;
    /** @internal */
    protected attachPassivePointerEvents(eventNode: HTMLElement): void;
    /** @internal */
    protected detachPassivePointerEvents(eventNode: HTMLElement): void;
    /** @internal */
    protected attachActivePointerEvents(eventNode: HTMLElement): void;
    /** @internal */
    protected detachActivePointerEvents(eventNode: HTMLElement): void;
    /** @internal */
    readonly pointers: {
        [id: string]: ViewPointerEventInit | undefined;
    } | null;
    /** @internal */
    protected updatePointer(pointer: ViewPointerEventInit, event: PointerEvent): void;
    /** @internal */
    protected firePointerEvent(event: PointerEvent): GraphicsView | null;
    /** @internal */
    protected onPointerEnter(event: PointerEvent): void;
    /** @internal */
    protected onPointerLeave(event: PointerEvent): void;
    /** @internal */
    protected onPointerDown(event: PointerEvent): void;
    /** @internal */
    protected onPointerMove(event: PointerEvent): void;
    /** @internal */
    protected onPointerUp(event: PointerEvent): void;
    /** @internal */
    protected onPointerCancel(event: PointerEvent): void;
    /** @internal */
    protected onPointerTargetChange(pointer: ViewPointerEventInit, newTargetView: GraphicsView | undefined, oldTargetView: GraphicsView | undefined): void;
    /** @internal */
    protected detectPointerTarget(pointer: ViewPointerEventInit, clientBounds: R2Box): void;
    /** @internal */
    protected attachPassiveTouchEvents(eventNode: HTMLElement): void;
    /** @internal */
    protected detachPassiveTouchEvents(eventNode: HTMLElement): void;
    /** @internal */
    protected attachActiveTouchEvents(eventNode: HTMLElement): void;
    /** @internal */
    protected detachActiveTouchEvents(eventNode: HTMLElement): void;
    /** @internal */
    readonly touches: {
        [id: string]: ViewTouchInit | undefined;
    } | null;
    /** @internal */
    protected updateTouch(touch: ViewTouchInit, event: Touch): void;
    /** @internal */
    protected fireTouchEvent(type: string, originalEvent: TouchEvent): void;
    /** @internal */
    protected onTouchStart(event: TouchEvent): void;
    /** @internal */
    protected onTouchMove(event: TouchEvent): void;
    /** @internal */
    protected onTouchEnd(event: TouchEvent): void;
    /** @internal */
    protected onTouchCancel(event: TouchEvent): void;
    protected resizeCanvas(canvas: HTMLCanvasElement): void;
    clearCanvas(): void;
    resetRenderer(): void;
    protected onObserve(observer: ObserverType<this>): void;
    protected onUnobserve(observer: ObserverType<this>): void;
    init(init: CanvasViewInit): void;
    /** @internal */
    static readonly tag: string;
    /** @internal */
    static readonly ClickEventsFlag: CanvasFlags;
    /** @internal */
    static readonly WheelEventsFlag: CanvasFlags;
    /** @internal */
    static readonly MouseEventsFlag: CanvasFlags;
    /** @internal */
    static readonly PointerEventsFlag: CanvasFlags;
    /** @internal */
    static readonly TouchEventsFlag: CanvasFlags;
    /** @internal */
    static readonly EventsMask: CanvasFlags;
    static readonly UncullFlags: ViewFlags;
    static readonly UnhideFlags: ViewFlags;
}

/** @public */
export declare interface CanvasViewInit extends HtmlViewInit {
    renderer?: AnyGraphicsRenderer;
    clickEventsEnabled?: boolean;
    wheelEventsEnabled?: boolean;
    mouseEventsEnabled?: boolean;
    pointerEventsEnabled?: boolean;
    touchEventsEnabled?: boolean;
}

/** @public */
export declare interface CanvasViewObserver<V extends CanvasView = CanvasView> extends HtmlViewObserver<V> {
}

/** @public */
export declare class CellController extends Controller {
    readonly observerType?: Class<CellControllerObserver>;
    readonly cell: TraitViewRef<this, CellTrait, CellView>;
    static readonly cell: MemberFastenerClass<CellController, "cell">;
    static fromTrait(cellTrait: CellTrait): CellController;
}

/** @public */
export declare interface CellControllerObserver<C extends CellController = CellController> extends ControllerObserver<C> {
    controllerWillAttachCellTrait?(cellTrait: CellTrait, controller: C): void;
    controllerDidDetachCellTrait?(cellTrait: CellTrait, controller: C): void;
    controllerWillAttachCellView?(cellView: CellView, controller: C): void;
    controllerDidDetachCellView?(cellView: CellView, controller: C): void;
    controllerDidPressCellView?(input: PositionGestureInput, event: Event | null, cellView: CellView, controller: C): void;
    controllerDidLongPressCellView?(input: PositionGestureInput, cellView: CellView, controller: C): void;
}

/** @public */
export declare class CellTrait extends Trait {
    readonly observerType?: Class<CellTraitObserver>;
}

/** @public */
export declare interface CellTraitObserver<T extends CellTrait = CellTrait> extends TraitObserver<T> {
}

/** @public */
export declare class CellView extends HtmlView {
    constructor(node: HTMLElement);
    protected initCell(): void;
    readonly observerType?: Class<CellViewObserver>;
    onPress(input: PositionGestureInput, event: Event | null): void;
    didPress(input: PositionGestureInput, event: Event | null): void;
    onLongPress(input: PositionGestureInput): void;
    didLongPress(input: PositionGestureInput): void;
}

/** @public */
export declare interface CellViewObserver<V extends CellView = CellView> extends HtmlViewObserver<V> {
    viewDidPress?(input: PositionGestureInput, event: Event | null, view: V): void;
    viewDidLongPress?(input: PositionGestureInput, view: V): void;
}

/** @public */
export declare class ChartController<X = unknown, Y = unknown> extends GraphController<X, Y> {
    readonly observerType?: Class<ChartControllerObserver<X, Y>>;
    readonly chart: TraitViewRef<this, ChartTrait<X, Y>, ChartView<X, Y>>;
    static readonly chart: MemberFastenerClass<ChartController, "chart">;
    readonly graph: TraitViewRef<this, GraphTrait<X, Y>, GraphView<X, Y>>;
    static readonly graph: MemberFastenerClass<ChartController, "graph">;
    readonly topAxis: TraitViewControllerRef<this, AxisTrait<X>, AxisView<X>, AxisController<X>>;
    static readonly topAxis: MemberFastenerClass<ChartController, "topAxis">;
    readonly rightAxis: TraitViewControllerRef<this, AxisTrait<Y>, AxisView<Y>, AxisController<Y>>;
    static readonly rightAxis: MemberFastenerClass<ChartController, "rightAxis">;
    readonly bottomAxis: TraitViewControllerRef<this, AxisTrait<X>, AxisView<X>, AxisController<X>>;
    static readonly bottomAxis: MemberFastenerClass<ChartController, "bottomAxis">;
    readonly leftAxis: TraitViewControllerRef<this, AxisTrait<Y>, AxisView<Y>, AxisController<Y>>;
    static readonly leftAxis: MemberFastenerClass<ChartController, "leftAxis">;
}

/** @public */
export declare interface ChartControllerAxisExt<D = unknown> {
    attachAxisTrait(axisTrait: AxisTrait<D>): void;
    detachAxisTrait(axisTrait: AxisTrait<D>): void;
    attachAxisView(axisView: AxisView<D>): void;
    detachAxisView(axisView: AxisView<D>): void;
}

/** @public */
export declare interface ChartControllerObserver<X = unknown, Y = unknown, C extends ChartController<X, Y> = ChartController<X, Y>> extends GraphControllerObserver<X, Y, C> {
    controllerWillAttachChartTrait?(chartTrait: ChartTrait<X, Y>, controller: C): void;
    controllerDidDetachChartTrait?(chartTrait: ChartTrait<X, Y>, controller: C): void;
    controllerWillAttachChartView?(chartView: ChartView<X, Y>, controller: C): void;
    controllerDidDetachChartView?(chartView: ChartView<X, Y>, controller: C): void;
    controllerWillAttachTopAxis?(topAxisController: AxisController<X>, controller: C): void;
    controllerDidDetachTopAxis?(topAxisController: AxisController<X>, controller: C): void;
    controllerWillAttachTopAxisTrait?(topAxisTrait: AxisTrait<X>, controller: C): void;
    controllerDidDetachTopAxisTrait?(topAxisTrait: AxisTrait<X>, controller: C): void;
    controllerWillAttachTopAxisView?(topAxisView: AxisView<X>, controller: C): void;
    controllerDidDetachTopAxisView?(topAxisView: AxisView<X>, controller: C): void;
    controllerWillAttachRightAxis?(rightAxisController: AxisController<Y>, controller: C): void;
    controllerDidDetachRightAxis?(rightAxisController: AxisController<Y>, controller: C): void;
    controllerWillAttachRightAxisTrait?(rightAxisTrait: AxisTrait<Y>, controller: C): void;
    controllerDidDetachRightAxisTrait?(rightAxisTrait: AxisTrait<Y>, controller: C): void;
    controllerWillAttachRightAxisView?(rightAxisView: AxisView<Y>, controller: C): void;
    controllerDidDetachRightAxisView?(rightAxisView: AxisView<Y>, controller: C): void;
    controllerWillAttachBottomAxis?(bottomAxisController: AxisController<X>, controller: C): void;
    controllerDidDetachBottomAxis?(bottomAxisController: AxisController<X>, controller: C): void;
    controllerWillAttachBottomAxisTrait?(bottomAxisTrait: AxisTrait<X>, controller: C): void;
    controllerDidDetachBottomAxisTrait?(bottomAxisTrait: AxisTrait<X>, controller: C): void;
    controllerWillAttachBottomAxisView?(bottomAxisView: AxisView<X>, controller: C): void;
    controllerDidDetachBottomAxisView?(bottomAxisView: AxisView<X>, controller: C): void;
    controllerWillAttachLeftAxis?(leftAxisController: AxisController<Y>, controller: C): void;
    controllerDidDetachLeftAxis?(leftAxisController: AxisController<Y>, controller: C): void;
    controllerWillAttachLeftAxisTrait?(leftAxisTrait: AxisTrait<Y>, controller: C): void;
    controllerDidDetachLeftAxisTrait?(leftAxisTrait: AxisTrait<Y>, controller: C): void;
    controllerWillAttachLeftAxisView?(leftAxisView: AxisView<Y>, controller: C): void;
    controllerDidDetachLeftAxisView?(leftAxisView: AxisView<Y>, controller: C): void;
}

/** @public */
export declare class ChartTrait<X = unknown, Y = unknown> extends Trait {
    readonly observerType?: Class<ChartTraitObserver<X, Y>>;
    readonly graph: TraitRef<this, GraphTrait<X, Y>>;
    static readonly graph: MemberFastenerClass<ChartTrait, "graph">;
    readonly topAxis: TraitRef<this, AxisTrait<X>>;
    static readonly topAxis: MemberFastenerClass<ChartTrait, "topAxis">;
    readonly rightAxis: TraitRef<this, AxisTrait<Y>>;
    static readonly rightAxis: MemberFastenerClass<ChartTrait, "rightAxis">;
    readonly bottomAxis: TraitRef<this, AxisTrait<X>>;
    static readonly bottomAxis: MemberFastenerClass<ChartTrait, "bottomAxis">;
    readonly leftAxis: TraitRef<this, AxisTrait<Y>>;
    static readonly leftAxis: MemberFastenerClass<ChartTrait, "leftAxis">;
    protected onStartConsuming(): void;
    protected onStopConsuming(): void;
}

/** @public */
export declare interface ChartTraitObserver<X = unknown, Y = unknown, R extends ChartTrait<X, Y> = ChartTrait<X, Y>> extends TraitObserver<R> {
    traitWillAttachGraph?(graphTrait: GraphTrait<X, Y>, trait: R): void;
    traitDidDetachGraph?(graphTrait: GraphTrait<X, Y>, trait: R): void;
    traitWillAttachTopAxis?(topAxisTrait: AxisTrait<X>, trait: R): void;
    traitDidDetachTopAxis?(topAxisTrait: AxisTrait<X>, trait: R): void;
    traitWillAttachRightAxis?(rightAxisTrait: AxisTrait<Y>, trait: R): void;
    traitDidDetachRightAxis?(rightAxisTrait: AxisTrait<Y>, trait: R): void;
    traitWillAttachBottomAxis?(bottomAxisTrait: AxisTrait<X>, trait: R): void;
    traitDidDetachBottomAxis?(bottomAxisTrait: AxisTrait<X>, trait: R): void;
    traitWillAttachLeftAxis?(leftAxisTrait: AxisTrait<Y>, trait: R): void;
    traitDidDetachLeftAxis?(leftAxisTrait: AxisTrait<Y>, trait: R): void;
}

/** @public */
export declare class ChartView<X = unknown, Y = unknown> extends ScaledView<X, Y> {
    readonly observerType?: Class<ChartViewObserver<X, Y>>;
    readonly gutterTop: ThemeAnimator<this, Length, AnyLength>;
    readonly gutterRight: ThemeAnimator<this, Length, AnyLength>;
    readonly gutterBottom: ThemeAnimator<this, Length, AnyLength>;
    readonly gutterLeft: ThemeAnimator<this, Length, AnyLength>;
    readonly borderColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly borderWidth: ThemeAnimator<this, number>;
    readonly borderSerif: ThemeAnimator<this, number>;
    readonly tickMarkColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly tickMarkWidth: ThemeAnimator<this, number>;
    readonly tickMarkLength: ThemeAnimator<this, number>;
    readonly tickLabelPadding: ThemeAnimator<this, number>;
    readonly tickTransition: Property<this, Timing, AnyTiming>;
    readonly gridLineColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly gridLineWidth: ThemeAnimator<this, number>;
    readonly font: ThemeAnimator<this, Font | null, AnyFont | null>;
    readonly textColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    xRange(): Range_2<number> | null;
    yRange(): Range_2<number> | null;
    readonly graph: ViewRef<this, GraphView<X, Y>>;
    static readonly graph: MemberFastenerClass<ChartView, "graph">;
    readonly topAxis: ViewRef<this, AxisView<X> & Initable<AxisViewInit<X> | true>>;
    static readonly topAxis: MemberFastenerClass<ChartView, "topAxis">;
    readonly rightAxis: ViewRef<this, AxisView<Y> & Initable<AxisViewInit<Y> | true>>;
    static readonly rightAxis: MemberFastenerClass<ChartView, "rightAxis">;
    readonly bottomAxis: ViewRef<this, AxisView<X> & Initable<AxisViewInit<X> | true>>;
    static readonly bottomAxis: MemberFastenerClass<ChartView, "bottomAxis">;
    readonly leftAxis: ViewRef<this, AxisView<Y> & Initable<AxisViewInit<Y> | true>>;
    static readonly leftAxis: MemberFastenerClass<ChartView, "leftAxis">;
    protected updateScales(): void;
    protected layoutChart(frame: R2Box): void;
    init(init: ChartViewInit<X, Y>): void;
}

/** @public */
export declare interface ChartViewInit<X = unknown, Y = unknown> extends ScaledViewInit<X, Y> {
    graph?: AnyGraphView<X, Y>;
    topAxis?: AnyAxisView<X> | true;
    rightAxis?: AnyAxisView<Y> | true;
    bottomAxis?: AnyAxisView<X> | true;
    leftAxis?: AnyAxisView<Y> | true;
    gutterTop?: AnyLength;
    gutterRight?: AnyLength;
    gutterBottom?: AnyLength;
    gutterLeft?: AnyLength;
    borderColor?: AnyColor;
    borderWidth?: number;
    borderSerif?: number;
    tickMarkColor?: AnyColor;
    tickMarkWidth?: number;
    tickMarkLength?: number;
    tickLabelPadding?: number;
    tickTransition?: AnyTiming;
    gridLineColor?: AnyColor;
    gridLineWidth?: number;
    font?: AnyFont;
    textColor?: AnyColor;
}

/** @public */
export declare interface ChartViewObserver<X = unknown, Y = unknown, V extends ChartView<X, Y> = ChartView<X, Y>> extends ScaledViewObserver<X, Y, V> {
    viewWillAttachGraph?(graphView: GraphView<X, Y>, view: V): void;
    viewDidDetachGraph?(graphView: GraphView<X, Y>, view: V): void;
    viewWillAttachTopAxis?(topAxisView: AxisView<X>, view: V): void;
    viewDidDetachTopAxis?(topAxisView: AxisView<X>, view: V): void;
    viewWillAttachRightAxis?(rightAxisView: AxisView<Y>, view: V): void;
    viewDidDetachRightAxis?(rightAxisView: AxisView<Y>, view: V): void;
    viewWillAttachBottomAxis?(bottomAxisView: AxisView<X>, view: V): void;
    viewDidDetachBottomAxis?(bottomAxisView: AxisView<X>, view: V): void;
    viewWillAttachLeftAxis?(leftAxisView: AxisView<Y>, view: V): void;
    viewDidDetachLeftAxis?(leftAxisView: AxisView<Y>, view: V): void;
}

/** @public */
export declare class CircleIcon extends FilledIcon implements Interpolate<CircleIcon>, Equals, Equivalent, Debug {
    constructor(fillColor: Color | null, fillLook: Look<Color> | null, moodModifier: MoodMatrix | null);
    readonly fillColor: Color | null;
    withFillColor(fillColor: Color | null): CircleIcon;
    readonly fillLook: Look<Color> | null;
    withFillLook(fillLook: Look<Color> | null): CircleIcon;
    readonly moodModifier: MoodMatrix | null;
    withMoodModifier(moodModifier: MoodMatrix | null): CircleIcon;
    modifyMood(feel: Feel, updates: MoodVectorUpdates<Feel>): CircleIcon;
    isThemed(): boolean;
    withTheme(theme: ThemeMatrix, mood: MoodVector): CircleIcon;
    render(renderer: GraphicsRenderer, frame: R2Box): void;
    paint(context: PaintingContext, frame: R2Box): void;
    draw(context: DrawingContext, frame: R2Box): void;
    protected copy(fillColor: Color | null, fillLook: Look<Color> | null, moodModifier: MoodMatrix | null): CircleIcon;
    interpolateTo(that: CircleIcon): Interpolator<CircleIcon>;
    interpolateTo(that: unknown): Interpolator<CircleIcon> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static create(): CircleIcon;
}

/** @internal */
export declare interface CircleIconInterpolator extends Interpolator<CircleIcon> {
    /** @internal */
    readonly fillColorInterpolator: Interpolator<Color | null>;
    /** @internal */
    readonly fillLook: Look<Color> | null;
    /** @internal */
    readonly moodModifier: MoodMatrix | null;
    readonly 0: CircleIcon;
    readonly 1: CircleIcon;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const CircleIconInterpolator: {
    (i0: CircleIcon, i1: CircleIcon): CircleIconInterpolator;
    /** @internal */
    prototype: CircleIconInterpolator;
};

/** @public */
export declare class ColController extends Controller {
    readonly observerType?: Class<ColControllerObserver>;
    readonly col: TraitViewRef<this, ColTrait, ColView>;
    static readonly col: MemberFastenerClass<ColController, "col">;
    protected createLabelView(label: ColLabel, colTrait: ColTrait): HtmlView | string | null;
    protected setLabelView(label: ColLabel | null, colTrait: ColTrait): void;
    readonly label: ViewRef<this, HtmlView>;
    static readonly label: MemberFastenerClass<ColController, "label">;
}

/** @public */
export declare interface ColControllerObserver<C extends ColController = ColController> extends ControllerObserver<C> {
    controllerWillAttachColView?(colView: ColView, controller: C): void;
    controllerDidDetachColView?(colView: ColView, controller: C): void;
    controllerWillAttachColTrait?(colTrait: ColTrait, controller: C): void;
    controllerDidDetachColTrait?(colTrait: ColTrait, controller: C): void;
    controllerWillSetColLayout?(newColLayout: ColLayout | null, oldColLayout: ColLayout | null, controller: C): void;
    controllerDidSetColLayout?(newColLayout: ColLayout | null, oldColLayout: ColLayout | null, controller: C): void;
    controllerWillAttachColLabelView?(colLabelView: HtmlView, controller: C): void;
    controllerDidDetachColLabelView?(colLabelView: HtmlView, controller: C): void;
}

/** @public */
export declare type ColLabel = ColLabelFunction | string;

/** @public */
export declare type ColLabelFunction = (colTrait: ColTrait) => HtmlView | string | null;

/** @public */
export declare class ColLayout implements Equals, Equivalent, Debug {
    constructor(key: string, grow: number, shrink: number, basis: Length, optional: boolean, persistent: boolean, textColor: Look<Color> | Color | null, width: Length | null, left: Length | null, right: Length | null, hidden: boolean);
    readonly key: string;
    readonly grow: number;
    readonly shrink: number;
    readonly basis: Length;
    withFlex(grow: number, shrink: number, basis?: AnyLength): ColLayout;
    readonly optional: boolean;
    asOptional(optional: boolean): ColLayout;
    readonly persistent: boolean;
    asPersistent(persistent: boolean): ColLayout;
    readonly textColor: Look<Color> | Color | null;
    withTextColor(textColor: Look<Color> | AnyColor | null): ColLayout;
    readonly width: Length | null;
    readonly left: Length | null;
    readonly right: Length | null;
    readonly hidden: boolean;
    asHidden(hidden: boolean): ColLayout;
    resized(width: AnyLength | null, left: AnyLength | null, right: AnyLength | null, hidden?: boolean): ColLayout;
    protected copy(key: string, grow: number, shrink: number, basis: Length, optional: boolean, persistent: boolean, textColor: Look<Color> | Color | null, width: Length | null, left: Length | null, right: Length | null, hidden: boolean): ColLayout;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static create(key: string, grow?: number, shrink?: number, basis?: AnyLength, optional?: boolean, persistent?: boolean, textColor?: Look<Color> | AnyColor | null): ColLayout;
    static fromAny(value: AnyColLayout): ColLayout;
    static fromInit(init: ColLayoutInit): ColLayout;
}

/** @public */
export declare interface ColLayoutInit {
    key?: string;
    grow?: number;
    shrink?: number;
    basis?: AnyLength;
    optional?: boolean;
    persistent?: boolean;
    textColor?: Look<Color> | AnyColor | null;
    width?: AnyLength | null;
    left?: AnyLength | null;
    right?: AnyLength | null;
    hidden?: boolean;
}

/** @public */
export declare abstract class Color implements Interpolate<Color>, HashCode, Equivalent, Debug {
    abstract isDefined(): boolean;
    abstract alpha(): number;
    abstract alpha(a: number): Color;
    abstract plus(that: AnyColor): Color;
    abstract times(scalar: number): Color;
    abstract combine(that: AnyColor, scalar?: number): Color;
    abstract readonly lightness: number;
    abstract lighter(k?: number): Color;
    abstract darker(k?: number): Color;
    contrast(k?: number): Color;
    abstract rgb(): RgbColor;
    abstract hsl(): HslColor;
    interpolateTo(that: Color): Interpolator<Color>;
    interpolateTo(that: unknown): Interpolator<Color> | null;
    abstract equivalentTo(that: unknown, epsilon?: number): boolean;
    abstract equals(other: unknown): boolean;
    abstract hashCode(): number;
    abstract debug<T>(output: Output<T>): Output<T>;
    abstract toHexString(): string;
    abstract toRgbString(): string;
    abstract toHslString(): string;
    abstract toString(): string;
    static transparent(): Color;
    static black(alpha?: number): Color;
    static white(alpha?: number): Color;
    static rgb(r: number, g: number, b: number, a?: number): RgbColor;
    static hsl(h: AnyAngle, s: number, l: number, a?: number): HslColor;
    static forName(name: string): Color | null;
    static fromInit(value: ColorInit): Color;
    static fromAny(value: AnyColor): Color;
    static fromValue(value: Value): Color | null;
    static parse(string: string): Color;
    /** @internal */
    static isInit(value: unknown): value is ColorInit;
    /** @internal */
    static isAny(value: unknown): value is AnyColor;
    static form(): Form<Color, AnyColor>;
    /** @internal */
    static Darker: number;
    /** @internal */
    static Brighter: number;
}

/** @internal */
export declare const ColorAttributeAnimator: AttributeAnimatorFactory<AttributeAnimator<any, Color | null, AnyColor | null>>;

/** @internal */
export declare class ColorChannel {
    constructor(value: number, units?: string);
    readonly value: number;
    readonly units: string;
    scale(k: number): number;
}

/** @internal */
export declare class ColorChannelParser extends Parser<ColorChannel> {
    private readonly valueParser;
    private readonly step;
    constructor(valueParser?: Parser<number>, step?: number);
    feed(input: Input): Parser<ColorChannel>;
    static parse(input: Input, valueParser?: Parser<number>, step?: number): Parser<ColorChannel>;
}

/** @internal */
export declare class ColorForm extends Form<Color, AnyColor> {
    constructor(unit: Color | undefined);
    readonly unit: Color | undefined;
    withUnit(unit: Color | undefined): Form<Color, AnyColor>;
    mold(color: AnyColor): Item;
    cast(item: Item): Color | undefined;
}

/** @public */
export declare type ColorInit = RgbColorInit | HslColorInit;

/** @internal */
export declare class ColorLook extends Look<Color, AnyColor> {
    combine(combination: Color | undefined, value: Color, weight?: number): Color;
    between(a: Color, b: Color): Interpolator<Color>;
    coerce(value: AnyColor): Color;
}

/** @internal */
export declare class ColorParser extends Parser<Color> {
    private readonly identOutput;
    private readonly step;
    constructor(identOutput?: Output<string>, step?: number);
    feed(input: Input): Parser<Color>;
    static parse(input: Input, identOutput?: Output<string>, step?: number): Parser<Color>;
}

/** @public */
export declare class ColorStop implements Interpolate<ColorStop>, Equals, Equivalent {
    constructor(color: Color, stop: Length | null, hint: Length | null);
    readonly color: Color;
    withColor(color: AnyColor): ColorStop;
    readonly stop: Length | null;
    withStop(stop: AnyLength | null): ColorStop;
    readonly hint: Length | null;
    withHint(hint: AnyLength | null): ColorStop;
    interpolateTo(that: ColorStop): Interpolator<ColorStop>;
    interpolateTo(that: unknown): Interpolator<ColorStop> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    toString(): string;
    static create(color: AnyColor, stop?: AnyLength | null, hint?: AnyLength | null): ColorStop;
    static fromInit(init: ColorStopInit): ColorStop;
    static fromTuple(value: ColorStopTuple): ColorStop;
    static fromAny(value: AnyColorStop): ColorStop;
    static parse(string: string): ColorStop;
    static parseHint(string: string): ColorStop;
    static parseList(string: string): ColorStop[];
    /** @internal */
    static isInit(value: unknown): value is ColorStopInit;
    /** @internal */
    static isTuple(value: unknown): value is ColorStopTuple;
    /** @internal */
    static isAny(value: unknown): value is AnyColorStop;
}

/** @public */
export declare interface ColorStopInit {
    color: AnyColor;
    stop?: AnyLength;
    hint?: AnyLength;
}

/** @internal */
export declare interface ColorStopInterpolator extends Interpolator<ColorStop> {
    /** @internal */
    readonly colorInterpolator: Interpolator<Color>;
    /** @internal */
    readonly stopInterpolator: Interpolator<Length | null>;
    /** @internal */
    readonly hintInterpolator: Interpolator<Length | null>;
    readonly 0: ColorStop;
    readonly 1: ColorStop;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const ColorStopInterpolator: {
    (y0: ColorStop, y1: ColorStop): ColorStopInterpolator;
    /** @internal */
    prototype: ColorStopInterpolator;
};

/** @internal */
export declare class ColorStopListParser extends Parser<ColorStop[]> {
    private readonly stops;
    private readonly stopParser;
    private readonly step;
    constructor(stops?: ReadonlyArray<ColorStop>, stopParser?: Parser<ColorStop>, step?: number);
    feed(input: Input): Parser<ColorStop[]>;
    static parse(input: Input, stops?: ColorStop[], stopParser?: Parser<ColorStop>, step?: number): Parser<ColorStop[]>;
}

/** @internal */
export declare class ColorStopParser extends Parser<ColorStop> {
    private readonly colorParser;
    private readonly stopParser;
    private readonly hintParser;
    private readonly step;
    constructor(colorParser?: Parser<Color>, stopParser?: Parser<Length>, hintParser?: Parser<Length>, step?: number);
    feed(input: Input): Parser<ColorStop>;
    static parse(input: Input, colorParser?: Parser<Color>, stopParser?: Parser<Length>, hintParser?: Parser<Length>, step?: number): Parser<ColorStop>;
    static parseHint(input: Input): Parser<ColorStop>;
}

/** @public */
export declare type ColorStopTuple = [AnyColor, AnyLength | null];

/** @internal */
export declare const ColorStyleAnimator: StyleAnimatorFactory<StyleAnimator<any, Color | null, AnyColor | null>>;

/** @internal */
export declare const ColorThemeAnimator: ThemeAnimatorFactory<ThemeAnimator<any, Color | null | undefined, AnyColor | null | undefined>>;

/** @public */
export declare class ColTrait extends Trait {
    readonly observerType?: Class<ColTraitObserver>;
    readonly layout: Property<this, ColLayout | null, AnyColLayout | null>;
    readonly label: Property<this, ColLabel | null>;
}

/** @public */
export declare interface ColTraitObserver<T extends ColTrait = ColTrait> extends TraitObserver<T> {
    traitWillSetLayout?(newLayout: ColLayout | null, oldLayout: ColLayout | null, trait: T): void;
    traitDidSetLayout?(newLayout: ColLayout | null, oldLayout: ColLayout | null, trait: T): void;
    traitWillSetLabel?(newLabel: ColLabel | null, oldLabel: ColLabel | null, trait: T): void;
    traitDidSetLabel?(newLabel: ColLabel | null, oldLabel: ColLabel | null, trait: T): void;
}

/** @public */
export declare class ColView extends HtmlView {
    constructor(node: HTMLElement);
    protected initCol(): void;
    readonly observerType?: Class<ColViewObserver>;
    readonly label: ViewRef<this, HtmlView & Initable<HtmlViewInit | string>> & {
        create(value?: string): HtmlView;
    };
    static readonly label: MemberFastenerClass<ColView, "label">;
}

/** @public */
export declare interface ColViewObserver<V extends ColView = ColView> extends HtmlViewObserver<V> {
    viewWillAttachLabel?(labelView: HtmlView, view: V): void;
    viewDidDetachLabel?(labelView: HtmlView, view: V): void;
}

/** @public */
export declare interface ContinuousScaleAnimator<O extends View = View, X = unknown, Y = unknown, T extends ContinuousScale<X, Y> | null | undefined = ContinuousScale<X, Y> | null, U extends string = string> extends Animator<O, T, U> {
    setScale(domain: Domain<X> | string, range: Range_2<Y>, timing?: AnyTiming | boolean | null): void;
    setScale(xMin: X, xMax: X, yMin: Y, yMax: Y, timing?: AnyTiming | boolean | null): void;
    setDomain(domain: Domain<X> | string, timing?: AnyTiming | boolean | null): void;
    setDomain(xMin: X, xMax: X, timing?: AnyTiming | boolean | null): void;
    setRange(range: Range_2<Y>, timing?: AnyTiming | boolean | null): void;
    setRange(yMin: Y, yMax: Y, timing?: AnyTiming | boolean | null): void;
    setBaseScale(domain: Domain<X> | string, range: Range_2<Y>, timing?: AnyTiming | boolean | null): void;
    setBaseScale(xMin: X, xMax: X, yMin: Y, yMax: Y, timing?: AnyTiming | boolean | null): void;
    setBaseDomain(domain: Domain<X> | string, timing?: AnyTiming | boolean | null): void;
    setBaseDomain(xMin: X, xMax: X, timing?: AnyTiming | boolean | null): void;
    setBaseRange(range: Range_2<Y>, timing?: AnyTiming | boolean | null): void;
    setBaseRange(yMin: Y, yMax: Y, timing?: AnyTiming | boolean | null): void;
    /** @override */
    fromAny(value: T | U): T;
}

/** @public */
export declare const ContinuousScaleAnimator: AnimatorFactory<ContinuousScaleAnimator<any, any, any, any, any>>;

/** @public */
export declare class Controller extends Component<Controller> implements Initable<ControllerInit> {
    get componentType(): Class<Controller>;
    readonly observerType?: Class<ControllerObserver>;
    readonly contextType?: Class<ControllerContext>;
    protected willAttachParent(parent: Controller): void;
    protected onAttachParent(parent: Controller): void;
    protected didAttachParent(parent: Controller): void;
    protected willDetachParent(parent: Controller): void;
    protected onDetachParent(parent: Controller): void;
    protected didDetachParent(parent: Controller): void;
    setChild<C extends Controller>(key: string, newChild: C): Controller | null;
    setChild<F extends ControllerCreator<F>>(key: string, factory: F): Controller | null;
    setChild(key: string, newChild: AnyController | null): Controller | null;
    appendChild<C extends Controller>(child: C, key?: string): C;
    appendChild<F extends ControllerCreator<F>>(factory: F, key?: string): InstanceType<F>;
    appendChild(child: AnyController, key?: string): Controller;
    prependChild<C extends Controller>(child: C, key?: string): C;
    prependChild<F extends ControllerCreator<F>>(factory: F, key?: string): InstanceType<F>;
    prependChild(child: AnyController, key?: string): Controller;
    insertChild<C extends Controller>(child: C, target: Controller | null, key?: string): C;
    insertChild<F extends ControllerCreator<F>>(factory: F, target: Controller | null, key?: string): InstanceType<F>;
    insertChild(child: AnyController, target: Controller | null, key?: string): Controller;
    replaceChild<C extends Controller>(newChild: Controller, oldChild: C): C;
    replaceChild<C extends Controller>(newChild: AnyController, oldChild: C): C;
    protected willInsertChild(child: Controller, target: Controller | null): void;
    protected onInsertChild(child: Controller, target: Controller | null): void;
    protected didInsertChild(child: Controller, target: Controller | null): void;
    /** @internal */
    cascadeInsert(updateFlags?: ControllerFlags, controllerContext?: ControllerContext): void;
    protected willRemoveChild(child: Controller): void;
    protected onRemoveChild(child: Controller): void;
    protected didRemoveChild(child: Controller): void;
    protected willMount(): void;
    protected onMount(): void;
    protected didMount(): void;
    protected willUnmount(): void;
    protected didUnmount(): void;
    requireUpdate(updateFlags: ControllerFlags, immediate?: boolean): void;
    protected needsUpdate(updateFlags: ControllerFlags, immediate: boolean): ControllerFlags;
    requestUpdate(target: Controller, updateFlags: ControllerFlags, immediate: boolean): void;
    get updating(): boolean;
    get compiling(): boolean;
    protected needsCompile(compileFlags: ControllerFlags, controllerContext: ControllerContextType<this>): ControllerFlags;
    cascadeCompile(compileFlags: ControllerFlags, baseControllerContext: ControllerContext): void;
    protected willCompile(compileFlags: ControllerFlags, controllerContext: ControllerContextType<this>): void;
    protected onCompile(compileFlags: ControllerFlags, controllerContext: ControllerContextType<this>): void;
    protected didCompile(compileFlags: ControllerFlags, controllerContext: ControllerContextType<this>): void;
    protected willResolve(controllerContext: ControllerContextType<this>): void;
    protected onResolve(controllerContext: ControllerContextType<this>): void;
    protected didResolve(controllerContext: ControllerContextType<this>): void;
    protected willGenerate(controllerContext: ControllerContextType<this>): void;
    protected onGenerate(controllerContext: ControllerContextType<this>): void;
    protected didGenerate(controllerContext: ControllerContextType<this>): void;
    protected willAssemble(controllerContext: ControllerContextType<this>): void;
    protected onAssemble(controllerContext: ControllerContextType<this>): void;
    protected didAssemble(controllerContext: ControllerContextType<this>): void;
    protected compileChildren(compileFlags: ControllerFlags, controllerContext: ControllerContextType<this>, compileChild: (this: this, child: Controller, compileFlags: ControllerFlags, controllerContext: ControllerContextType<this>) => void): void;
    protected compileChild(child: Controller, compileFlags: ControllerFlags, controllerContext: ControllerContextType<this>): void;
    get executing(): boolean;
    protected needsExecute(executeFlags: ControllerFlags, controllerContext: ControllerContextType<this>): ControllerFlags;
    cascadeExecute(executeFlags: ControllerFlags, baseControllerContext: ControllerContext): void;
    protected willExecute(executeFlags: ControllerFlags, controllerContext: ControllerContextType<this>): void;
    protected onExecute(executeFlags: ControllerFlags, controllerContext: ControllerContextType<this>): void;
    protected didExecute(executeFlags: ControllerFlags, controllerContext: ControllerContextType<this>): void;
    protected willRevise(controllerContext: ControllerContextType<this>): void;
    protected onRevise(controllerContext: ControllerContextType<this>): void;
    protected didRevise(controllerContext: ControllerContextType<this>): void;
    protected willCompute(controllerContext: ControllerContextType<this>): void;
    protected onCompute(controllerContext: ControllerContextType<this>): void;
    protected didCompute(controllerContext: ControllerContextType<this>): void;
    protected executeChildren(executeFlags: ControllerFlags, controllerContext: ControllerContextType<this>, executeChild: (this: this, child: Controller, executeFlags: ControllerFlags, controllerContext: ControllerContextType<this>) => void): void;
    /** @internal */
    protected executeChild(child: Controller, executeFlags: ControllerFlags, controllerContext: ControllerContextType<this>): void;
    /** @internal */
    protected bindChildFastener(fastener: Fastener, child: Controller, target: Controller | null): void;
    /** @internal */
    protected unbindChildFastener(fastener: Fastener, child: Controller): void;
    /** @internal @override */
    decohereFastener(fastener: Fastener): void;
    readonly executeProvider: ExecuteProvider<this>;
    readonly historyProvider: HistoryProvider<this>;
    readonly storageProvider: StorageProvider<this>;
    /** @internal */
    get superControllerContext(): ControllerContext;
    /** @internal */
    extendControllerContext(controllerContext: ControllerContext): ControllerContextType<this>;
    get controllerContext(): ControllerContextType<this>;
    /** @override */
    init(init: ControllerInit): void;
    static create<S extends new () => InstanceType<S>>(this: S): InstanceType<S>;
    static fromInit<S extends abstract new (...args: any) => InstanceType<S>>(this: S, init: InitType<InstanceType<S>>): InstanceType<S>;
    static fromAny<S extends abstract new (...args: any) => InstanceType<S>>(this: S, value: AnyController<InstanceType<S>>): InstanceType<S>;
    /** @internal */
    static uid: () => number;
    /** @internal */
    static readonly MountedFlag: ControllerFlags;
    /** @internal */
    static readonly RemovingFlag: ControllerFlags;
    /** @internal */
    static readonly CompilingFlag: ControllerFlags;
    /** @internal */
    static readonly ExecutingFlag: ControllerFlags;
    /** @internal */
    static readonly ContextualFlag: ControllerFlags;
    /** @internal */
    static readonly UpdatingMask: ControllerFlags;
    /** @internal */
    static readonly StatusMask: ControllerFlags;
    static readonly NeedsCompile: ControllerFlags;
    static readonly NeedsResolve: ControllerFlags;
    static readonly NeedsGenerate: ControllerFlags;
    static readonly NeedsAssemble: ControllerFlags;
    /** @internal */
    static readonly CompileMask: ControllerFlags;
    static readonly NeedsExecute: ControllerFlags;
    static readonly NeedsRevise: ControllerFlags;
    static readonly NeedsCompute: ControllerFlags;
    /** @internal */
    static readonly ExecuteMask: ControllerFlags;
    /** @internal */
    static readonly UpdateMask: ControllerFlags;
    /** @internal */
    static readonly FlagShift: number;
    /** @internal */
    static readonly FlagMask: ControllerFlags;
    static readonly MountFlags: ControllerFlags;
    static readonly InsertChildFlags: ControllerFlags;
    static readonly RemoveChildFlags: ControllerFlags;
}

/** @public */
export declare interface ControllerClass<C extends Controller = Controller, U = AnyController<C>> extends Function, ControllerFactory<C, U> {
    readonly prototype: C;
}

/** @public */
export declare interface ControllerConstructor<C extends Controller = Controller, U = AnyController<C>> extends ControllerClass<C, U> {
    new (): C;
}

/** @public */
export declare interface ControllerContext {
    readonly updateTime: number;
}

/** @public */
export declare const ControllerContext: {
    current: ControllerContext | null;
    create(): ControllerContext;
};

/** @public */
export declare type ControllerContextType<C extends Controller> = C extends {
    readonly contextType?: Class<infer T>;
} ? T : never;

/** @public */
export declare type ControllerCreator<F extends (abstract new (...args: any) => C) & Creatable<InstanceType<F>>, C extends Controller = Controller> = (abstract new (...args: any) => InstanceType<F>) & Creatable<InstanceType<F>>;

/** @public */
export declare interface ControllerFactory<C extends Controller = Controller, U = AnyController<C>> extends Creatable<C>, FromAny<C, U> {
    fromInit(init: InitType<C>): C;
}

/** @public */
export declare type ControllerFlags = ComponentFlags;

/** @public */
export declare interface ControllerInit extends ComponentInit {
    /** @internal */
    uid?: never;
    type?: Creatable<Controller>;
    key?: string;
    children?: AnyController[];
}

/** @public */
export declare interface ControllerObserver<C extends Controller = Controller> extends ComponentObserver<C> {
    controllerWillAttachParent?(parent: Controller, controller: C): void;
    controllerDidAttachParent?(parent: Controller, controller: C): void;
    controllerWillDetachParent?(parent: Controller, controller: C): void;
    controllerDidDetachParent?(parent: Controller, controller: C): void;
    controllerWillInsertChild?(child: Controller, target: Controller | null, controller: C): void;
    controllerDidInsertChild?(child: Controller, target: Controller | null, controller: C): void;
    controllerWillRemoveChild?(child: Controller, controller: C): void;
    controllerDidRemoveChild?(child: Controller, controller: C): void;
    controllerWillMount?(controller: Controller): void;
    controllerDidMount?(controller: Controller): void;
    controllerWillUnmount?(controller: Controller): void;
    controllerDidUnmount?(controller: Controller): void;
    controllerWillResolve?(controllerContext: ControllerContextType<C>, controller: C): void;
    controllerDidResolve?(controllerContext: ControllerContextType<C>, controller: C): void;
    controllerWillGenerate?(controllerContext: ControllerContextType<C>, controller: C): void;
    controllerDidGenerate?(controllerContext: ControllerContextType<C>, controller: C): void;
    controllerWillAssemble?(controllerContext: ControllerContextType<C>, controller: C): void;
    controllerDidAssemble?(controllerContext: ControllerContextType<C>, controller: C): void;
    controllerWillRevise?(controllerContext: ControllerContextType<C>, controller: C): void;
    controllerDidRevise?(controllerContext: ControllerContextType<C>, controller: C): void;
    controllerWillCompute?(controllerContext: ControllerContextType<C>, controller: C): void;
    controllerDidCompute?(controllerContext: ControllerContextType<C>, controller: C): void;
}

/** @public */
export declare interface ControllerRef<O = unknown, C extends Controller = Controller> extends ControllerRelation<O, C> {
    (): C | null;
    (controller: AnyController<C> | null, target?: Controller | null, key?: string): O;
    /** @override */
    get fastenerType(): Proto<ControllerRef<any, any>>;
    /** @protected @override */
    onInherit(superFastener: Fastener): void;
    readonly controller: C | null;
    getController(): C;
    setController(controller: AnyController<C> | null, target?: Controller | null, key?: string): C | null;
    attachController(controller?: AnyController<C>, target?: Controller | null): C;
    detachController(): C | null;
    insertController(parent?: Controller, controller?: AnyController<C>, target?: Controller | null, key?: string): C;
    removeController(): C | null;
    deleteController(): C | null;
    /** @internal @override */
    bindController(controller: Controller, target: Controller | null): void;
    /** @internal @override */
    unbindController(controller: Controller): void;
    /** @override */
    detectController(controller: Controller): C | null;
    /** @internal */
    get key(): string | undefined;
}

/** @public */
export declare const ControllerRef: ControllerRefFactory<ControllerRef<any, any>>;

/** @public */
export declare interface ControllerRefClass<F extends ControllerRef<any, any> = ControllerRef<any, any>> extends ControllerRelationClass<F> {
}

/** @public */
export declare type ControllerRefDescriptor<O = unknown, C extends Controller = Controller, I = {}> = ThisType<ControllerRef<O, C> & I> & ControllerRefInit<C> & Partial<I>;

/** @public */
export declare interface ControllerRefFactory<F extends ControllerRef<any, any> = ControllerRef<any, any>> extends ControllerRefClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ControllerRefFactory<F> & I;
    define<O, C extends Controller = Controller>(className: string, descriptor: ControllerRefDescriptor<O, C>): ControllerRefFactory<ControllerRef<any, C>>;
    define<O, C extends Controller = Controller>(className: string, descriptor: {
        observes: boolean;
    } & ControllerRefDescriptor<O, C, ObserverType<C>>): ControllerRefFactory<ControllerRef<any, C>>;
    define<O, C extends Controller = Controller, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ControllerRefDescriptor<O, C, I>): ControllerRefFactory<ControllerRef<any, C> & I>;
    define<O, C extends Controller = Controller, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & ControllerRefDescriptor<O, C, I & ObserverType<C>>): ControllerRefFactory<ControllerRef<any, C> & I>;
    <O, C extends Controller = Controller>(descriptor: ControllerRefDescriptor<O, C>): PropertyDecorator;
    <O, C extends Controller = Controller>(descriptor: {
        observes: boolean;
    } & ControllerRefDescriptor<O, C, ObserverType<C>>): PropertyDecorator;
    <O, C extends Controller = Controller, I = {}>(descriptor: {
        implements: unknown;
    } & ControllerRefDescriptor<O, C, I>): PropertyDecorator;
    <O, C extends Controller = Controller, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & ControllerRefDescriptor<O, C, I & ObserverType<C>>): PropertyDecorator;
}

/** @public */
export declare interface ControllerRefInit<C extends Controller = Controller> extends ControllerRelationInit<C> {
    extends?: {
        prototype: ControllerRef<any, any>;
    } | string | boolean | null;
    key?: string | boolean;
}

/** @internal */
export declare type ControllerRefType<F extends ControllerRef<any, any>> = F extends ControllerRef<any, infer C> ? C : never;

/** @public */
export declare interface ControllerRelation<O = unknown, C extends Controller = Controller> extends Fastener<O> {
    /** @override */
    get fastenerType(): Proto<ControllerRelation<any, any>>;
    /** @protected */
    initController(controller: C): void;
    /** @protected */
    willAttachController(controller: C, target: Controller | null): void;
    /** @protected */
    onAttachController(controller: C, target: Controller | null): void;
    /** @protected */
    didAttachController(controller: C, target: Controller | null): void;
    /** @protected */
    deinitController(controller: C): void;
    /** @protected */
    willDetachController(controller: C): void;
    /** @protected */
    onDetachController(controller: C): void;
    /** @protected */
    didDetachController(controller: C): void;
    /** @internal @protected */
    get parentController(): Controller | null;
    /** @internal @protected */
    insertChild(parent: Controller, child: C, target: Controller | null, key: string | undefined): void;
    /** @internal */
    bindController(controller: Controller, target: Controller | null): void;
    /** @internal */
    unbindController(controller: Controller): void;
    detectController(controller: Controller): C | null;
    createController(): C;
    /** @internal @protected */
    fromAny(value: AnyController<C>): C;
    /** @internal @protected */
    get type(): ControllerFactory<C> | undefined;
    /** @internal @protected */
    get binds(): boolean | undefined;
    /** @internal @protected */
    get observes(): boolean | undefined;
    /** @internal @override */
    get lazy(): boolean;
    /** @internal @override */
    get static(): string | boolean;
}

/** @public */
export declare const ControllerRelation: ControllerRelationFactory<ControllerRelation<any, any>>;

/** @public */
export declare interface ControllerRelationClass<F extends ControllerRelation<any, any> = ControllerRelation<any, any>> extends FastenerClass<F> {
}

/** @public */
export declare type ControllerRelationDescriptor<O = unknown, C extends Controller = Controller, I = {}> = ThisType<ControllerRelation<O, C> & I> & ControllerRelationInit<C> & Partial<I>;

/** @public */
export declare interface ControllerRelationFactory<F extends ControllerRelation<any, any> = ControllerRelation<any, any>> extends ControllerRelationClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ControllerRelationFactory<F> & I;
    define<O, C extends Controller = Controller>(className: string, descriptor: ControllerRelationDescriptor<O, C>): ControllerRelationFactory<ControllerRelation<any, C>>;
    define<O, C extends Controller = Controller>(className: string, descriptor: {
        observes: boolean;
    } & ControllerRelationDescriptor<O, C, ObserverType<C>>): ControllerRelationFactory<ControllerRelation<any, C>>;
    define<O, C extends Controller = Controller, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ControllerRelationDescriptor<O, C, I>): ControllerRelationFactory<ControllerRelation<any, C> & I>;
    define<O, C extends Controller = Controller, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & ControllerRelationDescriptor<O, C, I & ObserverType<C>>): ControllerRelationFactory<ControllerRelation<any, C> & I>;
    <O, C extends Controller = Controller>(descriptor: ControllerRelationDescriptor<O, C>): PropertyDecorator;
    <O, C extends Controller = Controller>(descriptor: {
        observes: boolean;
    } & ControllerRelationDescriptor<O, C, ObserverType<C>>): PropertyDecorator;
    <O, C extends Controller = Controller, I = {}>(descriptor: {
        implements: unknown;
    } & ControllerRelationDescriptor<O, C, I>): PropertyDecorator;
    <O, C extends Controller = Controller, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & ControllerRelationDescriptor<O, C, I & ObserverType<C>>): PropertyDecorator;
}

/** @public */
export declare interface ControllerRelationInit<C extends Controller = Controller> extends FastenerInit {
    extends?: {
        prototype: ControllerRelation<any, any>;
    } | string | boolean | null;
    type?: ControllerFactory<C>;
    binds?: boolean;
    observes?: boolean;
    initController?(controller: C): void;
    willAttachController?(controller: C, target: Controller | null): void;
    didAttachController?(controller: C, target: Controller | null): void;
    deinitController?(controller: C): void;
    willDetachController?(controller: C): void;
    didDetachController?(controller: C): void;
    parentController?: Controller | null;
    insertChild?(parent: Controller, child: C, target: Controller | null, key: string | undefined): void;
    detectController?(controller: Controller): C | null;
    createController?(): C;
    fromAny?(value: AnyController<C>): C;
}

/** @internal */
export declare type ControllerRelationType<F extends ControllerRelation<any, any>> = F extends ControllerRelation<any, infer C> ? C : never;

/** @public */
export declare interface ControllerSet<O = unknown, C extends Controller = Controller> extends ControllerRelation<O, C> {
    (controller: AnyController<C>): O;
    /** @override */
    get fastenerType(): Proto<ControllerSet<any, any>>;
    /** @internal */
    readonly controllers: {
        readonly [controllerId: number]: C | undefined;
    };
    readonly controllerCount: number;
    hasController(controller: Controller): boolean;
    addController(controller?: AnyController<C>, target?: Controller | null, key?: string): C;
    attachController(controller?: AnyController<C>, target?: Controller | null): C;
    detachController(controller: C): C | null;
    insertController(parent?: Controller | null, controller?: AnyController<C>, target?: Controller | null, key?: string): C;
    removeController(controller: C): C | null;
    deleteController(controller: C): C | null;
    /** @internal @override */
    bindController(controller: Controller, target: Controller | null): void;
    /** @internal @override */
    unbindController(controller: Controller): void;
    /** @override */
    detectController(controller: Controller): C | null;
    /** @internal @protected */
    key(controller: C): string | undefined;
    get sorted(): boolean;
    /** @internal */
    initSorted(sorted: boolean): void;
    sort(sorted?: boolean): this;
    /** @protected */
    willSort(parent: Controller | null): void;
    /** @protected */
    onSort(parent: Controller | null): void;
    /** @protected */
    didSort(parent: Controller | null): void;
    /** @internal @protected */
    sortChildren(parent: Controller): void;
    /** @internal */
    compareChildren(a: Controller, b: Controller): number;
    /** @internal @protected */
    compare(a: C, b: C): number;
}

/** @public */
export declare const ControllerSet: ControllerSetFactory<ControllerSet<any, any>>;

/** @public */
export declare interface ControllerSetClass<F extends ControllerSet<any, any> = ControllerSet<any, any>> extends ControllerRelationClass<F> {
    /** @internal */
    readonly SortedFlag: FastenerFlags;
    /** @internal @override */
    readonly FlagShift: number;
    /** @internal @override */
    readonly FlagMask: FastenerFlags;
}

/** @public */
export declare type ControllerSetDescriptor<O = unknown, C extends Controller = Controller, I = {}> = ThisType<ControllerSet<O, C> & I> & ControllerSetInit<C> & Partial<I>;

/** @public */
export declare interface ControllerSetFactory<F extends ControllerSet<any, any> = ControllerSet<any, any>> extends ControllerSetClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ControllerSetFactory<F> & I;
    define<O, C extends Controller = Controller>(className: string, descriptor: ControllerSetDescriptor<O, C>): ControllerSetFactory<ControllerSet<any, C>>;
    define<O, C extends Controller = Controller>(className: string, descriptor: {
        observes: boolean;
    } & ControllerSetDescriptor<O, C, ObserverType<C>>): ControllerSetFactory<ControllerSet<any, C>>;
    define<O, C extends Controller = Controller, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ControllerSetDescriptor<O, C, I>): ControllerSetFactory<ControllerSet<any, C> & I>;
    define<O, C extends Controller = Controller, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & ControllerSetDescriptor<O, C, I & ObserverType<C>>): ControllerSetFactory<ControllerSet<any, C> & I>;
    <O, C extends Controller = Controller>(descriptor: ControllerSetDescriptor<O, C>): PropertyDecorator;
    <O, C extends Controller = Controller>(descriptor: {
        observes: boolean;
    } & ControllerSetDescriptor<O, C, ObserverType<C>>): PropertyDecorator;
    <O, C extends Controller = Controller, I = {}>(descriptor: {
        implements: unknown;
    } & ControllerSetDescriptor<O, C, I>): PropertyDecorator;
    <O, C extends Controller = Controller, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & ControllerSetDescriptor<O, C, I & ObserverType<C>>): PropertyDecorator;
}

/** @public */
export declare interface ControllerSetInit<C extends Controller = Controller> extends ControllerRelationInit<C> {
    extends?: {
        prototype: ControllerSet<any, any>;
    } | string | boolean | null;
    key?(controller: C): string | undefined;
    compare?(a: C, b: C): number;
    sorted?: boolean;
    willSort?(parent: Controller | null): void;
    didSort?(parent: Controller | null): void;
    sortChildren?(parent: Controller): void;
    compareChildren?(a: Controller, b: Controller): number;
}

/** @internal */
export declare type ControllerSetType<F extends ControllerSet<any, any>> = F extends ControllerSet<any, infer C> ? C : never;

/** @public */
export declare interface CssContext {
    /** @internal */
    getRule(index: number): CSSRule | null;
    /** @internal */
    insertRule(cssText: string, index?: number): number;
    /** @internal */
    removeRule(index: number): void;
}

/** @public */
export declare const CssContext: {
    is(object: unknown): object is CssContext;
};

/** @public */
export declare type CssCursor = "alias" | "all-scroll" | "auto" | "cell" | "col-resize" | "context-menu" | "copy" | "crosshair" | "default" | "e-resize" | "ew-resize" | "grab" | "grabbing" | "help" | "move" | "n-resize" | "ne-resize" | "nesw-resize" | "no-drop" | "none" | "not-allowed" | "ns-resize" | "nw-resize" | "nwse-resize" | "pointer" | "progress" | "row-resize" | "s-resize" | "se-resize" | "sw-resize" | "text" | "vertical-text" | "w-resize" | "wait" | "zoom-in" | "zoom-out";

/** @public */
export declare type CssDisplay = "block" | "contents" | "flex" | "flow" | "flow-root" | "grid" | "inline" | "inline-block" | "inline-flex" | "inline-grid" | "inline-table" | "list-item" | "none" | "ruby" | "ruby-base" | "ruby-base-container" | "ruby-text" | "ruby-text-container" | "run-in" | "table" | "table-caption" | "table-cell" | "table-column" | "table-column-group" | "table-footer-group" | "table-header-group" | "table-row" | "table-row-group";

/** @public */
export declare interface CssRule<O = unknown> extends Fastener<O>, FastenerContext, ConstraintScope, ThemeContext {
    /** @override */
    get fastenerType(): Proto<CssRule<any>>;
    readonly rule: CSSRule;
    /** @internal */
    readonly fasteners: {
        [fastenerName: string]: Fastener | undefined;
    } | null;
    /** @override */
    hasFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): boolean;
    /** @override */
    getFastener<F extends Fastener<any>>(fastenerName: string, fastenerBound: Proto<F>): F | null;
    /** @override */
    getFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): Fastener | null;
    /** @override */
    setFastener(fastenerName: string, fastener: Fastener | null): void;
    /** @override */
    getLazyFastener<F extends Fastener<any>>(fastenerName: string, fastenerBound: Proto<F>): F | null;
    /** @override */
    getLazyFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): Fastener | null;
    /** @override */
    getSuperFastener<F extends Fastener<any>>(fastenerName: string, fastenerBound: Proto<F>): F | null;
    /** @override */
    getSuperFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): Fastener | null;
    /** @internal @override */
    getSuperFastener(): Fastener | null;
    /** @internal @protected */
    mountFasteners(): void;
    /** @internal @protected */
    unmountFasteners(): void;
    /** @override */
    requireUpdate(updateFlags: number): void;
    /** @internal */
    readonly decoherent: ReadonlyArray<Fastener> | null;
    /** @override */
    decohereFastener(fastener: Fastener): void;
    /** @override */
    recohere(t: number): void;
    /** @internal @protected */
    recohereFasteners(t: number): void;
    /** @override */
    constraint(lhs: AnyConstraintExpression, relation: ConstraintRelation, rhs?: AnyConstraintExpression, strength?: AnyConstraintStrength): Constraint;
    /** @override */
    hasConstraint(constraint: Constraint): boolean;
    /** @override */
    addConstraint(constraint: Constraint): void;
    /** @override */
    removeConstraint(constraint: Constraint): void;
    /** @override */
    constraintVariable(name: string, value?: number, strength?: AnyConstraintStrength): ConstraintProperty<unknown, number>;
    /** @override */
    hasConstraintVariable(variable: ConstraintVariable): boolean;
    /** @override */
    addConstraintVariable(variable: ConstraintVariable): void;
    /** @override */
    removeConstraintVariable(variable: ConstraintVariable): void;
    /** @internal @override */
    setConstraintVariable(constraintVariable: ConstraintVariable, state: number): void;
    /** @override */
    getLook<T>(look: Look<T, unknown>, mood?: MoodVector<Feel> | null): T | undefined;
    /** @override */
    getLookOr<T, E>(look: Look<T, unknown>, elseValue: E): T | E;
    /** @override */
    getLookOr<T, E>(look: Look<T, unknown>, mood: MoodVector<Feel> | null, elseValue: E): T | E;
    applyTheme(theme: ThemeMatrix, mood: MoodVector, timing?: AnyTiming | boolean): void;
    /** @protected @override */
    onMount(): void;
    /** @protected @override */
    onUnmount(): void;
    /** @internal */
    createRule(cssText: string): CSSRule;
    /** @internal */
    initRule?(rule: CSSRule): void;
    /** @internal */
    initCss?(): string;
}

/** @public */
export declare const CssRule: CssRuleFactory<CssRule<any>>;

/** @public */
export declare interface CssRuleClass<F extends CssRule<any> = CssRule<any>> extends FastenerClass<F> {
}

/** @public */
export declare type CssRuleDescriptor<O = unknown, I = {}> = ThisType<CssRule<O> & I> & CssRuleInit & Partial<I>;

/** @public */
export declare interface CssRuleFactory<F extends CssRule<any> = CssRule<any>> extends CssRuleClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): CssRuleFactory<F> & I;
    define<O>(className: string, descriptor: CssRuleDescriptor<O>): CssRuleFactory<CssRule<any>>;
    define<O, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & CssRuleDescriptor<O, I>): CssRuleFactory<CssRule<any> & I>;
    <O>(descriptor: CssRuleDescriptor<O>): PropertyDecorator;
    <O, I = {}>(descriptor: {
        implements: unknown;
    } & CssRuleDescriptor<O, I>): PropertyDecorator;
}

/** @public */
export declare interface CssRuleInit extends FastenerInit {
    extends?: {
        prototype: CssRule<any>;
    } | string | boolean | null;
    css?: string | (() => string);
    initRule?(rule: CSSRule): void;
}

/** @public */
export declare type DataPointCategory = "flat" | "increasing" | "decreasing" | "maxima" | "minima";

/** @public */
export declare class DataPointController<X = unknown, Y = unknown> extends Controller {
    readonly observerType?: Class<DataPointControllerObserver<X, Y>>;
    protected updateLabel(x: X | undefined, y: Y | undefined, dataPointTrait: DataPointTrait<X, Y>): void;
    protected setX(x: X, dataPointTrait: DataPointTrait<X, Y>, timing?: AnyTiming | boolean): void;
    protected setY(y: Y, dataPointTrait: DataPointTrait<X, Y>, timing?: AnyTiming | boolean): void;
    protected setY2(y2: Y | undefined, dataPointTrait: DataPointTrait<X, Y>, timing?: AnyTiming | boolean): void;
    protected setRadius(radius: AnyLength | null, dataPointTrait: DataPointTrait<X, Y>, timing?: AnyTiming | boolean): void;
    protected setColor(color: Look<Color> | AnyColor | null, dataPointTrait: DataPointTrait<X, Y>, timing?: AnyTiming | boolean): void;
    protected setOpacity(opacity: number | undefined, dataPointTrait: DataPointTrait<X, Y>, timing?: AnyTiming | boolean): void;
    protected createLabelView(label: DataPointLabel<X, Y>, dataPointTrait: DataPointTrait<X, Y>): GraphicsView | string | null;
    protected setLabelView(label: DataPointLabel<X, Y> | null, dataPointTrait: DataPointTrait<X, Y>): void;
    readonly dataPointTiming: Property<this, Timing | boolean | undefined, AnyTiming>;
    readonly dataPoint: TraitViewRef<this, DataPointTrait<X, Y>, DataPointView<X, Y>>;
    static readonly dataPoint: MemberFastenerClass<DataPointController, "dataPoint">;
    readonly label: ViewRef<this, GraphicsView>;
    static readonly label: MemberFastenerClass<DataPointController, "label">;
}

/** @public */
export declare interface DataPointControllerObserver<X = unknown, Y = unknown, C extends DataPointController<X, Y> = DataPointController<X, Y>> extends ControllerObserver<C> {
    controllerWillAttachDataPointTrait?(dataPointTrait: DataPointTrait<X, Y>, controller: C): void;
    controllerDidDetachDataPointTrait?(dataPointTrait: DataPointTrait<X, Y>, controller: C): void;
    controllerWillAttachDataPointView?(dataPointView: DataPointView<X, Y>, controller: C): void;
    controllerDidDetachDataPointView?(dataPointView: DataPointView<X, Y>, controller: C): void;
    controllerWillSetDataPointX?(newX: X | undefined, oldX: X | undefined, controller: C): void;
    controllerDidSetDataPointX?(newX: X | undefined, oldX: X | undefined, controller: C): void;
    controllerWillSetDataPointY?(newY: Y | undefined, oldY: Y | undefined, controller: C): void;
    controllerDidSetDataPointY?(newY: Y | undefined, oldY: Y | undefined, controller: C): void;
    controllerWillSetDataPointY2?(newY2: Y | undefined, oldY2: Y | undefined, controller: C): void;
    controllerDidSetDataPointY2?(newY2: Y | undefined, oldY2: Y | undefined, controller: C): void;
    controllerWillSetDataPointRadius?(newRadius: Length | null, oldRadius: Length | null, controller: C): void;
    controllerDidSetDataPointRadius?(newRadius: Length | null, oldRadius: Length | null, controller: C): void;
    controllerWillSetDataPointColor?(newColor: Color | null, oldColor: Color | null, controller: C): void;
    controllerDidSetDataPointColor?(newColor: Color | null, oldColor: Color | null, controller: C): void;
    controllerWillSetDataPointOpacity?(newOpacity: number | undefined, oldOpacity: number | undefined, controller: C): void;
    controllerDidSetDataPointOpacity?(newOpacity: number | undefined, oldOpacity: number | undefined, controller: C): void;
    controllerWillAttachDataPointLabelView?(labelView: GraphicsView, controller: C): void;
    controllerDidDetachDataPointLabelView?(labelView: GraphicsView, controller: C): void;
}

/** @public */
export declare type DataPointLabel<X = unknown, Y = unknown> = DataPointLabelFunction<X, Y> | string;

/** @public */
export declare type DataPointLabelFunction<X, Y> = (dataPointTrait: DataPointTrait<X, Y>) => GraphicsView | string | null;

/** @public */
export declare type DataPointLabelPlacement = "auto" | "above" | "middle" | "below";

/** @public */
export declare class DataPointTrait<X = unknown, Y = unknown> extends Trait {
    constructor(x: X, y: Y);
    readonly observerType?: Class<DataPointTraitObserver<X, Y>>;
    readonly x: Property<this, X>;
    readonly y: Property<this, Y>;
    readonly y2: Property<this, Y | undefined>;
    readonly radius: Property<this, Length | null, AnyLength | null>;
    readonly color: Property<this, Look<Color> | Color | null, Look<Color> | AnyColor | null>;
    readonly opacity: Property<this, number | undefined>;
    formatLabel(x: X | undefined, y: Y | undefined): string | undefined;
    readonly label: Property<this, DataPointLabel<X, Y> | null>;
}

/** @public */
export declare interface DataPointTraitObserver<X = unknown, Y = unknown, R extends DataPointTrait<X, Y> = DataPointTrait<X, Y>> extends TraitObserver<R> {
    traitWillSetDataPointX?(newX: X, oldX: X, trait: R): void;
    traitDidSetDataPointX?(newX: X, oldX: X, trait: R): void;
    traitWillSetDataPointY?(newY: Y, oldY: Y, trait: R): void;
    traitDidSetDataPointY?(newY: Y, oldY: Y, trait: R): void;
    traitWillSetDataPointY2?(newY2: Y | undefined, oldY2: Y | undefined, trait: R): void;
    traitDidSetDataPointY2?(newY2: Y | undefined, oldY2: Y | undefined, trait: R): void;
    traitWillSetDataPointRadius?(newRadius: Length | null, oldRadius: Length | null, trait: R): void;
    traitDidSetDataPointRadius?(newRadius: Length | null, oldRadius: Length | null, trait: R): void;
    traitWillSetDataPointColor?(newColor: Look<Color> | Color | null, oldColor: Look<Color> | Color | null, trait: R): void;
    traitDidSetDataPointColor?(newColor: Look<Color> | Color | null, oldColor: Look<Color> | Color | null, trait: R): void;
    traitWillSetDataPointOpacity?(newOpacity: number | undefined, oldOpacity: number | undefined, trait: R): void;
    traitDidSetDataPointOpacity?(newOpacity: number | undefined, oldOpacity: number | undefined, trait: R): void;
    traitWillSetDataPointLabel?(newLabel: DataPointLabel<X, Y> | null, oldLabel: DataPointLabel<X, Y> | null, trait: R): void;
    traitDidSetDataPointLabel?(newLabel: DataPointLabel<X, Y> | null, oldLabel: DataPointLabel<X, Y> | null, trait: R): void;
}

/** @public */
export declare class DataPointView<X = unknown, Y = unknown> extends GraphicsView {
    constructor();
    readonly observerType?: Class<DataPointViewObserver<X, Y>>;
    readonly xCoord: number;
    /** @internal */
    setXCoord(xCoord: number): void;
    readonly yCoord: number;
    /** @internal */
    setYCoord(yCoord: number): void;
    readonly y2Coord: number | undefined;
    /** @internal */
    setY2Coord(y2Coord: number | undefined): void;
    readonly x: Animator<this, X | undefined>;
    readonly y: Animator<this, Y>;
    readonly y2: Animator<this, Y | undefined>;
    readonly radius: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly hitRadius: Property<this, number>;
    readonly color: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly opacity: ThemeAnimator<this, number | undefined>;
    readonly font: ThemeAnimator<this, Font | undefined, AnyFont | undefined>;
    readonly textColor: ThemeAnimator<this, Color | undefined, AnyColor | undefined>;
    readonly category: Property<this, DataPointCategory | undefined>;
    readonly labelPadding: ThemeAnimator<this, Length, AnyLength>;
    readonly label: ViewRef<this, GraphicsView & Initable<GraphicsViewInit | string>>;
    static readonly label: MemberFastenerClass<DataPointView, "label">;
    readonly labelPlacement: Property<this, DataPointLabelPlacement>;
    setState(point: DataPointViewInit<X, Y>, timing?: AnyTiming | boolean): void;
    /** @internal */
    readonly gradientStop: boolean;
    isGradientStop(): boolean;
    protected updateGradientStop(): void;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected layoutDataPoint(frame: R2Box): void;
    protected layoutLabel(labelView: GraphicsView, frame: R2Box): void;
    protected hitTest(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestPoint(x: number, y: number, context: CanvasContext, frame: R2Box): GraphicsView | null;
    init(init: DataPointViewInit<X, Y>): void;
    static fromAny<X, Y>(value: AnyDataPointView<X, Y>): DataPointView<X, Y>;
    static fromAny<S extends abstract new (...args: any) => InstanceType<S>>(this: S, value: AnyView<InstanceType<S>>): InstanceType<S>;
}

/** @public */
export declare interface DataPointViewInit<X = unknown, Y = unknown> extends GraphicsViewInit {
    x: X;
    y: Y;
    y2?: Y;
    radius?: AnyLength;
    hitRadius?: number;
    color?: AnyColor;
    opacity?: number;
    font?: AnyFont;
    textColor?: AnyColor;
    category?: DataPointCategory;
    labelPadding?: AnyLength;
    labelPlacement?: DataPointLabelPlacement;
    label?: GraphicsView | string;
}

/** @public */
export declare interface DataPointViewObserver<X = unknown, Y = unknown, V extends DataPointView<X, Y> = DataPointView<X, Y>> extends GraphicsViewObserver<V> {
    viewWillSetDataPointX?(newX: X | undefined, oldX: X | undefined, view: V): void;
    viewDidSetDataPointX?(newX: X | undefined, oldX: X | undefined, view: V): void;
    viewWillSetDataPointY?(newY: Y | undefined, oldY: Y | undefined, view: V): void;
    viewDidSetDataPointY?(newY: Y | undefined, oldY: Y | undefined, view: V): void;
    viewWillSetDataPointY2?(newY2: Y | undefined, oldY2: Y | undefined, view: V): void;
    viewDidSetDataPointY2?(newY2: Y | undefined, oldY2: Y | undefined, view: V): void;
    viewWillSetDataPointRadius?(newRadius: Length | null, oldRadius: Length | null, view: V): void;
    viewDidSetDataPointRadius?(newRadius: Length | null, oldRadius: Length | null, view: V): void;
    viewWillSetDataPointColor?(newColor: Color | null, oldColor: Color | null, view: V): void;
    viewDidSetDataPointColor?(newColor: Color | null, oldColor: Color | null, view: V): void;
    viewWillSetDataPointOpacity?(newOpacity: number | undefined, oldOpacity: number | undefined, view: V): void;
    viewDidSetDataPointOpacity?(newOpacity: number | undefined, oldOpacity: number | undefined, view: V): void;
    viewWillAttachDataPointLabel?(labelView: GraphicsView, view: V): void;
    viewDidDetachDataPointLabel?(labelView: GraphicsView | null, view: V): void;
}

/** @public */
export declare class DataSetController<X = unknown, Y = unknown> extends Controller {
    readonly observerType?: Class<DataSetControllerObserver<X, Y>>;
    readonly dataSet: TraitRef<this, DataSetTrait<X, Y>>;
    static readonly dataSet: MemberFastenerClass<DataSetController, "dataSet">;
    readonly dataPointTiming: Property<this, Timing | boolean | undefined, AnyTiming>;
    readonly dataPoints: TraitViewControllerSet<this, DataPointTrait<X, Y>, DataPointView<X, Y>, DataPointController<X, Y>> & DataSetControllerDataPointExt<X, Y>;
    static readonly dataPoints: MemberFastenerClass<DataSetController, "dataPoints">;
}

/** @public */
export declare interface DataSetControllerDataPointExt<X = unknown, Y = unknown> {
    attachDataPointTrait(dataPointTrait: DataPointTrait<X, Y>, dataPointController: DataPointController<X, Y>): void;
    detachDataPointTrait(dataPointTrait: DataPointTrait<X, Y>, dataPointController: DataPointController<X, Y>): void;
    attachDataPointView(dataPointView: DataPointView<X, Y>, dataPointController: DataPointController<X, Y>): void;
    detachDataPointView(dataPointView: DataPointView<X, Y>, dataPointController: DataPointController<X, Y>): void;
    attachDataPointLabelView(labelView: GraphicsView, dataPointController: DataPointController<X, Y>): void;
    detachDataPointLabelView(labelView: GraphicsView, dataPointController: DataPointController<X, Y>): void;
}

/** @public */
export declare interface DataSetControllerObserver<X = unknown, Y = unknown, C extends DataSetController<X, Y> = DataSetController<X, Y>> extends ControllerObserver<C> {
    controllerWillAttachDataSetTrait?(dataSetTrait: DataSetTrait<X, Y>, controller: C): void;
    controllerDidDetachDataSetTrait?(dataSetTrait: DataSetTrait<X, Y>, controller: C): void;
    controllerWillAttachDataPoint?(dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerDidDetachDataPoint?(dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerWillAttachDataPointTrait?(dataPointTrait: DataPointTrait<X, Y>, dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerDidDetachDataPointTrait?(dataPointTrait: DataPointTrait<X, Y>, dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerWillAttachDataPointView?(dataPointView: DataPointView<X, Y>, dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerDidDetachDataPointView?(dataPointView: DataPointView<X, Y>, dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerWillSetDataPointX?(newX: X | undefined, oldX: X | undefined, dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerDidSetDataPointX?(newX: X | undefined, oldX: X | undefined, dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerWillSetDataPointY?(newY: Y | undefined, oldY: Y | undefined, dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerDidSetDataPointY?(newY: Y | undefined, oldY: Y | undefined, dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerWillSetDataPointY2?(newY2: Y | undefined, oldY2: Y | undefined, dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerDidSetDataPointY2?(newY2: Y | undefined, oldY2: Y | undefined, dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerWillSetDataPointRadius?(newRadius: Length | null, oldRadius: Length | null, dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerDidSetDataPointRadius?(newRadius: Length | null, oldRadius: Length | null, dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerWillSetDataPointColor?(newColor: Color | null, oldColor: Color | null, dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerDidSetDataPointColor?(newColor: Color | null, oldColor: Color | null, dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerWillSetDataPointOpacity?(newOpacity: number | undefined, oldOpacity: number | undefined, dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerDidSetDataPointOpacity?(newOpacity: number | undefined, oldOpacity: number | undefined, dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerWillAttachDataPointLabelView?(labelView: GraphicsView | null, dataPointController: DataPointController<X, Y>, controller: C): void;
    controllerDidDetachDataPointLabelView?(labelView: GraphicsView | null, dataPointController: DataPointController<X, Y>, controller: C): void;
}

/** @public */
export declare class DataSetTrait<X = unknown, Y = unknown> extends Trait {
    readonly observerType?: Class<DataSetTraitObserver<X, Y>>;
    readonly dataPoints: TraitSet<this, DataPointTrait<X, Y>>;
    static readonly dataPoints: MemberFastenerClass<DataSetTrait, "dataPoints">;
    /** @internal */
    protected startConsumingDataPoints(): void;
    /** @internal */
    protected stopConsumingDataPoints(): void;
    protected onStartConsuming(): void;
    protected onStopConsuming(): void;
}

/** @public */
export declare interface DataSetTraitObserver<X = unknown, Y = unknown, R extends DataSetTrait<X, Y> = DataSetTrait<X, Y>> extends TraitObserver<R> {
    traitWillAttachDataPoint?(dataPointTrait: DataPointTrait<X, Y>, targetTrait: Trait | null, trait: R): void;
    traitDidDetachDataPoint?(dataPointTrait: DataPointTrait<X, Y>, trait: R): void;
}

/** @public */
export declare class DeckBar extends HtmlView {
    constructor(node: HTMLElement);
    protected initBar(): void;
    readonly observerType?: Class<DeckBarObserver>;
    protected initTheme(): void;
    readonly rail: Property<this, DeckRail | null, AnyDeckRail | null>;
    readonly deckPhase: ThemeAnimator<this, number | undefined>;
    readonly barHeight: Property<this, Length, AnyLength>;
    readonly itemSpacing: Property<this, Length | null, AnyLength | null>;
    readonly edgeInsets: Property<this, ViewportInsets | null>;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    onInsertChild(childView: View, targetView: View | null): void;
    protected onInsertSlot(childView: DeckSlot): void;
    protected onResize(viewContext: ViewContextType<this>): void;
    protected resizeBar(viewContext: ViewContextType<this>): void;
    onLayout(viewContext: ViewContextType<this>): void;
    protected layoutBar(viewContext: ViewContextType<this>): void;
    protected displayChildren(displayFlags: ViewFlags, viewContext: ViewContextType<this>, displayChild: (this: this, childView: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    protected layoutChildViews(displayFlags: ViewFlags, viewContext: ViewContextType<this>, displayChild: (this: this, childView: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    /** @internal */
    didPressBackButton(event: Event | null): void;
    /** @internal */
    didPressCloseButton(event: Event | null): void;
}

/** @public */
export declare interface DeckBarObserver<V extends DeckBar = DeckBar> extends HtmlViewObserver<V> {
    deckBarDidPressBackButton?(event: Event | null, view: V): void;
    deckBarDidPressCloseButton?(event: Event | null, view: V): void;
}

/** @public */
export declare class DeckButton extends DeckSlot {
    constructor(node: HTMLElement);
    protected initButton(): void;
    readonly observerType?: Class<DeckButtonObserver>;
    readonly iconPadding: Property<this, Length, AnyLength>;
    readonly deckPhase: ThemeAnimator<this, number | undefined>;
    readonly slotAlign: ThemeAnimator<this, number>;
    get colorLook(): Look<Color>;
    /** @internal */
    readonly closeIcon: DeckButtonCloseIcon<this, SvgIconView>;
    /** @internal */
    readonly backIcon: DeckButtonBackIcon<this, SvgIconView>;
    /** @internal */
    labelCount: number;
    /** @internal */
    label: DeckButtonLabel<this, HtmlView> | null;
    protected createLabel(value: string): HtmlView;
    pushLabel(newLabelView: HtmlView | string, timing?: AnyTiming | boolean): void;
    protected willPushLabel(newLabelView: HtmlView, oldLabelView: HtmlView | null): void;
    protected didPushLabel(newLabelView: HtmlView, oldLabelView: HtmlView | null): void;
    popLabel(timing?: AnyTiming | boolean): HtmlView | null;
    protected willPopLabel(newLabelView: HtmlView | null, oldLabelView: HtmlView): void;
    protected didPopLabel(newLabelView: HtmlView | null, oldLabelView: HtmlView): void;
    protected didLayout(viewContext: ViewContextType<this>): void;
}

/** @internal */
export declare interface DeckButtonBackIcon<O extends DeckButton = DeckButton, V extends SvgIconView = SvgIconView> extends ViewRef<O, V> {
    /** @override */
    didAttachView(iconView: V): void;
    /** @override */
    insertChild(parent: View, child: V, target: View | number | null, key: string | undefined): void;
    viewDidLayout(viewContext: ViewContext, iconView: V): void;
    /** @protected */
    initIcon(iconView: V): void;
    /** @protected */
    layoutIcon(iconView: V): void;
}

/** @internal */
export declare const DeckButtonBackIcon: ViewRefFactory<DeckButtonBackIcon<any, any>>;

/** @internal */
export declare interface DeckButtonCloseIcon<O extends DeckButton = DeckButton, V extends SvgIconView = SvgIconView> extends ViewRef<O, V> {
    /** @override */
    didAttachView(iconView: V): void;
    /** @override */
    insertChild(parent: View, child: V, target: View | number | null, key: string | undefined): void;
    viewDidLayout(viewContext: ViewContext, iconView: V): void;
    /** @protected */
    initIcon(iconView: V): void;
    /** @protected */
    layoutIcon(iconView: V): void;
}

/** @internal */
export declare const DeckButtonCloseIcon: ViewRefFactory<DeckButtonCloseIcon<any, any>>;

/** @internal */
export declare interface DeckButtonLabel<O extends DeckButton = DeckButton, V extends HtmlView = HtmlView> extends ViewRef<O, V> {
    labelIndex: number;
    /** @internal */
    labelWidth: Length | string | null;
    /** @internal */
    layoutWidth: number;
    /** @override */
    didAttachView(labelView: V): void;
    /** @override */
    insertChild(parent: View, child: V, target: View | number | null, key: string | undefined): void;
    /** @protected */
    viewDidApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean, labelView: V): void;
    viewDidLayout(viewContext: ViewContext, labelView: V): void;
    /** @protected */
    initLabel(labelView: V): void;
    /** @protected */
    layoutLabel(labelView: V): void;
}

/** @internal */
export declare const DeckButtonLabel: ViewRefFactory<DeckButtonLabel<any, any>>;

/** @public */
export declare interface DeckButtonObserver<V extends DeckButton = DeckButton> extends HtmlViewObserver<V> {
    deckButtonWillPushLabel?(newLabelView: HtmlView, oldLabelView: HtmlView | null, view: V): void;
    deckButtonDidPushLabel?(newLabelView: HtmlView, oldLabelView: HtmlView | null, view: V): void;
    deckButtonWillPopLabel?(newLabelView: HtmlView | null, oldLabelView: HtmlView, view: V): void;
    deckButtonDidPopLabel?(newLabelView: HtmlView | null, oldLabelView: HtmlView, view: V): void;
}

/** @public */
export declare class DeckCard extends HtmlView {
    constructor(node: HTMLElement);
    protected initCard(): void;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    readonly edgeInsets: Property<this, ViewportInsets | null>;
    readonly cardTitle: Property<this, string | undefined>;
    readonly backItem: ViewRef<this, HtmlView>;
    readonly titleView: ViewRef<this, HtmlView>;
    readonly leftItem: ViewRef<this, HtmlView>;
    readonly rightItem: ViewRef<this, HtmlView>;
}

/** @public */
export declare class DeckPost implements Equals, Equivalent, Debug {
    constructor(key: string, grow: number, shrink: number, basis: Length, width: Length | null, left: Length | null, right: Length | null);
    readonly key: string;
    readonly grow: number;
    withGrow(grow: number): DeckPost;
    readonly shrink: number;
    withShrink(shrink: number): DeckPost;
    readonly basis: Length;
    withBasis(basis: AnyLength): DeckPost;
    readonly width: Length | null;
    readonly left: Length | null;
    readonly right: Length | null;
    resized(width: AnyLength | null, left: AnyLength | null, right: AnyLength | null): DeckPost;
    protected copy(key: string, grow: number, shrink: number, basis: Length, width: Length | null, left: Length | null, right: Length | null): DeckPost;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static create(key: string, grow?: number, shrink?: number, basis?: AnyLength): DeckPost;
    static fromAny(value: AnyDeckPost): DeckPost;
    static fromInit(init: DeckPostInit): DeckPost;
}

/** @public */
export declare interface DeckPostInit {
    key?: string;
    grow?: number;
    shrink?: number;
    basis?: AnyLength;
    width?: AnyLength | null;
    left?: AnyLength | null;
    right?: AnyLength | null;
}

/** @public */
export declare class DeckRail implements Equals, Equivalent, Debug {
    constructor(width: Length | null, left: Length | null, right: Length | null, spacing: Length | null, posts: ReadonlyArray<DeckPost>);
    readonly width: Length | null;
    readonly left: Length | null;
    readonly right: Length | null;
    readonly spacing: Length | null;
    readonly posts: ReadonlyArray<DeckPost>;
    lookupPost(key: string): number | undefined;
    getPost(key: string | number): DeckPost | null;
    resized(width: AnyLength, left?: AnyLength | null, right?: AnyLength | null, spacing?: AnyLength | null): DeckRail;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static of(...deckPosts: AnyDeckPost[]): DeckRail;
    static create(posts: ReadonlyArray<DeckPost>): DeckRail;
    static fromAny(value: AnyDeckRail): DeckRail;
    static fromInit(init: DeckRailInit): DeckRail;
}

/** @public */
export declare interface DeckRailInit {
    width?: AnyLength | null;
    left?: AnyLength | null;
    right?: AnyLength | null;
    spacing?: AnyLength | null;
    posts?: AnyDeckPost[];
}

/** @public */
export declare class DeckSlider extends DeckSlot {
    constructor(node: HTMLElement);
    initSlider(): void;
    readonly observerType?: Class<DeckSliderObserver>;
    readonly deckPhase: ThemeAnimator<this, number | undefined>;
    readonly slotAlign: ThemeAnimator<this, number>;
    get colorLook(): Look<Color>;
    /** @internal */
    itemCount: number;
    /** @internal */
    item: DeckSliderItem<this, HtmlView> | null;
    protected createItem(value: string): HtmlView;
    pushItem(newItemView: HtmlView | string, timing?: AnyTiming | boolean): void;
    protected willPushItem(newItemView: HtmlView, oldItemView: HtmlView | null): void;
    protected didPushItem(newItemView: HtmlView, oldItemView: HtmlView | null): void;
    popItem(timing?: AnyTiming | boolean): HtmlView | null;
    protected willPopItem(newItemView: HtmlView | null, oldItemView: HtmlView): void;
    protected didPopItem(newItemView: HtmlView | null, oldItemView: HtmlView): void;
    protected didLayout(viewContext: ViewContextType<this>): void;
}

/** @internal */
export declare interface DeckSliderItem<O extends DeckSlider = DeckSlider, V extends HtmlView = HtmlView> extends ViewRef<O, V> {
    itemIndex: number;
    /** @internal */
    itemWidth: Length | string | null;
    /** @override */
    didAttachView(itemView: V): void;
    /** @override */
    insertChild(parent: View, child: V, target: View | number | null, key: string | undefined): void;
    /** @protected */
    viewDidApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean, itemView: V): void;
    viewDidLayout(viewContext: ViewContext, itemView: V): void;
    /** @protected */
    initItem(itemView: V): void;
    /** @protected */
    layoutItem(itemView: V): void;
}

/** @internal */
export declare const DeckSliderItem: ViewRefFactory<DeckSliderItem<any, any>>;

/** @public */
export declare interface DeckSliderObserver<V extends DeckSlider = DeckSlider> extends HtmlViewObserver<V> {
    deckSliderWillPushItem?(newItemView: HtmlView, oldItemView: HtmlView | null, view: V): void;
    deckSliderDidPushItem?(newItemView: HtmlView, oldItemView: HtmlView | null, view: V): void;
    deckSliderWillPopItem?(newItemView: HtmlView | null, oldItemView: HtmlView, view: V): void;
    deckSliderDidPopItem?(newItemView: HtmlView | null, oldItemView: HtmlView, view: V): void;
}

/** @public */
export declare abstract class DeckSlot extends HtmlView {
    constructor(node: HTMLElement);
    protected initSlot(): void;
    readonly post: Property<this, DeckPost | null, AnyDeckPost | null>;
    readonly nextPost: Property<this, DeckPost | null, AnyDeckPost | null>;
    readonly prevPost: Property<this, DeckPost | null, AnyDeckPost | null>;
    abstract readonly deckPhase: ThemeAnimator<this, number | undefined>;
    abstract readonly slotAlign: ThemeAnimator<this, number>;
    abstract readonly colorLook: Look<Color>;
}

/** @public */
export declare class DeckView extends HtmlView {
    constructor(node: HTMLElement);
    protected initDeck(): void;
    readonly observerType?: Class<DeckViewObserver>;
    readonly deckPhase: ThemeAnimator<this, number>;
    readonly inAlign: Property<this, number>;
    readonly outAlign: Property<this, number>;
    readonly edgeInsets: Property<this, ViewportInsets | null>;
    /** @internal */
    readonly bar: DeckViewBar<this, DeckBar>;
    /** @internal */
    cardCount: number;
    card: ViewRef<this, DeckCard> | null;
    pushCard(newCardView: DeckCard, timing?: AnyTiming | boolean): void;
    protected willPushCard(newCardView: DeckCard, oldCardView: DeckCard | null): void;
    protected onPushCard(newCardView: DeckCard, oldCardView: DeckCard | null): void;
    protected didPushCard(newCardView: DeckCard, oldCardView: DeckCard | null): void;
    popCard(timing?: AnyTiming | boolean): DeckCard | null;
    protected willPopCard(newCardView: DeckCard | null, oldCardView: DeckCard): void;
    protected onPopCard(newCardView: DeckCard | null, oldCardView: DeckCard): void;
    protected didPopCard(newCardView: DeckCard | null, oldCardView: DeckCard): void;
    protected didLayout(viewContext: ViewContextType<this>): void;
    /** @internal */
    didPressBackButton(event: Event | null): void;
    /** @internal */
    didPressCloseButton(event: Event | null): void;
}

/** @internal */
export declare interface DeckViewBar<O extends DeckView = DeckView, V extends DeckBar = DeckBar> extends ViewRef<O, V> {
    /** @override */
    didAttachView(barView: V): void;
    /** @override */
    insertChild(parent: View, child: V, target: View | number | null, key: string | undefined): void;
    viewDidResize(viewContext: ViewContext, barView: V): void;
    /** @protected */
    initBar(barView: V): void;
    /** @protected */
    resizeBar(barView: V): void;
    deckBarDidPressBackButton(event: Event | null, view: O): void;
    deckBarDidPressCloseButton(event: Event | null, view: O): void;
}

/** @internal */
export declare const DeckViewBar: ViewRefFactory<DeckViewBar<any, any>>;

/** @internal */
export declare interface DeckViewCard<O extends DeckView = DeckView, V extends DeckCard = DeckCard> extends ViewRef<O, V> {
    cardIndex: number;
    /** @override */
    didAttachView(cardView: V): void;
    /** @override */
    insertChild(parent: View, child: V, target: View | number | null, key: string | undefined): void;
    viewDidResize(viewContext: ViewContext, cardView: V): void;
    viewDidLayout(viewContext: ViewContext, cardView: V): void;
    /** @protected */
    initCard(cardView: V): void;
    /** @protected */
    resizeCard(cardView: V, viewContext: ViewContext): void;
    /** @protected */
    layoutCard(cardView: V, viewContext: ViewContext): void;
}

/** @internal */
export declare const DeckViewCard: ViewRefFactory<DeckViewCard<any, any>>;

/** @public */
export declare interface DeckViewObserver<V extends DeckView = DeckView> extends HtmlViewObserver<V> {
    deckWillPushCard?(newCardView: DeckCard, oldCardView: DeckCard | null, view: V): void;
    deckDidPushCard?(newCardView: DeckCard, oldCardView: DeckCard | null, view: V): void;
    deckWillPopCard?(newCardView: DeckCard | null, oldCardView: DeckCard, view: V): void;
    deckDidPopCard?(newCardView: DeckCard | null, oldCardView: DeckCard, view: V): void;
    deckDidPressBackButton?(event: Event | null, view: V): void;
    deckDidPressCloseButton?(event: Event | null, view: V): void;
}

/** @public */
export declare class DialController extends Controller {
    readonly observerType?: Class<DialControllerObserver>;
    protected updateLabel(value: number, limit: number, dialTrait: DialTrait): void;
    protected updateLegend(value: number, limit: number, dialTrait: DialTrait): void;
    protected setValue(value: number, timing?: AnyTiming | boolean): void;
    protected setLimit(limit: number, timing?: AnyTiming | boolean): void;
    protected setDialColor(dialColor: Look<Color> | Color | null, timing?: AnyTiming | boolean): void;
    protected setMeterColor(meterColor: Look<Color> | Color | null, timing?: AnyTiming | boolean): void;
    protected createLabelView(label: DialLabel): GraphicsView | string | null;
    protected setLabelView(label: DialLabel | null): void;
    protected createLegendView(legend: DialLegend): GraphicsView | string | null;
    protected setLegendView(legend: DialLegend | null): void;
    readonly dialTiming: Property<this, Timing | boolean | undefined, AnyTiming>;
    readonly dial: TraitViewRef<this, DialTrait, DialView>;
    static readonly dial: MemberFastenerClass<DialController, "dial">;
    readonly label: ViewRef<this, GraphicsView>;
    static readonly label: MemberFastenerClass<DialController, "label">;
    readonly legend: ViewRef<this, GraphicsView>;
    static readonly legend: MemberFastenerClass<DialController, "legend">;
}

/** @public */
export declare interface DialControllerObserver<C extends DialController = DialController> extends ControllerObserver<C> {
    controllerWillAttachDialTrait?(dialTrait: DialTrait, controller: C): void;
    controllerDidDetachDialTrait?(dialTrait: DialTrait, controller: C): void;
    controllerWillAttachDialView?(dialView: DialView, controller: C): void;
    controllerDidDetachDialView?(dialView: DialView, controller: C): void;
    controllerWillSetDialValue?(newValue: number, oldValue: number, controller: C): void;
    controllerDidSetDialValue?(newValue: number, oldValue: number, controller: C): void;
    controllerWillSetDialLimit?(newLimit: number, oldLimit: number, controller: C): void;
    controllerDidSetDialLimit?(newLimit: number, oldLimit: number, controller: C): void;
    controllerWillAttachDialLabelView?(labelView: GraphicsView, controller: C): void;
    controllerDidDetachDialLabelView?(labelView: GraphicsView, controller: C): void;
    controllerWillAttachDialLegendView?(legendView: GraphicsView, controller: C): void;
    controllerDidDetachDialLegendView?(legendView: GraphicsView, controller: C): void;
}

/** @public */
export declare type DialLabel = DialLabelFunction | string;

/** @public */
export declare type DialLabelFunction = (dialTrait: DialTrait | null) => GraphicsView | string | null;

/** @public */
export declare type DialLegend = DialLegendFunction | string;

/** @public */
export declare type DialLegendFunction = (dialTrait: DialTrait | null) => GraphicsView | string | null;

/** @public */
export declare class DialTrait extends Trait {
    readonly observerType?: Class<DialTraitObserver>;
    readonly value: Property<this, number>;
    readonly limit: Property<this, number>;
    readonly dialColor: Property<this, Look<Color> | Color | null, Look<Color> | AnyColor | null>;
    readonly meterColor: Property<this, Look<Color> | Color | null, Look<Color> | AnyColor | null>;
    formatLabel(value: number, limit: number): string | undefined;
    readonly label: Property<this, DialLabel | null>;
    formatLegend(value: number, limit: number): string | undefined;
    readonly legend: Property<this, DialLegend | null>;
}

/** @public */
export declare interface DialTraitObserver<R extends DialTrait = DialTrait> extends TraitObserver<R> {
    traitWillSetDialValue?(newValue: number, oldValue: number, trait: R): void;
    traitDidSetDialValue?(newValue: number, oldValue: number, trait: R): void;
    traitWillSetDialLimit?(newLimit: number, oldLimit: number, trait: R): void;
    traitDidSetDialLimit?(newLimit: number, oldLimit: number, trait: R): void;
    traitWillSetDialColor?(newDialColor: Look<Color> | Color | null, oldDialColor: Look<Color> | Color | null, trait: R): void;
    traitDidSetDialColor?(newDialColor: Look<Color> | Color | null, oldDialColor: Look<Color> | Color | null, trait: R): void;
    traitWillSetMeterColor?(newMeterColor: Look<Color> | Color | null, oldMeterColor: Look<Color> | Color | null, trait: R): void;
    traitDidSetMeterColor?(newMeterColor: Look<Color> | Color | null, oldMeterColor: Look<Color> | Color | null, trait: R): void;
    traitWillSetDialLabel?(newLabel: DialLabel | null, oldLabel: DialLabel | null, trait: R): void;
    traitDidSetDialLabel?(newLabel: DialLabel | null, oldLabel: DialLabel | null, trait: R): void;
    traitWillSetDialLegend?(newLegend: DialLegend | null, oldLegend: DialLegend | null, trait: R): void;
    traitDidSetDialLegend?(newLegend: DialLegend | null, oldLegend: DialLegend | null, trait: R): void;
}

/** @public */
export declare class DialView extends GraphicsView {
    readonly observerType?: Class<DialViewObserver>;
    readonly value: Animator<this, number>;
    readonly limit: Animator<this, number>;
    readonly center: Animator<this, R2Point, AnyR2Point>;
    readonly innerRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly outerRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly startAngle: ThemeAnimator<this, Angle, AnyAngle>;
    readonly sweepAngle: ThemeAnimator<this, Angle, AnyAngle>;
    readonly cornerRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly dialColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly meterColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly labelPadding: ThemeAnimator<this, Length, AnyLength>;
    readonly tickAlign: ThemeAnimator<this, number>;
    readonly tickRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly tickLength: ThemeAnimator<this, Length, AnyLength>;
    readonly tickWidth: ThemeAnimator<this, Length, AnyLength>;
    readonly tickPadding: ThemeAnimator<this, Length, AnyLength>;
    readonly tickColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly font: ThemeAnimator<this, Font | null, AnyFont | null>;
    readonly textColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly label: ViewRef<this, GraphicsView & Initable<GraphicsViewInit | string>>;
    static readonly label: MemberFastenerClass<DialView, "label">;
    readonly legend: ViewRef<this, GraphicsView & Initable<GraphicsViewInit | string>>;
    static readonly legend: MemberFastenerClass<DialView, "legend">;
    readonly arrangement: Property<this, DialViewArrangement>;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected renderDial(context: CanvasContext, frame: R2Box): void;
    protected hitTest(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestDial(x: number, y: number, context: CanvasContext, frame: R2Box): GraphicsView | null;
    init(init: DialViewInit): void;
}

/** @public */
export declare type DialViewArrangement = "auto" | "manual";

/** @public */
export declare interface DialViewInit extends GraphicsViewInit {
    value?: number;
    limit?: number;
    center?: AnyR2Point;
    innerRadius?: AnyLength;
    outerRadius?: AnyLength;
    startAngle?: AnyAngle;
    sweepAngle?: AnyAngle;
    cornerRadius?: AnyLength;
    dialColor?: AnyColor;
    meterColor?: AnyColor;
    labelPadding?: AnyLength;
    tickAlign?: number;
    tickRadius?: AnyLength;
    tickLength?: AnyLength;
    tickWidth?: AnyLength;
    tickPadding?: AnyLength;
    tickColor?: AnyColor;
    font?: AnyFont;
    textColor?: AnyColor;
    arrangement?: DialViewArrangement;
    label?: GraphicsView | string;
    legend?: GraphicsView | string;
}

/** @public */
export declare interface DialViewObserver<V extends DialView = DialView> extends ViewObserver<V> {
    viewWillSetDialValue?(newValue: number, oldValue: number, view: V): void;
    viewDidSetDialValue?(newValue: number, oldValue: number, view: V): void;
    viewWillSetDialLimit?(newLimit: number, oldLimit: number, view: V): void;
    viewDidSetDialLimit?(newLimit: number, oldLimit: number, view: V): void;
    viewWillAttachDialLabel?(labelView: GraphicsView, view: V): void;
    viewDidDetachDialLabel?(labelView: GraphicsView, view: V): void;
    viewWillAttachDialLegend?(legendView: GraphicsView, view: V): void;
    viewDidDetachDialLegend?(legendView: GraphicsView, view: V): void;
}

/** @public */
export declare class DisclosureButton extends HtmlView {
    constructor(node: HTMLElement);
    protected initDisclosureButton(): void;
    get icon(): SvgView;
    get arrow(): SvgView;
    readonly disclosure: ExpansionThemeAnimator<this, Expansion, AnyExpansion>;
    readonly collapsedColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly expandedColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    protected needsDisplay(displayFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    protected onLayout(viewContext: ViewContextType<this>): void;
}

/** @public */
export declare class DisclosureCellView extends CellView {
    protected initCell(): void;
    readonly disclosure: ExpansionThemeAnimator<this, Expansion, AnyExpansion>;
    readonly button: ViewRef<this, DisclosureButton>;
    static readonly button: MemberFastenerClass<DisclosureCellView, "button">;
    didPress(input: PositionGestureInput, event: Event | null): void;
}

/** @public */
export declare interface DisplayProvider<V extends View, S extends DisplayService<V> | null | undefined = DisplayService<V>> extends Provider<V, S> {
    updatedViewContext(viewContext: ViewContext): ViewContext;
    requestUpdate(target: View, updateFlags: ViewFlags, immediate: boolean): void;
    createService(): S;
}

/** @public */
export declare const DisplayProvider: ProviderClass<DisplayProvider<any, any>>;

/** @public */
export declare class DisplayService<V extends View = View> extends Service<V> {
    constructor();
    readonly observerType?: Class<DisplayServiceObserver<V>>;
    /** @internal */
    readonly flags: ViewFlags;
    /** @internal */
    setFlags(flags: ViewFlags): void;
    updatedViewContext(viewContext: ViewContext): ViewContext;
    /** @internal */
    updateDelay: number;
    protected needsUpdate(updateFlags: ViewFlags, immediate: boolean): ViewFlags;
    requestUpdate(targetView: View, updateFlags: ViewFlags, immediate: boolean): void;
    protected scheduleUpdate(): void;
    protected cancelUpdate(): void;
    protected runImmediatePass(): void;
    /** @internal */
    processTimer: number;
    protected scheduleProcessPass(updateDelay: number): void;
    protected cancelProcessPass(): void;
    protected runProcessPass(immediate?: boolean): void;
    /** @internal */
    displayFrame: number;
    protected scheduleDisplayPass(): void;
    protected cancelDisplayPass(): void;
    protected runDisplayPass(time?: number, immediate?: boolean): void;
    get powerFlags(): ViewFlags;
    power(): void;
    unpower(): void;
    protected onAttachRoot(root: V): void;
    protected onAttach(): void;
    protected onDetach(): void;
    protected attachEvents(): void;
    protected detachEvents(): void;
    /** @internal */
    protected onVisibilityChange(): void;
    /** @internal */
    static MinUpdateDelay: number;
    /** @internal */
    static MaxUpdateDelay: number;
    /** @internal */
    static MinProcessInterval: number;
    /** @internal */
    static MaxProcessInterval: number;
    static global<V extends View>(): DisplayService<V>;
}

/** @public */
export declare interface DisplayServiceObserver<V extends View = View, S extends DisplayService<V> = DisplayService<V>> extends ServiceObserver<V, S> {
}

/** @public */
export declare interface DomProvider<V extends NodeView, S extends DomService<V> | null | undefined = DomService<V>> extends Provider<V, S> {
    createService(): S;
}

/** @public */
export declare const DomProvider: ProviderClass<DomProvider<any, any>>;

/** @public */
export declare class DomService<V extends NodeView = NodeView> extends Service<V> {
    /** @override */
    readonly observerType?: Class<DomServiceObserver<V>>;
    protected onAttachRoot(root: V): void;
    materializeView(parentView: NodeView): void;
    materializeNode(parentView: NodeView, childNode: ViewNode): NodeView | null;
    materializeElement(parentView: NodeView, childNode: Element): ElementView | null;
    materializeText(parentView: NodeView, childNode: Text): TextView | null;
    static global<V extends NodeView>(): DomService<V>;
    static boot(): ElementView[];
    static bootElement(node: ViewElement): ElementView;
    /** @internal */
    static eval(qname: string): unknown;
}

/** @public */
export declare interface DomServiceObserver<V extends NodeView = NodeView, S extends DomService<V> = DomService<V>> extends ServiceObserver<V, S> {
}

/** @beta */
export declare abstract class DownlinkTrait extends Trait {
    readonly driver: TraitRef<this, Trait>;
    static readonly driver: MemberFastenerClass<DownlinkTrait, "driver">;
}

/** @public */
export declare class DrawerButton extends IconButton {
    constructor(node: HTMLElement);
    protected initButton(): void;
    protected initIcon(): void;
    readonly drawerView: DrawerView | null;
    setDrawerView(drawerView: DrawerView | null): void;
    protected onClick(event: MouseEvent): void;
    static get hamburgerIcon(): Graphics;
}

/** @public */
export declare type DrawerPlacement = "top" | "right" | "bottom" | "left";

/** @public */
export declare class DrawerView extends HtmlView implements Modal {
    constructor(node: HTMLElement);
    readonly observerType?: Class<DrawerViewObserver>;
    protected initDrawer(): void;
    readonly collapsedWidth: ThemeConstraintAnimator<this, Length, AnyLength>;
    readonly expandedWidth: ThemeConstraintAnimator<this, Length, AnyLength>;
    readonly effectiveWidth: ConstraintProperty<this, Length | null, AnyLength | null>;
    readonly effectiveHeight: ConstraintProperty<this, Length | null, AnyLength | null>;
    isHorizontal(): boolean;
    isVertical(): boolean;
    protected willSetPlacement(newPlacement: DrawerPlacement, oldPlacement: DrawerPlacement): void;
    protected onSetPlacement(newPlacement: DrawerPlacement, oldPlacement: DrawerPlacement): void;
    protected didSetPlacement(newPlacement: DrawerPlacement, oldPlacement: DrawerPlacement): void;
    readonly placement: Property<this, DrawerPlacement>;
    protected willPresent(): void;
    protected didPresent(): void;
    protected willDismiss(): void;
    protected didDismiss(): void;
    readonly slide: PresenceThemeAnimator<this, Presence, AnyPresence>;
    protected willExpand(): void;
    protected didExpand(): void;
    protected willCollapse(): void;
    protected didCollapse(): void;
    readonly stretch: ExpansionThemeAnimator<this, Expansion, AnyExpansion>;
    readonly edgeInsets: Property<this, ViewportInsets | null>;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected layoutDrawer(viewContext: ViewContextType<this>): void;
    protected layoutDrawerTop(viewContext: ViewContextType<this>): void;
    protected layoutDrawerRight(viewContext: ViewContextType<this>): void;
    protected layoutDrawerBottom(viewContext: ViewContextType<this>): void;
    protected layoutDrawerLeft(viewContext: ViewContextType<this>): void;
    get modalView(): View | null;
    get modalState(): ModalState;
    readonly modality: boolean | number;
    showModal(options: ModalOptions, timing?: AnyTiming | boolean): void;
    hideModal(timing?: AnyTiming | boolean): void;
    present(timing?: AnyTiming | boolean): void;
    dismiss(timing?: AnyTiming | boolean): void;
    expand(timing?: AnyTiming | boolean): void;
    collapse(timing?: AnyTiming | boolean): void;
    toggle(timing?: AnyTiming | boolean): void;
    init(init: DrawerViewInit): void;
}

/** @public */
export declare interface DrawerViewInit extends HtmlViewInit {
    placement?: DrawerPlacement;
    collapsedWidth?: AnyLength;
    expandedWidth?: AnyLength;
}

/** @public */
export declare interface DrawerViewObserver<V extends DrawerView = DrawerView> extends HtmlViewObserver<V> {
    viewWillSetPlacement?(newPlacement: DrawerPlacement, oldPlacement: DrawerPlacement, view: V): void;
    viewDidSetPlacement?(newPlacement: DrawerPlacement, oldPlacement: DrawerPlacement, view: V): void;
    viewWillPresent?(view: V): void;
    viewDidPresent?(view: V): void;
    viewWillDismiss?(view: V): void;
    viewDidDismiss?(view: V): void;
    viewWillExpand?(view: V): void;
    viewDidExpand?(view: V): void;
    viewWillCollapse?(view: V): void;
    viewDidCollapse?(view: V): void;
}

/** @public */
export declare interface DrawingContext extends GraphicsContext, R2PathContext {
    moveTo(x: number, y: number): void;
    lineTo(x: number, y: number): void;
    quadraticCurveTo(x1: number, y1: number, x: number, y: number): void;
    bezierCurveTo(x1: number, y1: number, x2: number, y2: number, x: number, y: number): void;
    arcTo(x1: number, y1: number, x2: number, y2: number, r: number): void;
    arc(cx: number, cy: number, r: number, a0: number, a1: number, ccw?: boolean): void;
    ellipse(cx: number, cy: number, rx: number, ry: number, phi: number, a0: number, a1: number, ccw?: boolean): void;
    rect(x: number, y: number, w: number, h: number): void;
    closePath(): void;
}

/** @public */
export declare abstract class DrawingRenderer extends GraphicsRenderer {
    abstract readonly context: DrawingContext;
    abstract readonly transform: Transform;
    abstract readonly pixelRatio: number;
}

/** @public */
export declare class ElementView extends NodeView implements StyleContext {
    constructor(node: Element);
    readonly observerType?: Class<ElementViewObserver>;
    readonly node: Element & ElementCSSInlineStyle;
    protected initElement(node: Element): void;
    /** @internal */
    protected mountTheme(): void;
    getAttribute(attributeName: string): string | null;
    setAttribute(attributeName: string, value: unknown): this;
    protected willSetAttribute(attributeName: string, value: unknown): void;
    protected onSetAttribute(attributeName: string, value: unknown): void;
    protected didSetAttribute(attributeName: string, value: unknown): void;
    getStyle(propertyNames: string | ReadonlyArray<string>): CSSStyleValue | string | undefined;
    setStyle(propertyName: string, value: unknown, priority?: string): this;
    protected willSetStyle(propertyName: string, value: unknown, priority: string | undefined): void;
    protected onSetStyle(propertyName: string, value: unknown, priority: string | undefined): void;
    protected didSetStyle(propertyName: string, value: unknown, priority: string | undefined): void;
    id(): string | undefined;
    id(value: string | undefined): this;
    className(): string | undefined;
    className(value: string | undefined): this;
    get classList(): DOMTokenList;
    hasClass(className: string): boolean;
    addClass(...classNames: string[]): this;
    removeClass(...classNames: string[]): this;
    toggleClass(className: string, state?: boolean): this;
    get clientBounds(): R2Box;
    get pageBounds(): R2Box;
    on<K extends keyof ElementEventMap>(type: K, listener: (this: Element, event: ElementEventMap[K]) => unknown, options?: AddEventListenerOptions | boolean): this;
    on(type: string, listener: EventListenerOrEventListenerObject, options?: AddEventListenerOptions | boolean): this;
    off<K extends keyof ElementEventMap>(type: K, listener: (this: Element, event: ElementEventMap[K]) => unknown, options?: EventListenerOptions | boolean): this;
    off(type: string, listener: EventListenerOrEventListenerObject, options?: EventListenerOptions | boolean): this;
    /** @internal */
    readonly observerCache: ElementViewObserverCache<this>;
    protected onObserve(observer: ObserverType<this>): void;
    protected onUnobserve(observer: ObserverType<this>): void;
    init(init: ElementViewInit): void;
    /** @internal */
    static readonly tag?: string;
    /** @internal */
    static readonly namespace?: string;
    static create<S extends abstract new (...args: any) => InstanceType<S>>(this: S): InstanceType<S>;
    static create(): ElementView;
    static fromTag<S extends abstract new (...args: any) => InstanceType<S>>(this: S, tag: string, namespace?: string): InstanceType<S>;
    static fromTag(tag: string, namespace?: string): ElementView;
    static fromNode<S extends new (node: Element) => InstanceType<S>>(this: S, node: ViewNodeType<InstanceType<S>>): InstanceType<S>;
    static fromNode(node: Element): ElementView;
    static fromAny<S extends abstract new (...args: any) => InstanceType<S>>(this: S, value: AnyElementView<InstanceType<S>>): InstanceType<S>;
    static fromAny(value: AnyElementView | string): ElementView;
}

/** @public */
export declare interface ElementViewClass<V extends ElementView = ElementView, U = AnyElementView<V>> extends NodeViewClass<V, U>, ElementViewFactory<V, U> {
    readonly tag?: string;
    readonly namespace?: string;
}

/** @public */
export declare interface ElementViewConstructor<V extends ElementView = ElementView, U = AnyElementView<V>> extends NodeViewConstructor<V, U>, ElementViewClass<V, U> {
}

/** @public */
export declare interface ElementViewFactory<V extends ElementView = ElementView, U = AnyElementView<V>> extends NodeViewFactory<V, U> {
    fromTag(tag: string): V;
}

/** @public */
export declare interface ElementViewInit extends NodeViewInit {
    id?: string;
    classList?: string[];
}

/** @public */
export declare interface ElementViewObserver<V extends ElementView = ElementView> extends NodeViewObserver<V> {
    viewWillSetAttribute?(name: string, value: unknown, view: V): void;
    viewDidSetAttribute?(name: string, value: unknown, view: V): void;
    viewWillSetStyle?(name: string, value: unknown, priority: string | undefined, view: V): void;
    viewDidSetStyle?(name: string, value: unknown, priority: string | undefined, view: V): void;
}

/** @internal */
export declare interface ElementViewObserverCache<V extends ElementView> extends ViewObserverCache<V> {
    viewWillSetAttributeObservers?: ReadonlyArray<ViewWillSetAttribute<V>>;
    viewDidSetAttributeObservers?: ReadonlyArray<ViewDidSetAttribute<V>>;
    viewWillSetStyleObservers?: ReadonlyArray<ViewWillSetStyle<V>>;
    viewDidSetStyleObservers?: ReadonlyArray<ViewDidSetStyle<V>>;
}

/** @public */
export declare class EnclosedIcon extends Icon implements Interpolate<EnclosedIcon>, Equals, Equivalent, Debug {
    constructor(outer: Icon | null, inner: Icon | null, innerScale: number, moodModifier: MoodMatrix | null, outerMoodModifier: MoodMatrix | null, innerMoodModifier: MoodMatrix | null);
    readonly outer: Icon | null;
    withOuter(outer: Icon | null): EnclosedIcon;
    readonly inner: Icon | null;
    withInner(inner: Icon | null): EnclosedIcon;
    readonly innerScale: number;
    withInnerScale(innerScale: number): EnclosedIcon;
    readonly moodModifier: MoodMatrix | null;
    withMoodModifier(moodModifier: MoodMatrix | null): EnclosedIcon;
    modifyMood(feel: Feel, updates: MoodVectorUpdates<Feel>): EnclosedIcon;
    /** @internal */
    readonly outerMoodModifier: MoodMatrix | null;
    withOuterMoodModifier(outerMoodModifier: MoodMatrix | null): EnclosedIcon;
    modifyOuterMood(feel: Feel, updates: MoodVectorUpdates<Feel>): EnclosedIcon;
    /** @internal */
    readonly innerMoodModifier: MoodMatrix | null;
    withInnerMoodModifier(innerMoodModifier: MoodMatrix | null): EnclosedIcon;
    modifyInnerMood(feel: Feel, updates: MoodVectorUpdates<Feel>): EnclosedIcon;
    isThemed(): boolean;
    withTheme(theme: ThemeMatrix, mood: MoodVector): EnclosedIcon;
    render(renderer: GraphicsRenderer, frame: R2Box): void;
    paint(context: PaintingContext, frame: R2Box): void;
    draw(context: DrawingContext, frame: R2Box): void;
    outerFrame(frame: R2Box): R2Box;
    innerFrame(frame: R2Box): R2Box;
    protected copy(outer: Icon | null, inner: Icon | null, innerScale: number, moodModifier: MoodMatrix | null, outerMoodModifier: MoodMatrix | null, innerMoodModifier: MoodMatrix | null): EnclosedIcon;
    interpolateTo(that: EnclosedIcon): Interpolator<EnclosedIcon>;
    interpolateTo(that: unknown): Interpolator<EnclosedIcon> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static create(outer: Icon | null, inner: Icon | null): EnclosedIcon;
    static embossed(outer: Icon | null, inner: Icon | null): EnclosedIcon;
    static get embossedMoodModifier(): MoodMatrix;
}

/** @internal */
export declare interface EnclosedIconInterpolator extends Interpolator<EnclosedIcon> {
    /** @internal */
    readonly outerInterpolator: Interpolator<Icon | null>;
    /** @internal */
    readonly innerInterpolator: Interpolator<Icon | null>;
    /** @internal */
    readonly innerScaleInterpolator: Interpolator<number>;
    /** @internal */
    readonly moodModifier: MoodMatrix | null;
    /** @internal */
    readonly outerMoodModifier: MoodMatrix | null;
    /** @internal */
    readonly innerMoodModifier: MoodMatrix | null;
    readonly 0: EnclosedIcon;
    readonly 1: EnclosedIcon;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const EnclosedIconInterpolator: {
    (i0: EnclosedIcon, i1: EnclosedIcon): EnclosedIconInterpolator;
    /** @internal */
    prototype: EnclosedIconInterpolator;
};

/** @public */
export declare class EphemeralStorageService<C extends Controller = Controller> extends StorageService<C> {
    constructor(storage?: Dictionary<string>);
    readonly storage: Dictionary<string>;
    get(key: string): string | undefined;
    set(key: string, newValue: string | undefined): string | undefined;
    clear(): void;
}

/** @public */
export declare class EquirectangularMapViewport extends WorldMapViewport {
    constructor(viewFrame: R2Box);
    readonly viewFrame: R2Box;
    withViewFrame(viewFrame: R2Box): WorldMapViewport;
    project(geoPoint: AnyGeoPoint): R2Point;
    project(lng: number, lat: number): R2Point;
    unproject(viewPoint: AnyR2Point): GeoPoint;
    unproject(x: number, y: number): GeoPoint;
}

/** @public */
export declare class EsriMapView extends EsriView {
    constructor(map: __esri.MapView);
    readonly observerType?: Class<EsriMapViewObserver>;
    readonly map: __esri.MapView;
    protected initMap(map: __esri.MapView): void;
    readonly geoViewport: EsriMapViewport;
    protected willSetGeoViewport(newGeoViewport: EsriMapViewport, oldGeoViewport: EsriMapViewport): void;
    protected onSetGeoViewport(newGeoViewport: EsriMapViewport, oldGeoViewport: EsriMapViewport): void;
    protected didSetGeoViewport(newGeoViewport: EsriMapViewport, oldGeoViewport: EsriMapViewport): void;
    protected updateGeoViewport(): boolean;
    protected onMapRender(): void;
    moveTo(geoPerspective: AnyGeoPerspective, timing?: AnyTiming | boolean): void;
    readonly canvas: ViewRef<this, CanvasView>;
    static readonly canvas: MemberFastenerClass<EsriMapView, "canvas">;
    readonly container: ViewRef<this, HtmlView>;
    static readonly container: MemberFastenerClass<EsriMapView, "container">;
}

/** @public */
export declare interface EsriMapViewObserver<V extends EsriMapView = EsriMapView> extends EsriViewObserver<V> {
    viewWillSetGeoViewport?(newGeoViewport: EsriMapViewport, oldGeoViewport: EsriMapViewport, view: V): void;
    viewDidSetGeoViewport?(newGeoViewport: EsriMapViewport, oldGeoViewport: EsriMapViewport, view: V): void;
}

/** @public */
export declare class EsriMapViewport extends EsriViewport {
    constructor(map: __esri.MapView, geoFrame: GeoBox, geoCenter: GeoPoint, zoom: number, heading: number, tilt: number);
    readonly map: __esri.MapView;
    project(geoPoint: AnyGeoPoint): R2Point;
    project(lng: number, lat: number): R2Point;
    unproject(viewPoint: AnyR2Point): GeoPoint;
    unproject(x: number, y: number): GeoPoint;
    static create(map: __esri.MapView): EsriMapViewport;
}

/** @public */
export declare class EsriSceneView extends EsriView {
    constructor(map: __esri.SceneView);
    readonly observerType?: Class<EsriSceneViewObserver>;
    readonly map: __esri.SceneView;
    protected initMap(map: __esri.SceneView): void;
    readonly geoViewport: EsriSceneViewport;
    protected willSetGeoViewport(newGeoViewport: EsriSceneViewport, oldGeoViewport: EsriSceneViewport): void;
    protected onSetGeoViewport(newGeoViewport: EsriSceneViewport, oldGeoViewport: EsriSceneViewport): void;
    protected didSetGeoViewport(newGeoViewport: EsriSceneViewport, oldGeoViewport: EsriSceneViewport): void;
    protected updateGeoViewport(): boolean;
    protected onMapRender(): void;
    moveTo(geoPerspective: AnyGeoPerspective, timing?: AnyTiming | boolean): void;
    readonly canvas: ViewRef<this, CanvasView>;
    static readonly canvas: MemberFastenerClass<EsriSceneView, "canvas">;
    readonly container: ViewRef<this, HtmlView>;
    static readonly container: MemberFastenerClass<EsriSceneView, "container">;
}

/** @public */
export declare interface EsriSceneViewObserver<V extends EsriSceneView = EsriSceneView> extends EsriViewObserver<V> {
    viewWillSetGeoViewport?(newGeoViewport: EsriSceneViewport, oldGeoViewport: EsriSceneViewport, view: V): void;
    viewDidSetGeoViewport?(newGeoViewport: EsriSceneViewport, oldGeoViewport: EsriSceneViewport, view: V): void;
}

/** @public */
export declare class EsriSceneViewport extends EsriViewport {
    constructor(map: __esri.SceneView, geoFrame: GeoBox, geoCenter: GeoPoint, zoom: number, heading: number, tilt: number);
    readonly map: __esri.SceneView;
    project(geoPoint: AnyGeoPoint): R2Point;
    project(lng: number, lat: number): R2Point;
    unproject(viewPoint: AnyR2Point): GeoPoint;
    unproject(x: number, y: number): GeoPoint;
    static create(map: __esri.SceneView): EsriSceneViewport;
}

/** @public */
export declare abstract class EsriView extends MapView {
    constructor();
    readonly observerType?: Class<EsriViewObserver>;
    abstract readonly map: __esri.View;
    abstract readonly geoViewport: EsriViewport;
}

/** @public */
export declare interface EsriViewObserver<V extends EsriView = EsriView> extends MapViewObserver<V> {
    viewWillSetGeoViewport?(newGeoViewport: EsriViewport, oldGeoViewport: EsriViewport, view: V): void;
    viewDidSetGeoViewport?(newGeoViewport: EsriViewport, oldGeoViewport: EsriViewport, view: V): void;
}

/** @public */
export declare abstract class EsriViewport implements GeoViewport, Equals {
    constructor(map: __esri.View, geoFrame: GeoBox, geoCenter: GeoPoint, zoom: number, heading: number, tilt: number);
    readonly map: __esri.View;
    readonly geoFrame: GeoBox;
    readonly geoCenter: GeoPoint;
    readonly zoom: number;
    readonly heading: number;
    readonly tilt: number;
    abstract project(geoPoint: AnyGeoPoint): R2Point;
    abstract project(lng: number, lat: number): R2Point;
    abstract unproject(viewPoint: AnyR2Point): GeoPoint;
    abstract unproject(x: number, y: number): GeoPoint;
    equals(that: unknown): boolean;
    /** @internal */
    static webMercatorUtils: __esri.webMercatorUtils | undefined;
    /** @internal */
    static init(): void;
}

/** @public */
export declare interface ExecuteProvider<C extends Controller, S extends ExecuteService<C> | null | undefined = ExecuteService<C>> extends Provider<C, S> {
    get controllerContext(): ControllerContext;
    updatedControllerContext(): ControllerContext;
    requestUpdate(target: Controller, updateFlags: ControllerFlags, immediate: boolean): void;
    createService(): S;
}

/** @public */
export declare const ExecuteProvider: ProviderClass<ExecuteProvider<any, any>>;

/** @public */
export declare class ExecuteService<C extends Controller = Controller> extends Service<C> {
    constructor();
    readonly observerType?: Class<ExecuteServiceObserver<C>>;
    readonly flags: ControllerFlags;
    /** @internal */
    setFlags(flags: ControllerFlags): void;
    readonly controllerContext: ControllerContext;
    updatedControllerContext(): ControllerContext;
    /** @internal */
    updateDelay: number;
    protected needsUpdate(updateFlags: ControllerFlags, immediate: boolean): ControllerFlags;
    requestUpdate(targetController: Controller, updateFlags: ControllerFlags, immediate: boolean): void;
    protected scheduleUpdate(): void;
    protected cancelUpdate(): void;
    protected runImmediatePass(): void;
    /** @internal */
    compileTimer: number;
    protected scheduleCompilePass(updateDelay: number): void;
    protected cancelCompilePass(): void;
    protected runCompilePass(immediate?: boolean): void;
    /** @internal */
    executeTimer: number;
    protected scheduleExecutePass(updateDelay: number): void;
    protected cancelExecutePass(): void;
    protected runExecutePass(immediate?: boolean): void;
    get powerFlags(): ControllerFlags;
    power(): void;
    unpower(): void;
    protected onAttachRoot(root: C): void;
    protected onAttach(): void;
    protected onDetach(): void;
    protected attachEvents(): void;
    protected detachEvents(): void;
    /** @internal */
    protected onVisibilityChange(): void;
    static global<C extends Controller>(): ExecuteService<C>;
    /** @internal */
    static MinUpdateDelay: number;
    /** @internal */
    static MaxUpdateDelay: number;
    /** @internal */
    static MinCompileInterval: number;
    /** @internal */
    static MaxCompileInterval: number;
    /** @internal */
    static MinExecuteInterval: number;
    /** @internal */
    static MaxExecuteInterval: number;
}

/** @public */
export declare interface ExecuteServiceObserver<C extends Controller = Controller, S extends ExecuteService<C> = ExecuteService<C>> extends ServiceObserver<C, S> {
}

/** @public */
export declare class Expansion implements Interpolate<Expansion>, HashCode, Equivalent, Debug {
    constructor(phase: number, direction: number);
    readonly phase: number;
    withPhase(phase: number): Expansion;
    readonly direction: number;
    withDirection(direction: number): Expansion;
    get modalState(): "hidden" | "showing" | "shown" | "hiding" | undefined;
    get collapsed(): boolean;
    get expanded(): boolean;
    get expanding(): boolean;
    get collapsing(): boolean;
    asExpanding(): Expansion;
    asCollapsing(): Expansion;
    asToggling(): Expansion;
    asToggled(): Expansion;
    interpolateTo(that: Expansion): Interpolator<Expansion>;
    interpolateTo(that: unknown): Interpolator<Expansion> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static collapsed(): Expansion;
    static expanded(): Expansion;
    static expanding(phase?: number): Expansion;
    static collapsing(phase?: number): Expansion;
    static create(phase: number, direction?: number): Expansion;
    static fromInit(value: ExpansionInit): Expansion;
    static fromAny(value: AnyExpansion): Expansion;
    /** @internal */
    static isInit(value: unknown): value is ExpansionInit;
    /** @internal */
    static isAny(value: unknown): value is AnyExpansion;
}

/** @public */
export declare interface ExpansionInit {
    readonly phase: number;
    readonly direction: number;
}

/** @internal */
export declare const ExpansionInterpolator: {
    (e0: Expansion, e1: Expansion): Interpolator<Expansion>;
    /** @internal */
    prototype: Interpolator<Expansion>;
};

/** @public */
export declare interface ExpansionThemeAnimator<O = unknown, T extends Expansion | null | undefined = Expansion, U extends AnyExpansion | null | undefined = AnyExpansion> extends ThemeAnimator<O, T, U> {
    get phase(): number | undefined;
    getPhase(): number;
    getPhaseOr<E>(elsePhase: E): number | E;
    setPhase(newPhase: number, timingOrAffinity: Affinity | AnyTiming | boolean | null | undefined): void;
    setPhase(newPhase: number, timing?: AnyTiming | boolean | null, affinity?: Affinity): void;
    get direction(): number;
    setDirection(newDirection: number, timingOrAffinity: Affinity | AnyTiming | boolean | null | undefined): void;
    setDirection(newDirection: number, timing?: AnyTiming | boolean | null, affinity?: Affinity): void;
    get modalState(): string | undefined;
    get collapsed(): boolean;
    get expanded(): boolean;
    get expanding(): boolean;
    get collapsing(): boolean;
    expand(timingOrAffinity: Affinity | AnyTiming | boolean | null | undefined): void;
    expand(timing?: AnyTiming | boolean | null, affinity?: Affinity): void;
    collapse(timingOrAffinity: Affinity | AnyTiming | boolean | null | undefined): void;
    collapse(timing?: AnyTiming | boolean | null, affinity?: Affinity): void;
    toggle(timingOrAffinity: Affinity | AnyTiming | boolean | null | undefined): void;
    toggle(timing?: AnyTiming | boolean | null, affinity?: Affinity): void;
    /** @override @protected */
    onSetValue(newValue: T, oldValue: T): void;
    /** @protected */
    willExpand(): void;
    /** @protected */
    didExpand(): void;
    /** @protected */
    willCollapse(): void;
    /** @protected */
    didCollapse(): void;
    /** @override */
    (newValue: T, oldValue: T | undefined): boolean;
    /** @override */
    fromAny(value: T | U): T;
}

/** @public */
export declare const ExpansionThemeAnimator: ThemeAnimatorFactory<ExpansionThemeAnimator<any, Expansion | null | undefined, AnyExpansion | null | undefined>>;

/** @public */
export declare interface ExpansionThemeAnimatorInit {
    willExpand?(): void;
    didExpand?(): void;
    willCollapse?(): void;
    didCollapse?(): void;
}

/** @public */
export declare abstract class Feel implements Mood {
    constructor(name: string);
    readonly name: string;
    abstract combine<T>(look: Look<T, any>, combination: T | undefined, value: T, weight?: number): T;
    empty(): FeelVector;
    of(...looks: [Look<unknown>, any][]): FeelVector;
    from(array: ReadonlyArray<[Look<unknown>, unknown]>, index?: {
        readonly [name: string]: number | undefined;
    }): FeelVector;
    toString(): string;
    static ambient: Feel;
    static default: Feel;
    static primary: Feel;
    static secondary: Feel;
    static unselected: Feel;
    static selected: Feel;
    static disabled: Feel;
    static inactive: Feel;
    static warning: Feel;
    static alert: Feel;
    static darker: Feel;
    static lighter: Feel;
    static contrasted: Feel;
    static raised: Feel;
    static covered: Feel;
    static opaque: Feel;
    static floating: Feel;
    static transparent: Feel;
    static translucent: Feel;
    static embossed: Feel;
    static nested: Feel;
    static hovering: Feel;
    static navigating: Feel;
}

/** @public */
export declare class FeelVector implements Interpolate<FeelVector>, Equals, Debug {
    constructor(array: ReadonlyArray<[Look<unknown>, unknown]>, index: {
        readonly [name: string]: number | undefined;
    });
    /** @internal */
    readonly array: ReadonlyArray<[Look<unknown>, unknown]>;
    /** @internal */
    readonly index: {
        readonly [name: string]: number | undefined;
    };
    get size(): number;
    isEmpty(): boolean;
    has(look: Look<any>): boolean;
    has(name: string): boolean;
    get<T>(look: Look<T, any>): T | undefined;
    get(name: string): unknown | undefined;
    get(index: number): unknown | undefined;
    getOr<T, E>(look: Look<T, any>, elseValue: E): T | E;
    getOr(name: string, elseValue: unknown): unknown;
    getOr(index: number, elseValue: unknown): unknown;
    updated<T, U = never>(look: Look<T, U>, value: T | U | undefined): FeelVector;
    updated(updates: FeelVectorUpdates): FeelVector;
    plus(that: FeelVector): FeelVector;
    negative(): FeelVector;
    minus(that: FeelVector): FeelVector;
    times(scalar: number): FeelVector;
    protected copy(array: ReadonlyArray<[Look<unknown>, unknown]>, index?: {
        readonly [name: string]: number | undefined;
    }): FeelVector;
    forEach<R>(callback: <T>(value: T, look: Look<T>) => R | void): R | undefined;
    forEach<R, S>(callback: <T>(this: S, value: T, look: Look<T>) => R | void, thisArg: S): R | undefined;
    interpolateTo(that: FeelVector): Interpolator<FeelVector>;
    interpolateTo(that: unknown): Interpolator<FeelVector> | null;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static empty(): FeelVector;
    static of(...looks: [Look<unknown>, unknown][]): FeelVector;
    static fromArray(array: ReadonlyArray<[Look<unknown>, unknown]>, index?: {
        readonly [name: string]: number | undefined;
    }): FeelVector;
    static fromAny(value: AnyFeelVector): FeelVector;
    /** @internal */
    static index<T>(array: ReadonlyArray<[Look<T>, T]>): {
        readonly [name: string]: number | undefined;
    };
}

/** @public */
export declare type FeelVectorArray = ReadonlyArray<[Look<unknown>, unknown]>;

/** @internal */
export declare interface FeelVectorInterpolator extends Interpolator<FeelVector> {
    /** @internal */
    readonly interpolators: ReadonlyArray<[Look<unknown>, Interpolator<unknown>]>;
    /** @internal */
    readonly index: {
        readonly [name: string]: number | undefined;
    };
    get 0(): FeelVector;
    get 1(): FeelVector;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const FeelVectorInterpolator: {
    (v0: FeelVector, v1: FeelVector): FeelVectorInterpolator;
    /** @internal */
    prototype: FeelVectorInterpolator;
};

/** @public */
export declare type FeelVectorUpdates = ReadonlyArray<[Look<unknown>, unknown | undefined]>;

/** @public */
export declare abstract class FilledIcon extends Icon {
    abstract readonly fillColor: Color | null;
    abstract withFillColor(fillColor: Color | null): FilledIcon;
    abstract readonly fillLook: Look<Color> | null;
    abstract withFillLook(fillLook: Look<Color> | null): FilledIcon;
    abstract withMoodModifier(moodModifier: MoodMatrix | null): FilledIcon;
    abstract modifyMood(feel: Feel, updates: MoodVectorUpdates<Feel>): FilledIcon;
    abstract withTheme(theme: ThemeMatrix, mood: MoodVector): FilledIcon;
}

/** @public */
export declare type FillRule = "nonzero" | "evenodd" | "inherit";

/** @public */
export declare interface FillView extends GraphicsView {
    readonly fill: ThemeAnimator<this, Color | null, AnyColor | null>;
}

/** @public */
export declare const FillView: {
    init(view: FillView, init: FillViewInit): void;
    is(object: unknown): object is FillView;
};

/** @public */
export declare interface FillViewInit extends GraphicsViewInit {
    fill?: AnyColor;
}

/** @public */
export declare type FlexBasis = Length | "auto" | "content" | "fill" | "fit-content" | "max-content" | "min-content";

/** @public */
export declare type FlexDirection = "column" | "column-reverse" | "row" | "row-reverse";

/** @public */
export declare type FlexWrap = "nowrap" | "wrap" | "wrap-reverse";

/** @public */
export declare class FloatingButton extends ButtonMembrane {
    constructor(node: HTMLElement);
    protected initButton(): void;
    readonly buttonType: FloatingButtonType;
    setButtonType(buttonType: FloatingButtonType): void;
    readonly gesture: PositionGesture<this, HtmlView>;
    static readonly gesture: MemberFastenerClass<FloatingButton, "gesture">;
    /** @internal */
    static IconRef: ViewRefFactory<ViewRef<any, HtmlIconView> & {
        iconIndex: number;
    }>;
    /** @internal */
    iconCount: number;
    icon: ViewRef<this, HtmlIconView> | null;
    pushIcon(icon: Graphics, timing?: AnyTiming | boolean): void;
    popIcon(timing?: AnyTiming | boolean): void;
    readonly disclosure: ExpansionThemeAnimator<this, Expansion | undefined, AnyExpansion | undefined>;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    protected onLayout(viewContext: ViewContextType<this>): void;
}

/** @public */
export declare type FloatingButtonType = "regular" | "mini";

/** @public */
export declare class Focus implements Interpolate<Focus>, HashCode, Equivalent, Debug {
    constructor(phase: number, direction: number);
    readonly phase: number;
    withPhase(phase: number): Focus;
    readonly direction: number;
    withDirection(direction: number): Focus;
    get unfocused(): boolean;
    get focused(): boolean;
    get focusing(): boolean;
    get unfocusing(): boolean;
    asFocusing(): Focus;
    asUnfocusing(): Focus;
    asToggling(): Focus;
    asToggled(): Focus;
    interpolateTo(that: Focus): Interpolator<Focus>;
    interpolateTo(that: unknown): Interpolator<Focus> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static unfocused(): Focus;
    static focused(): Focus;
    static focusing(phase?: number): Focus;
    static unfocusing(phase?: number): Focus;
    static create(phase: number, direction?: number): Focus;
    static fromInit(value: FocusInit): Focus;
    static fromAny(value: AnyFocus): Focus;
    /** @internal */
    static isInit(value: unknown): value is FocusInit;
    /** @internal */
    static isAny(value: unknown): value is AnyFocus;
}

/** @public */
export declare interface FocusInit {
    readonly phase: number;
    readonly direction: number;
}

/** @internal */
export declare const FocusInterpolator: {
    (f0: Focus, f1: Focus): Interpolator<Focus>;
    /** @internal */
    prototype: Interpolator<Focus>;
};

/** @public */
export declare interface FocusThemeAnimator<O = unknown, T extends Focus | null | undefined = Focus, U extends AnyFocus | null | undefined = AnyFocus> extends ThemeAnimator<O, T, U> {
    get phase(): number | undefined;
    getPhase(): number;
    getPhaseOr<E>(elsePhase: E): number | E;
    setPhase(newPhase: number, timingOrAffinity: Affinity | AnyTiming | boolean | undefined): void;
    setPhase(newPhase: number, timing?: AnyTiming | boolean, affinity?: Affinity): void;
    get direction(): number;
    setDirection(newDirection: number, timingOrAffinity: Affinity | AnyTiming | boolean | undefined): void;
    setDirection(newDirection: number, timing?: AnyTiming | boolean, affinity?: Affinity): void;
    get unfocused(): boolean;
    get focused(): boolean;
    get focusing(): boolean;
    get unfocusing(): boolean;
    focus(timingOrAffinity: Affinity | AnyTiming | boolean | undefined): void;
    focus(timing?: AnyTiming | boolean, affinity?: Affinity): void;
    unfocus(timingOrAffinity: Affinity | AnyTiming | boolean | undefined): void;
    unfocus(timing?: AnyTiming | boolean, affinity?: Affinity): void;
    toggle(timingOrAffinity: Affinity | AnyTiming | boolean | undefined): void;
    toggle(timing?: AnyTiming | boolean, affinity?: Affinity): void;
    /** @override @protected */
    onSetValue(newValue: T, oldValue: T): void;
    /** @protected */
    willFocus(): void;
    /** @protected */
    didFocus(): void;
    /** @protected */
    willUnfocus(): void;
    /** @protected */
    didUnfocus(): void;
    /** @override */
    (newState: T, oldState: T | undefined): boolean;
    /** @override */
    fromAny(value: T | U): T;
}

/** @public */
export declare const FocusThemeAnimator: ThemeAnimatorFactory<FocusThemeAnimator<any, Focus | null | undefined, AnyFocus | null | undefined>>;

/** @public */
export declare interface FocusThemeAnimatorInit {
    willFocus?(): void;
    didFocus?(): void;
    willUnfocus?(): void;
    didUnfocus?(): void;
}

/** @public */
export declare class Font implements Interpolate<Font>, Equals, Equivalent, Debug {
    constructor(style: FontStyle | undefined, variant: FontVariant | undefined, weight: FontWeight | undefined, stretch: FontStretch | undefined, size: FontSize | null, height: LineHeight | null, family: FontFamily | ReadonlyArray<FontFamily>);
    readonly style: FontStyle | undefined;
    withStyle(style: FontStyle | undefined): Font;
    readonly variant: FontVariant | undefined;
    withVariant(variant: FontVariant | undefined): Font;
    readonly weight: FontWeight | undefined;
    withWeight(weight: FontWeight | undefined): Font;
    readonly stretch: FontStretch | undefined;
    withStretch(stretch: FontStretch | undefined): Font;
    readonly size: FontSize | null;
    withSize(size: AnyFontSize | null): Font;
    readonly height: LineHeight | null;
    withHeight(height: AnyLineHeight | null): Font;
    readonly family: FontFamily | ReadonlyArray<FontFamily>;
    withFamily(family: FontFamily | ReadonlyArray<FontFamily>): Font;
    toAny(): FontInit;
    interpolateTo(that: Font): Interpolator<Font>;
    interpolateTo(that: unknown): Interpolator<Font> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    readonly stringValue: string | undefined;
    toString(): string;
    static style(style: FontStyle | undefined, family: FontFamily | ReadonlyArray<FontFamily>): Font;
    static variant(variant: FontVariant | undefined, family: FontFamily | ReadonlyArray<FontFamily>): Font;
    static weight(weight: FontWeight | undefined, family: FontFamily | ReadonlyArray<FontFamily>): Font;
    static stretch(stretch: FontStretch | undefined, family: FontFamily | ReadonlyArray<FontFamily>): Font;
    static size(size: AnyFontSize | null, family: FontFamily | ReadonlyArray<FontFamily>): Font;
    static family(family: FontFamily | ReadonlyArray<FontFamily>): Font;
    static create(style: FontStyle | undefined, variant: FontVariant | undefined, weight: FontWeight | undefined, stretch: FontStretch | undefined, size: AnyFontSize | null | undefined, height: AnyLineHeight | null | undefined, family: FontFamily | ReadonlyArray<FontFamily>): Font;
    static fromInit(init: FontInit): Font;
    static fromValue(value: Value): Font | null;
    static fromAny(value: AnyFont): Font;
    static parse(string: string): Font;
    /** @internal */
    static isInit(value: unknown): value is FontInit;
    /** @internal */
    static isAny(value: unknown): value is AnyFont;
    static form(unit?: Font): Form<Font, AnyFont>;
}

/** @public */
export declare type FontFamily = string | GenericFamily;

/** @public */
export declare const FontFamily: {
    fromValue(value: Value): string | string[] | null;
    format(family: string): string;
};

/** @internal */
export declare class FontFamilyParser extends Parser<FontFamily> {
    private readonly output;
    private readonly quote;
    private readonly code;
    private readonly step;
    constructor(output?: Output<string>, quote?: number, code?: number, step?: number);
    feed(input: Input): Parser<FontFamily>;
    static parse<I, V>(input: Input, output?: Output<string>, quote?: number, code?: number, step?: number): Parser<FontFamily>;
}

/** @internal */
export declare const FontFamilyStyleAnimator: StyleAnimatorFactory<StyleAnimator<any, string | readonly string[] | undefined, string | readonly string[] | undefined>>;

/** @internal */
export declare class FontForm extends Form<Font, AnyFont> {
    constructor(unit: Font | undefined);
    readonly unit: Font | undefined;
    withUnit(unit: Font | undefined): Form<Font, AnyFont>;
    mold(font: AnyFont): Item;
    cast(item: Item): Font | undefined;
}

/** @public */
export declare interface FontInit {
    style?: FontStyle;
    variant?: FontVariant;
    weight?: FontWeight;
    stretch?: FontStretch;
    size?: AnyFontSize | null;
    height?: AnyLineHeight | null;
    family: FontFamily | FontFamily[];
}

/** @internal */
export declare interface FontInterpolator extends Interpolator<Font> {
    /** @internal */
    readonly styleInterpolator: Interpolator<FontStyle | undefined>;
    /** @internal */
    readonly variantInterpolator: Interpolator<FontVariant | undefined>;
    /** @internal */
    readonly weightInterpolator: Interpolator<FontWeight | undefined>;
    /** @internal */
    readonly stretchInterpolator: Interpolator<FontStretch | undefined>;
    /** @internal */
    readonly sizeInterpolator: Interpolator<FontSize | null>;
    /** @internal */
    readonly heightInterpolator: Interpolator<LineHeight | null>;
    /** @internal */
    readonly familyInterpolator: Interpolator<FontFamily | ReadonlyArray<FontFamily>>;
    get 0(): Font;
    get 1(): Font;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const FontInterpolator: {
    (f0: Font, f1: Font): FontInterpolator;
    /** @internal */
    prototype: FontInterpolator;
};

/** @internal */
export declare class FontLook extends Look<Font, AnyFont> {
    combine(combination: Font | undefined, value: Font, weight?: number): Font;
    between(a: Font, b: Font): Interpolator<Font>;
    coerce(value: AnyFont): Font;
}

/** @internal */
export declare class FontParser extends Parser<Font> {
    private readonly style;
    private readonly variant;
    private readonly weight;
    private readonly stretch;
    private readonly size;
    private readonly height;
    private readonly family;
    private readonly identOutput;
    private readonly lengthParser;
    private readonly familyParser;
    private readonly step;
    constructor(style?: FontStyle, variant?: FontVariant, weight?: FontWeight, stretch?: FontStretch, size?: FontSize, height?: LineHeight, family?: FontFamily | FontFamily[], identOutput?: Output<string>, lengthParser?: Parser<Length>, familyParser?: Parser<FontFamily>, step?: number);
    feed(input: Input): Parser<Font>;
    static parse(input: Input, style?: FontStyle, variant?: FontVariant, weight?: FontWeight, stretch?: FontStretch, size?: FontSize, height?: LineHeight, family?: FontFamily | FontFamily[], identOutput?: Output<string>, lengthParser?: Parser<Length>, familyParser?: Parser<FontFamily>, step?: number): Parser<Font>;
    static parseRest(input: Input, style?: FontStyle, variant?: FontVariant, weight?: FontWeight, stretch?: FontStretch, size?: FontSize, height?: LineHeight, family?: FontFamily | FontFamily[]): Parser<Font>;
}

/** @public */
export declare type FontSize = Length | "large" | "larger" | "medium" | "small" | "smaller" | "x-large" | "x-small" | "xx-large" | "xx-small";

/** @public */
export declare const FontSize: {
    fromAny(size: AnyFontSize): FontSize;
    fromValue(value: Value): FontSize | null;
};

/** @public */
export declare type FontStretch = "normal" | "ultra-condensed" | "extra-condensed" | "semi-condensed" | "condensed" | "expanded" | "semi-expanded" | "extra-expanded" | "ultra-expanded";

/** @public */
export declare type FontStyle = "normal" | "italic" | "oblique";

/** @internal */
export declare const FontThemeAnimator: ThemeAnimatorFactory<ThemeAnimator<any, Font | null | undefined, AnyFont | null | undefined>>;

/** @public */
export declare type FontVariant = "normal" | "small-caps";

/** @public */
export declare type FontWeight = "normal" | "100" | "200" | "300" | "400" | "500" | "600" | "700" | "800" | "900" | "bold" | "bolder" | "lighter";

/** @public */
export declare class GaugeController extends Controller {
    readonly observerType?: Class<GaugeControllerObserver>;
    protected createTitleView(title: GaugeTitle, gaugeTrait: GaugeTrait): GraphicsView | string | null;
    protected setTitleView(title: GaugeTitle | null, gaugeTrait: GaugeTrait): void;
    protected setLimit(limit: number): void;
    readonly gauge: TraitViewRef<this, GaugeTrait, GaugeView>;
    static readonly gauge: MemberFastenerClass<GaugeController, "gauge">;
    readonly title: ViewRef<this, GraphicsView>;
    static readonly title: MemberFastenerClass<GaugeController, "title">;
    readonly dialTiming: Property<this, Timing | boolean | undefined, AnyTiming>;
    readonly dials: TraitViewControllerSet<this, DialTrait, DialView, DialController> & GaugeControllerDialExt;
    static readonly dials: MemberFastenerClass<GaugeController, "dials">;
}

/** @public */
export declare interface GaugeControllerDialExt {
    attachDialTrait(dialTrait: DialTrait, dialController: DialController): void;
    detachDialTrait(dialTrait: DialTrait, dialController: DialController): void;
    attachDialView(dialView: DialView, dialController: DialController): void;
    detachDialView(dialView: DialView, dialController: DialController): void;
    attachDialLabelView(labelView: GraphicsView, dialController: DialController): void;
    detachDialLabelView(labelView: GraphicsView, dialController: DialController): void;
    attachDialLegendView(legendView: GraphicsView, dialController: DialController): void;
    detachDialLegendView(legendView: GraphicsView, dialController: DialController): void;
}

/** @public */
export declare interface GaugeControllerObserver<C extends GaugeController = GaugeController> extends ControllerObserver<C> {
    controllerWillAttachGaugeTrait?(gaugeTrait: GaugeTrait, controller: C): void;
    controllerDidDetachGaugeTrait?(gaugeTrait: GaugeTrait, controller: C): void;
    controllerWillAttachGaugeView?(gaugeView: GaugeView, controller: C): void;
    controllerDidDetachGaugeView?(gaugeView: GaugeView | null, controller: C): void;
    controllerWillAttachGaugeTitleView?(titleView: GraphicsView, controller: C): void;
    controllerDidDetachGaugeTitleView?(titleView: GraphicsView, controller: C): void;
    controllerWillAttachDial?(dialController: DialController, controller: C): void;
    controllerDidDetachDial?(dialController: DialController, controller: C): void;
    controllerWillAttachDialTrait?(dialTrait: DialTrait, dialController: DialController, controller: C): void;
    controllerDidDetachDialTrait?(dialTrait: DialTrait, dialController: DialController, controller: C): void;
    controllerWillAttachDialView?(dialView: DialView, dialController: DialController, controller: C): void;
    controllerDidDetachDialView?(dialView: DialView, dialController: DialController, controller: C): void;
    controllerWillSetDialValue?(newValue: number, oldValue: number, dialController: DialController, controller: C): void;
    controllerDidSetDialValue?(newValue: number, oldValue: number, dialController: DialController, controller: C): void;
    controllerWillSetDialLimit?(newLimit: number, oldLimit: number, dialController: DialController, controller: C): void;
    controllerDidSetDialLimit?(newLimit: number, oldLimit: number, dialController: DialController, controller: C): void;
    controllerWillAttachDialLabelView?(labelView: GraphicsView, dialController: DialController, controller: C): void;
    controllerDidDetachDialLabelView?(labelView: GraphicsView, dialController: DialController, controller: C): void;
    controllerWillAttachDialLegendView?(legendView: GraphicsView, dialController: DialController, controller: C): void;
    controllerDidDetachDialLegendView?(legendView: GraphicsView, dialController: DialController, controller: C): void;
}

/** @public */
export declare type GaugeTitle = GaugeTitleFunction | string;

/** @public */
export declare type GaugeTitleFunction = (gaugeTrait: GaugeTrait) => GraphicsView | string | null;

/** @public */
export declare class GaugeTrait extends Trait {
    readonly observerType?: Class<GaugeTraitObserver>;
    readonly title: Property<this, GaugeTitle | null>;
    static readonly title: MemberFastenerClass<GaugeTrait, "title">;
    readonly limit: Property<this, number>;
    static readonly limit: MemberFastenerClass<GaugeTrait, "limit">;
    readonly dials: TraitSet<this, DialTrait>;
    static readonly dials: MemberFastenerClass<GaugeTrait, "dials">;
    /** @internal */
    protected startConsumingDials(): void;
    /** @internal */
    protected stopConsumingDials(): void;
    protected onStartConsuming(): void;
    protected onStopConsuming(): void;
}

/** @public */
export declare interface GaugeTraitObserver<R extends GaugeTrait = GaugeTrait> extends TraitObserver<R> {
    traitWillSetGaugeTitle?(newTitle: GaugeTitle | null, oldTitle: GaugeTitle | null, trait: R): void;
    traitDidSetGaugeTitle?(newTitle: GaugeTitle | null, oldTitle: GaugeTitle | null, trait: R): void;
    traitWillSetGaugeLimit?(newLimit: number, oldLimit: number, trait: R): void;
    traitDidSetGaugeLimit?(newLimit: number, oldLimit: number, trait: R): void;
    traitWillAttachDial?(dialTrait: DialTrait, targetTrait: Trait | null, trait: R): void;
    traitDidDetachDial?(dialTrait: DialTrait, trait: R): void;
}

/** @public */
export declare class GaugeView extends GraphicsView {
    readonly observerType?: Class<GaugeViewObserver>;
    readonly limit: Animator<this, number>;
    readonly center: Animator<this, R2Point, AnyR2Point>;
    readonly innerRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly outerRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly startAngle: ThemeAnimator<this, Angle, AnyAngle>;
    readonly sweepAngle: ThemeAnimator<this, Angle, AnyAngle>;
    readonly cornerRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly dialSpacing: ThemeAnimator<this, Length, AnyLength>;
    readonly dialColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly meterColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly labelPadding: ThemeAnimator<this, Length, AnyLength>;
    readonly tickAlign: ThemeAnimator<this, number>;
    readonly tickRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly tickLength: ThemeAnimator<this, Length, AnyLength>;
    readonly tickWidth: ThemeAnimator<this, Length, AnyLength>;
    readonly tickPadding: ThemeAnimator<this, Length, AnyLength>;
    readonly tickColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly font: ThemeAnimator<this, Font | null, AnyFont | null>;
    readonly textColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly title: ViewRef<this, GraphicsView & Initable<GraphicsViewInit | string>>;
    static readonly title: MemberFastenerClass<GaugeView, "title">;
    readonly dials: ViewSet<this, DialView> & GaugeViewDialExt;
    static readonly dials: MemberFastenerClass<GaugeView, "dials">;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected layoutGauge(frame: R2Box): void;
    init(init: GaugeViewInit): void;
}

/** @public */
export declare interface GaugeViewDialExt {
    attachLabelView(labelView: GraphicsView): void;
    detachLabelView(labelView: GraphicsView): void;
    attachLegendView(legendView: GraphicsView): void;
    detachLegendView(legendView: GraphicsView): void;
}

/** @public */
export declare interface GaugeViewInit extends GraphicsViewInit {
    limit?: number;
    center?: AnyR2Point;
    innerRadius?: AnyLength;
    outerRadius?: AnyLength;
    startAngle?: AnyAngle;
    sweepAngle?: AnyAngle;
    cornerRadius?: AnyLength;
    dialSpacing?: AnyLength;
    dialColor?: AnyColor;
    meterColor?: AnyColor;
    labelPadding?: AnyLength;
    tickAlign?: number;
    tickRadius?: AnyLength;
    tickLength?: AnyLength;
    tickWidth?: AnyLength;
    tickPadding?: AnyLength;
    tickColor?: AnyColor;
    font?: AnyFont;
    textColor?: AnyColor;
    title?: GraphicsView | string;
    dials?: AnyDialView[];
}

/** @public */
export declare interface GaugeViewObserver<V extends GaugeView = GaugeView> extends ViewObserver<V> {
    viewWillAttachGaugeTitle?(titleView: GraphicsView, view: V): void;
    viewDidDetachGaugeTitle?(titleView: GraphicsView, view: V): void;
    viewWillAttachDial?(dialView: DialView, targetView: View | null, view: V): void;
    viewDidDetachDial?(dialView: DialView, view: V): void;
}

/** @public */
export declare type GenericFamily = "serif" | "sans-serif" | "cursive" | "fantasy" | "monospace" | "system-ui" | "emoji" | "math" | "fangsong";

/** @public */
export declare class GeoArcView extends GeoView implements FillView, StrokeView {
    constructor();
    readonly observerType?: Class<GeoArcViewObserver>;
    readonly geoCenter: Animator<this, GeoPoint | null, AnyGeoPoint | null>;
    readonly viewCenter: Animator<this, R2Point | null, AnyR2Point | null>;
    readonly innerRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly outerRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly startAngle: ThemeAnimator<this, Angle, AnyAngle>;
    readonly sweepAngle: ThemeAnimator<this, Angle, AnyAngle>;
    readonly padAngle: ThemeAnimator<this, Angle, AnyAngle>;
    readonly padRadius: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly cornerRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly fill: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly stroke: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly strokeWidth: ThemeAnimator<this, Length | null, AnyLength | null>;
    get value(): Arc | null;
    get state(): Arc | null;
    protected onProject(viewContext: ViewContextType<this>): void;
    protected projectGeoCenter(geoCenter: GeoPoint | null): void;
    protected projectArc(viewContext: ViewContextType<this>): void;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected renderArc(context: PaintingContext, frame: R2Box): void;
    protected renderGeoBounds(viewContext: ViewContextType<this>, outlineColor: Color, outlineWidth: number): void;
    protected updateGeoBounds(): void;
    readonly viewBounds: R2Box;
    deriveViewBounds(): R2Box;
    get popoverFrame(): R2Box;
    protected hitTest(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestArc(x: number, y: number, context: CanvasContext, frame: R2Box): GraphicsView | null;
    ripple(options?: GeoRippleOptions): GeoRippleView | null;
    init(init: GeoArcViewInit): void;
}

/** @public */
export declare interface GeoArcViewInit extends GeoViewInit, FillViewInit, StrokeViewInit {
    geoCenter?: AnyGeoPoint;
    viewCenter?: R2Point;
    innerRadius?: AnyLength;
    outerRadius?: AnyLength;
    startAngle?: AnyAngle;
    sweepAngle?: AnyAngle;
    padAngle?: AnyAngle;
    padRadius?: AnyLength | null;
    cornerRadius?: AnyLength;
}

/** @public */
export declare interface GeoArcViewObserver<V extends GeoArcView = GeoArcView> extends GeoViewObserver<V> {
    viewWillSetGeoCenter?(newGeoCenter: GeoPoint | null, oldGeoCenter: GeoPoint | null, view: V): void;
    viewDidSetGeoCenter?(newGeoCenter: GeoPoint | null, oldGeoCenter: GeoPoint | null, view: V): void;
}

/** @public */
export declare class GeoAreaController extends GeoPathController {
    readonly observerType?: Class<GeoAreaControllerObserver>;
    protected setGeoPath(geoPath: GeoPath | null, geoTrait: GeoAreaTrait, timing?: AnyTiming | boolean): void;
    protected setFill(fill: Look<Color> | Color | null, geoTrait: GeoAreaTrait, timing?: AnyTiming | boolean): void;
    protected setStroke(stroke: Look<Color> | Color | null, geoTrait: GeoAreaTrait, timing?: AnyTiming | boolean): void;
    protected setStrokeWidth(strokeWidth: Length | null, geoTrait: GeoAreaTrait, timing?: AnyTiming | boolean): void;
    readonly geo: TraitViewRef<this, GeoAreaTrait, GeoAreaView>;
    static readonly geo: MemberFastenerClass<GeoAreaController, "geo">;
}

/** @public */
export declare interface GeoAreaControllerObserver<C extends GeoAreaController = GeoAreaController> extends GeoPathControllerObserver<C> {
    controllerWillAttachGeoTrait?(geoTrait: GeoAreaTrait, controller: C): void;
    controllerDidDetachGeoTrait?(geoTrait: GeoAreaTrait, controller: C): void;
    controllerWillAttachGeoView?(geoView: GeoAreaView, controller: C): void;
    controllerDidDetachGeoView?(geoView: GeoAreaView, controller: C): void;
    controllerWillSetFill?(newFill: Look<Color> | Color | null, oldFill: Look<Color> | Color | null, controller: C): void;
    controllerDidSetFill?(newFill: Look<Color> | Color | null, oldFill: Look<Color> | Color | null, controller: C): void;
    controllerWillSetStroke?(newStroke: Look<Color> | Color | null, oldStroke: Look<Color> | Color | null, controller: C): void;
    controllerDidSetStroke?(newStroke: Look<Color> | Color | null, oldStroke: Look<Color> | Color | null, controller: C): void;
    controllerWillSetStrokeWidth?(newStrokeWidth: Length | null, oldStrokeWidth: Length | null, controller: C): void;
    controllerDidSetStrokeWidth?(newStrokeWidth: Length | null, oldStrokeWidth: Length | null, controller: C): void;
}

/** @public */
export declare abstract class GeoAreaTrait extends GeoPathTrait {
    readonly observerType?: Class<GeoAreaTraitObserver>;
    readonly fill: Property<this, Look<Color> | Color | null, Look<Color> | AnyColor | null>;
    readonly stroke: Property<this, Look<Color> | Color | null, Look<Color> | AnyColor | null>;
    readonly strokeWidth: Property<this, Length | null, AnyLength | null>;
}

/** @public */
export declare interface GeoAreaTraitObserver<R extends GeoAreaTrait = GeoAreaTrait> extends GeoPathTraitObserver<R> {
    traitWillSetFill?(newFill: Look<Color> | Color | null, oldFill: Look<Color> | Color | null, trait: R): void;
    traitDidSetFill?(newFill: Look<Color> | Color | null, oldFill: Look<Color> | Color | null, trait: R): void;
    traitWillSetStroke?(newStroke: Look<Color> | Color | null, oldStroke: Look<Color> | Color | null, trait: R): void;
    traitDidSetStroke?(newStroke: Look<Color> | Color | null, oldStroke: Look<Color> | Color | null, trait: R): void;
    traitWillSetStrokeWidth?(newStrokeWidth: Length | null, oldStrokeWidth: Length | null, trait: R): void;
    traitDidSetStrokeWidth?(newStrokeWidth: Length | null, oldStrokeWidth: Length | null, trait: R): void;
}

/** @public */
export declare class GeoAreaView extends GeoPathView implements FillView, StrokeView {
    readonly observerType?: Class<GeoAreaViewObserver>;
    readonly fill: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly stroke: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly strokeWidth: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly clipViewport: Property<this, boolean>;
    cullGeoFrame(geoFrame?: GeoBox): void;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected renderArea(context: PaintingContext, frame: R2Box): void;
    protected hitTest(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestArea(x: number, y: number, context: CanvasContext, frame: R2Box): GraphicsView | null;
    init(init: GeoAreaViewInit): void;
}

/** @public */
export declare interface GeoAreaViewInit extends GeoPathViewInit, FillViewInit, StrokeViewInit {
    clipViewport?: true;
}

/** @public */
export declare interface GeoAreaViewObserver<V extends GeoAreaView = GeoAreaView> extends GeoPathViewObserver<V> {
    viewWillSetFill?(newFill: Color | null, oldFill: Color | null, view: V): void;
    viewDidSetFill?(newFill: Color | null, oldFill: Color | null, view: V): void;
    viewWillSetStroke?(newStroke: Color | null, oldStroke: Color | null, view: V): void;
    viewDidSetStroke?(newStroke: Color | null, oldStroke: Color | null, view: V): void;
    viewWillSetStrokeWidth?(newStrokeWidth: Length | null, oldStrokeWidth: Length | null, view: V): void;
    viewDidSetStrokeWidth?(newStrokeWidth: Length | null, oldStrokeWidth: Length | null, view: V): void;
}

/** @public */
export declare class GeoCircleView extends GeoView implements FillView, StrokeView {
    constructor();
    readonly observerType?: Class<GeoCircleViewObserver>;
    readonly geoCenter: Animator<this, GeoPoint | null, AnyGeoPoint | null>;
    readonly viewCenter: Animator<this, R2Point | null, AnyR2Point | null>;
    readonly radius: ThemeAnimator<this, Length, AnyLength>;
    readonly fill: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly stroke: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly strokeWidth: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly hitRadius: Property<this, number | undefined>;
    protected onProject(viewContext: ViewContextType<this>): void;
    protected projectGeoCenter(geoCenter: GeoPoint | null): void;
    protected projectCircle(viewContext: ViewContextType<this>): void;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected renderCircle(context: PaintingContext, frame: R2Box): void;
    protected renderGeoBounds(viewContext: ViewContextType<this>, outlineColor: Color, outlineWidth: number): void;
    protected updateGeoBounds(): void;
    readonly viewBounds: R2Box;
    deriveViewBounds(): R2Box;
    get popoverFrame(): R2Box;
    get hitBounds(): R2Box;
    protected hitTest(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestCircle(x: number, y: number, context: CanvasContext, frame: R2Box, transform: Transform): GraphicsView | null;
    ripple(options?: GeoRippleOptions): GeoRippleView | null;
    init(init: GeoCircleViewInit): void;
}

/** @public */
export declare interface GeoCircleViewInit extends GeoViewInit, FillViewInit, StrokeViewInit {
    geoCenter?: AnyGeoPoint;
    viewCenter?: AnyR2Point;
    radius?: AnyLength;
    hitRadius?: number;
}

/** @public */
export declare interface GeoCircleViewObserver<V extends GeoCircleView = GeoCircleView> extends GeoViewObserver<V> {
    viewWillSetGeoCenter?(newGeoCenter: GeoPoint | null, oldGeoCenter: GeoPoint | null, view: V): void;
    viewDidSetGeoCenter?(newGeoCenter: GeoPoint | null, oldGeoCenter: GeoPoint | null, view: V): void;
}

/** @public */
export declare abstract class GeoController extends Controller {
    readonly observerType?: Class<GeoControllerObserver>;
    readonly geoTiming: Property<this, Timing | boolean | undefined, AnyTiming>;
    abstract readonly geo: TraitViewRef<this, GeoTrait, GeoView>;
    static fromTrait(geoTrait: GeoTrait): GeoController;
}

/** @public */
export declare interface GeoControllerObserver<C extends GeoController = GeoController> extends ControllerObserver<C> {
    controllerWillAttachGeoTrait?(geoTrait: GeoTrait, controller: C): void;
    controllerDidDetachGeoTrait?(geoTrait: GeoTrait, controller: C): void;
    controllerWillAttachGeoView?(geoView: GeoView, controller: C): void;
    controllerDidDetachGeoView?(geoView: GeoView, controller: C): void;
    controllerWillSetGeoBounds?(newGeoBounds: GeoBox, oldGeoBounds: GeoBox, controller: C): void;
    controllerDidSetGeoBounds?(newGeoBounds: GeoBox, oldGeoBounds: GeoBox, controller: C): void;
}

/** @public */
export declare class GeoGridController extends GeoLayerController {
    constructor(geoTile: GeoTile);
    readonly observerType?: Class<GeoGridControllerObserver>;
    readonly geoTile: GeoTile;
    get minCullZoom(): number;
    get maxCullZoom(): number;
    protected autoCullGeoView(geoViewport: GeoViewport, geoView: GeoView): void;
    get minConsumeZoom(): number;
    get maxConsumeZoom(): number;
    protected autoConsumeGeoView(geoViewport: GeoViewport, geoView: GeoView): void;
    readonly geo: TraitViewRef<this, GeoGridTrait, GeoView>;
    static readonly geo: MemberFastenerClass<GeoGridController, "geo">;
    readonly features: TraitViewControllerSet<this, GeoTrait, GeoView, GeoController> & GeoLayerControllerFeatureExt;
    static readonly features: MemberFastenerClass<GeoGridController, "features">;
    readonly tiles: TraitViewControllerSet<this, GeoGridTrait, GeoView, GeoGridController> & GeoGridControllerTileExt;
    static readonly tiles: MemberFastenerClass<GeoGridController, "tiles">;
}

/** @public */
export declare interface GeoGridControllerObserver<C extends GeoGridController = GeoGridController> extends GeoLayerControllerObserver<C> {
    controllerWillAttachGeoTrait?(geoTrait: GeoGridTrait, controller: C): void;
    controllerDidDetachGeoTrait?(geoTrait: GeoGridTrait, controller: C): void;
    controllerWillAttachTile?(tileController: GeoGridController, controller: C): void;
    controllerDidDetachTile(tileController: GeoGridController, controller: C): void;
    controllerWillAttachTileTrait?(tileTrait: GeoTrait, tileController: GeoGridController, controller: C): void;
    controllerDidDetachTileTrait?(tileTrait: GeoTrait, tileController: GeoGridController, controller: C): void;
    controllerWillAttachTileView?(tileView: GeoView, tileController: GeoGridController, controller: C): void;
    controllerDidDetachTileView?(tileView: GeoView, tileController: GeoGridController, controller: C): void;
}

/** @public */
export declare interface GeoGridControllerTileExt {
    attachTileTrait(tileTrait: GeoGridTrait, tileController: GeoGridController): void;
    detachTileTrait(tileTrait: GeoGridTrait, tileController: GeoGridController): void;
    attachTileView(tileView: GeoView, tileController: GeoGridController): void;
    detachTileView(tileView: GeoView, tileController: GeoGridController): void;
}

/** @public */
export declare class GeoGridTrait extends GeoLayerTrait {
    constructor(geoTile: GeoTile);
    readonly observerType?: Class<GeoGridTraitObserver>;
    readonly geoTile: GeoTile;
    readonly geoBounds: GeoBox;
    setGeoBounds(newGeoBounds: GeoBox): void;
    readonly features: TraitSet<this, GeoTrait>;
    static readonly features: MemberFastenerClass<GeoGridTrait, "features">;
    readonly tiles: TraitSet<this, GeoGridTrait>;
    static readonly tiles: MemberFastenerClass<GeoGridTrait, "tiles">;
    protected createTileTrait(geoTile: GeoTile): GeoGridTrait | null;
    protected createTileModel(geoTile: GeoTile): Model | null;
    protected initTiles(): void;
    protected onStartConsuming(): void;
}

/** @public */
export declare interface GeoGridTraitObserver<R extends GeoGridTrait = GeoGridTrait> extends GeoLayerTraitObserver<R> {
    traitWillAttachTile?(tileTrait: GeoGridTrait, trait: R): void;
    traitDidDetachTile?(tileTrait: GeoGridTrait, trait: R): void;
}

/** @public */
export declare class GeoGridView extends GeoView {
    constructor(geoTile: GeoTile);
    readonly geoTile: GeoTile;
    readonly geoBounds: GeoBox;
    protected setGeoBounds(newGeoBounds: GeoBox): void;
    protected updateGeoBounds(): void;
}

/** @public */
export declare class GeoIconController extends GeoController {
    readonly observerType?: Class<GeoIconControllerObserver>;
    protected setGeoCenter(geoCenter: GeoPoint | null, geoTrait: GeoIconTrait, timing?: AnyTiming | boolean): void;
    protected setIconLayout(iconLayout: IconLayout | null, geoTrait: GeoIconTrait, timing?: AnyTiming | boolean): void;
    protected setGraphics(graphics: Graphics | null, geoTrait: GeoIconTrait, timing?: AnyTiming | boolean): void;
    readonly geo: TraitViewRef<this, GeoIconTrait, GeoIconView>;
    static readonly geo: MemberFastenerClass<GeoIconController, "geo">;
}

/** @public */
export declare interface GeoIconControllerObserver<C extends GeoIconController = GeoIconController> extends GeoControllerObserver<C> {
    controllerWillAttachGeoTrait?(geoTrait: GeoIconTrait, controller: C): void;
    controllerDidDetachGeoTrait?(geoTrait: GeoIconTrait, controller: C): void;
    controllerWillAttachGeoView?(geoView: GeoIconView, controller: C): void;
    controllerDidDetachGeoView?(geoView: GeoIconView, controller: C): void;
    controllerWillSetGeoCenter?(newGeoCenter: GeoPoint | null, oldGeoCenter: GeoPoint | null, controller: C): void;
    controllerDidSetGeoCenter?(newGeoCenter: GeoPoint | null, oldGeoCenter: GeoPoint | null, controller: C): void;
    controllerWillSetGraphics?(newGraphics: Graphics | null, oldGraphics: Graphics | null, controller: C): void;
    controllerDidSetGraphics?(newGraphics: Graphics | null, oldGraphics: Graphics | null, controller: C): void;
}

/** @public */
export declare class GeoIconTrait extends GeoTrait {
    readonly observerType?: Class<GeoIconTraitObserver>;
    get geoBounds(): GeoBox;
    readonly geoCenter: Property<this, GeoPoint | null, AnyGeoPoint | null>;
    readonly iconLayout: Property<this, IconLayout | null, AnyIconLayout | null>;
    readonly graphics: Property<this, Graphics | null>;
}

/** @public */
export declare interface GeoIconTraitObserver<R extends GeoIconTrait = GeoIconTrait> extends GeoTraitObserver<R> {
    traitWillSetGeoCenter?(newGeoCenter: GeoPoint | null, oldGeoCenter: GeoPoint | null, trait: R): void;
    traitDidSetGeoCenter?(newGeoCenter: GeoPoint | null, oldGeoCenter: GeoPoint | null, trait: R): void;
    traitWillSetIconLayout?(newIconLayout: IconLayout | null, oldIconLayout: IconLayout | null, trait: R): void;
    traitDidSetIconLayout?(newIconLayout: IconLayout | null, oldIconLayout: IconLayout | null, trait: R): void;
    traitWillSetGraphics?(newGraphics: Graphics | null, oldGraphics: Graphics | null, trait: R): void;
    traitDidSetGraphics?(newGraphics: Graphics | null, oldGraphics: Graphics | null, trait: R): void;
}

/** @public */
export declare class GeoIconView extends GeoView implements IconView {
    constructor();
    readonly observerType?: Class<GeoIconViewObserver>;
    /** @internal */
    sprite: Sprite | null;
    readonly geoCenter: Animator<this, GeoPoint | null, AnyGeoPoint | null>;
    readonly viewCenter: Animator<this, R2Point | null, AnyR2Point | null>;
    readonly xAlign: Animator<this, number>;
    readonly yAlign: Animator<this, number>;
    readonly iconWidth: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly iconHeight: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly iconColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly graphics: ThemeAnimator<this, Graphics | null>;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    protected onProject(viewContext: ViewContextType<this>): void;
    protected projectGeoCenter(geoCenter: GeoPoint | null): void;
    protected projectIcon(viewContext: ViewContextType<this>): void;
    protected onRasterize(viewContext: ViewContextType<this>): void;
    protected rasterizeIcon(frame: R2Box): void;
    protected onComposite(viewContext: ViewContextType<this>): void;
    protected compositeIcon(renderer: CanvasRenderer, frame: R2Box): void;
    protected renderGeoBounds(viewContext: ViewContextType<this>, outlineColor: Color, outlineWidth: number): void;
    protected updateGeoBounds(): void;
    readonly viewBounds: R2Box;
    deriveViewBounds(viewFrame?: R2Box): R2Box;
    get popoverFrame(): R2Box;
    protected hitTest(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestIcon(x: number, y: number, renderer: CanvasRenderer, frame: R2Box): GraphicsView | null;
    ripple(options?: GeoRippleOptions): GeoRippleView | null;
    protected onUnmount(): void;
    init(init: GeoIconViewInit): void;
    static readonly MountFlags: ViewFlags;
    static readonly UncullFlags: ViewFlags;
}

/** @public */
export declare interface GeoIconViewInit extends GeoViewInit, IconViewInit {
    geoCenter?: AnyGeoPoint;
    viewCenter?: AnyR2Point;
}

/** @public */
export declare interface GeoIconViewObserver<V extends GeoIconView = GeoIconView> extends GeoViewObserver<V> {
    viewWillSetGeoCenter?(newGeoCenter: GeoPoint | null, oldGeoCenter: GeoPoint | null, view: V): void;
    viewDidSetGeoCenter?(newGeoCenter: GeoPoint | null, oldGeoCenter: GeoPoint | null, view: V): void;
    viewWillSetGraphics?(newGraphics: Graphics | null, oldGraphics: Graphics | null, view: V): void;
    viewDidSetGraphics?(newGraphics: Graphics | null, oldGraphics: Graphics | null, view: V): void;
}

/** @public */
export declare class GeoLayerController extends GeoController {
    readonly observerType?: Class<GeoLayerControllerObserver>;
    readonly geo: TraitViewRef<this, GeoLayerTrait, GeoView>;
    static readonly geo: MemberFastenerClass<GeoLayerController, "geo">;
    readonly features: TraitViewControllerSet<this, GeoTrait, GeoView, GeoController> & GeoLayerControllerFeatureExt;
    static readonly features: MemberFastenerClass<GeoLayerController, "features">;
}

/** @public */
export declare interface GeoLayerControllerFeatureExt {
    attachFeatureTrait(featureTrait: GeoTrait, featureController: GeoController): void;
    detachFeatureTrait(featureTrait: GeoTrait, featureController: GeoController): void;
    attachFeatureView(featureView: GeoView, featureController: GeoController): void;
    detachFeatureView(featureView: GeoView, featureController: GeoController): void;
}

/** @public */
export declare interface GeoLayerControllerObserver<C extends GeoLayerController = GeoLayerController> extends GeoControllerObserver<C> {
    controllerWillAttachGeoTrait?(geoTrait: GeoLayerTrait, controller: C): void;
    controllerDidDetachGeoTrait?(geoTrait: GeoLayerTrait, controller: C): void;
    controllerWillAttachGeoView?(geoView: GeoView, controller: C): void;
    controllerDidDetachGeoView?(geoView: GeoView, controller: C): void;
    controllerWillAttachFeature?(featureController: GeoController, controller: C): void;
    controllerDidDetachFeature(featureController: GeoController, controller: C): void;
    controllerWillAttachFeatureTrait?(featureTrait: GeoTrait, featureController: GeoController, controller: C): void;
    controllerDidDetachFeatureTrait?(featureTrait: GeoTrait, featureController: GeoController, controller: C): void;
    controllerWillAttachFeatureView?(featureView: GeoView, featureController: GeoController, controller: C): void;
    controllerDidDetachFeatureView?(featureView: GeoView, featureController: GeoController, controller: C): void;
    controllerWillSetFeatureGeoBounds?(newGeoBounds: GeoBox, oldGeoBounds: GeoBox, featureController: GeoController, controller: C): void;
    controllerDidSetFeatureGeoBounds?(newGeoBounds: GeoBox, oldGeoBounds: GeoBox, featureController: GeoController, controller: C): void;
}

/** @public */
export declare class GeoLayerTrait extends GeoTrait {
    constructor();
    readonly observerType?: Class<GeoLayerTraitObserver>;
    readonly geoBounds: GeoBox;
    setGeoBounds(newGeoBounds: GeoBox): void;
    protected willSetGeoBounds(newGeoBounds: GeoBox, oldGeoBounds: GeoBox): void;
    protected onSetGeoBounds(newGeoBounds: GeoBox, oldGeoBounds: GeoBox): void;
    protected didSetGeoBounds(newGeoBounds: GeoBox, oldGeoBounds: GeoBox): void;
    readonly features: TraitSet<this, GeoTrait>;
    static readonly features: MemberFastenerClass<GeoLayerTrait, "features">;
    /** @internal */
    protected startConsumingFeatures(): void;
    /** @internal */
    protected stopConsumingFeatures(): void;
    protected onStartConsuming(): void;
    protected onStopConsuming(): void;
}

/** @public */
export declare interface GeoLayerTraitObserver<R extends GeoLayerTrait = GeoLayerTrait> extends GeoTraitObserver<R> {
    traitWillAttachFeature?(featureTrait: GeoTrait, trait: R): void;
    traitDidDetachFeature?(featureTrait: GeoTrait, trait: R): void;
}

/** @public */
export declare class GeoLineController extends GeoPathController {
    readonly observerType?: Class<GeoLineControllerObserver>;
    protected setGeoPath(geoPath: GeoPath | null, geoTrait: GeoLineTrait, timing?: AnyTiming | boolean): void;
    protected setStroke(stroke: Look<Color> | Color | null, geoTrait: GeoLineTrait, timing?: AnyTiming | boolean): void;
    protected setStrokeWidth(strokeWidth: Length | null, geoTrait: GeoLineTrait, timing?: AnyTiming | boolean): void;
    readonly geo: TraitViewRef<this, GeoLineTrait, GeoLineView>;
    static readonly geo: MemberFastenerClass<GeoLineController, "geo">;
}

/** @public */
export declare interface GeoLineControllerObserver<C extends GeoLineController = GeoLineController> extends GeoPathControllerObserver<C> {
    controllerWillAttachGeoTrait?(geoTrait: GeoLineTrait, controller: C): void;
    controllerDidDetachGeoTrait?(geoTrait: GeoLineTrait, controller: C): void;
    controllerWillAttachGeoView?(geoView: GeoLineView, controller: C): void;
    controllerDidDetachGeoView?(geoView: GeoLineView, controller: C): void;
    controllerWillSetStroke?(newStroke: Look<Color> | Color | null, oldStroke: Look<Color> | Color | null, controller: C): void;
    controllerDidSetStroke?(newStroke: Look<Color> | Color | null, oldStroke: Look<Color> | Color | null, controller: C): void;
    controllerWillSetStrokeWidth?(newStrokeWidth: Length | null, oldStrokeWidth: Length | null, controller: C): void;
    controllerDidSetStrokeWidth?(newStrokeWidth: Length | null, oldStrokeWidth: Length | null, controller: C): void;
}

/** @public */
export declare abstract class GeoLineTrait extends GeoPathTrait {
    readonly observerType?: Class<GeoLineTraitObserver>;
    readonly stroke: Property<this, Look<Color> | Color | null, Look<Color> | AnyColor | null>;
    readonly strokeWidth: Property<this, Length | null, AnyLength | null>;
}

/** @public */
export declare interface GeoLineTraitObserver<R extends GeoLineTrait = GeoLineTrait> extends GeoPathTraitObserver<R> {
    traitWillSetStroke?(newStroke: Look<Color> | Color | null, oldStroke: Look<Color> | Color | null, trait: R): void;
    traitDidSetStroke?(newStroke: Look<Color> | Color | null, oldStroke: Look<Color> | Color | null, trait: R): void;
    traitWillSetStrokeWidth?(newStrokeWidth: Length | null, oldStrokeWidth: Length | null, trait: R): void;
    traitDidSetStrokeWidth?(newStrokeWidth: Length | null, oldStrokeWidth: Length | null, trait: R): void;
}

/** @public */
export declare class GeoLineView extends GeoPathView implements StrokeView {
    readonly observerType?: Class<GeoLineViewObserver>;
    readonly stroke: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly strokeWidth: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly hitWidth: Property<this, number | undefined>;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected renderLine(context: PaintingContext, frame: R2Box): void;
    protected hitTest(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestLine(x: number, y: number, context: CanvasContext, frame: R2Box): GraphicsView | null;
    init(init: GeoLineViewInit): void;
}

/** @public */
export declare interface GeoLineViewInit extends GeoPathViewInit, StrokeViewInit {
    hitWidth?: number;
}

/** @public */
export declare interface GeoLineViewObserver<V extends GeoLineView = GeoLineView> extends GeoPathViewObserver<V> {
    viewWillSetStroke?(newStroke: Color | null, oldStroke: Color | null, view: V): void;
    viewDidSetStroke?(newStroke: Color | null, oldStroke: Color | null, view: V): void;
    viewWillSetStrokeWidth?(newStrokeWidth: Length | null, oldStrokeWidth: Length | null, view: V): void;
    viewDidSetStrokeWidth?(newStrokeWidth: Length | null, oldStrokeWidth: Length | null, view: V): void;
}

/** @public */
export declare abstract class GeoPathController extends GeoController {
    readonly observerType?: Class<GeoPathControllerObserver>;
    abstract readonly geo: TraitViewRef<this, GeoPathTrait, GeoPathView>;
}

/** @public */
export declare interface GeoPathControllerObserver<C extends GeoPathController = GeoPathController> extends GeoControllerObserver<C> {
    controllerWillAttachGeoTrait?(geoTrait: GeoPathTrait, controller: C): void;
    controllerDidDetachGeoTrait?(geoTrait: GeoPathTrait, controller: C): void;
    controllerWillAttachGeoView?(geoView: GeoPathView, controller: C): void;
    controllerDidDetachGeoView?(geoView: GeoPathView, controller: C): void;
    controllerWillSetGeoPath?(newGeoPath: GeoPath | null, oldGeoPath: GeoPath | null, controller: C): void;
    controllerDidSetGeoPath?(newGeoPath: GeoPath | null, oldGeoPath: GeoPath | null, controller: C): void;
}

/** @public */
export declare abstract class GeoPathTrait extends GeoTrait {
    readonly observerType?: Class<GeoPathTraitObserver>;
    get geoBounds(): GeoBox;
    readonly geoPath: Property<this, GeoPath | null, AnyGeoPath | null>;
}

/** @public */
export declare interface GeoPathTraitObserver<R extends GeoPathTrait = GeoPathTrait> extends GeoTraitObserver<R> {
    traitWillSetGeoPath?(newGeoPath: GeoPath | null, oldGeoPath: GeoPath | null, trait: R): void;
    traitDidSetGeoPath?(newGeoPath: GeoPath | null, oldGeoPath: GeoPath | null, trait: R): void;
}

/** @public */
export declare class GeoPathView extends GeoView {
    constructor();
    readonly observerType?: Class<GeoPathViewObserver>;
    readonly geoPath: Animator<this, GeoPath | null, AnyGeoPath | null>;
    readonly viewPath: Animator<this, R2Path | null>;
    readonly geoCentroid: Animator<this, GeoPoint | null, AnyGeoPoint | null>;
    readonly viewCentroid: Animator<this, R2Point | null, AnyR2Point | null>;
    protected onProject(viewContext: ViewContextType<this>): void;
    protected projectPath(viewContext: ViewContextType<this>): void;
    protected updateGeoBounds(): void;
    get popoverFrame(): R2Box;
    readonly viewBounds: R2Box;
    ripple(options?: GeoRippleOptions): GeoRippleView | null;
    init(init: GeoPathViewInit): void;
}

/** @public */
export declare interface GeoPathViewInit extends GeoViewInit {
    geoPath?: GeoPath;
}

/** @public */
export declare interface GeoPathViewObserver<V extends GeoPathView = GeoPathView> extends GeoViewObserver<V> {
    viewWillSetGeoPath?(newGeoPath: GeoPath | null, oldGeoPath: GeoPath | null, view: V): void;
    viewDidSetGeoPath?(newGeoPath: GeoPath | null, oldGeoPath: GeoPath | null, view: V): void;
}

/** @public */
export declare interface GeoPerspective {
    readonly geoFrame: GeoBox | null;
    readonly geoCenter: GeoPoint | null;
    readonly zoom: number | undefined;
    readonly heading: number | undefined;
    readonly tilt: number | undefined;
}

/** @public */
export declare const GeoPerspective: {
    fromAny(value: AnyGeoPerspective): GeoPerspective;
    is(object: unknown): object is GeoPerspective;
};

/** @public */
export declare interface GeoPerspectiveInit {
    geoFrame?: AnyGeoBox | null;
    geoCenter?: AnyGeoPoint | null;
    zoom?: number;
    heading?: number;
    tilt?: number;
}

/** @public */
export declare class GeoPlotView extends GeoView implements StrokeView {
    constructor();
    readonly observerType?: Class<GeoPlotViewObserver>;
    points(): ReadonlyArray<GeoPointView>;
    points(points: ReadonlyArray<AnyGeoPointView>, timing?: AnyTiming | boolean): this;
    appendPoint(point: AnyGeoPointView, key?: string): GeoPointView;
    setPoint(key: string, point: AnyGeoPointView): GeoPointView;
    readonly geoCentroid: Property<this, GeoPoint, AnyGeoPoint>;
    readonly viewCentroid: Property<this, R2Point, AnyR2Point>;
    readonly stroke: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly strokeWidth: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly font: ThemeAnimator<this, Font | null, AnyFont | null>;
    readonly textColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly hitWidth: Property<this, number | undefined>;
    /** @internal */
    readonly gradientStops: number;
    protected onInsertChild(childView: View, targetView: View | null): void;
    protected onInsertPoint(childView: GeoPointView): void;
    protected didProject(viewContext: ViewContextType<this>): void;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected renderPlotStroke(context: PaintingContext, frame: R2Box): void;
    protected renderPlotGradient(context: CanvasContext, frame: R2Box): void;
    protected updateGeoBounds(): void;
    get popoverFrame(): R2Box;
    readonly viewBounds: R2Box;
    protected hitTest(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestPlot(x: number, y: number, context: CanvasContext, frame: R2Box): GraphicsView | null;
    ripple(options?: GeoRippleOptions): GeoRippleView | null;
    init(init: GeoPlotViewInit): void;
}

/** @public */
export declare interface GeoPlotViewInit extends GeoViewInit, StrokeViewInit {
    points?: ReadonlyArray<AnyGeoPointView>;
    hitWidth?: number;
    font?: AnyFont;
    textColor?: AnyColor;
}

/** @public */
export declare interface GeoPlotViewObserver<V extends GeoPlotView = GeoPlotView> extends GeoViewObserver<V> {
}

/** @public */
export declare type GeoPointLabelPlacement = "auto" | "top" | "right" | "bottom" | "left";

/** @public */
export declare class GeoPointView extends GeoView {
    readonly observerType?: Class<GeoPointViewObserver>;
    readonly geoPoint: Animator<this, GeoPoint, AnyGeoPoint>;
    readonly viewPoint: Animator<this, R2Point, AnyR2Point>;
    readonly radius: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly color: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly opacity: ThemeAnimator<this, number | undefined>;
    readonly labelPadding: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly font: ThemeAnimator<this, Font | null, AnyFont | null>;
    readonly textColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly hitRadius: Property<this, number | undefined>;
    readonly label: ViewRef<this, GraphicsView & Initable<GraphicsViewInit | string>>;
    static readonly label: MemberFastenerClass<GeoPointView, "label">;
    readonly labelPlacement: Property<this, GeoPointLabelPlacement>;
    isGradientStop(): boolean;
    setState(point: AnyGeoPointView, timing?: AnyTiming | boolean): void;
    protected needsProcess(processFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    protected onProject(viewContext: ViewContextType<this>): void;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected layoutLabel(labelView: GraphicsView, frame: R2Box): void;
    protected updateGeoBounds(): void;
    readonly viewBounds: R2Box;
    get hitBounds(): R2Box;
    protected hitTest(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestPoint(hx: number, hy: number, context: CanvasContext, frame: R2Box): GraphicsView | null;
    ripple(options?: GeoRippleOptions): GeoRippleView | null;
    toAny(): GeoPointViewInit;
    init(init: AnyGeoPoint | GeoPointViewInit): void;
}

/** @public */
export declare interface GeoPointViewInit extends GeoViewInit {
    lng?: number;
    lat?: number;
    x?: number;
    y?: number;
    radius?: AnyLength;
    hitRadius?: number;
    color?: AnyColor;
    opacity?: number;
    labelPadding?: AnyLength;
    labelPlacement?: GeoPointLabelPlacement;
    font?: AnyFont;
    textColor?: AnyColor;
    label?: GraphicsView | string;
}

/** @public */
export declare interface GeoPointViewObserver<V extends GeoPointView = GeoPointView> extends GeoViewObserver<V> {
    viewWillSetGeoPoint?(newGeoPoint: GeoPoint, oldGeoPoint: GeoPoint, view: V): void;
    viewDidSetGeoPoint?(newGeoPoint: GeoPoint, oldGeoPoint: GeoPoint, view: V): void;
    viewWillAttachGeoLabel?(labelView: GraphicsView, view: V): void;
    viewDidDetachGeoLabel?(labelView: GraphicsView, view: V): void;
}

/** @public */
export declare class GeoRasterView extends GeoView {
    constructor();
    readonly observerType?: Class<GeoRasterViewObserver>;
    readonly contextType?: Class<GeoRasterViewContext>;
    readonly geoAnchor: Animator<this, GeoPoint | null, AnyGeoPoint | null>;
    readonly viewAnchor: Animator<this, R2Point | null, AnyR2Point | null>;
    readonly xAlign: Animator<this, number>;
    readonly yAlign: Animator<this, number>;
    readonly width: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly height: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly opacity: ThemeAnimator<this, number>;
    readonly compositeOperation: Animator<this, CanvasCompositeOperation>;
    get pixelRatio(): number;
    /** @internal */
    readonly canvas: HTMLCanvasElement;
    get compositor(): GraphicsRenderer | null;
    readonly renderer: GraphicsRenderer | null;
    setRenderer(renderer: AnyGraphicsRenderer | null): void;
    protected createRenderer(rendererType?: GraphicsRendererType): GraphicsRenderer | null;
    protected needsUpdate(updateFlags: ViewFlags, immediate: boolean): ViewFlags;
    protected needsProcess(processFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    protected onResize(viewContext: ViewContextType<this>): void;
    protected onProject(viewContext: ViewContextType<this>): void;
    protected projectGeoAnchor(geoAnchor: GeoPoint | null): void;
    protected projectRaster(viewContext: ViewContextType<this>): void;
    protected needsDisplay(displayFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected didComposite(viewContext: ViewContextType<this>): void;
    extendViewContext(viewContext: GeoViewContext): ViewContextType<this>;
    /** @internal */
    readonly ownRasterFrame: R2Box | null;
    get rasterFrame(): R2Box;
    /** @internal */
    setRasterFrame(rasterFrame: R2Box | null): void;
    protected deriveRasterFrame(): R2Box;
    protected createCanvas(): HTMLCanvasElement;
    protected resizeCanvas(canvas: HTMLCanvasElement, rasterFrame: R2Box): void;
    protected clearCanvas(rasterFrame: R2Box): void;
    protected resetRenderer(rasterFrame: R2Box): void;
    protected compositeImage(viewContext: ViewContextType<this>): void;
    ripple(options?: GeoRippleOptions): GeoRippleView | null;
    init(init: GeoRasterViewInit): void;
    static readonly MountFlags: ViewFlags;
    static readonly UncullFlags: ViewFlags;
    static readonly UnhideFlags: ViewFlags;
}

/** @public */
export declare interface GeoRasterViewContext extends GeoViewContext {
    readonly compositor: GraphicsRenderer | null;
}

/** @public */
export declare interface GeoRasterViewInit extends GeoViewInit {
    geoAnchor?: AnyGeoPoint;
    viewAnchor?: AnyR2Point;
    xAlign?: number;
    yAlign?: number;
    width?: AnyLength;
    height?: AnyLength;
    opacity?: number;
    compositeOperation?: CanvasCompositeOperation;
}

/** @public */
export declare interface GeoRasterViewObserver<V extends GeoRasterView = GeoRasterView> extends GeoViewObserver<V> {
    viewWillSetGeoAnchor?(newGeoAnchor: GeoPoint | null, oldGeoAnchor: GeoPoint | null, view: V): void;
    viewDidSetGeoAnchor?(newGeoAnchor: GeoPoint | null, oldGeoAnchor: GeoPoint | null, view: V): void;
}

/** @public */
export declare interface GeoRippleOptions {
    source?: GeoView | null;
    center?: AnyGeoPoint | null;
    width?: AnyLength | null;
    radius?: AnyLength | null;
    color?: Look<Color> | AnyColor | null;
    opacity?: number;
    timing?: AnyTiming | number | boolean;
}

/** @public */
export declare class GeoRippleView extends GeoView implements StrokeView {
    constructor();
    readonly observerType?: Class<GeoRippleViewObserver>;
    readonly geoCenter: Animator<this, GeoPoint | null, AnyGeoPoint | null>;
    readonly viewCenter: Animator<this, R2Point | null, AnyR2Point | null>;
    readonly radius: ThemeAnimator<this, Length, AnyLength>;
    readonly stroke: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly strokeWidth: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly source: ViewRef<this, GeoView>;
    static readonly source: MemberFastenerClass<GeoRippleView, "source">;
    protected onProject(viewContext: ViewContextType<this>): void;
    protected projectGeoCenter(geoCenter: GeoPoint | null): void;
    protected projectRipple(viewContext: ViewContextType<this>): void;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected renderRipple(context: PaintingContext, frame: R2Box): void;
    protected renderGeoBounds(viewContext: ViewContextType<this>, outlineColor: Color, outlineWidth: number): void;
    protected updateGeoBounds(): void;
    readonly viewBounds: R2Box;
    protected updateViewBounds(): void;
    deriveViewBounds(): R2Box;
    ripple(options?: GeoRippleOptions): this;
    static ripple(sourceView: GeoView, options?: GeoRippleOptions): GeoRippleView | null;
}

/** @public */
export declare interface GeoRippleViewObserver<V extends GeoRippleView = GeoRippleView> extends GeoViewObserver<V> {
    viewWillSetGeoCenter?(newGeoCenter: GeoPoint | null, oldGeoCenter: GeoPoint | null, view: V): void;
    viewDidSetGeoCenter?(newGeoCenter: GeoPoint | null, oldGeoCenter: GeoPoint | null, view: V): void;
}

/** @public */
export declare abstract class GeoTrait extends Trait {
    readonly observerType?: Class<GeoTraitObserver>;
    abstract readonly geoBounds: GeoBox;
}

/** @public */
export declare interface GeoTraitObserver<R extends GeoTrait = GeoTrait> extends TraitObserver<R> {
    traitWillSetGeoBounds?(newGeoBounds: GeoBox, oldGeoBounds: GeoBox, trait: R): void;
    traitDidSetGeoBounds?(newGeoBounds: GeoBox, oldGeoBounds: GeoBox, trait: R): void;
}

/** @public */
export declare class GeoTree {
    constructor(depth: number, maxDepth: number, density: number, geoFrame: GeoBox, geoBounds: GeoBox, geoCenter: GeoPoint, southWest: GeoTree | null, northWest: GeoTree | null, southEast: GeoTree | null, northEast: GeoTree | null, views: ReadonlyArray<GeoView>, size: number);
    readonly depth: number;
    readonly maxDepth: number;
    readonly density: number;
    readonly geoFrame: GeoBox;
    readonly geoBounds: GeoBox;
    readonly geoCenter: GeoPoint;
    readonly southWest: GeoTree | null;
    readonly northWest: GeoTree | null;
    readonly southEast: GeoTree | null;
    readonly northEast: GeoTree | null;
    readonly views: ReadonlyArray<GeoView>;
    readonly size: number;
    isEmpty(): boolean;
    contains(bounds: GeoBox): boolean;
    intersects(bounds: GeoBox): boolean;
    getTree(bounds: GeoBox): GeoTree;
    has(view: GeoView, bounds: GeoBox): boolean;
    private hasNode;
    private hasLeaf;
    inserted(view: GeoView, bounds: GeoBox): GeoTree;
    private insertedNode;
    private insertedLeaf;
    removed(view: GeoView, bounds: GeoBox): GeoTree;
    private removedNode;
    private removedLeaf;
    private reinsertedNode;
    private reinsertedLeaf;
    moved(view: GeoView, newBounds: GeoBox, oldBounds: GeoBox): GeoTree;
    forEach<T>(callback: (view: GeoView) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, view: GeoView) => T | void, thisArg: S): T | undefined;
    forEachReverse<T>(callback: (view: GeoView) => T | void): T | undefined;
    forEachReverse<T, S>(callback: (this: S, view: GeoView) => T | void, thisArg: S): T | undefined;
    forEachIntersecting<T>(bounds: GeoBox, callback: (view: GeoView) => T | void): T | undefined;
    forEachIntersecting<T, S>(bounds: GeoBox, callback: (this: S, view: GeoView) => T | void, thisArg: S): T | undefined;
    forEachNonIntersecting<T>(bounds: GeoBox, callback: (view: GeoView) => T | void): T | undefined;
    forEachNonIntersecting<T, S>(bounds: GeoBox, callback: (this: S, view: GeoView) => T | void, thisArg: S): T | undefined;
    protected createTree(depth: number, maxDepth: number, density: number, geoFrame: GeoBox, geoBounds?: GeoBox, geoCenter?: GeoPoint, southWest?: GeoTree | null, northWest?: GeoTree | null, southEast?: GeoTree | null, northEast?: GeoTree | null, views?: ReadonlyArray<GeoView>, size?: number): GeoTree;
    static empty(geoFrame?: GeoBox, depth?: number, maxDepth?: number, density?: number): GeoTree;
}

/** @public */
export declare class GeoTreeView extends GeoView {
    constructor(geoFrame?: GeoBox, depth?: number, maxDepth?: number, density?: number);
    /** @internal */
    readonly root: GeoTree;
    /** @internal */
    updateRoot(newRoot: GeoTree): void;
    /** @internal */
    readonly stem: GeoTree | null;
    /** @internal */
    getStem(geoBounds: GeoBox): GeoTree;
    protected onInsertChild(child: View, target: View | null): void;
    protected onRemoveChild(child: View): void;
    protected willProject(viewContext: ViewContextType<this>): void;
    protected processChildren(processFlags: ViewFlags, viewContext: ViewContextType<this>, processChild: (this: this, child: View, processFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    /** @internal */
    protected processTree(tree: GeoTree, processFlags: ViewFlags, viewContext: ViewContextType<this>, processChild: (this: this, child: View, processFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    readonly geoTreeColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected renderGeoTree(viewContext: ViewContextType<this>, outlineColor: Color): void;
    protected renderGeoTreeOutline(tree: GeoTree, geoProjection: GeoProjection, context: PaintingContext, outlineColor: Color): void;
    protected displayChildren(displayFlags: ViewFlags, viewContext: ViewContextType<this>, displayChild: (this: this, child: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    /** @internal */
    protected displayTree(tree: GeoTree, displayFlags: ViewFlags, viewContext: ViewContextType<this>, displayChild: (this: this, child: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    protected updateGeoBounds(): void;
    protected onSetChildGeoBounds(child: GeoView, newChildViewGeoBounds: GeoBox, oldChildViewGeoBounds: GeoBox): void;
    protected hitTest(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestTree(tree: GeoTree, x: number, y: number, geoPoint: GeoPoint, viewContext: ViewContextType<this>): GraphicsView | null;
    init(init: GeoTreeViewInit): void;
}

/** @public */
export declare interface GeoTreeViewInit extends GeoViewInit {
    geoTreeColor?: AnyColor;
}

/** @public */
export declare class GeoView extends GraphicsView {
    constructor();
    readonly observerType?: Class<GeoViewObserver>;
    readonly contextType?: Class<GeoViewContext>;
    readonly geoBoundsColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    protected didInsertChild(child: View, target: View | null): void;
    protected didRemoveChild(child: View): void;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected renderGeoBounds(viewContext: ViewContextType<this>, outlineColor: Color, outlineWidth: number): void;
    protected renderGeoOutline(geoBox: GeoBox, geoProjection: GeoProjection, context: PaintingContext, outlineColor: Color, outlineWidth: number): void;
    protected onHide(): void;
    protected onUnhide(): void;
    protected onSetUnbounded(unbounded: boolean): void;
    cullGeoFrame(geoFrame?: GeoBox): void;
    get geoViewport(): GeoViewport;
    /**
     * The map-specified geo-coordinate bounding box in which this view should layout
     * and render geometry.
     */
    get geoFrame(): GeoBox;
    /**
     * The self-defined geo-coordinate bounding box surrounding all geometry this
     * view could possibly render. Views with geo bounds that don't overlap
     * their map frames may be culled from rendering and hit testing.
     */
    readonly geoBounds: GeoBox;
    protected setGeoBounds(newGeoBounds: GeoBox): void;
    willSetGeoBounds(newGeoBounds: GeoBox, oldGeoBounds: GeoBox): void;
    protected onSetGeoBounds(newGeoBounds: GeoBox, oldGeoBounds: GeoBox): void;
    didSetGeoBounds(newGeoBounds: GeoBox, oldGeoBounds: GeoBox): void;
    protected updateGeoBounds(): void;
    protected onInsertChildGeoBounds(child: GeoView, newGeoBounds: GeoBox): void;
    protected onRemoveChildGeoBounds(child: GeoView, oldGeoBounds: GeoBox): void;
    protected onSetChildGeoBounds(child: GeoView, newGeoBounds: GeoBox, oldGeoBounds: GeoBox): void;
    protected onHideChild(child: GeoView): void;
    protected onUnhideChild(child: GeoView): void;
    protected onSetChildUnbounded(child: GeoView, unbounded: boolean): void;
    get ownGeoBounds(): GeoBox | null;
    deriveGeoBounds(): GeoBox;
    init(init: GeoViewInit): void;
    static readonly MountFlags: ViewFlags;
    static readonly UncullFlags: ViewFlags;
}

/** @public */
export declare interface GeoViewContext extends GraphicsViewContext {
    readonly geoViewport: GeoViewport;
}

/** @public */
export declare interface GeoViewInit extends GraphicsViewInit {
}

/** @public */
export declare interface GeoViewObserver<V extends GeoView = GeoView> extends GraphicsViewObserver<V> {
    viewWillSetGeoBounds?(newGeoBounds: GeoBox, oldGeoBounds: GeoBox, view: V): void;
    viewDidSetGeoBounds?(newGeoBounds: GeoBox, oldGeoBounds: GeoBox, view: V): void;
}

/** @public */
export declare interface GeoViewport extends GeoProjection, GeoPerspective {
    readonly geoFrame: GeoBox;
    readonly geoCenter: GeoPoint;
    readonly zoom: number;
    readonly heading: number;
    readonly tilt: number;
}

/** @public */
export declare const GeoViewport: {
    is(object: unknown): object is GeoViewport;
};

/** @public */
export declare interface Gesture<O = unknown, V extends View = View> extends Fastener<O> {
    (): V | null;
    (view: V | null, targetView?: View | null): O;
    /** @override */
    get fastenerType(): Proto<Gesture<any, any>>;
    readonly view: V | null;
    getView(): V;
    setView(newView: V | null, targetView?: View | null): V | null;
    /** @protected */
    willAttachView(view: V, target: View | null): void;
    /** @protected */
    onAttachView(view: V, target: View | null): void;
    /** @protected */
    didAttachView(view: V, target: View | null): void;
    /** @protected */
    willDetachView(view: V): void;
    /** @protected */
    onDetachView(view: V): void;
    /** @protected */
    didDetachView(view: V): void;
    /** @internal @protected */
    attachEvents(view: V): void;
    /** @internal @protected */
    detachEvents(view: V): void;
    /** @internal */
    readonly inputs: {
        readonly [inputId: string]: GestureInput | undefined;
    };
    readonly inputCount: number;
    getInput(inputId: string | number): GestureInput | null;
    /** @internal */
    createInput(inputId: string, inputType: GestureInputType, isPrimary: boolean, x: number, y: number, t: number): GestureInput;
    /** @internal */
    getOrCreateInput(inputId: string | number, inputType: GestureInputType, isPrimary: boolean, x: number, y: number, t: number): GestureInput;
    /** @internal */
    clearInput(input: GestureInput): void;
    /** @internal */
    clearInputs(): void;
    /** @internal */
    bindView(view: View, target?: View | null): void;
    /** @internal */
    unbindView(view: View): void;
    detectView(view: View): V | null;
    /** @internal */
    viewWillUnmount(view: V): void;
    /** @protected @override */
    onMount(): void;
    /** @internal */
    get key(): string | undefined;
    /** @internal */
    get self(): boolean | undefined;
    /** @internal */
    get binds(): boolean | undefined;
    /** @internal */
    get observes(): boolean | undefined;
    /** @internal @override */
    get lazy(): boolean;
    /** @internal @override */
    get static(): string | boolean;
}

/** @public */
export declare const Gesture: GestureFactory<Gesture<any, any>>;

/** @public */
export declare interface GestureClass<G extends Gesture<any, any> = Gesture<any, any>> extends FastenerClass<G> {
}

/** @public */
export declare type GestureDescriptor<O = unknown, V extends View = View, I = {}> = ThisType<Gesture<O, V> & I> & GestureInit<V> & Partial<I>;

/** @public */
export declare interface GestureFactory<G extends Gesture<any, any> = Gesture<any, any>> extends GestureClass<G> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): GestureFactory<G> & I;
    specialize(method: GestureMethod): GestureFactory | null;
    define<O, V extends View = View>(className: string, descriptor: GestureDescriptor<O, V>): GestureFactory<Gesture<any, V>>;
    define<O, V extends View = View>(className: string, descriptor: {
        observes: boolean;
    } & GestureDescriptor<O, V, ObserverType<V>>): GestureFactory<Gesture<any, V>>;
    define<O, V extends View = View, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & GestureDescriptor<O, V, I>): GestureFactory<Gesture<any, V> & I>;
    define<O, V extends View = View, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & GestureDescriptor<O, V, I & ObserverType<V>>): GestureFactory<Gesture<any, V> & I>;
    <O, V extends View = View>(descriptor: GestureDescriptor<O, V>): PropertyDecorator;
    <O, V extends View = View>(descriptor: {
        observes: boolean;
    } & GestureDescriptor<O, V, ObserverType<V>>): PropertyDecorator;
    <O, V extends View = View, I = {}>(descriptor: {
        implements: unknown;
    } & GestureDescriptor<O, V, I>): PropertyDecorator;
    <O, V extends View = View, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & GestureDescriptor<O, V, I & ObserverType<V>>): PropertyDecorator;
}

/** @public */
export declare interface GestureInit<V extends View = View> extends FastenerInit {
    extends?: {
        prototype: Gesture<any, any>;
    } | string | boolean | null;
    method?: GestureMethod;
    key?: string | boolean;
    self?: boolean;
    binds?: boolean;
    observes?: boolean;
    willAttachView?(view: V, target: View | null): void;
    didAttachView?(view: V, target: View | null): void;
    willDetachView?(view: V): void;
    didDetachView?(view: V): void;
    detectView?(view: View): V | null;
}

/** @public */
export declare class GestureInput {
    readonly inputId: string;
    inputType: GestureInputType;
    isPrimary: boolean;
    target: EventTarget | null;
    button: number;
    buttons: number;
    altKey: boolean;
    ctrlKey: boolean;
    metaKey: boolean;
    shiftKey: boolean;
    width: number;
    height: number;
    tiltX: number;
    tiltY: number;
    twist: number;
    pressure: number;
    tangentialPressure: number;
    x0: number;
    y0: number;
    t0: number;
    dx: number;
    dy: number;
    dt: number;
    x: number;
    y: number;
    t: number;
    detail: unknown;
    defaultPrevented: boolean;
    constructor(inputId: string, inputType: GestureInputType, isPrimary: boolean, x: number, y: number, t: number);
    preventDefault(): void;
    /** @internal */
    static pointerInputType(inputType: string): GestureInputType;
}

/** @public */
export declare type GestureInputType = "mouse" | "wheel" | "touch" | "pen" | "unknown";

/** @public */
export declare type GestureMethod = "auto" | "pointer" | "touch" | "mouse";

/** @internal */
export declare type GestureView<G extends Gesture<any, any>> = G extends Gesture<any, infer V> ? V : never;

/** @public */
export declare class GoogleMapView extends MapView {
    constructor(map: google.maps.Map);
    readonly observerType?: Class<GoogleMapViewObserver>;
    readonly map: google.maps.Map;
    protected initMap(map: google.maps.Map): void;
    readonly mapOverlay: google.maps.OverlayView;
    protected createMapOverlay(map: google.maps.Map): google.maps.OverlayView;
    /** @internal */
    static get MapOverlay(): {
        new (owner: GoogleMapView): google.maps.OverlayView;
    };
    readonly geoViewport: GoogleMapViewport;
    protected willSetGeoViewport(newGeoViewport: GoogleMapViewport, oldGeoViewport: GoogleMapViewport): void;
    protected onSetGeoViewport(newGeoViewport: GoogleMapViewport, oldGeoViewport: GoogleMapViewport): void;
    protected didSetGeoViewport(newGeoViewport: GoogleMapViewport, oldGeoViewport: GoogleMapViewport): void;
    protected updateGeoViewport(): boolean;
    protected willProcess(processFlags: ViewFlags, viewContext: ViewContextType<this>): void;
    protected onMapDraw(): void;
    protected onMapIdle(): void;
    moveTo(geoPerspective: AnyGeoPerspective, timing?: AnyTiming | boolean): void;
    readonly canvas: ViewRef<this, CanvasView>;
    static readonly canvas: MemberFastenerClass<GoogleMapView, "canvas">;
    readonly container: ViewRef<this, HtmlView> & {
        materializeView(containerView: HtmlView): void;
    };
    static readonly container: MemberFastenerClass<GoogleMapView, "container">;
}

/** @public */
export declare interface GoogleMapViewObserver<V extends GoogleMapView = GoogleMapView> extends MapViewObserver<V> {
    viewWillSetGeoViewport?(newGeoViewport: GoogleMapViewport, oldGeoViewport: GoogleMapViewport, view: V): void;
    viewDidSetGeoViewport?(newGeoViewport: GoogleMapViewport, oldGeoViewport: GoogleMapViewport, view: V): void;
}

/** @public */
export declare class GoogleMapViewport implements GeoViewport, Equals {
    constructor(projection: google.maps.MapCanvasProjection | null, geoFrame: GeoBox, geoCenter: GeoPoint, zoom: number, heading: number, tilt: number);
    readonly projection: google.maps.MapCanvasProjection | null;
    readonly geoFrame: GeoBox;
    readonly geoCenter: GeoPoint;
    readonly zoom: number;
    readonly heading: number;
    readonly tilt: number;
    project(geoPoint: AnyGeoPoint): R2Point;
    project(lng: number, lat: number): R2Point;
    unproject(viewPoint: AnyR2Point): GeoPoint;
    unproject(x: number, y: number): GeoPoint;
    equals(that: unknown): boolean;
    static create(map: google.maps.Map, projection: google.maps.MapCanvasProjection | null | undefined): GoogleMapViewport;
}

/** @public */
export declare class GraphController<X = unknown, Y = unknown> extends Controller {
    readonly observerType?: Class<GraphControllerObserver<X, Y>>;
    readonly graph: TraitViewRef<this, GraphTrait<X, Y>, GraphView<X, Y>>;
    static readonly graph: MemberFastenerClass<GraphController, "graph">;
    readonly plots: TraitViewControllerSet<this, PlotTrait<X, Y>, PlotView<X, Y>, PlotController<X, Y>>;
    static readonly plots: MemberFastenerClass<GraphController, "plots">;
}

/** @public */
export declare interface GraphControllerObserver<X = unknown, Y = unknown, C extends GraphController<X, Y> = GraphController<X, Y>> extends ControllerObserver<C> {
    controllerWillAttachGraphTrait?(graphTrait: GraphTrait<X, Y> | null, controller: C): void;
    controllerDidDetachGraphTrait?(graphTrait: GraphTrait<X, Y>, controller: C): void;
    controllerWillAttachGraphView?(graphView: GraphView<X, Y>, controller: C): void;
    controllerDidDetachGraphView?(graphView: GraphView<X, Y>, controller: C): void;
    controllerWillAttachPlot?(plotController: PlotController<X, Y>, controller: C): void;
    controllerDidDetachPlot?(plotController: PlotController<X, Y>, controller: C): void;
    controllerWillAttachPlotTrait?(plotTrait: PlotTrait<X, Y>, plotController: PlotController<X, Y>, controller: C): void;
    controllerDidDetachPlotTrait?(plotTrait: PlotTrait<X, Y>, plotController: PlotController<X, Y>, controller: C): void;
    controllerWillAttachPlotView?(plotView: PlotView<X, Y>, plotController: PlotController<X, Y>, controller: C): void;
    controllerDidDetachPlotView?(plotView: PlotView<X, Y>, plotController: PlotController<X, Y>, controller: C): void;
    controllerWillAttachDataSetTrait?(dataSetTrait: DataSetTrait<X, Y>, plotController: PlotController<X, Y>, controller: C): void;
    controllerDidDetachDataSetTrait?(dataSetTrait: DataSetTrait<X, Y>, plotController: PlotController<X, Y>, controller: C): void;
    controllerWillAttachDataPoint?(dataPointController: DataPointController<X, Y>, plotController: PlotController<X, Y>, controller: C): void;
    controllerDidDetachDataPoint?(dataPointController: DataPointController<X, Y>, plotController: PlotController<X, Y>, controller: C): void;
    controllerWillAttachDataPointTrait?(dataPointTrait: DataPointTrait<X, Y>, dataPointController: DataPointController<X, Y>, plotController: PlotController<X, Y>, controller: C): void;
    controllerDidDetachDataPointTrait?(dataPointTrait: DataPointTrait<X, Y>, dataPointController: DataPointController<X, Y>, plotController: PlotController<X, Y>, controller: C): void;
    controllerWillAttachDataPointView?(dataPointView: DataPointView<X, Y>, dataPointController: DataPointController<X, Y>, plotController: PlotController<X, Y>, controller: C): void;
    controllerDidDetachDataPointView?(dataPointView: DataPointView<X, Y>, dataPointController: DataPointController<X, Y>, plotController: PlotController<X, Y>, controller: C): void;
    controllerWillAttachDataPointLabelView?(labelView: GraphicsView, dataPointController: DataPointController<X, Y>, plotController: PlotController<X, Y>, controller: C): void;
    controllerDidDetachDataPointLabelView?(labelView: GraphicsView, dataPointController: DataPointController<X, Y>, plotController: PlotController<X, Y>, controller: C): void;
}

/** @public */
export declare interface GraphControllerPlotExt<X = unknown, Y = unknown> {
    attachPlotTrait(plotTrait: PlotTrait<X, Y>, plotController: PlotController<X, Y>): void;
    detachPlotTrait(plotTrait: PlotTrait<X, Y>, plotController: PlotController<X, Y>): void;
    attachPlotView(plotView: PlotView<X, Y>, plotController: PlotController<X, Y>): void;
    detachPlotView(plotView: PlotView<X, Y>, plotController: PlotController<X, Y>): void;
    attachDataSetTrait(dataSetTrait: DataSetTrait<X, Y>, plotController: PlotController<X, Y>): void;
    detachDataSetTrait(dataSetTrait: DataSetTrait<X, Y>, plotController: PlotController<X, Y>): void;
    attachDataPoint(dataPointController: DataPointController<X, Y>, plotController: PlotController<X, Y>): void;
    detachDataPoint(dataPointController: DataPointController<X, Y>, plotController: PlotController<X, Y>): void;
    attachDataPointTrait(dataPointTrait: DataPointTrait<X, Y>, dataPointController: DataPointController<X, Y>, plotController: PlotController<X, Y>): void;
    detachDataPointTrait(dataPointTrait: DataPointTrait<X, Y>, dataPointController: DataPointController<X, Y>, plotController: PlotController<X, Y>): void;
    attachDataPointView(dataPointView: DataPointView<X, Y>, dataPointController: DataPointController<X, Y>, plotController: PlotController<X, Y>): void;
    detachDataPointView(dataPointView: DataPointView<X, Y>, dataPointController: DataPointController<X, Y>, plotController: PlotController<X, Y>): void;
    attachDataPointLabelView(dataPointLabelView: GraphicsView, dataPointController: DataPointController<X, Y>, plotController: PlotController<X, Y>): void;
    detachDataPointLabelView(dataPointLabelView: GraphicsView, dataPointController: DataPointController<X, Y>, plotController: PlotController<X, Y>): void;
}

/** @public */
export declare interface Graphics {
    render(renderer: GraphicsRenderer, frame: R2Box): void;
}

/** @public */
export declare interface GraphicsContext {
}

/** @public */
export declare class GraphicsIconView extends GraphicsView implements IconView {
    readonly xAlign: Animator<this, number>;
    readonly yAlign: Animator<this, number>;
    readonly iconWidth: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly iconHeight: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly iconColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly graphics: ThemeAnimator<this, Graphics | null>;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected renderIcon(renderer: PaintingRenderer, frame: R2Box): void;
    readonly viewBounds: R2Box;
    protected hitTest(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestIcon(x: number, y: number, renderer: CanvasRenderer, frame: R2Box): GraphicsView | null;
    init(init: GraphicsIconViewInit): void;
}

/** @public */
export declare interface GraphicsIconViewInit extends GraphicsViewInit, IconViewInit {
}

/** @public */
export declare abstract class GraphicsRenderer {
}

/** @public */
export declare type GraphicsRendererType = "canvas" | "webgl";

/** @public */
export declare class GraphicsView extends View {
    constructor();
    readonly observerType?: Class<GraphicsViewObserver>;
    readonly contextType?: Class<GraphicsViewContext>;
    readonly renderer: GraphicsRenderer | null;
    protected needsProcess(processFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    protected renderViewOutline(viewBox: R2Box, context: CanvasContext, outlineColor: Color, outlineWidth: number): void;
    readonly spriteProvider: Provider<this, SpriteService>;
    /** @internal */
    readonly ownViewFrame: R2Box | null;
    /**
     * The parent-specified view-coordinate bounding box in which this view
     * should layout and render graphics.
     */
    get viewFrame(): R2Box;
    /**
     * Sets the view-coordinate bounding box in which this view should layout
     * and render graphics. Should only be invoked by the view's parent view.
     */
    setViewFrame(viewFrame: R2Box | null): void;
    protected deriveViewFrame(): R2Box;
    cullViewFrame(viewFrame?: R2Box): void;
    /**
     * The self-defined view-coordinate bounding box surrounding all graphics
     * this view could possibly render. Views with view bounds that don't
     * overlap their view frames may be culled from rendering and hit testing.
     */
    readonly viewBounds: R2Box;
    get ownViewBounds(): R2Box | null;
    deriveViewBounds(): R2Box;
    /**
     * The self-defined view-coordinate bounding box surrounding all hit regions
     * in this view.
     */
    get hitBounds(): R2Box;
    deriveHitBounds(): R2Box;
    cascadeHitTest(x: number, y: number, baseViewContext: ViewContext): GraphicsView | null;
    protected hitTest(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestChildren(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestChild(child: GraphicsView, x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    get parentTransform(): Transform;
    get clientBounds(): R2Box;
    get popoverFrame(): R2Box;
    /** @internal */
    readonly eventHandlers: {
        [type: string]: ViewEventHandler[] | undefined;
    } | null;
    on<K extends keyof GraphicsViewEventMap>(type: K, listener: (this: this, event: GraphicsViewEventMap[K]) => unknown, options?: AddEventListenerOptions | boolean): this;
    on(type: string, listener: EventListenerOrEventListenerObject, options?: AddEventListenerOptions | boolean): this;
    off<K extends keyof GraphicsViewEventMap>(type: K, listener: (this: View, event: GraphicsViewEventMap[K]) => unknown, options?: EventListenerOptions | boolean): this;
    off(type: string, listener: EventListenerOrEventListenerObject, options?: EventListenerOptions | boolean): this;
    /** @internal */
    handleEvent(event: ViewEvent): void;
    /**
     * Invokes event handlers registered with this `View` before propagating the
     * `event` up the view hierarchy. Returns a `View`, without invoking any
     * registered event handlers, on which `dispatchEvent` should be called to
     * continue event propagation.
     * @internal
     */
    bubbleEvent(event: ViewEvent): View | null;
    dispatchEvent(event: ViewEvent): boolean;
    /** @internal */
    readonly hoverSet: {
        [id: string]: null | undefined;
    } | null;
    isHovering(): boolean;
    /** @internal */
    protected onMouseOver(event: ViewMouseEvent): void;
    /** @internal */
    protected onMouseOut(event: ViewMouseEvent): void;
    /** @internal */
    protected onPointerOver(event: ViewPointerEvent): void;
    /** @internal */
    protected onPointerOut(event: ViewPointerEvent): void;
    init(init: GraphicsViewInit): void;
    static readonly UncullFlags: ViewFlags;
    static readonly UnhideFlags: ViewFlags;
    static readonly InsertChildFlags: ViewFlags;
    static readonly RemoveChildFlags: ViewFlags;
}

/** @public */
export declare interface GraphicsViewContext extends ViewContext {
    readonly renderer: GraphicsRenderer | null;
}

/** @public */
export declare interface GraphicsViewEventMap {
    "auxclick": MouseEvent;
    "click": MouseEvent;
    "contextmenu": MouseEvent;
    "dblclick": MouseEvent;
    "mousedown": MouseEvent;
    "mouseenter": MouseEvent;
    "mouseleave": MouseEvent;
    "mousemove": MouseEvent;
    "mouseout": MouseEvent;
    "mouseover": MouseEvent;
    "mouseup": MouseEvent;
    "pointercancel": PointerEvent;
    "pointerdown": PointerEvent;
    "pointerenter": PointerEvent;
    "pointerleave": PointerEvent;
    "pointermove": PointerEvent;
    "pointerout": PointerEvent;
    "pointerover": PointerEvent;
    "pointerup": PointerEvent;
    "touchcancel": TouchEvent;
    "touchend": TouchEvent;
    "touchmove": TouchEvent;
    "touchstart": TouchEvent;
    "wheel": WheelEvent;
}

/** @public */
export declare interface GraphicsViewInit extends ViewInit {
    hidden?: boolean;
}

/** @public */
export declare interface GraphicsViewObserver<V extends GraphicsView = GraphicsView> extends ViewObserver<V> {
}

/** @public */
export declare class GraphTrait<X = unknown, Y = unknown> extends Trait {
    readonly observerType?: Class<GraphTraitObserver<X, Y>>;
    readonly plots: TraitSet<this, PlotTrait<X, Y>>;
    static readonly plots: MemberFastenerClass<GraphTrait, "plots">;
    /** @internal */
    protected startConsumingPlots(): void;
    /** @internal */
    protected stopConsumingPlots(): void;
    protected onStartConsuming(): void;
    protected onStopConsuming(): void;
}

/** @public */
export declare interface GraphTraitObserver<X = unknown, Y = unknown, R extends GraphTrait<X, Y> = GraphTrait<X, Y>> extends TraitObserver<R> {
    traitWillAttachPlot?(plotTrait: PlotTrait<X, Y>, trait: R): void;
    traitDidDetachPlot?(plotTrait: PlotTrait<X, Y>, trait: R): void;
}

/** @public */
export declare class GraphView<X = unknown, Y = unknown> extends ScaledView<X, Y> {
    readonly observerType?: Class<GraphViewObserver<X, Y>>;
    readonly font: ThemeAnimator<this, Font | null, AnyFont | null>;
    readonly textColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    addPlot(plot: AnyPlotView<X, Y>, key?: string): void;
    protected willRender(viewContext: ViewContextType<this>): void;
    protected didRender(viewContext: ViewContextType<this>): void;
    protected clipGraph(context: CanvasContext, frame: R2Box): void;
    protected hitTest(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    init(init: GraphViewInit<X, Y>): void;
}

/** @public */
export declare interface GraphViewInit<X = unknown, Y = unknown> extends ScaledViewInit<X, Y> {
    plots?: AnyPlotView<X, Y>[];
    font?: AnyFont;
    textColor?: AnyColor;
}

/** @public */
export declare interface GraphViewObserver<X = unknown, Y = unknown, V extends GraphView<X, Y> = GraphView<X, Y>> extends ScaledViewObserver<X, Y, V> {
}

/** @public */
export declare class HeaderController extends Controller {
    readonly observerType?: Class<HeaderControllerObserver>;
    readonly header: TraitViewRef<this, HeaderTrait, HeaderView>;
    static readonly header: MemberFastenerClass<HeaderController, "header">;
    getColTrait(key: string): ColTrait | null;
    getColTrait<R extends ColTrait>(key: string, colTraitClass: TraitClass<R>): R | null;
    getOrCreateColTrait(key: string): ColTrait;
    getOrCreateColTrait<R extends ColTrait>(key: string, colTraitConstructor: TraitConstructor<R>): R;
    setColTrait(key: string, colTrait: ColTrait): void;
    getColView(key: string): ColView | null;
    getColView<V extends ColView>(key: string, colViewClass: Class<V>): V | null;
    getOrCreateColView(key: string): ColView;
    getOrCreateColView<V extends ColView>(key: string, colViewClass: HtmlViewClass<V>): V;
    setColView(key: string, colView: ColView): void;
    readonly cols: TraitViewControllerSet<this, ColTrait, ColView, ColController>;
    static readonly cols: MemberFastenerClass<HeaderController, "cols">;
}

/** @public */
export declare type HeaderControllerColExt = {
    attachColTrait(colTrait: ColTrait, colController: ColController): void;
    detachColTrait(colTrait: ColTrait, colController: ColController): void;
    attachColView(colView: ColView, colController: ColController): void;
    detachColView(colView: ColView, colController: ColController): void;
    attachColLabelView(colLabelView: HtmlView, colController: ColController): void;
    detachColLabelView(colLabelView: HtmlView, colController: ColController): void;
};

/** @public */
export declare interface HeaderControllerObserver<C extends HeaderController = HeaderController> extends ControllerObserver<C> {
    controllerWillAttachHeaderTrait?(headerTrait: HeaderTrait, controller: C): void;
    controllerDidDetachHeaderTrait?(headerTrait: HeaderTrait, controller: C): void;
    controllerWillAttachHeaderView?(headerView: HeaderView, controller: C): void;
    controllerDidDetachHeaderView?(headerView: HeaderView, controller: C): void;
    controllerWillAttachCol?(colController: ColController, controller: C): void;
    controllerDidDetachCol?(colController: ColController, controller: C): void;
    controllerWillAttachColTrait?(colTrait: ColTrait, colController: ColController, controller: C): void;
    controllerDidDetachColTrait?(colTrait: ColTrait, colController: ColController, controller: C): void;
    controllerWillAttachColView?(colView: ColView, colController: ColController, controller: C): void;
    controllerDidDetachColView?(colView: ColView, colController: ColController, controller: C): void;
    controllerWillSetColLayout?(newColLayout: ColLayout | null, oldColLayout: ColLayout | null, colController: ColController, controller: C): void;
    controllerDidSetColLayout?(newColLayout: ColLayout | null, oldColLayout: ColLayout | null, colController: ColController, controller: C): void;
    controllerWillAttachColLabelView?(colLabelView: HtmlView, colController: ColController, controller: C): void;
    controllerDidDetachColLabelView?(colLabelView: HtmlView, colController: ColController, controller: C): void;
}

/** @public */
export declare class HeaderTrait extends Trait {
    readonly observerType?: Class<HeaderTraitObserver>;
    getCol(key: string): ColTrait | null;
    getCol<R extends ColTrait>(key: string, colTraitClass: TraitClass<R>): R | null;
    getOrCreateCol(key: string): ColTrait;
    getOrCreateCol<R extends ColTrait>(key: string, colTraitConstructor: TraitConstructor<R>): R;
    setCol(key: string, colTrait: ColTrait): void;
    readonly cols: TraitSet<this, ColTrait>;
    static readonly cols: MemberFastenerClass<HeaderTrait, "cols">;
    /** @internal */
    protected startConsumingCols(): void;
    /** @internal */
    protected stopConsumingCols(): void;
    protected onStartConsuming(): void;
    protected onStopConsuming(): void;
}

/** @public */
export declare interface HeaderTraitObserver<T extends HeaderTrait = HeaderTrait> extends TraitObserver<T> {
    traitWillAttachCol?(colTrait: ColTrait, targetTrait: Trait | null, trait: T): void;
    traitDidDetachCol?(colTrait: ColTrait, trait: T): void;
}

/** @public */
export declare class HeaderView extends HtmlView {
    constructor(node: HTMLElement);
    protected initHeader(): void;
    readonly observerType?: Class<HeaderViewObserver>;
    readonly layout: Property<this, TableLayout | null, AnyTableLayout | null>;
    readonly depth: Property<this, number>;
    readonly rowSpacing: ThemeConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly rowHeight: ThemeConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly stretch: ExpansionThemeAnimator<this, Expansion | null, AnyExpansion | null>;
    getCol(key: string): ColView | null;
    getCol<V extends ColView>(key: string, colViewClass: Class<V>): V | null;
    getOrCreateCol(key: string): ColView;
    getOrCreateCol<V extends ColView>(key: string, colViewClass: HtmlViewClass<V>): V;
    setCol(key: string, colView: ColView): void;
    readonly cols: ViewSet<this, ColView>;
    static readonly cols: MemberFastenerClass<HeaderView, "cols">;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected layoutHeader(): void;
    protected displayChildren(displayFlags: ViewFlags, viewContext: ViewContextType<this>, displayChild: (this: this, child: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    protected layoutChildViews(displayFlags: ViewFlags, viewContext: ViewContextType<this>, displayChild: (this: this, child: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
}

/** @public */
export declare interface HeaderViewObserver<V extends HeaderView = HeaderView> extends HtmlViewObserver<V> {
    viewWillAttachCol?(colView: ColView, targetView: View | null, view: V): void;
    viewDidDetachCol?(colView: ColView, view: V): void;
}

/** @public */
export declare type Height = Length | string | "auto";

/** @internal */
export declare class HexColorParser extends Parser<RgbColor> {
    private readonly value;
    private readonly step;
    constructor(value?: number, step?: number);
    feed(input: Input): Parser<RgbColor>;
    static parse(input: Input, value?: number, step?: number): Parser<RgbColor>;
}

/** @public */
export declare interface HistoryProvider<C extends Controller, S extends HistoryService<C> | null | undefined = HistoryService<C>> extends Provider<C, S> {
    get historyState(): HistoryState;
    pushHistory(deltaState: HistoryStateInit): void;
    replaceHistory(deltaState: HistoryStateInit): void;
    createService(): S;
}

/** @public */
export declare const HistoryProvider: ProviderClass<HistoryProvider<any, any>>;

/** @public */
export declare class HistoryService<C extends Controller = Controller> extends Service<C> {
    constructor();
    readonly observerType?: Class<HistoryServiceObserver<C>>;
    /** @internal */
    readonly historyState: HistoryState;
    get historyUri(): Uri;
    pushHistory(deltaState: HistoryStateInit): void;
    protected willPushHistory(newState: HistoryState, oldState: HistoryState): void;
    protected onPushHistory(newState: HistoryState, oldState: HistoryState): void;
    protected didPushHistory(newState: HistoryState, oldState: HistoryState): void;
    replaceHistory(deltaState: HistoryStateInit): void;
    protected willReplaceHistory(newState: HistoryState, oldState: HistoryState): void;
    protected onReplaceHistory(newState: HistoryState, oldState: HistoryState): void;
    protected didReplaceHistory(newState: HistoryState, oldState: HistoryState): void;
    /** @internal */
    popHistory(event: PopStateEvent): void;
    protected willPopHistory(newState: HistoryState, oldState: HistoryState): void;
    protected onPopHistory(newState: HistoryState, oldState: HistoryState): void;
    protected didPopHistory(newState: HistoryState, oldState: HistoryState): void;
    protected onAttach(): void;
    protected onDetach(): void;
    protected attachEvents(): void;
    protected detachEvents(): void;
    static global<C extends Controller>(): HistoryService<C>;
}

/** @public */
export declare interface HistoryServiceObserver<C extends Controller = Controller, S extends HistoryService<C> = HistoryService<C>> extends ServiceObserver<C, S> {
    serviceWillPushHistory?(newState: HistoryState, oldState: HistoryState, service: S): void;
    serviceDidPushHistory?(newState: HistoryState, oldState: HistoryState, service: S): void;
    serviceWillReplaceHistory?(newState: HistoryState, oldState: HistoryState, service: S): void;
    serviceDidReplaceHistory?(newState: HistoryState, oldState: HistoryState, service: S): void;
    serviceWillPopHistory?(newState: HistoryState, oldState: HistoryState, service: S): void | boolean;
    serviceDidPopHistory?(newState: HistoryState, oldState: HistoryState, service: S): void;
}

/** @public */
export declare interface HistoryState {
    readonly fragment: string | undefined;
    readonly permanent: {
        readonly [key: string]: string | undefined;
    };
    readonly ephemeral: {
        readonly [key: string]: string | undefined;
    };
}

/** @public */
export declare const HistoryState: {
    /** @internal */
    empty(): HistoryState;
    /** @internal */
    current(): MutableHistoryState;
    /** @internal */
    updated(delta: HistoryStateInit, state?: MutableHistoryState | undefined): MutableHistoryState;
    /** @internal */
    cloned(state: HistoryState): MutableHistoryState;
    /** @internal */
    fromUri(uri: AnyUri): HistoryState;
    /** @internal */
    fromUriFragment(fragment: AnyUriFragment): HistoryState;
    /** @internal */
    toUri(state: HistoryState): Uri;
};

/** @public */
export declare interface HistoryStateInit {
    fragment?: string;
    permanent?: {
        [key: string]: string | undefined;
    };
    ephemeral?: {
        [key: string]: string | undefined;
    };
}

/** @public */
export declare class HslColor extends Color {
    constructor(h: number, s: number, l: number, a?: number);
    isDefined(): boolean;
    readonly h: number;
    readonly s: number;
    readonly l: number;
    readonly a: number;
    alpha(): number;
    alpha(a: number): HslColor;
    get lightness(): number;
    plus(that: AnyColor): HslColor;
    times(scalar: number): HslColor;
    combine(that: AnyColor, scalar?: number): HslColor;
    lighter(k?: number): HslColor;
    darker(k?: number): HslColor;
    private static toRgb;
    rgb(): RgbColor;
    hsl(): HslColor;
    interpolateTo(that: HslColor): Interpolator<HslColor>;
    interpolateTo(that: Color): Interpolator<Color>;
    interpolateTo(that: unknown): Interpolator<Color> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toHexString(): string;
    toRgbString(): string;
    toHslString(): string;
    /** @internal */
    readonly stringValue: string | undefined;
    toString(): string;
    static transparent(): HslColor;
    static black(alpha?: number): HslColor;
    static white(alpha?: number): HslColor;
    static fromInit(value: HslColorInit): HslColor;
    static fromAny(value: AnyHslColor): HslColor;
    static fromValue(value: Value): HslColor | null;
    static parse(str: string): HslColor;
    /** @internal */
    static isInit(value: unknown): value is HslColorInit;
    /** @internal */
    static isAny(value: unknown): value is AnyHslColor;
}

/** @public */
export declare interface HslColorInit {
    readonly h: AnyAngle;
    readonly s: number;
    readonly l: number;
    readonly a?: number;
}

/** @internal */
export declare const HslColorInterpolator: {
    (c0: HslColor, c1: HslColor): Interpolator<HslColor>;
    /** @internal */
    prototype: Interpolator<HslColor>;
};

/** @internal */
export declare class HslColorParser extends Parser<HslColor> {
    private readonly hParser;
    private readonly sParser;
    private readonly lParser;
    private readonly aParser;
    private readonly step;
    constructor(hParser?: Parser<Angle>, sParser?: Parser<ColorChannel>, lParser?: Parser<ColorChannel>, aParser?: Parser<ColorChannel>, step?: number);
    feed(input: Input): Parser<HslColor>;
    static parse(input: Input, hParser?: Parser<Angle>, sParser?: Parser<ColorChannel>, lParser?: Parser<ColorChannel>, aParser?: Parser<ColorChannel>, step?: number): Parser<HslColor>;
    /** @internal */
    static parseRest(input: Input): Parser<HslColor>;
}

/** @public */
export declare class HtmlIconView extends HtmlView implements IconView {
    constructor(node: HTMLElement);
    protected initIcon(): void;
    protected createSvgView(): SvgIconView | null;
    get svgView(): SvgIconView | null;
    readonly xAlign: Animator<this, number>;
    readonly yAlign: Animator<this, number>;
    readonly iconWidth: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly iconHeight: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly iconColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly graphics: ThemeAnimator<this, Graphics | null>;
    protected onInsertChild(child: View, target: View | null): void;
    protected onInsertSvg(svgView: SvgIconView): void;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    protected onResize(viewContext: ViewContextType<this>): void;
    protected needsDisplay(displayFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected layoutIcon(): void;
    init(init: HtmlIconViewInit): void;
}

/** @public */
export declare interface HtmlIconViewInit extends HtmlViewInit, IconViewInit {
}

/** @public */
export declare class HtmlView extends ElementView {
    constructor(node: HTMLElement);
    readonly observerType?: Class<HtmlViewObserver>;
    readonly node: HTMLElement;
    setChild<V extends View>(key: string, newChild: V): View | null;
    setChild<F extends ViewCreator<F>>(key: string, factory: F): View | null;
    setChild(key: string, newChild: AnyView | Node | keyof HtmlViewTagMap | null): View | null;
    appendChild<V extends View>(child: V, key?: string): V;
    appendChild<F extends ViewCreator<F>>(factory: F, key?: string): InstanceType<F>;
    appendChild<K extends keyof HtmlViewTagMap>(tag: K, key?: string): HtmlViewTagMap[K];
    appendChild(child: AnyView | Node | keyof HtmlViewTagMap, key?: string): View;
    prependChild<V extends View>(child: V, key?: string): V;
    prependChild<F extends ViewCreator<F>>(factory: F, key?: string): InstanceType<F>;
    prependChild<K extends keyof HtmlViewTagMap>(tag: K, key?: string): HtmlViewTagMap[K];
    prependChild(child: AnyView | Node | keyof HtmlViewTagMap, key?: string): View;
    insertChild<V extends View>(child: V, target: View | Node | null, key?: string): V;
    insertChild<F extends ViewCreator<F>>(factory: F, target: View | Node | null, key?: string): InstanceType<F>;
    insertChild<K extends keyof HtmlViewTagMap>(tag: K, target: View | Node | null, key?: string): HtmlViewTagMap[K];
    insertChild(child: AnyView | Node | keyof HtmlViewTagMap, target: View | Node | null, key?: string): View;
    replaceChild<V extends View>(newChild: View, oldChild: V): V;
    replaceChild<V extends View>(newChild: AnyView | Node | keyof HtmlViewTagMap, oldChild: V): V;
    readonly autocomplete: AttributeAnimator<this, string>;
    readonly checked: AttributeAnimator<this, boolean, boolean | string>;
    readonly colspan: AttributeAnimator<this, number, number | string>;
    readonly disabled: AttributeAnimator<this, boolean, boolean | string>;
    readonly placeholder: AttributeAnimator<this, string>;
    readonly rowspan: AttributeAnimator<this, number, number | string>;
    readonly selected: AttributeAnimator<this, boolean, boolean | string>;
    readonly title: AttributeAnimator<this, string>;
    readonly type: AttributeAnimator<this, string>;
    readonly value: AttributeAnimator<this, string>;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    /** @internal */
    applyRootTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    /** @internal */
    static isPositioned(element: HTMLElement): boolean;
    isPositioned(): boolean;
    /** @internal */
    static parentTransform(element: HTMLElement): Transform;
    /** @internal */
    static pageTransform(element: HTMLElement): Transform;
    get parentTransform(): Transform;
    get pageTransform(): Transform;
    on<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, event: HTMLElementEventMap[K]) => unknown, options?: AddEventListenerOptions | boolean): this;
    on(type: string, listener: EventListenerOrEventListenerObject, options?: AddEventListenerOptions | boolean): this;
    off<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, event: HTMLElementEventMap[K]) => unknown, options?: EventListenerOptions | boolean): this;
    off(type: string, listener: EventListenerOrEventListenerObject, options?: EventListenerOptions | boolean): this;
    /** @internal */
    protected initAttributes(init: HtmlViewAttributesInit): void;
    /** @internal */
    protected initStyle(init: HtmlViewStyleInit): void;
    init(init: HtmlViewInit): void;
    static readonly tag: string;
    static create<S extends abstract new (...args: any) => InstanceType<S>>(this: S): InstanceType<S>;
    static create(): HtmlView;
    static fromTag(tag: "style"): StyleView;
    static fromTag(tag: "svg"): SvgView;
    static fromTag<S extends abstract new (...args: any) => InstanceType<S>>(this: S, tag: string): InstanceType<S>;
    static fromTag(tag: string): HtmlView;
    static fromNode<S extends new (node: HTMLElement) => InstanceType<S>>(this: S, node: ViewNodeType<InstanceType<S>>): InstanceType<S>;
    static fromNode(node: HTMLElement): HtmlView;
    static fromAny<S extends abstract new (...args: any) => InstanceType<S>>(this: S, value: AnyHtmlView<InstanceType<S>>): InstanceType<S>;
    static fromAny(value: AnyHtmlView | string): HtmlView;
    static forTag<S extends abstract new (...args: any) => InstanceType<S>>(this: S, tag: string): HtmlViewFactory<InstanceType<S>>;
    static forTag(tag: string): HtmlViewFactory;
}

/** @public */
export declare interface HtmlView extends StyleMap {
    applyTheme(theme: ThemeMatrix, mood: MoodVector, timing?: AnyTiming | boolean): void;
    requireUpdate(updateFlags: ViewFlags, immediate?: boolean): void;
}

/** @public */
export declare interface HtmlViewAttributesInit {
    autocomplete?: MemberAnimatorInit<HtmlView, "autocomplete">;
    checked?: MemberAnimatorInit<HtmlView, "checked">;
    colspan?: MemberAnimatorInit<HtmlView, "colspan">;
    disabled?: MemberAnimatorInit<HtmlView, "disabled">;
    placeholder?: MemberAnimatorInit<HtmlView, "placeholder">;
    rowspan?: MemberAnimatorInit<HtmlView, "rowspan">;
    selected?: MemberAnimatorInit<HtmlView, "selected">;
    title?: MemberAnimatorInit<HtmlView, "title">;
    type?: MemberAnimatorInit<HtmlView, "type">;
    value?: MemberAnimatorInit<HtmlView, "value">;
}

/** @public */
export declare interface HtmlViewClass<V extends HtmlView = HtmlView, U = AnyHtmlView<V>> extends ElementViewClass<V, U>, HtmlViewFactory<V, U> {
    readonly tag: string;
}

/** @public */
export declare interface HtmlViewConstructor<V extends HtmlView = HtmlView, U = AnyHtmlView<V>> extends ElementViewConstructor<V, U>, HtmlViewClass<V, U> {
    readonly tag: string;
}

/** @public */
export declare interface HtmlViewFactory<V extends HtmlView = HtmlView, U = AnyHtmlView<V>> extends ElementViewFactory<V, U> {
}

/** @public */
export declare interface HtmlViewInit extends ElementViewInit {
    attributes?: HtmlViewAttributesInit;
    style?: HtmlViewStyleInit;
}

/** @public */
export declare interface HtmlViewObserver<V extends HtmlView = HtmlView> extends ElementViewObserver<V> {
}

/** @public */
export declare interface HtmlViewStyleInit extends StyleMapInit {
}

/** @internal */
export declare class HtmlViewTagFactory<V extends HtmlView> implements HtmlViewFactory<V> {
    constructor(factory: HtmlViewFactory<V>, tag: string);
    /** @internal */
    readonly factory: HtmlViewFactory<V>;
    readonly tag: string;
    create(): V;
    fromTag(tag: string): V;
    fromNode(node: ViewNodeType<V>): V;
    fromInit(init: InitType<V>): V;
    fromAny(value: AnyHtmlView<V>): V;
}

/** @public */
export declare interface HtmlViewTagMap {
    a: HtmlView;
    abbr: HtmlView;
    address: HtmlView;
    area: HtmlView;
    article: HtmlView;
    aside: HtmlView;
    audio: HtmlView;
    b: HtmlView;
    base: HtmlView;
    bdi: HtmlView;
    bdo: HtmlView;
    blockquote: HtmlView;
    body: HtmlView;
    br: HtmlView;
    button: HtmlView;
    canvas: HtmlView;
    caption: HtmlView;
    cite: HtmlView;
    code: HtmlView;
    col: HtmlView;
    colgroup: HtmlView;
    data: HtmlView;
    datalist: HtmlView;
    dd: HtmlView;
    del: HtmlView;
    details: HtmlView;
    dfn: HtmlView;
    dialog: HtmlView;
    div: HtmlView;
    dl: HtmlView;
    dt: HtmlView;
    em: HtmlView;
    embed: HtmlView;
    fieldset: HtmlView;
    figcaption: HtmlView;
    figure: HtmlView;
    footer: HtmlView;
    form: HtmlView;
    h1: HtmlView;
    h2: HtmlView;
    h3: HtmlView;
    h4: HtmlView;
    h5: HtmlView;
    h6: HtmlView;
    head: HtmlView;
    header: HtmlView;
    hr: HtmlView;
    html: HtmlView;
    i: HtmlView;
    iframe: HtmlView;
    img: HtmlView;
    input: HtmlView;
    ins: HtmlView;
    kbd: HtmlView;
    label: HtmlView;
    legend: HtmlView;
    li: HtmlView;
    link: HtmlView;
    main: HtmlView;
    map: HtmlView;
    mark: HtmlView;
    meta: HtmlView;
    meter: HtmlView;
    nav: HtmlView;
    noscript: HtmlView;
    object: HtmlView;
    ol: HtmlView;
    optgroup: HtmlView;
    option: HtmlView;
    output: HtmlView;
    p: HtmlView;
    param: HtmlView;
    picture: HtmlView;
    pre: HtmlView;
    progress: HtmlView;
    q: HtmlView;
    rb: HtmlView;
    rp: HtmlView;
    rt: HtmlView;
    rtc: HtmlView;
    ruby: HtmlView;
    s: HtmlView;
    samp: HtmlView;
    script: HtmlView;
    section: HtmlView;
    select: HtmlView;
    small: HtmlView;
    slot: HtmlView;
    source: HtmlView;
    span: HtmlView;
    strong: HtmlView;
    style: StyleView;
    sub: HtmlView;
    summary: HtmlView;
    sup: HtmlView;
    table: HtmlView;
    tbody: HtmlView;
    td: HtmlView;
    template: HtmlView;
    textarea: HtmlView;
    tfoot: HtmlView;
    th: HtmlView;
    thead: HtmlView;
    time: HtmlView;
    title: HtmlView;
    tr: HtmlView;
    track: HtmlView;
    u: HtmlView;
    ul: HtmlView;
    var: HtmlView;
    video: HtmlView;
    wbr: HtmlView;
}

/** @public */
export declare abstract class Icon implements Graphics {
    abstract readonly moodModifier: MoodMatrix | null;
    abstract withMoodModifier(moodModifier: MoodMatrix | null): Icon;
    abstract modifyMood(feel: Feel, updates: MoodVectorUpdates<Feel>): Icon;
    abstract isThemed(): boolean;
    abstract withTheme(theme: ThemeMatrix, mood: MoodVector): Icon;
    abstract render(renderer: GraphicsRenderer, frame: R2Box): void;
    abstract paint(context: PaintingContext, frame: R2Box): void;
    abstract draw(context: DrawingContext, frame: R2Box): void;
}

/** @public */
export declare class IconButton extends ButtonMembrane implements IconView {
    constructor(node: HTMLElement);
    readonly observerType?: Class<HtmlViewObserver & ButtonObserver>;
    protected initButton(): void;
    protected initTheme(): void;
    readonly xAlign: Animator<this, number>;
    readonly yAlign: Animator<this, number>;
    readonly iconWidth: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly iconHeight: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly iconColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly graphics: ThemeAnimator<this, Graphics | null>;
    /** @internal */
    static IconRef: ViewRefFactory<ViewRef<any, SvgIconView> & {
        iconIndex: number;
    }>;
    /** @internal */
    iconCount: number;
    icon: ViewRef<this, SvgIconView> | null;
    pushIcon(icon: Graphics, timing?: AnyTiming | boolean): void;
    popIcon(timing?: AnyTiming | boolean): SvgIconView | null;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    protected onResize(viewContext: ViewContextType<this>): void;
    protected needsDisplay(displayFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected layoutIcon(): void;
    protected onMount(): void;
    protected onUnmount(): void;
    get hovers(): boolean;
    setHovers(hovers: boolean): void;
    readonly gesture: PositionGesture<this, HtmlView>;
    static readonly gesture: MemberFastenerClass<IconButton, "gesture">;
    protected onClick(event: MouseEvent): void;
    init(init: IconButtonInit): void;
}

/** @public */
export declare interface IconButtonInit extends ButtonMembraneInit, IconViewInit {
}

/** @public */
export declare class IconCellController extends CellController {
    readonly observerType?: Class<IconCellControllerObserver>;
    protected setIcon(icon: Graphics | null): void;
    readonly cell: TraitViewRef<this, IconCellTrait, IconCellView>;
    static readonly cell: MemberFastenerClass<IconCellController, "cell">;
}

/** @public */
export declare interface IconCellControllerObserver<C extends IconCellController = IconCellController> extends CellControllerObserver<C> {
    controllerWillAttachCellTrait?(cellTrait: IconCellTrait, controller: C): void;
    controllerDidDetachCellTrait?(cellTrait: IconCellTrait, controller: C): void;
    controllerWillAttachCellView?(cellView: IconCellView, controller: C): void;
    controllerDidDetachCellView?(cellView: IconCellView, controller: C): void;
    controllerWillSetCellIcon?(newCellIcon: Graphics | null, oldCellIcon: Graphics | null, controller: C): void;
    controllerDidSetCellIcon?(newCellIcon: Graphics | null, oldCellIcon: Graphics | null, controller: C): void;
}

/** @public */
export declare class IconCellTrait extends CellTrait {
    readonly observerType?: Class<IconCellTraitObserver>;
    readonly icon: Property<this, Graphics | null>;
}

/** @public */
export declare interface IconCellTraitObserver<T extends IconCellTrait = IconCellTrait> extends CellTraitObserver<T> {
    traitWillSetIcon?(newIcon: Graphics | null, oldIcon: Graphics | null, trait: T): void;
    traitDidSetIcon?(newIcon: Graphics | null, oldIcon: Graphics | null, trait: T): void;
}

/** @public */
export declare class IconCellView extends CellView {
    constructor(node: HTMLElement);
    protected initCell(): void;
    readonly observerType?: Class<IconCellViewObserver>;
    protected initSvg(): void;
    protected createSvgView(): SvgIconView | null;
    get svgView(): SvgIconView | null;
    readonly xAlign: Animator<this, number>;
    readonly yAlign: Animator<this, number>;
    readonly iconWidth: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly iconHeight: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly iconColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly graphics: ThemeAnimator<this, Graphics | null>;
    protected onInsertChild(child: View, target: View | null): void;
    protected onInsertSvg(svgView: SvgIconView): void;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    protected onResize(viewContext: ViewContextType<this>): void;
    protected needsDisplay(displayFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected layoutIcon(): void;
}

/** @public */
export declare interface IconCellViewObserver<V extends IconCellView = IconCellView> extends CellViewObserver<V> {
    viewWillSetGraphics?(newGraphics: Graphics | null, oldGraphics: Graphics | null, view: V): void;
    viewDidSetGraphics?(newGraphics: Graphics | null, oldGraphics: Graphics | null, view: V): void;
}

/** @internal */
export declare const IconGraphicsAnimator: ThemeAnimatorClass<ThemeAnimator<any, Graphics | null | undefined, Graphics | null | undefined>>;

/** @public */
export declare interface IconLayout {
    readonly iconWidth: Length;
    readonly iconHeight: Length;
    readonly xAlign: number | undefined;
    readonly yAlign: number | undefined;
}

/** @public */
export declare const IconLayout: {
    fromAny(value: AnyIconLayout): IconLayout;
    is(object: unknown): object is IconLayout;
};

/** @public */
export declare interface IconLayoutInit {
    iconWidth: AnyLength;
    iconHeight: AnyLength;
    xAlign?: number;
    yAlign?: number;
}

/** @public */
export declare interface IconView extends View {
    readonly xAlign: Animator<this, number>;
    readonly yAlign: Animator<this, number>;
    readonly iconWidth: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly iconHeight: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly iconColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly graphics: ThemeAnimator<this, Graphics | null>;
}

/** @public */
export declare const IconView: {
    is(object: unknown): object is IconView;
    init(view: IconView, init: IconViewInit): void;
};

/** @public */
export declare interface IconViewInit extends ViewInit {
    xAlign?: number;
    yAlign?: number;
    iconWidth?: AnyLength;
    iconHeight?: AnyLength;
    iconColor?: AnyColor;
    graphics?: Graphics;
}

/** @public */
export declare class InputTokenView extends TokenView {
    constructor(node: HTMLElement);
    readonly observerType?: Class<InputTokenViewObserver>;
    protected initToken(): void;
    protected initStylesheet(styleView: StyleView): void;
    /** @internal */
    static PlaceholderRule: StyleRuleFactory<StyleRule<any>>;
    protected initLabel(labelView: HtmlView): void;
    readonly stylesheet: ViewRef<this, StyleView>;
    static readonly stylesheet: MemberFastenerClass<InputTokenView, "stylesheet">;
    readonly label: ViewRef<this, HtmlView>;
    static readonly label: MemberFastenerClass<InputTokenView, "label">;
    /** @internal */
    get placeholderLook(): Look<Color>;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    protected onInputUpdate(event: InputEvent): void;
    protected didUpdateInput(inputView: HtmlView): void;
    protected onInputChange(event: Event): void;
    protected didChangeInput(inputView: HtmlView): void;
    protected onInputKey(event: KeyboardEvent): void;
    protected didAcceptInput(inputView: HtmlView): void;
    init(init: InputTokenViewInit): void;
}

/** @public */
export declare interface InputTokenViewInit extends TokenViewInit {
}

/** @public */
export declare interface InputTokenViewObserver<V extends InputTokenView = InputTokenView> extends TokenViewObserver<V> {
    tokenDidUpdateInput?(inputView: HtmlView, view: V): void;
    tokenDidChangeInput?(inputView: HtmlView, view: V): void;
    tokenDidAcceptInput?(inputView: HtmlView, view: V): void;
}

/** @public */
export declare class InterpolatedFeel extends Feel {
    combine<T>(look: Look<T, any>, combination: T | undefined, value: T, weight?: number): T;
}

/** @public */
export declare type JustifyContent = "baseline" | "center" | "end" | "first baseline" | "flex-end" | "flex-start" | "last baseline" | "left" | "right" | "safe center" | "space-around" | "space-between" | "space-evenly" | "start" | "stretch" | "unsafe center";

/** @public */
export declare interface LayoutProvider<V extends View, S extends LayoutService<V> | null | undefined = LayoutService<V>> extends Provider<V, S> {
    createService(): S;
}

/** @public */
export declare const LayoutProvider: ProviderClass<LayoutProvider<any, any>>;

/** @public */
export declare class LayoutService<V extends View = View> extends Service<V> implements ConstraintContext {
    constructor();
    readonly observerType?: Class<LayoutServiceObserver<V>>;
    readonly solver: ConstraintSolver;
    /** @internal */
    protected createSolver(): ConstraintSolver;
    /** @override */
    activateConstraint(constraint: Constraint): void;
    /** @override */
    deactivateConstraint(constraint: Constraint): void;
    /** @override */
    activateConstraintVariable(variable: ConstraintVariable): void;
    /** @override */
    deactivateConstraintVariable(variable: ConstraintVariable): void;
    /** @override */
    setConstraintVariable(variable: ConstraintVariable, value: number): void;
    static global<V extends View>(): LayoutService<V>;
}

/** @public */
export declare interface LayoutServiceObserver<V extends View = View, S extends LayoutService<V> = LayoutService<V>> extends ServiceObserver<V, S> {
}

/** @public */
export declare class LeafController extends Controller {
    readonly observerType?: Class<LeafControllerObserver>;
    readonly leaf: TraitViewRef<this, LeafTrait, LeafView>;
    static readonly leaf: MemberFastenerClass<LeafController, "leaf">;
    getCellTrait<F extends abstract new (...args: any) => CellTrait>(key: string, cellTraitClass: F): InstanceType<F> | null;
    getCellTrait(key: string): CellTrait | null;
    getOrCreateCellTrait<F extends TraitCreator<F, CellTrait>>(key: string, cellTraitClass: F): InstanceType<F>;
    setCellTrait(key: string, cellTrait: CellTrait): void;
    getCellView<F extends abstract new (...args: any) => CellView>(key: string, cellViewClass: F): InstanceType<F> | null;
    getCellView(key: string): CellView | null;
    getOrCreateCellView<F extends ViewCreator<F, CellView>>(key: string, cellViewClass: F): InstanceType<F>;
    setCellView(key: string, cellView: CellView): void;
    readonly cells: TraitViewControllerSet<this, CellTrait, CellView, CellController>;
    static readonly cells: MemberFastenerClass<LeafController, "cells">;
}

/** @public */
export declare interface LeafControllerCellExt {
    attachCellTrait(cellTrait: CellTrait, cellController: CellController): void;
    detachCellTrait(cellTrait: CellTrait, cellController: CellController): void;
    attachCellView(cellView: CellView, cellController: CellController): void;
    detachCellView(cellView: CellView, cellController: CellController): void;
    attachCellContentView(cellContentView: HtmlView, cellController: CellController): void;
    detachCellContentView(cellContentView: HtmlView, cellController: CellController): void;
}

/** @public */
export declare interface LeafControllerObserver<C extends LeafController = LeafController> extends ControllerObserver<C> {
    controllerWillAttachLeafTrait?(leafTrait: LeafTrait, controller: C): void;
    controllerDidDetachLeafTrait?(leafTrait: LeafTrait, controller: C): void;
    controllerWillAttachLeafView?(leafView: LeafView, controller: C): void;
    controllerDidDetachLeafView?(leafView: LeafView, controller: C): void;
    controllerWillHighlightLeafView?(leafView: LeafView, controller: C): void;
    controllerDidHighlightLeafView?(leafView: LeafView, controller: C): void;
    controllerWillUnhighlightLeafView?(leafView: LeafView, controller: C): void;
    controllerDidUnhighlightLeafView?(leafView: LeafView, controller: C): void;
    controllerDidEnterLeafView?(leafView: LeafView, controller: C): void;
    controllerDidLeaveLeafView?(leafView: LeafView, controller: C): void;
    controllerDidPressLeafView?(input: PositionGestureInput, event: Event | null, leafView: LeafView, controller: C): void;
    controllerDidLongPressLeafView?(input: PositionGestureInput, leafView: LeafView, controller: C): void;
    controllerWillAttachCell?(cellController: CellController, controller: C): void;
    controllerDidDetachCell?(cellController: CellController, controller: C): void;
    controllerWillAttachCellTrait?(cellTrait: CellTrait, cellController: CellController, controller: C): void;
    controllerDidDetachCellTrait?(cellTrait: CellTrait, cellController: CellController, controller: C): void;
    controllerWillAttachCellView?(cellView: CellView, cellController: CellController, controller: C): void;
    controllerDidDetachCellView?(cellView: CellView, cellController: CellController, controller: C): void;
    controllerDidPressCellView?(input: PositionGestureInput, event: Event | null, cellView: CellView, cellController: CellController, controller: C): void;
    controllerDidLongPressCellView?(input: PositionGestureInput, cellView: CellView, cellController: CellController, controller: C): void;
    controllerWillAttachCellContentView?(cellContentView: HtmlView, cellController: CellController, controller: C): void;
    controllerDidDetachCellContentView?(cellContentView: HtmlView, cellController: CellController, controller: C): void;
    controllerWillSetCellIcon?(newIcon: Graphics | null, oldIcon: Graphics | null, cellController: CellController, controller: C): void;
    controllerDidSetCellIcon?(newIcon: Graphics | null, oldIcon: Graphics | null, cellController: CellController, controller: C): void;
}

/** @public */
export declare class LeafletView extends MapView {
    constructor(map: L.Map);
    readonly observerType?: Class<LeafletViewObserver>;
    readonly map: L.Map;
    protected initMap(map: L.Map): void;
    readonly geoViewport: LeafletViewport;
    protected willSetGeoViewport(newGeoViewport: LeafletViewport, oldGeoViewport: LeafletViewport): void;
    protected onSetGeoViewport(newGeoViewport: LeafletViewport, oldGeoViewport: LeafletViewport): void;
    protected didSetGeoViewport(newGeoViewport: LeafletViewport, oldGeoViewport: LeafletViewport): void;
    protected updateGeoViewport(): boolean;
    protected onMapRender(): void;
    protected onMoveStart(): void;
    protected onMoveEnd(): void;
    moveTo(geoPerspective: AnyGeoPerspective, timing?: AnyTiming | boolean): void;
    protected willMoveMap(): void;
    protected didMoveMap(): void;
    readonly canvas: ViewRef<this, CanvasView>;
    static readonly canvas: MemberFastenerClass<LeafletView, "canvas">;
    readonly container: ViewRef<this, HtmlView>;
    static readonly container: MemberFastenerClass<LeafletView, "container">;
}

/** @public */
export declare interface LeafletViewObserver<V extends LeafletView = LeafletView> extends MapViewObserver<V> {
    viewWillSetGeoViewport?(newGeoViewport: LeafletViewport, oldGeoViewport: LeafletViewport, view: V): void;
    viewDidSetGeoViewport?(newGeoViewport: LeafletViewport, oldGeoViewport: LeafletViewport, view: V): void;
    viewWillMoveMap?(view: V): void;
    viewDidMoveMap?(view: V): void;
}

/** @public */
export declare class LeafletViewport implements GeoViewport, Equals {
    constructor(map: L.Map, geoFrame: GeoBox, geoCenter: GeoPoint, viewOrigin: R2Point, zoom: number, heading: number, tilt: number);
    readonly map: L.Map;
    readonly geoFrame: GeoBox;
    readonly geoCenter: GeoPoint;
    readonly viewOrigin: R2Point;
    readonly zoom: number;
    readonly heading: number;
    readonly tilt: number;
    project(geoPoint: AnyGeoPoint): R2Point;
    project(lng: number, lat: number): R2Point;
    unproject(viewPoint: AnyR2Point): GeoPoint;
    unproject(x: number, y: number): GeoPoint;
    equals(that: unknown): boolean;
    static create(map: L.Map): LeafletViewport;
}

/** @public */
export declare class LeafTrait extends Trait {
    readonly observerType?: Class<LeafTraitObserver>;
    getCell<F extends abstract new (...args: any) => CellTrait>(key: string, cellTraitClass: F): InstanceType<F> | null;
    getCell(key: string): CellTrait | null;
    getOrCreateCell<F extends TraitCreator<F, CellTrait>>(key: string, cellTraitClass: F): InstanceType<F>;
    setCell(key: string, cellTrait: CellTrait): void;
    readonly cells: TraitSet<this, CellTrait>;
    static readonly cells: MemberFastenerClass<LeafTrait, "cells">;
    /** @internal */
    protected startConsumingCells(): void;
    /** @internal */
    protected stopConsumingCells(): void;
    protected onStartConsuming(): void;
    protected onStopConsuming(): void;
}

/** @public */
export declare interface LeafTraitObserver<T extends LeafTrait = LeafTrait> extends TraitObserver<T> {
    traitWillAttachCell?(cellTrait: CellTrait, targetTrait: Trait | null, trait: T): void;
    traitDidDetachCell?(cellTrait: CellTrait, trait: T): void;
}

/** @public */
export declare class LeafView extends HtmlView {
    constructor(node: HTMLElement);
    protected initLeaf(): void;
    readonly observerType?: Class<LeafViewObserver>;
    readonly layout: Property<this, TableLayout | null, AnyTableLayout | null>;
    readonly depth: Property<this, number>;
    readonly rowSpacing: ThemeConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly rowHeight: ThemeConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly stretch: ExpansionThemeAnimator<this, Expansion | null, AnyExpansion | null>;
    readonly hovers: Property<this, boolean>;
    readonly hover: FocusThemeAnimator<this>;
    readonly highlight: FocusThemeAnimator<this>;
    getCell<F extends abstract new (...args: any) => CellView>(key: string, cellViewClass: F): InstanceType<F> | null;
    getCell(key: string): CellView | null;
    getOrCreateCell<F extends ViewCreator<F, CellView>>(key: string, cellViewClass: F): InstanceType<F>;
    setCell(key: string, cellView: CellView): void;
    readonly cells: ViewSet<this, CellView>;
    static readonly cells: MemberFastenerClass<LeafView, "cells">;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected layoutLeaf(): void;
    protected displayChildren(displayFlags: ViewFlags, viewContext: ViewContextType<this>, displayChild: (this: this, child: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    protected layoutChildViews(displayFlags: ViewFlags, viewContext: ViewContextType<this>, displayChild: (this: this, child: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    readonly glows: Property<this, boolean>;
    protected glow(input: PositionGestureInput): void;
    readonly gesture: PositionGesture<this, LeafView>;
    static readonly gesture: MemberFastenerClass<LeafView, "gesture">;
}

/** @public */
export declare interface LeafViewObserver<V extends LeafView = LeafView> extends HtmlViewObserver<V> {
    viewWillAttachCell?(cellView: CellView, targetView: View | null, view: V): void;
    viewDidDetachCell?(cellView: CellView, view: V): void;
    viewWillHighlight?(view: V): void;
    viewDidHighlight?(view: V): void;
    viewWillUnhighlight?(view: V): void;
    viewDidUnhighlight?(view: V): void;
    viewDidEnter?(view: V): void;
    viewDidLeave?(view: V): void;
    viewDidPress?(input: PositionGestureInput, event: Event | null, view: V): void;
    viewDidLongPress?(input: PositionGestureInput, view: V): void;
}

/** @public */
export declare class LeftAxisController<Y = unknown> extends AxisController<Y> {
    readonly axis: TraitViewRef<this, LeftAxisTrait<Y>, LeftAxisView<Y>>;
    static readonly axis: MemberFastenerClass<LeftAxisController, "axis">;
}

/** @public */
export declare abstract class LeftAxisTrait<Y = unknown> extends AxisTrait<Y> {
    readonly observerType?: Class<AxisTraitObserver<Y, LeftAxisTrait<Y>>>;
}

/** @public */
export declare class LeftAxisView<Y = unknown> extends AxisView<Y> {
    get orientation(): AxisOrientation;
    readonly scale: ContinuousScaleAnimator<this, Y, number>;
    protected layoutTick(tick: TickView<Y>, origin: R2Point, frame: R2Box, scale: ContinuousScale<Y, number>): void;
    protected renderDomain(context: PaintingContext, origin: R2Point, frame: R2Box): void;
}

/** @public */
export declare class LeftTickView<Y = unknown> extends TickView<Y> {
    constructor(value: Y);
    get orientation(): TickOrientation;
    protected layoutLabel(labelView: GraphicsView): void;
    protected renderTick(context: PaintingContext, frame: R2Box): void;
}

/** @internal */
export declare const LengthAttributeAnimator: AttributeAnimatorFactory<AttributeAnimator<any, Length | null, AnyLength | null>>;

/** @internal */
export declare class LengthLook extends Look<Length, AnyLength> {
    combine(combination: Length | undefined, value: Length, weight?: number): Length;
    between(a: Length, b: Length): Interpolator<Length>;
    coerce(value: AnyLength): Length;
}

/** @internal */
export declare const LengthStyleAnimator: StyleAnimatorFactory<StyleAnimator<any, Length | null, AnyLength | null>>;

/** @internal */
export declare const LengthStyleConstraintAnimator: StyleConstraintAnimatorFactory<StyleConstraintAnimator<any, Length | null, AnyLength | null>>;

/** @internal */
export declare const LengthThemeAnimator: ThemeAnimatorFactory<ThemeAnimator<any, Length | null | undefined, AnyLength | null | undefined>>;

/** @internal */
export declare const LengthThemeConstraintAnimator: ThemeConstraintAnimatorFactory<ThemeConstraintAnimator<any, Length | null | undefined, AnyLength | null | undefined>>;

/** @public */
export declare class LinearGradient implements Interpolate<LinearGradient>, Equals, Equivalent {
    constructor(angle: LinearGradientAngle, stops: ReadonlyArray<ColorStop>);
    readonly angle: LinearGradientAngle;
    withAngle(angle: AnyLinearGradientAngle): LinearGradient;
    readonly stops: ReadonlyArray<ColorStop>;
    withStops(stops: ReadonlyArray<AnyColorStop>): LinearGradient;
    interpolateTo(that: LinearGradient): Interpolator<LinearGradient>;
    interpolateTo(that: unknown): Interpolator<LinearGradient> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    /** @internal */
    readonly stringValue: string | undefined;
    toString(): string;
    static create(angle: AnyLinearGradientAngle, ...stops: AnyColorStop[]): LinearGradient;
    static fromInit(init: LinearGradientInit): LinearGradient;
    static fromAny(value: AnyLinearGradient): LinearGradient;
    static parse(string: string): LinearGradient;
    static parseAngle(string: string): LinearGradientAngle;
    /** @internal */
    static isInit(value: unknown): value is LinearGradientInit;
    /** @internal */
    static isAny(value: unknown): value is AnyLinearGradient;
}

/** @public */
export declare type LinearGradientAngle = Angle | LinearGradientSide | LinearGradientCorner;

/** @internal */
export declare class LinearGradientAngleParser extends Parser<LinearGradientAngle> {
    private readonly identOutput;
    private readonly angleParser;
    private readonly side;
    private readonly step;
    constructor(identOutput?: Output<string>, angleParser?: Parser<Angle>, side?: LinearGradientSide, step?: number);
    feed(input: Input): Parser<LinearGradientAngle>;
    static parse(input: Input, identOutput?: Output<string>, angleParser?: Parser<Angle>, side?: LinearGradientSide, step?: number): Parser<LinearGradientAngle>;
}

/** @public */
export declare type LinearGradientCorner = [LinearGradientSide, LinearGradientSide];

/** @public */
export declare interface LinearGradientInit {
    angle: AnyLinearGradientAngle;
    stops: AnyColorStop[];
}

/** @internal */
export declare interface LinearGradientInterpolator extends Interpolator<LinearGradient> {
    /** @internal */
    readonly angleInterpolator: Interpolator<LinearGradientAngle>;
    /** @internal */
    readonly stopInterpolators: ReadonlyArray<Interpolator<ColorStop>>;
    readonly 0: LinearGradient;
    readonly 1: LinearGradient;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const LinearGradientInterpolator: {
    (g0: LinearGradient, g1: LinearGradient): LinearGradientInterpolator;
    /** @internal */
    prototype: LinearGradientInterpolator;
};

/** @internal */
export declare class LinearGradientParser extends Parser<LinearGradient> {
    private readonly identOutput;
    private readonly angleParser;
    private readonly stopsParser;
    private readonly step;
    constructor(identOutput?: Output<string>, angleParser?: Parser<LinearGradientAngle>, stopsParser?: Parser<ColorStop[]>, step?: number);
    feed(input: Input): Parser<LinearGradient>;
    static parse(input: Input, identOutput?: Output<string>, angleParser?: Parser<LinearGradientAngle>, stopsParser?: Parser<ColorStop[]>, step?: number): Parser<LinearGradient>;
    /** @internal */
    static parseRest(input: Input, identOutput?: Output<string>): Parser<LinearGradient>;
}

/** @public */
export declare type LinearGradientSide = "left" | "right" | "top" | "bottom";

/** @public */
export declare type LineHeight = Length | "normal";

/** @public */
export declare const LineHeight: {
    fromAny(height: AnyLineHeight): LineHeight;
    fromValue(value: Value): LineHeight | null;
};

/** @public */
export declare class LinePlotController<X = unknown, Y = unknown> extends SeriesPlotController<X, Y> {
    readonly observerType?: Class<LinePlotControllerObserver<X, Y>>;
    readonly dataPoints: TraitViewControllerSet<this, DataPointTrait<X, Y>, DataPointView<X, Y>, DataPointController<X, Y>> & DataSetControllerDataPointExt<X, Y>;
    static readonly dataPoints: MemberFastenerClass<LinePlotController, "dataPoints">;
    protected setPlotStroke(stroke: Look<Color> | Color | null, timing?: AnyTiming | boolean): void;
    protected setPlotStrokeWidth(strokeWidth: Length | null, timing?: AnyTiming | boolean): void;
    readonly plot: TraitViewRef<this, LinePlotTrait<X, Y>, LinePlotView<X, Y>>;
    static readonly plot: MemberFastenerClass<LinePlotController, "plot">;
}

/** @public */
export declare interface LinePlotControllerObserver<X = unknown, Y = unknown, C extends LinePlotController<X, Y> = LinePlotController<X, Y>> extends SeriesPlotControllerObserver<X, Y, C> {
    controllerWillAttachPlotTrait?(plotTrait: LinePlotTrait<X, Y>, controller: C): void;
    controllerDidDetachPlotTrait?(plotTrait: LinePlotTrait<X, Y>, controller: C): void;
    controllerWillAttachPlotView?(plotView: LinePlotView<X, Y>, controller: C): void;
    controllerDidDetachPlotView?(plotView: LinePlotView<X, Y>, controller: C): void;
    controllerWillSetPlotStroke?(newStroke: Color | null, oldStroke: Color | null, controller: C): void;
    controllerDidSetPlotStroke?(newStroke: Color | null, oldStroke: Color | null, controller: C): void;
    controllerWillSetPlotStrokeWidth?(newStrokeWidth: Length | null, oldStrokeWidth: Length | null, controller: C): void;
    controllerDidSetPlotStrokeWidth?(newStrokeWidth: Length | null, oldStrokeWidth: Length | null, controller: C): void;
}

/** @public */
export declare class LinePlotTrait<X = unknown, Y = unknown> extends SeriesPlotTrait<X, Y> {
    readonly observerType?: Class<LinePlotTraitObserver<X, Y>>;
    readonly stroke: Property<this, Look<Color> | Color | null, Look<Color> | AnyColor | null>;
    readonly strokeWidth: Property<this, Length | null, AnyLength | null>;
}

/** @public */
export declare interface LinePlotTraitObserver<X = unknown, Y = unknown, R extends LinePlotTrait<X, Y> = LinePlotTrait<X, Y>> extends SeriesPlotTraitObserver<X, Y, R> {
    traitWillSetPlotStroke?(newStroke: Look<Color> | Color | null, oldStroke: Look<Color> | Color | null, trait: R): void;
    traitDidSetPlotStroke?(newStroke: Look<Color> | Color | null, oldStroke: Look<Color> | Color | null, trait: R): void;
    traitWillSetPlotStrokeWidth?(newStrokeWidth: Length | null, oldStrokeWidth: Length | null, trait: R): void;
    traitDidSetPlotStrokeWidth?(newStrokeWidth: Length | null, oldStrokeWidth: Length | null, trait: R): void;
}

/** @public */
export declare class LinePlotView<X = unknown, Y = unknown> extends SeriesPlotView<X, Y> implements StrokeView {
    readonly observerType?: Class<LinePlotViewObserver<X, Y>>;
    readonly stroke: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly strokeWidth: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly hitWidth: Property<this, number>;
    protected renderPlot(context: CanvasContext, frame: R2Box): void;
    protected hitTestPlot(x: number, y: number, renderer: CanvasRenderer): GraphicsView | null;
    init(init: LinePlotViewInit<X, Y>): void;
}

/** @public */
export declare interface LinePlotViewInit<X = unknown, Y = unknown> extends SeriesPlotViewInit<X, Y>, StrokeViewInit {
    hitWidth?: number;
}

/** @public */
export declare interface LinePlotViewObserver<X = unknown, Y = unknown, V extends LinePlotView<X, Y> = LinePlotView<X, Y>> extends SeriesPlotViewObserver<X, Y, V> {
    viewWillSetPlotStroke?(newStroke: Color | null, oldStroke: Color | null, view: V): void;
    viewDidSetPlotStroke?(newStroke: Color | null, oldStroke: Color | null, view: V): void;
    viewWillSetPlotStrokeWidth?(newStrokeWidth: Length | null, oldStrokeWidth: Length | null, view: V): void;
    viewDidSetPlotStrokeWidth?(newStrokeWidth: Length | null, oldStrokeWidth: Length | null, view: V): void;
}

/** @public */
export declare abstract class Look<T, U = never> implements Mood {
    constructor(name: string);
    readonly name: string;
    add(a: LookVector<T>, b: LookVector<T>): LookVector<T>;
    negate(a: LookVector<T>): LookVector<T>;
    subtract(a: LookVector<T>, b: LookVector<T>): LookVector<T>;
    multiply(a: LookVector<T>, scalar: number): LookVector<T>;
    dot(a: LookVector<T>, b: MoodVector): T | undefined;
    dotOr<E>(a: LookVector<T>, b: MoodVector, elseValue: E): T | E;
    abstract combine(combination: T | undefined, value: T, weight?: number): T;
    abstract between(a: T, b: T): Interpolator<T>;
    abstract coerce(value: T | U): T;
    empty(): LookVector<T>;
    of(...feels: [Feel, T | U][]): LookVector<T>;
    fromArray(array: ReadonlyArray<[Feel, T]>, index?: {
        readonly [name: string]: number | undefined;
    }): LookVector<T>;
    toString(): string;
    static font: Look<Font, AnyFont>;
    static color: Look<Color, AnyColor>;
    static iconColor: Look<Color, AnyColor>;
    static statusColor: Look<Color, AnyColor>;
    static accentColor: Look<Color, AnyColor>;
    static mutedColor: Look<Color, AnyColor>;
    static neutralColor: Look<Color, AnyColor>;
    static subduedColor: Look<Color, AnyColor>;
    static faintColor: Look<Color, AnyColor>;
    static highlightColor: Look<Color, AnyColor>;
    static backgroundColor: Look<Color, AnyColor>;
    static borderColor: Look<Color, AnyColor>;
    static opacity: Look<number>;
    static shadow: Look<BoxShadow, AnyBoxShadow>;
    static spacing: Look<Length, AnyLength>;
    static timing: Look<Timing, AnyTiming>;
}

/** @public */
export declare class LookVector<T> implements Equals, Debug {
    constructor(array: ReadonlyArray<[Feel, T]>, index: {
        readonly [name: string]: number | undefined;
    });
    /** @internal */
    readonly array: ReadonlyArray<[Feel, T]>;
    /** @internal */
    readonly index: {
        readonly [name: string]: number | undefined;
    };
    get size(): number;
    isEmpty(): boolean;
    has(feel: Feel): boolean;
    has(name: string): boolean;
    get(feel: Feel): T | undefined;
    get(name: string): T | undefined;
    get(index: number): T | undefined;
    getOr<E>(feel: Feel, elseValue: E): T | E;
    getOr<E>(name: string, elseValue: E): T | E;
    getOr<E>(index: number, elseValue: E): T | E;
    updated(feel: Feel, value: T | undefined): LookVector<T>;
    updated(updates: LookVectorUpdates<T>): LookVector<T>;
    protected copy(array: ReadonlyArray<[Feel, T]>, index?: {
        readonly [name: string]: number | undefined;
    }): LookVector<T>;
    forEach<R>(callback: (value: T, feel: Feel) => R | void): R | undefined;
    forEach<R, S>(callback: (this: S, value: T, feel: Feel) => R | void, thisArg: S): R | undefined;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static empty<T>(): LookVector<T>;
    static of<T>(...feels: [Feel, T][]): LookVector<T>;
    static fromArray<T>(array: ReadonlyArray<[Feel, T]>, index?: {
        [name: string]: number | undefined;
    }): LookVector<T>;
    static fromAny<T>(value: AnyLookVector<T>): LookVector<T>;
    /** @internal */
    static index<T>(array: ReadonlyArray<[Feel, T]>): {
        readonly [name: string]: number | undefined;
    };
}

/** @public */
export declare type LookVectorArray<T> = ReadonlyArray<[Feel, T]>;

/** @public */
export declare type LookVectorUpdates<T> = ReadonlyArray<[Feel, T | undefined]>;

/** @public */
export declare class MapboxView extends MapView {
    constructor(map: mapboxgl.Map);
    readonly observerType?: Class<MapboxViewObserver>;
    readonly map: mapboxgl.Map;
    protected initMap(map: mapboxgl.Map): void;
    readonly geoViewport: MapboxViewport;
    protected willSetGeoViewport(newGeoViewport: MapboxViewport, oldGeoViewport: MapboxViewport): void;
    protected onSetGeoViewport(newGeoViewport: MapboxViewport, oldGeoViewport: MapboxViewport): void;
    protected didSetGeoViewport(newGeoViewport: MapboxViewport, oldGeoViewport: MapboxViewport): void;
    protected updateGeoViewport(): boolean;
    protected onMapRender(): void;
    protected onMoveStart(): void;
    protected onMoveEnd(): void;
    moveTo(geoPerspective: AnyGeoPerspective, timing?: AnyTiming | boolean): void;
    protected willMoveMap(): void;
    protected didMoveMap(): void;
    readonly canvas: ViewRef<this, CanvasView>;
    static readonly canvas: MemberFastenerClass<MapboxView, "canvas">;
    readonly container: ViewRef<this, HtmlView>;
    static readonly container: MemberFastenerClass<MapboxView, "container">;
}

/** @public */
export declare interface MapboxViewObserver<V extends MapboxView = MapboxView> extends MapViewObserver<V> {
    viewWillSetGeoViewport?(newGeoViewport: MapboxViewport, oldGeoViewport: MapboxViewport, view: V): void;
    viewDidSetGeoViewport?(newGeoViewport: MapboxViewport, oldGeoViewport: MapboxViewport, view: V): void;
    viewWillMoveMap?(view: V): void;
    viewDidMoveMap?(view: V): void;
}

/** @public */
export declare class MapboxViewport implements GeoViewport, Equals {
    constructor(map: mapboxgl.Map, geoFrame: GeoBox, geoCenter: GeoPoint, zoom: number, heading: number, tilt: number);
    readonly map: mapboxgl.Map;
    readonly geoFrame: GeoBox;
    readonly geoCenter: GeoPoint;
    readonly zoom: number;
    readonly heading: number;
    readonly tilt: number;
    project(geoPoint: AnyGeoPoint): R2Point;
    project(lng: number, lat: number): R2Point;
    unproject(viewPoint: AnyR2Point): GeoPoint;
    unproject(x: number, y: number): GeoPoint;
    equals(that: unknown): boolean;
    static create(map: mapboxgl.Map): MapboxViewport;
}

/** @public */
export declare abstract class MapController extends Controller {
    readonly observerType?: Class<MapControllerObserver>;
    protected abstract createMapView(containerView: HtmlView): MapView;
    protected setGeoPerspective(geoPerspective: GeoPerspective | null): void;
    readonly map: TraitViewRef<this, MapTrait, MapView>;
    static readonly map: MemberFastenerClass<MapController, "map">;
    readonly canvas: ViewRef<this, CanvasView>;
    static readonly canvas: MemberFastenerClass<MapController, "canvas">;
    readonly container: ViewRef<this, HtmlView>;
    static readonly container: MemberFastenerClass<MapController, "container">;
    readonly geoTiming: Property<this, Timing | boolean | undefined, AnyTiming>;
    readonly layers: TraitViewControllerSet<this, GeoTrait, GeoView, GeoController> & MapControllerLayerExt;
    static readonly layers: MemberFastenerClass<MapController, "layers">;
}

/** @public */
export declare interface MapControllerLayerExt {
    attachLayerTrait(layerTrait: GeoTrait, layerController: GeoController): void;
    detachLayerTrait(layerTrait: GeoTrait, layerController: GeoController): void;
    attachLayerView(layerView: GeoView, layerController: GeoController): void;
    detachLayerView(layerView: GeoView, layerController: GeoController): void;
}

/** @public */
export declare interface MapControllerObserver<C extends MapController = MapController> extends ControllerObserver<C> {
    controllerWillAttachMapTrait?(mapTrait: MapTrait, controller: C): void;
    controllerDidDetachMapTrait?(mapTrait: MapTrait, controller: C): void;
    controllerWillAttachMapView?(mapView: MapView, controller: C): void;
    controllerDidDetachMapView?(mapView: MapView, controller: C): void;
    controllerWillAttachMapCanvasView?(mapCanvasView: CanvasView, controller: C): void;
    controllerDidDetachMapCanvasView?(mapCanvasView: CanvasView, controller: C): void;
    controllerWillAttachMapContainerView?(mapContainerView: HtmlView, controller: C): void;
    controllerDidDetachMapContainerView?(mapContainerView: HtmlView, controller: C): void;
    controllerWillSetGeoViewport?(newGeoViewport: GeoViewport, oldGeoViewport: GeoViewport, controller: C): void;
    controllerDidSetGeoViewport?(newGeoViewport: GeoViewport, oldGeoViewport: GeoViewport, controller: C): void;
    controllerWillAttachLayer?(layerController: GeoController, controller: C): void;
    controllerDidDetachLayer(layerController: GeoController, controller: C): void;
    controllerWillAttachLayerTrait?(layerTrait: GeoTrait, layerController: GeoController, controller: C): void;
    controllerDidDetachLayerTrait?(layerTrait: GeoTrait, layerController: GeoController, controller: C): void;
    controllerWillAttachLayerView?(layerView: GeoView, layerController: GeoController, controller: C): void;
    controllerDidDetachLayerView?(layerView: GeoView, layerController: GeoController, controller: C): void;
    controllerWillSetLayerGeoBounds?(newGeoBounds: GeoBox, oldGeoBounds: GeoBox, layerController: GeoController, controller: C): void;
    controllerDidSetLayerGeoBounds?(newGeoBounds: GeoBox, oldGeoBounds: GeoBox, layerController: GeoController, controller: C): void;
}

/** @beta */
export declare abstract class MapDownlinkTrait extends DownlinkTrait {
    protected downlinkDidUpdate(key: Value, newValue: Value, oldValue: Value): void;
    protected downlinkDidRemove(key: Value, oldValue: Value): void;
    readonly downlink: MapDownlinkFastener<this, Value, Value, AnyValue, AnyValue>;
}

/** @public */
export declare class MapTrait extends GeoTrait {
    readonly observerType?: Class<MapTraitObserver>;
    get geoBounds(): GeoBox;
    readonly geoPerspective: Property<this, GeoPerspective | null, AnyGeoPerspective | null>;
    readonly layers: TraitSet<this, GeoTrait>;
    static readonly layers: MemberFastenerClass<MapTrait, "layers">;
    /** @internal */
    protected startConsumingLayers(): void;
    /** @internal */
    protected stopConsumingLayers(): void;
    protected onStartConsuming(): void;
    protected onStopConsuming(): void;
}

/** @public */
export declare interface MapTraitObserver<R extends MapTrait = MapTrait> extends GeoTraitObserver<R> {
    traitWillSetGeoPerspective?(newGeoPerspective: GeoPerspective | null, oldGeoPerspective: GeoPerspective | null, trait: R): void;
    traitDidSetGeoPerspective?(newGeoPerspective: GeoPerspective | null, oldGeoPerspective: GeoPerspective | null, trait: R): void;
    traitWillAttachLayer?(layerTrait: GeoTrait, targetTrait: Trait | null, trait: R): void;
    traitDidDetachLayer?(layerTrait: GeoTrait, trait: R): void;
}

/** @public */
export declare abstract class MapView extends GeoView {
    readonly observerType?: Class<MapViewObserver>;
    abstract get geoViewport(): GeoViewport;
    abstract moveTo(geoPerspective: AnyGeoPerspective, timing?: AnyTiming | boolean): void;
    readonly canvas: ViewRef<this, CanvasView>;
    static readonly canvas: MemberFastenerClass<MapView, "canvas">;
    readonly container: ViewRef<this, HtmlView>;
    static readonly container: MemberFastenerClass<MapView, "container">;
    protected needsProcess(processFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    extendViewContext(viewContext: GraphicsViewContext): ViewContextType<this>;
    get geoFrame(): GeoBox;
}

/** @public */
export declare interface MapViewObserver<V extends MapView = MapView> extends GeoViewObserver<V> {
    viewWillSetGeoViewport?(newGeoViewport: GeoViewport, oldGeoViewport: GeoViewport, view: V): void;
    viewDidSetGeoViewport?(newGeoViewport: GeoViewport, oldGeoViewport: GeoViewport, view: V): void;
    viewWillAttachMapCanvas?(mapCanvasView: CanvasView, view: V): void;
    viewDidDetachMapCanvas?(mapCanvasView: CanvasView, view: V): void;
    viewWillAttachMapContainer?(mapContainerView: HtmlView, view: V): void;
    viewDidDetachMapContainer?(mapContainerView: HtmlView, view: V): void;
}

/** @public */
export declare type MaxHeight = Length | string | "fill-available" | "fit-content" | "max-content" | "min-content" | "none";

/** @public */
export declare type MaxWidth = Length | string | "fill-available" | "fit-content" | "max-content" | "min-content" | "none";

/** @public */
export declare interface MediaRule<O = unknown> extends CssRule<O>, CssContext {
    /** @override */
    readonly rule: CSSMediaRule;
    /** @override */
    getRule(index: number): CSSRule | null;
    /** @override */
    insertRule(cssText: string, index?: number): number;
    /** @override */
    removeRule(index: number): void;
    /** @override */
    applyTheme(theme: ThemeMatrix, mood: MoodVector, timing?: AnyTiming | boolean | null): void;
    /** @internal */
    createRule(cssText: string): CSSMediaRule;
    /** @internal */
    initRule?(rule: CSSMediaRule): void;
    /** @internal */
    initCss?(): string;
}

/** @public */
export declare const MediaRule: MediaRuleFactory<MediaRule<any>>;

/** @public */
export declare interface MediaRuleClass<F extends MediaRule<any> = MediaRule<any>> extends CssRuleClass<F> {
}

/** @public */
export declare type MediaRuleDescriptor<O = unknown, I = {}> = ThisType<MediaRule<O> & I> & MediaRuleInit & Partial<I>;

/** @public */
export declare interface MediaRuleFactory<F extends MediaRule<any> = MediaRule<any>> extends MediaRuleClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): MediaRuleFactory<F> & I;
    define<O>(className: string, descriptor: MediaRuleDescriptor<O>): MediaRuleFactory<MediaRule<any>>;
    define<O, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & MediaRuleDescriptor<O, I>): MediaRuleFactory<MediaRule<any> & I>;
    <O>(descriptor: MediaRuleDescriptor<O>): PropertyDecorator;
    <O, I = {}>(descriptor: {
        implements: unknown;
    } & MediaRuleDescriptor<O, I>): PropertyDecorator;
}

/** @public */
export declare interface MediaRuleInit extends CssRuleInit {
    extends?: {
        prototype: MediaRule<any>;
    } | string | boolean | null;
    initRule?(rule: CSSMediaRule): void;
}

/** @internal */
export declare type MemberGestureView<O, K extends keyof O> = O[K] extends Gesture<any, infer V> ? V : never;

/** @public */
export declare type MinHeight = Length | string | "fill-available" | "fit-content" | "max-content" | "min-content";

/** @public */
export declare type MinWidth = Length | string | "fill-available" | "fit-content" | "max-content" | "min-content";

/** @public */
export declare interface Modal {
    readonly modalView: View | null;
    readonly modalState: ModalState;
    readonly modality: boolean | number;
    showModal(options: ModalOptions, timing?: AnyTiming | boolean): void;
    hideModal(timing?: AnyTiming | boolean): void;
}

/** @public */
export declare const Modal: {
    is(object: unknown): object is Modal;
};

/** @public */
export declare interface ModalOptions {
    modal?: boolean | number;
    multi?: boolean;
}

/** @public */
export declare interface ModalProvider<V extends View, S extends ModalService<V> | null | undefined = ModalService<V>> extends Provider<V, S> {
    presentModal(modal: Modal, options?: ModalOptions): void;
    dismissModal(modal: Modal): void;
    dismissModals(): void;
    toggleModal(modal: Modal, options?: ModalOptions): void;
    updateModality(): void;
    displaceModals(event: Event | null): void;
    createService(): S;
}

/** @public */
export declare const ModalProvider: ProviderClass<ModalProvider<any, any>>;

/** @public */
export declare class ModalService<V extends View = View> extends Service<V> {
    constructor();
    /** @override */
    readonly observerType?: Class<ModalServiceObserver<V>>;
    readonly modals: ReadonlyArray<Modal>;
    isModal(): boolean;
    readonly modality: number;
    readonly matteView: View | null;
    setMatteView(matteView: View | null): void;
    protected insertModalView(modalView: View): void;
    presentModal(modal: Modal, options?: ModalOptions): void;
    protected willPresentModal(modal: Modal, options: ModalOptions): void;
    protected onPresentModal(modal: Modal, options: ModalOptions): void;
    protected didPresentModal(modal: Modal, options: ModalOptions): void;
    dismissModal(modal: Modal): void;
    protected willDismissModal(modal: Modal): void;
    protected onDismissModal(modal: Modal): void;
    protected didDismissModal(modal: Modal): void;
    dismissModals(): void;
    toggleModal(modal: Modal, options?: ModalOptions): void;
    updateModality(): void;
    protected willUpdateModality(newModality: number, oldModality: number): void;
    protected onUpdateModality(newModality: number, oldModality: number): void;
    protected didUpdateModality(newModality: number, oldModality: number): void;
    displaceModals(event: Event | null): void;
    protected willDisplaceModals(event: Event | null): boolean;
    protected onDisplaceModals(event: Event | null): void;
    protected didDisplaceModals(event: Event | null): void;
    protected onAttachRoot(root: V): void;
    protected onDetachRoot(root: V): void;
    protected attachEvents(view: V): void;
    protected detachEvents(view: V): void;
    protected onClick(event: Event): void;
    static insertModalView(modalView: View): void;
    static global<V extends View>(): ModalService<V>;
}

/** @public */
export declare interface ModalServiceObserver<V extends View = View, S extends ModalService<V> = ModalService<V>> extends ServiceObserver<V, S> {
    serviceWillPresentModal?(modal: Modal, options: ModalOptions, service: S): void;
    serviceDidPresentModal?(modal: Modal, options: ModalOptions, service: S): void;
    serviceWillDismissModal?(modal: Modal, service: S): void;
    serviceDidDismissModal?(modal: Modal, service: S): void;
    serviceWillUpdateModality?(newModality: number, oldModality: number, service: S): void;
    serviceDidUpdateModality?(newModality: number, oldModality: number, service: S): void;
    serviceWillDisplaceModals?(event: Event | null, service: S): void | boolean;
    serviceDidDisplaceModals?(event: Event | null, service: S): void;
}

/** @public */
export declare type ModalState = "hidden" | "showing" | "shown" | "hiding";

/** @public */
export declare class Model extends Component<Model> implements Initable<ModelInit>, Consumable {
    constructor();
    get componentType(): Class<Model>;
    readonly observerType?: Class<ModelObserver>;
    /** @override */
    readonly consumerType?: Class<Consumer>;
    readonly contextType?: Class<ModelContext>;
    protected willAttachParent(parent: Model): void;
    protected onAttachParent(parent: Model): void;
    protected didAttachParent(parent: Model): void;
    protected willDetachParent(parent: Model): void;
    protected onDetachParent(parent: Model): void;
    protected didDetachParent(parent: Model): void;
    setChild<M extends Model>(key: string, newChild: M): Model | null;
    setChild<F extends ModelCreator<F>>(key: string, factory: F): Model | null;
    setChild(key: string, newChild: AnyModel | null): Model | null;
    appendChild<M extends Model>(child: M, key?: string): M;
    appendChild<F extends ModelCreator<F>>(factory: F, key?: string): InstanceType<F>;
    appendChild(child: AnyModel, key?: string): Model;
    prependChild<M extends Model>(child: M, key?: string): M;
    prependChild<F extends ModelCreator<F>>(factory: F, key?: string): InstanceType<F>;
    prependChild(child: AnyModel, key?: string): Model;
    insertChild<M extends Model>(child: M, target: Model | null, key?: string): M;
    insertChild<F extends ModelCreator<F>>(factory: F, target: Model | null, key?: string): InstanceType<F>;
    insertChild(child: AnyModel, target: Model | null, key?: string): Model;
    replaceChild<M extends Model>(newChild: Model, oldChild: M): M;
    replaceChild<M extends Model>(newChild: AnyModel, oldChild: M): M;
    protected willInsertChild(child: Model, target: Model | null): void;
    protected onInsertChild(child: Model, target: Model | null): void;
    protected didInsertChild(child: Model, target: Model | null): void;
    /** @internal */
    cascadeInsert(updateFlags?: ModelFlags, modelContext?: ModelContext): void;
    protected willRemoveChild(child: Model): void;
    protected onRemoveChild(child: Model): void;
    protected didRemoveChild(child: Model): void;
    /** @internal */
    cascadeMount(): void;
    protected willMount(): void;
    protected onMount(): void;
    protected didMount(): void;
    /** @internal */
    cascadeUnmount(): void;
    protected willUnmount(): void;
    protected onUnmount(): void;
    protected didUnmount(): void;
    requireUpdate(updateFlags: ModelFlags, immediate?: boolean): void;
    protected needsUpdate(updateFlags: ModelFlags, immediate: boolean): ModelFlags;
    requestUpdate(target: Model, updateFlags: ModelFlags, immediate: boolean): void;
    get updating(): boolean;
    get analyzing(): boolean;
    protected needsAnalyze(analyzeFlags: ModelFlags, modelContext: ModelContextType<this>): ModelFlags;
    cascadeAnalyze(analyzeFlags: ModelFlags, baesModelContext: ModelContext): void;
    protected willAnalyze(analyzeFlags: ModelFlags, modelContext: ModelContextType<this>): void;
    protected onAnalyze(analyzeFlags: ModelFlags, modelContext: ModelContextType<this>): void;
    protected didAnalyze(analyzeFlags: ModelFlags, modelContext: ModelContextType<this>): void;
    protected willMutate(modelContext: ModelContextType<this>): void;
    protected onMutate(modelContext: ModelContextType<this>): void;
    protected didMutate(modelContext: ModelContextType<this>): void;
    protected willAggregate(modelContext: ModelContextType<this>): void;
    protected onAggregate(modelContext: ModelContextType<this>): void;
    protected didAggregate(modelContext: ModelContextType<this>): void;
    protected willCorrelate(modelContext: ModelContextType<this>): void;
    protected onCorrelate(modelContext: ModelContextType<this>): void;
    protected didCorrelate(modelContext: ModelContextType<this>): void;
    protected analyzeChildren(analyzeFlags: ModelFlags, modelContext: ModelContextType<this>, analyzeChild: (this: this, child: Model, analyzeFlags: ModelFlags, modelContext: ModelContextType<this>) => void): void;
    protected analyzeTraitChildren(trait: Trait, analyzeFlags: ModelFlags, modelContext: ModelContextType<this>, analyzeChild: (this: this, child: Model, analyzeFlags: ModelFlags, modelContext: ModelContextType<this>) => void): void;
    protected analyzeOwnChildren(analyzeFlags: ModelFlags, modelContext: ModelContextType<this>, analyzeChild: (this: this, child: Model, analyzeFlags: ModelFlags, modelContext: ModelContextType<this>) => void): void;
    protected analyzeChild(child: Model, analyzeFlags: ModelFlags, modelContext: ModelContextType<this>): void;
    get refreshing(): boolean;
    protected needsRefresh(refreshFlags: ModelFlags, modelContext: ModelContextType<this>): ModelFlags;
    cascadeRefresh(refreshFlags: ModelFlags, baseModelContext: ModelContext): void;
    protected willRefresh(refreshFlags: ModelFlags, modelContext: ModelContextType<this>): void;
    protected onRefresh(refreshFlags: ModelFlags, modelContext: ModelContextType<this>): void;
    protected didRefresh(refreshFlags: ModelFlags, modelContext: ModelContextType<this>): void;
    protected willValidate(modelContext: ModelContextType<this>): void;
    protected onValidate(modelContext: ModelContextType<this>): void;
    protected didValidate(modelContext: ModelContextType<this>): void;
    protected willReconcile(modelContext: ModelContextType<this>): void;
    protected onReconcile(modelContext: ModelContextType<this>): void;
    protected didReconcile(modelContext: ModelContextType<this>): void;
    protected refreshChildren(refreshFlags: ModelFlags, modelContext: ModelContextType<this>, refreshChild: (this: this, child: Model, refreshFlags: ModelFlags, modelContext: ModelContextType<this>) => void): void;
    protected refreshTraitChildren(trait: Trait, refreshFlags: ModelFlags, modelContext: ModelContextType<this>, refreshChild: (this: this, child: Model, refreshFlags: ModelFlags, modelContext: ModelContextType<this>) => void): void;
    protected refreshOwnChildren(refreshFlags: ModelFlags, modelContext: ModelContextType<this>, refreshChild: (this: this, child: Model, refreshFlags: ModelFlags, modelContext: ModelContextType<this>) => void): void;
    protected refreshChild(child: Model, refreshFlags: ModelFlags, modelContext: ModelContextType<this>): void;
    readonly firstTrait: Trait | null;
    /** @internal */
    setFirstTrait(firstTrait: Trait | null): void;
    readonly lastTrait: Trait | null;
    /** @internal */
    setLastTrait(lastTrait: Trait | null): void;
    forEachTrait<T>(callback: (trait: Trait) => T | void): T | undefined;
    forEachTrait<T, S>(callback: (this: S, trait: Trait) => T | void, thisArg: S): T | undefined;
    /** @internal */
    readonly traitMap: Dictionary<Trait> | null;
    /** @internal */
    protected insertTraitMap(trait: Trait): void;
    /** @internal */
    protected removeTraitMap(trait: Trait): void;
    getTrait<F extends abstract new (...args: any) => Trait>(key: string, traitBound: F): InstanceType<F> | null;
    getTrait(key: string, traitBound?: abstract new (...args: any) => Trait): Trait | null;
    getTrait<F extends abstract new (...args: any) => Trait>(traitBound: F): InstanceType<F> | null;
    setTrait<T extends Trait>(key: string, newTrait: T): Trait | null;
    setTrait<F extends TraitCreator<F>>(key: string, factory: F): Trait | null;
    setTrait(key: string, newTrait: AnyTrait | null): Trait | null;
    appendTrait<T extends Trait>(trait: T, key?: string): T;
    appendTrait<F extends TraitCreator<F>>(factory: F, key?: string): InstanceType<F>;
    appendTrait(trait: AnyTrait, key?: string): Trait;
    prependTrait<T extends Trait>(trait: T, key?: string): T;
    prependTrait<F extends TraitCreator<F>>(factory: F, key?: string): InstanceType<F>;
    prependTrait(trait: AnyTrait, key?: string): Trait;
    insertTrait<T extends Trait>(trait: T, target: Trait | null, key?: string): T;
    insertTrait<F extends TraitCreator<F>>(factory: F, target: Trait | null, key?: string): InstanceType<F>;
    insertTrait(trait: AnyTrait, target: Trait | null, key?: string): Trait;
    replaceTrait<T extends Trait>(newTrait: Trait, oldTrait: T): T;
    replaceTrait<T extends Trait>(newTrait: AnyTrait, oldTrait: T): T;
    get insertTraitFlags(): ModelFlags;
    protected willInsertTrait(trait: Trait, target: Trait | null): void;
    protected onInsertTrait(trait: Trait, target: Trait | null): void;
    protected didInsertTrait(trait: Trait, target: Trait | null): void;
    removeTrait<T extends Trait>(trait: T): T;
    removeTrait(key: string | Trait): Trait | null;
    get removeTraitFlags(): ModelFlags;
    protected willRemoveTrait(trait: Trait): void;
    protected onRemoveTrait(trait: Trait): void;
    protected didRemoveTrait(trait: Trait): void;
    sortTraits(comparator: Comparator<Trait>): void;
    /** @internal */
    protected mountTraits(): void;
    /** @internal */
    protected unmountTraits(): void;
    getSuperTrait<F extends abstract new (...args: any) => Trait>(superBound: F): InstanceType<F> | null;
    getBaseTrait<F extends abstract new (...args: any) => Trait>(baseBound: F): InstanceType<F> | null;
    protected bindFastener(fastener: Fastener): void;
    /** @internal */
    protected bindChildFastener(fastener: Fastener, child: Model, target: Model | null): void;
    /** @internal */
    protected unbindChildFastener(fastener: Fastener, child: Model): void;
    /** @internal */
    protected bindTraitFasteners(trait: Trait, target: Trait | null): void;
    /** @internal */
    protected bindTraitFastener(fastener: Fastener, trait: Trait, target: Trait | null): void;
    /** @internal */
    protected unbindTraitFasteners(trait: Trait): void;
    /** @internal */
    protected unbindTraitFastener(fastener: Fastener, trait: Trait): void;
    /** @internal @override */
    decohereFastener(fastener: Fastener): void;
    /** @internal */
    recohereFasteners(t?: number): void;
    /** @internal */
    recohereDownlinks(t: number): void;
    /** @internal */
    readonly consumers: ReadonlyArray<ConsumerType<this>>;
    /** @override */
    consume(consumer: ConsumerType<this>): void;
    protected willConsume(consumer: ConsumerType<this>): void;
    protected onConsume(consumer: ConsumerType<this>): void;
    protected didConsume(consumer: ConsumerType<this>): void;
    /** @override */
    unconsume(consumer: ConsumerType<this>): void;
    protected willUnconsume(consumer: ConsumerType<this>): void;
    protected onUnconsume(consumer: ConsumerType<this>): void;
    protected didUnconsume(consumer: ConsumerType<this>): void;
    get consuming(): boolean;
    get startConsumingFlags(): ModelFlags;
    protected startConsuming(): void;
    protected willStartConsuming(): void;
    protected onStartConsuming(): void;
    protected didStartConsuming(): void;
    get stopConsumingFlags(): ModelFlags;
    protected stopConsuming(): void;
    protected willStopConsuming(): void;
    protected onStopConsuming(): void;
    protected didStopConsuming(): void;
    /** @internal */
    protected startConsumingFasteners(): void;
    /** @internal */
    protected stopConsumingFasteners(): void;
    readonly refreshProvider: RefreshProvider<this>;
    readonly selectionProvider: SelectionProvider<this>;
    readonly warpProvider: WarpProvider<this>;
    readonly warpRef: Property<this, WarpRef | null>;
    /** @internal */
    get superModelContext(): ModelContext;
    /** @internal */
    extendModelContext(modelContext: ModelContext): ModelContextType<this>;
    get modelContext(): ModelContextType<this>;
    /** @override */
    init(init: ModelInit): void;
    static create<S extends new () => InstanceType<S>>(this: S): InstanceType<S>;
    static fromInit<S extends abstract new (...args: any) => InstanceType<S>>(this: S, init: InitType<InstanceType<S>>): InstanceType<S>;
    static fromAny<S extends abstract new (...args: any) => InstanceType<S>>(this: S, value: AnyModel<InstanceType<S>>): InstanceType<S>;
    /** @internal */
    static uid: () => number;
    /** @internal */
    static readonly MountedFlag: ModelFlags;
    /** @internal */
    static readonly RemovingFlag: ModelFlags;
    /** @internal */
    static readonly AnalyzingFlag: ModelFlags;
    /** @internal */
    static readonly RefreshingFlag: ModelFlags;
    /** @internal */
    static readonly ContextualFlag: ModelFlags;
    /** @internal */
    static readonly ConsumingFlag: ModelFlags;
    /** @internal */
    static readonly UpdatingMask: ModelFlags;
    /** @internal */
    static readonly StatusMask: ModelFlags;
    static readonly NeedsAnalyze: ModelFlags;
    static readonly NeedsMutate: ModelFlags;
    static readonly NeedsAggregate: ModelFlags;
    static readonly NeedsCorrelate: ModelFlags;
    /** @internal */
    static readonly AnalyzeMask: ModelFlags;
    static readonly NeedsRefresh: ModelFlags;
    static readonly NeedsValidate: ModelFlags;
    static readonly NeedsReconcile: ModelFlags;
    /** @internal */
    static readonly RefreshMask: ModelFlags;
    /** @internal */
    static readonly UpdateMask: ModelFlags;
    /** @internal */
    static readonly FlagShift: number;
    /** @internal */
    static readonly FlagMask: ModelFlags;
    static readonly MountFlags: ModelFlags;
    static readonly InsertChildFlags: ModelFlags;
    static readonly RemoveChildFlags: ModelFlags;
    static readonly InsertTraitFlags: ModelFlags;
    static readonly RemoveTraitFlags: ModelFlags;
    static readonly StartConsumingFlags: ModelFlags;
    static readonly StopConsumingFlags: ModelFlags;
}

/** @public */
export declare interface ModelClass<M extends Model = Model, U = AnyModel<M>> extends Function, ModelFactory<M, U> {
    readonly prototype: M;
}

/** @public */
export declare interface ModelConstructor<M extends Model = Model, U = AnyModel<M>> extends ModelClass<M, U> {
    new (): M;
}

/** @public */
export declare interface ModelContext {
    readonly updateTime: number;
}

/** @public */
export declare const ModelContext: {
    current: ModelContext | null;
    create(): ModelContext;
};

/** @public */
export declare type ModelContextType<M extends Model> = M extends {
    readonly contextType?: Class<infer T>;
} ? T : never;

/** @public */
export declare type ModelCreator<F extends (abstract new (...args: any) => M) & Creatable<InstanceType<F>>, M extends Model = Model> = (abstract new (...args: any) => InstanceType<F>) & Creatable<InstanceType<F>>;

/** @public */
export declare interface ModelFactory<M extends Model = Model, U = AnyModel<M>> extends Creatable<M>, FromAny<M, U> {
    fromInit(init: InitType<M>): M;
}

/** @public */
export declare type ModelFlags = ComponentFlags;

/** @public */
export declare interface ModelInit extends ComponentInit {
    type?: Creatable<Model>;
    key?: string;
    traits?: AnyTrait[];
    children?: AnyModel[];
}

/** @public */
export declare interface ModelObserver<M extends Model = Model> extends ComponentObserver<M> {
    modelWillAttachParent?(parent: Model, model: M): void;
    modelDidAttachParent?(parent: Model, model: M): void;
    modelWillDetachParent?(parent: Model, model: M): void;
    modelDidDetachParent?(parent: Model, model: M): void;
    modelWillInsertChild?(child: Model, target: Model | null, model: M): void;
    modelDidInsertChild?(child: Model, target: Model | null, model: M): void;
    modelWillRemoveChild?(child: Model, model: M): void;
    modelDidRemoveChild?(child: Model, model: M): void;
    modelWillInsertTrait?(trait: Trait, target: Trait | null, model: M): void;
    modelDidInsertTrait?(trait: Trait, target: Trait | null, model: M): void;
    modelWillRemoveTrait?(trait: Trait, model: M): void;
    modelDidRemoveTrait?(trait: Trait, model: M): void;
    modelWillMount?(model: M): void;
    modelDidMount?(model: M): void;
    modelWillUnmount?(model: M): void;
    modelDidUnmount?(model: M): void;
    modelWillMutate?(modelContext: ModelContextType<M>, model: M): void;
    modelDidMutate?(modelContext: ModelContextType<M>, model: M): void;
    modelWillAggregate?(modelContext: ModelContextType<M>, model: M): void;
    modelDidAggregate?(modelContext: ModelContextType<M>, model: M): void;
    modelWillCorrelate?(modelContext: ModelContextType<M>, model: M): void;
    modelDidCorrelate?(modelContext: ModelContextType<M>, model: M): void;
    modelWillValidate?(modelContext: ModelContextType<M>, model: M): void;
    modelDidValidate?(modelContext: ModelContextType<M>, model: M): void;
    modelWillReconcile?(modelContext: ModelContextType<M>, model: M): void;
    modelDidReconcile?(modelContext: ModelContextType<M>, model: M): void;
    modelWillStartConsuming?(model: M): void;
    modelDidStartConsuming?(model: M): void;
    modelWillStopConsuming?(model: M): void;
    modelDidStopConsuming?(model: M): void;
}

/** @public */
export declare interface ModelRef<O = unknown, M extends Model = Model> extends ModelRelation<O, M> {
    (): M | null;
    (model: AnyModel<M> | null, target?: Model | null, key?: string): O;
    /** @override */
    get fastenerType(): Proto<ModelRef<any, any>>;
    /** @protected @override */
    onInherit(superFastener: Fastener): void;
    readonly model: M | null;
    getModel(): M;
    setModel(model: AnyModel<M> | null, target?: Model | null, key?: string): M | null;
    attachModel(model?: AnyModel<M>, target?: Model | null): M;
    detachModel(): M | null;
    insertModel(parent?: Model | null, model?: AnyModel<M>, target?: Model | null, key?: string): M;
    removeModel(): M | null;
    deleteModel(): M | null;
    /** @internal @override */
    bindModel(model: Model, target: Model | null): void;
    /** @internal @override */
    unbindModel(model: Model): void;
    /** @override */
    detectModel(model: Model): M | null;
    /** @internal */
    get key(): string | undefined;
}

/** @public */
export declare const ModelRef: ModelRefFactory<ModelRef<any, any>>;

/** @public */
export declare interface ModelRefClass<F extends ModelRef<any, any> = ModelRef<any, any>> extends ModelRelationClass<F> {
}

/** @public */
export declare type ModelRefDescriptor<O = unknown, M extends Model = Model, I = {}> = ThisType<ModelRef<O, M> & I> & ModelRefInit<M> & Partial<I>;

/** @public */
export declare interface ModelRefFactory<F extends ModelRef<any, any> = ModelRef<any, any>> extends ModelRefClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ModelRefFactory<F> & I;
    define<O, M extends Model = Model>(className: string, descriptor: ModelRefDescriptor<O, M>): ModelRefFactory<ModelRef<any, M>>;
    define<O, M extends Model = Model>(className: string, descriptor: {
        observes: boolean;
    } & ModelRefDescriptor<O, M, ObserverType<M>>): ModelRefFactory<ModelRef<any, M>>;
    define<O, M extends Model = Model, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ModelRefDescriptor<O, M, I>): ModelRefFactory<ModelRef<any, M> & I>;
    define<O, M extends Model = Model, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & ModelRefDescriptor<O, M, I & ObserverType<M>>): ModelRefFactory<ModelRef<any, M> & I>;
    <O, M extends Model = Model>(descriptor: ModelRefDescriptor<O, M>): PropertyDecorator;
    <O, M extends Model = Model>(descriptor: {
        observes: boolean;
    } & ModelRefDescriptor<O, M, ObserverType<M>>): PropertyDecorator;
    <O, M extends Model = Model, I = {}>(descriptor: {
        implements: unknown;
    } & ModelRefDescriptor<O, M, I>): PropertyDecorator;
    <O, M extends Model = Model, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & ModelRefDescriptor<O, M, I & ObserverType<M>>): PropertyDecorator;
}

/** @public */
export declare interface ModelRefInit<M extends Model = Model> extends ModelRelationInit<M> {
    extends?: {
        prototype: ModelRef<any, any>;
    } | string | boolean | null;
    key?: string | boolean;
}

/** @internal */
export declare type ModelRefType<F extends ModelRef<any, any>> = F extends ModelRef<any, infer M> ? M : never;

/** @public */
export declare interface ModelRelation<O = unknown, M extends Model = Model> extends Fastener<O> {
    /** @override */
    get fastenerType(): Proto<ModelRelation<any, any>>;
    /** @protected */
    initModel(model: M): void;
    /** @protected */
    willAttachModel(model: M, target: Model | null): void;
    /** @protected */
    onAttachModel(model: M, target: Model | null): void;
    /** @protected */
    didAttachModel(model: M, target: Model | null): void;
    /** @protected */
    deinitModel(model: M): void;
    /** @protected */
    willDetachModel(model: M): void;
    /** @protected */
    onDetachModel(model: M): void;
    /** @protected */
    didDetachModel(model: M): void;
    /** @internal @protected */
    get parentModel(): Model | null;
    /** @internal @protected */
    insertChild(parent: Model, child: M, target: Model | null, key: string | undefined): void;
    /** @internal */
    bindModel(model: Model, target: Model | null): void;
    /** @internal */
    unbindModel(model: Model): void;
    detectModel(model: Model): M | null;
    createModel(): M;
    /** @internal @protected */
    fromAny(value: AnyModel<M>): M;
    /** @internal @protected */
    get type(): ModelFactory<M> | undefined;
    /** @internal @protected */
    get binds(): boolean | undefined;
    /** @internal @protected */
    get observes(): boolean | undefined;
    /** @internal @override */
    get lazy(): boolean;
    /** @internal @override */
    get static(): string | boolean;
}

/** @public */
export declare const ModelRelation: ModelRelationFactory<ModelRelation<any, any>>;

/** @public */
export declare interface ModelRelationClass<F extends ModelRelation<any, any> = ModelRelation<any, any>> extends FastenerClass<F> {
}

/** @public */
export declare type ModelRelationDescriptor<O = unknown, M extends Model = Model, I = {}> = ThisType<ModelRelation<O, M> & I> & ModelRelationInit<M> & Partial<I>;

/** @public */
export declare interface ModelRelationFactory<F extends ModelRelation<any, any> = ModelRelation<any, any>> extends ModelRelationClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ModelRelationFactory<F> & I;
    define<O, M extends Model = Model>(className: string, descriptor: ModelRelationDescriptor<O, M>): ModelRelationFactory<ModelRelation<any, M>>;
    define<O, M extends Model = Model>(className: string, descriptor: {
        observes: boolean;
    } & ModelRelationDescriptor<O, M, ObserverType<M>>): ModelRelationFactory<ModelRelation<any, M>>;
    define<O, M extends Model = Model, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ModelRelationDescriptor<O, M, I>): ModelRelationFactory<ModelRelation<any, M> & I>;
    define<O, M extends Model = Model, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & ModelRelationDescriptor<O, M, I & ObserverType<M>>): ModelRelationFactory<ModelRelation<any, M> & I>;
    <O, M extends Model = Model>(descriptor: ModelRelationDescriptor<O, M>): PropertyDecorator;
    <O, M extends Model = Model>(descriptor: {
        observes: boolean;
    } & ModelRelationDescriptor<O, M, ObserverType<M>>): PropertyDecorator;
    <O, M extends Model = Model, I = {}>(descriptor: {
        implements: unknown;
    } & ModelRelationDescriptor<O, M, I>): PropertyDecorator;
    <O, M extends Model = Model, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & ModelRelationDescriptor<O, M, I & ObserverType<M>>): PropertyDecorator;
}

/** @public */
export declare interface ModelRelationInit<M extends Model = Model> extends FastenerInit {
    extends?: {
        prototype: ModelRelation<any, any>;
    } | string | boolean | null;
    type?: ModelFactory<M>;
    binds?: boolean;
    observes?: boolean;
    initModel?(model: M): void;
    willAttachModel?(model: M, target: Model | null): void;
    didAttachModel?(model: M, target: Model | null): void;
    deinitModel?(model: M): void;
    willDetachModel?(model: M): void;
    didDetachModel?(model: M): void;
    parentModel?: Model | null;
    insertChild?(parent: Model, child: M, target: Model | null, key: string | undefined): void;
    detectModel?(model: Model): M | null;
    createModel?(): M;
    fromAny?(value: AnyModel<M>): M;
}

/** @internal */
export declare type ModelRelationType<F extends ModelRelation<any, any>> = F extends ModelRelation<any, infer M> ? M : never;

/** @public */
export declare interface ModelSet<O = unknown, M extends Model = Model> extends ModelRelation<O, M> {
    (model: AnyModel<M>): O;
    /** @override */
    get fastenerType(): Proto<ModelSet<any, any>>;
    /** @internal */
    readonly models: {
        readonly [modelId: number]: M | undefined;
    };
    readonly modelCount: number;
    hasModel(model: Model): boolean;
    addModel(model?: AnyModel<M>, target?: Model | null, key?: string): M;
    attachModel(model?: AnyModel<M>, target?: Model | null): M;
    detachModel(model: M): M | null;
    insertModel(parent?: Model | null, model?: AnyModel<M>, target?: Model | null, key?: string): M;
    removeModel(model: M): M | null;
    deleteModel(model: M): M | null;
    /** @internal @override */
    bindModel(model: Model, target: Model | null): void;
    /** @internal @override */
    unbindModel(model: Model): void;
    /** @override */
    detectModel(model: Model): M | null;
    /** @internal @protected */
    key(model: M): string | undefined;
    get sorted(): boolean;
    /** @internal */
    initSorted(sorted: boolean): void;
    sort(sorted?: boolean): this;
    /** @protected */
    willSort(parent: Model | null): void;
    /** @protected */
    onSort(parent: Model | null): void;
    /** @protected */
    didSort(parent: Model | null): void;
    /** @internal @protected */
    sortChildren(parent: Model): void;
    /** @internal */
    compareChildren(a: Model, b: Model): number;
    /** @internal @protected */
    compare(a: M, b: M): number;
}

/** @public */
export declare const ModelSet: ModelSetFactory<ModelSet<any, any>>;

/** @public */
export declare interface ModelSetClass<F extends ModelSet<any, any> = ModelSet<any, any>> extends ModelRelationClass<F> {
    /** @internal */
    readonly SortedFlag: FastenerFlags;
    /** @internal @override */
    readonly FlagShift: number;
    /** @internal @override */
    readonly FlagMask: FastenerFlags;
}

/** @public */
export declare type ModelSetDescriptor<O = unknown, M extends Model = Model, I = {}> = ThisType<ModelSet<O, M> & I> & ModelSetInit<M> & Partial<I>;

/** @public */
export declare interface ModelSetFactory<F extends ModelSet<any, any> = ModelSet<any, any>> extends ModelSetClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ModelSetFactory<F> & I;
    define<O, M extends Model = Model>(className: string, descriptor: ModelSetDescriptor<O, M>): ModelSetFactory<ModelSet<any, M>>;
    define<O, M extends Model = Model>(className: string, descriptor: {
        observes: boolean;
    } & ModelSetDescriptor<O, M, ObserverType<M>>): ModelSetFactory<ModelSet<any, M>>;
    define<O, M extends Model = Model, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ModelSetDescriptor<O, M, I>): ModelSetFactory<ModelSet<any, M> & I>;
    define<O, M extends Model = Model, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & ModelSetDescriptor<O, M, I & ObserverType<M>>): ModelSetFactory<ModelSet<any, M> & I>;
    <O, M extends Model = Model>(descriptor: ModelSetDescriptor<O, M>): PropertyDecorator;
    <O, M extends Model = Model>(descriptor: {
        observes: boolean;
    } & ModelSetDescriptor<O, M, ObserverType<M>>): PropertyDecorator;
    <O, M extends Model = Model, I = {}>(descriptor: {
        implements: unknown;
    } & ModelSetDescriptor<O, M, I>): PropertyDecorator;
    <O, M extends Model = Model, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & ModelSetDescriptor<O, M, I & ObserverType<M>>): PropertyDecorator;
}

/** @public */
export declare interface ModelSetInit<M extends Model = Model> extends ModelRelationInit<M> {
    extends?: {
        prototype: ModelSet<any, any>;
    } | string | boolean | null;
    key?(model: M): string | undefined;
    compare?(a: M, b: M): number;
    sorted?: boolean;
    willSort?(parent: Model | null): void;
    didSort?(parent: Model | null): void;
    sortChildren?(parent: Model): void;
    compareChildren?(a: Model, b: Model): number;
}

/** @internal */
export declare type ModelSetType<F extends ModelSet<any, any>> = F extends ModelSet<any, infer M> ? M : never;

/** @public */
export declare interface MomentumGesture<O = unknown, V extends View = View> extends PositionGesture<O, V> {
    /** @internal @override */
    readonly inputs: {
        readonly [inputId: string]: MomentumGestureInput | undefined;
    };
    /** @override */
    getInput(inputId: string | number): MomentumGestureInput | null;
    /** @internal @override */
    createInput(inputId: string, inputType: GestureInputType, isPrimary: boolean, x: number, y: number, t: number): MomentumGestureInput;
    /** @internal @override */
    getOrCreateInput(inputId: string | number, inputType: GestureInputType, isPrimary: boolean, x: number, y: number, t: number): MomentumGestureInput;
    /** @internal @override */
    clearInput(input: MomentumGestureInput): void;
    /** @internal @override */
    clearInputs(): void;
    hysteresis: number;
    acceleration: number;
    velocityMax: number;
    /** @internal */
    viewWillAnimate(viewContext: ViewContext): void;
    /** @internal */
    interrupt(event: Event | null): void;
    /** @internal */
    cancel(event: Event | null): void;
    /** @internal */
    startInteracting(): void;
    /** @protected */
    willStartInteracting(): void;
    /** @protected */
    onStartInteracting(): void;
    /** @protected */
    didStartInteracting(): void;
    /** @internal */
    stopInteracting(): void;
    /** @protected */
    willStopInteracting(): void;
    /** @protected */
    onStopInteracting(): void;
    /** @protected */
    didStopInteracting(): void;
    /** @internal @override */
    onStartPressing(): void;
    /** @internal @override */
    onStopPressing(): void;
    /** @internal @override */
    beginPress(input: MomentumGestureInput, event: Event | null): void;
    /** @protected @override */
    onBeginPress(input: MomentumGestureInput, event: Event | null): void;
    /** @protected @override */
    onMovePress(input: MomentumGestureInput, event: Event | null): void;
    /** @protected @override */
    willEndPress(input: MomentumGestureInput, event: Event | null): void;
    /** @protected @override */
    onEndPress(input: MomentumGestureInput, event: Event | null): void;
    /** @protected @override */
    onCancelPress(input: MomentumGestureInput, event: Event | null): void;
    readonly coastCount: number;
    get coasting(): boolean;
    /** @internal */
    startCoasting(): void;
    /** @protected */
    willStartCoasting(): void;
    /** @protected */
    onStartCoasting(): void;
    /** @protected */
    didStartCoasting(): void;
    /** @internal */
    stopCoasting(): void;
    /** @protected */
    willStopCoasting(): void;
    /** @protected */
    onStopCoasting(): void;
    /** @protected */
    didStopCoasting(): void;
    /** @internal */
    beginCoast(input: MomentumGestureInput, event: Event | null): void;
    /** @protected */
    willBeginCoast(input: MomentumGestureInput, event: Event | null): boolean | void;
    /** @protected */
    onBeginCoast(input: MomentumGestureInput, event: Event | null): void;
    /** @protected */
    didBeginCoast(input: MomentumGestureInput, event: Event | null): void;
    /** @internal */
    endCoast(input: MomentumGestureInput, event: Event | null): void;
    /** @protected */
    willEndCoast(input: MomentumGestureInput, event: Event | null): void;
    /** @protected */
    onEndCoast(input: MomentumGestureInput, event: Event | null): void;
    /** @protected */
    didEndCoast(input: MomentumGestureInput, event: Event | null): void;
    /** @internal */
    doCoast(t: number): void;
    /** @protected */
    willCoast(): void;
    /** @protected */
    onCoast(): void;
    /** @protected */
    didCoast(): void;
    /** @internal */
    integrate(t: number): void;
}

/** @public */
export declare const MomentumGesture: MomentumGestureFactory<MomentumGesture<any, any>>;

/** @public */
export declare interface MomentumGestureClass<G extends MomentumGesture<any, any> = MomentumGesture<any, any>> extends PositionGestureClass<G> {
    /** @internal */
    readonly Hysteresis: number;
    /** @internal */
    readonly Acceleration: number;
    /** @internal */
    readonly VelocityMax: number;
}

/** @public */
export declare type MomentumGestureDescriptor<O = unknown, V extends View = View, I = {}> = ThisType<MomentumGesture<O, V> & I> & MomentumGestureInit<V> & Partial<I>;

/** @public */
export declare interface MomentumGestureFactory<G extends MomentumGesture<any, any> = MomentumGesture<any, any>> extends MomentumGestureClass<G> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): MomentumGestureFactory<G> & I;
    specialize(method: GestureMethod): MomentumGestureFactory | null;
    define<O, V extends View = View>(className: string, descriptor: MomentumGestureDescriptor<O, V>): MomentumGestureFactory<MomentumGesture<any, V>>;
    define<O, V extends View = View>(className: string, descriptor: {
        observes: boolean;
    } & MomentumGestureDescriptor<O, V, ObserverType<V>>): MomentumGestureFactory<MomentumGesture<any, V>>;
    define<O, V extends View = View, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & MomentumGestureDescriptor<O, V, I>): MomentumGestureFactory<MomentumGesture<any, V> & I>;
    define<O, V extends View = View, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & MomentumGestureDescriptor<O, V, I & ObserverType<V>>): MomentumGestureFactory<MomentumGesture<any, V> & I>;
    <O, V extends View = View>(descriptor: MomentumGestureDescriptor<O, V>): PropertyDecorator;
    <O, V extends View = View>(descriptor: {
        observes: boolean;
    } & MomentumGestureDescriptor<O, V, ObserverType<V>>): PropertyDecorator;
    <O, V extends View = View, I = {}>(descriptor: {
        implements: unknown;
    } & MomentumGestureDescriptor<O, V, I>): PropertyDecorator;
    <O, V extends View = View, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & MomentumGestureDescriptor<O, V, I & ObserverType<V>>): PropertyDecorator;
}

/** @public */
export declare interface MomentumGestureInit<V extends View = View> extends PositionGestureInit<V> {
    extends?: {
        prototype: MomentumGesture<any, any>;
    } | string | boolean | null;
    /**
     * The time delta for velocity derivation, in milliseconds.
     */
    hysteresis?: number;
    /**
     * The magnitude of the deceleration on coasting input points in,
     * pixels/millisecond^2. An acceleration of zero disables coasting.
     */
    acceleration?: number;
    /**
     * The maximum magnitude of the velocity of coasting input points,
     * in pixels/millisecond.
     */
    velocityMax?: number;
    willBeginHover?(input: MomentumGestureInput, event: Event | null): void;
    didBeginHover?(input: MomentumGestureInput, event: Event | null): void;
    willEndHover?(input: MomentumGestureInput, event: Event | null): void;
    didEndHover?(input: MomentumGestureInput, event: Event | null): void;
    willStartInteracting?(): void;
    didStartInteracting?(): void;
    willStopInteracting?(): void;
    didStopInteracting?(): void;
    willBeginPress?(input: MomentumGestureInput, event: Event | null): boolean | void;
    didBeginPress?(input: MomentumGestureInput, event: Event | null): void;
    willMovePress?(input: MomentumGestureInput, event: Event | null): void;
    didMovePress?(input: MomentumGestureInput, event: Event | null): void;
    willEndPress?(input: MomentumGestureInput, event: Event | null): void;
    didEndPress?(input: MomentumGestureInput, event: Event | null): void;
    willCancelPress?(input: MomentumGestureInput, event: Event | null): void;
    didCancelPress?(input: MomentumGestureInput, event: Event | null): void;
    willPress?(input: MomentumGestureInput, event: Event | null): void;
    didPress?(input: MomentumGestureInput, event: Event | null): void;
    willLongPress?(input: MomentumGestureInput): void;
    didLongPress?(input: MomentumGestureInput): void;
    willStartCoasting?(): void;
    didStartCoasting?(): void;
    willStopCoasting?(): void;
    didStopCoasting?(): void;
    willBeginCoast?(input: MomentumGestureInput, event: Event | null): boolean | void;
    didBeginCoast?(input: MomentumGestureInput, event: Event | null): void;
    willEndCoast?(input: MomentumGestureInput, event: Event | null): void;
    didEndCoast?(input: MomentumGestureInput, event: Event | null): void;
    willCoast?(): void;
    didCoast?(): void;
}

/** @public */
export declare class MomentumGestureInput extends PositionGestureInput {
    vx: number;
    vy: number;
    ax: number;
    ay: number;
    /** @internal */
    readonly path: {
        x: number;
        y: number;
        t: number;
    }[];
    coasting: boolean;
    constructor(inputId: string, inputType: GestureInputType, isPrimary: boolean, x: number, y: number, t: number);
    /** @internal */
    updatePosition(hysteresis: number): void;
    /** @internal */
    deriveVelocity(vMax: number): void;
    /** @internal */
    integrateVelocity(t: number): void;
}

/** @public */
export declare interface Mood {
    readonly name: string;
}

/** @public */
export declare const Mood: {
    ambient: MoodVector;
    default: MoodVector;
    primary: MoodVector;
    secondary: MoodVector;
    selected: MoodVector;
    disabled: MoodVector;
    inactive: MoodVector;
    warning: MoodVector;
    alert: MoodVector;
    darker: MoodVector;
    lighter: MoodVector;
    contrasted: MoodVector;
    raised: MoodVector;
    covered: MoodVector;
    opaque: MoodVector;
    floating: MoodVector;
    transparent: MoodVector;
    translucent: MoodVector;
    embossed: MoodVector;
    nested: MoodVector;
    hovering: MoodVector;
    navigating: MoodVector;
};

/** @public */
export declare class MoodMatrix<M extends Mood = Feel, N extends Mood = Feel> implements Equals, Debug {
    constructor(rowArray: ReadonlyArray<[M, MoodVector<N>]>, rowIndex: {
        readonly [name: string]: number | undefined;
    }, colArray: ReadonlyArray<[N, MoodVector<M>]>, colIndex: {
        readonly [name: string]: number | undefined;
    });
    /** @internal */
    readonly rowArray: ReadonlyArray<[M, MoodVector<N>]>;
    /** @internal */
    readonly rowIndex: {
        readonly [name: string]: number | undefined;
    };
    /** @internal */
    readonly colArray: ReadonlyArray<[N, MoodVector<M>]>;
    /** @internal */
    readonly colIndex: {
        readonly [name: string]: number | undefined;
    };
    get rowCount(): number;
    get colCount(): number;
    hasRow(rowKey: M): boolean;
    hasRow(rowKey: string): boolean;
    hasCol(colKey: N): boolean;
    hasCol(colKey: string): boolean;
    getRow(rowKey: M): MoodVector<N> | undefined;
    getRow(rowKey: string): MoodVector<N> | undefined;
    getRow(rowIndex: number): MoodVector<N> | undefined;
    getCol(colKey: N): MoodVector<M> | undefined;
    getCol(colKey: string): MoodVector<M> | undefined;
    getCol(colIndex: number): MoodVector<M> | undefined;
    plus(that: MoodMatrix<M, N>): MoodMatrix<M, N>;
    negative(): MoodMatrix<M, N>;
    minus(that: MoodMatrix<M, N>): MoodMatrix<M, N>;
    times(scalar: number): MoodMatrix<M, N>;
    dot(rowKey: M | string | number, col: MoodVector<N>): number | undefined;
    timesCol(col: MoodVector<N>): MoodVector<M>;
    timesCol(col: MoodVector<M & N>, implicitIdentity?: boolean): MoodVector<M | M>;
    timesRow(row: MoodVector<M>): MoodVector<N>;
    timesRow(row: MoodVector<M & N>, implicitIdentity?: boolean): MoodVector<M | M>;
    transform(that: MoodMatrix<N, N>, implicitIdentity?: boolean): MoodMatrix<M, N>;
    /** @internal */
    identityFor(that: MoodMatrix<N, M & N>): MoodMatrix<M, N>;
    row(rowKey: M, row: AnyMoodVector<N> | undefined): MoodMatrix<M, N>;
    col(colKey: N, col: AnyMoodVector<M> | undefined): MoodMatrix<M, N>;
    updatedRow(rowKey: M, updates: MoodVectorUpdates<N>, defaultRow?: AnyMoodVector<N>): MoodMatrix<M, N>;
    updatedRow(rowKey: M & N, updates: MoodVectorUpdates<M & N>, defaultRow?: AnyMoodVector<N> | boolean): MoodMatrix<M | N, N>;
    updatedCol(colKey: N, updates: MoodVectorUpdates<M>, defaultCol?: AnyMoodVector<M>): MoodMatrix<M, N>;
    updatedCol(colKey: M & N, updates: MoodVectorUpdates<M & N>, defaultCol?: AnyMoodVector<M> | boolean): MoodMatrix<M | N, N>;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static empty<M extends Mood = Feel, N extends Mood = Feel>(): MoodMatrix<M, N>;
    static forRows<M extends Mood, N extends Mood>(...rows: [M, AnyMoodVector<N>][]): MoodMatrix<M, N>;
    static forCols<M extends Mood, N extends Mood>(...cols: [N, AnyMoodVector<M>][]): MoodMatrix<M, N>;
    static fromRowArray<M extends Mood, N extends Mood>(rowArray: ReadonlyArray<[M, MoodVector<N>]>, rowIndex?: {
        readonly [name: string]: number | undefined;
    }): MoodMatrix<M, N>;
    static fromColArray<M extends Mood, N extends Mood>(colArray: ReadonlyArray<[N, MoodVector<M>]>, colIndex?: {
        readonly [name: string]: number | undefined;
    }): MoodMatrix<M, N>;
}

/** @public */
export declare class MoodVector<M extends Mood = Feel> implements Equals, Debug {
    constructor(array: ReadonlyArray<[M, number]>, index: {
        readonly [name: string]: number | undefined;
    });
    /** @internal */
    readonly array: ReadonlyArray<[M, number]>;
    /** @internal */
    readonly index: {
        readonly [name: string]: number | undefined;
    };
    get size(): number;
    isEmpty(): boolean;
    has(key: M): boolean;
    has(name: string): boolean;
    get(key: M): number | undefined;
    get(name: string): number | undefined;
    get(index: number): number | undefined;
    getOr<E>(key: M, elseValue: E): number | E;
    getOr<E>(name: string, elseValue: E): number | E;
    getOr<E>(index: number, elseValue: E): number | E;
    updated(key: M, value: number | undefined): MoodVector<M>;
    updated(updates: MoodVectorUpdates<M>): MoodVector<M>;
    plus(that: MoodVector<M>): MoodVector<M>;
    negative(): MoodVector<M>;
    minus(that: MoodVector<M>): MoodVector<M>;
    times(scalar: number): MoodVector<M>;
    dot(that: MoodVector<M>): number | undefined;
    protected copy(array: ReadonlyArray<[M, number]>, index?: {
        readonly [name: string]: number | undefined;
    }): MoodVector<M>;
    forEach<R>(callback: (value: number, key: M) => R | void): R | undefined;
    forEach<R, S>(callback: (this: S, value: number, key: M) => R | void, thisArg: S): R | undefined;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static empty<M extends Mood>(): MoodVector<M>;
    static of<M extends Mood>(...keys: [M, number][]): MoodVector<M>;
    static fromArray<M extends Mood>(array: ReadonlyArray<[M, number]>, index?: {
        [name: string]: number | undefined;
    }): MoodVector<M>;
    static fromAny<M extends Mood>(value: AnyMoodVector<M>): MoodVector<M>;
    /** @internal */
    static index<M extends Mood>(array: ReadonlyArray<[M, unknown]>): {
        readonly [name: string]: number | undefined;
    };
}

/** @public */
export declare type MoodVectorArray<M extends Mood = Feel> = ReadonlyArray<[M, number]>;

/** @public */
export declare type MoodVectorUpdates<M extends Mood = Feel> = ReadonlyArray<[M, number | undefined]>;

/** @internal */
export declare interface MouseMomentumGesture<O = unknown, V extends View = View> extends MomentumGesture<O, V> {
    /** @internal @protected @override */
    attachHoverEvents(view: V): void;
    /** @internal @protected @override */
    detachHoverEvents(view: V): void;
    /** @internal @protected @override */
    attachPressEvents(view: V): void;
    /** @internal @protected @override */
    detachPressEvents(view: V): void;
    /** @internal @protected */
    updateInput(input: MomentumGestureInput, event: MouseEvent): void;
    /** @internal @protected */
    onMouseEnter(event: MouseEvent): void;
    /** @internal @protected */
    onMouseLeave(event: MouseEvent): void;
    /** @internal @protected */
    onMouseDown(event: MouseEvent): void;
    /** @internal @protected */
    onMouseMove(event: MouseEvent): void;
    /** @internal @protected */
    onMouseUp(event: MouseEvent): void;
    /** @internal @protected */
    onMouseLeaveDocument(event: MouseEvent): void;
}

/** @internal */
export declare const MouseMomentumGesture: MomentumGestureFactory<MouseMomentumGesture<any, any>>;

/** @internal */
export declare interface MousePositionGesture<O = unknown, V extends View = View> extends PositionGesture<O, V> {
    /** @internal @protected @override */
    attachHoverEvents(view: V): void;
    /** @internal @protected @override */
    detachHoverEvents(view: V): void;
    /** @internal @protected @override */
    attachPressEvents(view: V): void;
    /** @internal @protected @override */
    detachPressEvents(view: V): void;
    /** @internal @protected */
    updateInput(input: PositionGestureInput, event: MouseEvent): void;
    /** @internal @protected */
    onMouseEnter(event: MouseEvent): void;
    /** @internal @protected */
    onMouseLeave(event: MouseEvent): void;
    /** @internal @protected */
    onMouseDown(event: MouseEvent): void;
    /** @internal @protected */
    onMouseMove(event: MouseEvent): void;
    /** @internal @protected */
    onMouseUp(event: MouseEvent): void;
    /** @internal @protected */
    onMouseLeaveDocument(event: MouseEvent): void;
}

/** @internal */
export declare const MousePositionGesture: PositionGestureFactory<MousePositionGesture<any, any>>;

/** @internal */
export declare interface MouseScaleGesture<O = unknown, V extends View = View, X = unknown, Y = unknown> extends ScaleGesture<O, V, X, Y> {
    /** @internal @protected @override */
    attachHoverEvents(view: V): void;
    /** @internal @protected @override */
    detachHoverEvents(view: V): void;
    /** @internal @protected @override */
    attachPressEvents(view: V): void;
    /** @internal @protected @override */
    detachPressEvents(view: V): void;
    /** @internal @protected */
    updateInput(input: ScaleGestureInput<X, Y>, event: MouseEvent): void;
    /** @internal @protected */
    onMouseEnter(event: MouseEvent): void;
    /** @internal @protected */
    onMouseLeave(event: MouseEvent): void;
    /** @internal @protected */
    onMouseDown(event: MouseEvent): void;
    /** @internal @protected */
    onMouseMove(event: MouseEvent): void;
    /** @internal @protected */
    onMouseUp(event: MouseEvent): void;
    /** @internal @protected */
    onMouseLeaveDocument(event: MouseEvent): void;
    /** @internal @protected */
    onWheel(event: WheelEvent): void;
}

/** @internal */
export declare const MouseScaleGesture: ScaleGestureFactory<MouseScaleGesture<any, any, any, any>>;

/** @internal */
export declare interface MutableHistoryState {
    fragment: string | undefined;
    permanent: {
        [key: string]: string | undefined;
    };
    ephemeral: {
        [key: string]: string | undefined;
    };
}

/** @public */
export declare class NodeView extends View {
    constructor(node: Node);
    readonly observerType?: Class<NodeViewObserver>;
    readonly node: Node;
    setChild<V extends View>(key: string, newChild: V): View | null;
    setChild<F extends ViewCreator<F>>(key: string, factory: F): View | null;
    setChild(key: string, newChild: AnyView | Node | null): View | null;
    appendChild<V extends View>(child: V, key?: string): V;
    appendChild<F extends ViewCreator<F>>(factory: F, key?: string): InstanceType<F>;
    appendChild(child: AnyView | Node, key?: string): View;
    prependChild<V extends View>(child: V, key?: string): V;
    prependChild<F extends ViewCreator<F>>(factory: F, key?: string): InstanceType<F>;
    prependChild(child: AnyView | Node, key?: string): View;
    insertChild<V extends View>(child: V, target: View | Node | null, key?: string): V;
    insertChild<F extends ViewCreator<F>>(factory: F, target: View | null, key?: string): InstanceType<F>;
    insertChild(child: AnyView | Node, target: View | Node | null, key?: string): View;
    /** @internal */
    injectChild<V extends NodeView>(child: V, target: View | Node | null, key?: string): V;
    /** @internal */
    injectChild(child: AnyNodeView, target: View | Node | null, key?: string): View;
    replaceChild<V extends View>(newChild: View, oldChild: V): V;
    replaceChild<V extends View>(newChild: AnyView | Node, oldChild: V): V;
    removeChild<V extends View | Node>(child: V): V;
    removeChild(key: string | View): View | null;
    removeChild(key: string | View | Node): View | Node | null;
    removeChildren(): void;
    /** @internal */
    static isRootView(node: Node): boolean;
    /** @internal */
    static isNodeMounted(node: Node): boolean;
    /** @internal */
    static mount(view: NodeView): void;
    /** @internal */
    mount(): void;
    readonly domProvider: DomProvider<this>;
    text(): string | undefined;
    text(value: string | null | undefined): this;
    get parentTransform(): Transform;
    get clientBounds(): R2Box;
    get pageBounds(): R2Box;
    dispatchEvent(event: Event): boolean;
    on(type: string, listener: EventListenerOrEventListenerObject, options?: AddEventListenerOptions | boolean): this;
    off(type: string, listener: EventListenerOrEventListenerObject, options?: EventListenerOptions | boolean): this;
    init(init: NodeViewInit): void;
    static fromNode<S extends new (node: Node) => InstanceType<S>>(this: S, node: ViewNodeType<InstanceType<S>>): InstanceType<S>;
    static fromNode(node: Node): NodeView;
    static fromAny<S extends abstract new (...args: any) => InstanceType<S>>(this: S, value: AnyNodeView<InstanceType<S>>): InstanceType<S>;
    static fromAny(value: AnyNodeView): NodeView;
}

/** @public */
export declare interface NodeViewClass<V extends NodeView = NodeView, U = AnyNodeView<V>> extends ViewClass<V, U>, NodeViewFactory<V, U> {
}

/** @public */
export declare interface NodeViewConstructor<V extends NodeView = NodeView, U = AnyNodeView<V>> extends NodeViewClass<V, U> {
    new (node: ViewNodeType<V>): V;
}

/** @public */
export declare interface NodeViewFactory<V extends NodeView = NodeView, U = AnyNodeView<V>> extends ViewFactory<V, U> {
    fromNode(node: ViewNodeType<V>): V;
}

/** @public */
export declare interface NodeViewInit extends ViewInit {
    text?: string;
}

/** @public */
export declare interface NodeViewObserver<V extends NodeView = NodeView> extends ViewObserver<V> {
}

/** @internal */
export declare const NumberAttributeAnimator: AttributeAnimatorFactory<AttributeAnimator<any, number | undefined, string>>;

/** @internal */
export declare class NumberLook extends Look<number> {
    combine(combination: number | undefined, value: number, weight: number): number;
    between(a: number, b: number): Interpolator<number>;
    coerce(value: number): number;
}

/** @internal */
export declare const NumberStyleAnimator: StyleAnimatorFactory<StyleAnimator<any, number | undefined, string>>;

/** @internal */
export declare const NumberStyleConstraintAnimator: StyleConstraintAnimatorFactory<StyleConstraintAnimator<any, number | undefined, string>>;

/** @internal */
export declare const NumberThemeAnimator: ThemeAnimatorFactory<ThemeAnimator<any, number | null | undefined, string | number | null | undefined>>;

/** @internal */
export declare const NumberThemeConstraintAnimator: ThemeConstraintAnimatorFactory<ThemeConstraintAnimator<any, number | null | undefined, string | number | null | undefined>>;

/** @public */
export declare class NumberTickGenerator extends TickGenerator<number> {
    /** @internal */
    protected x0: number;
    /** @internal */
    protected dx: number;
    /** @internal */
    protected n: number;
    constructor(x0: number, x1: number, n: number);
    count(): number;
    count(n: number): this;
    domain(): Domain<number>;
    domain(xs: AnyDomain<number>): this;
    domain(x0: number, x1: number): this;
    generate(): number[];
    /** @internal */
    static interval(dx: number, n?: number): number;
}

/** @public */
export declare class OpacityFeel extends Feel {
    combine<T>(look: Look<T, any>, combination: T | undefined, value: T, weight?: number): T;
}

/** @public */
export declare type Overflow = "auto" | "hidden" | "scroll" | "visible";

/** @public */
export declare type OverscrollBehavior = "auto" | "contain" | "none";

/** @public */
export declare type Paint = Color | "none" | "context-fill" | "context-stroke" | "currentColor";

/** @public */
export declare interface PaintingContext extends DrawingContext {
    fillStyle: string | CanvasGradient | CanvasPattern;
    strokeStyle: string | CanvasGradient | CanvasPattern;
    lineWidth: number;
    lineCap: CanvasLineCap;
    lineJoin: CanvasLineJoin;
    miterLimit: number;
    lineDashOffset: number;
    getLineDash(): number[];
    setLineDash(segments: number[]): void;
    beginPath(): void;
    fill(fillRule?: PaintingFillRule): void;
    stroke(): void;
}

/** @public */
export declare type PaintingFillRule = "nonzero" | "evenodd";

/** @public */
export declare abstract class PaintingRenderer extends DrawingRenderer {
    abstract readonly context: PaintingContext;
}

/** @public */
export declare class PathContext implements DrawingContext {
    constructor();
    readonly precision: number;
    setPrecision(precision: number): void;
    /** @internal */
    get anglePrecision(): number;
    /** @internal */
    x0: number;
    /** @internal */
    y0: number;
    /** @internal */
    x1: number;
    /** @internal */
    y1: number;
    /** @internal */
    d: string;
    moveTo(x: number, y: number): void;
    lineTo(x: number, y: number): void;
    quadraticCurveTo(x1: number, y1: number, x: number, y: number): void;
    bezierCurveTo(x1: number, y1: number, x2: number, y2: number, x: number, y: number): void;
    arcTo(x1: number, y1: number, x2: number, y2: number, r: number): void;
    arc(cx: number, cy: number, r: number, a0: number, a1: number, ccw?: boolean): void;
    rect(x: number, y: number, w: number, h: number): void;
    ellipse(cx: number, cy: number, rx: number, ry: number, phi: number, a0: number, a1: number, ccw?: boolean): void;
    closePath(): void;
    toString(): string;
    /** @internal */
    static Epsilon: number;
}

/** @public */
export declare class PathRenderer extends DrawingRenderer {
    constructor(context: PathContext);
    readonly context: PathContext;
    get transform(): Transform;
    get pixelRatio(): number;
}

/** @public */
export declare class PieController extends Controller {
    readonly observerType?: Class<PieControllerObserver>;
    protected createTitleView(title: PieTitle, pieTrait: PieTrait): GraphicsView | string | null;
    protected setTitleView(title: PieTitle | null, pieTrait: PieTrait): void;
    readonly pie: TraitViewRef<this, PieTrait, PieView>;
    static readonly pie: MemberFastenerClass<PieController, "pie">;
    readonly title: ViewRef<this, GraphicsView>;
    static readonly title: MemberFastenerClass<PieController, "title">;
    readonly sliceTiming: Property<this, Timing | boolean | undefined, AnyTiming>;
    readonly slices: TraitViewControllerSet<this, SliceTrait, SliceView, SliceController> & PieControllerSliceExt;
    static readonly slices: MemberFastenerClass<PieController, "slices">;
}

/** @public */
export declare interface PieControllerObserver<C extends PieController = PieController> extends ControllerObserver<C> {
    controllerWillAttachPieTrait?(pieTrait: PieTrait, controller: C): void;
    controllerDidDetachPieTrait?(pieTrait: PieTrait, controller: C): void;
    controllerWillAttachPieView?(pieView: PieView, controller: C): void;
    controllerDidDetachPieView?(pieView: PieView, controller: C): void;
    controllerWillAttachPieTitleView?(titleView: GraphicsView, controller: C): void;
    controllerDidDetachPieTitleView?(titleView: GraphicsView, controller: C): void;
    controllerWillAttachSlice?(sliceController: SliceController, controller: C): void;
    controllerDidDetachSlice?(sliceController: SliceController, controller: C): void;
    controllerWillAttachSliceTrait?(sliceTrait: SliceTrait, sliceController: SliceController, controller: C): void;
    controllerDidDetachSliceTrait?(sliceTrait: SliceTrait, sliceController: SliceController, controller: C): void;
    controllerWillAttachSliceView?(sliceView: SliceView, sliceController: SliceController, controller: C): void;
    controllerDidDetachSliceView?(sliceView: SliceView, sliceController: SliceController, controller: C): void;
    controllerWillSetSliceValue?(newValue: number, oldValue: number, sliceController: SliceController, controller: C): void;
    controllerDidSetSliceValue?(newValue: number, oldValue: number, sliceController: SliceController, controller: C): void;
    controllerWillAttachSliceLabelView?(labelView: GraphicsView, sliceController: SliceController, controller: C): void;
    controllerDidDetachSliceLabelView?(labelView: GraphicsView, sliceController: SliceController, controller: C): void;
    controllerWillAttachSliceLegendView?(legendView: GraphicsView, sliceController: SliceController, controller: C): void;
    controllerDidDetachSliceLegendView?(legendView: GraphicsView, sliceController: SliceController, controller: C): void;
}

/** @public */
export declare interface PieControllerSliceExt {
    attachSliceTrait(sliceTrait: SliceTrait, sliceController: SliceController): void;
    detachSliceTrait(sliceTrait: SliceTrait, sliceController: SliceController): void;
    attachSliceView(sliceView: SliceView, sliceController: SliceController): void;
    detachSliceView(sliceView: SliceView, sliceController: SliceController): void;
    attachSliceLabelView(labelView: GraphicsView, sliceController: SliceController): void;
    detachSliceLabelView(labelView: GraphicsView, sliceController: SliceController): void;
    attachSliceLegendView(legendView: GraphicsView, sliceController: SliceController): void;
    detachSliceLegendView(legendView: GraphicsView, sliceController: SliceController): void;
}

/** @public */
export declare type PieTitle = PieTitleFunction | string;

/** @public */
export declare type PieTitleFunction = (pieTrait: PieTrait) => GraphicsView | string | null;

/** @public */
export declare class PieTrait extends Trait {
    readonly observerType?: Class<PieTraitObserver>;
    readonly title: Property<this, PieTitle | null>;
    static readonly title: MemberFastenerClass<PieTrait, "title">;
    readonly slices: TraitSet<this, SliceTrait>;
    static readonly slices: MemberFastenerClass<PieTrait, "slices">;
    /** @internal */
    protected startConsumingSlices(): void;
    /** @internal */
    protected stopConsumingSlices(): void;
    protected onStartConsuming(): void;
    protected onStopConsuming(): void;
}

/** @public */
export declare interface PieTraitObserver<R extends PieTrait = PieTrait> extends TraitObserver<R> {
    traitWillSetPieTitle?(newTitle: PieTitle | null, oldTitle: PieTitle | null, trait: R): void;
    traitDidSetPieTitle?(newTitle: PieTitle | null, oldTitle: PieTitle | null, trait: R): void;
    traitWillAttachSlice?(sliceTrait: SliceTrait, targetTrait: Trait | null, trait: R): void;
    traitDidDetachSlice?(sliceTrait: SliceTrait, trait: R): void;
}

/** @public */
export declare class PieView extends GraphicsView {
    readonly observerType?: Class<PieViewObserver>;
    readonly limit: Animator<this, number>;
    readonly center: Animator<this, R2Point, AnyR2Point>;
    readonly baseAngle: ThemeAnimator<this, Angle, AnyAngle>;
    readonly innerRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly outerRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly padAngle: ThemeAnimator<this, Angle, AnyAngle>;
    readonly padRadius: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly cornerRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly labelRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly sliceColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly tickAlign: ThemeAnimator<this, number>;
    readonly tickRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly tickLength: ThemeAnimator<this, Length, AnyLength>;
    readonly tickWidth: ThemeAnimator<this, Length, AnyLength>;
    readonly tickPadding: ThemeAnimator<this, Length, AnyLength>;
    readonly tickColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly font: ThemeAnimator<this, Font | null, AnyFont | null>;
    readonly textColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly title: ViewRef<this, GraphicsView & Initable<GraphicsViewInit | string>>;
    static readonly title: MemberFastenerClass<PieView, "title">;
    readonly slices: ViewSet<this, SliceView> & PieViewSliceExt;
    static readonly slices: MemberFastenerClass<PieView, "slices">;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected layoutPie(frame: R2Box): void;
    init(init: PieViewInit): void;
}

/** @public */
export declare interface PieViewInit extends GraphicsViewInit {
    limit?: number;
    center?: AnyR2Point;
    baseAngle?: AnyAngle;
    innerRadius?: AnyLength;
    outerRadius?: AnyLength;
    padAngle?: AnyAngle;
    padRadius?: AnyLength | null;
    cornerRadius?: AnyLength;
    labelRadius?: AnyLength;
    sliceColor?: AnyColor;
    tickAlign?: number;
    tickRadius?: AnyLength;
    tickLength?: AnyLength;
    tickWidth?: AnyLength;
    tickPadding?: AnyLength;
    tickColor?: AnyColor;
    font?: AnyFont;
    textColor?: AnyColor;
    title?: GraphicsView | string;
    slices?: AnySliceView[];
}

/** @public */
export declare interface PieViewObserver<V extends PieView = PieView> extends ViewObserver<V> {
    viewWillAttachPieTitle?(titleView: GraphicsView, view: V): void;
    viewDidDetachPieTitle?(titleView: GraphicsView, view: V): void;
    viewWillAttachSlice?(sliceView: SliceView, targetView: View | null, view: V): void;
    viewDidDetachSlice?(sliceView: SliceView, view: V): void;
}

/** @public */
export declare interface PieViewSliceExt {
    attachLabelView(labelView: GraphicsView): void;
    detachLabelView(labelView: GraphicsView): void;
    attachLegendView(legendView: GraphicsView): void;
    detachLegendView(legendView: GraphicsView): void;
}

/** @public */
export declare abstract class PlotController<X = unknown, Y = unknown> extends DataSetController<X, Y> {
    readonly observerType?: Class<PlotControllerObserver<X, Y>>;
    readonly plotTiming: Property<this, Timing | boolean | undefined, AnyTiming>;
    abstract readonly plot: TraitViewRef<this, PlotTrait<X, Y>, PlotView<X, Y>>;
    static fromTrait<X, Y>(plotTrait: PlotTrait<X, Y>): PlotController<X, Y>;
}

/** @public */
export declare interface PlotControllerObserver<X = unknown, Y = unknown, C extends PlotController<X, Y> = PlotController<X, Y>> extends DataSetControllerObserver<X, Y, C> {
    controllerWillAttachPlotTrait?(plotTrait: PlotTrait<X, Y>, controller: C): void;
    controllerDidDetachPlotTrait?(plotTrait: PlotTrait<X, Y>, controller: C): void;
    controllerWillAttachPlotView?(plotView: PlotView<X, Y>, controller: C): void;
    controllerDidDetachPlotView?(plotView: PlotView<X, Y>, controller: C): void;
}

/** @public */
export declare class PlotTrait<X = unknown, Y = unknown> extends Trait {
    readonly observerType?: Class<PlotTraitObserver<X, Y>>;
    readonly dataSet: TraitRef<this, DataSetTrait<X, Y>>;
    static readonly dataSet: MemberFastenerClass<PlotTrait, "dataSet">;
    protected onStartConsuming(): void;
    protected onStopConsuming(): void;
}

/** @public */
export declare interface PlotTraitObserver<X = unknown, Y = unknown, R extends PlotTrait<X, Y> = PlotTrait<X, Y>> extends TraitObserver<R> {
    traitWillAttachDataSet?(dataSetTrait: DataSetTrait<X, Y>, trait: R): void;
    traitDidDetachDataSet?(dataSetTrait: DataSetTrait<X, Y>, trait: R): void;
}

/** @public */
export declare interface PlotView<X = unknown, Y = unknown> extends GraphicsView, ScaledXYView<X, Y> {
    /** @override */
    readonly observerType?: Class<PlotViewObserver<X, Y>>;
    readonly xScale: Animator<this, ContinuousScale<X, number> | null, string>;
    readonly yScale: Animator<this, ContinuousScale<Y, number> | null, string>;
    xDomain(): Domain<X> | null;
    xDomain(xDomain: Domain<X> | null, timing?: AnyTiming | boolean): this;
    xDomain(xMin: X, xMax: X, timing?: AnyTiming | boolean): this;
    yDomain(): Domain<Y> | null;
    yDomain(yDomain: Domain<Y> | null, timing?: AnyTiming | boolean): this;
    yDomain(yMin: Y, yMax: Y, timingtimingtiming?: AnyTiming | boolean): this;
    xRange(): Range_2<number> | null;
    yRange(): Range_2<number> | null;
    xRangePadding(): readonly [number, number];
    yRangePadding(): readonly [number, number];
    readonly xDataDomain: Domain<X> | null;
    readonly yDataDomain: Domain<Y> | null;
    readonly xDataRange: Range_2<number> | null;
    readonly yDataRange: Range_2<number> | null;
}

/** @public */
export declare interface PlotViewDataPointExt<X = unknown, Y = unknown> {
    attachDataPointLabelView(labelView: GraphicsView): void;
    detachDataPointLabelView(labelView: GraphicsView): void;
}

/** @public */
export declare interface PlotViewInit<X = unknown, Y = unknown> extends GraphicsViewInit {
    xScale?: ContinuousScale<X, number>;
    yScale?: ContinuousScale<Y, number>;
    data?: AnyDataPointView<X, Y>[];
    font?: AnyFont;
    textColor?: AnyColor;
}

/** @public */
export declare interface PlotViewObserver<X = unknown, Y = unknown, V extends PlotView<X, Y> = PlotView<X, Y>> extends ScaledXYViewObserver<X, Y, V> {
    viewWillAttachDataPoint?(dataPointView: DataPointView<X, Y>, targetView: View | null, view: V): void;
    viewDidDetachDataPoint?(dataPointView: DataPointView<X, Y>, view: V): void;
}

/** @public */
export declare type PointerEvents = "all" | "auto" | "fill" | "none" | "painted" | "stroke" | "visible" | "visibleFill" | "visiblePainted" | "visibleStroke";

/** @internal */
export declare interface PointerMomentumGesture<O = unknown, V extends View = View> extends MomentumGesture<O, V> {
    /** @internal @protected @override */
    attachHoverEvents(view: V): void;
    /** @internal @protected @override */
    detachHoverEvents(view: V): void;
    /** @internal @protected @override */
    attachPressEvents(view: V): void;
    /** @internal @protected @override */
    detachPressEvents(view: V): void;
    /** @internal @protected */
    updateInput(input: MomentumGestureInput, event: PointerEvent): void;
    /** @internal @protected */
    onPointerEnter(event: PointerEvent): void;
    /** @internal @protected */
    onPointerLeave(event: PointerEvent): void;
    /** @internal @protected */
    onPointerDown(event: PointerEvent): void;
    /** @internal @protected */
    onPointerMove(event: PointerEvent): void;
    /** @internal @protected */
    onPointerUp(event: PointerEvent): void;
    /** @internal @protected */
    onPointerCancel(event: PointerEvent): void;
    /** @internal @protected */
    onPointerLeaveDocument(event: PointerEvent): void;
}

/** @internal */
export declare const PointerMomentumGesture: MomentumGestureFactory<PointerMomentumGesture<any, any>>;

/** @internal */
export declare interface PointerPositionGesture<O = unknown, V extends View = View> extends PositionGesture<O, V> {
    /** @internal @protected @override */
    attachHoverEvents(view: V): void;
    /** @internal @protected @override */
    detachHoverEvents(view: V): void;
    /** @internal @protected @override */
    attachPressEvents(view: V): void;
    /** @internal @protected @override */
    detachPressEvents(view: V): void;
    /** @internal @protected */
    updateInput(input: PositionGestureInput, event: PointerEvent): void;
    /** @internal @protected */
    onPointerEnter(event: PointerEvent): void;
    /** @internal @protected */
    onPointerLeave(event: PointerEvent): void;
    /** @internal @protected */
    onPointerDown(event: PointerEvent): void;
    /** @internal @protected */
    onPointerMove(event: PointerEvent): void;
    /** @internal @protected */
    onPointerUp(event: PointerEvent): void;
    /** @internal @protected */
    onPointerCancel(event: PointerEvent): void;
    /** @internal @protected */
    onPointerLeaveDocument(event: PointerEvent): void;
}

/** @internal */
export declare const PointerPositionGesture: PositionGestureFactory<PointerPositionGesture<any, any>>;

/** @internal */
export declare interface PointerScaleGesture<O = unknown, V extends View = View, X = unknown, Y = unknown> extends ScaleGesture<O, V, X, Y> {
    /** @internal @protected @override */
    attachHoverEvents(view: V): void;
    /** @internal @protected @override */
    detachHoverEvents(view: V): void;
    /** @internal @protected @override */
    attachPressEvents(view: V): void;
    /** @internal @protected @override */
    detachPressEvents(view: V): void;
    /** @internal @protected */
    updateInput(input: ScaleGestureInput<X, Y>, event: PointerEvent): void;
    /** @internal @protected */
    onPointerEnter(event: PointerEvent): void;
    /** @internal @protected */
    onPointerLeave(event: PointerEvent): void;
    /** @internal @protected */
    onPointerDown(event: PointerEvent): void;
    /** @internal @protected */
    onPointerMove(event: PointerEvent): void;
    /** @internal @protected */
    onPointerUp(event: PointerEvent): void;
    /** @internal @protected */
    onPointerCancel(event: PointerEvent): void;
    /** @internal @protected */
    onPointerLeaveDocument(event: PointerEvent): void;
    /** @internal @protected */
    onWheel(event: WheelEvent): void;
}

/** @internal */
export declare const PointerScaleGesture: ScaleGestureFactory<PointerScaleGesture<any, any, any, any>>;

/** @public */
export declare class PolygonIcon extends FilledIcon implements Interpolate<PolygonIcon>, Equals, Equivalent, Debug {
    constructor(sides: number, rotation: Angle, fillColor: Color | null, fillLook: Look<Color> | null, moodModifier: MoodMatrix | null);
    readonly sides: number;
    readonly rotation: Angle;
    readonly fillColor: Color | null;
    withFillColor(fillColor: Color | null): PolygonIcon;
    readonly fillLook: Look<Color> | null;
    withFillLook(fillLook: Look<Color> | null): PolygonIcon;
    readonly moodModifier: MoodMatrix | null;
    withMoodModifier(moodModifier: MoodMatrix | null): PolygonIcon;
    modifyMood(feel: Feel, updates: MoodVectorUpdates<Feel>): PolygonIcon;
    isThemed(): boolean;
    withTheme(theme: ThemeMatrix, mood: MoodVector): PolygonIcon;
    render(renderer: GraphicsRenderer, frame: R2Box): void;
    paint(context: PaintingContext, frame: R2Box): void;
    draw(context: DrawingContext, frame: R2Box): void;
    protected copy(sides: number, rotation: Angle, fillColor: Color | null, fillLook: Look<Color> | null, moodModifier: MoodMatrix | null): PolygonIcon;
    interpolateTo(that: PolygonIcon): Interpolator<PolygonIcon>;
    interpolateTo(that: unknown): Interpolator<PolygonIcon> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static create(sides: number, rotation?: AnyAngle): PolygonIcon;
}

/** @internal */
export declare interface PolygonIconInterpolator extends Interpolator<PolygonIcon> {
    /** @internal */
    readonly sides: number;
    /** @internal */
    readonly rotationInterpolator: Interpolator<Angle>;
    /** @internal */
    readonly fillColorInterpolator: Interpolator<Color | null>;
    /** @internal */
    readonly fillLook: Look<Color> | null;
    /** @internal */
    readonly moodModifier: MoodMatrix | null;
    readonly 0: PolygonIcon;
    readonly 1: PolygonIcon;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const PolygonIconInterpolator: {
    (i0: PolygonIcon, i1: PolygonIcon): PolygonIconInterpolator;
    /** @internal */
    prototype: PolygonIconInterpolator;
};

/** @public */
export declare type PopoverPlacement = "none" | "above" | "below" | "over" | "top" | "bottom" | "right" | "left";

/** @public */
export declare class PopoverView extends HtmlView implements Modal {
    constructor(node: HTMLElement);
    readonly observerType?: Class<PopoverViewObserver>;
    protected initArrow(): void;
    protected createArrow(): HtmlView | null;
    /** @internal */
    readonly displayState: number;
    /** @internal */
    setDisplayState(displayState: number): void;
    readonly backgroundColor: StyleAnimator<this, Color | null, AnyColor | null>;
    /** @internal */
    readonly displayPhase: ThemeAnimator<this, number>;
    readonly placementGap: ThemeAnimator<this, Length, AnyLength>;
    readonly arrowWidth: ThemeAnimator<this, Length, AnyLength>;
    readonly arrowHeight: ThemeAnimator<this, Length, AnyLength>;
    readonly source: ViewRef<this, View>;
    static readonly source: MemberFastenerClass<PopoverView, "source">;
    setSource(sourceView: View | null): void;
    get modalView(): View | null;
    get modalState(): ModalState;
    isShown(): boolean;
    isHidden(): boolean;
    readonly modality: boolean | number;
    showModal(options: ModalOptions, timing?: AnyTiming | boolean): void;
    protected willShowPopover(): void;
    protected didShowPopover(): void;
    hideModal(timing?: AnyTiming | boolean): void;
    protected willHidePopover(): void;
    protected didHidePopover(): void;
    /** @internal */
    readonly allowedPlacement: PopoverPlacement[];
    placement(): ReadonlyArray<PopoverPlacement>;
    placement(placement: ReadonlyArray<PopoverPlacement>): this;
    /** @internal */
    readonly currentPlacement: PopoverPlacement;
    readonly placementFrame: Property<this, R2Box | null, AnyR2Box | null>;
    readonly dropdown: Property<this, boolean>;
    protected onMount(): void;
    protected onUnmount(): void;
    protected attachEvents(): void;
    protected detachEvents(): void;
    protected needsProcess(processFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    protected onAnimate(viewContext: ViewContextType<this>): void;
    protected applyDisplayPhase(displayPhase: number): void;
    protected onLayout(viewContext: ViewContextType<this>): void;
    /** @internal */
    readonly sourceFrame: R2Box | null;
    place(force?: boolean): PopoverPlacement;
    /** @internal */
    protected placePopover(sourceView: View, sourceFrame: R2Box): PopoverPlacement;
    protected willPlacePopover(placement: PopoverPlacement): void;
    protected onPlacePopover(placement: PopoverPlacement): void;
    protected didPlacePopover(placement: PopoverPlacement): void;
    /** @internal */
    protected placeArrow(sourceView: View, sourceFrame: R2Box, arrow: HtmlView, placement: PopoverPlacement): void;
    protected onClick(event: Event): void;
    init(init: PopoverViewInit): void;
    /** @internal */
    static readonly HiddenState: number;
    /** @internal */
    static readonly HidingState: number;
    /** @internal */
    static readonly HideState: number;
    /** @internal */
    static readonly ShownState: number;
    /** @internal */
    static readonly ShowingState: number;
    /** @internal */
    static readonly ShowState: number;
}

/** @public */
export declare interface PopoverViewInit extends HtmlViewInit {
    source?: View;
    placement?: PopoverPlacement[];
    placementFrame?: R2Box;
    arrowWidth?: AnyLength;
    arrowHeight?: AnyLength;
}

/** @public */
export declare interface PopoverViewObserver<V extends PopoverView = PopoverView> extends HtmlViewObserver<V> {
    popoverWillAttachSource?(sourceView: View, view: V): void;
    popoverDidDetachSource?(sourceView: View, view: V): void;
    popoverWillPlace?(placement: PopoverPlacement, view: V): void;
    popoverDidPlace?(placement: PopoverPlacement, view: V): void;
    popoverWillShow?(view: V): void;
    popoverDidShow?(view: V): void;
    popoverWillHide?(view: V): void;
    popoverDidHide?(view: V): void;
}

/** @public */
export declare type Position = "absolute" | "fixed" | "relative" | "static" | "sticky";

/** @public */
export declare interface PositionGesture<O = unknown, V extends View = View> extends Gesture<O, V> {
    /** @internal @protected @override */
    attachEvents(view: V): void;
    /** @internal @protected @override */
    detachEvents(view: V): void;
    /** @internal @protected */
    attachHoverEvents(view: V): void;
    /** @internal @protected */
    detachHoverEvents(view: V): void;
    /** @internal @protected */
    attachPressEvents(view: V): void;
    /** @internal @protected */
    detachPressEvents(view: V): void;
    /** @internal @override */
    readonly inputs: {
        readonly [inputId: string]: PositionGestureInput | undefined;
    };
    /** @override */
    getInput(inputId: string | number): PositionGestureInput | null;
    /** @internal @override */
    createInput(inputId: string, inputType: GestureInputType, isPrimary: boolean, x: number, y: number, t: number): PositionGestureInput;
    /** @internal */
    getOrCreateInput(inputId: string | number, inputType: GestureInputType, isPrimary: boolean, x: number, y: number, t: number): PositionGestureInput;
    /** @internal @override */
    clearInput(input: PositionGestureInput): void;
    /** @internal @override */
    clearInputs(): void;
    readonly hoverCount: number;
    get hovering(): boolean;
    /** @internal */
    startHovering(): void;
    /** @protected */
    willStartHovering(): void;
    /** @protected */
    onStartHovering(): void;
    /** @protected */
    didStartHovering(): void;
    /** @internal */
    stopHovering(): void;
    /** @protected */
    willStopHovering(): void;
    /** @protected */
    onStopHovering(): void;
    /** @protected */
    didStopHovering(): void;
    /** @internal */
    beginHover(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    willBeginHover(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    onBeginHover(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    didBeginHover(input: PositionGestureInput, event: Event | null): void;
    /** @internal */
    endHover(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    willEndHover(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    onEndHover(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    didEndHover(input: PositionGestureInput, event: Event | null): void;
    readonly pressCount: number;
    get pressing(): boolean;
    /** @internal */
    startPressing(): void;
    /** @protected */
    willStartPressing(): void;
    /** @protected */
    onStartPressing(): void;
    /** @protected */
    didStartPressing(): void;
    /** @internal */
    stopPressing(): void;
    /** @protected */
    willStopPressing(): void;
    /** @protected */
    onStopPressing(): void;
    /** @protected */
    didStopPressing(): void;
    /** @internal */
    beginPress(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    willBeginPress(input: PositionGestureInput, event: Event | null): boolean | void;
    /** @protected */
    onBeginPress(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    didBeginPress(input: PositionGestureInput, event: Event | null): void;
    /** @internal */
    movePress(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    willMovePress(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    onMovePress(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    didMovePress(input: PositionGestureInput, event: Event | null): void;
    /** @internal */
    endPress(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    willEndPress(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    onEndPress(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    didEndPress(input: PositionGestureInput, event: Event | null): void;
    /** @internal */
    cancelPress(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    willCancelPress(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    onCancelPress(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    didCancelPress(input: PositionGestureInput, event: Event | null): void;
    /** @internal */
    press(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    willPress(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    onPress(input: PositionGestureInput, event: Event | null): void;
    /** @protected */
    didPress(input: PositionGestureInput, event: Event | null): void;
    /** @internal */
    longPress(input: PositionGestureInput): void;
    /** @protected */
    willLongPress(input: PositionGestureInput): void;
    /** @protected */
    onLongPress(input: PositionGestureInput): void;
    /** @protected */
    didLongPress(input: PositionGestureInput): void;
}

/** @public */
export declare const PositionGesture: PositionGestureFactory<PositionGesture<any, any>>;

/** @public */
export declare interface PositionGestureClass<G extends PositionGesture<any, any> = PositionGesture<any, any>> extends GestureClass<G> {
}

/** @public */
export declare type PositionGestureDescriptor<O = unknown, V extends View = View, I = {}> = ThisType<PositionGesture<O, V> & I> & PositionGestureInit<V> & Partial<I>;

/** @public */
export declare interface PositionGestureFactory<G extends PositionGesture<any, any> = PositionGesture<any, any>> extends PositionGestureClass<G> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): PositionGestureFactory<G> & I;
    specialize(method: GestureMethod): PositionGestureFactory | null;
    define<O, V extends View = View>(className: string, descriptor: PositionGestureDescriptor<O, V>): PositionGestureFactory<PositionGesture<any, V>>;
    define<O, V extends View = View>(className: string, descriptor: {
        observes: boolean;
    } & PositionGestureDescriptor<O, V, ObserverType<V>>): PositionGestureFactory<PositionGesture<any, V>>;
    define<O, V extends View = View, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & PositionGestureDescriptor<O, V, I>): PositionGestureFactory<PositionGesture<any, V> & I>;
    define<O, V extends View = View, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & PositionGestureDescriptor<O, V, I & ObserverType<V>>): PositionGestureFactory<PositionGesture<any, V> & I>;
    <O, V extends View = View>(descriptor: PositionGestureDescriptor<O, V>): PropertyDecorator;
    <O, V extends View = View>(descriptor: {
        observes: boolean;
    } & PositionGestureDescriptor<O, V, ObserverType<V>>): PropertyDecorator;
    <O, V extends View = View, I = {}>(descriptor: {
        implements: unknown;
    } & PositionGestureDescriptor<O, V, I>): PropertyDecorator;
    <O, V extends View = View, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & PositionGestureDescriptor<O, V, I & ObserverType<V>>): PropertyDecorator;
}

/** @public */
export declare interface PositionGestureInit<V extends View = View> extends GestureInit<V> {
    extends?: {
        prototype: PositionGesture<any, any>;
    } | string | boolean | null;
    willStartHovering?(): void;
    didStartHovering?(): void;
    willStopHovering?(): void;
    didStopHovering?(): void;
    willBeginHover?(input: PositionGestureInput, event: Event | null): void;
    didBeginHover?(input: PositionGestureInput, event: Event | null): void;
    willEndHover?(input: PositionGestureInput, event: Event | null): void;
    didEndHover?(input: PositionGestureInput, event: Event | null): void;
    willStartPressing?(): void;
    didStartPressing?(): void;
    willStopPressing?(): void;
    didStopPressing?(): void;
    willBeginPress?(input: PositionGestureInput, event: Event | null): boolean | void;
    didBeginPress?(input: PositionGestureInput, event: Event | null): void;
    willMovePress?(input: PositionGestureInput, event: Event | null): void;
    didMovePress?(input: PositionGestureInput, event: Event | null): void;
    willEndPress?(input: PositionGestureInput, event: Event | null): void;
    didEndPress?(input: PositionGestureInput, event: Event | null): void;
    willCancelPress?(input: PositionGestureInput, event: Event | null): void;
    didCancelPress?(input: PositionGestureInput, event: Event | null): void;
    willPress?(input: PositionGestureInput, event: Event | null): void;
    didPress?(input: PositionGestureInput, event: Event | null): void;
    willLongPress?(input: PositionGestureInput): void;
    didLongPress?(input: PositionGestureInput): void;
}

/** @public */
export declare class PositionGestureInput extends GestureInput {
    hovering: boolean;
    pressing: boolean;
    holdTimer: number;
    holdDelay: number;
    constructor(inputId: string, inputType: GestureInputType, isPrimary: boolean, x: number, y: number, t: number);
    isRunaway(): boolean;
    setHoldTimer(f: () => void): void;
    clearHoldTimer(): void;
}

/** @public */
export declare class Presence implements Interpolate<Presence>, HashCode, Equivalent, Debug {
    constructor(phase: number, direction: number);
    readonly phase: number;
    withPhase(phase: number): Presence;
    readonly direction: number;
    withDirection(direction: number): Presence;
    get modalState(): "hidden" | "showing" | "shown" | "hiding" | undefined;
    get dismissed(): boolean;
    get presented(): boolean;
    get presenting(): boolean;
    get dismissing(): boolean;
    asPresenting(): Presence;
    asDismissing(): Presence;
    asToggling(): Presence;
    asToggled(): Presence;
    interpolateTo(that: Presence): Interpolator<Presence>;
    interpolateTo(that: unknown): Interpolator<Presence> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static dismissed(): Presence;
    static presented(): Presence;
    static presenting(phase?: number): Presence;
    static dismissing(phase?: number): Presence;
    static create(phase: number, direction?: number): Presence;
    static fromInit(value: PresenceInit): Presence;
    static fromAny(value: AnyPresence): Presence;
    /** @internal */
    static isInit(value: unknown): value is PresenceInit;
    /** @internal */
    static isAny(value: unknown): value is AnyPresence;
}

/** @public */
export declare interface PresenceInit {
    readonly phase: number;
    readonly direction: number;
}

/** @internal */
export declare const PresenceInterpolator: {
    (p0: Presence, p1: Presence): Interpolator<Presence>;
    /** @internal */
    prototype: Interpolator<Presence>;
};

/** @public */
export declare interface PresenceThemeAnimator<O = unknown, T extends Presence | null | undefined = Presence, U extends AnyPresence | null | undefined = AnyPresence> extends ThemeAnimator<O, T, U> {
    get phase(): number | undefined;
    getPhase(): number;
    getPhaseOr<E>(elsePhase: E): number | E;
    setPhase(newPhase: number, timingOrAffinity: Affinity | AnyTiming | boolean | null | undefined): void;
    setPhase(newPhase: number, timing?: AnyTiming | boolean | null, affinity?: Affinity): void;
    get direction(): number;
    setDirection(newDirection: number, timingOrAffinity: Affinity | AnyTiming | boolean | null | undefined): void;
    setDirection(newDirection: number, timing?: AnyTiming | boolean | null, affinity?: Affinity): void;
    get modalState(): string | undefined;
    get dismissed(): boolean;
    get presented(): boolean;
    get presenting(): boolean;
    get dismissing(): boolean;
    present(timingOrAffinity: Affinity | AnyTiming | boolean | null | undefined): void;
    present(timing?: AnyTiming | boolean | null, affinity?: Affinity): void;
    dismiss(timingOrAffinity: Affinity | AnyTiming | boolean | null | undefined): void;
    dismiss(timing?: AnyTiming | boolean | null, affinity?: Affinity): void;
    toggle(timingOrAffinity: Affinity | AnyTiming | boolean | null | undefined): void;
    toggle(timing?: AnyTiming | boolean | null, affinity?: Affinity): void;
    /** @override @protected */
    onSetValue(newValue: T, oldValue: T): void;
    /** @protected */
    willPresent(): void;
    /** @protected */
    didPresent(): void;
    /** @protected */
    willDismiss(): void;
    /** @protected */
    didDismiss(): void;
    /** @override */
    (newValue: T, oldValue: T | undefined): boolean;
    /** @override */
    fromAny(value: T | U): T;
}

/** @public */
export declare const PresenceThemeAnimator: ThemeAnimatorFactory<PresenceThemeAnimator<any, Presence | null | undefined, AnyPresence | null | undefined>>;

/** @public */
export declare interface PresenceThemeAnimatorInit {
    willPresent?(): void;
    didPresent?(): void;
    willDismiss?(): void;
    didDismiss?(): void;
}

/** @public */
export declare class RasterView extends GraphicsView {
    constructor();
    readonly contextType?: Class<RasterViewContext>;
    readonly opacity: ThemeConstraintAnimator<this, number>;
    readonly compositeOperation: Property<this, CanvasCompositeOperation>;
    get pixelRatio(): number;
    /** @internal */
    readonly canvas: HTMLCanvasElement;
    get compositor(): GraphicsRenderer | null;
    readonly renderer: GraphicsRenderer | null;
    setRenderer(renderer: AnyGraphicsRenderer | null): void;
    protected createRenderer(rendererType?: GraphicsRendererType): GraphicsRenderer | null;
    protected needsUpdate(updateFlags: ViewFlags, immediate: boolean): ViewFlags;
    protected needsProcess(processFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    protected onResize(viewContext: ViewContextType<this>): void;
    protected needsDisplay(displayFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected didComposite(viewContext: ViewContextType<this>): void;
    extendViewContext(viewContext: GraphicsViewContext): ViewContextType<this>;
    readonly viewBounds: R2Box;
    /** @internal */
    readonly ownRasterFrame: R2Box | null;
    get rasterFrame(): R2Box;
    /** @internal */
    setRasterFrame(rasterFrame: R2Box | null): void;
    protected deriveRasterFrame(): R2Box;
    protected createCanvas(): HTMLCanvasElement;
    protected resizeCanvas(canvas: HTMLCanvasElement, rasterFrame: R2Box): void;
    protected clearCanvas(rasterFrame: R2Box): void;
    protected resetRenderer(rasterFrame: R2Box): void;
    protected compositeImage(viewContext: ViewContextType<this>): void;
    init(init: RasterViewInit): void;
    static readonly MountFlags: ViewFlags;
    static readonly UncullFlags: ViewFlags;
    static readonly UnhideFlags: ViewFlags;
}

/** @public */
export declare interface RasterViewContext extends GraphicsViewContext {
    readonly compositor: GraphicsRenderer | null;
}

/** @public */
export declare interface RasterViewInit extends GraphicsViewInit {
    opacity?: number;
    compositeOperation?: CanvasCompositeOperation;
}

/** @public */
export declare class Rect implements Graphics, Equals, Debug {
    constructor(x: Length, y: Length, width: Length, height: Length);
    readonly x: Length;
    withX(x: AnyLength): Rect;
    readonly y: Length;
    withY(y: AnyLength): Rect;
    readonly width: Length;
    withWidth(width: AnyLength): Rect;
    readonly height: Length;
    withHeight(height: AnyLength): Rect;
    render(): string;
    render(renderer: GraphicsRenderer, frame?: R2Box): void;
    draw(context: DrawingContext, frame?: R2Box | null): void;
    protected renderRect(context: DrawingContext, frame: R2Box | null): void;
    protected copy(x: Length, y: Length, width: Length, height: Length): Rect;
    toAny(): RectInit;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static create(x: AnyLength, y: AnyLength, width: AnyLength, height: AnyLength): Rect;
    static fromAny(value: AnyRect): Rect;
}

/** @public */
export declare interface RectInit {
    x: AnyLength;
    y: AnyLength;
    width: AnyLength;
    height: AnyLength;
}

/** @public */
export declare class RectView extends GraphicsView implements FillView, StrokeView {
    readonly x: ThemeAnimator<this, Length, AnyLength>;
    readonly y: ThemeAnimator<this, Length, AnyLength>;
    readonly width: ThemeAnimator<this, Length, AnyLength>;
    readonly height: ThemeAnimator<this, Length, AnyLength>;
    readonly fill: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly stroke: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly strokeWidth: ThemeAnimator<this, Length | null, AnyLength | null>;
    get value(): Rect;
    get state(): Rect;
    setState(rect: Rect | RectViewInit, timing?: AnyTiming | boolean): void;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected renderRect(context: PaintingContext, frame: R2Box): void;
    readonly viewBounds: R2Box;
    protected hitTest(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestRect(hx: number, hy: number, context: CanvasContext, frame: R2Box): GraphicsView | null;
    init(init: Rect | RectViewInit): void;
}

/** @public */
export declare interface RectViewInit extends FillViewInit, StrokeViewInit {
    x?: AnyLength;
    y?: AnyLength;
    width?: AnyLength;
    height?: AnyLength;
}

/** @public */
export declare interface RefreshProvider<M extends Model, S extends RefreshService<M> | null | undefined = RefreshService<M>> extends Provider<M, S> {
    get modelContext(): ModelContext;
    updatedModelContext(): ModelContext;
    requestUpdate(target: Model, updateFlags: ModelFlags, immediate: boolean): void;
    createService(): S;
}

/** @public */
export declare const RefreshProvider: ProviderClass<RefreshProvider<any, any>>;

/** @public */
export declare class RefreshService<M extends Model = Model> extends Service<M> {
    constructor();
    readonly observerType?: Class<RefreshServiceObserver<M>>;
    readonly flags: ModelFlags;
    /** @internal */
    setFlags(flags: ModelFlags): void;
    readonly modelContext: ModelContext;
    updatedModelContext(): ModelContext;
    /** @internal */
    updateDelay: number;
    protected needsUpdate(updateFlags: ModelFlags, immediate: boolean): ModelFlags;
    requestUpdate(target: Model, updateFlags: ModelFlags, immediate: boolean): void;
    protected scheduleUpdate(): void;
    protected cancelUpdate(): void;
    protected runImmediatePass(): void;
    /** @internal */
    analyzeTimer: number;
    protected scheduleAnalyzePass(updateDelay: number): void;
    protected cancelAnalyzePass(): void;
    protected runAnalyzePass(immediate?: boolean): void;
    /** @internal */
    refreshTimer: number;
    protected scheduleRefreshPass(updateDelay: number): void;
    protected cancelRefreshPass(): void;
    protected runRefreshPass(immediate?: boolean): void;
    get powerFlags(): ModelFlags;
    power(): void;
    unpower(): void;
    protected onAttachRoot(root: M): void;
    protected onAttach(): void;
    protected onDetach(): void;
    protected attachEvents(): void;
    protected detachEvents(): void;
    /** @internal */
    protected onVisibilityChange(): void;
    static global<M extends Model>(): RefreshService<M>;
    /** @internal */
    static MinUpdateDelay: number;
    /** @internal */
    static MaxUpdateDelay: number;
    /** @internal */
    static MinAnalyzeInterval: number;
    /** @internal */
    static MaxAnalyzeInterval: number;
    /** @internal */
    static MinRefreshInterval: number;
    /** @internal */
    static MaxRefreshInterval: number;
}

/** @public */
export declare interface RefreshServiceObserver<M extends Model = Model, S extends RefreshService<M> = RefreshService<M>> extends ServiceObserver<M, S> {
}

/** @public */
export declare class RgbColor extends Color {
    constructor(r: number, g: number, b: number, a?: number);
    isDefined(): boolean;
    readonly r: number;
    readonly g: number;
    readonly b: number;
    readonly a: number;
    alpha(): number;
    alpha(a: number): RgbColor;
    get lightness(): number;
    plus(that: AnyColor): RgbColor;
    times(scalar: number): RgbColor;
    combine(that: AnyColor, scalar?: number): Color;
    lighter(k?: number): RgbColor;
    darker(k?: number): RgbColor;
    rgb(): RgbColor;
    hsl(): HslColor;
    interpolateTo(that: RgbColor): Interpolator<RgbColor>;
    interpolateTo(that: Color): Interpolator<Color>;
    interpolateTo(that: unknown): Interpolator<Color> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toHexString(): string;
    toRgbString(): string;
    toHslString(): string;
    /** @internal */
    readonly stringValue: string | undefined;
    toString(): string;
    static transparent(): RgbColor;
    static black(alpha?: number): RgbColor;
    static white(alpha?: number): RgbColor;
    static fromInit(value: RgbColorInit): RgbColor;
    static fromAny(value: AnyRgbColor): RgbColor;
    static fromValue(value: Value): RgbColor | null;
    static parse(str: string): RgbColor;
    /** @internal */
    static isInit(value: unknown): value is RgbColorInit;
    /** @internal */
    static isAny(value: unknown): value is AnyRgbColor;
}

/** @public */
export declare interface RgbColorInit {
    readonly r: number;
    readonly g: number;
    readonly b: number;
    readonly a?: number;
}

/** @internal */
export declare const RgbColorInterpolator: {
    (c0: RgbColor, c1: RgbColor): Interpolator<RgbColor>;
    /** @internal */
    prototype: Interpolator<RgbColor>;
};

/** @internal */
export declare class RgbColorParser extends Parser<RgbColor> {
    private readonly rParser;
    private readonly gParser;
    private readonly bParser;
    private readonly aParser;
    private readonly step;
    constructor(rParser?: Parser<ColorChannel>, gParser?: Parser<ColorChannel>, bParser?: Parser<ColorChannel>, aParser?: Parser<ColorChannel>, step?: number);
    feed(input: Input): Parser<RgbColor>;
    static parse(input: Input, rParser?: Parser<ColorChannel>, gParser?: Parser<ColorChannel>, bParser?: Parser<ColorChannel>, aParser?: Parser<ColorChannel>, step?: number): Parser<RgbColor>;
    /** @internal */
    static parseRest(input: Input): Parser<RgbColor>;
}

/** @public */
export declare class RightAxisController<Y = unknown> extends AxisController<Y> {
    readonly axis: TraitViewRef<this, RightAxisTrait<Y>, RightAxisView<Y>>;
    static readonly axis: MemberFastenerClass<RightAxisController, "axis">;
}

/** @public */
export declare abstract class RightAxisTrait<Y = unknown> extends AxisTrait<Y> {
    readonly observerType?: Class<AxisTraitObserver<Y, RightAxisTrait<Y>>>;
}

/** @public */
export declare class RightAxisView<Y = unknown> extends AxisView<Y> {
    get orientation(): AxisOrientation;
    readonly scale: ContinuousScaleAnimator<this, Y, number>;
    protected layoutTick(tick: TickView<Y>, origin: R2Point, frame: R2Box, scale: ContinuousScale<Y, number>): void;
    protected renderDomain(context: PaintingContext, origin: R2Point, frame: R2Box): void;
}

/** @public */
export declare class RightTickView<Y = unknown> extends TickView<Y> {
    constructor(value: Y);
    get orientation(): TickOrientation;
    protected layoutLabel(labelView: GraphicsView): void;
    protected renderTick(context: PaintingContext, frame: R2Box): void;
}

/** @public */
export declare class RowController extends LeafController {
    readonly observerType?: Class<RowControllerObserver>;
    readonly row: TraitViewRef<this, RowTrait, RowView>;
    static readonly row: MemberFastenerClass<RowController, "row">;
    readonly tree: TraitViewControllerRef<this, TableTrait, TableView, TableController>;
    static readonly tree: MemberFastenerClass<RowController, "tree">;
}

/** @public */
export declare interface RowControllerObserver<C extends RowController = RowController> extends LeafControllerObserver<C> {
    controllerWillAttachRowTrait?(rowTrait: RowTrait, controller: C): void;
    controllerDidDetachRowTrait?(rowTrait: RowTrait, controller: C): void;
    controllerWillAttachRowView?(rowView: RowView, controller: C): void;
    controllerDidDetachRowView?(rowView: RowView, controller: C): void;
    controllerWillAttachTree?(treeController: TableController, controller: C): void;
    controllerDidDetachTree?(treeController: TableController, controller: C): void;
    controllerWillAttachTreeTrait?(treeTrait: TableTrait, treeController: TableController, controller: C): void;
    controllerDidDetachTreeTrait?(treeTrait: TableTrait, treeController: TableController, controller: C): void;
    controllerWillAttachTreeView?(treeView: TableView, treeController: TableController, controller: C): void;
    controllerDidDetachTreeView?(treeView: TableView, treeController: TableController, controller: C): void;
    controllerWillExpandRowView?(rowView: RowView, controller: C): void;
    controllerDidExpandRowView?(rowView: RowView, controller: C): void;
    controllerWillCollapseRowView?(rowView: RowView, controller: C): void;
    controllerDidCollapseRowView?(rowView: RowView, controller: C): void;
}

/** @public */
export declare interface RowControllerTreeExt {
    attachTreeTrait(treeTrait: TableTrait, treeController: TableController): void;
    detachTreeTrait(treeTrait: TableTrait, treeController: TableController): void;
    attachTreeView(treeView: TableView, treeController: TableController): void;
    detachTreeView(treeView: TableView, treeController: TableController): void;
}

/** @public */
export declare class RowTrait extends LeafTrait {
    readonly observerType?: Class<RowTraitObserver>;
    readonly tree: TraitRef<this, TableTrait>;
    static readonly tree: MemberFastenerClass<RowTrait, "tree">;
}

/** @public */
export declare interface RowTraitObserver<T extends RowTrait = RowTrait> extends LeafTraitObserver<T> {
    traitWillAttachTree?(treeTrait: TableTrait, trait: T): void;
    traitDidDetachTree?(treeTrait: TableTrait, trait: T): void;
}

/** @public */
export declare class RowView extends HtmlView {
    constructor(node: HTMLElement);
    protected initRow(): void;
    readonly observerType?: Class<RowViewObserver>;
    readonly contextType?: Class<TableViewContext>;
    readonly layout: Property<this, TableLayout | null, AnyTableLayout | null>;
    readonly depth: Property<this, number>;
    readonly rowSpacing: ThemeConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly rowHeight: ThemeConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly hovers: Property<this, boolean>;
    readonly glows: Property<this, boolean>;
    getCell<F extends abstract new (...args: any) => CellView>(key: string, cellViewClass: F): InstanceType<F> | null;
    getCell(key: string): CellView | null;
    getOrCreateCell<F extends ViewCreator<F, CellView>>(key: string, cellViewClass: F): InstanceType<F>;
    setCell(key: string, cellView: CellView): void;
    readonly leaf: ViewRef<this, LeafView>;
    static readonly leaf: MemberFastenerClass<RowView, "leaf">;
    readonly head: ViewRef<this, HtmlView>;
    static readonly head: MemberFastenerClass<RowView, "head">;
    readonly tree: ViewRef<this, TableView>;
    static readonly tree: MemberFastenerClass<RowView, "tree">;
    readonly foot: ViewRef<this, HtmlView>;
    static readonly foot: MemberFastenerClass<RowView, "foot">;
    readonly disclosure: ExpansionThemeAnimator<this, Expansion, AnyExpansion>;
    readonly disclosing: ExpansionThemeAnimator<this, Expansion | null, AnyExpansion | null>;
    /** @internal */
    readonly visibleFrame: R2Box;
    protected detectVisibleFrame(viewContext: ViewContext): R2Box;
    extendViewContext(viewContext: ViewContext): ViewContextType<this>;
    protected onProcess(processFlags: ViewFlags, viewContext: ViewContextType<this>): void;
    protected needsProcess(processFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    protected onDisplay(displayFlags: ViewFlags, viewContext: ViewContextType<this>): void;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected resizeRow(): void;
    protected layoutLeaf(leafView: LeafView): void;
    protected didLayout(viewContext: ViewContextType<this>): void;
    protected layoutRow(): void;
    protected onCull(): void;
    protected onUncull(): void;
}

/** @public */
export declare interface RowViewObserver<V extends RowView = RowView> extends HtmlViewObserver<V> {
    viewWillAttachLeaf?(leafView: LeafView, view: V): void;
    viewDidDetachLeaf?(leafView: LeafView, view: V): void;
    viewWillHighlightLeaf?(leafView: LeafView, view: V): void;
    viewDidHighlightLeaf?(leafView: LeafView, view: V): void;
    viewWillUnhighlightLeaf?(leafView: LeafView, view: V): void;
    viewDidUnhighlightLeaf?(leafView: LeafView, view: V): void;
    viewDidEnterLeaf?(leafView: LeafView, view: V): void;
    viewDidLeaveLeaf?(leafView: LeafView, view: V): void;
    viewDidPressLeaf?(input: PositionGestureInput, event: Event | null, leafView: LeafView, view: V): void;
    viewDidLongPressLeaf?(input: PositionGestureInput, leafView: LeafView, view: V): void;
    viewWillAttachTree?(treeView: TableView, view: V): void;
    viewDidDetachTree?(treeView: TableView, view: V): void;
    viewWillExpand?(view: V): void;
    viewDidExpand?(view: V): void;
    viewWillCollapse?(view: V): void;
    viewDidCollapse?(view: V): void;
}

/** @internal */
export declare type ScaledFlags = number;

/** @public */
export declare abstract class ScaledView<X = unknown, Y = unknown> extends GraphicsView implements ScaledXYView<X, Y> {
    constructor();
    readonly observerType?: Class<ScaledViewObserver<X, Y>>;
    /** @internal */
    readonly scaledFlags: ScaledFlags;
    /** @internal */
    setScaledFlags(scaledFlags: ScaledFlags): void;
    readonly xScale: ContinuousScaleAnimator<this, X, number>;
    readonly yScale: ContinuousScaleAnimator<this, Y, number>;
    xDomain(): Domain<X> | null;
    xDomain(xDomain: Domain<X> | string | null, timing?: AnyTiming | boolean): this;
    xDomain(xMin: X, xMax: X, timing?: AnyTiming | boolean): this;
    yDomain(): Domain<Y> | null;
    yDomain(yDomain: Domain<Y> | string | null, timing?: AnyTiming | boolean): this;
    yDomain(yMin: Y, yMax: Y, timing?: AnyTiming | boolean): this;
    xRange(): Range_2<number> | null;
    yRange(): Range_2<number> | null;
    readonly xDataDomain: Domain<X> | null;
    protected setXDataDomain(newXDataDomain: Domain<X> | null): void;
    protected willSetXDataDomain(newXDataDomain: Domain<X> | null, oldXDataDomain: Domain<X> | null): void;
    protected onSetXDataDomain(newXDataDomain: Domain<X> | null, oldXDataDomain: Domain<X> | null): void;
    protected didSetXDataDomain(newXDataDomain: Domain<X> | null, oldXDataDomain: Domain<X> | null): void;
    protected updateXDataDomain(xScaledDomain: Domain<X> | null): void;
    readonly yDataDomain: Domain<Y> | null;
    protected setYDataDomain(newYDataDomain: Domain<Y> | null): void;
    protected willSetYDataDomain(newYDataDomain: Domain<Y> | null, oldYDataDomain: Domain<Y> | null): void;
    protected onSetYDataDomain(newYDataDomain: Domain<Y> | null, oldYDataDomain: Domain<Y> | null): void;
    protected didSetYDataDomain(newYDataDomain: Domain<Y> | null, oldYDataDomain: Domain<Y> | null): void;
    protected updateYDataDomain(yScaledDomain: Domain<Y> | null): void;
    readonly xDataRange: Range_2<number> | null;
    protected setXDataRange(xDataRange: Range_2<number> | null): void;
    protected updateXDataRange(): void;
    readonly yDataRange: Range_2<number> | null;
    protected setYDataRange(yDataRange: Range_2<number> | null): void;
    protected updateYDataRange(): void;
    readonly xDataDomainPadded: Domain<X> | null;
    protected setXDataDomainPadded(xDataDomainPadded: Domain<X> | null): void;
    protected updateXDataDomainPadded(): void;
    readonly yDataDomainPadded: Domain<Y> | null;
    protected setYDataDomainPadded(yDataDomainPadded: Domain<Y> | null): void;
    protected updateYDataDomainPadded(): void;
    readonly xDomainBounds: Property<this, readonly [X | boolean, X | boolean]>;
    readonly yDomainBounds: Property<this, readonly [Y | boolean, Y | boolean]>;
    readonly xZoomBounds: Property<this, readonly [number | boolean, number | boolean]>;
    readonly yZoomBounds: Property<this, readonly [number | boolean, number | boolean]>;
    readonly xDomainPadding: Property<this, readonly [X | boolean, X | boolean]>;
    readonly yDomainPadding: Property<this, readonly [Y | boolean, Y | boolean]>;
    protected updateXRangePadding(xScaledRangePadding: readonly [number, number]): void;
    readonly xRangePadding: Property<this, readonly [number, number]>;
    protected updateYRangePadding(yScaledRangePadding: readonly [number, number]): void;
    readonly yRangePadding: Property<this, readonly [number, number]>;
    readonly fitAlign: Property<this, readonly [number, number], number>;
    xFitAlign(): number;
    xFitAlign(xFitAlign: number): this;
    yFitAlign(): number;
    yFitAlign(yFitAlign: number): this;
    readonly fitAspectRatio: Property<this, number | undefined>;
    preserveAspectRatio(): boolean;
    preserveAspectRatio(preserveAspectRatio: boolean): this;
    domainTracking(): readonly [boolean, boolean];
    domainTracking(domainTracking: readonly [boolean, boolean] | boolean): this;
    domainTracking(xDomainTracking: boolean, yDomainTracking: boolean): this;
    xDomainTracking(): boolean;
    xDomainTracking(xDomainTracking: boolean): this;
    yDomainTracking(): boolean;
    yDomainTracking(yDomainTracking: boolean): this;
    scaleGestures(): readonly [boolean, boolean];
    scaleGestures(scaleGestures: readonly [boolean, boolean] | boolean): this;
    scaleGestures(xScaleGestures: boolean, yScaleGestures: boolean): this;
    xScaleGestures(): boolean;
    xScaleGestures(xScaleGestures: boolean): this;
    yScaleGestures(): boolean;
    yScaleGestures(yScaleGestures: boolean): this;
    readonly rescaleTransition: Property<this, Timing | boolean | undefined, AnyTiming>;
    readonly reboundTransition: Property<this, Timing | boolean | undefined, AnyTiming>;
    fitX(tween?: boolean): void;
    fitY(tween?: boolean): void;
    fit(tween?: boolean): void;
    /** @internal */
    readonly scaled: ViewSet<this, ScaledXView<X> | ScaledYView<Y>>;
    static readonly scaled: MemberFastenerClass<ScaledView, "scaled">;
    protected onLayout(viewContext: ViewContextType<this>): void;
    /**
     * Updates own scale ranges to project onto view frame. Infers own scales
     * from child view data domains if inherited x/y scales are undefined.
     */
    protected resizeScales(): void;
    protected updateScales(): void;
    /**
     * Clamps scales to domain bounds and corrects aspect ratio.
     */
    protected boundScales(oldXScale: ContinuousScale<X, number>, oldYScale: ContinuousScale<Y, number>, isCoasting: boolean): void;
    protected displayChildren(displayFlags: ViewFlags, viewContext: ViewContextType<this>, displayChild: (this: this, childView: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    protected layoutChildViews(xScale: ContinuousScale<X, number>, yScale: ContinuousScale<Y, number>, displayFlags: ViewFlags, viewContext: ViewContextType<this>, displayChild: (this: this, childView: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    protected onBeginBoundingXScale(xScale: ContinuousScale<X, number>): void;
    protected onEndBoundingXScale(xScale: ContinuousScale<X, number>): void;
    protected onInterruptBoundingXScale(xScale: ContinuousScale<X, number>): void;
    protected onBeginBoundingYScale(yScale: ContinuousScale<Y, number>): void;
    protected onEndBoundingYScale(yScale: ContinuousScale<Y, number>): void;
    protected onInterruptBoundingYScale(yScale: ContinuousScale<Y, number>): void;
    protected willReboundX(xScale: ContinuousScale<X, number>): void;
    protected didReboundX(xScale: ContinuousScale<X, number>): void;
    protected willReboundY(yScale: ContinuousScale<Y, number>): void;
    protected didReboundY(yScale: ContinuousScale<Y, number>): void;
    readonly gesture: ScaleGesture<this, ScaledView<X, Y>, X, Y>;
    static readonly gesture: MemberFastenerClass<ScaledView, "gesture">;
    init(init: ScaledViewInit<X, Y>): void;
    /** @internal */
    static createScale<X, Y>(x0: X, x1: X, y0: Y | undefined, y1: Y | undefined): ContinuousScale<X, Y>;
    /** @internal */
    static parseScale<X, Y>(string: string): ContinuousScale<X, Y>;
    /** @internal */
    static readonly XDomainTrackingFlag: ScaledFlags;
    /** @internal */
    static readonly YDomainTrackingFlag: ScaledFlags;
    /** @internal */
    static readonly XScaleGesturesFlag: ScaledFlags;
    /** @internal */
    static readonly YScaleGesturesFlag: ScaledFlags;
    /** @internal */
    static readonly XMinInRangeFlag: ScaledFlags;
    /** @internal */
    static readonly XMaxInRangeFlag: ScaledFlags;
    /** @internal */
    static readonly YMinInRangeFlag: ScaledFlags;
    /** @internal */
    static readonly YMaxInRangeFlag: ScaledFlags;
    /** @internal */
    static readonly InteractingFlag: ScaledFlags;
    /** @internal */
    static readonly InteractedFlag: ScaledFlags;
    /** @internal */
    static readonly XBoundingFlag: ScaledFlags;
    /** @internal */
    static readonly YBoundingFlag: ScaledFlags;
    /** @internal */
    static readonly XFitFlag: ScaledFlags;
    /** @internal */
    static readonly YFitFlag: ScaledFlags;
    /** @internal */
    static readonly XFitTweenFlag: ScaledFlags;
    /** @internal */
    static readonly YFitTweenFlag: ScaledFlags;
    /** @internal */
    static readonly RescaleFlag: ScaledFlags;
    /** @internal */
    static readonly DomainTrackingMask: ScaledFlags;
    /** @internal */
    static readonly ScaleGesturesMask: ScaledFlags;
    /** @internal */
    static readonly XInRangeMask: ScaledFlags;
    /** @internal */
    static readonly YInRangeMask: ScaledFlags;
    /** @internal */
    static readonly InteractingMask: ScaledFlags;
    /** @internal */
    static readonly BoundingMask: ScaledFlags;
    /** @internal */
    static readonly FitMask: ScaledFlags;
    /** @internal */
    static readonly FitTweenMask: ScaledFlags;
    /** @internal */
    static LinearZoomMin: number;
    /** @internal */
    static LinearZoomMax: number;
    /** @internal */
    static TimeZoomMin: number;
    /** @internal */
    static TimeZoomMax: number;
    static readonly InsertChildFlags: ViewFlags;
}

/** @public */
export declare interface ScaledViewInit<X = unknown, Y = unknown> extends GraphicsViewInit {
    xScale?: ContinuousScale<X, number>;
    yScale?: ContinuousScale<Y, number>;
    xDomainBounds?: [X | boolean, X | boolean];
    yDomainBounds?: [Y | boolean, Y | boolean];
    xZoomBounds?: [number | boolean, number | boolean];
    yZoomBounds?: [number | boolean, number | boolean];
    xDomainPadding?: [X | boolean, X | boolean];
    yDomainPadding?: [Y | boolean, Y | boolean];
    xRangePadding?: [number, number];
    yRangePadding?: [number, number];
    fitAlign?: [number, number] | number;
    xFitAlign?: number;
    yFitAlign?: number;
    fitAspectRatio?: number;
    preserveAspectRatio?: boolean;
    domainTracking?: [boolean, boolean] | boolean;
    xDomainTracking?: boolean;
    yDomainTracking?: boolean;
    scaleGestures?: [boolean, boolean] | boolean;
    xScaleGestures?: boolean;
    yScaleGestures?: boolean;
    rescaleTransition?: AnyTiming | boolean;
    reboundTransition?: AnyTiming | boolean;
}

/** @public */
export declare interface ScaledViewObserver<X = unknown, Y = unknown, V extends ScaledView<X, Y> = ScaledView<X, Y>> extends GraphicsViewObserver<V>, ScaledXYViewObserver<X, Y, V> {
    viewWillAttachScaled?(scaledView: ScaledXView<X> | ScaledYView<Y>, targetView: View | null, view: V): void;
    viewDidDetachScaled?(scaledView: ScaledXView<X> | ScaledYView<Y>, view: V): void;
}

/** @public */
export declare interface ScaledXView<X = unknown> extends GraphicsView {
    /** @override */
    readonly observerType?: Class<ScaledXViewObserver<X>>;
    readonly xScale: Animator<this, ContinuousScale<X, number> | null, string>;
    xDomain(): Domain<X> | null;
    xDomain(xDomain: Domain<X> | null, timing?: AnyTiming | boolean): this;
    xDomain(xMin: X, xMax: X, timing: AnyTiming | boolean): this;
    xRange(): Range_2<number> | null;
    xRangePadding(): readonly [number, number];
    readonly xDataDomain: Domain<X> | null;
    readonly xDataRange: Range_2<number> | null;
}

/** @public */
export declare const ScaledXView: {
    is<X>(object: unknown): object is ScaledXView<X>;
};

/** @public */
export declare interface ScaledXViewObserver<X = unknown, V extends ScaledXView<X> = ScaledXView<X>> extends GraphicsViewObserver<V> {
    viewWillSetXScale?(newXScale: ContinuousScale<X, number> | null, oldXScale: ContinuousScale<X, number> | null, view: V): void;
    viewDidSetXScale?(newXScale: ContinuousScale<X, number> | null, oldXScale: ContinuousScale<X, number> | null, view: V): void;
    viewWillSetXRangePadding?(newXRangePadding: readonly [number, number], oldXRangePadding: readonly [number, number], view: V): void;
    viewDidSetXRangePadding?(newXRangePadding: readonly [number, number], oldXRangePadding: readonly [number, number], view: V): void;
    viewWillSetXDataDomain?(newXDataDomain: Domain<X> | null, oldXDataDomain: Domain<X> | null, view: V): void;
    viewDidSetXDataDomain?(newXDataDomain: Domain<X> | null, oldXDataDomain: Domain<X> | null, view: V): void;
}

/** @public */
export declare interface ScaledXYView<X = unknown, Y = unknown> extends GraphicsView, ScaledXView<X>, ScaledYView<Y> {
    /** @override */
    readonly observerType?: Class<ScaledXYViewObserver<X, Y>>;
}

/** @public */
export declare const ScaledXYView: {
    is<X, Y>(object: unknown): object is ScaledXYView<X, Y>;
};

/** @public */
export declare interface ScaledXYViewObserver<X = unknown, Y = unknown, V extends ScaledXYView<X, Y> = ScaledXYView<X, Y>> extends ScaledXViewObserver<X, V>, ScaledYViewObserver<Y, V> {
}

/** @public */
export declare interface ScaledYView<Y = unknown> extends GraphicsView {
    /** @override */
    readonly observerType?: Class<ScaledYViewObserver<Y>>;
    readonly yScale: Animator<this, ContinuousScale<Y, number> | null, string>;
    yDomain(): Domain<Y> | null;
    yDomain(yDomain: Domain<Y> | null, timing?: AnyTiming | boolean): this;
    yDomain(yMin: Y, yMax: Y, timing: AnyTiming | boolean): this;
    yRange(): Range_2<number> | null;
    yRangePadding(): readonly [number, number];
    readonly yDataDomain: Domain<Y> | null;
    readonly yDataRange: Range_2<number> | null;
}

/** @public */
export declare const ScaledYView: {
    is<Y>(object: unknown): object is ScaledYView<Y>;
};

/** @public */
export declare interface ScaledYViewObserver<Y = unknown, V extends ScaledYView<Y> = ScaledYView<Y>> extends GraphicsViewObserver<V> {
    viewWillSetYScale?(newYScale: ContinuousScale<Y, number> | null, oldYScale: ContinuousScale<Y, number> | null, view: V): void;
    viewDidSetYScale?(newYScale: ContinuousScale<Y, number> | null, oldYScale: ContinuousScale<Y, number> | null, view: V): void;
    viewWillSetYRangePadding?(newYRangePadding: readonly [number, number], oldYRangePadding: readonly [number, number], view: V): void;
    viewDidSetYRangePadding?(newYRangePadding: readonly [number, number], oldYRangePadding: readonly [number, number], view: V): void;
    viewWillSetYDataDomain?(newYDataDomain: Domain<Y> | null, oldYDataDomain: Domain<Y> | null, view: V): void;
    viewDidSetYDataDomain?(newYDataDomain: Domain<Y> | null, oldYDataDomain: Domain<Y> | null, view: V): void;
}

/** @public */
export declare interface ScaleGesture<O = unknown, V extends View = View, X = unknown, Y = unknown> extends MomentumGesture<O, V> {
    /** @internal @override */
    readonly inputs: {
        readonly [inputId: string]: ScaleGestureInput<X, Y> | undefined;
    };
    /** @override */
    getInput(inputId: string | number): ScaleGestureInput<X, Y> | null;
    /** @internal @override */
    createInput(inputId: string, inputType: GestureInputType, isPrimary: boolean, x: number, y: number, t: number): ScaleGestureInput<X, Y>;
    /** @internal @override */
    getOrCreateInput(inputId: string | number, inputType: GestureInputType, isPrimary: boolean, x: number, y: number, t: number): ScaleGestureInput<X, Y>;
    /** @internal @override */
    clearInput(input: ScaleGestureInput<X, Y>): void;
    /** @internal @override */
    clearInputs(): void;
    distanceMin: number;
    get preserveAspectRatio(): boolean;
    set preserveAspectRatio(preserveAspectRatio: boolean);
    get wheel(): boolean;
    set wheel(wheel: boolean);
    getXScale(): ContinuousScale<X, number> | null;
    setXScale(xScale: ContinuousScale<X, number> | null, timing?: AnyTiming | boolean): void;
    getYScale(): ContinuousScale<Y, number> | null;
    setYScale(yScale: ContinuousScale<Y, number> | null, timing?: AnyTiming | boolean): void;
    /** @internal */
    clientToRangeX(clientX: number, xScale: ContinuousScale<X, number>, bounds: R2Box): number;
    /** @internal */
    clientToRangeY(clientY: number, yScale: ContinuousScale<Y, number>, bounds: R2Box): number;
    /** @internal */
    unscaleX(clientX: number, xScale: ContinuousScale<X, number>, bounds: R2Box): X;
    /** @internal */
    unscaleY(clientY: number, yScale: ContinuousScale<Y, number>, bounds: R2Box): Y;
    /** @internal @override */
    viewWillAnimate(viewContext: ViewContext): void;
    /** @protected @override */
    onBeginPress(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    /** @protected @override */
    onMovePress(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    /** @protected @override */
    onEndPress(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    /** @protected @override */
    onCancelPress(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    /** @internal @override */
    beginCoast(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    /** @protected @override */
    onBeginCoast(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    /** @protected @override */
    onEndCoast(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    /** @protected @override */
    onCoast(): void;
    /** @internal */
    updateInputDomain(input: ScaleGestureInput<X, Y>, xScale?: ContinuousScale<X, number> | null, yScale?: ContinuousScale<Y, number> | null, bounds?: R2Box): void;
    /** @internal */
    neutralizeX(): void;
    /** @internal */
    neutralizeY(): void;
    /** @internal */
    rescale(): void;
    /** @internal */
    rescaleRadial(oldXScale: ContinuousScale<X, number>, oldYScale: ContinuousScale<Y, number>, input0: ScaleGestureInput<X, Y>, input1: ScaleGestureInput<X, Y>, bounds: R2Box): void;
    /** @internal */
    rescaleXY(oldXScale: ContinuousScale<X, number>, oldYScale: ContinuousScale<Y, number>, input0: ScaleGestureInput<X, Y>, input1: ScaleGestureInput<X, Y> | undefined, bounds: R2Box): void;
    /** @internal */
    rescaleX(oldXScale: ContinuousScale<X, number>, input0: ScaleGestureInput<X, Y>, input1: ScaleGestureInput<X, Y> | undefined, bounds: R2Box): void;
    /** @internal */
    rescaleY(oldYScale: ContinuousScale<Y, number>, input0: ScaleGestureInput<X, Y>, input1: ScaleGestureInput<X, Y> | undefined, bounds: R2Box): void;
    /** @internal */
    conserveMomentum(input0: ScaleGestureInput<X, Y>): void;
    /** @internal */
    distributeXYMomentum(input0: ScaleGestureInput<X, Y>, input1: ScaleGestureInput<X, Y>): void;
    /** @internal */
    distributeXMomentum(input0: ScaleGestureInput<X, Y>, input1: ScaleGestureInput<X, Y>): void;
    /** @internal */
    distributeYMomentum(input0: ScaleGestureInput<X, Y>, input1: ScaleGestureInput<X, Y>): void;
    /** @internal @override */
    integrate(t: number): void;
    /** @internal */
    zoom(x: number, y: number, dz: number, event: Event | null): void;
    /** @internal @override */
    get observes(): boolean;
}

/** @public */
export declare const ScaleGesture: ScaleGestureFactory<ScaleGesture<any, any, any, any>>;

/** @public */
export declare interface ScaleGestureClass<G extends ScaleGesture<any, any, any, any> = ScaleGesture<any, any, any, any>> extends MomentumGestureClass<G> {
    /** @internal */
    readonly DistanceMin: number;
    /** @internal */
    readonly PreserveAspectRatioFlag: FastenerFlags;
    /** @internal */
    readonly WheelFlag: FastenerFlags;
    /** @internal */
    readonly NeedsRescale: FastenerFlags;
    /** @internal @override */
    readonly FlagShift: number;
    /** @internal @override */
    readonly FlagMask: FastenerFlags;
}

/** @public */
export declare type ScaleGestureDescriptor<O = unknown, V extends View = View, X = unknown, Y = unknown, I = {}> = ThisType<ScaleGesture<O, V, X, Y> & I> & ScaleGestureInit<V, X, Y> & Partial<I>;

/** @public */
export declare interface ScaleGestureFactory<G extends ScaleGesture<any, any, any, any> = ScaleGesture<any, any, any, any>> extends ScaleGestureClass<G> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ScaleGestureFactory<G> & I;
    specialize(method: GestureMethod): ScaleGestureFactory | null;
    define<O, V extends View = View, X = unknown, Y = unknown>(className: string, descriptor: ScaleGestureDescriptor<O, V, X, Y>): ScaleGestureFactory<ScaleGesture<any, V, X, Y>>;
    define<O, V extends View = View, X = unknown, Y = unknown>(className: string, descriptor: {
        observes: boolean;
    } & ScaleGestureDescriptor<O, V, X, Y, ObserverType<V>>): ScaleGestureFactory<ScaleGesture<any, V, X, Y>>;
    define<O, V extends View = View, X = unknown, Y = unknown, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ScaleGestureDescriptor<O, V, X, Y, I>): ScaleGestureFactory<ScaleGesture<any, V, X, Y> & I>;
    define<O, V extends View = View, X = unknown, Y = unknown, I = {}>(className: string, descriptor: {
        implements: boolean;
        observes: boolean;
    } & ScaleGestureDescriptor<O, V, X, Y, I & ObserverType<V>>): ScaleGestureFactory<ScaleGesture<any, V, X, Y> & I>;
    <O, V extends View = View, X = unknown, Y = unknown>(descriptor: ScaleGestureDescriptor<O, V, X, Y>): PropertyDecorator;
    <O, V extends View = View, X = unknown, Y = unknown>(descriptor: {
        observes: boolean;
    } & ScaleGestureDescriptor<O, V, X, Y, ObserverType<V>>): PropertyDecorator;
    <O, V extends View = View, X = unknown, Y = unknown, I = {}>(descriptor: {
        implements: unknown;
    } & ScaleGestureDescriptor<O, V, X, Y, I>): PropertyDecorator;
    <O, V extends View = View, X = unknown, Y = unknown, I = {}>(descriptor: {
        implements: boolean;
        observes: boolean;
    } & ScaleGestureDescriptor<O, V, X, Y, I & ObserverType<V>>): PropertyDecorator;
}

/** @public */
export declare interface ScaleGestureInit<V extends View = View, X = unknown, Y = unknown> extends MomentumGestureInit<V> {
    extends?: {
        prototype: ScaleGesture<any, any, any, any>;
    } | string | boolean | null;
    /**
     * The minimum radial distance between input positions, in pixels.
     * Used to avoid scale gesture singularities.
     */
    distanceMin?: number;
    preserveAspectRatio?: boolean;
    wheel?: boolean;
    getXScale?(): ContinuousScale<X, number> | null;
    setXScale?(xScale: ContinuousScale<X, number> | null, timing?: AnyTiming | boolean): void;
    getYScale?(): ContinuousScale<Y, number> | null;
    setYScale?(yScale: ContinuousScale<Y, number> | null, timing?: AnyTiming | boolean): void;
    willBeginHover?(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    didBeginHover?(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    willEndHover?(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    didEndHover?(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    willBeginPress?(input: ScaleGestureInput<X, Y>, event: Event | null): boolean | void;
    didBeginPress?(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    willMovePress?(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    didMovePress?(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    willEndPress?(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    didEndPress?(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    willCancelPress?(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    didCancelPress?(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    willPress?(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    didPress?(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    willLongPress?(input: ScaleGestureInput<X, Y>): void;
    didLongPress?(input: ScaleGestureInput<X, Y>): void;
    willBeginCoast?(input: ScaleGestureInput<X, Y>, event: Event | null): boolean | void;
    didBeginCoast?(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    willEndCoast?(input: ScaleGestureInput<X, Y>, event: Event | null): void;
    didEndCoast?(input: ScaleGestureInput<X, Y>, event: Event | null): void;
}

/** @public */
export declare class ScaleGestureInput<X = unknown, Y = unknown> extends MomentumGestureInput {
    xCoord: X | undefined;
    yCoord: Y | undefined;
    disableX: boolean;
    disableY: boolean;
    constructor(inputId: string, inputType: GestureInputType, isPrimary: boolean, x: number, y: number, t: number);
}

/** @public */
export declare abstract class ScatterPlotController<X = unknown, Y = unknown> extends PlotController<X, Y> {
    readonly observerType?: Class<ScatterPlotControllerObserver<X, Y>>;
    abstract readonly plot: TraitViewRef<this, ScatterPlotTrait<X, Y>, ScatterPlotView<X, Y>>;
}

/** @public */
export declare interface ScatterPlotControllerObserver<X = unknown, Y = unknown, C extends ScatterPlotController<X, Y> = ScatterPlotController<X, Y>> extends PlotControllerObserver<X, Y, C> {
    controllerWillAttachPlotTrait?(plotTrait: ScatterPlotTrait<X, Y>, controller: C): void;
    controllerDidDetachPlotTrait?(plotTrait: ScatterPlotTrait<X, Y>, controller: C): void;
    controllerWillAttachPlotView?(plotView: ScatterPlotView<X, Y>, controller: C): void;
    controllerDidDetachPlotView?(plotView: ScatterPlotView<X, Y>, controller: C): void;
}

/** @public */
export declare class ScatterPlotTrait<X = unknown, Y = unknown> extends PlotTrait<X, Y> {
    readonly observerType?: Class<ScatterPlotTraitObserver<X, Y>>;
}

/** @public */
export declare interface ScatterPlotTraitObserver<X = unknown, Y = unknown, R extends ScatterPlotTrait<X, Y> = ScatterPlotTrait<X, Y>> extends PlotTraitObserver<X, Y, R> {
}

/** @public */
export declare abstract class ScatterPlotView<X = unknown, Y = unknown> extends GraphicsView implements PlotView<X, Y> {
    constructor();
    readonly observerType?: Class<ScatterPlotViewObserver<X, Y>>;
    readonly font: ThemeAnimator<this, Font | null, AnyFont | null>;
    readonly textColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly xScale: ContinuousScaleAnimator<this, X, number>;
    readonly yScale: ContinuousScaleAnimator<this, Y, number>;
    xDomain(): Domain<X> | null;
    xDomain(xDomain: Domain<X> | string | null, timing?: AnyTiming | boolean): this;
    xDomain(xMin: X, xMax: X, timing?: AnyTiming | boolean): this;
    yDomain(): Domain<Y> | null;
    yDomain(yDomain: Domain<Y> | string | null, timing?: AnyTiming | boolean): this;
    yDomain(yMin: Y, yMax: Y, timing: AnyTiming | boolean): this;
    xRange(): Range_2<number> | null;
    yRange(): Range_2<number> | null;
    readonly xRangePadding: Property<this, readonly [number, number]>;
    readonly yRangePadding: Property<this, readonly [number, number]>;
    readonly xDataDomain: Domain<X> | null;
    protected setXDataDomain(newXDataDomain: Domain<X> | null): void;
    protected willSetXDataDomain(newXDataDomain: Domain<X> | null, oldXDataDomain: Domain<X> | null): void;
    protected onSetXDataDomain(newXDataDomain: Domain<X> | null, oldXDataDomain: Domain<X> | null): void;
    protected didSetXDataDomain(newXDataDomain: Domain<X> | null, oldXDataDomain: Domain<X> | null): void;
    protected updateXDataDomain(dataPointView: DataPointView<X, Y>): void;
    readonly yDataDomain: Domain<Y> | null;
    protected setYDataDomain(newYDataDomain: Domain<Y> | null): void;
    protected willSetYDataDomain(newYDataDomain: Domain<Y> | null, oldYDataDomain: Domain<Y> | null): void;
    protected onSetYDataDomain(newYDataDomain: Domain<Y> | null, oldYDataDomain: Domain<Y> | null): void;
    protected didSetYDataDomain(newYDataDomain: Domain<Y> | null, oldYDataDomain: Domain<Y> | null): void;
    protected updateYDataDomain(dataPointView: DataPointView<X, Y>): void;
    readonly xDataRange: Range_2<number> | null;
    protected setXDataRange(xDataRange: Range_2<number> | null): void;
    protected updateXDataRange(): void;
    readonly yDataRange: Range_2<number> | null;
    protected setYDataRange(yDataRange: Range_2<number> | null): void;
    protected updateYDataRange(): void;
    readonly dataPoints: ViewSet<this, DataPointView<X, Y>>;
    static readonly dataPoints: MemberFastenerClass<ScatterPlotView, "dataPoints">;
    protected onLayout(viewContext: ViewContextType<this>): void;
    /**
     * Updates own scale ranges to project onto view frame.
     */
    protected resizeScales(frame: R2Box): void;
    protected displayChildren(displayFlags: ViewFlags, viewContext: ViewContextType<this>, displayChild: (this: this, childView: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    protected layoutChildViews(xScale: ContinuousScale<X, number>, yScale: ContinuousScale<Y, number>, displayFlags: ViewFlags, viewContext: ViewContextType<this>, displayChild: (this: this, childView: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    protected didRender(viewContext: ViewContextType<this>): void;
    protected abstract renderPlot(context: CanvasContext, frame: R2Box): void;
    init(init: ScatterPlotViewInit<X, Y>): void;
}

/** @public */
export declare interface ScatterPlotViewInit<X = unknown, Y = unknown> extends PlotViewInit<X, Y> {
}

/** @public */
export declare interface ScatterPlotViewObserver<X = unknown, Y = unknown, V extends ScatterPlotView<X, Y> = ScatterPlotView<X, Y>> extends PlotViewObserver<X, Y, V> {
}

/** @public */
export declare class ScrimView extends HtmlView implements ModalServiceObserver {
    constructor(node: HTMLElement);
    protected initScrim(): void;
    /** @internal */
    readonly displayState: number;
    /** @internal */
    setDisplayState(displayState: number): void;
    readonly backgroundColor: StyleAnimator<this, Color | null, AnyColor | null>;
    isShown(): boolean;
    isHidden(): boolean;
    show(opacity: number, timing?: AnyTiming | boolean): void;
    protected willShowScrim(): void;
    protected didShowScrim(): void;
    hide(timing?: AnyTiming | boolean): void;
    protected willHideScrim(): void;
    protected didHideScrim(): void;
    protected onMount(): void;
    protected onUnmount(): void;
    serviceDidUpdateModality(newModality: number, oldModality: number, modalService: ModalService): void;
    protected onClick(event: Event): void;
    protected onSyntheticClick(event: Event): void;
    /** @internal */
    static readonly HiddenState: number;
    /** @internal */
    static readonly HidingState: number;
    /** @internal */
    static readonly HideState: number;
    /** @internal */
    static readonly ShownState: number;
    /** @internal */
    static readonly ShowingState: number;
    /** @internal */
    static readonly ShowState: number;
}

/** @public */
export declare class SelectableTrait extends Trait {
    constructor();
    readonly observerType?: Class<SelectableTraitObserver>;
    readonly selected: boolean;
    select(options?: SelectionOptions | null): void;
    /** @protected */
    willSelect(options: SelectionOptions | null): void;
    /** @protected */
    onSelect(options: SelectionOptions | null): void;
    /** @protected */
    didSelect(options: SelectionOptions | null): void;
    unselect(): void;
    /** @protected */
    willUnselect(): void;
    /** @protected */
    onUnselect(): void;
    /** @protected */
    didUnselect(): void;
    unselectAll(): void;
    toggle(options?: SelectionOptions): void;
    readonly selectionProvider: SelectionProvider<this>;
    protected didMount(): void;
    protected willUnmount(): void;
}

/** @public */
export declare interface SelectableTraitObserver<R extends SelectableTrait = SelectableTrait> extends TraitObserver<R> {
    traitWillSelect?(options: SelectionOptions | null, trait: R): void;
    traitDidSelect?(options: SelectionOptions | null, trait: R): void;
    traitWillUnselect?(trait: R): void;
    traitDidUnselect?(trait: R): void;
}

/** @public */
export declare interface SelectionOptions {
    multi?: boolean;
}

/** @public */
export declare interface SelectionProvider<M, S extends SelectionService<M> | null | undefined = SelectionService<M>> extends Provider<M, S> {
    get selections(): ReadonlyArray<Model>;
    select(model: Model, options?: SelectionOptions, index?: number): void;
    unselect(model: Model): void;
    unselectAll(): void;
    createService(): S;
}

/** @public */
export declare const SelectionProvider: ProviderClass<SelectionProvider<any, any>>;

/** @public */
export declare class SelectionService<M = unknown> extends Service<M> {
    constructor();
    readonly observerType?: Class<SelectionServiceObserver<M>>;
    readonly selections: ReadonlyArray<Model>;
    isSelected(model: Model): boolean;
    select(model: Model, options?: SelectionOptions | null, index?: number): void;
    protected willSelect(model: Model, index: number, options: SelectionOptions | null): void;
    protected onSelect(model: Model, index: number, options: SelectionOptions | null): void;
    protected didSelect(model: Model, index: number, options: SelectionOptions | null): void;
    unselect(model: Model): void;
    protected willUnselect(model: Model): void;
    protected onUnselect(model: Model): void;
    protected didUnselect(model: Model): void;
    unselectAll(): void;
    toggle(model: Model, options?: SelectionOptions | null, index?: number): void;
    static global<M>(): SelectionService<M>;
}

/** @public */
export declare interface SelectionServiceObserver<M = unknown, S extends SelectionService<M> = SelectionService<M>> extends ServiceObserver<M, S> {
    serviceWillSelect?(model: Model, index: number, options: SelectionOptions | null, service: S): void;
    serviceDidSelect?(model: Model, index: number, options: SelectionOptions | null, service: S): void;
    serviceWillUnselect?(model: Model, service: S): void;
    serviceDidUnselect?(model: Model, service: S): void;
}

/** @public */
export declare abstract class SeriesPlotController<X = unknown, Y = unknown> extends PlotController<X, Y> {
    readonly observerType?: Class<SeriesPlotControllerObserver<X, Y>>;
    abstract readonly plot: TraitViewRef<this, SeriesPlotTrait<X, Y>, SeriesPlotView<X, Y>>;
}

/** @public */
export declare interface SeriesPlotControllerObserver<X = unknown, Y = unknown, C extends SeriesPlotController<X, Y> = SeriesPlotController<X, Y>> extends PlotControllerObserver<X, Y, C> {
    controllerWillAttachPlotTrait?(plotTrait: SeriesPlotTrait<X, Y>, controller: C): void;
    controllerDidDetachPlotTrait?(plotTrait: SeriesPlotTrait<X, Y>, controller: C): void;
    controllerWillAttachPlotView?(plotView: SeriesPlotView<X, Y>, controller: C): void;
    controllerDidDetachPlotView?(plotView: SeriesPlotView<X, Y>, controller: C): void;
}

/** @public */
export declare type SeriesPlotHitMode = "domain" | "plot" | "data" | "none";

/** @public */
export declare class SeriesPlotTrait<X = unknown, Y = unknown> extends PlotTrait<X, Y> {
    readonly observerType?: Class<SeriesPlotTraitObserver<X, Y>>;
}

/** @public */
export declare interface SeriesPlotTraitObserver<X = unknown, Y = unknown, R extends SeriesPlotTrait<X, Y> = SeriesPlotTrait<X, Y>> extends PlotTraitObserver<X, Y, R> {
}

/** @public */
export declare abstract class SeriesPlotView<X = unknown, Y = unknown> extends GraphicsView implements PlotView<X, Y> {
    constructor();
    readonly observerType?: Class<SeriesPlotViewObserver<X, Y>>;
    readonly font: ThemeAnimator<this, Font | null, AnyFont | null>;
    readonly textColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly hitMode: Property<this, SeriesPlotHitMode>;
    readonly xScale: ContinuousScaleAnimator<this, X, number>;
    readonly yScale: ContinuousScaleAnimator<this, Y, number>;
    xDomain(): Domain<X> | null;
    xDomain(xDomain: Domain<X> | string | null, timing?: AnyTiming | boolean): this;
    xDomain(xMin: X, xMax: X, timing: AnyTiming | boolean): this;
    yDomain(): Domain<Y> | null;
    yDomain(yDomain: Domain<Y> | string | null, timing?: AnyTiming | boolean): this;
    yDomain(yMin: Y, yMax: Y, timing: AnyTiming | boolean): this;
    xRange(): Range_2<number> | null;
    yRange(): Range_2<number> | null;
    readonly xRangePadding: Property<this, readonly [number, number]>;
    readonly yRangePadding: Property<this, readonly [number, number]>;
    readonly xDataDomain: Domain<X> | null;
    protected setXDataDomain(newXDataDomain: Domain<X> | null): void;
    protected willSetXDataDomain(newXDataDomain: Domain<X> | null, oldXDataDomain: Domain<X> | null): void;
    protected onSetXDataDomain(newXDataDomain: Domain<X> | null, oldXDataDomain: Domain<X> | null): void;
    protected didSetXDataDomain(newXDataDomain: Domain<X> | null, oldXDataDomain: Domain<X> | null): void;
    protected updateXDataDomain(dataPointView: DataPointView<X, Y>): void;
    readonly yDataDomain: Domain<Y> | null;
    protected setYDataDomain(newYDataDomain: Domain<Y> | null): void;
    protected willSetYDataDomain(newYDataDomain: Domain<Y> | null, oldYDataDomain: Domain<Y> | null): void;
    protected onSetYDataDomain(newYDataDomain: Domain<Y> | null, oldYDataDomain: Domain<Y> | null): void;
    protected didSetYDataDomain(newYDataDomain: Domain<Y> | null, oldYDataDomain: Domain<Y> | null): void;
    protected updateYDataDomain(dataPointView: DataPointView<X, Y>): void;
    readonly xDataRange: Range_2<number> | null;
    protected setXDataRange(xDataRange: Range_2<number> | null): void;
    protected updateXDataRange(): void;
    readonly yDataRange: Range_2<number> | null;
    protected setYDataRange(yDataRange: Range_2<number> | null): void;
    protected updateYDataRange(): void;
    /** @internal */
    readonly gradientStops: number;
    readonly dataPoints: ViewSet<this, DataPointView<X, Y>>;
    static readonly dataPoints: MemberFastenerClass<SeriesPlotView, "dataPoints">;
    /** @internal */
    readonly dataPointViews: BTree<X, DataPointView<X, Y>>;
    getDataPoint(x: X): DataPointView<X, Y> | null;
    insertDataPoint(dataPointView: AnyDataPointView<X, Y>): DataPointView<X, Y>;
    insertDataPoints(...dataPointViews: AnyDataPointView<X, Y>[]): void;
    removeDataPoint(x: X): DataPointView<X, Y> | null;
    setChild<V extends View>(key: string, newChild: V): View | null;
    setChild<F extends ViewCreator<F>>(key: string, factory: F): View | null;
    setChild(key: string, newChild: AnyView | null): View | null;
    appendChild<V extends View>(child: V, key?: string): V;
    appendChild<F extends ViewCreator<F>>(factory: F, key?: string): InstanceType<F>;
    appendChild(child: AnyView, key?: string): View;
    prependChild<V extends View>(child: V, key?: string): V;
    prependChild<F extends ViewCreator<F>>(factory: F, key?: string): InstanceType<F>;
    prependChild(child: AnyView, key?: string): View;
    insertChild<V extends View>(child: V, target: View | null, key?: string): V;
    insertChild<F extends ViewCreator<F>>(factory: F, target: View | null, key?: string): InstanceType<F>;
    insertChild(child: AnyView, target: View | null, key?: string): View;
    protected onLayout(viewContext: ViewContextType<this>): void;
    /**
     * Updates own scale ranges to project onto view frame.
     */
    protected resizeScales(frame: R2Box): void;
    protected displayChildren(displayFlags: ViewFlags, viewContext: ViewContextType<this>, displayChild: (this: this, child: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    protected layoutChildViews(xScale: ContinuousScale<X, number>, yScale: ContinuousScale<Y, number>, displayFlags: ViewFlags, viewContext: ViewContextType<this>, displayChild: (this: this, child: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    protected didRender(viewContext: ViewContextType<this>): void;
    protected abstract renderPlot(context: CanvasContext, frame: R2Box): void;
    protected hitTest(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestChildren(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestDomain(x: number, y: number, renderer: CanvasRenderer): GraphicsView | null;
    protected abstract hitTestPlot(x: number, y: number, renderer: CanvasRenderer): GraphicsView | null;
    init(init: SeriesPlotViewInit<X, Y>): void;
}

/** @public */
export declare interface SeriesPlotViewInit<X = unknown, Y = unknown> extends PlotViewInit<X, Y> {
    hitMode?: SeriesPlotHitMode;
}

/** @public */
export declare interface SeriesPlotViewObserver<X = unknown, Y = unknown, V extends SeriesPlotView<X, Y> = SeriesPlotView<X, Y>> extends PlotViewObserver<X, Y, V> {
}

/** @internal */
export declare class ShadowLook extends Look<BoxShadow, AnyBoxShadow> {
    combine(combination: BoxShadow | undefined, value: BoxShadow, weight?: number): BoxShadow;
    between(a: BoxShadow, b: BoxShadow): Interpolator<BoxShadow>;
    coerce(value: AnyBoxShadow): BoxShadow;
}

/** @public */
export declare class SliceController extends Controller {
    readonly observerType?: Class<SliceControllerObserver>;
    protected updateLabel(value: number, sliceTrait: SliceTrait): void;
    protected updateLegend(value: number, sliceTrait: SliceTrait): void;
    protected setValue(value: number, timing?: AnyTiming | boolean): void;
    protected setSliceColor(sliceColor: Look<Color> | Color | null, timing?: AnyTiming | boolean): void;
    protected createLabelView(label: SliceLabel): GraphicsView | string | null;
    protected setLabelView(label: SliceLabel | null): void;
    protected createLegendView(legend: SliceLegend): GraphicsView | string | null;
    protected setLegendView(legend: SliceLegend | null): void;
    readonly sliceTiming: Property<this, Timing | boolean | undefined, AnyTiming>;
    readonly slice: TraitViewRef<this, SliceTrait, SliceView>;
    static readonly slice: MemberFastenerClass<SliceController, "slice">;
    readonly label: ViewRef<this, GraphicsView>;
    static readonly label: MemberFastenerClass<SliceController, "label">;
    readonly legend: ViewRef<this, GraphicsView>;
    static readonly legend: MemberFastenerClass<SliceController, "legend">;
}

/** @public */
export declare interface SliceControllerObserver<C extends SliceController = SliceController> extends ControllerObserver<C> {
    controllerWillAttachSliceTrait?(sliceTrait: SliceTrait, controller: C): void;
    controllerDidDetachSliceTrait?(sliceTrait: SliceTrait, controller: C): void;
    controllerWillAttachSliceView?(sliceView: SliceView, controller: C): void;
    controllerDidDetachSliceView?(sliceView: SliceView, controller: C): void;
    controllerWillSetSliceValue?(newValue: number, oldValue: number, controller: C): void;
    controllerDidSetSliceValue?(newValue: number, oldValue: number, controller: C): void;
    controllerWillAttachSliceLabelView?(labelView: GraphicsView, controller: C): void;
    controllerDidDetachSliceLabelView?(labelView: GraphicsView, controller: C): void;
    controllerWillAttachSliceLegendView?(legendView: GraphicsView, controller: C): void;
    controllerDidDetachSliceLegendView?(legendView: GraphicsView, controller: C): void;
}

/** @public */
export declare type SliceLabel = SliceLabelFunction | string;

/** @public */
export declare type SliceLabelFunction = (sliceTrait: SliceTrait | null) => GraphicsView | string | null;

/** @public */
export declare type SliceLegend = SliceLegendFunction | string;

/** @public */
export declare type SliceLegendFunction = (sliceTrait: SliceTrait | null) => GraphicsView | string | null;

/** @public */
export declare class SliceTrait extends Trait {
    readonly observerType?: Class<SliceTraitObserver>;
    readonly value: Property<this, number>;
    readonly sliceColor: Property<this, Look<Color> | Color | null, Look<Color> | AnyColor | null>;
    formatLabel(value: number): string | undefined;
    readonly label: Property<this, SliceLabel | null>;
    formatLegend(value: number): string | undefined;
    readonly legend: Property<this, SliceLegend | null>;
}

/** @public */
export declare interface SliceTraitObserver<R extends SliceTrait = SliceTrait> extends TraitObserver<R> {
    traitWillSetSliceValue?(newValue: number, oldValue: number, trait: R): void;
    traitDidSetSliceValue?(newValue: number, oldValue: number, trait: R): void;
    traitWillSetSliceColor?(newSliceColor: Look<Color> | Color | null, oldSliceColor: Look<Color> | Color | null, trait: R): void;
    traitDidSetSliceColor?(newSliceColor: Look<Color> | Color | null, oldSliceColor: Look<Color> | Color | null, trait: R): void;
    traitWillSetSliceLabel?(newLabel: SliceLabel | null, oldLabel: SliceLabel | null, trait: R): void;
    traitDidSetSliceLabel?(newLabel: SliceLabel | null, oldLabel: SliceLabel | null, trait: R): void;
    traitWillSetSliceLegend?(newLegend: SliceLegend | null, oldLegend: SliceLegend | null, trait: R): void;
    traitDidSetSliceLegend?(newLegend: SliceLegend | null, oldLegend: SliceLegend | null, trait: R): void;
}

/** @public */
export declare class SliceView extends GraphicsView {
    readonly observerType?: Class<SliceViewObserver>;
    readonly value: Animator<this, number>;
    readonly total: Animator<this, number>;
    readonly center: Animator<this, R2Point, AnyR2Point>;
    readonly innerRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly outerRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly phaseAngle: ThemeAnimator<this, Angle, AnyAngle>;
    readonly padAngle: ThemeAnimator<this, Angle, AnyAngle>;
    readonly padRadius: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly cornerRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly labelRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly sliceColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly tickAlign: ThemeAnimator<this, number>;
    readonly tickRadius: ThemeAnimator<this, Length, AnyLength>;
    readonly tickLength: ThemeAnimator<this, Length, AnyLength>;
    readonly tickWidth: ThemeAnimator<this, Length, AnyLength>;
    readonly tickPadding: ThemeAnimator<this, Length, AnyLength>;
    readonly tickColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly font: ThemeAnimator<this, Font | null, AnyFont | null>;
    readonly textColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly label: ViewRef<this, GraphicsView & Initable<GraphicsViewInit | string>>;
    static readonly label: MemberFastenerClass<SliceView, "label">;
    readonly legend: ViewRef<this, GraphicsView & Initable<GraphicsViewInit | string>>;
    static readonly legend: MemberFastenerClass<SliceView, "legend">;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected renderSlice(context: PaintingContext, frame: R2Box): void;
    protected hitTest(x: number, y: number, viewContext: ViewContextType<this>): GraphicsView | null;
    protected hitTestSlice(x: number, y: number, context: CanvasContext, frame: R2Box): GraphicsView | null;
    init(init: SliceViewInit): void;
}

/** @public */
export declare interface SliceViewInit extends GraphicsViewInit {
    value?: number;
    total?: number;
    center?: AnyR2Point;
    innerRadius?: AnyLength;
    outerRadius?: AnyLength;
    phaseAngle?: AnyAngle;
    padAngle?: AnyAngle;
    padRadius?: AnyLength | null;
    cornerRadius?: AnyLength;
    labelRadius?: AnyLength;
    sliceColor?: AnyColor;
    tickAlign?: number;
    tickRadius?: AnyLength;
    tickLength?: AnyLength;
    tickWidth?: AnyLength;
    tickPadding?: AnyLength;
    tickColor?: AnyColor;
    font?: AnyFont;
    textColor?: AnyColor;
    label?: GraphicsView | string;
    legend?: GraphicsView | string;
}

/** @public */
export declare interface SliceViewObserver<V extends SliceView = SliceView> extends ViewObserver<V> {
    viewWillSetSliceValue?(newValue: number, oldValue: number, view: V): void;
    viewDidSetSliceValue?(newValue: number, oldValue: number, view: V): void;
    viewWillAttachSliceLabel?(labelView: GraphicsView, view: V): void;
    viewDidDetachSliceLabel?(labelView: GraphicsView, view: V): void;
    viewWillAttachSliceLegend?(legendView: GraphicsView, view: V): void;
    viewDidDetachSliceLegend?(legendView: GraphicsView, view: V): void;
}

/** @public */
export declare class Sprite {
    /** @internal */
    constructor(sheet: SpriteSheet, rowIndex: number, colIndex: number);
    /** @internal */
    readonly sheet: SpriteSheet;
    /** @internal */
    readonly rowIndex: number;
    /** @internal */
    readonly colIndex: number;
    get width(): number;
    get height(): number;
    get pixelRatio(): number;
    getRenderer(): CanvasRenderer;
    clear(): void;
    draw(context: CanvasContext, frame: R2Box): void;
    release(): void;
}

/** @public */
export declare class SpriteService {
    constructor(canvasWidth?: number, canvasHeight?: number, pixelRatio?: number, minSizeClass?: number, maxSizeClass?: number);
    readonly canvasWidth: number;
    readonly canvasHeight: number;
    readonly pixelRatio: number;
    readonly minSizeClass: number;
    readonly maxSizeClass: number;
    readonly slabs: ReadonlyArray<SpriteSheet | null>;
    /** @internal */
    protected createSlab(sizeClass: number): SpriteSheet;
    /** @internal */
    getFreeSlab(sizeClass: number): SpriteSheet | null;
    /** @internal */
    protected createSheet(width: number, height: number): SpriteSheet;
    /** @internal */
    getFreeSheet(width: number, height: number): SpriteSheet;
    acquireSprite(width: number, height: number): Sprite;
    static global(): SpriteService;
    /** @internal */
    static readonly TextureWidth: number;
    /** @internal */
    static readonly TextureHeight: number;
}

/** @public */
export declare class SpriteSheet {
    constructor(spriteWidth: number, spriteHeight: number, canvasWidth: number, canvasHeight: number, pixelRatio: number);
    protected createSprites(sprites: Sprite[], rowCount: number, colCount: number): void;
    protected createSprite(rowIndex: number, colIndex: number): Sprite;
    readonly spriteWidth: number;
    readonly spriteHeight: number;
    readonly sprites: ReadonlyArray<Sprite>;
    /** @internal */
    readonly freeSprites: Sprite[];
    readonly canvas: HTMLCanvasElement;
    readonly renderer: CanvasRenderer;
    /** @internal */
    nextSheet: SpriteSheet | null;
    get pixelRatio(): number;
    get canvasWidth(): number;
    get canvasHeight(): number;
    get rowCount(): number;
    get colCount(): number;
    get spriteCount(): number;
    get freeCount(): number;
    /** @internal */
    static acquireNextFreeSheet(sheet: SpriteSheet): SpriteSheet | null;
    acquireSprite(): Sprite | null;
    /** @internal */
    releaseSprite(sprite: Sprite): void;
    /** @internal */
    clearSprite(rowIndex: number, colIndex: number): void;
    /** @internal */
    getSpriteRenderer(rowIndex: number, colIndex: number): CanvasRenderer;
    /** @internal */
    drawSprite(context: CanvasContext, frame: R2Box, rowIndex: number, colIndex: number): void;
}

/** @public */
export declare interface StorageProvider<C extends Controller, S extends StorageService<C> | null | undefined = StorageService<C>> extends Provider<C, S> {
    get(key: string): string | undefined;
    set(key: string, newValue: string | undefined): string | undefined;
    clear(): void;
    createService(): S;
}

/** @public */
export declare const StorageProvider: ProviderClass<StorageProvider<any, any>>;

/** @public */
export declare abstract class StorageService<C extends Controller = Controller> extends Service<C> {
    readonly observerType?: Class<StorageServiceObserver<C>>;
    abstract get(key: string): string | undefined;
    abstract set(key: string, newValue: string | undefined): string | undefined;
    protected willSet(key: string, newValue: string | undefined, oldValue: string | undefined): void;
    protected onSet(key: string, newValue: string | undefined, oldValue: string | undefined): void;
    protected didSet(key: string, newValue: string | undefined, oldValue: string | undefined): void;
    abstract clear(): void;
    protected willClear(): void;
    protected onClear(): void;
    protected didClear(): void;
    static global<C extends Controller>(): StorageService<C>;
}

/** @public */
export declare interface StorageServiceObserver<C extends Controller = Controller, S extends StorageService<C> = StorageService<C>> extends ServiceObserver<C, S> {
    serviceWillStore?(key: string, newValue: string | undefined, oldValue: string | undefined, service: S): void;
    serviceDidStore?(key: string, newValue: string | undefined, oldValue: string | undefined, service: S): void;
    serviceWillClear?(service: S): void;
    serviceDidClear?(service: S): void;
}

/** @internal */
export declare const StringAttributeAnimator: AttributeAnimatorFactory<AttributeAnimator<any, string | undefined, string | undefined>>;

/** @internal */
export declare const StringStyleAnimator: StyleAnimatorFactory<StyleAnimator<any, string | undefined, string | undefined>>;

/** @internal */
export declare const StringThemeAnimator: ThemeAnimatorFactory<ThemeAnimator<any, string | null | undefined, string | null | undefined>>;

/** @public */
export declare type StrokeLinecap = "butt" | "round" | "square";

/** @public */
export declare type StrokeLinejoin = "arcs" | "bevel" | "miter" | "miter-clip" | "round";

/** @public */
export declare interface StrokeView extends GraphicsView {
    readonly stroke: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly strokeWidth: ThemeAnimator<this, Length | null, AnyLength | null>;
}

/** @public */
export declare const StrokeView: {
    init(view: StrokeView, init: StrokeViewInit): void;
    is(object: unknown): object is StrokeView;
};

/** @public */
export declare interface StrokeViewInit extends GraphicsViewInit {
    stroke?: AnyColor;
    strokeWidth?: AnyLength;
}

/** @public */
export declare interface StyleAnimator<O = unknown, T = unknown, U = never> extends ThemeAnimator<O, T, U> {
    get propertyNames(): string | ReadonlyArray<string>;
    get propertyValue(): T | undefined;
    get computedValue(): T | undefined;
    /** @internal */
    readonly ownValue: T;
    get value(): T;
    set value(value: T);
    /** @override @protected */
    onSetValue(newValue: T, oldValue: T): void;
    readonly priority: string | undefined;
    setPriority(priority: string | undefined): void;
    parse(value: string): T;
    fromCssValue(value: CSSStyleValue): T;
}

/** @public */
export declare const StyleAnimator: StyleAnimatorFactory<StyleAnimator<any, any, any>>;

/** @public */
export declare interface StyleAnimatorClass<A extends StyleAnimator<any, any> = StyleAnimator<any, any, any>> extends ThemeAnimatorClass<A> {
}

/** @public */
export declare type StyleAnimatorDescriptor<O = unknown, T = unknown, U = never, I = {}> = ThisType<StyleAnimator<O, T, U> & I> & StyleAnimatorInit<T, U> & Partial<I>;

/** @public */
export declare interface StyleAnimatorFactory<A extends StyleAnimator<any, any> = StyleAnimator<any, any, any>> extends StyleAnimatorClass<A> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): StyleAnimatorFactory<A> & I;
    specialize(type: unknown): StyleAnimatorFactory | null;
    define<O, T, U = never>(className: string, descriptor: StyleAnimatorDescriptor<O, T, U>): StyleAnimatorFactory<StyleAnimator<any, T, U>>;
    define<O, T, U = never, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & StyleAnimatorDescriptor<O, T, U, I>): StyleAnimatorFactory<StyleAnimator<any, T, U> & I>;
    <O, T extends Length | null | undefined = Length | null | undefined, U extends AnyLength | null | undefined = AnyLength | null | undefined>(descriptor: {
        type: typeof Length;
    } & StyleAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends Color | null | undefined = Color | null | undefined, U extends AnyColor | null | undefined = AnyColor | null | undefined>(descriptor: {
        type: typeof Color;
    } & StyleAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends BoxShadow | null | undefined = BoxShadow | null | undefined, U extends AnyBoxShadow | null | undefined = AnyBoxShadow | null | undefined>(descriptor: {
        type: typeof BoxShadow;
    } & StyleAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends Transform | null | undefined = Transform | null | undefined, U extends AnyTransform | null | undefined = AnyTransform | null | undefined>(descriptor: {
        type: typeof Transform;
    } & StyleAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends FontFamily | ReadonlyArray<FontFamily> | null | undefined = FontFamily | ReadonlyArray<FontFamily> | null | undefined, U extends FontFamily | ReadonlyArray<FontFamily> | null | undefined = FontFamily | ReadonlyArray<FontFamily> | null | undefined>(descriptor: {
        type: typeof FontFamily;
    } & StyleAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends string | null | undefined = string | null | undefined, U extends string | null | undefined = string | null | undefined>(descriptor: {
        type: typeof String;
    } & StyleAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends number | null | undefined = number | null | undefined, U extends number | string | null | undefined = number | string | null | undefined>(descriptor: {
        type: typeof Number;
    } & StyleAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = never>(descriptor: ({
        type: FromAny<T, U>;
    } | {
        fromAny(value: T | U): T;
    }) & StyleAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = never>(descriptor: StyleAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = never, I = {}>(descriptor: {
        implements: unknown;
    } & StyleAnimatorDescriptor<O, T, U, I>): PropertyDecorator;
}

/** @public */
export declare interface StyleAnimatorInit<T = unknown, U = never> extends ThemeAnimatorInit<T, U> {
    extends?: {
        prototype: StyleAnimator<any, any>;
    } | string | boolean | null;
    propertyNames: string | ReadonlyArray<string>;
    parse?(value: string): T;
    fromCssValue?(value: CSSStyleValue): T;
}

/** @public */
export declare interface StyleConstraintAnimator<O = unknown, T = unknown, U = never> extends StyleAnimator<O, T, U>, ConstraintVariable {
    /** @internal @override */
    readonly id: number;
    /** @internal @override */
    isExternal(): boolean;
    /** @internal @override */
    isDummy(): boolean;
    /** @internal @override */
    isInvalid(): boolean;
    /** @override */
    isConstant(): boolean;
    /** @internal @override */
    evaluateConstraintVariable(): void;
    /** @internal @override */
    updateConstraintSolution(value: number): void;
    /** @override */
    readonly strength: ConstraintStrength;
    setStrength(strength: AnyConstraintStrength): void;
    /** @override */
    get coefficient(): number;
    /** @override */
    get variable(): ConstraintVariable | null;
    /** @override */
    get terms(): ConstraintMap<ConstraintVariable, number>;
    /** @override */
    get constant(): number;
    /** @override */
    plus(that: AnyConstraintExpression): ConstraintExpression;
    /** @override */
    negative(): ConstraintTerm;
    /** @override */
    minus(that: AnyConstraintExpression): ConstraintExpression;
    /** @override */
    times(scalar: number): ConstraintExpression;
    /** @override */
    divide(scalar: number): ConstraintExpression;
    get constrained(): boolean;
    constrain(constrained?: boolean): this;
    /** @internal */
    readonly conditionCount: number;
    /** @internal @override */
    addConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;
    /** @internal @override */
    removeConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;
    /** @internal */
    get constraining(): boolean;
    /** @internal */
    startConstraining(): void;
    /** @protected */
    willStartConstraining(): void;
    /** @protected */
    onStartConstraining(): void;
    /** @protected */
    didStartConstraining(): void;
    /** @internal */
    stopConstraining(): void;
    /** @protected */
    willStopConstraining(): void;
    /** @protected */
    onStopConstraining(): void;
    /** @protected */
    didStopConstraining(): void;
    /** @internal */
    updateConstraintVariable(): void;
    /** @protected @override */
    onSetValue(newValue: T, oldValue: T): void;
    /** @protected @override */
    onMount(): void;
    /** @protected @override */
    onUnmount(): void;
    /** @override */
    fromAny(value: T | U): T;
    /** @internal @protected */
    toNumber(value: T): number;
    /** @internal @protected */
    readonly constraintValue?: T;
}

/** @public */
export declare const StyleConstraintAnimator: StyleConstraintAnimatorFactory<StyleConstraintAnimator<any, any, any>>;

/** @public */
export declare interface StyleConstraintAnimatorClass<A extends StyleConstraintAnimator<any, any> = StyleConstraintAnimator<any, any, any>> extends StyleAnimatorClass<A> {
    /** @internal */
    readonly ConstrainedFlag: FastenerFlags;
    /** @internal */
    readonly ConstrainingFlag: FastenerFlags;
    /** @internal @override */
    readonly FlagShift: number;
    /** @internal @override */
    readonly FlagMask: FastenerFlags;
}

/** @public */
export declare type StyleConstraintAnimatorDescriptor<O = unknown, T = unknown, U = never, I = {}> = ThisType<StyleConstraintAnimator<O, T, U> & I> & StyleConstraintAnimatorInit<T, U> & Partial<I>;

/** @public */
export declare interface StyleConstraintAnimatorFactory<A extends StyleConstraintAnimator<any, any> = StyleConstraintAnimator<any, any, any>> extends StyleConstraintAnimatorClass<A> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): StyleConstraintAnimatorFactory<A> & I;
    specialize(type: unknown): StyleConstraintAnimatorFactory | null;
    define<O, T, U = never>(className: string, descriptor: StyleConstraintAnimatorDescriptor<O, T, U>): StyleConstraintAnimatorFactory<StyleConstraintAnimator<any, T, U>>;
    define<O, T, U = never, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & StyleConstraintAnimatorDescriptor<O, T, U, I>): StyleConstraintAnimatorFactory<StyleConstraintAnimator<any, T, U> & I>;
    <O, T extends Length | null | undefined = Length | null | undefined, U extends AnyLength | null | undefined = AnyLength | null | undefined>(descriptor: {
        type: typeof Length;
    } & StyleConstraintAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends number | undefined = number | undefined, U extends number | string | undefined = number | string | undefined>(descriptor: {
        type: typeof Number;
    } & StyleConstraintAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = never>(descriptor: ({
        type: FromAny<T, U>;
    } | {
        fromAny(value: T | U): T;
    }) & StyleConstraintAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = never>(descriptor: StyleConstraintAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = never, I = {}>(descriptor: {
        implements: unknown;
    } & StyleConstraintAnimatorDescriptor<O, T, U, I>): PropertyDecorator;
}

/** @public */
export declare interface StyleConstraintAnimatorInit<T = unknown, U = never> extends StyleAnimatorInit<T, U> {
    extends?: {
        prototype: StyleConstraintAnimator<any, any>;
    } | string | boolean | null;
    constrain?: boolean;
    strength?: AnyConstraintStrength;
    willStartConstraining?(): void;
    didStartConstraining?(): void;
    willStopConstraining?(): void;
    didStopConstraining?(): void;
    constraintValue?: T;
    toNumber?(value: T): number;
}

/** @public */
export declare interface StyleContext {
    readonly node?: Node;
    getStyle(propertyNames: string | ReadonlyArray<string>): CSSStyleValue | string | undefined;
    setStyle(propertyName: string, value: unknown, priority?: string): this;
}

/** @public */
export declare const StyleContext: {
    is(object: unknown): object is StyleContext;
};

/** @public */
export declare interface StyleMap extends StyleContext {
    readonly alignContent: StyleAnimator<this, AlignContent | undefined>;
    readonly alignItems: StyleAnimator<this, AlignItems | undefined>;
    readonly alignSelf: StyleAnimator<this, AlignSelf | undefined>;
    readonly appearance: StyleAnimator<this, Appearance | undefined>;
    readonly backdropFilter: StyleAnimator<this, string | undefined>;
    readonly backgroundClip: StyleAnimator<this, BackgroundClip | undefined>;
    readonly backgroundColor: StyleAnimator<this, Color | null, AnyColor | null>;
    readonly backgroundImage: StyleAnimator<this, LinearGradient | string | null, AnyLinearGradient | string | null>;
    readonly borderCollapse: StyleAnimator<this, BorderCollapse | undefined>;
    borderColor(): [Color | null, Color | null, Color | null, Color | null] | Color | null;
    borderColor(value: [AnyColor | null, AnyColor | null, AnyColor | null, AnyColor | null] | AnyColor | null, timing?: AnyTiming | boolean, precedence?: number): this;
    readonly borderTopColor: StyleAnimator<this, Color | null, AnyColor | null>;
    readonly borderRightColor: StyleAnimator<this, Color | null, AnyColor | null>;
    readonly borderBottomColor: StyleAnimator<this, Color | null, AnyColor | null>;
    readonly borderLeftColor: StyleAnimator<this, Color | null, AnyColor | null>;
    borderRadius(): [Length | null, Length | null, Length | null, Length | null] | Length | null;
    borderRadius(value: [AnyLength | null, AnyLength | null, AnyLength | null, AnyLength | null] | AnyLength | null, timing?: AnyTiming | boolean, precedence?: number): this;
    readonly borderTopLeftRadius: StyleAnimator<this, Length | null, AnyLength | null>;
    readonly borderTopRightRadius: StyleAnimator<this, Length | null, AnyLength | null>;
    readonly borderBottomRightRadius: StyleAnimator<this, Length | null, AnyLength | null>;
    readonly borderBottomLeftRadius: StyleAnimator<this, Length | null, AnyLength | null>;
    readonly borderSpacing: StyleAnimator<this, string | undefined>;
    borderStyle(): [BorderStyle | undefined, BorderStyle | undefined, BorderStyle | undefined, BorderStyle | undefined] | BorderStyle | undefined;
    borderStyle(value: [BorderStyle | undefined, BorderStyle | undefined, BorderStyle | undefined, BorderStyle | undefined] | BorderStyle | undefined, timing?: AnyTiming | boolean, precedence?: number): this;
    readonly borderTopStyle: StyleAnimator<this, BorderStyle | undefined>;
    readonly borderRightStyle: StyleAnimator<this, BorderStyle | undefined>;
    readonly borderBottomStyle: StyleAnimator<this, BorderStyle | undefined>;
    readonly borderLeftStyle: StyleAnimator<this, BorderStyle | undefined>;
    borderWidth(): [Length | null, Length | null, Length | null, Length | null] | Length | null;
    borderWidth(value: [AnyLength | null, AnyLength | null, AnyLength | null, AnyLength | null] | AnyLength | null, timing?: AnyTiming | boolean, precedence?: number): this;
    readonly borderTopWidth: StyleAnimator<this, Length | null, AnyLength | null>;
    readonly borderRightWidth: StyleAnimator<this, Length | null, AnyLength | null>;
    readonly borderBottomWidth: StyleAnimator<this, Length | null, AnyLength | null>;
    readonly borderLeftWidth: StyleAnimator<this, Length | null, AnyLength | null>;
    readonly bottom: StyleConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly boxShadow: StyleAnimator<this, BoxShadow | null, AnyBoxShadow | null>;
    readonly boxSizing: StyleAnimator<this, BoxSizing | undefined>;
    readonly color: StyleAnimator<this, Color | null, AnyColor | null>;
    readonly cursor: StyleAnimator<this, CssCursor | undefined>;
    readonly display: StyleAnimator<this, CssDisplay | undefined>;
    readonly filter: StyleAnimator<this, string | undefined>;
    readonly flexBasis: StyleAnimator<this, Length | FlexBasis | null, AnyLength | FlexBasis | null>;
    readonly flexDirection: StyleAnimator<this, FlexDirection | string>;
    readonly flexGrow: StyleAnimator<this, number | undefined>;
    readonly flexShrink: StyleAnimator<this, number | undefined>;
    readonly flexWrap: StyleAnimator<this, FlexWrap | undefined>;
    font(): Font | null;
    font(value: AnyFont | null, timing?: AnyTiming | boolean, precedence?: number): this;
    readonly fontFamily: StyleAnimator<this, FontFamily | FontFamily[] | undefined, FontFamily | ReadonlyArray<FontFamily> | undefined>;
    readonly fontSize: StyleAnimator<this, Length | null, AnyLength | null>;
    readonly fontStretch: StyleAnimator<this, FontStretch | undefined>;
    readonly fontStyle: StyleAnimator<this, FontStyle | undefined>;
    readonly fontVariant: StyleAnimator<this, FontVariant | undefined>;
    readonly fontWeight: StyleAnimator<this, FontWeight | undefined>;
    readonly height: StyleConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly justifyContent: StyleAnimator<this, JustifyContent | undefined>;
    readonly left: StyleConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly lineHeight: StyleAnimator<this, Length | null, AnyLength | null>;
    margin(): [Length | null, Length | null, Length | null, Length | null] | Length | null;
    margin(value: [AnyLength | null, AnyLength | null, AnyLength | null, AnyLength | null] | AnyLength | null, timing?: AnyTiming | boolean, precedence?: number): this;
    readonly marginTop: StyleConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly marginRight: StyleConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly marginBottom: StyleConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly marginLeft: StyleConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly maxHeight: StyleAnimator<this, Length | null, AnyLength | null>;
    readonly maxWidth: StyleAnimator<this, Length | null, AnyLength | null>;
    readonly minHeight: StyleAnimator<this, Length | null, AnyLength | null>;
    readonly minWidth: StyleAnimator<this, Length | null, AnyLength | null>;
    readonly opacity: StyleAnimator<this, number | undefined>;
    readonly order: StyleAnimator<this, number | undefined>;
    readonly outlineColor: StyleAnimator<this, Color | null, AnyColor | null>;
    readonly outlineStyle: StyleAnimator<this, BorderStyle | undefined>;
    readonly outlineWidth: StyleAnimator<this, Length | null, AnyLength | null>;
    overflow(): [Overflow | undefined, Overflow | undefined] | Overflow | undefined;
    overflow(value: [Overflow | undefined, Overflow | undefined] | Overflow | undefined, timing?: AnyTiming | boolean, precedence?: number): this;
    readonly overflowX: StyleAnimator<this, Overflow | undefined>;
    readonly overflowY: StyleAnimator<this, Overflow | undefined>;
    readonly overflowScrolling: StyleAnimator<this, "auto" | "touch" | undefined>;
    overscrollBehavior(): [OverscrollBehavior | undefined, OverscrollBehavior | undefined] | OverscrollBehavior | undefined;
    overscrollBehavior(value: [OverscrollBehavior | undefined, OverscrollBehavior | undefined] | OverscrollBehavior | undefined, timing?: AnyTiming | boolean, precedence?: number): this;
    readonly overscrollBehaviorX: StyleAnimator<this, OverscrollBehavior | undefined>;
    readonly overscrollBehaviorY: StyleAnimator<this, OverscrollBehavior | undefined>;
    padding(): [Length | null, Length | null, Length | null, Length | null] | Length | null;
    padding(value: [AnyLength | null, AnyLength | null, AnyLength | null, AnyLength | null] | AnyLength | null, timing?: AnyTiming | boolean, precedence?: number): this;
    readonly paddingTop: StyleConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly paddingRight: StyleConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly paddingBottom: StyleConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly paddingLeft: StyleConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly pointerEvents: StyleAnimator<this, PointerEvents | undefined>;
    readonly position: StyleAnimator<this, Position | undefined>;
    readonly right: StyleConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly textAlign: StyleAnimator<this, TextAlign | undefined>;
    readonly textDecorationColor: StyleAnimator<this, Color | null, AnyColor | null>;
    readonly textDecorationLine: StyleAnimator<this, string | undefined>;
    readonly textDecorationStyle: StyleAnimator<this, TextDecorationStyle | undefined>;
    readonly textOverflow: StyleAnimator<this, string | undefined>;
    readonly textTransform: StyleAnimator<this, TextTransform | undefined>;
    readonly top: StyleConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly touchAction: StyleAnimator<this, TouchAction | undefined>;
    readonly transform: StyleAnimator<this, Transform | null, AnyTransform | null>;
    readonly userSelect: StyleAnimator<this, UserSelect | undefined>;
    readonly verticalAlign: StyleAnimator<this, VerticalAlign | undefined, AnyLength | VerticalAlign | undefined>;
    readonly visibility: StyleAnimator<this, Visibility | undefined>;
    readonly whiteSpace: StyleAnimator<this, WhiteSpace | undefined>;
    readonly width: StyleConstraintAnimator<this, Length | null, AnyLength | null>;
    readonly zIndex: StyleAnimator<this, number | undefined>;
}

/** @public */
export declare const StyleMap: {
    /** @internal */
    init(map: StyleMap, init: StyleMapInit): void;
    /** @internal */
    define(prototype: StyleMap): void;
};

/** @public */
export declare interface StyleMapInit {
    alignContent?: MemberAnimatorInit<StyleMap, "alignContent">;
    alignItems?: MemberAnimatorInit<StyleMap, "alignItems">;
    alignSelf?: MemberAnimatorInit<StyleMap, "alignSelf">;
    appearance?: MemberAnimatorInit<StyleMap, "appearance">;
    backdropFilter?: MemberAnimatorInit<StyleMap, "backdropFilter">;
    backgroundClip?: MemberAnimatorInit<StyleMap, "backgroundClip">;
    backgroundColor?: MemberAnimatorInit<StyleMap, "backgroundColor">;
    backgroundImage?: MemberAnimatorInit<StyleMap, "backgroundImage">;
    borderCollapse?: MemberAnimatorInit<StyleMap, "borderCollapse">;
    borderColor?: [AnyColor | null, AnyColor | null, AnyColor | null, AnyColor | null] | AnyColor | null;
    borderTopColor?: MemberAnimatorInit<StyleMap, "borderTopColor">;
    borderRightColor?: MemberAnimatorInit<StyleMap, "borderRightColor">;
    borderBottomColor?: MemberAnimatorInit<StyleMap, "borderBottomColor">;
    borderLeftColor?: MemberAnimatorInit<StyleMap, "borderLeftColor">;
    borderRadius?: [AnyLength | null, AnyLength | null, AnyLength | null, AnyLength | null] | AnyLength | null;
    borderTopLeftRadius?: MemberAnimatorInit<StyleMap, "borderTopLeftRadius">;
    borderTopRightRadius?: MemberAnimatorInit<StyleMap, "borderTopRightRadius">;
    borderBottomRightRadius?: MemberAnimatorInit<StyleMap, "borderBottomRightRadius">;
    borderBottomLeftRadius?: MemberAnimatorInit<StyleMap, "borderBottomLeftRadius">;
    borderSpacing?: MemberAnimatorInit<StyleMap, "borderSpacing">;
    borderStyle?: [BorderStyle | undefined, BorderStyle | undefined, BorderStyle | undefined, BorderStyle | undefined] | BorderStyle | undefined;
    borderTopStyle?: MemberAnimatorInit<StyleMap, "borderTopStyle">;
    borderRightStyle?: MemberAnimatorInit<StyleMap, "borderRightStyle">;
    borderBottomStyle?: MemberAnimatorInit<StyleMap, "borderBottomStyle">;
    borderLeftStyle?: MemberAnimatorInit<StyleMap, "borderLeftStyle">;
    borderWidth?: [AnyLength | null, AnyLength | null, AnyLength | null, AnyLength | null] | AnyLength | null;
    borderTopWidth?: MemberAnimatorInit<StyleMap, "borderTopWidth">;
    borderRightWidth?: MemberAnimatorInit<StyleMap, "borderRightWidth">;
    borderBottomWidth?: MemberAnimatorInit<StyleMap, "borderBottomWidth">;
    borderLeftWidth?: MemberAnimatorInit<StyleMap, "borderLeftWidth">;
    bottom?: MemberAnimatorInit<StyleMap, "bottom">;
    boxShadow?: MemberAnimatorInit<StyleMap, "boxShadow">;
    boxSizing?: MemberAnimatorInit<StyleMap, "boxSizing">;
    color?: MemberAnimatorInit<StyleMap, "color">;
    cursor?: MemberAnimatorInit<StyleMap, "cursor">;
    display?: MemberAnimatorInit<StyleMap, "display">;
    filter?: MemberAnimatorInit<StyleMap, "filter">;
    flexBasis?: MemberAnimatorInit<StyleMap, "flexBasis">;
    flexDirection?: MemberAnimatorInit<StyleMap, "flexDirection">;
    flexGrow?: MemberAnimatorInit<StyleMap, "flexGrow">;
    flexShrink?: MemberAnimatorInit<StyleMap, "flexShrink">;
    flexWrap?: MemberAnimatorInit<StyleMap, "flexWrap">;
    font?: AnyFont;
    fontFamily?: MemberAnimatorInit<StyleMap, "fontFamily">;
    fontSize?: MemberAnimatorInit<StyleMap, "fontSize">;
    fontStretch?: MemberAnimatorInit<StyleMap, "fontStretch">;
    fontStyle?: MemberAnimatorInit<StyleMap, "fontStyle">;
    fontVariant?: MemberAnimatorInit<StyleMap, "fontVariant">;
    fontWeight?: MemberAnimatorInit<StyleMap, "fontWeight">;
    height?: MemberAnimatorInit<StyleMap, "height">;
    justifyContent?: MemberAnimatorInit<StyleMap, "justifyContent">;
    left?: MemberAnimatorInit<StyleMap, "left">;
    lineHeight?: MemberAnimatorInit<StyleMap, "lineHeight">;
    margin?: [AnyLength | null, AnyLength | null, AnyLength | null, AnyLength | null] | AnyLength;
    marginTop?: MemberAnimatorInit<StyleMap, "marginTop">;
    marginRight?: MemberAnimatorInit<StyleMap, "marginRight">;
    marginBottom?: MemberAnimatorInit<StyleMap, "marginBottom">;
    marginLeft?: MemberAnimatorInit<StyleMap, "marginLeft">;
    maxHeight?: MemberAnimatorInit<StyleMap, "maxHeight">;
    maxWidth?: MemberAnimatorInit<StyleMap, "maxWidth">;
    minHeight?: MemberAnimatorInit<StyleMap, "minHeight">;
    minWidth?: MemberAnimatorInit<StyleMap, "minWidth">;
    opacity?: MemberAnimatorInit<StyleMap, "opacity">;
    order?: MemberAnimatorInit<StyleMap, "order">;
    outlineColor?: MemberAnimatorInit<StyleMap, "outlineColor">;
    outlineStyle?: MemberAnimatorInit<StyleMap, "outlineStyle">;
    outlineWidth?: MemberAnimatorInit<StyleMap, "outlineWidth">;
    overflow?: [Overflow | undefined, Overflow | undefined] | Overflow | undefined;
    overflowX?: MemberAnimatorInit<StyleMap, "overflowX">;
    overflowY?: MemberAnimatorInit<StyleMap, "overflowY">;
    overflowScrolling?: MemberAnimatorInit<StyleMap, "overflowScrolling">;
    overscrollBehavior?: [OverscrollBehavior | undefined, OverscrollBehavior | undefined] | OverscrollBehavior | undefined;
    overscrollBehaviorX?: MemberAnimatorInit<StyleMap, "overscrollBehaviorX">;
    overscrollBehaviorY?: MemberAnimatorInit<StyleMap, "overscrollBehaviorY">;
    padding?: [AnyLength | null, AnyLength | null, AnyLength | null, AnyLength | null] | AnyLength | null;
    paddingTop?: MemberAnimatorInit<StyleMap, "paddingTop">;
    paddingRight?: MemberAnimatorInit<StyleMap, "paddingRight">;
    paddingBottom?: MemberAnimatorInit<StyleMap, "paddingBottom">;
    paddingLeft?: MemberAnimatorInit<StyleMap, "paddingLeft">;
    pointerEvents?: MemberAnimatorInit<StyleMap, "pointerEvents">;
    position?: MemberAnimatorInit<StyleMap, "position">;
    right?: MemberAnimatorInit<StyleMap, "right">;
    textAlign?: MemberAnimatorInit<StyleMap, "textAlign">;
    textDecorationColor?: MemberAnimatorInit<StyleMap, "textDecorationColor">;
    textDecorationLine?: MemberAnimatorInit<StyleMap, "textDecorationLine">;
    textDecorationStyle?: MemberAnimatorInit<StyleMap, "textDecorationStyle">;
    textOverflow?: MemberAnimatorInit<StyleMap, "textOverflow">;
    textTransform?: MemberAnimatorInit<StyleMap, "textTransform">;
    top?: MemberAnimatorInit<StyleMap, "top">;
    touchAction?: MemberAnimatorInit<StyleMap, "touchAction">;
    transform?: MemberAnimatorInit<StyleMap, "transform">;
    userSelect?: MemberAnimatorInit<StyleMap, "userSelect">;
    verticalAlign?: MemberAnimatorInit<StyleMap, "verticalAlign">;
    visibility?: MemberAnimatorInit<StyleMap, "visibility">;
    whiteSpace?: MemberAnimatorInit<StyleMap, "whiteSpace">;
    width?: MemberAnimatorInit<StyleMap, "width">;
    zIndex?: MemberAnimatorInit<StyleMap, "zIndex">;
}

/** @public */
export declare interface StyleRule<O = unknown> extends CssRule<O>, StyleMap {
    (property: string): unknown;
    (property: string, value: unknown): O;
    /** @override */
    readonly rule: CSSStyleRule;
    get selector(): string;
    setSelector(selector: string): void;
    /** @override */
    getStyle(propertyNames: string | ReadonlyArray<string>): CSSStyleValue | string | undefined;
    /** @override */
    setStyle(propertyName: string, value: unknown, priority?: string): this;
    /** @protected */
    willSetStyle(propertyName: string, value: unknown, priority: string | undefined): void;
    /** @protected */
    onSetStyle(propertyName: string, value: unknown, priority: string | undefined): void;
    /** @protected */
    didSetStyle(propertyName: string, value: unknown, priority: string | undefined): void;
    /** @override */
    applyTheme(theme: ThemeMatrix, mood: MoodVector, timing?: AnyTiming | boolean | null): void;
    /** @internal */
    createRule(cssText: string): CSSStyleRule;
    /** @internal */
    initRule?(rule: CSSStyleRule): void;
    /** @internal */
    initCss?(): string;
}

/** @public */
export declare const StyleRule: StyleRuleFactory<StyleRule<any>>;

/** @public */
export declare interface StyleRuleClass<F extends StyleRule<any> = StyleRule<any>> extends CssRuleClass<F> {
}

/** @public */
export declare type StyleRuleDescriptor<O = unknown, I = {}> = ThisType<StyleRule<O> & I> & StyleRuleInit & Partial<I>;

/** @public */
export declare interface StyleRuleFactory<F extends StyleRule<any> = StyleRule<any>> extends StyleRuleClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): StyleRuleFactory<F> & I;
    define<O>(className: string, descriptor: StyleRuleDescriptor<O>): StyleRuleFactory<StyleRule<any>>;
    define<O, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & StyleRuleDescriptor<O, I>): StyleRuleFactory<StyleRule<any> & I>;
    <O>(descriptor: StyleRuleDescriptor<O>): PropertyDecorator;
    <O, I = {}>(descriptor: {
        implements: unknown;
    } & StyleRuleDescriptor<O, I>): PropertyDecorator;
}

/** @public */
export declare interface StyleRuleInit extends CssRuleInit {
    extends?: {
        prototype: StyleRule<any>;
    } | string | boolean | null;
    style?: StyleMapInit;
    willSetStyle?(propertyName: string, value: unknown, priority: string | undefined): void;
    didSetStyle?(propertyName: string, value: unknown, priority: string | undefined): void;
    initRule?(rule: CSSStyleRule): void;
}

/** @public */
declare interface StyleSheet_2<O = unknown> extends Fastener<O>, FastenerContext, ConstraintScope, ThemeContext, CssContext {
    /** @override */
    get fastenerType(): Proto<StyleSheet_2<any>>;
    readonly stylesheet: CSSStyleSheet;
    /** @override */
    getRule(index: number): CSSRule | null;
    /** @override */
    insertRule(cssText: string, index?: number): number;
    /** @override */
    removeRule(index: number): void;
    /** @internal */
    readonly fasteners: {
        [fastenerName: string]: Fastener | undefined;
    } | null;
    /** @override */
    hasFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): boolean;
    /** @override */
    getFastener<F extends Fastener<any>>(fastenerName: string, fastenerBound: Proto<F>): F | null;
    /** @override */
    getFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): Fastener | null;
    /** @override */
    setFastener(fastenerName: string, fastener: Fastener | null): void;
    /** @override */
    getLazyFastener<F extends Fastener<any>>(fastenerName: string, fastenerBound: Proto<F>): F | null;
    /** @override */
    getLazyFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): Fastener | null;
    /** @override */
    getSuperFastener<F extends Fastener<any>>(fastenerName: string, fastenerBound: Proto<F>): F | null;
    /** @override */
    getSuperFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): Fastener | null;
    /** @internal @override */
    getSuperFastener(): Fastener | null;
    /** @internal @protected */
    mountFasteners(): void;
    /** @internal @protected */
    unmountFasteners(): void;
    /** @override */
    requireUpdate(updateFlags: number): void;
    /** @internal */
    readonly decoherent: ReadonlyArray<Fastener> | null;
    /** @override */
    decohereFastener(fastener: Fastener): void;
    /** @override */
    recohere(t: number): void;
    /** @internal @protected */
    recohereFasteners(t: number): void;
    /** @override */
    constraint(lhs: AnyConstraintExpression, relation: ConstraintRelation, rhs?: AnyConstraintExpression, strength?: AnyConstraintStrength): Constraint;
    /** @override */
    hasConstraint(constraint: Constraint): boolean;
    /** @override */
    addConstraint(constraint: Constraint): void;
    /** @override */
    removeConstraint(constraint: Constraint): void;
    /** @override */
    constraintVariable(name: string, value?: number, strength?: AnyConstraintStrength): ConstraintProperty<unknown, number>;
    /** @override */
    hasConstraintVariable(variable: ConstraintVariable): boolean;
    /** @override */
    addConstraintVariable(variable: ConstraintVariable): void;
    /** @override */
    removeConstraintVariable(variable: ConstraintVariable): void;
    /** @internal @override */
    setConstraintVariable(constraintVariable: ConstraintVariable, state: number): void;
    /** @override */
    getLook<T>(look: Look<T, unknown>, mood?: MoodVector<Feel> | null): T | undefined;
    /** @override */
    getLookOr<T, E>(look: Look<T, unknown>, elseValue: E): T | E;
    /** @override */
    getLookOr<T, E>(look: Look<T, unknown>, mood: MoodVector<Feel> | null, elseValue: E): T | E;
    applyTheme(theme: ThemeMatrix, mood: MoodVector, timing?: AnyTiming | boolean | null): void;
    /** @protected @override */
    onMount(): void;
    /** @protected @override */
    onUnmount(): void;
    /** @internal */
    createStylesheet(): CSSStyleSheet;
    /** @internal */
    initStylesheet?(stylesheet: CSSStyleSheet): void;
    /** @internal */
    initCss?(): string | undefined;
}

/** @public */
declare const StyleSheet_2: StyleSheetFactory<StyleSheet_2<any>>;
export { StyleSheet_2 as StyleSheet }

/** @public */
export declare interface StyleSheetClass<F extends StyleSheet_2<any> = StyleSheet_2<any>> extends FastenerClass<F> {
}

/** @public */
export declare type StyleSheetDescriptor<O = unknown, I = {}> = ThisType<StyleSheet_2<O> & I> & StyleSheetInit & Partial<I>;

/** @public */
export declare interface StyleSheetFactory<F extends StyleSheet_2<any> = StyleSheet_2<any>> extends StyleSheetClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): StyleSheetFactory<F> & I;
    define<O>(className: string, descriptor: StyleSheetDescriptor<O>): StyleSheetFactory<StyleSheet_2<any>>;
    define<O, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & StyleSheetDescriptor<O, I>): StyleSheetFactory<StyleSheet_2<any> & I>;
    <O>(descriptor: StyleSheetDescriptor<O>): PropertyDecorator;
    <O, I = {}>(descriptor: {
        implements: unknown;
    } & StyleSheetDescriptor<O, I>): PropertyDecorator;
}

/** @public */
export declare interface StyleSheetInit extends FastenerInit {
    extends?: {
        prototype: StyleSheet_2<any>;
    } | string | boolean | null;
    css?: string | (() => string | undefined);
    createStylesheet?(): CSSStyleSheet;
    initStylesheet?(stylesheet: CSSStyleSheet): void;
}

/** @public */
export declare type StyleValue = DateTime | Angle | Length | Font | Color | LinearGradient | BoxShadow | Transform | Interpolator<any> | number | boolean;

/** @public */
export declare const StyleValue: {
    fromAny(value: AnyStyleValue): StyleValue;
    parse(input: Input | string): StyleValue;
    form(): Form<StyleValue, AnyStyleValue>;
};

/** @internal */
export declare class StyleValueForm extends Form<StyleValue, AnyStyleValue> {
    constructor(unit: StyleValue | undefined);
    readonly unit: StyleValue | undefined;
    withUnit(unit: StyleValue | undefined): Form<StyleValue, AnyStyleValue>;
    mold(value: AnyStyleValue): Item;
    cast(item: Item): StyleValue | undefined;
}

/** @internal */
export declare class StyleValueParser extends Parser<StyleValue> {
    private readonly identOutput;
    private readonly valueParser;
    private readonly unitsOutput;
    private readonly step;
    constructor(identOutput?: Output<string>, valueParser?: Parser<number>, unitsOutput?: Output<string>, step?: number);
    feed(input: Input): Parser<StyleValue>;
    static parse(input: Input, identOutput?: Output<string>, valueParser?: Parser<number>, unitsOutput?: Output<string>, step?: number): Parser<StyleValue>;
}

/** @public */
export declare class StyleView extends HtmlView implements StyleContext {
    constructor(node: HTMLStyleElement);
    readonly observerType?: Class<StyleViewObserver>;
    readonly node: HTMLStyleElement;
    readonly sheet: StyleSheet_2<this>;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    init(init: StyleViewInit): void;
    /** @internal */
    static readonly tag: string;
}

/** @public */
export declare interface StyleViewInit extends HtmlViewInit {
}

/** @public */
export declare interface StyleViewObserver<V extends StyleView = StyleView> extends HtmlViewObserver<V> {
}

/** @public */
export declare class SvgContext implements PaintingContext {
    constructor(view: SvgView);
    readonly view: SvgView;
    readonly precision: number;
    setPrecision(precision: number): void;
    /** @internal */
    readonly pathContext: PathContext | null;
    protected getPathContext(): PathContext;
    protected getOrCreatePathContext(): PathContext;
    protected createPathContext(): PathContext;
    /** @internal */
    readonly pathView: SvgView | null;
    /** @internal */
    setPathView(pathView: SvgView | null): void;
    /** @internal */
    nextPathView(): SvgView | null;
    /** @internal */
    finalizePath(): void;
    /** @internal */
    readonly pathFlags: number;
    /** @internal */
    setPathFlags(pathFlags: number): void;
    fillStyle: string | CanvasGradient | CanvasPattern;
    strokeStyle: string | CanvasGradient | CanvasPattern;
    lineWidth: number;
    lineCap: CanvasLineCap;
    lineJoin: CanvasLineJoin;
    miterLimit: number;
    lineDashOffset: number;
    /** @internal */
    lineDash: number[];
    getLineDash(): number[];
    setLineDash(segments: number[]): void;
    beginPath(): void;
    moveTo(x: number, y: number): void;
    lineTo(x: number, y: number): void;
    quadraticCurveTo(x1: number, y1: number, x: number, y: number): void;
    bezierCurveTo(x1: number, y1: number, x2: number, y2: number, x: number, y: number): void;
    arcTo(x1: number, y1: number, x2: number, y2: number, r: number): void;
    arc(cx: number, cy: number, r: number, a0: number, a1: number, ccw?: boolean): void;
    ellipse(cx: number, cy: number, rx: number, ry: number, phi: number, a0: number, a1: number, ccw?: boolean): void;
    rect(x: number, y: number, w: number, h: number): void;
    closePath(): void;
    fill(fillRule?: PaintingFillRule): void;
    stroke(): void;
    beginSvg(): void;
    finalizeSvg(): void;
    /** @internal */
    static readonly FillFlag: number;
    /** @internal */
    static readonly FillRuleFlag: number;
    /** @internal */
    static readonly StrokeFlag: number;
    /** @internal */
    static readonly PathFlag: number;
}

/** @public */
export declare class SvgIconView extends SvgView implements IconView {
    constructor(node: SVGElement);
    readonly xAlign: Animator<this, number>;
    readonly yAlign: Animator<this, number>;
    readonly iconWidth: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly iconHeight: ThemeAnimator<this, Length | null, AnyLength | null>;
    readonly iconColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly graphics: ThemeAnimator<this, Graphics | null>;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    protected onResize(viewContext: ViewContextType<this>): void;
    protected needsDisplay(displayFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected renderIcon(): void;
    get iconBounds(): R2Box;
    init(init: SvgIconViewInit): void;
    static readonly MountFlags: ViewFlags;
}

/** @public */
export declare interface SvgIconViewInit extends SvgViewInit, IconViewInit {
}

/** @public */
export declare type SvgPointerEvents = "all" | "auto" | "bounding-box" | "fill" | "none" | "painted" | "stroke" | "visible" | "visibleFill" | "visiblePainted" | "visibleStroke";

/** @public */
export declare class SvgRenderer extends PaintingRenderer {
    constructor(context: SvgContext);
    readonly context: SvgContext;
    get transform(): Transform;
    get pixelRatio(): number;
}

/** @public */
export declare class SvgView extends ElementView {
    constructor(node: SVGElement);
    readonly observerType?: Class<SvgViewObserver>;
    readonly node: SVGElement;
    setChild<V extends View>(key: string, newChild: V): View | null;
    setChild<F extends ViewCreator<F>>(key: string, factory: F): View | null;
    setChild(key: string, newChild: AnyView | Node | keyof SvgViewTagMap | null): View | null;
    appendChild<V extends View>(child: V, key?: string): V;
    appendChild<F extends ViewCreator<F>>(factory: F, key?: string): InstanceType<F>;
    appendChild<K extends keyof SvgViewTagMap>(tag: K, key?: string): SvgViewTagMap[K];
    appendChild(child: AnyView | Node | keyof SvgViewTagMap, key?: string): View;
    prependChild<V extends View>(child: V, key?: string): V;
    prependChild<F extends ViewCreator<F>>(factory: F, key?: string): InstanceType<F>;
    prependChild<K extends keyof SvgViewTagMap>(tag: K, key?: string): SvgViewTagMap[K];
    prependChild(child: AnyView | Node | keyof SvgViewTagMap, key?: string): View;
    insertChild<V extends View>(child: V, target: View | Node | null, key?: string): V;
    insertChild<F extends ViewCreator<F>>(factory: F, target: View | Node | null, key?: string): InstanceType<F>;
    insertChild<K extends keyof SvgViewTagMap>(tag: K, target: View | Node | null, key?: string): SvgViewTagMap[K];
    insertChild(child: AnyView | Node | keyof SvgViewTagMap, target: View | Node | null, key?: string): View;
    replaceChild<V extends View>(newChild: View, oldChild: V): V;
    replaceChild<V extends View>(newChild: AnyView | Node | keyof SvgViewTagMap, oldChild: V): V;
    readonly alignmentBaseline: AttributeAnimator<this, AlignmentBaseline>;
    readonly clipPath: AttributeAnimator<this, string | undefined>;
    readonly cursor: AttributeAnimator<this, CssCursor | undefined>;
    readonly cx: AttributeAnimator<this, number | undefined>;
    readonly cy: AttributeAnimator<this, number | undefined>;
    readonly d: AttributeAnimator<this, string | undefined>;
    readonly dx: AttributeAnimator<this, Length | null, AnyLength | null>;
    readonly dy: AttributeAnimator<this, Length | null, AnyLength | null>;
    readonly edgeMode: AttributeAnimator<this, string | undefined>;
    readonly fill: AttributeAnimator<this, Color | null, AnyColor | null>;
    readonly fillRule: AttributeAnimator<this, FillRule | undefined>;
    readonly floodColor: AttributeAnimator<this, Color | null, AnyColor | null>;
    readonly floodOpacity: AttributeAnimator<this, number | undefined>;
    readonly height: AttributeAnimator<this, Length | null, AnyLength | null>;
    readonly in: AttributeAnimator<this, string | undefined>;
    readonly in2: AttributeAnimator<this, string | undefined>;
    readonly lengthAdjust: AttributeAnimator<this, "spacing" | "spacingAndGlyphs" | undefined>;
    readonly mode: AttributeAnimator<this, string | undefined>;
    readonly opacity: AttributeAnimator<this, number | undefined>;
    readonly pointerEvents: AttributeAnimator<this, SvgPointerEvents | undefined>;
    readonly points: AttributeAnimator<this, string | undefined>;
    readonly preserveAspectRatio: AttributeAnimator<this, boolean | undefined>;
    readonly r: AttributeAnimator<this, number | undefined>;
    readonly result: AttributeAnimator<this, string | undefined>;
    readonly stdDeviation: AttributeAnimator<this, number | undefined>;
    readonly stroke: AttributeAnimator<this, Color | null, AnyColor | null>;
    readonly strokeDasharray: AttributeAnimator<this, string | undefined>;
    readonly strokeDashoffset: AttributeAnimator<this, number | undefined>;
    readonly strokeLinecap: AttributeAnimator<this, StrokeLinecap | undefined>;
    readonly strokeLinejoin: AttributeAnimator<this, StrokeLinejoin | undefined>;
    readonly strokeMiterlimit: AttributeAnimator<this, number | undefined>;
    readonly strokeWidth: AttributeAnimator<this, number | undefined>;
    readonly textAnchor: AttributeAnimator<this, TextAnchor | undefined>;
    readonly textLength: AttributeAnimator<this, Length | null, AnyLength | null>;
    readonly transform: AttributeAnimator<this, Transform | null, AnyTransform | null>;
    readonly type: AttributeAnimator<this, string | undefined>;
    readonly values: AttributeAnimator<this, string | undefined>;
    readonly viewBox: AttributeAnimator<this, string | undefined>;
    readonly width: AttributeAnimator<this, Length | null, AnyLength | null>;
    readonly x: AttributeAnimator<this, number | undefined>;
    readonly x1: AttributeAnimator<this, number | undefined>;
    readonly x2: AttributeAnimator<this, number | undefined>;
    readonly y: AttributeAnimator<this, number | undefined>;
    readonly y1: AttributeAnimator<this, number | undefined>;
    readonly y2: AttributeAnimator<this, number | undefined>;
    readonly cssTransform: StyleAnimator<this, Transform | null, AnyTransform | null>;
    readonly filter: StyleAnimator<this, string | undefined>;
    font(): Font | null;
    font(value: AnyFont | null, timing?: AnyTiming | boolean): this;
    readonly fontFamily: StyleAnimator<this, FontFamily | FontFamily[] | undefined, FontFamily | ReadonlyArray<FontFamily> | undefined>;
    readonly fontSize: StyleAnimator<this, Length | null, AnyLength | null>;
    readonly fontStretch: StyleAnimator<this, FontStretch | undefined>;
    readonly fontStyle: StyleAnimator<this, FontStyle | undefined>;
    readonly fontVariant: StyleAnimator<this, FontVariant | undefined>;
    readonly fontWeight: StyleAnimator<this, FontWeight | undefined>;
    readonly lineHeight: StyleAnimator<this, Length | null, AnyLength | null>;
    readonly touchAction: StyleAnimator<this, TouchAction | undefined>;
    get parentTransform(): Transform;
    on<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGElement, event: SVGElementEventMap[K]) => unknown, options?: AddEventListenerOptions | boolean): this;
    on(type: string, listener: EventListenerOrEventListenerObject, options?: AddEventListenerOptions | boolean): this;
    off<K extends keyof SVGElementEventMap>(type: K, listener: (this: SVGElement, event: SVGElementEventMap[K]) => unknown, options?: EventListenerOptions | boolean): this;
    off(type: string, listener: EventListenerOrEventListenerObject, options?: EventListenerOptions | boolean): this;
    /** @internal */
    protected initAttributes(init: SvgViewAttributesInit): void;
    /** @internal */
    protected initStyle(init: SvgViewStyleInit): void;
    init(init: SvgViewInit): void;
    static readonly tag: string;
    static readonly namespace: string;
    static create<S extends abstract new (...args: any) => InstanceType<S>>(this: S): InstanceType<S>;
    static create(): SvgView;
    static fromTag<S extends abstract new (...args: any) => InstanceType<S>>(this: S, tag: string): InstanceType<S>;
    static fromTag(tag: string): SvgView;
    static fromNode<S extends new (node: SVGElement) => InstanceType<S>>(this: S, node: ViewNodeType<InstanceType<S>>): InstanceType<S>;
    static fromNode(node: SVGElement): SvgView;
    static fromAny<S extends abstract new (...args: any) => InstanceType<S>>(this: S, value: AnySvgView<InstanceType<S>>): InstanceType<S>;
    static fromAny(value: AnySvgView | string): SvgView;
    static forTag<S extends abstract new (...args: any) => InstanceType<S>>(this: S, tag: string): SvgViewFactory<InstanceType<S>>;
    static forTag(tag: string): SvgViewFactory;
}

/** @public */
export declare interface SvgViewAttributesInit {
    alignmentBaseline?: MemberAnimatorInit<SvgView, "alignmentBaseline">;
    clipPath?: MemberAnimatorInit<SvgView, "clipPath">;
    cursor?: MemberAnimatorInit<SvgView, "cursor">;
    cx?: MemberAnimatorInit<SvgView, "cx">;
    cy?: MemberAnimatorInit<SvgView, "cy">;
    d?: MemberAnimatorInit<SvgView, "d">;
    dx?: MemberAnimatorInit<SvgView, "dx">;
    dy?: MemberAnimatorInit<SvgView, "dy">;
    edgeMode?: MemberAnimatorInit<SvgView, "edgeMode">;
    fill?: MemberAnimatorInit<SvgView, "fill">;
    fillRule?: MemberAnimatorInit<SvgView, "fillRule">;
    floodColor?: MemberAnimatorInit<SvgView, "floodColor">;
    floodOpacity?: MemberAnimatorInit<SvgView, "floodOpacity">;
    height?: MemberAnimatorInit<SvgView, "height">;
    in?: MemberAnimatorInit<SvgView, "in">;
    in2?: MemberAnimatorInit<SvgView, "in2">;
    lengthAdjust?: MemberAnimatorInit<SvgView, "lengthAdjust">;
    mode?: MemberAnimatorInit<SvgView, "mode">;
    opacity?: MemberAnimatorInit<SvgView, "opacity">;
    pointerEvents?: MemberAnimatorInit<SvgView, "pointerEvents">;
    points?: MemberAnimatorInit<SvgView, "points">;
    preserveAspectRatio?: MemberAnimatorInit<SvgView, "preserveAspectRatio">;
    r?: MemberAnimatorInit<SvgView, "r">;
    result?: MemberAnimatorInit<SvgView, "result">;
    stdDeviation?: MemberAnimatorInit<SvgView, "stdDeviation">;
    stroke?: MemberAnimatorInit<SvgView, "stroke">;
    strokeDasharray?: MemberAnimatorInit<SvgView, "strokeDasharray">;
    strokeDashoffset?: MemberAnimatorInit<SvgView, "strokeDashoffset">;
    strokeLinecap?: MemberAnimatorInit<SvgView, "strokeLinecap">;
    strokeLinejoin?: MemberAnimatorInit<SvgView, "strokeLinejoin">;
    strokeMiterlimit?: MemberAnimatorInit<SvgView, "strokeMiterlimit">;
    strokeWidth?: MemberAnimatorInit<SvgView, "strokeWidth">;
    textAnchor?: MemberAnimatorInit<SvgView, "textAnchor">;
    textLength?: MemberAnimatorInit<SvgView, "textLength">;
    transform?: MemberAnimatorInit<SvgView, "transform">;
    type?: MemberAnimatorInit<SvgView, "type">;
    values?: MemberAnimatorInit<SvgView, "values">;
    viewBox?: MemberAnimatorInit<SvgView, "viewBox">;
    width?: MemberAnimatorInit<SvgView, "width">;
    x?: MemberAnimatorInit<SvgView, "x">;
    x1?: MemberAnimatorInit<SvgView, "x1">;
    x2?: MemberAnimatorInit<SvgView, "x2">;
    y?: MemberAnimatorInit<SvgView, "y">;
    y1?: MemberAnimatorInit<SvgView, "y1">;
    y2?: MemberAnimatorInit<SvgView, "y2">;
}

/** @public */
export declare interface SvgViewClass<V extends SvgView = SvgView, U = AnySvgView<V>> extends ElementViewClass<V, U>, SvgViewFactory<V, U> {
    readonly tag: string;
    readonly namespace: string;
}

/** @public */
export declare interface SvgViewConstructor<V extends SvgView = SvgView, U = AnySvgView<V>> extends ElementViewConstructor<V, U>, SvgViewClass<V, U> {
    readonly tag: string;
    readonly namespace: string;
}

/** @public */
export declare interface SvgViewFactory<V extends SvgView = SvgView, U = AnySvgView<V>> extends ElementViewFactory<V, U> {
}

/** @public */
export declare interface SvgViewInit extends ElementViewInit {
    attributes?: SvgViewAttributesInit;
    style?: SvgViewStyleInit;
}

/** @public */
export declare interface SvgViewObserver<V extends SvgView = SvgView> extends ElementViewObserver<V> {
}

/** @public */
export declare interface SvgViewStyleInit {
    cssTransform?: MemberAnimatorInit<SvgView, "cssTransform">;
    filter?: MemberAnimatorInit<SvgView, "filter">;
    fontFamily?: MemberAnimatorInit<SvgView, "fontFamily">;
    fontSize?: MemberAnimatorInit<SvgView, "fontSize">;
    fontStretch?: MemberAnimatorInit<SvgView, "fontStretch">;
    fontStyle?: MemberAnimatorInit<SvgView, "fontStyle">;
    fontVariant?: MemberAnimatorInit<SvgView, "fontVariant">;
    fontWeight?: MemberAnimatorInit<SvgView, "fontWeight">;
    lineHeight?: MemberAnimatorInit<SvgView, "lineHeight">;
    touchAction?: MemberAnimatorInit<SvgView, "touchAction">;
}

/** @internal */
export declare class SvgViewTagFactory<V extends SvgView> implements SvgViewFactory<V> {
    constructor(factory: SvgViewFactory<V>, tag: string);
    /** @internal */
    readonly factory: SvgViewFactory<V>;
    readonly tag: string;
    get namespace(): string;
    create(): V;
    fromTag(tag: string): V;
    fromNode(node: ViewNodeType<V>): V;
    fromInit(init: InitType<V>): V;
    fromAny(value: AnySvgView<V>): V;
}

/** @public */
export declare interface SvgViewTagMap {
    a: SvgView;
    animate: SvgView;
    animateMotion: SvgView;
    animateTransform: SvgView;
    audio: SvgView;
    canvas: SvgView;
    circle: SvgView;
    clipPath: SvgView;
    defs: SvgView;
    desc: SvgView;
    discard: SvgView;
    ellipse: SvgView;
    feBlend: SvgView;
    feColorMatrix: SvgView;
    feComponentTransfer: SvgView;
    feComposite: SvgView;
    feConvolveMatrix: SvgView;
    feDiffuseLighting: SvgView;
    feDisplacementMap: SvgView;
    feDistantLight: SvgView;
    feDropShadow: SvgView;
    feFlood: SvgView;
    feFuncA: SvgView;
    feFuncB: SvgView;
    feFuncG: SvgView;
    feFuncR: SvgView;
    feGaussianBlur: SvgView;
    feImage: SvgView;
    feMerge: SvgView;
    feMergeNode: SvgView;
    feMorphology: SvgView;
    feOffset: SvgView;
    fePointLight: SvgView;
    feSpecularLighting: SvgView;
    feSpotLight: SvgView;
    feTile: SvgView;
    feTurbulence: SvgView;
    filter: SvgView;
    foreignObject: SvgView;
    g: SvgView;
    iframe: SvgView;
    image: SvgView;
    line: SvgView;
    linearGradient: SvgView;
    marker: SvgView;
    mask: SvgView;
    metadata: SvgView;
    mpath: SvgView;
    path: SvgView;
    pattern: SvgView;
    polygon: SvgView;
    polyline: SvgView;
    radialGradient: SvgView;
    rect: SvgView;
    script: SvgView;
    set: SvgView;
    stop: SvgView;
    style: SvgView;
    svg: SvgView;
    switch: SvgView;
    symbol: SvgView;
    text: SvgView;
    textPath: SvgView;
    title: SvgView;
    tspan: SvgView;
    unknown: SvgView;
    use: SvgView;
    video: SvgView;
    view: SvgView;
}

/** @public */
export declare class TableController extends Controller {
    readonly observerType?: Class<TableControllerObserver>;
    protected layoutTable(tableLayout: TableLayout, tableView: TableView): void;
    readonly table: TraitViewRef<this, TableTrait, TableView>;
    static readonly table: MemberFastenerClass<TableController, "table">;
    readonly header: TraitViewControllerRef<this, HeaderTrait, HeaderView, HeaderController>;
    static readonly header: MemberFastenerClass<TableController, "header">;
    readonly cols: TraitViewControllerSet<this, ColTrait, ColView, ColController>;
    static readonly cols: MemberFastenerClass<TableController, "cols">;
    readonly rows: TraitViewControllerSet<this, RowTrait, RowView, RowController>;
    static readonly rows: MemberFastenerClass<TableController, "rows">;
}

/** @public */
export declare interface TableControllerColExt {
    attachColTrait(colTrait: ColTrait, colController: ColController): void;
    detachColTrait(colTrait: ColTrait, colController: ColController): void;
    attachColView(colView: ColView, colController: ColController): void;
    detachColView(colView: ColView, colController: ColController): void;
    attachColLabelView(colLabelView: HtmlView, colController: ColController): void;
    detachColLabelView(colLabelView: HtmlView, colController: ColController): void;
}

/** @public */
export declare interface TableControllerHeaderExt {
    attachHeaderTrait(headerTrait: HeaderTrait, headerController: HeaderController): void;
    detachHeaderTrait(headerTrait: HeaderTrait, headerController: HeaderController): void;
    attachHeaderView(headerView: HeaderView, headerController: HeaderController): void;
    detachHeaderView(headerView: HeaderView, headerController: HeaderController): void;
}

/** @public */
export declare interface TableControllerObserver<C extends TableController = TableController> extends ControllerObserver<C> {
    controllerWillAttachTableTrait?(tableTrait: TableTrait, controller: C): void;
    controllerDidDetachTableTrait?(tableTrait: TableTrait, controller: C): void;
    controllerWillSetTableLayout?(newTableLayout: TableLayout | null, oldTableLayout: TableLayout | null, controller: C): void;
    controllerDidSetTableLayout?(newTableLayout: TableLayout | null, oldTableLayout: TableLayout | null, controller: C): void;
    controllerWillAttachTableView?(tableView: TableView, controller: C): void;
    controllerDidDetachTableView?(tableView: TableView, controller: C): void;
    controllerWillAttachHeader?(headerController: HeaderController, controller: C): void;
    controllerDidDetachHeader?(headerController: HeaderController, controller: C): void;
    controllerWillAttachHeaderTrait?(headerTrait: HeaderTrait, controller: C): void;
    controllerDidDetachHeaderTrait?(headerTrait: HeaderTrait, controller: C): void;
    controllerWillAttachHeaderView?(headerView: HeaderView, controller: C): void;
    controllerDidDetachHeaderView?(headerView: HeaderView, controller: C): void;
    controllerWillAttachCol?(colController: ColController, controller: C): void;
    controllerDidDetachCol?(colController: ColController, controller: C): void;
    controllerWillAttachColTrait?(colTrait: ColTrait, colController: ColController, controller: C): void;
    controllerDidDetachColTrait?(colTrait: ColTrait, colController: ColController, controller: C): void;
    controllerWillSetColLayout?(newColLayout: ColLayout | null, oldColLayout: ColLayout | null, colController: ColController, controller: C): void;
    controllerDidSetColLayout?(newColLayout: ColLayout | null, oldColLayout: ColLayout | null, colController: ColController, controller: C): void;
    controllerWillAttachColView?(colView: ColView, colController: ColController, controller: C): void;
    controllerDidDetachColView?(colView: ColView, colController: ColController, controller: C): void;
    controllerWillAttachColLabelView?(colLabelView: HtmlView, colController: ColController, controller: C): void;
    controllerDidDetachColLabelView?(colLabelView: HtmlView, colController: ColController, controller: C): void;
    controllerWillAttachRow?(rowController: RowController, controller: C): void;
    controllerDidDetachRow?(rowController: RowController, controller: C): void;
    controllerWillAttachRowTrait?(rowTrait: RowTrait, rowController: RowController, controller: C): void;
    controllerDidDetachRowTrait?(rowTrait: RowTrait, rowController: RowController, controller: C): void;
    controllerWillAttachRowView?(rowView: RowView, rowController: RowController, controller: C): void;
    controllerDidDetachRowView?(rowView: RowView, rowController: RowController, controller: C): void;
    controllerWillAttachLeafTrait?(leafTrait: LeafTrait, rowController: RowController, controller: C): void;
    controllerDidDetachLeafTrait?(leafTrait: LeafTrait, rowController: RowController, controller: C): void;
    controllerWillAttachLeafView?(leafView: LeafView, rowController: RowController, controller: C): void;
    controllerDidDetachLeafView?(leafView: LeafView, rowController: RowController, controller: C): void;
    controllerWillHighlightLeafView?(leafView: LeafView, rowController: RowController, controller: C): void;
    controllerDidHighlightLeafView?(leafView: LeafView, rowController: RowController, controller: C): void;
    controllerWillUnhighlightLeafView?(leafView: LeafView, rowController: RowController, controller: C): void;
    controllerDidUnhighlightLeafView?(leafView: LeafView, rowController: RowController, controller: C): void;
    controllerDidEnterLeafView?(leafView: LeafView, rowController: RowController, controller: C): void;
    controllerDidLeaveLeafView?(leafView: LeafView, rowController: RowController, controller: C): void;
    controllerDidPressLeafView?(input: PositionGestureInput, event: Event | null, leafView: LeafView, rowController: RowController, controller: C): void;
    controllerDidLongPressLeafView?(input: PositionGestureInput, leafView: LeafView, rowController: RowController, controller: C): void;
    controllerWillAttachCell?(cellController: CellController, rowController: RowController, controller: C): void;
    controllerDidDetachCell?(cellController: CellController, rowController: RowController, controller: C): void;
    controllerWillAttachCellTrait?(cellTrait: CellTrait, cellController: CellController, rowController: RowController, controller: C): void;
    controllerDidDetachCellTrait?(cellTrait: CellTrait, cellController: CellController, rowController: RowController, controller: C): void;
    controllerWillAttachCellView?(cellView: CellView, cellController: CellController, rowController: RowController, controller: C): void;
    controllerDidDetachCellView?(cellView: CellView, cellController: CellController, rowController: RowController, controller: C): void;
    controllerWillAttachCellContentView?(cellContentView: HtmlView, cellController: CellController, rowController: RowController, controller: C): void;
    controllerDidDetachCellContentView?(cellContentView: HtmlView, cellController: CellController, rowController: RowController, controller: C): void;
    controllerWillSetCellIcon?(newCellIcon: Graphics | null, oldCellIcon: Graphics | null, cellController: CellController, rowController: RowController, controller: C): void;
    controllerDidSetCellIcon?(newCellIcon: Graphics | null, oldCellIcon: Graphics | null, cellController: CellController, rowController: RowController, controller: C): void;
    controllerWillAttachTree?(treeController: TableController, rowController: RowController, controller: C): void;
    controllerDidDetachTree?(treeController: TableController, rowController: RowController, controller: C): void;
    controllerWillAttachTreeTrait?(treeTrait: TableTrait, treeController: TableController, rowController: RowController, controller: C): void;
    controllerDidDetachTreeTrait?(treeTrait: TableTrait, treeController: TableController, rowController: RowController, controller: C): void;
    controllerWillAttachTreeView?(treeView: TableView, treeController: TableController, rowController: RowController, controller: C): void;
    controllerDidDetachTreeView?(treeView: TableView, treeController: TableController, rowController: RowController, controller: C): void;
    controllerWillExpandRowView?(rowView: RowView, rowController: RowController, controller: C): void;
    controllerDidExpandRowView?(rowView: RowView, rowController: RowController, controller: C): void;
    controllerWillCollapseRowView?(rowView: RowView, rowController: RowController, controller: C): void;
    controllerDidCollapseRowView?(rowView: RowView, rowController: RowController, controller: C): void;
}

/** @public */
export declare interface TableControllerRowExt {
    attachRowTrait(rowTrait: RowTrait, rowController: RowController): void;
    detachRowTrait(rowTrait: RowTrait, rowController: RowController): void;
    attachRowView(rowView: RowView, rowController: RowController): void;
    detachRowView(rowView: RowView, rowController: RowController): void;
    attachLeafTrait(leafTrait: LeafTrait, rowController: RowController): void;
    detachLeafTrait(leafTrait: LeafTrait, rowController: RowController): void;
    attachLeafView(leafView: LeafView, rowController: RowController): void;
    detachLeafView(leafView: LeafView, rowController: RowController): void;
    attachCell(cellController: CellController, rowController: RowController): void;
    detachCell(cellController: CellController, rowController: RowController): void;
    attachCellTrait(cellTrait: CellTrait, cellController: CellController, rowController: RowController): void;
    detachCellTrait(cellTrait: CellTrait, cellController: CellController, rowController: RowController): void;
    attachCellView(cellView: CellView, cellController: CellController, rowController: RowController): void;
    detachCellView(cellView: CellView, cellController: CellController, rowController: RowController): void;
    attachCellContentView(cellContentView: HtmlView, cellController: CellController, rowController: RowController): void;
    detachCellContentView(cellContentView: HtmlView, cellController: CellController, rowController: RowController): void;
    attachTree(treeController: TableController, rowController: RowController): void;
    detachTree(treeController: TableController, rowController: RowController): void;
    attachTreeTrait(treeTrait: TableTrait, treeController: TableController, rowController: RowController): void;
    detachTreeTrait(treeTrait: TableTrait, treeController: TableController, rowController: RowController): void;
    attachTreeView(treeView: TableView, treeController: TableController, rowController: RowController): void;
    detachTreeView(treeView: TableView, treeController: TableController, rowController: RowController): void;
}

/** @public */
export declare class TableLayout implements Equals, Equivalent, Debug {
    constructor(width: Length | null, left: Length | null, right: Length | null, colSpacing: Length | null, cols: ReadonlyArray<ColLayout>);
    readonly width: Length | null;
    readonly left: Length | null;
    readonly right: Length | null;
    readonly colSpacing: Length | null;
    readonly cols: ReadonlyArray<ColLayout>;
    getCol(key: string): ColLayout | null;
    resized(width: AnyLength, left?: AnyLength | null, right?: AnyLength | null, colSpacing?: AnyLength | null): TableLayout;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static of(...tableCols: AnyColLayout[]): TableLayout;
    static create(cols: ReadonlyArray<ColLayout>): TableLayout;
    static fromAny(value: AnyTableLayout): TableLayout;
    static fromInit(init: TableLayoutInit): TableLayout;
}

/** @public */
export declare interface TableLayoutInit {
    width?: AnyLength | null;
    left?: AnyLength | null;
    right?: AnyLength | null;
    colSpacing?: AnyLength | null;
    cols: AnyColLayout[];
}

/** @public */
export declare class TableTrait extends Trait {
    readonly observerType?: Class<TableTraitObserver>;
    protected createLayout(): TableLayout | null;
    protected updateLayout(): void;
    readonly layout: Property<this, TableLayout | null, AnyTableLayout | null>;
    readonly colSpacing: Property<this, Length | null, AnyLength | null>;
    readonly header: TraitRef<this, HeaderTrait>;
    static readonly header: MemberFastenerClass<TableTrait, "header">;
    readonly cols: TraitSet<this, ColTrait>;
    static readonly cols: MemberFastenerClass<TableTrait, "cols">;
    /** @internal */
    protected startConsumingCols(): void;
    /** @internal */
    protected stopConsumingCols(): void;
    readonly rows: TraitSet<this, RowTrait>;
    static readonly rows: MemberFastenerClass<TableTrait, "rows">;
    /** @internal */
    protected startConsumingRows(): void;
    /** @internal */
    protected stopConsumingRows(): void;
    protected onStartConsuming(): void;
    protected onStopConsuming(): void;
}

/** @public */
export declare interface TableTraitObserver<T extends TableTrait = TableTrait> extends TraitObserver<T> {
    traitWillSetTableLayout?(newTableLayout: TableLayout | null, oldTableLayout: TableLayout | null, trait: T): void;
    traitDidSetTableLayout?(newTableLayout: TableLayout | null, oldTableLayout: TableLayout | null, trait: T): void;
    traitWillAttachHeader?(headerTrait: HeaderTrait, trait: T): void;
    traitDidDetachHeader?(headerTrait: HeaderTrait, trait: T): void;
    traitWillAttachCol?(colTrait: ColTrait, targetTrait: Trait | null, trait: T): void;
    traitDidDetachCol?(colTrait: ColTrait, trait: T): void;
    traitWillAttachRow?(rowTrait: RowTrait, targetTrait: Trait | null, trait: T): void;
    traitDidDetachRow?(rowTrait: RowTrait, trait: T): void;
}

/** @public */
export declare class TableView extends HtmlView {
    constructor(node: HTMLElement);
    protected initTable(): void;
    readonly observerType?: Class<TableViewObserver>;
    readonly contextType?: Class<TableViewContext>;
    readonly layout: Property<this, TableLayout | null, AnyTableLayout | null>;
    readonly edgeInsets: Property<this, ViewportInsets | null>;
    readonly depth: Property<this, number>;
    readonly rowSpacing: ThemeConstraintAnimator<this, Length, AnyLength>;
    readonly rowHeight: ThemeConstraintAnimator<this, Length, AnyLength>;
    readonly hovers: Property<this, boolean>;
    readonly glows: Property<this, boolean>;
    readonly disclosure: ExpansionThemeAnimator<this, Expansion | null, AnyExpansion | null>;
    readonly disclosing: ExpansionThemeAnimator<this, Expansion | null, AnyExpansion | null>;
    readonly stretch: ExpansionThemeAnimator<this, Expansion | null, AnyExpansion | null>;
    readonly header: ViewRef<this, HeaderView>;
    static readonly header: MemberFastenerClass<TableView, "header">;
    readonly rows: ViewSet<this, RowView>;
    static readonly rows: MemberFastenerClass<TableView, "rows">;
    /** @internal */
    readonly visibleViews: ReadonlyArray<View>;
    /** @internal */
    readonly visibleFrame: R2Box;
    protected detectVisibleFrame(viewContext: ViewContext): R2Box;
    extendViewContext(viewContext: ViewContext): ViewContextType<this>;
    needsProcess(processFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    protected onResize(viewContext: ViewContextType<this>): void;
    protected resizeTable(): void;
    protected processVisibleViews(processFlags: ViewFlags, viewContext: ViewContextType<this>, processChild: (this: this, child: View, processFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    protected processChildren(processFlags: ViewFlags, viewContext: ViewContextType<this>, processChild: (this: this, child: View, processFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    protected scrollChildViews(processFlags: ViewFlags, viewContext: ViewContextType<this>, processChild: (this: this, child: View, processFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    protected displayVisibleViews(displayFlags: ViewFlags, viewContext: ViewContextType<this>, displayChild: (this: this, child: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    protected displayChildren(displayFlags: ViewFlags, viewContext: ViewContextType<this>, displayChild: (this: this, child: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    protected layoutChildViews(displayFlags: ViewFlags, viewContext: ViewContextType<this>, displayChild: (this: this, child: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
}

/** @public */
export declare interface TableViewContext extends ViewContext {
    /**
     * The current client viewport rectangle, translated into view coordinates.
     */
    readonly visibleFrame: R2Box;
}

/** @public */
export declare interface TableViewObserver<V extends TableView = TableView> extends HtmlViewObserver<V> {
    viewWillAttachHeader?(headerView: HeaderView, view: V): void;
    viewDidDetachHeader?(headerView: HeaderView, view: V): void;
    viewWillAttachRow?(rowView: RowView, targetView: View | null, view: V): void;
    viewDidDetachRow?(rowView: RowView, view: V): void;
    viewWillAttachLeaf?(leafView: LeafView, rowView: RowView): void;
    viewDidDetachLeaf?(leafView: LeafView, rowView: RowView): void;
    viewWillHighlightLeaf?(leafView: LeafView, rowView: RowView): void;
    viewDidHighlightLeaf?(leafView: LeafView, rowView: RowView): void;
    viewWillUnhighlightLeaf?(leafView: LeafView, rowView: RowView): void;
    viewDidUnhighlightLeaf?(leafView: LeafView, rowView: RowView): void;
    viewDidEnterLeaf?(leafView: LeafView, rowView: RowView): void;
    viewDidLeaveLeaf?(leafView: LeafView, rowView: RowView): void;
    viewDidPressLeaf?(input: PositionGestureInput, event: Event | null, leafView: LeafView, rowView: RowView): void;
    viewDidLongPressLeaf?(input: PositionGestureInput, leafView: LeafView, rowView: RowView): void;
    viewWillAttachTree?(treeView: TableView, rowView: RowView): void;
    viewDidDetachTree?(treeView: TableView, rowView: RowView): void;
    viewWillExpandRow?(rowView: RowView): void;
    viewDidExpandRow?(rowView: RowView): void;
    viewWillCollapseRow?(rowView: RowView): void;
    viewDidCollapseRow?(rowView: RowView): void;
}

/** @public */
export declare type TextAlign = "center" | "end" | "justify" | "justify-all" | "left" | "match-parent" | "right" | "start";

/** @public */
export declare type TextAnchor = "end" | "inherit" | "middle" | "start";

/** @public */
export declare type TextCellContent = TextCellContentFunction | string;

/** @public */
export declare type TextCellContentFunction = (cellTrait: TextCellTrait) => HtmlView | string | null;

/** @public */
export declare class TextCellController extends CellController {
    readonly observerType?: Class<TextCellControllerObserver>;
    readonly cell: TraitViewRef<this, TextCellTrait, TextCellView>;
    static readonly cell: MemberFastenerClass<TextCellController, "cell">;
    protected createContentView(content: TextCellContent, cellTrait: TextCellTrait): HtmlView | string | null;
    protected setContentView(content: TextCellContent | null, cellTrait: TextCellTrait): void;
    readonly content: ViewRef<this, HtmlView>;
    static readonly content: MemberFastenerClass<TextCellController, "content">;
}

/** @public */
export declare interface TextCellControllerObserver<C extends TextCellController = TextCellController> extends CellControllerObserver<C> {
    controllerWillAttachCellTrait?(cellTrait: TextCellTrait, controller: C): void;
    controllerDidDetachCellTrait?(cellTrait: TextCellTrait, controller: C): void;
    controllerWillAttachCellView?(cellView: TextCellView, controller: C): void;
    controllerDidDetachCellView?(cellView: TextCellView, controller: C): void;
    controllerWillAttachCellContentView?(cellContentView: HtmlView, controller: C): void;
    controllerDidDetachCellContentView?(cellContentView: HtmlView, controller: C): void;
}

/** @public */
export declare class TextCellTrait extends CellTrait {
    readonly observerType?: Class<TextCellTraitObserver>;
    readonly content: Property<this, TextCellContent | null>;
}

/** @public */
export declare interface TextCellTraitObserver<T extends TextCellTrait = TextCellTrait> extends CellTraitObserver<T> {
    traitWillSetContent?(newContent: TextCellContent | null, oldContent: TextCellContent | null, trait: T): void;
    traitDidSetContent?(newContent: TextCellContent | null, oldContent: TextCellContent | null, trait: T): void;
}

/** @public */
export declare class TextCellView extends CellView {
    protected initCell(): void;
    readonly observerType?: Class<TextCellViewObserver>;
    readonly content: ViewRef<this, HtmlView & Initable<HtmlViewInit | string>> & {
        create(value?: string): HtmlView;
    };
    static readonly content: MemberFastenerClass<TextCellView, "content">;
}

/** @public */
export declare interface TextCellViewObserver<V extends TextCellView = TextCellView> extends CellViewObserver<V> {
    viewWillAttachContent?(contentView: HtmlView, view: V): void;
    viewDidDetachContent?(contentView: HtmlView, view: V): void;
}

/** @public */
export declare type TextDecorationStyle = "dashed" | "dotted" | "double" | "solid" | "wavy";

/** @public */
export declare class TextRun implements Graphics, Equals, Debug {
    constructor(text: string, font: Font | null, textAlign: CanvasTextAlign | null, textBaseline: CanvasTextBaseline | null, textOrigin: R2Point | null, textColor: Color | null);
    readonly text: string;
    withText(text: string): TextRun;
    readonly font: Font | null;
    withFont(font: AnyFont | null): TextRun;
    readonly textAlign: CanvasTextAlign | null;
    withTextAlign(textAlign: CanvasTextAlign | null): TextRun;
    readonly textBaseline: CanvasTextBaseline | null;
    withTextBaseline(textBaseline: CanvasTextBaseline | null): TextRun;
    readonly textOrigin: R2Point | null;
    withTextOrigin(textOrigin: AnyR2Point | null): TextRun | null;
    readonly textColor: Color | null;
    withTextColor(textColor: AnyColor | null): TextRun;
    render(renderer: GraphicsRenderer, frame: R2Box): void;
    draw(context: CanvasContext, frame: R2Box): void;
    protected renderText(context: CanvasContext, frame: R2Box): void;
    protected copy(text: string, font: Font | null, textAlign: CanvasTextAlign | null, textBaseline: CanvasTextBaseline | null, textOrigin: R2Point | null, textColor: Color | null): TextRun;
    toAny(): TextRunInit;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static create(text: string, font?: AnyFont | null, textAlign?: CanvasTextAlign | null, textBaseline?: CanvasTextBaseline | null, textOrigin?: AnyR2Point | null, textColor?: AnyColor | null): TextRun;
    static fromAny(value: AnyTextRun): TextRun;
}

/** @public */
export declare interface TextRunInit {
    text: string;
    font?: AnyFont;
    textAlign?: CanvasTextAlign;
    textBaseline?: CanvasTextBaseline;
    textOrigin?: AnyR2Point;
    textColor?: AnyColor;
}

/** @public */
export declare class TextRunView extends GraphicsView implements TypesetView {
    readonly text: ThemeAnimator<this, string>;
    readonly font: ThemeAnimator<this, Font | null, AnyFont | null>;
    readonly textAlign: ThemeAnimator<this, CanvasTextAlign | undefined>;
    readonly textBaseline: ThemeAnimator<this, CanvasTextBaseline | undefined>;
    readonly textOrigin: ThemeAnimator<this, R2Point | null, AnyR2Point | null>;
    readonly textColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    get value(): TextRun;
    get state(): TextRun;
    setState(run: TextRun | TextRunViewInit | string, timing?: AnyTiming | boolean): void;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected renderText(context: CanvasContext): void;
    init(init: TextRun | TextRunViewInit | string): void;
}

/** @public */
export declare interface TextRunViewInit extends TypesetViewInit {
    text?: string;
}

/** @public */
export declare type TextTransform = "capitalize" | "full-width" | "lowercase" | "none" | "uppercase";

/** @public */
export declare class TextView extends NodeView {
    constructor(node: Text);
    readonly observerType?: Class<TextViewObserver>;
    readonly node: Text;
    init(init: TextViewInit): void;
    static create<S extends new (node: Text) => InstanceType<S>>(this: S, text?: string): InstanceType<S>;
    static create(text?: string): TextView;
    static fromNode<S extends new (node: Text) => InstanceType<S>>(this: S, node: Text): InstanceType<S>;
    static fromNode(node: Text): TextView;
    static fromAny<S extends abstract new (...args: any) => InstanceType<S>>(this: S, value: AnyTextView<InstanceType<S>>): InstanceType<S>;
    static fromAny(value: AnyTextView | string): TextView;
}

/** @public */
export declare interface TextViewConstructor<V extends TextView = TextView, U = AnyTextView<V>> extends NodeViewConstructor<V, U> {
    new (node: Text): V;
}

/** @public */
export declare interface TextViewInit extends NodeViewInit {
}

/** @public */
export declare interface TextViewObserver<V extends TextView = TextView> extends NodeViewObserver<V> {
}

/** @public */
export declare const Theme: {
    dark: ThemeMatrix;
    light: ThemeMatrix;
};

/** @public */
export declare interface ThemeAnimator<O = unknown, T = unknown, U = T> extends Animator<O, T, U> {
    /** @protected @override */
    onSetAffinity(newAffinity: Affinity, oldAffinity: Affinity): void;
    /** @protected @override */
    onInherit(superFastener: Property<unknown, T>): void;
    get superLook(): Look<T> | null;
    getSuperLook(): Look<T>;
    getSuperLookOr<E>(elseLook: E): Look<T> | E;
    readonly look: Look<T> | null;
    getLook(): Look<T>;
    getLookOr<E>(elseLook: E): Look<T> | E;
    setLook(newLook: Look<T> | null, timingOrAffinity: Affinity | AnyTiming | boolean | null | undefined): void;
    setLook(newLook: Look<T> | null, timing?: AnyTiming | boolean | null, affinity?: Affinity): void;
    /** @protected */
    willSetLook(newLook: Look<T> | null, oldLook: Look<T> | null, timing: Timing | boolean): void;
    /** @protected */
    onSetLook(newLook: Look<T> | null, oldLook: Look<T> | null, timing: Timing | boolean): void;
    /** @protected */
    didSetLook(newLook: Look<T> | null, oldLook: Look<T> | null, timing: Timing | boolean): void;
    /** @internal */
    applyLook(look: Look<T>, timing: Timing | boolean): void;
    applyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    /** @internal @protected @override */
    tweenInherited(t: number): void;
    /** @protected @override */
    onMount(): void;
}

/** @public */
export declare const ThemeAnimator: ThemeAnimatorFactory<ThemeAnimator<any, any, any>>;

/** @public */
export declare interface ThemeAnimatorClass<A extends ThemeAnimator<any, any> = ThemeAnimator<any, any>> extends AnimatorClass<A> {
}

/** @public */
export declare type ThemeAnimatorDescriptor<O = unknown, T = unknown, U = T, I = {}> = ThisType<ThemeAnimator<O, T, U> & I> & ThemeAnimatorInit<T, U> & Partial<I>;

/** @public */
export declare interface ThemeAnimatorFactory<A extends ThemeAnimator<any, any> = ThemeAnimator<any, any>> extends ThemeAnimatorClass<A> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ThemeAnimatorFactory<A> & I;
    specialize(type: unknown): ThemeAnimatorFactory | null;
    define<O, T, U = T>(className: string, descriptor: ThemeAnimatorDescriptor<O, T, U>): ThemeAnimatorFactory<ThemeAnimator<any, T, U>>;
    define<O, T, U = T, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ThemeAnimatorDescriptor<O, T, U, I>): ThemeAnimatorFactory<ThemeAnimator<any, T, U> & I>;
    <O, T extends Angle | null | undefined = Angle | null | undefined, U extends AnyAngle | null | undefined = AnyAngle | null | undefined>(descriptor: {
        type: typeof Angle;
    } & ThemeAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends Length | null | undefined = Length | null | undefined, U extends AnyLength | null | undefined = AnyLength | null | undefined>(descriptor: {
        type: typeof Length;
    } & ThemeAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends Transform | null | undefined = Transform | null | undefined, U extends AnyTransform | null | undefined = AnyTransform | null | undefined>(descriptor: {
        type: typeof Transform;
    } & ThemeAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends Color | null | undefined = Color | null | undefined, U extends AnyColor | null | undefined = AnyColor | null | undefined>(descriptor: {
        type: typeof Color;
    } & ThemeAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends Font | null | undefined = Font | null | undefined, U extends AnyFont | null | undefined = AnyFont | null | undefined>(descriptor: {
        type: typeof Font;
    } & ThemeAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends Focus | null | undefined = Focus | null | undefined, U extends AnyFocus | null | undefined = AnyFocus | null | undefined>(descriptor: {
        type: typeof Focus;
    } & ThemeAnimatorDescriptor<O, T, U> & FocusThemeAnimatorInit): PropertyDecorator;
    <O, T extends Presence | null | undefined = Presence | null | undefined, U extends AnyPresence | null | undefined = AnyPresence | null | undefined>(descriptor: {
        type: typeof Presence;
    } & ThemeAnimatorDescriptor<O, T, U> & PresenceThemeAnimatorInit): PropertyDecorator;
    <O, T extends Expansion | null | undefined = Expansion | null | undefined, U extends AnyExpansion | null | undefined = AnyExpansion | null | undefined>(descriptor: {
        type: typeof Expansion;
    } & ThemeAnimatorDescriptor<O, T, U> & ExpansionThemeAnimatorInit): PropertyDecorator;
    <O, T extends string | undefined = string | undefined, U extends string | undefined = string | undefined>(descriptor: {
        type: typeof String;
    } & ThemeAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends number | undefined = number | undefined, U extends number | string | undefined = number | string | undefined>(descriptor: {
        type: typeof Number;
    } & ThemeAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends boolean | undefined = boolean | undefined, U extends boolean | string | undefined = boolean | string | undefined>(descriptor: {
        type: typeof Boolean;
    } & ThemeAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = T>(descriptor: ({
        type: FromAny<T, U>;
    } | {
        fromAny(value: T | U): T;
    }) & ThemeAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = T>(descriptor: ThemeAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = T, I = {}>(descriptor: {
        implements: unknown;
    } & ThemeAnimatorDescriptor<O, T, U, I>): PropertyDecorator;
}

/** @public */
export declare interface ThemeAnimatorInit<T = unknown, U = T> extends AnimatorInit<T, U> {
    extends?: {
        prototype: ThemeAnimator<any, any>;
    } | string | boolean | null;
    look?: Look<T>;
    willSetLook?(newLook: Look<T> | null, oldLook: Look<T> | null, timing: Timing | boolean): void;
    didSetLook?(newLook: Look<T> | null, oldLook: Look<T> | null, timing: Timing | boolean): void;
}

/** @public */
export declare interface ThemeConstraintAnimator<O = unknown, T = unknown, U = T> extends ThemeAnimator<O, T, U>, ConstraintVariable {
    /** @internal @override */
    readonly id: number;
    /** @internal @override */
    isExternal(): boolean;
    /** @internal @override */
    isDummy(): boolean;
    /** @internal @override */
    isInvalid(): boolean;
    /** @override */
    isConstant(): boolean;
    /** @internal @override */
    evaluateConstraintVariable(): void;
    /** @internal @override */
    updateConstraintSolution(value: number): void;
    /** @override */
    readonly strength: ConstraintStrength;
    setStrength(strength: AnyConstraintStrength): void;
    /** @override */
    get coefficient(): number;
    /** @override */
    get variable(): ConstraintVariable | null;
    /** @override */
    get terms(): ConstraintMap<ConstraintVariable, number>;
    /** @override */
    get constant(): number;
    /** @override */
    plus(that: AnyConstraintExpression): ConstraintExpression;
    /** @override */
    negative(): ConstraintTerm;
    /** @override */
    minus(that: AnyConstraintExpression): ConstraintExpression;
    /** @override */
    times(scalar: number): ConstraintExpression;
    /** @override */
    divide(scalar: number): ConstraintExpression;
    get constrained(): boolean;
    constrain(constrained?: boolean): this;
    /** @internal */
    readonly conditionCount: number;
    /** @internal @override */
    addConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;
    /** @internal @override */
    removeConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;
    /** @internal */
    get constraining(): boolean;
    /** @internal */
    startConstraining(): void;
    /** @protected */
    willStartConstraining(): void;
    /** @protected */
    onStartConstraining(): void;
    /** @protected */
    didStartConstraining(): void;
    /** @internal */
    stopConstraining(): void;
    /** @protected */
    willStopConstraining(): void;
    /** @protected */
    onStopConstraining(): void;
    /** @protected */
    didStopConstraining(): void;
    /** @internal */
    updateConstraintVariable(): void;
    /** @protected @override */
    onSetValue(newValue: T, oldValue: T): void;
    /** @protected @override */
    onMount(): void;
    /** @protected @override */
    onUnmount(): void;
    /** @override */
    fromAny(value: T | U): T;
    /** @internal @protected */
    toNumber(value: T): number;
}

/** @public */
export declare const ThemeConstraintAnimator: ThemeConstraintAnimatorFactory<ThemeConstraintAnimator<any, any, any>>;

/** @public */
export declare interface ThemeConstraintAnimatorClass<A extends ThemeConstraintAnimator<any, any> = ThemeConstraintAnimator<any, any>> extends ThemeAnimatorClass<A> {
    /** @internal */
    readonly ConstrainedFlag: FastenerFlags;
    /** @internal */
    readonly ConstrainingFlag: FastenerFlags;
    /** @internal @override */
    readonly FlagShift: number;
    /** @internal @override */
    readonly FlagMask: FastenerFlags;
}

/** @public */
export declare type ThemeConstraintAnimatorDescriptor<O = unknown, T = unknown, U = T, I = {}> = ThisType<ThemeConstraintAnimator<O, T, U> & I> & ThemeConstraintAnimatorInit<T, U> & Partial<I>;

/** @public */
export declare interface ThemeConstraintAnimatorFactory<A extends ThemeConstraintAnimator<any, any> = ThemeConstraintAnimator<any, any>> extends ThemeConstraintAnimatorClass<A> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ThemeConstraintAnimatorFactory<A> & I;
    specialize(type: unknown): ThemeConstraintAnimatorFactory | null;
    define<O, T, U = T>(className: string, descriptor: ThemeConstraintAnimatorDescriptor<O, T, U>): ThemeConstraintAnimatorFactory<ThemeConstraintAnimator<any, T, U>>;
    define<O, T, U = T, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ThemeConstraintAnimatorDescriptor<O, T, U, I>): ThemeConstraintAnimatorFactory<ThemeConstraintAnimator<any, T, U> & I>;
    <O, T extends Length | null | undefined = Length | null | undefined, U extends AnyLength | null | undefined = AnyLength | null | undefined>(descriptor: {
        type: typeof Length;
    } & ThemeConstraintAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends number | null | undefined = number | null | undefined, U extends number | string | null | undefined = number | string | null | undefined>(descriptor: {
        type: typeof Number;
    } & ThemeConstraintAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = T>(descriptor: ({
        type: FromAny<T, U>;
    } | {
        fromAny(value: T | U): T;
    }) & ThemeConstraintAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = T>(descriptor: ThemeConstraintAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = T, I = {}>(descriptor: {
        implements: unknown;
    } & ThemeConstraintAnimatorDescriptor<O, T, U, I>): PropertyDecorator;
}

/** @public */
export declare interface ThemeConstraintAnimatorInit<T = unknown, U = T> extends ThemeAnimatorInit<T, U> {
    extends?: {
        prototype: ThemeConstraintAnimator<any, any>;
    } | string | boolean | null;
    constrain?: boolean;
    strength?: AnyConstraintStrength;
    willStartConstraining?(): void;
    didStartConstraining?(): void;
    willStopConstraining?(): void;
    didStopConstraining?(): void;
    toNumber?(value: T): number;
}

/** @public */
export declare interface ThemeContext {
    getLook<T>(look: Look<T, unknown>, mood?: MoodVector<Feel> | null): T | undefined;
    getLookOr<T, E>(look: Look<T, unknown>, elseValue: E): T | E;
    getLookOr<T, E>(look: Look<T, unknown>, mood: MoodVector<Feel> | null, elseValue: E): T | E;
}

/** @public */
export declare const ThemeContext: {
    is(object: unknown): object is ThemeContext;
};

/** @public */
export declare class ThemeMatrix implements Equals, Debug {
    constructor(rowArray: ReadonlyArray<[Look<unknown>, LookVector<unknown>]>, rowIndex: {
        readonly [name: string]: number | undefined;
    }, colArray: ReadonlyArray<[Feel, FeelVector]>, colIndex: {
        readonly [name: string]: number | undefined;
    });
    /** @internal */
    readonly rowArray: ReadonlyArray<[Look<unknown>, LookVector<unknown>]>;
    /** @internal */
    readonly rowIndex: {
        readonly [name: string]: number | undefined;
    };
    /** @internal */
    readonly colArray: ReadonlyArray<[Feel, FeelVector]>;
    /** @internal */
    readonly colIndex: {
        readonly [name: string]: number | undefined;
    };
    get rowCount(): number;
    get colCount(): number;
    hasRow(look: Look<unknown>): boolean;
    hasRow(name: string): boolean;
    hasCol(feel: Feel): boolean;
    hasCol(name: string): boolean;
    getRow<T>(look: Look<T>): LookVector<T> | undefined;
    getRow(name: string): LookVector<unknown> | undefined;
    getRow(index: number): LookVector<unknown> | undefined;
    getCol(feel: Feel): FeelVector | undefined;
    getCol(name: string): FeelVector | undefined;
    getCol(index: number): FeelVector | undefined;
    get<T>(look: Look<T>, mood: MoodVector): T | undefined;
    getOr<T, E>(look: Look<T>, mood: MoodVector, elseValue: E): T | E;
    plus(that: ThemeMatrix): ThemeMatrix;
    negative(): ThemeMatrix;
    minus(that: ThemeMatrix): ThemeMatrix;
    times(scalar: number): ThemeMatrix;
    dot<T>(look: Look<T>, col: MoodVector): T | undefined;
    dot(look: string | number, col: MoodVector): unknown | undefined;
    dotOr<T, E>(look: Look<T>, col: MoodVector, elseValue: E): T | E;
    dotOr(look: string | number, col: MoodVector, elseValue: unknown): unknown;
    timesCol(col: MoodVector): FeelVector;
    transform(that: MoodMatrix, implicitIdentity?: boolean): ThemeMatrix;
    row<T, U = never>(look: Look<T, U>, row: AnyLookVector<T> | undefined): ThemeMatrix;
    col(feel: Feel, col: AnyFeelVector | undefined): ThemeMatrix;
    updatedRow<T, U = never>(look: Look<T, U>, updates: LookVectorUpdates<T>, defaultRow?: AnyLookVector<T>): ThemeMatrix;
    updatedCol(feel: Feel, updates: FeelVectorUpdates, defaultCol?: AnyFeelVector): ThemeMatrix;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static empty(): ThemeMatrix;
    static forRows(...rows: [Look<unknown>, AnyLookVector<unknown>][]): ThemeMatrix;
    static forCols(...cols: [Feel, AnyFeelVector][]): ThemeMatrix;
    static fromRowArray(rowArray: ReadonlyArray<[Look<unknown>, LookVector<unknown>]>, rowIndex?: {
        readonly [name: string]: number | undefined;
    }): ThemeMatrix;
    static fromColArray(colArray: ReadonlyArray<[Feel, FeelVector]>, colIndex?: {
        readonly [name: string]: number | undefined;
    }): ThemeMatrix;
}

/** @public */
export declare interface ThemeProvider<V extends View, S extends ThemeService<V> | null | undefined = ThemeService<V>> extends Provider<V, S> {
    get mood(): MoodVector;
    setMood(mood: MoodVector): void;
    get theme(): ThemeMatrix;
    setTheme(theme: ThemeMatrix): void;
    createService(): S;
}

/** @public */
export declare const ThemeProvider: ProviderClass<ThemeProvider<any, any>>;

/** @public */
export declare class ThemeService<V extends View = View> extends Service<V> {
    constructor();
    readonly observerType?: Class<ThemeServiceObserver<V>>;
    readonly mood: MoodVector;
    protected initMood(): MoodVector;
    setMood(mood: MoodVector): void;
    readonly theme: ThemeMatrix;
    protected initTheme(): ThemeMatrix;
    setTheme(theme: ThemeMatrix): void;
    protected applyTheme(theme: ThemeMatrix, mood: MoodVector, timing?: AnyTiming | boolean): void;
    protected willApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    protected didApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    static global<V extends View>(): ThemeService<V>;
}

/** @public */
export declare interface ThemeServiceObserver<V extends View = View, S extends ThemeService<V> = ThemeService<V>> extends ServiceObserver<V, S> {
    serviceWillApplyTheme?(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean, service: S): void;
    serviceDidApplyTheme?(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean, service: S): void;
}

/** @public */
export declare abstract class TickGenerator<D> {
    abstract count(): number;
    abstract count(n: number): this;
    abstract domain(): Domain<D>;
    abstract domain(xs: AnyDomain<D>): this;
    abstract domain(x0: D, x1: D): this;
    abstract generate(): D[];
    format(tickValue: D): string;
    static fromScale<D>(scale: ContinuousScale<D, number>, n?: number): TickGenerator<D>;
    /** @internal */
    static step(dx: number, n: number): number;
}

/** @public */
export declare type TickOrientation = "top" | "right" | "bottom" | "left";

/** @internal */
export declare const enum TickState {
    Excluded = 0,
    Entering = 1,
    Included = 2,
    Leaving = 3
}

/** @public */
export declare abstract class TickView<D = unknown> extends GraphicsView {
    constructor(value: D);
    readonly observerType?: Class<TickViewObserver<D>>;
    abstract readonly orientation: TickOrientation;
    readonly value: D;
    /** @internal */
    readonly offset: number;
    /** @internal */
    setOffset(offset: number): void;
    /** @internal */
    readonly tickState: TickState;
    readonly anchor: Animator<this, R2Point, AnyR2Point>;
    readonly opacity: ThemeAnimator<this, number>;
    readonly tickMarkColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly tickMarkWidth: ThemeAnimator<this, number>;
    readonly tickMarkLength: ThemeAnimator<this, number>;
    readonly tickLabelPadding: ThemeAnimator<this, number>;
    readonly gridLineColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly gridLineWidth: ThemeAnimator<this, number>;
    readonly font: ThemeAnimator<this, Font | null, AnyFont | null>;
    readonly textColor: ThemeAnimator<this, Color | null, AnyColor | null>;
    readonly label: ViewRef<this, GraphicsView & Initable<GraphicsViewInit | string>>;
    static readonly label: MemberFastenerClass<TickView, "label">;
    /** @internal */
    readonly preserved: boolean;
    preserve(): boolean;
    preserve(preserve: boolean): this;
    fadeIn(timing?: Timing | boolean): void;
    fadeOut(timing?: Timing | boolean): void;
    protected onLayout(viewContext: ViewContextType<this>): void;
    /** @internal */
    private static globalAlpha;
    protected willRender(viewContext: ViewContextType<this>): void;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected didRender(viewContext: ViewContextType<this>): void;
    protected abstract layoutLabel(labelView: GraphicsView): void;
    protected abstract renderTick(context: PaintingContext, frame: R2Box): void;
    init(init: TickViewInit<D>): void;
    static top<D>(value: D): TopTickView<D>;
    static right<D>(value: D): RightTickView<D>;
    static bottom<D>(value: D): BottomTickView<D>;
    static left<D>(value: D): LeftTickView<D>;
    static from<D>(value: D, orientation: TickOrientation): TickView<D>;
    static fromInit<D>(init: TickViewInit<D>, orientation?: TickOrientation): TickView<D>;
    static fromInit(init: TickViewInit, orientation?: TickOrientation): TickView;
    static fromAny<D>(value: AnyTickView<D>, orientation?: TickOrientation): TickView<D>;
    static fromAny(value: AnyTickView, orientation?: TickOrientation): TickView;
}

/** @public */
export declare interface TickViewInit<D = unknown> extends GraphicsViewInit {
    value: D;
    orientation?: TickOrientation;
    tickMarkColor?: AnyColor;
    tickMarkWidth?: number;
    tickMarkLength?: number;
    tickLabelPadding?: number;
    gridLineColor?: AnyColor;
    gridLineWidth?: number;
    font?: AnyFont;
    textColor?: AnyColor;
    label?: GraphicsView | string | null;
}

/** @public */
export declare interface TickViewObserver<D = unknown, V extends TickView<D> = TickView<D>> extends GraphicsViewObserver<V> {
    viewWillAttachTickLabel?(labelView: GraphicsView, view: V): void;
    viewDidDetachTickLabel?(labelView: GraphicsView, view: V): void;
}

/** @public */
export declare class TimeTickGenerator extends TickGenerator<DateTime> {
    /** @internal */
    protected t0: number;
    /** @internal */
    protected dt: number;
    /** @internal */
    protected zone: TimeZone;
    /** @internal */
    protected n: number;
    constructor(t0: AnyDateTime, t1: AnyDateTime, n: number, zone?: TimeZone);
    count(): number;
    count(n: number): this;
    domain(): Domain<DateTime>;
    domain(ts: AnyDomain<DateTime>): this;
    domain(d0: AnyDateTime, d1: AnyDateTime): this;
    generate(interval?: TimeInterval | number): DateTime[];
    format(tickValue: DateTime): string;
    /** @internal */
    static interval(dt: number, interval?: TimeInterval | number): TimeInterval;
}

/** @internal */
export declare class TimingLook extends Look<Timing, AnyTiming> {
    combine(combination: Timing | undefined, value: Timing, weight: number): Timing;
    between(a: Timing, b: Timing): Interpolator<Timing>;
    coerce(value: AnyTiming): Timing;
}

/** @public */
export declare class TitleDeckBar extends DeckBar {
    constructor(node: HTMLElement);
    protected initRail(): void;
    get closeIcon(): Graphics;
    createCloseIcon(): SvgIconView | null;
    protected initBackMembrane(backMembrane: ButtonMembrane): void;
    get backIcon(): Graphics;
    createBackIcon(): SvgIconView | null;
    createBackButton(): DeckButton;
    protected initBackButton(backButton: DeckButton): void;
    protected initTitleSlider(titleSlider: DeckSlider): void;
    protected initMoreSlider(moreSlider: DeckSlider): void;
    pushTitle(title: string, timing?: AnyTiming | boolean): void;
    popTitle(timing?: AnyTiming | boolean): void;
    didPopBackButton(newLabelView: HtmlView | null, oldLabelView: HtmlView, backButton: DeckButton): void;
    readonly backMembrane: ViewRef<this, ButtonMembrane>;
    readonly backButton: ViewRef<this, DeckButton>;
    readonly titleSlider: ViewRef<this, DeckSlider>;
    readonly moreSlider: ViewRef<this, DeckSlider>;
    protected didLayout(viewContext: ViewContextType<this>): void;
    protected onBackButtonClick(event: MouseEvent): void;
    static get closeIcon(): Graphics;
    static get backIcon(): Graphics;
}

/** @public */
export declare class TitleDeckView extends DeckView {
    constructor(node: HTMLElement);
    protected initBar(): void;
    protected willPushCard(newCardView: DeckCard, oldCardView: DeckCard | null): void;
    protected didPushCard(newCardView: DeckCard, oldCardView: DeckCard | null): void;
    protected willPopCard(newCardView: DeckCard | null, oldCardView: DeckCard): void;
    didPressBackButton(event: Event | null): void;
}

/** @public */
export declare function ToAttributeString(value: unknown): string;

/** @public */
export declare interface ToAttributeString {
    toAttributeString(): string;
}

/** @public */
export declare interface ToCssValue {
    toCssValue(): CSSStyleValue | null;
}

/** @public */
export declare const ToCssValue: (value: unknown) => CSSStyleValue | null;

/** @public */
export declare class TokenView extends HtmlView {
    constructor(node: HTMLElement);
    readonly observerType?: Class<TokenViewObserver>;
    protected initToken(): void;
    protected initShape(shapeView: SvgView): void;
    protected initHead(headView: SvgView): void;
    protected initHeadIcon(headIconView: SvgView): void;
    protected initBody(bodyView: SvgView): void;
    protected initFoot(footView: SvgView): void;
    protected initFootIcon(footIconView: SvgView): void;
    protected initLabelContainer(labelContainer: HtmlView): void;
    protected initLabel(labelView: HtmlView): void;
    readonly tokenState: TokenViewState;
    get expanded(): boolean;
    get collapsed(): boolean;
    readonly expandedPhase: Animator<this, number>;
    readonly shape: ViewRef<this, SvgView>;
    static readonly shape: MemberFastenerClass<TokenView, "shape">;
    /** @internal */
    get fillLook(): Look<Color>;
    readonly head: ViewRef<this, SvgView>;
    static readonly head: MemberFastenerClass<TokenView, "head">;
    readonly headGesture: PositionGesture<this, SvgView>;
    static readonly headGesture: MemberFastenerClass<TokenView, "headGesture">;
    /** @internal */
    readonly headIcon: ViewRef<this, SvgView>;
    static readonly headIcon: MemberFastenerClass<TokenView, "headIcon">;
    readonly icon: Property<this, Graphics | null> & {
        embossed: boolean;
    };
    readonly body: ViewRef<this, SvgView>;
    static readonly body: MemberFastenerClass<TokenView, "body">;
    readonly bodyGesture: PositionGesture<this, SvgView>;
    static readonly bodyGesture: MemberFastenerClass<TokenView, "bodyGesture">;
    readonly foot: ViewRef<this, SvgView>;
    static readonly foot: MemberFastenerClass<TokenView, "foot">;
    readonly footGesture: PositionGesture<this, SvgView>;
    static readonly footGesture: MemberFastenerClass<TokenView, "footGesture">;
    /** @internal */
    readonly footIcon: ViewRef<this, SvgView>;
    static readonly footIcon: MemberFastenerClass<TokenView, "footIcon">;
    readonly accessory: Property<this, Graphics | null> & {
        embossed: boolean;
    };
    readonly labelContainer: ViewRef<this, HtmlView>;
    static readonly labelContainer: MemberFastenerClass<TokenView, "labelContainer">;
    readonly label: ViewRef<this, HtmlView>;
    static readonly label: MemberFastenerClass<TokenView, "label">;
    protected needsProcess(processFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected layoutToken(): void;
    expand(timing?: AnyTiming | boolean): void;
    protected willExpand(): void;
    protected onExpand(): void;
    protected didExpand(): void;
    collapse(timing?: AnyTiming | boolean): void;
    protected willCollapse(): void;
    protected onCollapse(): void;
    protected didCollapse(): void;
    toggle(timing?: AnyTiming | boolean): void;
    protected onClickHead(event: MouseEvent): void;
    protected didPressHead(): void;
    protected onClickBody(event: MouseEvent): void;
    protected didPressBody(): void;
    protected onClickFoot(event: MouseEvent): void;
    protected didPressFoot(): void;
    init(init: TokenViewInit): void;
}

/** @public */
export declare interface TokenViewInit extends HtmlViewInit {
}

/** @public */
export declare interface TokenViewObserver<V extends TokenView = TokenView> extends HtmlViewObserver<V> {
    tokenWillExpand?(view: V): void;
    tokenDidExpand?(view: V): void;
    tokenWillCollapse?(view: V): void;
    tokenDidCollapse?(view: V): void;
    tokenDidPressHead?(view: V): void;
    tokenDidPressBody?(view: V): void;
    tokenDidPressFoot?(view: V): void;
}

/** @public */
export declare type TokenViewState = "collapsed" | "expanding" | "expanded" | "collapsing";

/** @public */
export declare class TopAxisController<X = unknown> extends AxisController<X> {
    readonly axis: TraitViewRef<this, TopAxisTrait<X>, TopAxisView<X>>;
    static readonly axis: MemberFastenerClass<TopAxisController, "axis">;
}

/** @public */
export declare abstract class TopAxisTrait<X = unknown> extends AxisTrait<X> {
    readonly observerType?: Class<AxisTraitObserver<X, TopAxisTrait<X>>>;
}

/** @public */
export declare class TopAxisView<X = unknown> extends AxisView<X> {
    get orientation(): AxisOrientation;
    readonly scale: ContinuousScaleAnimator<this, X, number>;
    protected layoutTick(tick: TickView<X>, origin: R2Point, frame: R2Box, scale: ContinuousScale<X, number>): void;
    protected renderDomain(context: PaintingContext, origin: R2Point, frame: R2Box): void;
}

/** @public */
export declare class TopTickView<X = unknown> extends TickView<X> {
    constructor(value: X);
    get orientation(): TickOrientation;
    protected layoutLabel(labelView: GraphicsView): void;
    protected renderTick(context: PaintingContext, frame: R2Box): void;
}

/** @public */
export declare function ToStyleString(value: unknown): string;

/** @public */
export declare interface ToStyleString {
    toStyleString(): string;
}

/** @public */
export declare type TouchAction = "auto" | "manipulation" | "none" | "pan-down" | "pan-down pinch-zoom" | "pan-left" | "pan-left pan-down" | "pan-left pan-down pinch-zoom" | "pan-left pan-up" | "pan-left pan-up pinch-zoom" | "pan-left pan-y" | "pan-left pan-y pinch-zoom" | "pan-left pinch-zoom" | "pan-right" | "pan-right pan-down" | "pan-right pan-down pinch-zoom" | "pan-right pan-up" | "pan-right pan-up pinch-zoom" | "pan-right pan-y" | "pan-right pan-y pinch-zoom" | "pan-right pinch-zoom" | "pan-up" | "pan-up pinch-zoom" | "pan-x" | "pan-x pan-down" | "pan-x pan-down pinch-zoom" | "pan-x pan-up" | "pan-x pan-up pinch-zoom" | "pan-x pan-y" | "pan-x pan-y pinch-zoom" | "pan-x pinch-zoom" | "pan-y" | "pan-y pinch-zoom" | "pinch-zoom";

/** @internal */
export declare interface TouchMomentumGesture<O = unknown, V extends View = View> extends MomentumGesture<O, V> {
    /** @internal @protected @override */
    attachHoverEvents(view: V): void;
    /** @internal @protected @override */
    detachHoverEvents(view: V): void;
    /** @internal @protected @override */
    attachPressEvents(view: V): void;
    /** @internal @protected @override */
    detachPressEvents(view: V): void;
    /** @internal @protected */
    updateInput(input: MomentumGestureInput, event: TouchEvent, touch: Touch): void;
    /** @internal @protected */
    onTouchStart(event: TouchEvent): void;
    /** @internal @protected */
    onTouchMove(event: TouchEvent): void;
    /** @internal @protected */
    onTouchEnd(event: TouchEvent): void;
    /** @internal @protected */
    onTouchCancel(event: TouchEvent): void;
}

/** @internal */
export declare const TouchMomentumGesture: MomentumGestureFactory<TouchMomentumGesture<any, any>>;

/** @internal */
export declare interface TouchPositionGesture<O = unknown, V extends View = View> extends PositionGesture<O, V> {
    /** @internal @protected @override */
    attachHoverEvents(view: V): void;
    /** @internal @protected @override */
    detachHoverEvents(view: V): void;
    /** @internal @protected @override */
    attachPressEvents(view: V): void;
    /** @internal @protected @override */
    detachPressEvents(view: V): void;
    /** @internal @protected */
    updateInput(input: PositionGestureInput, event: TouchEvent, touch: Touch): void;
    /** @internal @protected */
    onTouchStart(event: TouchEvent): void;
    /** @internal @protected */
    onTouchMove(event: TouchEvent): void;
    /** @internal @protected */
    onTouchEnd(event: TouchEvent): void;
    /** @internal @protected */
    onTouchCancel(event: TouchEvent): void;
}

/** @internal */
export declare const TouchPositionGesture: PositionGestureFactory<TouchPositionGesture<any, any>>;

/** @internal */
export declare interface TouchScaleGesture<O = unknown, V extends View = View, X = unknown, Y = unknown> extends ScaleGesture<O, V, X, Y> {
    /** @internal @protected @override */
    attachHoverEvents(view: V): void;
    /** @internal @protected @override */
    detachHoverEvents(view: V): void;
    /** @internal @protected @override */
    attachPressEvents(view: V): void;
    /** @internal @protected @override */
    detachPressEvents(view: V): void;
    /** @internal @protected */
    updateInput(input: ScaleGestureInput<X, Y>, event: TouchEvent, touch: Touch): void;
    /** @internal @protected */
    onTouchStart(event: TouchEvent): void;
    /** @internal @protected */
    onTouchMove(event: TouchEvent): void;
    /** @internal @protected */
    onTouchEnd(event: TouchEvent): void;
    /** @internal @protected */
    onTouchCancel(event: TouchEvent): void;
}

/** @internal */
export declare const TouchScaleGesture: ScaleGestureFactory<TouchScaleGesture<any, any, any, any>>;

/** @public */
export declare abstract class Trait implements HashCode, Initable<TraitInit>, Observable, Consumable, FastenerContext {
    constructor();
    readonly observerType?: Class<TraitObserver>;
    /** @override */
    readonly consumerType?: Class<Consumer>;
    /** @internal */
    readonly uid: number;
    readonly key: string | undefined;
    /** @internal */
    setKey(key: string | undefined): void;
    /** @internal */
    readonly flags: TraitFlags;
    setFlags(flags: TraitFlags): void;
    readonly model: Model | null;
    /** @internal */
    attachModel(model: Model, nextTrait: Trait | null): void;
    protected willAttachModel(model: Model): void;
    protected onAttachModel(model: Model): void;
    protected didAttachModel(model: Model): void;
    /** @internal */
    detachModel(model: Model): void;
    protected willDetachModel(model: Model): void;
    protected onDetachModel(model: Model): void;
    protected didDetachModel(model: Model): void;
    get modelFlags(): ModelFlags;
    setModelFlags(modelFlags: ModelFlags): void;
    remove(): void;
    get parent(): Model | null;
    /** @protected */
    willAttachParent(parent: Model): void;
    /** @protected */
    onAttachParent(parent: Model): void;
    /** @protected */
    didAttachParent(parent: Model): void;
    /** @protected */
    willDetachParent(parent: Model): void;
    /** @protected */
    onDetachParent(parent: Model): void;
    /** @protected */
    didDetachParent(parent: Model): void;
    get nextSibling(): Model | null;
    get previousSibling(): Model | null;
    get firstChild(): Model | null;
    get lastChild(): Model | null;
    forEachChild<T>(callback: (child: Model) => T | void): T | undefined;
    forEachChild<T, S>(callback: (this: S, child: Model) => T | void, thisArg: S): T | undefined;
    getChild<F extends abstract new (...args: any) => Model>(key: string, childBound: F): InstanceType<F> | null;
    getChild(key: string, childBound?: abstract new (...args: any) => Model): Model | null;
    setChild<M extends Model>(key: string, newChild: M): Model | null;
    setChild<F extends ModelCreator<F>>(key: string, factory: F): Model | null;
    setChild(key: string, newChild: AnyModel | null): Model | null;
    appendChild<M extends Model>(child: M, key?: string): M;
    appendChild<F extends ModelCreator<F>>(factory: F, key?: string): InstanceType<F>;
    appendChild(child: AnyModel, key?: string): Model;
    prependChild<M extends Model>(child: M, key?: string): M;
    prependChild<F extends ModelCreator<F>>(factory: F, key?: string): InstanceType<F>;
    prependChild(child: AnyModel, key?: string): Model;
    insertChild<M extends Model>(child: M, target: Model | null, key?: string): M;
    insertChild<F extends ModelCreator<F>>(factory: F, target: Model | null, key?: string): InstanceType<F>;
    insertChild(child: AnyModel, target: Model | null, key?: string): Model;
    replaceChild<M extends Model>(newChild: Model, oldChild: M): M;
    replaceChild<M extends Model>(newChild: AnyModel, oldChild: M): M;
    get insertChildFlags(): ModelFlags;
    /** @protected */
    willInsertChild(child: Model, target: Model | null): void;
    /** @protected */
    onInsertChild(child: Model, target: Model | null): void;
    /** @protected */
    didInsertChild(child: Model, target: Model | null): void;
    removeChild<M extends Model>(child: M): M | null;
    removeChild(key: string | Model): Model | null;
    get removeChildFlags(): ModelFlags;
    /** @protected */
    willRemoveChild(child: Model): void;
    /** @protected */
    onRemoveChild(child: Model): void;
    /** @protected */
    didRemoveChild(child: Model): void;
    removeChildren(): void;
    sortChildren(comparator: Comparator<Model>): void;
    getSuper<F extends abstract new (...args: any) => Model>(superBound: F): InstanceType<F> | null;
    getBase<F extends abstract new (...args: any) => Model>(baseBound: F): InstanceType<F> | null;
    readonly nextTrait: Trait | null;
    /** @internal */
    setNextTrait(nextTrait: Trait | null): void;
    readonly previousTrait: Trait | null;
    /** @internal */
    setPreviousTrait(previousTrait: Trait | null): void;
    get firstTrait(): Trait | null;
    get lastTrait(): Trait | null;
    forEachTrait<T>(callback: (trait: Trait) => T | void): T | undefined;
    forEachTrait<T, S>(callback: (this: S, trait: Trait) => T | void, thisArg: S): T | undefined;
    getTrait<F extends abstract new (...args: any) => Trait>(key: string, traitBound: F): InstanceType<F> | null;
    getTrait(key: string, traitBound?: abstract new (...args: any) => Trait): Trait | null;
    getTrait<F extends abstract new (...args: any) => Trait>(traitBound: F): InstanceType<F> | null;
    setTrait<T extends Trait>(key: string, newTrait: T): Trait | null;
    setTrait<F extends TraitCreator<F>>(key: string, factory: F): Trait | null;
    setTrait(key: string, newTrait: AnyTrait | null): Trait | null;
    appendTrait<T extends Trait>(trait: T, key?: string): T;
    appendTrait<F extends TraitCreator<F>>(factory: F, key?: string): InstanceType<F>;
    appendTrait(trait: AnyTrait, key?: string): Trait;
    prependTrait<T extends Trait>(trait: T, key?: string): T;
    prependTrait<F extends TraitCreator<F>>(factory: F, key?: string): InstanceType<F>;
    prependTrait(trait: AnyTrait, key?: string): Trait;
    insertTrait<T extends Trait>(trait: T, target: Trait | null, key?: string): T;
    insertTrait<F extends TraitCreator<F>>(factory: F, target: Trait | null, key?: string): InstanceType<F>;
    insertTrait(trait: AnyTrait, target: Trait | null, key?: string): Trait;
    replaceTraitt<T extends Trait>(newTrait: Trait, oldTrait: T): T;
    replaceTraitt<T extends Trait>(newTrait: AnyTrait, oldTrait: T): T;
    get insertTraitFlags(): ModelFlags;
    /** @protected */
    willInsertTrait(trait: Trait, target: Trait | null): void;
    /** @protected */
    onInsertTrait(trait: Trait, target: Trait | null): void;
    /** @protected */
    didInsertTrait(trait: Trait, target: Trait | null): void;
    removeTrait<T extends Trait>(trait: T): T | null;
    removeTrait(key: string | Trait): Trait | null;
    get removeTraitFlags(): ModelFlags;
    /** @protected */
    willRemoveTrait(trait: Trait): void;
    /** @protected */
    onRemoveTrait(trait: Trait): void;
    /** @protected */
    didRemoveTrait(trait: Trait): void;
    sortTraits(comparator: Comparator<Trait>): void;
    getSuperTrait<F extends abstract new (...args: any) => Trait>(superBound: F): InstanceType<F> | null;
    getBaseTrait<F extends abstract new (...args: any) => Trait>(baseBound: F): InstanceType<F> | null;
    readonly warpProvider: WarpProvider<this>;
    readonly warpRef: Property<this, WarpRef | null>;
    get mounted(): boolean;
    get mountFlags(): ModelFlags;
    /** @internal */
    mountTrait(): void;
    protected willMount(): void;
    protected onMount(): void;
    protected didMount(): void;
    /** @internal */
    unmountTrait(): void;
    protected willUnmount(): void;
    protected onUnmount(): void;
    protected didUnmount(): void;
    requireUpdate(updateFlags: ModelFlags, immediate?: boolean): void;
    /** @protected */
    needsUpdate(updateFlags: ModelFlags, immediate: boolean): ModelFlags;
    requestUpdate(target: Model, updateFlags: ModelFlags, immediate: boolean): void;
    get updating(): boolean;
    get analyzing(): boolean;
    /** @protected */
    needsAnalyze(analyzeFlags: ModelFlags, modelContext: TraitContextType<this>): ModelFlags;
    /** @protected */
    willAnalyze(analyzeFlags: ModelFlags, modelContext: TraitContextType<this>): void;
    /** @protected */
    onAnalyze(analyzeFlags: ModelFlags, modelContext: TraitContextType<this>): void;
    /** @protected */
    didAnalyze(analyzeFlags: ModelFlags, modelContext: TraitContextType<this>): void;
    /** @protected */
    willMutate(modelContext: TraitContextType<this>): void;
    /** @protected */
    onMutate(modelContext: TraitContextType<this>): void;
    /** @protected */
    didMutate(modelContext: TraitContextType<this>): void;
    /** @protected */
    willAggregate(modelContext: TraitContextType<this>): void;
    /** @protected */
    onAggregate(modelContext: TraitContextType<this>): void;
    /** @protected */
    didAggregate(modelContext: TraitContextType<this>): void;
    /** @protected */
    willCorrelate(modelContext: TraitContextType<this>): void;
    /** @protected */
    onCorrelate(modelContext: TraitContextType<this>): void;
    /** @protected */
    didCorrelate(modelContext: TraitContextType<this>): void;
    /** @protected */
    analyzeChildren(analyzeFlags: ModelFlags, modelContext: TraitContextType<this>, analyzeChild: (this: TraitModelType<this>, child: Model, analyzeFlags: ModelFlags, modelContext: TraitContextType<this>) => void, analyzeChildren: (this: TraitModelType<this>, analyzeFlags: ModelFlags, modelContext: TraitContextType<this>, analyzeChild: (this: TraitModelType<this>, child: Model, analyzeFlags: ModelFlags, modelContext: TraitContextType<this>) => void) => void): void;
    get refreshing(): boolean;
    /** @protected */
    needsRefresh(refreshFlags: ModelFlags, modelContext: TraitContextType<this>): ModelFlags;
    /** @protected */
    willRefresh(refreshFlags: ModelFlags, modelContext: TraitContextType<this>): void;
    /** @protected */
    onRefresh(refreshFlags: ModelFlags, modelContext: TraitContextType<this>): void;
    /** @protected */
    didRefresh(refreshFlags: ModelFlags, modelContext: TraitContextType<this>): void;
    /** @protected */
    willValidate(modelContext: TraitContextType<this>): void;
    /** @protected */
    onValidate(modelContext: TraitContextType<this>): void;
    /** @protected */
    didValidate(modelContext: TraitContextType<this>): void;
    /** @protected */
    willReconcile(modelContext: TraitContextType<this>): void;
    /** @protected */
    onReconcile(modelContext: TraitContextType<this>): void;
    /** @protected */
    didReconcile(modelContext: TraitContextType<this>): void;
    /** @protected */
    refreshChildren(refreshFlags: ModelFlags, modelContext: TraitContextType<this>, refreshChild: (this: TraitModelType<this>, child: Model, refreshFlags: ModelFlags, modelContext: TraitContextType<this>) => void, refreshChildren: (this: TraitModelType<this>, refreshFlags: ModelFlags, modelContext: TraitContextType<this>, refreshChild: (this: TraitModelType<this>, child: Model, refreshFlags: ModelFlags, modelContext: TraitContextType<this>) => void) => void): void;
    /** @internal */
    readonly fasteners: {
        [fastenerName: string]: Fastener | undefined;
    } | null;
    /** @override */
    hasFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): boolean;
    /** @override */
    getFastener<F extends Fastener<any>>(fastenerName: string, fastenerBound: Proto<F>): F | null;
    /** @override */
    getFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): Fastener | null;
    /** @override */
    setFastener(fastenerName: string, newFastener: Fastener | null): void;
    /** @internal */
    protected attachFastener(fastenerName: string, fastener: Fastener): void;
    protected willAttachFastener(fastenerName: string, fastener: Fastener): void;
    protected onAttachFastener(fastenerName: string, fastener: Fastener): void;
    protected didAttachFastener(fastenerName: string, fastener: Fastener): void;
    /** @internal */
    protected detachFastener(fastenerName: string, fastener: Fastener): void;
    protected willDetachFastener(fastenerName: string, fastener: Fastener): void;
    protected onDetachFastener(fastenerName: string, fastener: Fastener): void;
    protected didDetachFastener(fastenerName: string, fastener: Fastener): void;
    /** @override */
    getLazyFastener<F extends Fastener<any>>(fastenerName: string, fastenerBound: Proto<F>): F | null;
    /** @override */
    getLazyFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): Fastener | null;
    /** @override */
    getSuperFastener<F extends Fastener<any>>(fastenerName: string, fastenerBound: Proto<F>): F | null;
    /** @override */
    getSuperFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): Fastener | null;
    /** @internal */
    protected mountFasteners(): void;
    /** @internal */
    protected unmountFasteners(): void;
    protected bindFastener(fastener: Fastener): void;
    /** @internal */
    protected bindModelFasteners(model: Model): void;
    /** @internal */
    protected unbindModelFasteners(model: Model): void;
    /** @internal */
    protected bindChildFasteners(child: Model, target: Model | null): void;
    /** @internal */
    protected bindChildFastener(fastener: Fastener, child: Model, target: Model | null): void;
    /** @internal */
    protected unbindChildFasteners(child: Model): void;
    /** @internal */
    protected unbindChildFastener(fastener: Fastener, child: Model): void;
    /** @internal */
    protected bindTraitFasteners(trait: Trait, target: Trait | null): void;
    /** @internal */
    protected bindTraitFastener(fastener: Fastener, trait: Trait, target: Trait | null): void;
    /** @internal */
    protected unbindTraitFasteners(trait: Trait): void;
    /** @internal */
    protected unbindTraitFastener(fastener: Fastener, trait: Trait): void;
    /** @internal */
    readonly decoherent: ReadonlyArray<Fastener> | null;
    /** @internal */
    decohereFastener(fastener: Fastener): void;
    /** @internal */
    recohereFasteners(t?: number): void;
    /** @internal */
    recohereDownlinks(t: number): void;
    /** @internal */
    readonly observers: ReadonlyArray<ObserverType<this>>;
    /** @override */
    observe(observer: ObserverType<this>): void;
    protected willObserve(observer: ObserverType<this>): void;
    protected onObserve(observer: ObserverType<this>): void;
    protected didObserve(observer: ObserverType<this>): void;
    /** @override */
    unobserve(observer: ObserverType<this>): void;
    protected willUnobserve(observer: ObserverType<this>): void;
    protected onUnobserve(observer: ObserverType<this>): void;
    protected didUnobserve(observer: ObserverType<this>): void;
    protected forEachObserver<T>(callback: (this: this, observer: ObserverType<this>) => T | void): T | undefined;
    callObservers<O, K extends keyof ObserverMethods<O>>(this: this & {
        readonly observerType?: Class<O>;
    }, key: K, ...args: ObserverParameters<O, K>): void;
    /** @internal */
    readonly consumers: ReadonlyArray<ConsumerType<this>>;
    /** @override */
    consume(consumer: ConsumerType<this>): void;
    protected willConsume(consumer: ConsumerType<this>): void;
    protected onConsume(consumer: ConsumerType<this>): void;
    protected didConsume(consumer: ConsumerType<this>): void;
    /** @override */
    unconsume(consumer: ConsumerType<this>): void;
    protected willUnconsume(consumer: ConsumerType<this>): void;
    protected onUnconsume(consumer: ConsumerType<this>): void;
    protected didUnconsume(consumer: ConsumerType<this>): void;
    get consuming(): boolean;
    get startConsumingFlags(): ModelFlags;
    protected startConsuming(): void;
    protected willStartConsuming(): void;
    protected onStartConsuming(): void;
    protected didStartConsuming(): void;
    get stopConsumingFlags(): ModelFlags;
    protected stopConsuming(): void;
    protected willStopConsuming(): void;
    protected onStopConsuming(): void;
    protected didStopConsuming(): void;
    /** @internal */
    protected startConsumingFasteners(): void;
    /** @internal */
    protected stopConsumingFasteners(): void;
    get modelContext(): TraitContextType<this> | null;
    /** @override */
    equals(that: unknown): boolean;
    /** @override */
    hashCode(): number;
    /** @override */
    init(init: TraitInit): void;
    static create<S extends new () => InstanceType<S>>(this: S): InstanceType<S>;
    static fromInit<S extends abstract new (...args: any) => InstanceType<S>>(this: S, init: InitType<InstanceType<S>>): InstanceType<S>;
    static fromAny<S extends abstract new (...args: any) => InstanceType<S>>(this: S, value: AnyTrait<InstanceType<S>>): InstanceType<S>;
    /** @internal */
    static uid: () => number;
    /** @internal */
    static readonly MountedFlag: TraitFlags;
    /** @internal */
    static readonly ConsumingFlag: TraitFlags;
    /** @internal */
    static readonly FlagShift: number;
    /** @internal */
    static readonly FlagMask: ModelFlags;
    static readonly MountFlags: ModelFlags;
    static readonly InsertChildFlags: ModelFlags;
    static readonly RemoveChildFlags: ModelFlags;
    static readonly InsertTraitFlags: ModelFlags;
    static readonly RemoveTraitFlags: ModelFlags;
    static readonly StartConsumingFlags: TraitFlags;
    static readonly StopConsumingFlags: TraitFlags;
}

/** @public */
export declare interface TraitClass<T extends Trait = Trait, U = AnyTrait<T>> extends Function, TraitFactory<T, U> {
    readonly prototype: T;
}

/** @public */
export declare interface TraitConstructor<T extends Trait = Trait, U = AnyTrait<T>> extends TraitClass<T, U> {
    new (): T;
}

/** @public */
export declare type TraitContextType<T extends Trait> = ModelContextType<TraitModelType<T>>;

/** @public */
export declare interface TraitControllerRef<O = unknown, T extends Trait = Trait, C extends Controller = Controller> extends ControllerRef<O, C> {
    /** @override */
    get fastenerType(): Proto<TraitControllerRef<any, any, any>>;
    /** @internal */
    getTraitRef(controller: C): TraitRef<unknown, T>;
    get trait(): T | null;
    setTrait(trait: T | null, targetTrait?: Trait | null, key?: string): C | null;
    removeTrait(trait: T | null): C | null;
    deleteTrait(trait: T | null): C | null;
    createController(trait?: T): C;
}

/** @public */
export declare const TraitControllerRef: TraitControllerRefFactory<TraitControllerRef<any, any, any>>;

/** @public */
export declare interface TraitControllerRefClass<F extends TraitControllerRef<any, any, any> = TraitControllerRef<any, any, any>> extends ControllerRefClass<F> {
}

/** @public */
export declare type TraitControllerRefDescriptor<O = unknown, T extends Trait = Trait, C extends Controller = Controller, I = {}> = ThisType<TraitControllerRef<O, T, C> & I> & TraitControllerRefInit<T, C> & Partial<I>;

/** @public */
export declare interface TraitControllerRefFactory<F extends TraitControllerRef<any, any, any> = TraitControllerRef<any, any, any>> extends TraitControllerRefClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): TraitControllerRefFactory<F> & I;
    define<O, T extends Trait = Trait, C extends Controller = Controller>(className: string, descriptor: TraitControllerRefDescriptor<O, T, C>): TraitControllerRefFactory<TraitControllerRef<any, T, C>>;
    define<O, T extends Trait = Trait, C extends Controller = Controller>(className: string, descriptor: {
        observes: boolean;
    } & TraitControllerRefDescriptor<O, T, C, ObserverType<C>>): TraitControllerRefFactory<TraitControllerRef<any, T, C>>;
    define<O, T extends Trait = Trait, C extends Controller = Controller, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & TraitControllerRefDescriptor<O, T, C, I>): TraitControllerRefFactory<TraitControllerRef<any, T, C> & I>;
    define<O, T extends Trait = Trait, C extends Controller = Controller, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & TraitControllerRefDescriptor<O, T, C, I & ObserverType<C>>): TraitControllerRefFactory<TraitControllerRef<any, T, C> & I>;
    <O, T extends Trait = Trait, C extends Controller = Controller>(descriptor: TraitControllerRefDescriptor<O, T, C>): PropertyDecorator;
    <O, T extends Trait = Trait, C extends Controller = Controller>(descriptor: {
        observes: boolean;
    } & TraitControllerRefDescriptor<O, T, C, ObserverType<C>>): PropertyDecorator;
    <O, T extends Trait = Trait, C extends Controller = Controller, I = {}>(descriptor: {
        implements: unknown;
    } & TraitControllerRefDescriptor<O, T, C, I>): PropertyDecorator;
    <O, T extends Trait = Trait, C extends Controller = Controller, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & TraitControllerRefDescriptor<O, T, C, I & ObserverType<C>>): PropertyDecorator;
}

/** @public */
export declare interface TraitControllerRefInit<T extends Trait, C extends Controller = Controller> extends ControllerRefInit<C> {
    extends?: {
        prototype: TraitControllerRef<any, any, any>;
    } | string | boolean | null;
    getTraitRef?(controller: C): TraitRef<any, T>;
    createController?(trait?: T): C;
}

/** @internal */
export declare type TraitControllerRefType<F extends TraitControllerRef<any, any, any>> = F extends TraitControllerRef<any, any, infer C> ? C : never;

/** @public */
export declare interface TraitControllerSet<O = unknown, T extends Trait = Trait, C extends Controller = Controller> extends ControllerSet<O, C> {
    /** @internal */
    readonly traitControllers: {
        readonly [traitId: number]: C | undefined;
    };
    /** @internal */
    getTraitRef(controller: C): TraitRef<unknown, T>;
    hasTraitController(trait: Trait): boolean;
    addTraitController(trait: T, targetTrait?: Trait | null, key?: string): C;
    removeTraitController(trait: T): C | null;
    deleteTraitController(trait: T): C | null;
    attachControllerTrait(controller: C, trait: T, targetTrait?: Trait | null): C;
    /** @protected */
    initControllerTrait(controller: C, trait: T): void;
    /** @protected */
    willAttachControllerTrait(controller: C, trait: T, targetTrait: Trait | null): void;
    /** @protected */
    onAttachControllerTrait(controller: C, trait: T, targetTrait: Trait | null): void;
    /** @protected */
    didAttachControllerTrait(controller: C, trait: T, targetTrait: Trait | null): void;
    detachControllerTrait(controller: C, trait: T): C | null;
    /** @protected */
    deinitControllerTrait(controller: C, trait: T): void;
    /** @protected */
    willDetachControllerTrait(controller: C, trait: T): void;
    /** @protected */
    onDetachControllerTrait(controller: C, trait: T): void;
    /** @protected */
    didDetachControllerTrait(controller: C, trait: T): void;
    /** @protected @override */
    onAttachController(controller: C, targetController: Controller | null): void;
    /** @protected @override */
    onDetachController(controller: C): void;
    createController(trait?: T): C;
}

/** @public */
export declare const TraitControllerSet: TraitControllerSetFactory<TraitControllerSet<any, any, any>>;

/** @public */
export declare interface TraitControllerSetClass<F extends TraitControllerSet<any, any, any> = TraitControllerSet<any, any, any>> extends ControllerSetClass<F> {
}

/** @public */
export declare type TraitControllerSetDescriptor<O = unknown, T extends Trait = Trait, C extends Controller = Controller, I = {}> = ThisType<TraitControllerSet<O, T, C> & I> & TraitControllerSetInit<T, C> & Partial<I>;

/** @public */
export declare interface TraitControllerSetFactory<F extends TraitControllerSet<any, any, any> = TraitControllerSet<any, any, any>> extends TraitControllerSetClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): TraitControllerSetFactory<F> & I;
    define<O, T extends Trait = Trait, C extends Controller = Controller>(className: string, descriptor: TraitControllerSetDescriptor<O, T, C>): TraitControllerSetFactory<TraitControllerSet<any, T, C>>;
    define<O, T extends Trait = Trait, C extends Controller = Controller>(className: string, descriptor: {
        observes: boolean;
    } & TraitControllerSetDescriptor<O, T, C, ObserverType<C>>): TraitControllerSetFactory<TraitControllerSet<any, T, C>>;
    define<O, T extends Trait = Trait, C extends Controller = Controller, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & TraitControllerSetDescriptor<O, T, C, I>): TraitControllerSetFactory<TraitControllerSet<any, T, C> & I>;
    define<O, T extends Trait = Trait, C extends Controller = Controller, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & TraitControllerSetDescriptor<O, T, C, I & ObserverType<C>>): TraitControllerSetFactory<TraitControllerSet<any, T, C> & I>;
    <O, T extends Trait = Trait, C extends Controller = Controller>(descriptor: TraitControllerSetDescriptor<O, T, C>): PropertyDecorator;
    <O, T extends Trait = Trait, C extends Controller = Controller>(descriptor: {
        observes: boolean;
    } & TraitControllerSetDescriptor<O, T, C, ObserverType<C>>): PropertyDecorator;
    <O, T extends Trait = Trait, C extends Controller = Controller, I = {}>(descriptor: {
        implements: unknown;
    } & TraitControllerSetDescriptor<O, T, C, I>): PropertyDecorator;
    <O, T extends Trait = Trait, C extends Controller = Controller, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & TraitControllerSetDescriptor<O, T, C, I & ObserverType<C>>): PropertyDecorator;
}

/** @public */
export declare interface TraitControllerSetInit<T extends Trait = Trait, C extends Controller = Controller> extends ControllerSetInit<C> {
    extends?: {
        prototype: TraitControllerSet<any, any, any>;
    } | string | boolean | null;
    getTraitRef?(controller: C): TraitRef<any, T>;
    willAttachControllerTrait?(controller: C, trait: T, targetTrait: Trait | null): void;
    didAttachControllerTrait?(controller: C, trait: T, targetTrait: Trait | null): void;
    willDetachControllerTrait?(controller: C, trait: T): void;
    didDetachControllerTrait?(controller: C, trait: T): void;
    createController?(trait?: T): C;
}

/** @internal */
export declare type TraitControllerSetType<F extends TraitControllerSet<any, any, any>> = F extends TraitControllerSet<any, any, infer C> ? C : never;

/** @public */
export declare type TraitCreator<F extends (abstract new (...args: any) => T) & Creatable<InstanceType<F>>, T extends Trait = Trait> = (abstract new (...args: any) => InstanceType<F>) & Creatable<InstanceType<F>>;

/** @public */
export declare interface TraitFactory<T extends Trait = Trait, U = AnyTrait<T>> extends Creatable<T>, FromAny<T, U> {
    fromInit(init: InitType<T>): T;
}

/** @public */
export declare type TraitFlags = number;

/** @public */
export declare interface TraitInit {
    /** @internal */
    uid?: never;
    type?: Creatable<Trait>;
    key?: string;
    traits?: AnyTrait[];
}

/** @public */
export declare type TraitModelType<T extends Trait> = T extends {
    readonly model: infer M | null;
} ? M : never;

/** @public */
export declare interface TraitObserver<R extends Trait = Trait> extends Observer<R> {
    traitWillAttachModel?(model: TraitModelType<R>, trait: R): void;
    traitDidAttachModel?(model: TraitModelType<R>, trait: R): void;
    traitWillDetachModel?(model: TraitModelType<R>, trait: R): void;
    traitDidDetachModel?(model: TraitModelType<R>, trait: R): void;
    traitWillAttachParent?(parent: Model, trait: R): void;
    traitDidAttachParent?(parent: Model, trait: R): void;
    traitWillDetachParent?(parent: Model, trait: R): void;
    traitDidDetachParent?(parent: Model, trait: R): void;
    traitWillInsertChild?(child: Model, target: Model | null, trait: R): void;
    traitDidInsertChild?(child: Model, target: Model | null, trait: R): void;
    traitWillRemoveChild?(child: Model, trait: R): void;
    traitDidRemoveChild?(child: Model, trait: R): void;
    traitWillInsertTrait?(member: Trait, target: Trait | null, trait: R): void;
    traitDidInsertTrait?(member: Trait, target: Trait | null, trait: R): void;
    traitWillRemoveTrait?(member: Trait, trait: R): void;
    traitDidRemoveTrait?(member: Trait, trait: R): void;
    traitWillMount?(trait: R): void;
    traitDidMount?(trait: R): void;
    traitWillUnmount?(trait: R): void;
    traitDidUnmount?(trait: R): void;
    traitWillMutate?(modelContext: TraitContextType<R>, trait: R): void;
    traitDidMutate?(modelContext: TraitContextType<R>, trait: R): void;
    traitWillAggregate?(modelContext: TraitContextType<R>, trait: R): void;
    traitDidAggregate?(modelContext: TraitContextType<R>, trait: R): void;
    traitWillCorrelate?(modelContext: TraitContextType<R>, trait: R): void;
    traitDidCorrelate?(modelContext: TraitContextType<R>, trait: R): void;
    traitWillValidate?(modelContext: TraitContextType<R>, trait: R): void;
    traitDidValidate?(modelContext: TraitContextType<R>, trait: R): void;
    traitWillReconcile?(modelContext: TraitContextType<R>, trait: R): void;
    traitDidReconcile?(modelContext: TraitContextType<R>, trait: R): void;
    traitWillStartConsuming?(trait: R): void;
    traitDidStartConsuming?(trait: R): void;
    traitWillStopConsuming?(trait: R): void;
    traitDidStopConsuming?(trait: R): void;
}

/** @public */
export declare interface TraitRef<O = unknown, T extends Trait = Trait> extends TraitRelation<O, T> {
    (): T | null;
    (trait: AnyTrait<T> | null, target?: Trait | null, key?: string): O;
    /** @override */
    get fastenerType(): Proto<TraitRef<any, any>>;
    /** @protected @override */
    onInherit(superFastener: Fastener): void;
    readonly trait: T | null;
    getTrait(): T;
    setTrait(trait: AnyTrait<T> | null, target?: Trait | null, key?: string): T | null;
    attachTrait(trait?: AnyTrait<T>, target?: Trait | null): T;
    detachTrait(): T | null;
    insertTrait(model?: Model | null, trait?: AnyTrait<T>, target?: Trait | null, key?: string): T;
    removeTrait(): T | null;
    deleteTrait(): T | null;
    /** @internal @override */
    bindModel(model: Model, target: Model | null): void;
    /** @internal @override */
    unbindModel(model: Model): void;
    /** @override */
    detectModel(model: Model): T | null;
    /** @internal @override */
    bindTrait(trait: Trait, target: Trait | null): void;
    /** @internal @override */
    unbindTrait(trait: Trait): void;
    /** @override */
    detectTrait(trait: Trait): T | null;
    /** @internal */
    get key(): string | undefined;
}

/** @public */
export declare const TraitRef: TraitRefFactory<TraitRef<any, any>>;

/** @public */
export declare interface TraitRefClass<F extends TraitRef<any, any> = TraitRef<any, any>> extends TraitRelationClass<F> {
}

/** @public */
export declare type TraitRefDescriptor<O = unknown, T extends Trait = Trait, I = {}> = ThisType<TraitRef<O, T> & I> & TraitRefInit<T> & Partial<I>;

/** @public */
export declare interface TraitRefFactory<F extends TraitRef<any, any> = TraitRef<any, any>> extends TraitRefClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): TraitRefFactory<F> & I;
    define<O, T extends Trait = Trait>(className: string, descriptor: TraitRefDescriptor<O, T>): TraitRefFactory<TraitRef<any, T>>;
    define<O, T extends Trait = Trait>(className: string, descriptor: {
        observes: boolean;
    } & TraitRefDescriptor<O, T, ObserverType<T>>): TraitRefFactory<TraitRef<any, T>>;
    define<O, T extends Trait = Trait, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & TraitRefDescriptor<O, T, I>): TraitRefFactory<TraitRef<any, T> & I>;
    define<O, T extends Trait = Trait, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & TraitRefDescriptor<O, T, I & ObserverType<T>>): TraitRefFactory<TraitRef<any, T> & I>;
    <O, T extends Trait = Trait>(descriptor: TraitRefDescriptor<O, T>): PropertyDecorator;
    <O, T extends Trait = Trait>(descriptor: {
        observes: boolean;
    } & TraitRefDescriptor<O, T, ObserverType<T>>): PropertyDecorator;
    <O, T extends Trait = Trait, I = {}>(descriptor: {
        implements: unknown;
    } & TraitRefDescriptor<O, T, I>): PropertyDecorator;
    <O, T extends Trait = Trait, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & TraitRefDescriptor<O, T, I & ObserverType<T>>): PropertyDecorator;
}

/** @public */
export declare interface TraitRefInit<T extends Trait = Trait> extends TraitRelationInit<T> {
    extends?: {
        prototype: TraitRef<any, any>;
    } | string | boolean | null;
    key?: string | boolean;
}

/** @internal */
export declare type TraitRefType<F extends TraitRef<any, any>> = F extends TraitRef<any, infer T> ? T : never;

/** @public */
export declare interface TraitRelation<O = unknown, T extends Trait = Trait> extends Fastener<O> {
    /** @override */
    get fastenerType(): Proto<TraitRelation<any, any>>;
    /** @protected */
    initTrait(trait: T): void;
    /** @protected */
    willAttachTrait(trait: T, target: Trait | null): void;
    /** @protected */
    onAttachTrait(trait: T, target: Trait | null): void;
    /** @protected */
    didAttachTrait(trait: T, target: Trait | null): void;
    /** @protected */
    deinitTrait(trait: T): void;
    /** @protected */
    willDetachTrait(trait: T): void;
    /** @protected */
    onDetachTrait(trait: T): void;
    /** @protected */
    didDetachTrait(trait: T): void;
    /** @internal @protected */
    get parentModel(): Model | null;
    /** @internal @protected */
    insertChild(model: Model, trait: T, target: Trait | null, key: string | undefined): void;
    /** @internal */
    bindModel(model: Model, targetModel: Model | null): void;
    /** @internal */
    unbindModel(model: Model): void;
    detectModel(model: Model): T | null;
    /** @internal */
    bindTrait(trait: Trait, target: Trait | null): void;
    /** @internal */
    unbindTrait(trait: Trait): void;
    detectTrait(trait: Trait): T | null;
    createTrait(): T;
    /** @internal @protected */
    fromAny(value: AnyTrait<T>): T;
    /** @internal @protected */
    get type(): TraitFactory<T> | undefined;
    /** @internal @protected */
    get binds(): boolean | undefined;
    /** @internal @protected */
    get observes(): boolean | undefined;
    /** @internal @override */
    get lazy(): boolean;
    /** @internal @override */
    get static(): string | boolean;
}

/** @public */
export declare const TraitRelation: TraitRelationFactory<TraitRelation<any, any>>;

/** @public */
export declare interface TraitRelationClass<F extends TraitRelation<any, any> = TraitRelation<any, any>> extends FastenerClass<F> {
}

/** @public */
export declare type TraitRelationDescriptor<O = unknown, T extends Trait = Trait, I = {}> = ThisType<TraitRelation<O, T> & I> & TraitRelationInit<T> & Partial<I>;

/** @public */
export declare interface TraitRelationFactory<F extends TraitRelation<any, any> = TraitRelation<any, any>> extends TraitRelationClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): TraitRelationFactory<F> & I;
    define<O, T extends Trait = Trait>(className: string, descriptor: TraitRelationDescriptor<O, T>): TraitRelationFactory<TraitRelation<any, T>>;
    define<O, T extends Trait = Trait>(className: string, descriptor: {
        observes: boolean;
    } & TraitRelationDescriptor<O, T, ObserverType<T>>): TraitRelationFactory<TraitRelation<any, T>>;
    define<O, T extends Trait = Trait, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & TraitRelationDescriptor<O, T, I>): TraitRelationFactory<TraitRelation<any, T> & I>;
    define<O, T extends Trait = Trait, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & TraitRelationDescriptor<O, T, I & ObserverType<T>>): TraitRelationFactory<TraitRelation<any, T> & I>;
    <O, T extends Trait = Trait>(descriptor: TraitRelationDescriptor<O, T>): PropertyDecorator;
    <O, T extends Trait = Trait>(descriptor: {
        observes: boolean;
    } & TraitRelationDescriptor<O, T, ObserverType<T>>): PropertyDecorator;
    <O, T extends Trait = Trait, I = {}>(descriptor: {
        implements: unknown;
    } & TraitRelationDescriptor<O, T, I>): PropertyDecorator;
    <O, T extends Trait = Trait, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & TraitRelationDescriptor<O, T, I & ObserverType<T>>): PropertyDecorator;
}

/** @public */
export declare interface TraitRelationInit<T extends Trait = Trait> extends FastenerInit {
    extends?: {
        prototype: TraitRelation<any, any>;
    } | string | boolean | null;
    type?: TraitFactory<T>;
    binds?: boolean;
    observes?: boolean;
    initTrait?(trait: T): void;
    willAttachTrait?(trait: T, target: Trait | null): void;
    didAttachTrait?(trait: T, target: Trait | null): void;
    deinitTrait?(trait: T): void;
    willDetachTrait?(trait: T): void;
    didDetachTrait?(trait: T): void;
    parentModel?: Model | null;
    insertChild?(model: Model, trait: T, target: Trait | null, key: string | undefined): void;
    detectModel?(model: Model): T | null;
    detectTrait?(trait: Trait): T | null;
    createTrait?(): T;
    fromAny?(value: AnyTrait<T>): T;
}

/** @internal */
export declare type TraitRelationType<F extends TraitRelation<any, any>> = F extends TraitRelation<any, infer T> ? T : never;

/** @public */
export declare interface TraitSet<O = unknown, T extends Trait = Trait> extends TraitRelation<O, T> {
    (trait: AnyTrait<T>): O;
    /** @override */
    get fastenerType(): Proto<TraitSet<any, any>>;
    /** @internal */
    readonly traits: {
        readonly [traitId: number]: T | undefined;
    };
    readonly traitCount: number;
    hasTrait(trait: Trait): boolean;
    addTrait(trait?: AnyTrait<T>, target?: Trait | null, key?: string): T;
    attachTrait(trait?: AnyTrait<T>, target?: Trait | null): T;
    detachTrait(trait: T): T | null;
    insertTrait(model?: Model | null, trait?: AnyTrait<T>, target?: Trait | null, key?: string): T;
    removeTrait(trait: T): T | null;
    deleteTrait(trait: T): T | null;
    /** @internal @override */
    bindModel(model: Model, target: Model | null): void;
    /** @internal @override */
    unbindModel(model: Model): void;
    /** @override */
    detectModel(model: Model): T | null;
    /** @internal @override */
    bindTrait(trait: Trait, target: Trait | null): void;
    /** @internal @override */
    unbindTrait(trait: Trait): void;
    /** @override */
    detectTrait(trait: Trait): T | null;
    /** @internal @protected */
    key(trait: T): string | undefined;
    get sorted(): boolean;
    /** @internal */
    initSorted(sorted: boolean): void;
    sort(sorted?: boolean): this;
    /** @protected */
    willSort(parent: Model | null): void;
    /** @protected */
    onSort(parent: Model | null): void;
    /** @protected */
    didSort(parent: Model | null): void;
    /** @internal @protected */
    sortChildren(parent: Model): void;
    /** @internal */
    compareChildren(a: Trait, b: Trait): number;
    /** @internal @protected */
    compare(a: T, b: T): number;
}

/** @public */
export declare const TraitSet: TraitSetFactory<TraitSet<any, any>>;

/** @public */
export declare interface TraitSetClass<F extends TraitSet<any, any> = TraitSet<any, any>> extends TraitRelationClass<F> {
    /** @internal */
    readonly SortedFlag: FastenerFlags;
    /** @internal @override */
    readonly FlagShift: number;
    /** @internal @override */
    readonly FlagMask: FastenerFlags;
}

/** @public */
export declare type TraitSetDescriptor<O = unknown, T extends Trait = Trait, I = {}> = ThisType<TraitSet<O, T> & I> & TraitSetInit<T> & Partial<I>;

/** @public */
export declare interface TraitSetFactory<F extends TraitSet<any, any> = TraitSet<any, any>> extends TraitSetClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): TraitSetFactory<F> & I;
    define<O, T extends Trait = Trait>(className: string, descriptor: TraitSetDescriptor<O, T>): TraitSetFactory<TraitSet<any, T>>;
    define<O, T extends Trait = Trait>(className: string, descriptor: {
        observes: boolean;
    } & TraitSetDescriptor<O, T, ObserverType<T>>): TraitSetFactory<TraitSet<any, T>>;
    define<O, T extends Trait = Trait, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & TraitSetDescriptor<O, T, I>): TraitSetFactory<TraitSet<any, T> & I>;
    define<O, T extends Trait = Trait, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & TraitSetDescriptor<O, T, I & ObserverType<T>>): TraitSetFactory<TraitSet<any, T> & I>;
    <O, T extends Trait = Trait>(descriptor: TraitSetDescriptor<O, T>): PropertyDecorator;
    <O, T extends Trait = Trait>(descriptor: {
        observes: boolean;
    } & TraitSetDescriptor<O, T, ObserverType<T>>): PropertyDecorator;
    <O, T extends Trait = Trait, I = {}>(descriptor: {
        implements: unknown;
    } & TraitSetDescriptor<O, T, I>): PropertyDecorator;
    <O, T extends Trait = Trait, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & TraitSetDescriptor<O, T, I & ObserverType<T>>): PropertyDecorator;
}

/** @public */
export declare interface TraitSetInit<T extends Trait = Trait> extends TraitRelationInit<T> {
    extends?: {
        prototype: TraitSet<any, any>;
    } | string | boolean | null;
    key?(trait: T): string | undefined;
    compare?(a: T, b: T): number;
    sorted?: boolean;
    willSort?(parent: Model | null): void;
    didSort?(parent: Model | null): void;
    sortChildren?(parent: Model): void;
    compareChildren?(a: Trait, b: Trait): number;
}

/** @internal */
export declare type TraitSetType<F extends TraitSet<any, any>> = F extends TraitSet<any, infer T> ? T : never;

/** @public */
export declare interface TraitViewControllerRef<O = unknown, T extends Trait = Trait, V extends View = View, C extends Controller = Controller> extends ControllerRef<O, C> {
    /** @override */
    get fastenerType(): Proto<TraitViewControllerRef<any, any, any, any>>;
    /** @internal */
    getTraitViewRef(controller: C): TraitViewRef<unknown, T, V>;
    get trait(): T | null;
    setTrait(trait: T | null, targetTrait?: Trait | null, key?: string): C | null;
    removeTrait(trait: T | null): C | null;
    deleteTrait(trait: T | null): C | null;
    get view(): V | null;
    createController(trait?: T): C;
    /** @internal @protected */
    get parentView(): View | null;
}

/** @public */
export declare const TraitViewControllerRef: TraitViewControllerRefFactory<TraitViewControllerRef<any, any, any, any>>;

/** @public */
export declare interface TraitViewControllerRefClass<F extends TraitViewControllerRef<any, any, any, any> = TraitViewControllerRef<any, any, any, any>> extends ControllerRefClass<F> {
}

/** @public */
export declare type TraitViewControllerRefDescriptor<O = unknown, T extends Trait = Trait, V extends View = View, C extends Controller = Controller, I = {}> = ThisType<TraitViewControllerRef<O, T, V, C> & I> & TraitViewControllerRefInit<T, V, C> & Partial<I>;

/** @public */
export declare interface TraitViewControllerRefFactory<F extends TraitViewControllerRef<any, any, any, any> = TraitViewControllerRef<any, any, any, any>> extends TraitViewControllerRefClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): TraitViewControllerRefFactory<F> & I;
    define<O, T extends Trait = Trait, V extends View = View, C extends Controller = Controller>(className: string, descriptor: TraitViewControllerRefDescriptor<O, T, V, C>): TraitViewControllerRefFactory<TraitViewControllerRef<any, T, V, C>>;
    define<O, T extends Trait = Trait, V extends View = View, C extends Controller = Controller>(className: string, descriptor: {
        observes: boolean;
    } & TraitViewControllerRefDescriptor<O, T, V, C, ObserverType<C>>): TraitViewControllerRefFactory<TraitViewControllerRef<any, T, V, C>>;
    define<O, T extends Trait = Trait, V extends View = View, C extends Controller = Controller, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & TraitViewControllerRefDescriptor<O, T, V, C, I>): TraitViewControllerRefFactory<TraitViewControllerRef<any, T, V, C> & I>;
    define<O, T extends Trait = Trait, V extends View = View, C extends Controller = Controller, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & TraitViewControllerRefDescriptor<O, T, V, C, I & ObserverType<C>>): TraitViewControllerRefFactory<TraitViewControllerRef<any, T, V, C> & I>;
    <O, T extends Trait = Trait, V extends View = View, C extends Controller = Controller>(descriptor: TraitViewControllerRefDescriptor<O, T, V, C>): PropertyDecorator;
    <O, T extends Trait = Trait, V extends View = View, C extends Controller = Controller>(descriptor: {
        observes: boolean;
    } & TraitViewControllerRefDescriptor<O, T, V, C, ObserverType<C>>): PropertyDecorator;
    <O, T extends Trait = Trait, V extends View = View, C extends Controller = Controller, I = {}>(descriptor: {
        implements: unknown;
    } & TraitViewControllerRefDescriptor<O, T, V, C, I>): PropertyDecorator;
    <O, T extends Trait = Trait, V extends View = View, C extends Controller = Controller, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & TraitViewControllerRefDescriptor<O, T, V, C, I & ObserverType<C>>): PropertyDecorator;
}

/** @public */
export declare interface TraitViewControllerRefInit<T extends Trait, V extends View, C extends Controller = Controller> extends ControllerRefInit<C> {
    extends?: {
        prototype: TraitViewControllerRef<any, any, any, any>;
    } | string | boolean | null;
    getTraitViewRef?(controller: C): TraitViewRef<any, T, V>;
    createController?(trait?: T): C;
    parentView?: View | null;
}

/** @internal */
export declare type TraitViewControllerRefType<F extends TraitViewControllerRef<any, any, any, any>> = F extends TraitViewControllerRef<any, any, any, infer C> ? C : never;

/** @public */
export declare interface TraitViewControllerSet<O = unknown, T extends Trait = Trait, V extends View = View, C extends Controller = Controller> extends ControllerSet<O, C> {
    /** @internal */
    readonly traitControllers: {
        readonly [traitId: number]: C | undefined;
    };
    /** @internal */
    getTraitViewRef(controller: C): TraitViewRef<unknown, T, V>;
    hasTraitController(trait: Trait): boolean;
    addTraitController(trait: T, targetTrait?: Trait | null, key?: string): C;
    removeTraitController(trait: T): C | null;
    deleteTraitController(trait: T): C | null;
    attachControllerTrait(controller: C, trait: T, targetTrait?: Trait | null): C;
    /** @protected */
    initControllerTrait(controller: C, trait: T): void;
    /** @protected */
    willAttachControllerTrait(controller: C, trait: T, targetTrait: Trait | null): void;
    /** @protected */
    onAttachControllerTrait(controller: C, trait: T, targetTrait: Trait | null): void;
    /** @protected */
    didAttachControllerTrait(controller: C, trait: T, targetTrait: Trait | null): void;
    detachControllerTrait(controller: C, trait: T): C | null;
    /** @protected */
    deinitControllerTrait(controller: C, trait: T): void;
    /** @protected */
    willDetachControllerTrait(controller: C, trait: T): void;
    /** @protected */
    onDetachControllerTrait(controller: C, trait: T): void;
    /** @protected */
    didDetachControllerTrait(controller: C, trait: T): void;
    /** @protected @override */
    onAttachController(controller: C, targetController: Controller | null): void;
    /** @protected @override */
    onDetachController(controller: C): void;
    createController(trait?: T): C;
    /** @internal @protected */
    get parentView(): View | null;
}

/** @public */
export declare const TraitViewControllerSet: TraitViewControllerSetFactory<TraitViewControllerSet<any, any, any, any>>;

/** @public */
export declare interface TraitViewControllerSetClass<F extends TraitViewControllerSet<any, any, any, any> = TraitViewControllerSet<any, any, any, any>> extends ControllerSetClass<F> {
}

/** @public */
export declare type TraitViewControllerSetDescriptor<O = unknown, T extends Trait = Trait, V extends View = View, C extends Controller = Controller, I = {}> = ThisType<TraitViewControllerSet<O, T, V, C> & I> & TraitViewControllerSetInit<T, V, C> & Partial<I>;

/** @public */
export declare interface TraitViewControllerSetFactory<F extends TraitViewControllerSet<any, any, any, any> = TraitViewControllerSet<any, any, any, any>> extends TraitViewControllerSetClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): TraitViewControllerSetFactory<F> & I;
    define<O, T extends Trait = Trait, V extends View = View, C extends Controller = Controller>(className: string, descriptor: TraitViewControllerSetDescriptor<O, T, V, C>): TraitViewControllerSetFactory<TraitViewControllerSet<any, T, V, C>>;
    define<O, T extends Trait = Trait, V extends View = View, C extends Controller = Controller>(className: string, descriptor: {
        observes: boolean;
    } & TraitViewControllerSetDescriptor<O, T, V, C, ObserverType<C>>): TraitViewControllerSetFactory<TraitViewControllerSet<any, T, V, C>>;
    define<O, T extends Trait = Trait, V extends View = View, C extends Controller = Controller, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & TraitViewControllerSetDescriptor<O, T, V, C, I>): TraitViewControllerSetFactory<TraitViewControllerSet<any, T, V, C> & I>;
    define<O, T extends Trait = Trait, V extends View = View, C extends Controller = Controller, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & TraitViewControllerSetDescriptor<O, T, V, C, I & ObserverType<C>>): TraitViewControllerSetFactory<TraitViewControllerSet<any, T, V, C> & I>;
    <O, T extends Trait = Trait, V extends View = View, C extends Controller = Controller>(descriptor: TraitViewControllerSetDescriptor<O, T, V, C>): PropertyDecorator;
    <O, T extends Trait = Trait, V extends View = View, C extends Controller = Controller>(descriptor: {
        observes: boolean;
    } & TraitViewControllerSetDescriptor<O, T, V, C, ObserverType<C>>): PropertyDecorator;
    <O, T extends Trait = Trait, V extends View = View, C extends Controller = Controller, I = {}>(descriptor: {
        implements: unknown;
    } & TraitViewControllerSetDescriptor<O, T, V, C, I>): PropertyDecorator;
    <O, T extends Trait = Trait, V extends View = View, C extends Controller = Controller, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & TraitViewControllerSetDescriptor<O, T, V, C, I & ObserverType<C>>): PropertyDecorator;
}

/** @public */
export declare interface TraitViewControllerSetInit<T extends Trait = Trait, V extends View = View, C extends Controller = Controller> extends ControllerSetInit<C> {
    extends?: {
        prototype: TraitViewControllerSet<any, any, any, any>;
    } | string | boolean | null;
    getTraitViewRef?(controller: C): TraitViewRef<any, T, V>;
    willAttachControllerTrait?(controller: C, trait: T, targetTrait: Trait | null): void;
    didAttachControllerTrait?(controller: C, trait: T, targetTrait: Trait | null): void;
    willDetachControllerTrait?(controller: C, trait: T): void;
    didDetachControllerTrait?(controller: C, trait: T): void;
    createController?(trait?: T): C;
    parentView?: View | null;
}

/** @internal */
export declare type TraitViewControllerSetType<F extends TraitViewControllerSet<any, any, any, any>> = F extends TraitViewControllerSet<any, any, any, infer C> ? C : never;

/** @public */
export declare interface TraitViewRef<O = unknown, T extends Trait = Trait, V extends View = View> extends Fastener<O> {
    /** @override */
    get fastenerType(): Proto<TraitViewRef<any, any, any>>;
    /** @protected @override */
    onInherit(superFastener: Fastener): void;
    readonly trait: T | null;
    getTrait(): T;
    setTrait(trait: AnyTrait<T> | null, target?: Trait | null, key?: string): T | null;
    attachTrait<T2 extends T>(trait: T2 | TraitFactory<T2>, target?: Trait | null): T2;
    attachTrait(trait: AnyTrait<T>, target?: Trait | null): T;
    attachTrait(trait?: AnyTrait<T> | null, target?: Trait | null): T | null;
    detachTrait(): T | null;
    /** @protected */
    initTrait(trait: T): void;
    /** @protected */
    willAttachTrait(trait: T, target: Trait | null): void;
    /** @protected */
    onAttachTrait(trait: T, target: Trait | null): void;
    /** @protected */
    didAttachTrait(trait: T, target: Trait | null): void;
    /** @protected */
    deinitTrait(trait: T): void;
    /** @protected */
    willDetachTrait(trait: T): void;
    /** @protected */
    onDetachTrait(trait: T): void;
    /** @protected */
    didDetachTrait(trait: T): void;
    insertTrait(model?: Model | null, trait?: AnyTrait<T> | null, target?: Trait | null, key?: string): T | null;
    removeTrait(): T | null;
    deleteTrait(): T | null;
    /** @internal @protected */
    get parentModel(): Model | null;
    /** @internal @protected */
    insertChildTrait(model: Model, trait: T, target: Trait | null, key: string | undefined): void;
    /** @internal @override */
    bindModel(model: Model, targetModel: Model | null): void;
    /** @internal @override */
    unbindModel(model: Model): void;
    /** @override */
    detectModel(model: Model): T | null;
    /** @internal */
    bindTrait(trait: Trait, target: Trait | null): void;
    /** @internal */
    unbindTrait(trait: Trait): void;
    detectTrait(trait: Trait): T | null;
    createTrait(): T;
    /** @internal @protected */
    fromAnyTrait(value: AnyTrait<T>): T;
    /** @internal */
    get traitKey(): string | undefined;
    /** @internal @protected */
    get traitType(): TraitFactory<T> | undefined;
    /** @internal @protected */
    get bindsTrait(): boolean | undefined;
    /** @internal @protected */
    get observesTrait(): boolean | undefined;
    readonly view: V | null;
    getView(): V;
    setView(view: AnyView<V> | null, target?: View | null, key?: string): V | null;
    attachView<V2 extends V>(view: V2 | ViewFactory<V2>, target?: View | null): V2;
    attachView(view: AnyView<V>, target?: View | null): V;
    attachView(view?: AnyView<V> | null, target?: View | null): V | null;
    detachView(): V | null;
    /** @protected */
    initView(view: V): void;
    /** @protected */
    willAttachView(view: V, target: View | null): void;
    /** @protected */
    onAttachView(view: V, target: View | null): void;
    /** @protected */
    didAttachView(view: V, target: View | null): void;
    /** @protected */
    deinitView(view: V): void;
    /** @protected */
    willDetachView(view: V): void;
    /** @protected */
    onDetachView(view: V): void;
    /** @protected */
    didDetachView(view: V): void;
    insertView(parent?: View | null, view?: AnyView<V> | null, target?: View | null, key?: string): V | null;
    removeView(): V | null;
    deleteView(): V | null;
    /** @internal @protected */
    get parentView(): View | null;
    /** @internal @protected */
    insertChildView(parent: View, child: V, target: View | null, key: string | undefined): void;
    /** @internal */
    bindView(view: View, target: View | null): void;
    /** @internal */
    unbindView(view: View): void;
    detectView(view: View): V | null;
    createView(): V;
    /** @internal @protected */
    fromAnyView(value: AnyView<V>): V;
    /** @internal */
    get viewKey(): string | undefined;
    /** @internal @protected */
    get viewType(): ViewFactory<V> | undefined;
    /** @internal @protected */
    get bindsView(): boolean | undefined;
    /** @internal @protected */
    get observesView(): boolean | undefined;
    /** @internal @override */
    get lazy(): boolean;
    /** @internal @override */
    get static(): string | boolean;
}

/** @public */
export declare const TraitViewRef: TraitViewRefFactory<TraitViewRef<any, any, any>>;

/** @public */
export declare interface TraitViewRefClass<F extends TraitViewRef<any, any, any> = TraitViewRef<any, any, any>> extends FastenerClass<F> {
}

/** @public */
export declare type TraitViewRefDescriptor<O = unknown, T extends Trait = Trait, V extends View = View, I = {}> = ThisType<TraitViewRef<O, T, V> & I> & TraitViewRefInit<T, V> & Partial<I>;

/** @public */
export declare interface TraitViewRefFactory<F extends TraitViewRef<any, any, any> = TraitViewRef<any, any, any>> extends TraitViewRefClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): TraitViewRefFactory<F> & I;
    define<O, T extends Trait = Trait, V extends View = View>(className: string, descriptor: TraitViewRefDescriptor<O, T, V>): TraitViewRefFactory<TraitViewRef<any, T, V>>;
    define<O, T extends Trait = Trait, V extends View = View>(className: string, descriptor: {
        observesTrait: boolean;
    } & TraitViewRefDescriptor<O, T, V, ObserverType<T>>): TraitViewRefFactory<TraitViewRef<any, T, V>>;
    define<O, T extends Trait = Trait, V extends View = View>(className: string, descriptor: {
        observesView: boolean;
    } & TraitViewRefDescriptor<O, T, V, ObserverType<V>>): TraitViewRefFactory<TraitViewRef<any, T, V>>;
    define<O, T extends Trait = Trait, V extends View = View>(className: string, descriptor: {
        observesTrait: boolean;
        observesView: boolean;
    } & TraitViewRefDescriptor<O, T, V, ObserverType<T> & ObserverType<V>>): TraitViewRefFactory<TraitViewRef<any, T, V>>;
    define<O, T extends Trait = Trait, V extends View = View, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & TraitViewRefDescriptor<O, T, V, I>): TraitViewRefFactory<TraitViewRef<any, T, V> & I>;
    define<O, T extends Trait = Trait, V extends View = View, I = {}>(className: string, descriptor: {
        implements: unknown;
        observesTrait: boolean;
    } & TraitViewRefDescriptor<O, T, V, I & ObserverType<T>>): TraitViewRefFactory<TraitViewRef<any, T, V> & I>;
    define<O, T extends Trait = Trait, V extends View = View, I = {}>(className: string, descriptor: {
        implements: unknown;
        observesView: boolean;
    } & TraitViewRefDescriptor<O, T, V, I & ObserverType<V>>): TraitViewRefFactory<TraitViewRef<any, T, V> & I>;
    define<O, T extends Trait = Trait, V extends View = View, I = {}>(className: string, descriptor: {
        implements: unknown;
        observesTrait: boolean;
        observesView: boolean;
    } & TraitViewRefDescriptor<O, T, V, I & ObserverType<T> & ObserverType<V>>): TraitViewRefFactory<TraitViewRef<any, T, V> & I>;
    <O, T extends Trait = Trait, V extends View = View>(descriptor: TraitViewRefDescriptor<O, T, V>): PropertyDecorator;
    <O, T extends Trait = Trait, V extends View = View>(descriptor: {
        observesTrait: boolean;
    } & TraitViewRefDescriptor<O, T, V, ObserverType<T>>): PropertyDecorator;
    <O, T extends Trait = Trait, V extends View = View>(descriptor: {
        observesView: boolean;
    } & TraitViewRefDescriptor<O, T, V, ObserverType<V>>): PropertyDecorator;
    <O, T extends Trait = Trait, V extends View = View>(descriptor: {
        observesTrait: boolean;
        observesView: boolean;
    } & TraitViewRefDescriptor<O, T, V, ObserverType<T> & ObserverType<V>>): PropertyDecorator;
    <O, T extends Trait = Trait, V extends View = View, I = {}>(descriptor: {
        implements: unknown;
    } & TraitViewRefDescriptor<O, T, V, I>): PropertyDecorator;
    <O, T extends Trait = Trait, V extends View = View, I = {}>(descriptor: {
        implements: unknown;
        observesTrait: boolean;
    } & TraitViewRefDescriptor<O, T, V, I & ObserverType<T>>): PropertyDecorator;
    <O, T extends Trait = Trait, V extends View = View, I = {}>(descriptor: {
        implements: unknown;
        observesView: boolean;
    } & TraitViewRefDescriptor<O, T, V, I & ObserverType<V>>): PropertyDecorator;
    <O, T extends Trait = Trait, V extends View = View, I = {}>(descriptor: {
        implements: unknown;
        observesTrait: boolean;
        observesView: boolean;
    } & TraitViewRefDescriptor<O, T, V, I & ObserverType<T> & ObserverType<V>>): PropertyDecorator;
}

/** @public */
export declare interface TraitViewRefInit<T extends Trait = Trait, V extends View = View> extends FastenerInit {
    extends?: {
        prototype: TraitViewRef<any, any, any>;
    } | string | boolean | null;
    traitKey?: string | boolean;
    traitType?: TraitFactory<T>;
    bindsTrait?: boolean;
    observesTrait?: boolean;
    initTrait?(trait: T): void;
    willAttachTrait?(trait: T, target: Trait | null): void;
    didAttachTrait?(trait: T, target: Trait | null): void;
    deinitTrait?(trait: T): void;
    willDetachTrait?(trait: T): void;
    didDetachTrait?(trait: T): void;
    parentModel?: Model | null;
    insertChildTrait?(model: Model, trait: T, target: Trait | null, key: string | undefined): void;
    detectTrait?(trait: Trait): T | null;
    createTrait?(): T;
    fromAnyTrait?(value: AnyTrait<T>): T;
    viewKey?: string | boolean;
    viewType?: ViewFactory<V>;
    bindsView?: boolean;
    observesView?: boolean;
    initView?(view: V): void;
    willAttachView?(view: V, target: View | null): void;
    didAttachView?(view: V, target: View | null): void;
    deinitView?(view: V): void;
    willDetachView?(view: V): void;
    didDetachView?(view: V): void;
    parentView?: View | null;
    insertChildView?(parent: View, child: V, target: View | null, key: string | undefined): void;
    detectView?(view: View): V | null;
    createView?(): V;
    fromAnyView?(value: AnyView<V>): V;
}

/** @internal */
export declare type TraitViewRefTraitType<F extends TraitViewRef<any, any, any>> = F extends TraitViewRef<any, infer T, any> ? T : never;

/** @internal */
export declare type TraitViewRefViewType<F extends TraitViewRef<any, any, any>> = F extends TraitViewRef<any, any, infer V> ? V : never;

/** @internal */
export declare const TransformAttributeAnimator: AttributeAnimatorFactory<AttributeAnimator<any, Transform | null, AnyTransform | null>>;

/** @internal */
export declare const TransformStyleAnimator: StyleAnimatorFactory<StyleAnimator<any, Transform | null, AnyTransform | null>>;

/** @internal */
export declare const TransformThemeAnimator: ThemeAnimatorFactory<ThemeAnimator<any, Transform | null | undefined, AnyTransform | null | undefined>>;

/** @public */
export declare interface TypesetView extends GraphicsView {
    readonly font: ThemeAnimator<this, Font | null, AnyFont | null>;
    readonly textAlign: ThemeAnimator<this, CanvasTextAlign | undefined>;
    readonly textBaseline: ThemeAnimator<this, CanvasTextBaseline | undefined>;
    readonly textOrigin: ThemeAnimator<this, R2Point | null, AnyR2Point | null>;
    readonly textColor: ThemeAnimator<this, Color | null, AnyColor | null>;
}

/** @public */
export declare const TypesetView: {
    init(view: TypesetView, init: TypesetViewInit): void;
    is(object: unknown): object is TypesetView;
};

/** @public */
export declare interface TypesetViewInit extends GraphicsViewInit {
    font?: AnyFont;
    textAlign?: CanvasTextAlign;
    textBaseline?: CanvasTextBaseline;
    textOrigin?: AnyR2Point;
    textColor?: AnyColor;
}

/** @public */
export declare type UserSelect = "all" | "auto" | "contain" | "none" | "text";

/** @beta */
export declare abstract class ValueDownlinkTrait extends DownlinkTrait {
    protected downlinkDidSet(newValue: Value, oldValue: Value): void;
    readonly downlink: ValueDownlinkFastener<this, Value, AnyValue>;
}

/** @public */
export declare class VectorIcon extends FilledIcon implements Interpolate<VectorIcon>, Equals, Equivalent, Debug {
    constructor(path: R2Path, fillRule: PaintingFillRule, fillColor: Color | null, fillLook: Look<Color> | null, moodModifier: MoodMatrix | null);
    readonly path: R2Path;
    readonly fillRule: PaintingFillRule;
    withFillRule(fillRule: PaintingFillRule): VectorIcon;
    readonly fillColor: Color | null;
    withFillColor(fillColor: Color | null): VectorIcon;
    readonly fillLook: Look<Color> | null;
    withFillLook(fillLook: Look<Color> | null): VectorIcon;
    readonly moodModifier: MoodMatrix | null;
    withMoodModifier(moodModifier: MoodMatrix | null): VectorIcon;
    modifyMood(feel: Feel, updates: MoodVectorUpdates<Feel>): VectorIcon;
    isThemed(): boolean;
    withTheme(theme: ThemeMatrix, mood: MoodVector): VectorIcon;
    render(renderer: GraphicsRenderer, frame: R2Box): void;
    paint(context: PaintingContext, frame: R2Box): void;
    draw(context: DrawingContext, frame: R2Box): void;
    protected copy(path: R2Path, fillRule: PaintingFillRule, fillColor: Color | null, fillLook: Look<Color> | null, moodModifier: MoodMatrix | null): VectorIcon;
    interpolateTo(that: VectorIcon): Interpolator<VectorIcon>;
    interpolateTo(that: unknown): Interpolator<VectorIcon> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static create(width: number, height: number, path: AnyR2Path, fillRule?: PaintingFillRule): VectorIcon;
}

/** @internal */
export declare interface VectorIconInterpolator extends Interpolator<VectorIcon> {
    /** @internal */
    readonly path: R2Path;
    /** @internal */
    readonly fillRule: PaintingFillRule;
    /** @internal */
    readonly fillColorInterpolator: Interpolator<Color | null>;
    /** @internal */
    readonly fillLook: Look<Color> | null;
    /** @internal */
    readonly moodModifier: MoodMatrix | null;
    readonly 0: VectorIcon;
    readonly 1: VectorIcon;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const VectorIconInterpolator: {
    (i0: VectorIcon, i1: VectorIcon): VectorIconInterpolator;
    /** @internal */
    prototype: VectorIconInterpolator;
};

/** @public */
export declare type VerticalAlign = Length | "baseline" | "sub" | "super" | "text-top" | "text-bottom" | "middle" | "top" | "bottom";

/** @public */
export declare class View extends Component<View> implements Initable<ViewInit>, ConstraintScope, ConstraintContext, ThemeContext {
    constructor();
    get componentType(): Class<View>;
    readonly observerType?: Class<ViewObserver>;
    readonly contextType?: Class<ViewContext>;
    /** @internal */
    attachParent(parent: View, nextSibling: View | null): void;
    protected willAttachParent(parent: View): void;
    protected onAttachParent(parent: View): void;
    protected didAttachParent(parent: View): void;
    protected willDetachParent(parent: View): void;
    protected onDetachParent(parent: View): void;
    protected didDetachParent(parent: View): void;
    setChild<V extends View>(key: string, newChild: V): View | null;
    setChild<F extends ViewCreator<F>>(key: string, factory: F): View | null;
    setChild(key: string, newChild: AnyView | null): View | null;
    appendChild<V extends View>(child: V, key?: string): V;
    appendChild<F extends ViewCreator<F>>(factory: F, key?: string): InstanceType<F>;
    appendChild(child: AnyView, key?: string): View;
    prependChild<V extends View>(child: V, key?: string): V;
    prependChild<F extends ViewCreator<F>>(factory: F, key?: string): InstanceType<F>;
    prependChild(child: AnyView, key?: string): View;
    insertChild<V extends View>(child: V, target: View | null, key?: string): V;
    insertChild<F extends ViewCreator<F>>(factory: F, target: View | null, key?: string): InstanceType<F>;
    insertChild(child: AnyView, target: View | null, key?: string): View;
    replaceChild<V extends View>(newChild: View, oldChild: V): V;
    replaceChild<V extends View>(newChild: AnyView, oldChild: V): V;
    protected willInsertChild(child: View, target: View | null): void;
    protected onInsertChild(child: View, target: View | null): void;
    protected didInsertChild(child: View, target: View | null): void;
    /** @internal */
    cascadeInsert(updateFlags?: ViewFlags, viewContext?: ViewContext): void;
    protected willRemoveChild(child: View): void;
    protected onRemoveChild(child: View): void;
    protected didRemoveChild(child: View): void;
    /** @internal */
    mount(): void;
    protected willMount(): void;
    protected onMount(): void;
    protected didMount(): void;
    /** @internal */
    unmount(): void;
    protected willUnmount(): void;
    protected didUnmount(): void;
    get culled(): boolean;
    setCulled(culled: boolean): void;
    /** @internal */
    cascadeCull(): void;
    protected willCull(): void;
    protected onCull(): void;
    protected didCull(): void;
    /** @internal */
    protected cullChildren(): void;
    /** @internal */
    cascadeUncull(): void;
    get uncullFlags(): ViewFlags;
    protected willUncull(): void;
    protected onUncull(): void;
    protected didUncull(): void;
    /** @internal */
    protected uncullChildren(): void;
    /**
     * Returns `true` if this view is ineligible for rendering and hit testing,
     * and should be excluded from its parent's layout and hit bounds.
     */
    get hidden(): boolean;
    /**
     * Makes this view ineligible for rendering and hit testing, and excludes
     * this view from its parent's layout and hit bounds, when `hidden` is `true`.
     * Makes this view eligible for rendering and hit testing, and includes this
     * view in its parent's layout and hit bounds, when `hidden` is `false`.
     */
    setHidden(hidden: boolean): void;
    /** @internal */
    cascadeHide(): void;
    protected willHide(): void;
    protected onHide(): void;
    protected didHide(): void;
    /** @internal */
    protected hideChildren(): void;
    cascadeUnhide(): void;
    get unhideFlags(): ViewFlags;
    protected willUnhide(): void;
    protected onUnhide(): void;
    protected didUnhide(): void;
    /** @internal */
    protected unhideChildren(): void;
    get unbounded(): boolean;
    setUnbounded(unboundedFlag: boolean): void;
    protected willSetUnbounded(unboundedFlag: boolean): void;
    protected onSetUnbounded(unboundedFlag: boolean): void;
    protected didSetUnbounded(unboundedFlag: boolean): void;
    get intangible(): boolean;
    setIntangible(intangible: boolean): void;
    protected willSetIntangible(intangible: boolean): void;
    protected onSetIntangible(intangible: boolean): void;
    protected didSetIntangible(intangible: boolean): void;
    requireUpdate(updateFlags: ViewFlags, immediate?: boolean): void;
    protected needsUpdate(updateFlags: ViewFlags, immediate: boolean): ViewFlags;
    requestUpdate(target: View, updateFlags: ViewFlags, immediate: boolean): void;
    get updating(): boolean;
    get processing(): boolean;
    protected needsProcess(processFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    cascadeProcess(processFlags: ViewFlags, baseViewContext: ViewContext): void;
    protected willProcess(processFlags: ViewFlags, viewContext: ViewContextType<this>): void;
    protected onProcess(processFlags: ViewFlags, viewContext: ViewContextType<this>): void;
    protected didProcess(processFlags: ViewFlags, viewContext: ViewContextType<this>): void;
    protected willResize(viewContext: ViewContextType<this>): void;
    protected onResize(viewContext: ViewContextType<this>): void;
    protected didResize(viewContext: ViewContextType<this>): void;
    protected willScroll(viewContext: ViewContextType<this>): void;
    protected onScroll(viewContext: ViewContextType<this>): void;
    protected didScroll(viewContext: ViewContextType<this>): void;
    protected willChange(viewContext: ViewContextType<this>): void;
    protected onChange(viewContext: ViewContextType<this>): void;
    protected didChange(viewContext: ViewContextType<this>): void;
    protected willAnimate(viewContext: ViewContextType<this>): void;
    protected onAnimate(viewContext: ViewContextType<this>): void;
    protected didAnimate(viewContext: ViewContextType<this>): void;
    protected willProject(viewContext: ViewContextType<this>): void;
    protected onProject(viewContext: ViewContextType<this>): void;
    protected didProject(viewContext: ViewContextType<this>): void;
    protected processChildren(processFlags: ViewFlags, viewContext: ViewContextType<this>, processChild: (this: this, child: View, processFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    protected processChild(child: View, processFlags: ViewFlags, viewContext: ViewContextType<this>): void;
    get displaying(): boolean;
    protected needsDisplay(displayFlags: ViewFlags, viewContext: ViewContextType<this>): ViewFlags;
    cascadeDisplay(displayFlags: ViewFlags, baseViewContext: ViewContext): void;
    protected willDisplay(displayFlags: ViewFlags, viewContext: ViewContextType<this>): void;
    protected onDisplay(displayFlags: ViewFlags, viewContext: ViewContextType<this>): void;
    protected didDisplay(displayFlags: ViewFlags, viewContext: ViewContextType<this>): void;
    protected willLayout(viewContext: ViewContextType<this>): void;
    protected onLayout(viewContext: ViewContextType<this>): void;
    protected didLayout(viewContext: ViewContextType<this>): void;
    protected willRender(viewContext: ViewContextType<this>): void;
    protected onRender(viewContext: ViewContextType<this>): void;
    protected didRender(viewContext: ViewContextType<this>): void;
    protected willRasterize(viewContext: ViewContextType<this>): void;
    protected onRasterize(viewContext: ViewContextType<this>): void;
    protected didRasterize(viewContext: ViewContextType<this>): void;
    protected willComposite(viewContext: ViewContextType<this>): void;
    protected onComposite(viewContext: ViewContextType<this>): void;
    protected didComposite(viewContext: ViewContextType<this>): void;
    protected displayChildren(displayFlags: ViewFlags, viewContext: ViewContextType<this>, displayChild: (this: this, child: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>) => void): void;
    protected displayChild(child: View, displayFlags: ViewFlags, viewContext: ViewContextType<this>): void;
    readonly viewportProvider: ViewportProvider<this>;
    readonly displayProvider: DisplayProvider<this>;
    readonly layoutProvider: LayoutProvider<this>;
    readonly themeProvider: ThemeProvider<this>;
    readonly modalProvider: ModalProvider<this>;
    readonly mood: Property<this, MoodVector | null>;
    readonly theme: Property<this, ThemeMatrix | null>;
    /** @override */
    getLook<T>(look: Look<T, unknown>, mood?: MoodVector<Feel> | null): T | undefined;
    /** @override */
    getLookOr<T, E>(look: Look<T, unknown>, elseValue: E): T | E;
    /** @override */
    getLookOr<T, E>(look: Look<T, unknown>, mood: MoodVector<Feel> | null, elseValue: E): T | E;
    /** @internal */
    applyTheme(theme: ThemeMatrix, mood: MoodVector, timing?: AnyTiming | boolean): void;
    protected willApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    protected onApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    protected didApplyTheme(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    /** @internal */
    protected themeAnimators(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean): void;
    readonly moodModifier: Property<this, MoodMatrix | null>;
    readonly themeModifier: Property<this, MoodMatrix | null>;
    /** @internal */
    modifyMood(feel: Feel, updates: MoodVectorUpdates<Feel>, timing?: AnyTiming | boolean): void;
    /** @internal */
    modifyTheme(feel: Feel, updates: MoodVectorUpdates<Feel>, timing?: AnyTiming | boolean): void;
    /** @internal */
    protected changeMood(): void;
    /** @internal */
    protected changeTheme(): void;
    /** @internal */
    protected updateTheme(timing?: AnyTiming | boolean): void;
    /** @internal */
    protected mountTheme(): void;
    /** @internal */
    protected bindChildFastener(fastener: Fastener, child: View, target: View | null): void;
    /** @internal */
    protected unbindChildFastener(fastener: Fastener, child: View): void;
    /** @internal @override */
    decohereFastener(fastener: Fastener): void;
    /** @internal */
    recohereFasteners(t?: number): void;
    /** @internal */
    recohereAnimators(t: number): void;
    /** @override */
    constraint(lhs: AnyConstraintExpression, relation: ConstraintRelation, rhs?: AnyConstraintExpression, strength?: AnyConstraintStrength): Constraint;
    /** @internal */
    readonly constraints: ReadonlyArray<Constraint>;
    /** @override */
    hasConstraint(constraint: Constraint): boolean;
    /** @override */
    addConstraint(constraint: Constraint): void;
    /** @override */
    removeConstraint(constraint: Constraint): void;
    /** @internal @override */
    activateConstraint(constraint: Constraint): void;
    /** @internal @override */
    deactivateConstraint(constraint: Constraint): void;
    /** @override */
    constraintVariable(name: string, value?: number, strength?: AnyConstraintStrength): ConstraintProperty<unknown, number>;
    /** @internal */
    readonly constraintVariables: ReadonlyArray<ConstraintVariable>;
    /** @override */
    hasConstraintVariable(constraintVariable: ConstraintVariable): boolean;
    /** @override */
    addConstraintVariable(constraintVariable: ConstraintVariable): void;
    /** @override */
    removeConstraintVariable(constraintVariable: ConstraintVariable): void;
    /** @internal @override */
    activateConstraintVariable(constraintVariable: ConstraintVariable): void;
    /** @internal @override */
    deactivateConstraintVariable(constraintVariable: ConstraintVariable): void;
    /** @internal @override */
    setConstraintVariable(constraintVariable: ConstraintVariable, value: number): void;
    /** @internal */
    evaluateConstraintVariables(): void;
    /** @internal */
    protected activateLayout(): void;
    /** @internal */
    protected deactivateLayout(): void;
    /** @internal */
    setProperty(key: string, value: unknown, timing?: AnyTiming | boolean | null, affinity?: Affinity): void;
    setProperties(properties: MemberPropertyInitMap<this>, timingOrAffinity: Affinity | AnyTiming | boolean | null | undefined): void;
    setProperties(properties: MemberPropertyInitMap<this>, timing?: AnyTiming | boolean | null, affinity?: Affinity): void;
    /** @internal */
    get superViewContext(): ViewContext;
    /** @internal */
    extendViewContext(viewContext: ViewContext): ViewContextType<this>;
    get viewContext(): ViewContextType<this>;
    get viewportIdiom(): ViewportIdiom;
    get viewport(): Viewport;
    /**
     * Returns the transformation from the parent view coordinates to view
     * coordinates.
     */
    get parentTransform(): Transform;
    /**
     * Returns the transformation from page coordinates to view coordinates.
     */
    get pageTransform(): Transform;
    get pageBounds(): R2Box;
    /**
     * Returns the bounding box, in page coordinates, the edges to which attached
     * popovers should point.
     */
    get popoverFrame(): R2Box;
    /**
     * Returns the transformation from viewport coordinates to view coordinates.
     */
    get clientTransform(): Transform;
    get clientBounds(): R2Box;
    intersectsViewport(): boolean;
    dispatchEvent(event: Event): boolean;
    on(type: string, listener: EventListenerOrEventListenerObject, options?: AddEventListenerOptions | boolean): this;
    off(type: string, listener: EventListenerOrEventListenerObject, options?: EventListenerOptions | boolean): this;
    /** @internal */
    readonly observerCache: ViewObserverCache<this>;
    protected onObserve(observer: ObserverType<this>): void;
    protected onUnobserve(observer: ObserverType<this>): void;
    /** @override */
    init(init: ViewInit): void;
    static create<S extends new () => InstanceType<S>>(this: S): InstanceType<S>;
    static fromInit<S extends abstract new (...args: any) => InstanceType<S>>(this: S, init: InitType<InstanceType<S>>): InstanceType<S>;
    static fromAny<S extends abstract new (...args: any) => InstanceType<S>>(this: S, value: AnyView<InstanceType<S>>): InstanceType<S>;
    /** @internal */
    static uid: () => number;
    /** @internal */
    static readonly MountedFlag: ViewFlags;
    /** @internal */
    static readonly RemovingFlag: ViewFlags;
    /** @internal */
    static readonly ProcessingFlag: ViewFlags;
    /** @internal */
    static readonly DisplayingFlag: ViewFlags;
    /** @internal */
    static readonly ContextualFlag: ViewFlags;
    /** @internal */
    static readonly CullFlag: ViewFlags;
    /** @internal */
    static readonly CulledFlag: ViewFlags;
    /** @internal */
    static readonly HideFlag: ViewFlags;
    /** @internal */
    static readonly HiddenFlag: ViewFlags;
    /** @internal */
    static readonly UnboundedFlag: ViewFlags;
    /** @internal */
    static readonly IntangibleFlag: ViewFlags;
    /** @internal */
    static readonly CulledMask: ViewFlags;
    /** @internal */
    static readonly HiddenMask: ViewFlags;
    /** @internal */
    static readonly UpdatingMask: ViewFlags;
    /** @internal */
    static readonly StatusMask: ViewFlags;
    static readonly NeedsProcess: ViewFlags;
    static readonly NeedsResize: ViewFlags;
    static readonly NeedsScroll: ViewFlags;
    static readonly NeedsChange: ViewFlags;
    static readonly NeedsAnimate: ViewFlags;
    static readonly NeedsProject: ViewFlags;
    /** @internal */
    static readonly ProcessMask: ViewFlags;
    static readonly NeedsDisplay: ViewFlags;
    static readonly NeedsLayout: ViewFlags;
    static readonly NeedsRender: ViewFlags;
    static readonly NeedsRasterize: ViewFlags;
    static readonly NeedsComposite: ViewFlags;
    /** @internal */
    static readonly DisplayMask: ViewFlags;
    /** @internal */
    static readonly UpdateMask: ViewFlags;
    /** @internal */
    static readonly FlagShift: number;
    /** @internal */
    static readonly FlagMask: ViewFlags;
    static readonly MountFlags: ViewFlags;
    static readonly UncullFlags: ViewFlags;
    static readonly UnhideFlags: ViewFlags;
    static readonly InsertChildFlags: ViewFlags;
    static readonly RemoveChildFlags: ViewFlags;
}

/** @public */
export declare interface ViewClass<V extends View = View, U = AnyView<V>> extends Function, ViewFactory<V, U> {
    readonly prototype: V;
}

/** @public */
export declare interface ViewConstructor<V extends View = View, U = AnyView<V>> extends ViewClass<V, U> {
    new (): V;
}

/** @public */
export declare interface ViewContext {
    readonly updateTime: number;
    readonly viewportIdiom: ViewportIdiom;
    readonly viewport: Viewport;
    readonly viewFrame: R2Box;
}

/** @public */
export declare const ViewContext: {
    current: ViewContext | null;
    create(): ViewContext;
};

/** @public */
export declare type ViewContextType<V extends View> = V extends {
    readonly contextType?: Class<infer T>;
} ? T : never;

/** @public */
export declare type ViewCreator<F extends (abstract new (...args: any) => V) & Creatable<InstanceType<F>>, V extends View = View> = (abstract new (...args: any) => InstanceType<F>) & Creatable<InstanceType<F>>;

/** @internal */
export declare interface ViewDidAnimate<V extends View = View> {
    viewDidAnimate(viewContext: ViewContextType<V>, view: V): void;
}

/** @internal */
export declare interface ViewDidChange<V extends View = View> {
    viewDidChange(viewContext: ViewContextType<V>, view: V): void;
}

/** @internal */
export declare interface ViewDidComposite<V extends View = View> {
    viewDidComposite(viewContext: ViewContextType<V>, view: V): void;
}

/** @internal */
export declare interface ViewDidInsertChild<V extends View = View> {
    viewDidInsertChild(child: View, target: View | null, view: V): void;
}

/** @internal */
export declare interface ViewDidLayout<V extends View = View> {
    viewDidLayout(viewContext: ViewContextType<V>, view: V): void;
}

/** @internal */
export declare interface ViewDidProject<V extends View = View> {
    viewDidProject(viewContext: ViewContextType<V>, view: V): void;
}

/** @internal */
export declare interface ViewDidRasterize<V extends View = View> {
    viewDidRasterize(viewContext: ViewContextType<V>, view: V): void;
}

/** @internal */
export declare interface ViewDidRemoveChild<V extends View = View> {
    viewDidRemoveChild(child: View, view: V): void;
}

/** @internal */
export declare interface ViewDidRender<V extends View = View> {
    viewDidRender(viewContext: ViewContextType<V>, view: V): void;
}

/** @internal */
export declare interface ViewDidResize<V extends View = View> {
    viewDidResize(viewContext: ViewContextType<V>, view: V): void;
}

/** @internal */
export declare interface ViewDidScroll<V extends View = View> {
    viewDidScroll(viewContext: ViewContextType<V>, view: V): void;
}

/** @internal */
export declare interface ViewDidSetAttribute<V extends ElementView = ElementView> {
    viewDidSetAttribute(name: string, value: unknown, view: V): void;
}

/** @internal */
export declare interface ViewDidSetStyle<V extends ElementView = ElementView> {
    viewDidSetStyle(name: string, value: unknown, priority: string | undefined, view: V): void;
}

/** @public */
export declare interface ViewElement extends Element, ElementCSSInlineStyle {
    view?: ElementView;
}

/** @public */
export declare interface ViewEvent extends Event {
    targetView?: View;
    relatedTargetView?: View | null;
}

/** @internal */
export declare interface ViewEventHandler {
    listener: EventListenerOrEventListenerObject;
    capture: boolean;
    passive: boolean;
    once: boolean;
}

/** @public */
export declare interface ViewEventInit extends EventInit {
    targetView?: View;
    relatedTargetView?: View | null;
}

/** @public */
export declare interface ViewFactory<V extends View = View, U = AnyView<V>> extends Creatable<V>, FromAny<V, U> {
    fromInit(init: InitType<V>): V;
}

/** @public */
export declare type ViewFlags = ComponentFlags;

/** @public */
export declare interface ViewHtml extends HTMLElement {
    view?: HtmlView;
}

/** @public */
export declare interface ViewInit extends ComponentInit {
    type?: Creatable<View>;
    key?: string;
    children?: AnyView[];
    mood?: MoodVector;
    moodModifier?: MoodMatrix;
    theme?: ThemeMatrix;
    themeModifier?: MoodMatrix;
}

/** @public */
export declare interface ViewMouseEvent extends MouseEvent, ViewEvent {
}

/** @public */
export declare interface ViewMouseEventInit extends MouseEventInit, ViewEventInit {
}

/** @public */
export declare interface ViewNode extends Node {
    view?: NodeView;
}

/** @public */
export declare type ViewNodeType<V extends NodeView> = V extends {
    readonly node: infer N;
} ? N : never;

/** @public */
export declare interface ViewObserver<V extends View = View> extends ComponentObserver<V> {
    viewWillAttachParent?(parent: View, view: V): void;
    viewDidAttachParent?(parent: View, view: V): void;
    viewWillDetachParent?(parent: View, view: V): void;
    viewDidDetachParent?(parent: View, view: V): void;
    viewWillInsertChild?(child: View, target: View | null, view: V): void;
    viewDidInsertChild?(child: View, target: View | null, view: V): void;
    viewWillRemoveChild?(child: View, view: V): void;
    viewDidRemoveChild?(child: View, view: V): void;
    viewWillMount?(view: V): void;
    viewDidMount?(view: V): void;
    viewWillUnmount?(view: V): void;
    viewDidUnmount?(view: V): void;
    viewWillCull?(view: V): void;
    viewDidCull?(view: V): void;
    viewWillUncull?(view: V): void;
    viewDidUncull?(view: V): void;
    viewWillHide?(view: V): void;
    viewDidHide?(view: V): void;
    viewWillUnhide?(view: V): void;
    viewDidUnhide?(view: V): void;
    viewWillResize?(viewContext: ViewContextType<V>, view: V): void;
    viewDidResize?(viewContext: ViewContextType<V>, view: V): void;
    viewWillScroll?(viewContext: ViewContextType<V>, view: V): void;
    viewDidScroll?(viewContext: ViewContextType<V>, view: V): void;
    viewWillChange?(viewContext: ViewContextType<V>, view: V): void;
    viewDidChange?(viewContext: ViewContextType<V>, view: V): void;
    viewWillAnimate?(viewContext: ViewContextType<V>, view: V): void;
    viewDidAnimate?(viewContext: ViewContextType<V>, view: V): void;
    viewWillProject?(viewContext: ViewContextType<V>, view: V): void;
    viewDidProject?(viewContext: ViewContextType<V>, view: V): void;
    viewWillLayout?(viewContext: ViewContextType<V>, view: V): void;
    viewDidLayout?(viewContext: ViewContextType<V>, view: V): void;
    viewWillRender?(viewContext: ViewContextType<V>, view: V): void;
    viewDidRender?(viewContext: ViewContextType<V>, view: V): void;
    viewWillRasterize?(viewContext: ViewContextType<V>, view: V): void;
    viewDidRasterize?(viewContext: ViewContextType<V>, view: V): void;
    viewWillComposite?(viewContext: ViewContextType<V>, view: V): void;
    viewDidComposite?(viewContext: ViewContextType<V>, view: V): void;
    viewWillApplyTheme?(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean, view: V): void;
    viewDidApplyTheme?(theme: ThemeMatrix, mood: MoodVector, timing: Timing | boolean, view: V): void;
}

/** @internal */
export declare interface ViewObserverCache<V extends View> {
    viewWillInsertChildObservers?: ReadonlyArray<ViewWillInsertChild<V>>;
    viewDidInsertChildObservers?: ReadonlyArray<ViewDidInsertChild<V>>;
    viewWillRemoveChildObservers?: ReadonlyArray<ViewWillRemoveChild<V>>;
    viewDidRemoveChildObservers?: ReadonlyArray<ViewDidRemoveChild<V>>;
    viewWillResizeObservers?: ReadonlyArray<ViewWillResize<V>>;
    viewDidResizeObservers?: ReadonlyArray<ViewDidResize<V>>;
    viewWillScrollObservers?: ReadonlyArray<ViewWillScroll<V>>;
    viewDidScrollObservers?: ReadonlyArray<ViewDidScroll<V>>;
    viewWillChangeObservers?: ReadonlyArray<ViewWillChange<V>>;
    viewDidChangeObservers?: ReadonlyArray<ViewDidChange<V>>;
    viewWillAnimateObservers?: ReadonlyArray<ViewWillAnimate<V>>;
    viewDidAnimateObservers?: ReadonlyArray<ViewDidAnimate<V>>;
    viewWillProjectObservers?: ReadonlyArray<ViewWillProject<V>>;
    viewDidProjectObservers?: ReadonlyArray<ViewDidProject<V>>;
    viewWillLayoutObservers?: ReadonlyArray<ViewWillLayout<V>>;
    viewDidLayoutObservers?: ReadonlyArray<ViewDidLayout<V>>;
    viewWillRenderObservers?: ReadonlyArray<ViewWillRender<V>>;
    viewDidRenderObservers?: ReadonlyArray<ViewDidRender<V>>;
    viewWillRasterizeObservers?: ReadonlyArray<ViewWillRasterize<V>>;
    viewDidRasterizeObservers?: ReadonlyArray<ViewDidRasterize<V>>;
    viewWillCompositeObservers?: ReadonlyArray<ViewWillComposite<V>>;
    viewDidCompositeObservers?: ReadonlyArray<ViewDidComposite<V>>;
}

/** @public */
export declare interface ViewPointerEvent extends PointerEvent, ViewEvent {
}

/** @public */
export declare interface ViewPointerEventInit extends PointerEventInit, ViewEventInit {
}

/** @public */
export declare interface Viewport {
    readonly width: number;
    readonly height: number;
    readonly visual: ViewportArea;
    readonly safeArea: ViewportInsets;
    readonly orientation: OrientationType;
    readonly colorScheme: ViewportColorScheme;
}

/** @public */
export declare const Viewport: {
    detect(): Viewport;
};

/** @public */
export declare interface ViewportArea {
    readonly width: number;
    readonly height: number;
    readonly offsetLeft: number;
    readonly offsetTop: number;
    readonly pageLeft: number;
    readonly pageTop: number;
    readonly scale: number;
}

/** @public */
export declare type ViewportColorScheme = "dark" | "light" | "no-preference";

/** @public */
export declare type ViewportIdiom = "unspecified" | "mobile" | "tablet" | "desktop";

/** @public */
export declare interface ViewportInsets {
    readonly insetTop: number;
    readonly insetRight: number;
    readonly insetBottom: number;
    readonly insetLeft: number;
}

/** @public */
export declare interface ViewportProvider<V extends View, S extends ViewportService<V> | null | undefined = ViewportService<V>> extends Provider<V, S> {
    get viewContext(): ViewContext;
    get viewport(): Viewport;
    get viewportIdiom(): ViewportIdiom;
    setViewportIdiom(viewportIdiom: ViewportIdiom): void;
    createService(): S;
}

/** @public */
export declare const ViewportProvider: ProviderClass<ViewportProvider<any, any>>;

/** @public */
export declare class ViewportService<V extends View = View> extends Service<V> {
    constructor();
    readonly observerType?: Class<ViewportServiceObserver<V>>;
    readonly viewContext: ViewContext;
    get viewport(): Viewport;
    get viewportIdiom(): ViewportIdiom;
    /** @internal */
    detectViewportIdiom(viewport: Viewport): ViewportIdiom | undefined;
    /** @internal */
    updateViewportIdiom(viewport: Viewport): void;
    setViewportIdiom(newViewportIdiom: ViewportIdiom): void;
    protected willSetViewportIdiom(newViewportIdiom: ViewportIdiom, oldViewportIdiom: ViewportIdiom): void;
    protected onSetViewportIdiom(newViewportIdiom: ViewportIdiom, oldViewportIdiom: ViewportIdiom): void;
    protected didSetViewportIdiom(newViewportIdiom: ViewportIdiom, oldViewportIdiom: ViewportIdiom): void;
    protected willReorient(orientation: OrientationType): void;
    protected onReorient(orientation: OrientationType): void;
    protected didReorient(orientation: OrientationType): void;
    protected onObserve(observer: ObserverType<this>): void;
    protected onAttach(): void;
    protected onDetach(): void;
    protected attachEvents(): void;
    protected detachEvents(): void;
    /** @internal */
    throttleScroll(): void;
    /** @internal */
    throttleResize(): void;
    /** @internal */
    viewportResizeTimer: number;
    /** @internal */
    protected debounceViewportResize(): void;
    /** @internal */
    protected throttleViewportResize(): void;
    /** @internal */
    reorientationTimer: number;
    /** @internal */
    protected debounceReorientation(): void;
    /** @internal */
    protected throttleReorientation(): void;
    /** @internal */
    static ViewportResizeDelay: number;
    /** @internal */
    static ReorientationDelay: number;
    static global<V extends View>(): ViewportService<V>;
}

/** @public */
export declare interface ViewportServiceObserver<V extends View = View, S extends ViewportService<V> = ViewportService<V>> extends ServiceObserver<V, S> {
    detectViewportIdiom?(viewport: Viewport, service: S): void | ViewportIdiom;
    serviceWillSetViewportIdiom?(newViewportIdiom: ViewportIdiom, oldViewportIdiom: ViewportIdiom, service: S): void;
    serviceDidSetViewportIdiom?(newViewportIdiom: ViewportIdiom, oldViewportIdiom: ViewportIdiom, service: S): void;
    serviceWillReorient?(orientation: OrientationType, service: S): void;
    serviceDidReorient?(orientation: OrientationType, service: S): void;
}

/** @public */
export declare interface ViewRef<O = unknown, V extends View = View> extends ViewRelation<O, V>, ConstraintScope, ConstraintContext {
    (): V | null;
    (view: AnyView<V> | null, target?: View | null, key?: string): O;
    /** @override */
    get fastenerType(): Proto<ViewRef<any, any>>;
    /** @protected @override */
    onInherit(superFastener: Fastener): void;
    readonly view: V | null;
    getView(): V;
    setView(view: AnyView<V> | null, target?: View | null, key?: string): V | null;
    attachView(view?: AnyView<V>, target?: View | null): V;
    detachView(): V | null;
    insertView(parent?: View | null, view?: AnyView<V>, target?: View | null, key?: string): V;
    removeView(): V | null;
    deleteView(): V | null;
    /** @internal @override */
    bindView(view: View, target: View | null): void;
    /** @internal @override */
    unbindView(view: View): void;
    /** @override */
    detectView(view: View): V | null;
    constraint(lhs: AnyConstraintExpression, relation: ConstraintRelation, rhs?: AnyConstraintExpression, strength?: AnyConstraintStrength): Constraint;
    /** @internal */
    readonly constraints: ReadonlyArray<Constraint>;
    /** @override */
    hasConstraint(constraint: Constraint): boolean;
    /** @override */
    addConstraint(constraint: Constraint): void;
    /** @override */
    removeConstraint(constraint: Constraint): void;
    /** @override */
    activateConstraint(constraint: Constraint): void;
    /** @override */
    deactivateConstraint(constraint: Constraint): void;
    /** @override */
    constraintVariable(name: string, value?: number, strength?: AnyConstraintStrength): ConstraintProperty<unknown, number>;
    /** @internal */
    readonly constraintVariables: ReadonlyArray<ConstraintVariable>;
    /** @override */
    hasConstraintVariable(variable: ConstraintVariable): boolean;
    /** @override */
    addConstraintVariable(variable: ConstraintVariable): void;
    /** @override */
    removeConstraintVariable(variable: ConstraintVariable): void;
    /** @override */
    activateConstraintVariable(constraintVariable: ConstraintVariable): void;
    /** @override */
    deactivateConstraintVariable(constraintVariable: ConstraintVariable): void;
    /** @override */
    setConstraintVariable(constraintVariable: ConstraintVariable, state: number): void;
    /** @internal @protected */
    activateLayout(): void;
    /** @internal @protected */
    deactivateLayout(): void;
    /** @protected @override */
    onMount(): void;
    /** @protected @override */
    onUnmount(): void;
    /** @internal */
    get key(): string | undefined;
}

/** @public */
export declare const ViewRef: ViewRefFactory<ViewRef<any, any>>;

/** @public */
export declare interface ViewRefClass<F extends ViewRef<any, any> = ViewRef<any, any>> extends ViewRelationClass<F> {
}

/** @public */
export declare type ViewRefDescriptor<O = unknown, V extends View = View, I = {}> = ThisType<ViewRef<O, V> & I> & ViewRefInit<V> & Partial<I>;

/** @public */
export declare interface ViewRefFactory<F extends ViewRef<any, any> = ViewRef<any, any>> extends ViewRefClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ViewRefFactory<F> & I;
    define<O, V extends View = View>(className: string, descriptor: ViewRefDescriptor<O, V>): ViewRefFactory<ViewRef<any, V>>;
    define<O, V extends View = View>(className: string, descriptor: {
        observes: boolean;
    } & ViewRefDescriptor<O, V, ObserverType<V>>): ViewRefFactory<ViewRef<any, V>>;
    define<O, V extends View = View, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ViewRefDescriptor<O, V, I>): ViewRefFactory<ViewRef<any, V> & I>;
    define<O, V extends View = View, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & ViewRefDescriptor<O, V, I & ObserverType<V>>): ViewRefFactory<ViewRef<any, V> & I>;
    <O, V extends View = View>(descriptor: ViewRefDescriptor<O, V>): PropertyDecorator;
    <O, V extends View = View>(descriptor: {
        observes: boolean;
    } & ViewRefDescriptor<O, V, ObserverType<V>>): PropertyDecorator;
    <O, V extends View = View, I = {}>(descriptor: {
        implements: unknown;
    } & ViewRefDescriptor<O, V, I>): PropertyDecorator;
    <O, V extends View = View, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & ViewRefDescriptor<O, V, I & ObserverType<V>>): PropertyDecorator;
}

/** @public */
export declare interface ViewRefInit<V extends View = View> extends ViewRelationInit<V> {
    extends?: {
        prototype: ViewRef<any, any>;
    } | string | boolean | null;
    key?: string | boolean;
}

/** @internal */
export declare type ViewRefType<F extends ViewRef<any, any>> = F extends ViewRef<any, infer V> ? V : never;

/** @public */
export declare interface ViewRelation<O = unknown, V extends View = View> extends Fastener<O> {
    /** @override */
    get fastenerType(): Proto<ViewRelation<any, any>>;
    /** @protected */
    initView(view: V): void;
    /** @protected */
    willAttachView(view: V, target: View | null): void;
    /** @protected */
    onAttachView(view: V, target: View | null): void;
    /** @protected */
    didAttachView(view: V, target: View | null): void;
    /** @protected */
    deinitView(view: V): void;
    /** @protected */
    willDetachView(view: V): void;
    /** @protected */
    onDetachView(view: V): void;
    /** @protected */
    didDetachView(view: V): void;
    /** @internal @protected */
    get parentView(): View | null;
    /** @internal @protected */
    insertChild(parent: View, child: V, target: View | null, key: string | undefined): void;
    /** @internal */
    bindView(view: View, target: View | null): void;
    /** @internal */
    unbindView(view: View): void;
    detectView(view: View): V | null;
    createView(): V;
    /** @internal @protected */
    fromAny(value: AnyView<V>): V;
    /** @internal @protected */
    get type(): ViewFactory<V> | undefined;
    /** @internal @protected */
    get binds(): boolean | undefined;
    /** @internal @protected */
    get observes(): boolean | undefined;
    /** @internal @override */
    get lazy(): boolean;
    /** @internal @override */
    get static(): string | boolean;
}

/** @public */
export declare const ViewRelation: ViewRelationFactory<ViewRelation<any, any>>;

/** @public */
export declare interface ViewRelationClass<F extends ViewRelation<any, any> = ViewRelation<any, any>> extends FastenerClass<F> {
}

/** @public */
export declare type ViewRelationDescriptor<O = unknown, V extends View = View, I = {}> = ThisType<ViewRelation<O, V> & I> & ViewRelationInit<V> & Partial<I>;

/** @public */
export declare interface ViewRelationFactory<F extends ViewRelation<any, any> = ViewRelation<any, any>> extends ViewRelationClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ViewRelationFactory<F> & I;
    define<O, V extends View = View>(className: string, descriptor: ViewRelationDescriptor<O, V>): ViewRelationFactory<ViewRelation<any, V>>;
    define<O, V extends View = View>(className: string, descriptor: {
        observes: boolean;
    } & ViewRelationDescriptor<O, V, ObserverType<V>>): ViewRelationFactory<ViewRelation<any, V>>;
    define<O, V extends View = View, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ViewRelationDescriptor<O, V, I>): ViewRelationFactory<ViewRelation<any, V> & I>;
    define<O, V extends View = View, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & ViewRelationDescriptor<O, V, I & ObserverType<V>>): ViewRelationFactory<ViewRelation<any, V> & I>;
    <O, V extends View = View>(descriptor: ViewRelationDescriptor<O, V>): PropertyDecorator;
    <O, V extends View = View>(descriptor: {
        observes: boolean;
    } & ViewRelationDescriptor<O, V, ObserverType<V>>): PropertyDecorator;
    <O, V extends View = View, I = {}>(descriptor: {
        implements: unknown;
    } & ViewRelationDescriptor<O, V, I>): PropertyDecorator;
    <O, V extends View = View, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & ViewRelationDescriptor<O, V, I & ObserverType<V>>): PropertyDecorator;
}

/** @public */
export declare interface ViewRelationInit<V extends View = View> extends FastenerInit {
    extends?: {
        prototype: ViewRelation<any, any>;
    } | string | boolean | null;
    type?: ViewFactory<V>;
    binds?: boolean;
    observes?: boolean;
    initView?(view: V): void;
    willAttachView?(view: V, target: View | null): void;
    didAttachView?(view: V, target: View | null): void;
    deinitView?(view: V): void;
    willDetachView?(view: V): void;
    didDetachView?(view: V): void;
    parentView?: View | null;
    insertChild?(parent: View, child: V, target: View | null, key: string | undefined): void;
    detectView?(view: View): V | null;
    createView?(): V;
    fromAny?(value: AnyView<V>): V;
}

/** @internal */
export declare type ViewRelationType<F extends ViewRelation<any, any>> = F extends ViewRelation<any, infer V> ? V : never;

/** @public */
export declare interface ViewSet<O = unknown, V extends View = View> extends ViewRelation<O, V> {
    (view: AnyView<V>): O;
    /** @override */
    get fastenerType(): Proto<ViewSet<any, any>>;
    /** @internal */
    readonly views: {
        readonly [viewId: number]: V | undefined;
    };
    readonly viewCount: number;
    hasView(view: View): boolean;
    addView(view?: AnyView<V>, target?: View | null, key?: string): V;
    attachView(view?: AnyView<V>, target?: View | null): V;
    detachView(view: V): V | null;
    insertView(parent?: View | null, view?: AnyView<V>, target?: View | null, key?: string): V;
    removeView(view: V): V | null;
    deleteView(view: V): V | null;
    /** @internal @override */
    bindView(view: View, target: View | null): void;
    /** @internal @override */
    unbindView(view: View): void;
    /** @override */
    detectView(view: View): V | null;
    /** @internal @protected */
    key(view: V): string | undefined;
    get sorted(): boolean;
    /** @internal */
    initSorted(sorted: boolean): void;
    sort(sorted?: boolean): this;
    /** @protected */
    willSort(parent: View | null): void;
    /** @protected */
    onSort(parent: View | null): void;
    /** @protected */
    didSort(parent: View | null): void;
    /** @internal @protected */
    sortChildren(parent: View): void;
    /** @internal */
    compareChildren(a: View, b: View): number;
    /** @internal @protected */
    compare(a: V, b: V): number;
}

/** @public */
export declare const ViewSet: ViewSetFactory<ViewSet<any, any>>;

/** @public */
export declare interface ViewSetClass<F extends ViewSet<any, any> = ViewSet<any, any>> extends ViewRelationClass<F> {
    /** @internal */
    readonly SortedFlag: FastenerFlags;
    /** @internal @override */
    readonly FlagShift: number;
    /** @internal @override */
    readonly FlagMask: FastenerFlags;
}

/** @public */
export declare type ViewSetDescriptor<O = unknown, V extends View = View, I = {}> = ThisType<ViewSet<O, V> & I> & ViewSetInit<V> & Partial<I>;

/** @public */
export declare interface ViewSetFactory<F extends ViewSet<any, any> = ViewSet<any, any>> extends ViewSetClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ViewSetFactory<F> & I;
    define<O, V extends View = View>(className: string, descriptor: ViewSetDescriptor<O, V>): ViewSetFactory<ViewSet<any, V>>;
    define<O, V extends View = View>(className: string, descriptor: {
        observes: boolean;
    } & ViewSetDescriptor<O, V, ObserverType<V>>): ViewSetFactory<ViewSet<any, V>>;
    define<O, V extends View = View, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ViewSetDescriptor<O, V, I>): ViewSetFactory<ViewSet<any, V> & I>;
    define<O, V extends View = View, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & ViewSetDescriptor<O, V, I & ObserverType<V>>): ViewSetFactory<ViewSet<any, V> & I>;
    <O, V extends View = View>(descriptor: ViewSetDescriptor<O, V>): PropertyDecorator;
    <O, V extends View = View>(descriptor: {
        observes: boolean;
    } & ViewSetDescriptor<O, V, ObserverType<V>>): PropertyDecorator;
    <O, V extends View = View, I = {}>(descriptor: {
        implements: unknown;
    } & ViewSetDescriptor<O, V, I>): PropertyDecorator;
    <O, V extends View = View, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & ViewSetDescriptor<O, V, I & ObserverType<V>>): PropertyDecorator;
}

/** @public */
export declare interface ViewSetInit<V extends View = View> extends ViewRelationInit<V> {
    extends?: {
        prototype: ViewSet<any, any>;
    } | string | boolean | null;
    key?(view: V): string | undefined;
    compare?(a: V, b: V): number;
    sorted?: boolean;
    willSort?(parent: View | null): void;
    didSort?(parent: View | null): void;
    sortChildren?(parent: View): void;
    compareChildren?(a: View, b: View): number;
}

/** @internal */
export declare type ViewSetType<F extends ViewSet<any, any>> = F extends ViewSet<any, infer V> ? V : never;

/** @public */
export declare interface ViewSvg extends SVGElement {
    view?: SvgView;
}

/** @public */
export declare interface ViewText extends Text {
    view?: TextView;
}

/** @public */
export declare interface ViewTouch extends Touch {
    targetView?: View;
}

/** @public */
export declare interface ViewTouchEvent extends TouchEvent, ViewEvent {
    targetViewTouches?: TouchList;
}

/** @public */
export declare interface ViewTouchEventInit extends TouchEventInit, ViewEventInit {
    targetViewTouches?: TouchList;
}

/** @public */
export declare interface ViewTouchInit extends TouchInit {
    targetView?: View;
}

/** @internal */
export declare interface ViewWillAnimate<V extends View = View> {
    viewWillAnimate(viewContext: ViewContextType<V>, view: V): void;
}

/** @internal */
export declare interface ViewWillChange<V extends View = View> {
    viewWillChange(viewContext: ViewContextType<V>, view: V): void;
}

/** @internal */
export declare interface ViewWillComposite<V extends View = View> {
    viewWillComposite(viewContext: ViewContextType<V>, view: V): void;
}

/** @internal */
export declare interface ViewWillInsertChild<V extends View = View> {
    viewWillInsertChild(child: View, target: View | null, view: V): void;
}

/** @internal */
export declare interface ViewWillLayout<V extends View = View> {
    viewWillLayout(viewContext: ViewContextType<V>, view: V): void;
}

/** @internal */
export declare interface ViewWillProject<V extends View = View> {
    viewWillProject(viewContext: ViewContextType<V>, view: V): void;
}

/** @internal */
export declare interface ViewWillRasterize<V extends View = View> {
    viewWillRasterize(viewContext: ViewContextType<V>, view: V): void;
}

/** @internal */
export declare interface ViewWillRemoveChild<V extends View = View> {
    viewWillRemoveChild(child: View, view: V): void;
}

/** @internal */
export declare interface ViewWillRender<V extends View = View> {
    viewWillRender(viewContext: ViewContextType<V>, view: V): void;
}

/** @internal */
export declare interface ViewWillResize<V extends View = View> {
    viewWillResize(viewContext: ViewContextType<V>, view: V): void;
}

/** @internal */
export declare interface ViewWillScroll<V extends View = View> {
    viewWillScroll(viewContext: ViewContextType<V>, view: V): void;
}

/** @internal */
export declare interface ViewWillSetAttribute<V extends ElementView = ElementView> {
    viewWillSetAttribute(name: string, value: unknown, view: V): void;
}

/** @internal */
export declare interface ViewWillSetStyle<V extends ElementView = ElementView> {
    viewWillSetStyle(name: string, value: unknown, priority: string | undefined, view: V): void;
}

/** @public */
export declare type Visibility = "collapse" | "hidden" | "visible";

/** @public */
export declare interface WebGLContext extends GraphicsContext, WebGLRenderingContext {
}

/** @public */
export declare class WebGLRenderer extends GraphicsRenderer {
    constructor(context: WebGLContext, pixelRatio?: number);
    readonly context: WebGLContext;
    readonly pixelRatio: number;
}

/** @public */
export declare class WebStorageService<C extends Controller = Controller> extends StorageService<C> {
    constructor(storage: Storage);
    readonly storage: Storage;
    get(key: string): string | undefined;
    set(key: string, newValue: string | undefined): string | undefined;
    clear(): void;
    /** @internal */
    onStorage(event: StorageEvent): void;
    protected onAttach(): void;
    protected onDetach(): void;
    protected attachEvents(): void;
    protected detachEvents(): void;
    static local<C extends Controller>(): WebStorageService<C> | null;
    static session<C extends Controller>(): WebStorageService<C> | null;
}

/** @public */
export declare type WhiteSpace = "normal" | "nowrap" | "pre" | "pre-line" | "pre-wrap";

/** @public */
export declare type Width = Length | string | "auto" | "available" | "fit-content" | "max-content" | "min-content";

/** @public */
export declare class WorldMapView extends MapView {
    constructor(geoViewport: WorldMapViewport);
    readonly observerType?: Class<WorldMapViewObserver>;
    readonly geoViewport: WorldMapViewport;
    protected willSetGeoViewport(newGeoViewport: WorldMapViewport, oldGeoViewport: WorldMapViewport): void;
    protected onSetGeoViewport(newGeoViewport: WorldMapViewport, oldGeoViewport: WorldMapViewport): void;
    protected didSetGeoViewport(newGeoViewport: WorldMapViewport, oldGeoViewport: WorldMapViewport): void;
    protected updateGeoViewport(): boolean;
    protected willProcess(processFlags: ViewFlags, viewContext: ViewContextType<this>): void;
    moveTo(geoPerspective: AnyGeoPerspective, timing?: AnyTiming | boolean): void;
    readonly canvas: ViewRef<this, CanvasView>;
    static readonly canvas: MemberFastenerClass<WorldMapView, "canvas">;
    readonly container: ViewRef<this, HtmlView>;
    static readonly container: MemberFastenerClass<WorldMapView, "container">;
    static create(geoViewport?: WorldMapViewport): WorldMapView;
    static create(): WorldMapView;
}

/** @public */
export declare interface WorldMapViewObserver<V extends WorldMapView = WorldMapView> extends MapViewObserver<V> {
    viewWillSetGeoViewport?(newGeoViewport: WorldMapViewport, oldGeoViewport: WorldMapViewport, view: V): void;
    viewDidSetGeoViewport?(newGeoViewport: WorldMapViewport, oldGeoViewport: WorldMapViewport, view: V): void;
}

/** @public */
export declare abstract class WorldMapViewport implements GeoViewport, Equals {
    get geoFrame(): GeoBox;
    get geoCenter(): GeoPoint;
    get zoom(): number;
    get heading(): number;
    get tilt(): number;
    abstract readonly viewFrame: R2Box;
    abstract withViewFrame(viewFrame: R2Box): WorldMapViewport;
    abstract project(geoPoint: AnyGeoPoint): R2Point;
    abstract project(lng: number, lat: number): R2Point;
    abstract unproject(viewPoint: AnyR2Point): GeoPoint;
    abstract unproject(x: number, y: number): GeoPoint;
    protected canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
}

export { }
