/// <reference types="w3c-css-typed-object-model-level-1" />

/** @public */
export declare class Absent extends Value {
    /** @internal */
    private constructor();
    /**
     * Always returns `false` because `Absent` represents an undefined value.
     */
    isDefined(): boolean;
    /**
     * Always returns `false` because `Absent` is not a distinct value.
     */
    isDistinct(): boolean;
    /**
     * Always returns `false` because `Absent` is not a definite value.
     */
    isDefinite(): boolean;
    isConstant(): boolean;
    /**
     * Always returns an empty `Record` because `Absent` is not a distinct value.
     */
    unflattened(): Record_2;
    updated(key: AnyValue, value: AnyValue): Record_2;
    updatedAttr(key: AnyText, value: AnyValue): Record_2;
    updatedSlot(key: AnyValue, value: AnyValue): Record_2;
    appended(...items: AnyItem[]): Record_2;
    prepended(...items: AnyItem[]): Record_2;
    concat(...items: AnyItem[]): Record_2;
    conditional(thenTerm: AnyValue, elseTerm: AnyValue): Value;
    conditional(thenTerm: AnyItem, elseTerm: AnyItem): Item;
    or(that: AnyValue): Value;
    or(that: AnyItem): Item;
    and(that: AnyValue): Value;
    and(that: AnyItem): Item;
    not(): Value;
    /**
     * Always returns `false` because `Absent` behaves like a falsey value.
     */
    booleanValue(): boolean;
    /**
     * Always returns `false` because `Absent` behaves like a falsey value.
     */
    booleanValue<T>(orElse: T): boolean;
    toAny(): AnyAbsent;
    forEach<T>(callback: (item: Item, index: number) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, item: Item, index: number) => T | void, thisArg: S): T | undefined;
    iterator(): Cursor<Item>;
    interpolateTo(that: Absent): Interpolator<Absent>;
    interpolateTo(that: Item): Interpolator<Item>;
    interpolateTo(that: unknown): Interpolator<Item> | null;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    static absent(): Absent;
    static fromAny(value: AnyAbsent): Absent;
}

/** @public */
export declare abstract class AbstractInlet<I> implements Inlet<I> {
    constructor();
    readonly input: Outlet<I> | null;
    /** @internal */
    readonly version: number;
    bindInput(newInput: Outlet<I> | null): void;
    unbindInput(): void;
    disconnectInputs(): void;
    disconnectOutputs(): void;
    decohereOutput(): void;
    recohereOutput(version: number): void;
    protected willDecohereOutput(): void;
    protected onDecohereOutput(): void;
    protected didDecohereOutput(): void;
    protected willRecohereOutput(version: number): void;
    protected onRecohereOutput(version: number): void;
    protected didRecohereOutput(version: number): void;
}

/** @public */
export declare abstract class AbstractInoutlet<I, O> implements Inoutlet<I, O> {
    constructor();
    readonly input: Outlet<I> | null;
    /** @internal */
    readonly outputs: ReadonlyArray<Inlet<O>>;
    /** @internal */
    readonly version: number;
    bindInput(newInput: Outlet<I> | null): void;
    unbindInput(): void;
    disconnectInputs(): void;
    abstract get(): O | undefined;
    outputIterator(): Iterator_2<Inlet<O>>;
    bindOutput(output: Inlet<O>): void;
    unbindOutput(output: Inlet<O>): void;
    unbindOutputs(): void;
    disconnectOutputs(): void;
    decohereOutput(): void;
    decohereInput(): void;
    decohere(): void;
    recohereOutput(version: number): void;
    recohereInput(version: number): void;
    recohere(version: number): void;
    protected willDecohere(): void;
    protected onDecohere(): void;
    protected didDecohere(): void;
    protected willRecohere(version: number): void;
    protected onRecohere(version: number): void;
    protected didRecohere(version: number): void;
}

/** @public */
export declare interface AbstractInoutlet<I, O> extends OutletCombinators<O> {
}

/** @public */
export declare abstract class AbstractMapInlet<K, V, O> implements MapInlet<K, V, O> {
    constructor();
    readonly input: MapOutlet<K, V, O> | null;
    /** @internal */
    readonly effects: BTree<K, KeyEffect>;
    /** @internal */
    readonly version: number;
    bindInput(newInput: MapOutlet<K, V, O> | null): void;
    unbindInput(): void;
    disconnectInputs(): void;
    disconnectOutputs(): void;
    decohereOutputKey(key: K, effect: KeyEffect): void;
    decohereOutput(): void;
    recohereOutputKey(key: K, version: number): void;
    recohereOutput(version: number): void;
    protected willDecohereOutputKey(key: K, effect: KeyEffect): void;
    protected onDecohereOutputKey(key: K, effect: KeyEffect): void;
    protected didDecohereOutputKey(key: K, effect: KeyEffect): void;
    protected willDecohereOutput(): void;
    protected onDecohereOutput(): void;
    protected didDecohereOutput(): void;
    protected willRecohereOutputKey(key: K, effect: KeyEffect, version: number): void;
    protected onRecohereOutputKey(key: K, effect: KeyEffect, version: number): void;
    protected didRecohereOutputKey(key: K, effect: KeyEffect, version: number): void;
    protected willRecohereOutput(version: number): void;
    protected onRecohereOutput(version: number): void;
    protected didRecohereOutput(version: number): void;
}

/** @public */
export declare abstract class AbstractMapInletMapOutlet<KI, KO, VI, VO, I, O> implements MapInletMapOutlet<KI, KO, VI, VO, I, O> {
    constructor();
    readonly input: MapOutlet<KI, VI, I> | null;
    /** @internal */
    readonly outputEffects: BTree<KI, KeyEffect>;
    /** @internal */
    readonly inputEffects: BTree<KO, KeyEffect>;
    /** @internal */
    readonly outlets: BTree<KO, KeyOutlet<KO, VO>>;
    /** @internal */
    readonly outputs: ReadonlyArray<Inlet<O>>;
    /** @internal */
    readonly version: number;
    bindInput(newInput: MapOutlet<KI, VI, I>): void;
    unbindInput(): void;
    disconnectInputs(): void;
    abstract has(key: KO): boolean;
    abstract get(): O;
    abstract get(key: KO): VO | undefined;
    abstract keyIterator(): Iterator_2<KO>;
    outlet(key: KO): Outlet<VO>;
    outputIterator(): Iterator_2<Inlet<O>>;
    bindOutput(output: Inlet<O>): void;
    unbindOutput(output: Inlet<O>): void;
    unbindOutputs(): void;
    disconnectOutputs(): void;
    decohereOutputKey(key: KI, effect: KeyEffect): void;
    decohereInputKey(key: KO, effect: KeyEffect): void;
    decohereOutput(): void;
    decohereInput(): void;
    decohere(): void;
    recohereOutputKey(key: KI, version: number): void;
    recohereInputKey(key: KO, version: number): void;
    recohereOutput(version: number): void;
    recohereInput(version: number): void;
    recohere(version: number): void;
    protected willDecohereOutputKey(key: KI, effect: KeyEffect): void;
    protected onDecohereOutputKey(key: KI, effect: KeyEffect): void;
    protected didDecohereOutputKey(key: KI, effect: KeyEffect): void;
    protected willDecohereInputKey(key: KO, effect: KeyEffect): void;
    protected onDecohereInputKey(key: KO, effect: KeyEffect): void;
    protected didDecohereInputKey(key: KO, effect: KeyEffect): void;
    protected willDecohere(): void;
    protected onDecohere(): void;
    protected didDecohere(): void;
    protected willRecohereOutputKey(key: KI, effect: KeyEffect, version: number): void;
    protected onRecohereOutputKey(key: KI, effect: KeyEffect, version: number): void;
    protected didRecohereOutputKey(key: KI, effect: KeyEffect, version: number): void;
    protected willRecohereInputKey(key: KO, effect: KeyEffect, version: number): KeyEffect;
    protected onRecohereInputKey(key: KO, effect: KeyEffect, version: number): void;
    protected didRecohereInputKey(key: KO, effect: KeyEffect, version: number): void;
    protected willRecohere(version: number): void;
    protected onRecohere(version: number): void;
    protected didRecohere(version: number): void;
}

/** @public */
export declare interface AbstractMapInletMapOutlet<KI, KO, VI, VO, I, O> extends MapOutletCombinators<KO, VO, O> {
}

/** @public */
export declare abstract class AbstractMapInletOutlet<K, V, I, O> implements MapInletOutlet<K, V, I, O> {
    constructor();
    readonly input: MapOutlet<K, V, I> | null;
    /** @internal */
    readonly effects: BTree<K, KeyEffect>;
    /** @internal */
    readonly outputs: ReadonlyArray<Inlet<O>>;
    /** @internal */
    readonly version: number;
    bindInput(newInput: MapOutlet<K, V, I>): void;
    unbindInput(): void;
    disconnectInputs(): void;
    abstract get(): O | undefined;
    outputIterator(): Iterator_2<Inlet<O>>;
    bindOutput(output: Inlet<O>): void;
    unbindOutput(output: Inlet<O>): void;
    unbindOutputs(): void;
    disconnectOutputs(): void;
    decohereOutputKey(key: K, effect: KeyEffect): void;
    decohereOutput(): void;
    decohereInput(): void;
    decohere(): void;
    recohereOutputKey(key: K, version: number): void;
    recohereOutput(version: number): void;
    recohereInput(version: number): void;
    recohere(version: number): void;
    protected willDecohereOutputKey(key: K, effect: KeyEffect): void;
    protected onDecohereOutputKey(key: K, effect: KeyEffect): void;
    protected didDecohereOutputKey(key: K, effect: KeyEffect): void;
    protected willDecohere(): void;
    protected onDecohere(): void;
    protected didDecohere(): void;
    protected willRecohereOutputKey(key: K, effect: KeyEffect, version: number): void;
    protected onRecohereOutputKey(key: K, effect: KeyEffect, version: number): void;
    protected didRecohereOutputKey(key: K, effect: KeyEffect, version: number): void;
    protected willRecohere(version: number): void;
    protected onRecohere(version: number): void;
    protected didRecohere(version: number): void;
}

/** @public */
export declare interface AbstractMapInletOutlet<K, V, I, O> extends OutletCombinators<O> {
}

/** @public */
export declare abstract class AbstractMapInoutlet<K, VI, VO, I, O> implements MapInoutlet<K, VI, VO, I, O> {
    constructor();
    readonly input: MapOutlet<K, VI, I> | null;
    /** @internal */
    readonly effects: BTree<K, KeyEffect>;
    /** @internal */
    readonly outlets: BTree<K, KeyOutlet<K, VO>>;
    /** @internal */
    readonly outputs: ReadonlyArray<Inlet<O>>;
    /** @internal */
    readonly version: number;
    bindInput(newInput: MapOutlet<K, VI, I>): void;
    unbindInput(): void;
    disconnectInputs(): void;
    abstract has(key: K): boolean;
    abstract get(): O | undefined;
    abstract get(key: K): VO | undefined;
    abstract keyIterator(): Iterator_2<K>;
    outlet(key: K): Outlet<VO>;
    outputIterator(): Iterator_2<Inlet<O>>;
    bindOutput(output: Inlet<O>): void;
    unbindOutput(output: Inlet<O>): void;
    unbindOutputs(): void;
    disconnectOutputs(): void;
    decohereOutputKey(key: K, effect: KeyEffect): void;
    decohereInputKey(key: K, effect: KeyEffect): void;
    decohereKey(key: K, effect: KeyEffect): void;
    decohereOutput(): void;
    decohereInput(): void;
    decohere(): void;
    recohereOutputKey(key: K, version: number): void;
    recohereInputKey(key: K, version: number): void;
    recohereKey(key: K, version: number): void;
    recohereOutput(version: number): void;
    recohereInput(version: number): void;
    recohere(version: number): void;
    protected willDecohereKey(key: K, effect: KeyEffect): void;
    protected onDecohereKey(key: K, effect: KeyEffect): void;
    protected didDecohereKey(key: K, effect: KeyEffect): void;
    protected willDecohere(): void;
    protected onDecohere(): void;
    protected didDecohere(): void;
    protected willRecohereKey(key: K, effect: KeyEffect, version: number): void;
    protected onRecohereKey(key: K, effect: KeyEffect, version: number): void;
    protected didRecohereKey(key: K, effect: KeyEffect, version: number): void;
    protected willRecohere(version: number): void;
    protected onRecohere(version: number): void;
    protected didRecohere(version: number): void;
}

/** @public */
export declare interface AbstractMapInoutlet<K, VI, VO, I, O> extends MapOutletCombinators<K, VO, O> {
}

/** @public */
export declare abstract class AbstractMapOutlet<K, V, O> implements MapOutlet<K, V, O> {
    constructor();
    /** @internal */
    readonly effects: BTree<K, KeyEffect>;
    /** @internal */
    readonly outlets: BTree<K, KeyOutlet<K, V>>;
    /** @internal */
    readonly outputs: ReadonlyArray<Inlet<O>>;
    /** @internal */
    readonly version: number;
    abstract has(key: K): boolean;
    abstract get(): O | undefined;
    abstract get(key: K): V | undefined;
    abstract keyIterator(): Iterator_2<K>;
    outlet(key: K): Outlet<V>;
    outputIterator(): Iterator_2<Inlet<O>>;
    bindOutput(output: Inlet<O>): void;
    unbindOutput(output: Inlet<O>): void;
    unbindOutputs(): void;
    disconnectOutputs(): void;
    disconnectInputs(): void;
    decohereInputKey(key: K, effect: KeyEffect): void;
    decohereInput(): void;
    recohereInputKey(key: K, version: number): void;
    recohereInput(version: number): void;
    protected willDecohereInputKey(key: K, effect: KeyEffect): void;
    protected onDecohereInputKey(key: K, effect: KeyEffect): void;
    protected didDecohereInputKey(key: K, effect: KeyEffect): void;
    protected willDecohereInput(): void;
    protected onDecohereInput(): void;
    protected didDecohereInput(): void;
    protected willRecohereInputKey(key: K, effect: KeyEffect, version: number): void;
    protected onRecohereInputKey(key: K, effect: KeyEffect, version: number): void;
    protected didRecohereInputKey(key: K, effect: KeyEffect, version: number): void;
    protected willRecohereInput(version: number): void;
    protected onRecohereInput(version: number): void;
    protected didRecohereInput(version: number): void;
}

/** @public */
export declare interface AbstractMapOutlet<K, V, O> extends MapOutletCombinators<K, V, O> {
}

/** @public */
export declare abstract class AbstractOutlet<O> implements Outlet<O> {
    constructor();
    /** @internal */
    readonly outputs: ReadonlyArray<Inlet<O>>;
    /** @internal */
    readonly version: number;
    abstract get(): O | undefined;
    outputIterator(): Cursor<Inlet<O>>;
    bindOutput(output: Inlet<O>): void;
    unbindOutput(output: Inlet<O>): void;
    unbindOutputs(): void;
    disconnectOutputs(): void;
    disconnectInputs(): void;
    decohereInput(): void;
    recohereInput(version: number): void;
    protected willDecohereInput(): void;
    protected onDecohereInput(): void;
    protected didDecohereInput(): void;
    protected willRecohereInput(version: number): void;
    protected onRecohereInput(version: number): void;
    protected didRecohereInput(version: number): void;
}

/** @public */
export declare interface AbstractOutlet<O> extends OutletCombinators<O> {
}

/** @public */
export declare abstract class AbstractRecordOutlet extends Record_2 implements RecordOutlet {
    constructor();
    /** @internal */
    readonly effects: BTree<Value, KeyEffect>;
    /** @internal */
    readonly outlets: BTree<Value, KeyOutlet<Value, Value>>;
    /** @internal */
    readonly outputs: ReadonlyArray<Inlet<Record_2>>;
    /** @internal */
    readonly version: number;
    readonly streamletScope: StreamletScope<Value> | null;
    get streamletContext(): StreamletContext | null;
    hasOwn(key: AnyValue): boolean;
    get(): Record_2;
    get(key: AnyValue): Value;
    abstract keyIterator(): Cursor<Value>;
    outlet(key: Value | string): Outlet<Value>;
    outputIterator(): Cursor<Inlet<Record_2>>;
    bindOutput(output: Inlet<Record_2>): void;
    unbindOutput(output: Inlet<Record_2>): void;
    unbindOutputs(): void;
    disconnectOutputs(): void;
    disconnectInputs(): void;
    decohereInputKey(key: Value, effect: KeyEffect): void;
    decohereInput(): void;
    recohereInputKey(key: Value, version: number): void;
    recohereInput(version: number): void;
    protected willDecohereInputKey(key: Value, effect: KeyEffect): void;
    protected onDecohereInputKey(key: Value, effect: KeyEffect): void;
    protected didDecohereInputKey(key: Value, effect: KeyEffect): void;
    protected willDecohereInput(): void;
    protected onDecohereInput(): void;
    protected didDecohereInput(): void;
    protected willRecohereInputKey(key: Value, effect: KeyEffect, version: number): void;
    protected onRecohereInputKey(key: Value, effect: KeyEffect, version: number): void;
    protected didRecohereInputKey(key: Value, effect: KeyEffect, version: number): void;
    protected willRecohereInput(version: number): void;
    protected onRecohereInput(version: number): void;
    protected didRecohereInput(version: number): void;
    filter(predicate?: AnyItem): Selector;
    filter(func: FilterFieldsFunction<Value, Value>): MapOutlet<Value, Value, Map_2<Value, Value>>;
}

/** @public */
export declare interface AbstractRecordOutlet extends MapOutletCombinators<Value, Value, Record_2> {
}

/** @public */
export declare abstract class AbstractRecordStreamlet<I extends Value = Value, O extends Value = I> extends RecordStreamlet<I, O> implements GenericStreamlet<I, O> {
    constructor(scope?: StreamletScope<O> | null);
    readonly streamletScope: StreamletScope<O> | null;
    setStreamletScope(scope: StreamletScope<O> | null): void;
    readonly streamletContext: StreamletContext | null;
    setStreamletContext(context: StreamletContext | null): void;
    /** @internal */
    readonly version: number;
    isEmpty(): boolean;
    get length(): number;
    has(key: AnyValue): boolean;
    get(key: AnyValue): Value;
    getAttr(key: AnyText): Value;
    getSlot(key: AnyValue): Value;
    getField(key: AnyValue): Field | undefined;
    getItem(index: AnyNum): Item;
    set(key: AnyValue, newValue: AnyValue): this;
    setAttr(key: AnyText, newValue: AnyValue): this;
    setSlot(key: AnyValue, newValue: AnyValue): this;
    setItem(index: number, item: AnyItem): this;
    push(...items: AnyItem[]): number;
    splice(start: number, deleteCount?: number, ...newItems: AnyItem[]): Item[];
    delete(key: AnyValue): Item;
    clear(): void;
    forEach<T>(callback: (item: Item, index: number) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, item: Item, index: number) => T | void, thisArg: S): T | undefined;
    inlet(key: string): Inlet<I> | null;
    inlet<I2 extends I>(): Inlet<I2>;
    bindInput(key: string, input: Outlet<I>): void;
    unbindInput(key: string): void;
    outlet(key: string | Outlet<O>): Outlet<O> | null;
    outlet<O2 extends Value>(): Outlet<O2>;
    inoutlet<I2 extends I, O2 extends Value>(): Inoutlet<I2, O2>;
    decohere(): void;
    recohere(version: number): void;
    getInput<I2 extends I>(inlet: Inlet<I2> | string): I2 | undefined;
    getInput<I2 extends I, E = I2>(inlet: Inlet<I2> | string, orElse: E): I2 | E;
    castInput<T>(inlet: Inlet<I> | string, form: Form<T, unknown>): T | undefined;
    castInput<T, E = T>(inlet: Inlet<I> | string, form: Form<T, unknown>, orElse: E): T | E;
    coerceInput<T>(inlet: Inlet<I> | string, form: Form<T, unknown>): T;
    coerceInput<T, E = T>(inlet: Inlet<I> | string, form: Form<T, unknown>, orElse: E): T | E;
    getOutput(outlet: Outlet<O> | string): O | undefined;
    disconnectInputs(): void;
    disconnectOutputs(): void;
    willDecohereInlet(inlet: Inlet<I>): void;
    didDecohereInlet(inlet: Inlet<I>): void;
    willRecohereInlet(inlet: Inlet<I>, version: number): void;
    didRecohereInlet(inlet: Inlet<I>, version: number): void;
    willDecohereOutlet(outlet: Outlet<O>): void;
    didDecohereOutlet(outlet: Outlet<O>): void;
    willRecohereOutlet(outlet: Outlet<O>, version: number): void;
    didRecohereOutlet(outlet: Outlet<O>, version: number): void;
    protected willDecohere(): void;
    protected onDecohere(): void;
    protected didDecohere(): void;
    protected onDecohereOutlets(): void;
    protected willRecohere(version: number): void;
    protected onRecohereInlets(version: number): void;
    protected onRecohere(version: number): void;
    protected onRecohereOutlets(version: number): void;
    protected didRecohere(version: number): void;
}

/** @public */
export declare abstract class AbstractStreamlet<I = unknown, O = I> implements GenericStreamlet<I, O> {
    constructor(scope?: StreamletScope<O> | null);
    readonly streamletScope: StreamletScope<O> | null;
    setStreamletScope(scope: StreamletScope<O> | null): void;
    readonly streamletContext: StreamletContext | null;
    setStreamletContext(context: StreamletContext | null): void;
    /** @internal */
    readonly version: number;
    inlet(key: string): Inlet<I> | null;
    inlet<I2 extends I>(): Inlet<I2>;
    bindInput(key: string, input: Outlet<I>): void;
    unbindInput(key: string): void;
    outlet(key: string | Outlet<O>): Outlet<O> | null;
    outlet<O2>(): Outlet<O2>;
    inoutlet<I2 extends I, O2>(): Inoutlet<I2, O2>;
    decohere(): void;
    recohere(version: number): void;
    getInput<I2 extends I>(inlet: Inlet<I2> | string): I2 | undefined;
    getInput<I2 extends I, E = I2>(inlet: Inlet<I2> | string, orElse: E): I2 | E;
    getOutput(outlet: Outlet<O> | string): O | undefined;
    disconnectInputs(): void;
    /** @internal */
    static disconnectInputs<I, O>(streamlet: Streamlet<I, O>, streamletPrototype: StreamletPrototype | null): void;
    disconnectOutputs(): void;
    /** @internal */
    static disconnectOutputs<I, O>(streamlet: Streamlet<I, O>, streamletPrototype: StreamletPrototype | null): void;
    willDecohereInlet(inlet: Inlet<I>): void;
    didDecohereInlet(inlet: Inlet<I>): void;
    willRecohereInlet(inlet: Inlet<I>, version: number): void;
    didRecohereInlet(inlet: Inlet<I>, version: number): void;
    willDecohereOutlet(outlet: Outlet<O>): void;
    didDecohereOutlet(outlet: Outlet<O>): void;
    willRecohereOutlet(outlet: Outlet<O>, version: number): void;
    didRecohereOutlet(outlet: Outlet<O>, version: number): void;
    protected willDecohere(): void;
    protected onDecohere(): void;
    protected onDecohereOutlets(): void;
    /** @internal */
    static decohereOutlets<I, O>(streamlet: Streamlet<I, O>, streamletPrototype: StreamletPrototype | null): void;
    protected didDecohere(): void;
    protected willRecohere(version: number): void;
    protected onRecohereInlets(version: number): void;
    /** @internal */
    static recohereInlets<I, O>(version: number, streamlet: Streamlet<I, O>, streamletPrototype: StreamletPrototype | null): void;
    protected onRecohere(version: number): void;
    protected onRecohereOutlets(version: number): void;
    /** @internal */
    static recohereOutlets<I, O>(version: number, streamlet: Streamlet<I, O>, streamletPrototype: StreamletPrototype | null): void;
    protected didRecohere(version: number): void;
    /** @internal */
    static reflectEachInlet<I, O, T>(streamlet: Streamlet<I, O>, streamletPrototype: StreamletPrototype | null, callback: (inlet: Inlet<I>, name: string, index: number) => T | void): T | undefined;
    /** @internal */
    static reflectEachInlet<I, O, T, S>(streamlet: Streamlet<I, O>, streamletPrototype: StreamletPrototype | null, callback: (this: S, inlet: Inlet<I>, name: string, index: number) => T | void, thisArg: S): T | undefined;
    /** @internal */
    static reflectEachOutlet<I, O, T>(streamlet: Streamlet<I, O>, streamletPrototype: StreamletPrototype | null, callback: (outlet: Outlet<O>, name: string, index: number) => T | void): T | undefined;
    /** @internal */
    static reflectEachOutlet<I, O, T, S>(streamlet: Streamlet<I, O>, streamletPrototype: StreamletPrototype | null, callback: (this: S, outlet: Outlet<O>, name: string, index: number) => T | void, thisArg: S): T | undefined;
    /** @internal */
    static reflectInletCount(streamletPrototype: StreamletPrototype | null): number;
    /** @internal */
    static reflectOutletCount(streamletPrototype: StreamletPrototype | null): number;
    /** @internal */
    static reflectInletIndex<I, O>(index: number, streamlet: Streamlet<I, O>, streamletPrototype: StreamletPrototype | null): [string, Inlet<I>] | null;
    /** @internal */
    static reflectOutletIndex<I, O>(index: number, streamlet: Streamlet<I, O>, streamletPrototype: StreamletPrototype | null): [string, Outlet<O>] | null;
    /** @internal */
    static reflectInletKey<I, O>(key: string, streamlet: Streamlet<I, O>, streamletPrototype: StreamletPrototype | null): Inlet<I> | null;
    /** @internal */
    static reflectOutletKey<I, O>(key: string, streamlet: Streamlet<I, O>, streamletPrototype: StreamletPrototype | null): Outlet<O> | null;
    /** @internal */
    static reflectInletField<I, O>(streamlet: Streamlet<I, O>, inletDescriptor: InletDescriptor): Inlet<I>;
    /** @internal */
    static reflectValueInletField<I, O>(streamlet: Streamlet<I, O>, key: string): Inlet<I>;
    /** @internal */
    static reflectMapInletField<I, O>(streamlet: Streamlet<I, O>, key: string): Inlet<I>;
    /** @internal */
    static reflectOutletField<I, O>(streamlet: Streamlet<I, O>, outletDescriptor: OutletDescriptor): Outlet<O>;
    /** @internal */
    static reflectValueOutletField<I, O>(streamlet: Streamlet<I, O>, key: string): Outlet<O>;
    /** @internal */
    static reflectMapOutletField<I, O>(streamlet: Streamlet<I, O>, key: string): Outlet<O>;
    /** @internal */
    static reflectInoutletField<I, O>(streamlet: Streamlet<I, O>, inoutletDescriptor: InoutletDescriptor): Inoutlet<I, O>;
    /** @internal */
    static reflectValueInoutletField<I, O>(streamlet: Streamlet<I, O>, key: string): Inoutlet<I, O>;
    /** @internal */
    static reflectMapInoutletField<I, O>(streamlet: Streamlet<I, O>, key: string): Inoutlet<I, O>;
    /** @internal */
    static init(streamletPrototype: StreamletPrototype): void;
    /** @internal */
    static decorateInlet(options: InletOptions, target: StreamletPrototype, propertyKey: string | symbol): void;
    /** @internal */
    static decorateOutlet(options: OutletOptions, target: StreamletPrototype, propertyKey: string | symbol): void;
    /** @internal */
    static decorateInoutlet(options: InoutletOptions, target: StreamletPrototype, propertyKey: string | symbol): void;
}

/** @public */
export declare class AffineTransform extends Transform {
    constructor(x0: number, y0: number, x1: number, y1: number, tx: number, ty: number);
    readonly x0: number;
    readonly y0: number;
    readonly x1: number;
    readonly y1: number;
    readonly tx: number;
    readonly ty: number;
    transform(that: Transform): Transform;
    transform(x: number, y: number): R2Point;
    transformX(x: number, y: number): number;
    transformY(x: number, y: number): number;
    inverse(): Transform;
    multiply(that: AffineTransform): AffineTransform;
    toAffine(): AffineTransform;
    toMatrix(): DOMMatrix;
    toCssTransformComponent(): CSSTransformComponent | null;
    toValue(): Value;
    interpolateTo(that: AffineTransform): Interpolator<AffineTransform>;
    interpolateTo(that: Transform): Interpolator<Transform>;
    interpolateTo(that: unknown): Interpolator<Transform> | null;
    conformsTo(that: Transform): boolean;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    /** @internal */
    readonly stringValue: string | undefined;
    toString(): string;
    static identity(): AffineTransform;
    static fromAny(value: AffineTransform | string): AffineTransform;
    static fromMatrix(matrix: DOMMatrixReadOnly): AffineTransform;
    static fromCssTransformComponent(component: CSSMatrixComponent): AffineTransform;
    static fromValue(value: Value): AffineTransform | null;
    static parse(string: string): AffineTransform;
}

/** @internal */
export declare const AffineTransformInterpolator: {
    (f0: AffineTransform, f1: AffineTransform): Interpolator<AffineTransform>;
    /** @internal */
    prototype: Interpolator<AffineTransform>;
};

/** @internal */
export declare class AffineTransformParser extends Parser<AffineTransform> {
    private readonly identOutput;
    private readonly entries;
    private readonly entryParser;
    private readonly step;
    constructor(identOutput?: Output<string>, entries?: number[], entryParser?: Parser<number>, step?: number);
    feed(input: Input): Parser<AffineTransform>;
    static parse(input: Input, identOutput?: Output<string>, entries?: number[], entryParser?: Parser<number>, step?: number): Parser<AffineTransform>;
    /** @internal */
    static parseRest(input: Input, identOutput?: Output<string>): Parser<AffineTransform>;
}

/** @public */
export declare type Affinity = number;

/** @public */
export declare const Affinity: {
    readonly Transient: number;
    readonly Inherited: number;
    readonly Intrinsic: number;
    readonly Extrinsic: number;
    readonly Reflexive: number;
    /** @internal */
    readonly Shift: number;
    /** @internal */
    readonly Mask: number;
};

/** @public */
export declare class AndOperator extends BinaryOperator {
    constructor(operand1: Item, operand2: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): AndOperator;
}

/** @internal */
export declare class AndOutlet extends AbstractOutlet<Value> {
    constructor();
    readonly operand1Inlet: Inlet<Value>;
    readonly operand2Inlet: Inlet<Value>;
    get(): Value;
}

/** @public */
export declare abstract class Angle implements Interpolate<Angle>, HashCode, Equivalent, Compare, Debug {
    isDefined(): boolean;
    abstract readonly value: number;
    abstract readonly units: AngleUnits;
    plus(that: AnyAngle, units?: AngleUnits): Angle;
    negative(units?: AngleUnits): Angle;
    minus(that: AnyAngle, units?: AngleUnits): Angle;
    times(scalar: number, units?: AngleUnits): Angle;
    divide(scalar: number, units?: AngleUnits): Angle;
    combine(that: AnyAngle, scalar?: number, units?: AngleUnits): Angle;
    norm(total: AnyAngle, units?: AngleUnits): Angle;
    abstract degValue(): number;
    abstract gradValue(): number;
    abstract radValue(): number;
    abstract turnValue(): number;
    deg(): DegAngle;
    rad(): RadAngle;
    grad(): GradAngle;
    turn(): TurnAngle;
    toValue(): Value;
    toValue(units: AngleUnits): number;
    to(units: AngleUnits): Angle;
    abstract toCssValue(): CSSUnitValue | null;
    interpolateTo(that: Angle): Interpolator<Angle>;
    interpolateTo(that: unknown): Interpolator<Angle> | null;
    abstract compareTo(that: unknown): number;
    abstract equivalentTo(that: unknown, epsilon?: number): boolean;
    abstract equals(that: unknown): boolean;
    abstract hashCode(): number;
    abstract debug<T>(output: Output<T>): Output<T>;
    abstract toString(): string;
    static zero(units?: AngleUnits): Angle;
    static deg(value: number): DegAngle;
    static rad(value: number): RadAngle;
    static grad(value: number): GradAngle;
    static turn(value: number): TurnAngle;
    static create(value: number, units?: AngleUnits): Angle;
    static fromCssValue(value: CSSStyleValue): Angle;
    static fromAny(value: AnyAngle, defaultUnits?: AngleUnits): Angle;
    static fromValue(value: Value): Angle | null;
    static parse(string: string, defaultUnits?: AngleUnits): Angle;
    static form(): Form<Angle, AnyAngle>;
    /** @internal */
    static isAny(value: unknown): value is AnyAngle;
}

/** @internal */
export declare class AngleForm extends Form<Angle, AnyAngle> {
    constructor(defaultUnits: AngleUnits | undefined, unit: Angle | undefined);
    readonly defaultUnits: AngleUnits | undefined;
    readonly unit: Angle | undefined;
    withUnit(unit: Angle | undefined): Form<Angle, AnyAngle>;
    mold(angle: AnyAngle): Item;
    cast(item: Item): Angle | undefined;
}

/** @internal */
export declare const AngleInterpolator: {
    (a0: Angle, a1: Angle): Interpolator<Angle>;
    /** @internal */
    prototype: Interpolator<Angle>;
};

/** @internal */
export declare class AngleParser extends Parser<Angle> {
    private readonly defaultUnits;
    private readonly valueParser;
    private readonly unitsOutput;
    private readonly step;
    constructor(defaultUnits?: AngleUnits, valueParser?: Parser<number>, unitsOutput?: Output<string>, step?: number);
    feed(input: Input): Parser<Angle>;
    static parse(input: Input, defaultUnits?: AngleUnits, valueParser?: Parser<number>, unitsOutput?: Output<string>, step?: number): Parser<Angle>;
}

/** @public */
export declare type AngleUnits = "deg" | "rad" | "grad" | "turn";

/** @public */
export declare interface Animator<O = unknown, T = unknown, U = T> extends Property<O, T, U> {
    (): T;
    (newState: T | U, timingOrAffinity: Affinity | AnyTiming | boolean | null | undefined): O;
    (newState: T | U, timing?: AnyTiming | boolean | null, affinity?: Affinity): O;
    /** @protected @override */
    onInherit(superFastener: Property<unknown, T>): void;
    /** @override */
    setValue(newValue: T | U, affinity?: Affinity): void;
    get superState(): T | undefined;
    getSuperState(): NonNullable<T>;
    getSuperStateOr<E>(elseState: E): NonNullable<T> | E;
    readonly state: T;
    getState(): NonNullable<T>;
    getStateOr<E>(elseState: E): NonNullable<T> | E;
    transformState(state: T): T;
    setState(newState: T | U, timingOrAffinity: Affinity | AnyTiming | boolean | null | undefined): void;
    setState(newState: T | U, timing?: AnyTiming | boolean | null, affinity?: Affinity): void;
    /** @protected */
    willSetState(newstate: T, oldState: T): void;
    /** @protected */
    onSetState(newstate: T, oldState: T): void;
    /** @protected */
    didSetState(newstate: T, oldState: T): void;
    readonly timing: Timing | null;
    readonly interpolator: Interpolator<T> | null;
    setInterpolatedValue(newValue: T, newState?: T): void;
    /** @internal @protected @override */
    decohereSubFastener(subFastener: Property<unknown, T>): void;
    /** @override */
    recohere(t: number): void;
    /** @internal @protected */
    tween(t: number): void;
    /** @internal @protected */
    tweenInherited(t: number): void;
    /**
     * Returns `true` if this animator is actively transitioning to a new `state`.
     */
    get tweening(): boolean;
    /** @internal */
    startTweening(): void;
    /** @protected */
    willStartTweening(): void;
    /** @protected */
    onStartTweening(): void;
    /** @protected */
    didStartTweening(): void;
    /** @internal */
    stopTweening(): void;
    /** @protected */
    willStopTweening(): void;
    /** @protected */
    onStopTweening(): void;
    /** @protected */
    didStopTweening(): void;
    /** @internal @protected */
    willTransition(oldValue: T): void;
    /** @internal @protected */
    didTransition(newValue: T): void;
    /** @internal @protected */
    didInterrupt(value: T): void;
    /** @protected @override */
    onUnmount(): void;
}

/** @public */
export declare const Animator: AnimatorFactory<Animator<any, any, any>>;

/** @public */
export declare interface AnimatorClass<A extends Animator<any, any> = Animator<any, any>> extends PropertyClass<A> {
    /** @internal */
    readonly TweeningFlag: FastenerFlags;
    /** @internal */
    readonly DivergedFlag: FastenerFlags;
    /** @internal */
    readonly InterruptFlag: FastenerFlags;
    /** @internal @override */
    readonly FlagShift: number;
    /** @internal @override */
    readonly FlagMask: FastenerFlags;
}

/** @public */
export declare type AnimatorDescriptor<O = unknown, T = unknown, U = T, I = {}> = ThisType<Animator<O, T, U> & I> & AnimatorInit<T, U> & Partial<I>;

/** @public */
export declare interface AnimatorFactory<A extends Animator<any, any> = Animator<any, any>> extends AnimatorClass<A> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): AnimatorFactory<A> & I;
    specialize(type: unknown): AnimatorFactory | null;
    define<O, T, U = T>(className: string, descriptor: AnimatorDescriptor<O, T, U>): AnimatorFactory<Animator<any, T, U>>;
    define<O, T, U = T, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & AnimatorDescriptor<O, T, U, I>): AnimatorFactory<Animator<any, T, U> & I>;
    <O, T extends string | undefined = string | undefined, U extends string | undefined = string | undefined>(descriptor: {
        type: typeof String;
    } & AnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends number | undefined = number | undefined, U extends number | string | undefined = number | string | undefined>(descriptor: {
        type: typeof Number;
    } & AnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T extends boolean | undefined = boolean | undefined, U extends boolean | string | undefined = boolean | string | undefined>(descriptor: {
        type: typeof Boolean;
    } & AnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = T>(descriptor: ({
        type: FromAny<T, U>;
    } | {
        fromAny(value: T | U): T;
    }) & AnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = T>(descriptor: AnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = T, I = {}>(descriptor: {
        implements: unknown;
    } & AnimatorDescriptor<O, T, U, I>): PropertyDecorator;
}

/** @public */
export declare interface AnimatorInit<T = unknown, U = never> extends PropertyInit<T, U> {
    extends?: {
        prototype: Animator<any, any>;
    } | string | boolean | null;
    transformState?(state: T): T;
    willSetState?(newState: T, oldState: T): void;
    didSetState?(newState: T, oldState: T): void;
    willStartTweening?(): void;
    didStartTweening?(): void;
    willStopTweening?(): void;
    didStopTweening?(): void;
    willTransition?(oldValue: T): void;
    didTransition?(newValue: T): void;
    didInterrupt?(value: T): void;
}

/** @internal */
export declare type AnimatorValue<A extends Animator<any, any>> = A extends Animator<any, infer T, any> ? T : never;

/** @internal */
export declare type AnimatorValueInit<A extends Animator<any, any>> = A extends Animator<any, infer T, infer U> ? T | U : never;

/** @public */
export declare type AnyAbsent = Absent | undefined;

/** @public */
export declare type AnyAngle = Angle | string | number;

/** @public */
export declare type AnyBool = Bool | boolean;

/** @public */
export declare type AnyComponent<C extends Component = Component> = C | ComponentFactory<C> | InitType<C>;

/** @public */
export declare type AnyConstraintExpression = ConstraintExpression | number;

/** @public */
export declare type AnyConstraintStrength = ConstraintStrength | ConstraintStrengthInit;

/** @public */
export declare type AnyData = Data | Uint8Array;

/** @public */
export declare type AnyDateTime = DateTime | DateTimeInit | Date | string | number;

/** @public */
export declare type AnyDomain<X> = Domain<X> | readonly [X, X];

/** @public */
export declare type AnyEasing = Easing | EasingType;

/** @public */
export declare type AnyExtant = Extant | null;

/** @public */
export declare type AnyField = Field | {
    readonly $key: AnyValue;
    readonly $value: AnyValue;
} | {
    [key: string]: AnyValue;
};

/** @internal */
export declare class AnyForm extends Form<AnyItem> {
    constructor(unit?: AnyItem);
    readonly unit: AnyItem | undefined;
    withUnit(unit: AnyItem | undefined): Form<AnyItem>;
    mold(object: AnyItem, item?: Item): Item;
    cast(item: Item, object?: AnyItem): AnyItem | undefined;
}

/** @public */
export declare type AnyGeoBox = GeoBox | GeoBoxInit;

/** @public */
export declare type AnyGeoPath = GeoPath | GeoPathSplines | AnyGeoSpline;

/** @public */
export declare type AnyGeoPoint = GeoPoint | GeoPointInit | GeoPointTuple;

/** @public */
export declare type AnyGeoSegment = GeoSegment | GeoSegmentInit;

/** @public */
export declare type AnyGeoShape = GeoShape | GeoPointInit | GeoPointTuple | GeoSegmentInit | GeoTileInit | GeoTileTuple | GeoBoxInit;

/** @public */
export declare type AnyGeoSpline = GeoSpline | GeoSplinePoints;

/** @public */
export declare type AnyGeoTile = GeoTile | GeoTileInit | GeoTileTuple;

/**
 * Either an [[InputSettings]] instance, or an [[InputSettingsInit]] object
 * initializer.
 * @public
 */
export declare type AnyInputSettings = InputSettings | InputSettingsInit;

/** @public */
export declare type AnyInterpreter = Interpreter | AnyItem;

/**
 * Either an [[InterpreterSettings]] instance, or an [[InterpreterSettingsInit]]
 * object initializer.
 * @public
 */
export declare type AnyInterpreterSettings = InterpreterSettings | InterpreterSettingsInit;

/** @public */
export declare type AnyItem = Item | {
    readonly $key: AnyValue;
    readonly $value: AnyValue;
} | {
    readonly [key: string]: AnyValue;
} | ReadonlyArray<AnyItem> | Uint8Array | string | number | boolean | null | undefined;

/** @public */
export declare type AnyLength = Length | string | number;

/** @public */
export declare type AnyNum = Num | number;

/**
 * Either an [[OutputSettings]] instance, or an [[OutputSettingsInit]] object
 * initializer.
 * @public
 */
export declare type AnyOutputSettings = OutputSettings | OutputSettingsInit;

/** @public */
export declare type AnyR2Box = R2Box | R2BoxInit;

/** @public */
export declare type AnyR2Circle = R2Circle | R2CircleInit;

/** @public */
export declare type AnyR2Path = R2Path | string;

/** @public */
export declare type AnyR2Point = R2Point | R2PointInit | R2PointTuple;

/** @public */
export declare type AnyR2Segment = R2Segment | R2SegmentInit;

/** @public */
export declare type AnyR2Shape = R2Shape | R2PointInit | R2PointTuple | R2SegmentInit | R2BoxInit | R2CircleInit;

/** @public */
export declare type AnyR2Vector = R2Vector | R2VectorInit;

/** @public */
export declare type AnyRange<Y> = Range_2<Y> | readonly [Y, Y];

/** @public */
export declare type AnyRecord = Record_2 | {
    readonly [key: string]: AnyValue;
} | ReadonlyArray<AnyItem>;

/** @public */
export declare type AnyText = Text_2 | string;

/** @public */
export declare type AnyTimeZone = TimeZone | string | number;

/** @public */
export declare type AnyTiming = Timing | TimingInit;

/** @public */
export declare type AnyTransform = Transform | string;

/** @public */
export declare type AnyUri = Uri | UriInit | string;

/** @public */
export declare type AnyUriAuthority = UriAuthority | UriAuthorityInit | string;

/** @public */
export declare type AnyUriFragment = UriFragment | string;

/** @public */
export declare type AnyUriHost = UriHost | string;

/** @public */
export declare type AnyUriPath = UriPath | string[] | string;

/** @public */
export declare type AnyUriPort = UriPort | number | string;

/** @public */
export declare type AnyUriQuery = UriQuery | {
    [key: string]: string;
} | string;

/** @public */
export declare type AnyUriScheme = UriScheme | string;

/** @public */
export declare type AnyUriUser = UriUser | UriUserInit | string;

/** @public */
export declare type AnyValue = Value | {
    readonly [key: string]: AnyValue;
} | ReadonlyArray<AnyItem> | Uint8Array | string | number | boolean | null | undefined;

/** @internal */
export declare interface ArrayInterpolator<Y> extends Interpolator<ReadonlyArray<Y>> {
    /** @internal */
    readonly interpolators: ReadonlyArray<Interpolator<Y>>;
    readonly 0: ReadonlyArray<Y>;
    readonly 1: ReadonlyArray<Y>;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const ArrayInterpolator: {
    <Y>(y0: readonly Y[], y1: readonly Y[]): ArrayInterpolator<Y>;
    /** @internal */
    prototype: ArrayInterpolator<any>;
};

/**
 * Utilities for immutably updating, comparing, and hashing arrays.
 * @public
 */
export declare const Arrays: {
    readonly empty: ReadonlyArray<never>;
    /**
     * Returns a copy of an array with the given element inserted, if the element
     * is not already present in the arrary; otherwise returns the input array if
     * it already containts the specified element.
     */
    inserted<T>(newElement: T, oldArray: readonly T[] | null | undefined): readonly T[];
    /**
     * Returns a copy of an array with the given element removed; returns the
     * input array if it does not contain the specified element.
     */
    removed<T_1>(oldElement: T_1, oldArray: readonly T_1[] | null | undefined): readonly T_1[];
    /**
     * Returns `true` if `x` and `y` are structurally equal arrays; otherwise
     * returns `x === y` if either `x` or `y` is not an array.
     */
    equal(x: ArrayLike<unknown> | null | undefined, y: ArrayLike<unknown> | null | undefined): boolean;
    /**
     * Returns `true` if `x` and `y` are structurally [[Equivalent.equivalentTo
     * equivalent]] arrays; otherwise returns `x === y` if either `x` or `y` is
     * not an array.
     */
    equivalent(x: ArrayLike<unknown> | null | undefined, y: ArrayLike<unknown> | null | undefined, epsilon?: number | undefined): boolean;
    /**
     * Returns the relative order of `x` with respect to `y`. Returns `-1` if
     * the elements of array `x` order lexicographically before the elements of
     * array `y`; returns `1` if the elements of array `x` order lexicographically
     * after the elements of array `y`; and returns `0` if `x` and `y` are equal
     * arrays. If either `x` or `y` is `null` or `undefined`, then arrays order
     * before `null`, and `null` orders before `undefined`.
     */
    compare(x: ArrayLike<unknown> | null | undefined, y: ArrayLike<unknown> | null | undefined): number;
    /**
     * Returns a 32-bit hash value for the elements of array `x`, if defined;
     * otherwise returns `0` or `1` if `x` is `undefined` or `null`, respectively.
     */
    hash(x: ArrayLike<unknown> | null | undefined): number;
};

/**
 * Type that implements common assertion functions.
 * @public
 */
export declare interface Assert {
    /**
     * Asserts that `condition` is truthy.
     *
     * @throws [[AssertException]] with `message` if `condition` is falsy.
     */
    ok(condition: unknown, message?: string): void;
    /**
     * Asserts that `condition` is falsy.
     *
     * @throws [[AssertException]] with `message` if `condition` is truthy.
     */
    notOk(condition: unknown, message?: string): void;
    /**
     * Asserts that `lhs` is identical (`===`) to `rhs`.
     *
     * @throws [[AssertException]] with `message` if `lhs` is not identical (`!==`) to `rhs`.
     */
    identical(lhs: unknown, rhs: unknown, message?: string): void;
    /**
     * Asserts that `lhs` is not identical (`!==`) to `rhs`.
     *
     * @throws [[AssertException]] with `message` if `lhs` is identical (`===`) to `rhs`.
     */
    notIdentical(lhs: unknown, rhs: unknown, message?: string): void;
    /**
     * Asserts that `object` has the prototype of `constructor` in its prototype chain.
     *
     * @throws [[AssertException]] with `message` if `object` does not have the prototype of `constructor` in its prototype chain.
     */
    instanceOf(object: unknown, constructor: Function, message?: string): void;
    /**
     * Asserts that `object` does not have the prototype of `constructor` in its prototype chain.
     *
     * @throws [[AssertException]] with `message` if `object` does have the prototype of `constructor` in its prototype chain.
     */
    notInstanceOf(object: unknown, constructor: Function, message?: string): void;
    /**
     * Asserts that `lhs` is [[Values.equal structurally equal]] to `rhs`.
     *
     * @throws [[AssertException]] with `message` if `lhs` is not structurally equal to `rhs`.
     */
    equal(lhs: unknown, rhs: unknown, message?: string): void;
    /**
     * Asserts that `lhs` is not [[Values.equal structurally equal]] to `rhs`.
     *
     * @throws [[AssertException]] with `message` if `lhs` is structurally equal to `rhs`.
     */
    notEqual(lhs: unknown, rhs: unknown, message?: string): void;
    /**
     * Asserts that `lhs` is [[Values.equivalent structurally equivalent]] to `rhs`.
     *
     * @throws [[AssertException]] with `message` if `lhs` is not structurally equivalent to `rhs`.
     */
    equivalent(lhs: unknown, rhs: unknown, message?: string): void;
    /**
     * Asserts that `lhs` is not [[Values.equivalent structurally equivalent]] to `rhs`.
     *
     * @throws [[AssertException]] with `message` if `lhs` is structurally equivalent to `rhs`.
     */
    notEquivalent(lhs: unknown, rhs: unknown, message?: string): void;
    /**
     * Asserts that `lhs` [[Values.compare structurally orders before]] `rhs`.
     *
     * @throws [[AssertException]] with `message` if `lhs` does not structurally order before `rhs`.
     */
    compareLessThan(lhs: unknown, rhs: unknown, message?: string): void;
    /**
     * Asserts that `lhs` does not [[Values.compare structurally order before]] `rhs`.
     *
     * @throws [[AssertException]] with `message` if `lhs` does structurally order before `rhs`.
     */
    compareNotLessThan(lhs: unknown, rhs: unknown, message?: string): void;
    /**
     * Asserts that `lhs` [[Values.compare structurally orders before or the same as]] `rhs`.
     *
     * @throws [[AssertException]] with `message` if `lhs` does not structurally order before or the same as `rhs`.
     */
    compareLessThanOrEqual(lhs: unknown, rhs: unknown, message?: string): void;
    /**
     * Asserts that `lhs` does not [[Values.compare structurally order before or the same as]] `rhs`.
     *
     * @throws [[AssertException]] with `message` if `lhs` does structurally order before or the same as `rhs`.
     */
    compareNotLessThanOrEqual(lhs: unknown, rhs: unknown, message?: string): void;
    /**
     * Asserts that `lhs` [[Values.compare structurally orders the same as]] `rhs`.
     *
     * @throws [[AssertException]] with `message` if `lhs` does not structurally order before or the same as `rhs`.
     */
    compareEqual(lhs: unknown, rhs: unknown, message?: string): void;
    /**
     * Asserts that `lhs` does not [[Values.compare structurally order the same as]] `rhs`.
     *
     * @throws [[AssertException]] with `message` if `lhs` does structurally order before or the same as `rhs`.
     */
    compareNotEqual(lhs: unknown, rhs: unknown, message?: string): void;
    /**
     * Asserts that `lhs` [[Values.compare structurally orders after or the same as]] `rhs`.
     *
     * @throws [[AssertException]] with `message` if `lhs` does not structurally order after or the same as `rhs`.
     */
    compareGreaterThanOrEqual(lhs: unknown, rhs: unknown, message?: string): void;
    /**
     * Asserts that `lhs` does not [[Values.compare structurally order after or the same as]] `rhs`.
     *
     * @throws [[AssertException]] with `message` if `lhs` does structurally order after or the same as `rhs`.
     */
    compareNotGreaterThanOrEqual(lhs: unknown, rhs: unknown, message?: string): void;
    /**
     * Asserts that `lhs` [[Values.compare structurally orders after]] `rhs`.
     *
     * @throws [[AssertException]] with `message` if `lhs` does not structurally order after `rhs`.
     */
    compareGreaterThan(lhs: unknown, rhs: unknown, message?: string): void;
    /**
     * Asserts that `lhs` does not [[Values.compare structurally order after]] `rhs`.
     *
     * @throws [[AssertException]] with `message` if `lhs` does structurally order after `rhs`.
     */
    compareNotGreaterThan(lhs: unknown, rhs: unknown, message?: string): void;
}

/**
 * General `Assert` implementation. When called as a function, asserts that
 * `condition` is truthy.
 *
 * @throws [[AssertException]] with `message` if `condition` is falsy.
 * @public
 */
export declare const assert: Assert & AssertFunction;

/**
 * Exception thrown when an [[Assert]] fails.
 * @public
 */
export declare class AssertException extends Error {
    constructor(message?: string);
}

/**
 * Callable assertion function.
 *
 * @throws [[AssertException]] if the assertion fails.
 * @public
 */
export declare interface AssertFunction {
    (condition: unknown, message?: string): void;
}

/** @public */
declare class Attr_2 extends Field {
    constructor(key: Text_2, value: Value, flags?: number);
    isConstant(): boolean;
    get name(): string;
    readonly key: Text_2;
    readonly value: Value;
    /** @internal */
    readonly flags: number;
    setValue(newValue: Value): Value;
    updatedValue(value: Value): Attr_2;
    bitwiseOr(that: AnyItem): Item;
    bitwiseXor(that: AnyItem): Item;
    bitwiseAnd(that: AnyItem): Item;
    plus(that: AnyItem): Item;
    minus(that: AnyItem): Item;
    times(that: AnyItem): Item;
    divide(that: AnyItem): Item;
    modulo(that: AnyItem): Item;
    not(): Item;
    bitwiseNot(): Item;
    negative(): Item;
    positive(): Item;
    inverse(): Item;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    toAny(): AnyField;
    isAliased(): boolean;
    isMutable(): boolean;
    alias(): void;
    branch(): Attr_2;
    clone(): Attr_2;
    commit(): this;
    interpolateTo(that: Attr_2): Interpolator<Attr_2>;
    interpolateTo(that: Item): Interpolator<Item>;
    interpolateTo(that: unknown): Interpolator<Item> | null;
    get typeOrder(): number;
    compareTo(that: Item): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    keyEquals(key: unknown): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    static of(key: AnyText, value?: AnyValue): Attr_2;
}
export { Attr_2 as Attr }

/** @internal */
export declare interface AttrInterpolator extends Interpolator<Attr_2> {
    /** @internal */
    readonly keyInterpolator: Interpolator<Text_2>;
    /** @internal */
    readonly valueInterpolator: Interpolator<Value>;
    readonly 0: Attr_2;
    readonly 1: Attr_2;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const AttrInterpolator: {
    (y0: Attr_2, y1: Attr_2): AttrInterpolator;
    /** @internal */
    prototype: AttrInterpolator;
};

/** @public */
export declare class AuthedResponse extends HostAddressed<AuthedResponse> {
    static readonly tag: string;
}

/** @public */
export declare const authenticate: typeof client.authenticate;

/** @public */
export declare class AuthRequest extends HostAddressed<AuthRequest> {
    static readonly tag: string;
}

/**
 * Base-10 (decimal) encoding [[Parser]]/[[Writer]] factory.
 * @public
 */
export declare const Base10: {
    /**
     * Returns `true` if the Unicode code point `c` is a valid base-10 digit.
     */
    isDigit(c: number): boolean;
    /**
     * Returns the decimal quantity between `0` (inclusive) and `10` (exclusive)
     * represented by the base-10 digit `c`.
     *
     * @throws `Error` if `c` is not a valid base-10 digit.
     */
    decodeDigit(c: number): number;
    /**
     * Returns the Unicode code point of the base-10 digit that encodes the given
     * decimal quantity between `0` (inclusive) and `10` (exclusive).
     */
    encodeDigit(b: number): number;
    /**
     * Returns the number of whole decimal digits in the given absolute `value`.
     */
    countDigits(value: number): number;
    integerParser(): Parser<number>;
    parseInteger(input: Input): Parser<number>;
    decimalParser(): Parser<number>;
    parseDecimal(input: Input): Parser<number>;
    numberParser(): Parser<number>;
    parseNumber(input: Input): Parser<number>;
    /**
     * Returns a `Writer` that, when fed an input `number` value, returns a
     * continuation that writes the base-10 (decimal) encoding of the input value.
     */
    integerWriter(): Writer<number, unknown>;
    /**
     * Returns a `Writer` that, when fed an input `number` value, returns a
     * continuation that writes the base-10 (decimal) encoding of the input value.
     */
    integerWriter(input: number): Writer<unknown, number>;
    /**
     * Writes the base-10 (decimal) encoding of the `input` value to the `output`,
     * returning a `Writer` continuation that knows how to write any remaining
     * output that couldn't be immediately generated.
     */
    writeInteger(output: Output, input: number): Writer;
};

/** @internal */
export declare class Base10IntegerWriter extends Writer {
    /** @internal */
    readonly value: unknown;
    /** @internal */
    readonly input: number;
    /** @internal */
    readonly index: number;
    /** @internal */
    readonly step: number;
    constructor(value: unknown, input: number, index?: number, step?: number);
    pull(output: Output): Writer;
    static write(output: Output, value: unknown, input: number, index?: number, step?: number): Writer;
}

/** @internal */
export declare class Base10NumberParser extends Parser<number> {
    /** @internal */
    readonly sign: number;
    /** @internal */
    readonly value: number;
    /** @internal */
    readonly mode: number;
    /** @internal */
    readonly step: number;
    constructor(sign?: number, value?: number, mode?: number, step?: number);
    feed(input: Input): Parser<number>;
    static parse(input: Input, sign?: number, value?: number, mode?: number, step?: number): Parser<number>;
}

/**
 * Base-16 (hexadecimal) encoding [[Parser]]/[[Writer]] factory.
 * @public
 */
export declare class Base16 {
    constructor(alphabet: string);
    /**
     * Returns a 16 character string, where the character at index `i` is the
     * encoding of the base-16 digit `i`.
     */
    readonly alphabet: string;
    /**
     * Returns the Unicode code point of the base-16 digit that encodes the given
     * 4-bit quantity.
     */
    encodeDigit(b: number): number;
    /**
     * Returns a `Writer` that, when fed an input `Uint8Array`, returns a
     * continuation that writes the base-16 (hexadecimal) encoding of the input
     * byte array.
     */
    uint8ArrayWriter(): Writer<Uint8Array, unknown>;
    /**
     * Returns a `Writer` continuation that writes the base-16 (hexadecimal)
     * encoding of the `input` `Uint8Array`.
     */
    uint8ArrayWriter(input: Uint8Array): Writer<unknown, Uint8Array>;
    /**
     * Writes the base-16 (hexadecimal) encoding of the `input` `Uint8Array` to
     * the `output`, returning a `Writer` continuation that knows how to write any
     * remaining output that couldn't be immediately generated.
     */
    writeUint8Array(output: Output, input: Uint8Array): Writer<unknown, unknown>;
    writeInteger(output: Output, input: number, width?: number): Writer<unknown, unknown>;
    writeIntegerLiteral(output: Output, input: number, width?: number): Writer<unknown, unknown>;
    /**
     * Returns the `Base16` encoding with lowercase alphanumeric digits.
     */
    static get lowercase(): Base16;
    /**
     * Returns the `Base16` encoding with uppercase alphanumeric digits.
     */
    static get uppercase(): Base16;
    /**
     * Returns `true` if the Unicode code point `c` is a valid base-16 digit.
     */
    static isDigit(c: number): boolean;
    /**
     * Returns the 4-bit quantity represented by the base-16 digit `c`.
     *
     * @throws `Error` if `c` is not a valid base-16 digit.
     */
    static decodeDigit(c: number): number;
    /**
     * Decodes the base-16 digits `c1` and `c2`, and writes the 8-bit  quantity
     * they represent to the given `output`.
     *
     * @returns the continuation of the `output`.
     */
    static writeQuantum<T>(output: Output<T>, c1: number, c2: number): Output<T>;
    /**
     * Returns a `Parser` that decodes base-16 (hexadecimal) encoded input, and
     * writes the decoded bytes to `output`.
     */
    static parser<O>(output: Output<O>): Parser<O>;
    /**
     * Parses the base-16 (hexadecimal) encoded `input`, and writes the decoded
     * bytes to `output`, returning a `Parser` continuation that knows how to
     * parse any additional input.
     */
    static parse<O>(input: Input, output: Output<O>): Parser<O>;
    /**
     * Parses the base-16 (hexadecimal) encoded `input`, and writes the decoded
     * bytes to a growable array, returning a `Parser` continuation that knows
     * how to parse any additional input. The returned `Parser` [[Parser.bind
     * binds]] a `Uint8Array` array containing all parsed base-16 data.
     */
    static parseUint8Array(input: Input): Parser<Uint8Array>;
}

/** @internal */
export declare class Base16IntegerWriter extends Writer {
    /** @internal */
    readonly base16: Base16;
    /** @internal */
    readonly value: unknown;
    /** @internal */
    readonly input: number;
    /** @internal */
    readonly width: number;
    /** @internal */
    readonly index: number;
    /** @internal */
    readonly step: number;
    constructor(base16: Base16, value: unknown, input: number, width: number, index?: number, step?: number);
    pull(output: Output): Writer;
    static write(output: Output, base16: Base16, value: unknown, input: number, width: number, index?: number, step?: number): Writer;
    static writeLiteral(output: Output, base16: Base16, value: unknown, input: number, width: number): Writer;
}

/** @internal */
export declare class Base16Parser<O> extends Parser<O> {
    /** @internal */
    readonly output: Output<O>;
    /** @internal */
    readonly p: number;
    /** @internal */
    readonly step: number;
    constructor(output: Output<O>, p?: number, step?: number);
    feed(input: Input): Parser<O>;
    static parse<O>(input: Input, output: Output<O>, p?: number, step?: number): Parser<O>;
}

/** @internal */
export declare class Base16Writer extends Writer {
    /** @internal */
    readonly base16: Base16;
    /** @internal */
    readonly value: unknown;
    /** @internal */
    readonly input: Uint8Array | null;
    /** @internal */
    readonly index: number;
    /** @internal */
    readonly step: number;
    constructor(base16: Base16, value: unknown, input: Uint8Array | null, index?: number, step?: number);
    feed(value: unknown): Writer;
    pull(output: Output): Writer;
    static write(output: Output, base16: Base16, value: unknown, input: Uint8Array, index?: number, step?: number): Writer;
}

/**
 * Base-64 (7-bit ASCII) encoding [[Parser]]/[[Writer]] factory.
 * @public
 */
export declare abstract class Base64 {
    /**
     * The 64 character string, where the character at index `i` is the encoding
     * of the base-64 digit `i`.
     */
    abstract readonly alphabet: string;
    /**
     * Returns `true` if this base-64 encoding requires padding.
     */
    abstract isPadded(): boolean;
    /**
     * Returns this `Base64` encoding with required padding, if `padded` is `true`.
     */
    abstract asPadded(padded: boolean): Base64;
    /**
     * Returns `true` if the Unicode code point `c` is a valid base-64 digit.
     */
    abstract isDigit(c: number): boolean;
    /**
     * Returns the 7-bit quantity represented by the base-64 digit `c`.
     *
     * @throws `Error` if `c` is not a valid base-64 digit.
     */
    decodeDigit(c: number): number;
    /**
     * Returns the Unicode code point of the base-64 digit that encodes the given
     * 7-bit quantity.
     */
    encodeDigit(b: number): number;
    /**
     * Decodes the base-64 digits `c1`, `c2`, `c3`, and `c4`, and writes the 8 to
     * 24 bit quantity they represent to the given `output`.
     *
     * @returns the continuation of the `output`.
     */
    writeQuantum<T>(output: Output<T>, c1: number, c2: number, c3: number, c4: number): Output<T>;
    /**
     * Returns a `Parser` that decodes base-64 (7-bit ASCII) encoded input, and
     * writes the decoded bytes to `output`.
     */
    parser<O>(output: Output<O>): Parser<O>;
    /**
     * Parses the base-64 (7-bit ASCII) encoded `input`, and writes the decoded
     * bytes to `output`, returning a `Parser` continuation that knows how to
     * parse any additional input.
     */
    parse<O>(input: Input, output: Output<O>): Parser<O>;
    /**
     * Parses the base-64 (7-bit ASCII) encoded `input`, and writes the decoded
     * bytes to a growable array, returning a `Parser` continuation that knows
     * how to parse any additional input. The returned `Parser` [[Parser.bind
     * binds]] a `Uint8Array` array containing all parsed base-64 data.
     */
    parseUint8Array(input: Input): Parser<Uint8Array>;
    /**
     * Returns a `Writer` that, when fed an input `Uint8Array`, returns a
     * continuation that writes the base-64 (7-bit ASCII) encoding of the input
     * `Uint8Array`.
     */
    uint8ArrayWriter(): Writer<Uint8Array, unknown>;
    /**
     * Returns a `Writer` continuation that writes the base-64 (7-bit ASCII)
     * encoding of the `input` byte array.
     */
    uint8ArrayWriter(input: Uint8Array): Writer<unknown, Uint8Array>;
    /**
     * Writes the base-64 (7-bit ASCII) encoding of the `input` `Uint8Array` to
     * the `output`, returning a `Writer` continuation that knows how to write
     * any remaining output that couldn't be immediately generated.
     */
    writeUint8Array(output: Output, input: Uint8Array): Writer;
    /** @internal */
    static get standardPadded(): Base64;
    /** @internal */
    static get standardUnpadded(): Base64;
    /**
     * Returns the `Base64` encoding with the standard alphabet, and required
     * padding, if `isPadding` is `true`.
     */
    static standard(padded?: boolean): Base64;
    /** @internal */
    static get urlPadded(): Base64;
    /** @internal */
    static get urlUnpadded(): Base64;
    /**
     * Returns the `Base64` encoding with the url and filename safe alphabet,
     * and required padding, if `padded` is `true`.
     */
    static url(padded?: boolean): Base64;
}

/** @internal */
export declare class Base64Parser<O> extends Parser<O> {
    /** @internal */
    readonly base64: Base64;
    /** @internal */
    readonly output: Output<O>;
    /** @internal */
    readonly p: number;
    /** @internal */
    readonly q: number;
    /** @internal */
    readonly r: number;
    /** @internal */
    readonly step: number;
    constructor(base64: Base64, output: Output<O>, p?: number, q?: number, r?: number, step?: number);
    feed(input: Input): Parser<O>;
    static parse<O>(input: Input, base64: Base64, output: Output<O>, p?: number, q?: number, r?: number, step?: number): Parser<O>;
}

/** @internal */
export declare class Base64Writer extends Writer {
    /** @internal */
    readonly base64: Base64;
    /** @internal */
    readonly value: unknown;
    /** @internal */
    readonly input: Uint8Array | null;
    /** @internal */
    readonly index: number;
    /** @internal */
    readonly step: number;
    constructor(base64: Base64, value: unknown, input: Uint8Array | null, index?: number, step?: number);
    feed(value: unknown): Writer;
    pull(output: Output): Writer;
    static write(output: Output, base64: Base64, value: unknown, input: Uint8Array, index?: number, step?: number): Writer;
}

/** @public */
export declare abstract class BaseRef implements DownlinkOwner, WarpRef {
    constructor(context: RefContext);
    /** @internal */
    readonly context: RefContext;
    /** @internal */
    readonly host: Host | null;
    /** @internal */
    readonly downlinks: Downlink[];
    /** @internal */
    readonly observers: ReadonlyArray<WarpObserver>;
    abstract readonly hostUri: Uri;
    get connected(): boolean;
    get authenticated(): boolean;
    get session(): Value;
    authenticate(credentials: AnyValue): void;
    abstract downlink(init?: EventDownlinkInit): EventDownlink;
    abstract downlinkList(init?: ListDownlinkInit<Value, AnyValue>): ListDownlink<Value, AnyValue>;
    abstract downlinkList<V extends VU, VU = never>(init?: ListDownlinkInit<V, VU>): ListDownlink<V, VU>;
    abstract downlinkMap(init?: MapDownlinkInit<Value, Value, AnyValue, AnyValue>): MapDownlink<Value, Value, AnyValue, AnyValue>;
    abstract downlinkMap<K extends KU, V extends VU, KU = never, VU = never>(init?: MapDownlinkInit<K, V, KU, VU>): MapDownlink<K, V, KU, VU>;
    abstract downlinkValue(init?: ValueDownlinkInit<Value, AnyValue>): ValueDownlink<Value, AnyValue>;
    abstract downlinkValue<V extends VU, VU = never>(init?: ValueDownlinkInit<V, VU>): ValueDownlink<V, VU>;
    abstract hostRef(hostUri: AnyUri): HostRef;
    abstract nodeRef(hostUri: AnyUri, nodeUri: AnyUri): NodeRef;
    abstract nodeRef(nodeUri: AnyUri): NodeRef;
    abstract laneRef(hostUri: AnyUri, nodeUri: AnyUri, laneUri: AnyUri): LaneRef;
    abstract laneRef(nodeUri: AnyUri, laneUri: AnyUri): LaneRef;
    /** @internal */
    addDownlink(downlink: Downlink): void;
    /** @internal */
    removeDownlink(downlink: Downlink): void;
    open(): void;
    close(): void;
    /** @internal */
    closeUp(): void;
    observe(observer: WarpObserver): this;
    unobserve(observer: unknown): this;
    didConnect(didConnect: WarpDidConnect): this;
    didAuthenticate(didAuthenticate: WarpDidAuthenticate): this;
    didDeauthenticate(didDeauthenticate: WarpDidDeauthenticate): this;
    didDisconnect(didDisconnect: WarpDidDisconnect): this;
    didFail(didFail: WarpDidFail): this;
    /** @internal */
    hostDidConnect(host: Host): void;
    /** @internal */
    hostDidAuthenticate(body: Value, host: Host): void;
    /** @internal */
    hostDidDeauthenticate(body: Value, host: Host): void;
    /** @internal */
    hostDidDisconnect(host: Host): void;
    /** @internal */
    hostDidFail(error: unknown, host: Host): void;
}

/**
 * Byte [[Input]]/[[Output]] factory.
 *
 * The `Binary.outputBuffer(...)` function returns an `Output` that writes
 * bytes to a growable array, and [[Output.bind binds]] a `Uint8Array`
 * containing all written bytes.
 * @public
 */
export declare const Binary: {
    /**
     * Returns a new `Output` that appends bytes to a growable array,
     * pre-allocated with space for `initialCapacity` bytes, if `initialCapacity`
     * is defined, using the given `settings`, if `settings` is defined. The
     * returned `Output` accepts an unbounded number of bytes, remaining
     * permanently in the _cont_ state, and can [[Output.bind bind]] a
     * `Uint8Array` with the current output state at any time.
     */
    output(initialCapacity?: number | undefined, settings?: AnyOutputSettings | undefined): Output<Uint8Array>;
    /**
     * Returns a new `Output` that appends bytes to a growable array,
     * pre-allocated with space for `initialCapacity` bytes, if `initialCapacity`
     * is defined, using the given `settings`, if `settings` is defined. The
     * returned `Output` accepts an unbounded number of bytes, remaining
     * permanently in the _cont_ state, and can [[Output.bind bind]] a
     * `Uint8Array` with the current output state at any time.
     */
    output(settings: AnyOutputSettings): Output<Uint8Array>;
    outputBuffer(array: Uint8Array, offset?: number | undefined, length?: number | undefined): OutputBuffer<Uint8Array>;
};

/** @public */
export declare abstract class BinaryOperator extends Operator {
    constructor(operand1: Item, operand2: Item);
    readonly operand1: Item;
    abstract readonly operator: string;
    readonly operand2: Item;
    isConstant(): boolean;
    interpolateTo(that: BinaryOperator): Interpolator<BinaryOperator>;
    interpolateTo(that: Item): Interpolator<Item>;
    interpolateTo(that: unknown): Interpolator<Item> | null;
}

/** @internal */
export declare interface BinaryOperatorInterpolator extends Interpolator<BinaryOperator> {
    /** @internal */
    readonly operand1Interpolator: Interpolator<Item>;
    /** @internal */
    readonly operator: string;
    /** @internal */
    readonly operand2Interpolator: Interpolator<Item>;
    readonly 0: BinaryOperator;
    readonly 1: BinaryOperator;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const BinaryOperatorInterpolator: {
    (y0: BinaryOperator, y1: BinaryOperator): BinaryOperatorInterpolator;
    /** @internal */
    prototype: BinaryOperatorInterpolator;
};

/** @internal */
export declare abstract class BinaryOutlet extends AbstractOutlet<Value> {
    constructor();
    readonly operand1Inlet: Inlet<Value>;
    readonly operand2Inlet: Inlet<Value>;
    get(): Value;
    protected abstract evaluate(argument1: Value, argument2: Value): Item;
}

/** @public */
export declare class BitwiseAndOperator extends BinaryOperator {
    constructor(operand1: Item, operand2: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): BitwiseAndOperator;
}

/** @internal */
export declare class BitwiseAndOutlet extends BinaryOutlet {
    protected evaluate(argument1: Value, argument2: Value): Item;
}

/** @public */
export declare class BitwiseNotOperator extends UnaryOperator {
    constructor(operand: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): BitwiseNotOperator;
}

/** @internal */
export declare class BitwiseNotOutlet extends UnaryOutlet {
    protected evaluate(argument: Value): Item;
}

/** @public */
export declare class BitwiseOrOperator extends BinaryOperator {
    constructor(operand1: Item, operand2: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): BitwiseOrOperator;
}

/** @internal */
export declare class BitwiseOrOutlet extends BinaryOutlet {
    protected evaluate(argument1: Value, argument2: Value): Item;
}

/** @public */
export declare class BitwiseXorOperator extends BinaryOperator {
    constructor(operand1: Item, operand2: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): BitwiseXorOperator;
}

/** @internal */
export declare class BitwiseXorOutlet extends BinaryOutlet {
    protected evaluate(argument1: Value, argument2: Value): Item;
}

/** @public */
export declare class Bool extends Value {
    private constructor();
    isDefinite(): boolean;
    isConstant(): boolean;
    readonly value: boolean;
    stringValue(): string;
    stringValue<T>(orElse: T): string;
    booleanValue(): boolean;
    booleanValue<T>(orElse: T): boolean;
    toAny(): AnyBool;
    valueOf(): boolean;
    conditional(thenTerm: AnyValue, elseTerm: AnyValue): Value;
    conditional(thenTerm: AnyItem, elseTerm: AnyItem): Item;
    or(that: AnyValue): Value;
    or(that: AnyItem): Item;
    and(that: AnyValue): Value;
    and(that: AnyItem): Item;
    not(): Value;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown): boolean;
    equals(that: unknown): boolean;
    /** @internal */
    readonly hashValue: number;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    static get true(): Bool;
    static get false(): Bool;
    static from(value: boolean): Bool;
    static fromAny(value: AnyBool): Bool;
}

/** @internal */
export declare const BooleanAnimator: AnimatorFactory<Animator<any, boolean | null | undefined, string | boolean | null | undefined>>;

/** @internal */
export declare class BooleanForm extends Form<boolean> {
    constructor(unit?: boolean);
    readonly unit: boolean | undefined;
    withUnit(unit: boolean | undefined): Form<boolean>;
    mold(object: boolean, item?: Item): Item;
    cast(item: Item, object?: boolean): boolean | undefined;
}

/** @internal */
export declare const BooleanProperty: PropertyFactory<Property<any, boolean | null | undefined, string | boolean | null | undefined>>;

/**
 * Utilities for comparing and hashing booleans.
 * @public
 */
export declare const Booleans: {
    /**
     * Returns the relative order of `x` with respect to `y`. Returns `-1` if
     * `x` is `true` and `y` is `false`; returns `1` if `x` is `false` and `y`
     * is `true`; and returns `0` if `x` and `y` are equal booleans. If either
     * `x` or `y` is `null` or `undefined`, then booleans order before `null`,
     * and `null` orders before `undefined`.
     */
    compare(x: boolean | null | undefined, y: boolean | null | undefined): number;
    /**
     * Returns a hash code for a number.
     */
    hash(x: boolean | null | undefined): number;
};

/** @public */
export declare abstract class BridgeFunc extends Func {
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
}

/** @public */
export declare class BTree<K = unknown, V = unknown, U = never> extends BTreeContext<K, V> implements ReducedMap<K, V, U> {
    /** @internal */
    root: BTreePage<K, V, U>;
    constructor();
    /** @internal */
    constructor(root: BTreePage<K, V, U>);
    get size(): number;
    isEmpty(): boolean;
    has(key: K): boolean;
    get(key: K): V | undefined;
    getEntry(index: number): [K, V] | undefined;
    firstKey(): K | undefined;
    firstValue(): V | undefined;
    firstEntry(): [K, V] | undefined;
    lastKey(): K | undefined;
    lastValue(): V | undefined;
    lastEntry(): [K, V] | undefined;
    nextKey(key: K): K | undefined;
    nextValue(key: K): V | undefined;
    nextEntry(key: K): [K, V] | undefined;
    previousKey(key: K): K | undefined;
    previousValue(key: K): V | undefined;
    previousEntry(key: K): [K, V] | undefined;
    set(key: K, newValue: V): this;
    delete(key: K): boolean;
    drop(lower: number): this;
    take(upper: number): this;
    clear(): void;
    updated(key: K, newValue: V): BTree<K, V, U>;
    removed(key: K): BTree<K, V, U>;
    cleared(): BTree<K, V, U>;
    reduced(identity: U, accumulator: (result: U, element: V) => U, combiner: (result: U, result2: U) => U): U;
    forEach<T>(callback: (key: K, value: V) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, key: K, value: V) => T | void, thisArg: S): T | undefined;
    forEachKey<T>(callback: (key: K) => T | void): T | undefined;
    forEachKey<T, S>(callback: (this: S, key: K) => T | void, thisArg: S): T | undefined;
    forEachValue<T>(callback: (value: V) => T | void): T | undefined;
    forEachValue<T, S>(callback: (this: S, value: V) => T | void, thisArg: S): T | undefined;
    keys(): Cursor<K>;
    values(): Cursor<V>;
    entries(): Cursor<[K, V]>;
    reverseKeys(): Cursor<K>;
    reverseValues(): Cursor<V>;
    reverseEntries(): Cursor<[K, V]>;
    clone(): BTree<K, V, U>;
    /** @internal */
    protected copy(root: BTreePage<K, V, U>): BTree<K, V, U>;
}

/** @public */
export declare abstract class BTreeContext<K, V> {
    pageSplitSize: number;
    compare(x: K, y: K): number;
    /** @internal */
    pageShouldSplit(page: BTreePage<K, V, unknown>): boolean;
    /** @internal */
    pageShouldMerge(page: BTreePage<K, V, unknown>): boolean;
}

/** @internal */
export declare class BTreeLeaf<K, V, U> extends BTreePage<K, V, U> {
    constructor(slots: ReadonlyArray<[K, V]>, fold: U | undefined);
    /** @internal */
    readonly slots: ReadonlyArray<[K, V]>;
    get arity(): number;
    get size(): number;
    isEmpty(): boolean;
    readonly fold: U | undefined;
    minKey(): K;
    maxKey(): K;
    has(key: K, tree: BTreeContext<K, V>): boolean;
    get(key: K, tree: BTreeContext<K, V>): V | undefined;
    getEntry(index: number): [K, V] | undefined;
    firstEntry(): [K, V] | undefined;
    lastEntry(): [K, V] | undefined;
    nextEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined;
    previousEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined;
    updated(key: K, newValue: V, tree: BTreeContext<K, V>): BTreeLeaf<K, V, U>;
    /** @internal */
    updatedSlot(x: number, key: K, newValue: V): BTreeLeaf<K, V, U>;
    /** @internal */
    insertedSlot(x: number, key: K, newValue: V): BTreeLeaf<K, V, U>;
    removed(key: K, tree: BTreeContext<K, V>): BTreeLeaf<K, V, U>;
    /** @internal */
    removedSlot(x: number): BTreeLeaf<K, V, U>;
    drop(lower: number, tree: BTreeContext<K, V>): BTreeLeaf<K, V, U>;
    take(upper: number, tree: BTreeContext<K, V>): BTreeLeaf<K, V, U>;
    balanced(tree: BTreeContext<K, V>): BTreePage<K, V, U>;
    split(x: number): BTreeNode<K, V, U>;
    splitLeft(x: number): BTreeLeaf<K, V, U>;
    splitRight(x: number): BTreeLeaf<K, V, U>;
    reduced(identity: U, accumulator: (result: U, element: V) => U, combiner: (result: U, result2: U) => U): BTreeLeaf<K, V, U>;
    forEach<T, S>(callback: (this: S, key: K, value: V) => T | void, thisArg: S): T | undefined;
    forEachKey<T, S>(callback: (this: S, key: K) => T | void, thisArg: S): T | undefined;
    forEachValue<T, S>(callback: (this: S, value: V) => T | void, thisArg: S): T | undefined;
    entries(): Cursor<[K, V]>;
    reverseEntries(): Cursor<[K, V]>;
    /** @internal */
    lookup(key: K, tree: BTreeContext<K, V>): number;
}

/** @internal */
export declare class BTreeNode<K, V, U> extends BTreePage<K, V, U> {
    constructor(pages: ReadonlyArray<BTreePage<K, V, U>>, knots: ReadonlyArray<K>, fold: U | undefined, size: number);
    /** @internal */
    readonly pages: ReadonlyArray<BTreePage<K, V, U>>;
    /** @internal */
    readonly knots: ReadonlyArray<K>;
    get arity(): number;
    readonly size: number;
    isEmpty(): boolean;
    readonly fold: U | undefined;
    minKey(): K;
    maxKey(): K;
    has(key: K, tree: BTreeContext<K, V>): boolean;
    get(key: K, tree: BTreeContext<K, V>): V | undefined;
    getEntry(x: number): [K, V] | undefined;
    firstEntry(): [K, V] | undefined;
    lastEntry(): [K, V] | undefined;
    nextEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined;
    previousEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined;
    updated(key: K, newValue: V, tree: BTreeContext<K, V>): BTreeNode<K, V, U>;
    /** @internal */
    updatedPage(x: number, newPage: BTreePage<K, V, U>, oldPage: BTreePage<K, V, U>): BTreeNode<K, V, U>;
    /** @internal */
    updatedPageSplit(x: number, newPage: BTreePage<K, V, U>, oldPage: BTreePage<K, V, U>): BTreeNode<K, V, U>;
    /** @internal */
    updatedPageMerge(x: number, newPage: BTreeNode<K, V, U>, oldPage: BTreePage<K, V, U>): BTreeNode<K, V, U>;
    removed(key: K, tree: BTreeContext<K, V>): BTreePage<K, V, U>;
    /** @internal */
    replacedPage(x: number, newPage: BTreePage<K, V, U>, oldPage: BTreePage<K, V, U>, tree: BTreeContext<K, V>): BTreePage<K, V, U>;
    /** @internal */
    removedPage(x: number, newPage: BTreePage<K, V, U>, oldPage: BTreePage<K, V, U>): BTreeNode<K, V, U>;
    drop(lower: number, tree: BTreeContext<K, V>): BTreePage<K, V, U>;
    take(upper: number, tree: BTreeContext<K, V>): BTreePage<K, V, U>;
    balanced(tree: BTreeContext<K, V>): BTreeNode<K, V, U>;
    split(x: number): BTreeNode<K, V, U>;
    splitLeft(x: number): BTreeNode<K, V, U>;
    splitRight(x: number): BTreeNode<K, V, U>;
    reduced(identity: U, accumulator: (result: U, element: V) => U, combiner: (result: U, result2: U) => U): BTreeNode<K, V, U>;
    forEach<T, S>(callback: (this: S, key: K, value: V) => T | void, thisArg: S): T | undefined;
    forEachKey<T, S>(callback: (this: S, key: K) => T | void, thisArg: S): T | undefined;
    forEachValue<T, S>(callback: (this: S, value: V) => T | void, thisArg: S): T | undefined;
    entries(): Cursor<[K, V]>;
    reverseEntries(): Cursor<[K, V]>;
    /** @internal */
    lookup(key: K, tree: BTreeContext<K, V>): number;
}

/** @internal */
export declare class BTreeNodeCursor<K, V, U> extends NodeCursor<[K, V], BTreePage<K, V, U>> {
    constructor(pages: ReadonlyArray<BTreePage<K, V, U>>, index?: number, childIndex?: number, childCursor?: Cursor<[K, V]> | null);
    protected pageSize(page: BTreePage<K, V, U>): number;
    protected pageCursor(page: BTreePage<K, V, U>): Cursor<[K, V]>;
    protected reversePageCursor(page: BTreePage<K, V, U>): Cursor<[K, V]>;
}

/** @internal */
export declare abstract class BTreePage<K, V, U> {
    abstract readonly arity: number;
    abstract readonly size: number;
    abstract isEmpty(): boolean;
    abstract readonly fold: U | undefined;
    abstract minKey(): K;
    abstract maxKey(): K;
    abstract has(key: K, tree: BTreeContext<K, V>): boolean;
    abstract get(key: K, tree: BTreeContext<K, V>): V | undefined;
    abstract getEntry(index: number): [K, V] | undefined;
    abstract firstEntry(): [K, V] | undefined;
    abstract lastEntry(): [K, V] | undefined;
    abstract nextEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined;
    abstract previousEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined;
    abstract updated(key: K, newValue: V, tree: BTreeContext<K, V>): BTreePage<K, V, U>;
    abstract removed(key: K, tree: BTreeContext<K, V>): BTreePage<K, V, U>;
    abstract drop(lower: number, tree: BTreeContext<K, V>): BTreePage<K, V, U>;
    abstract take(upper: number, tree: BTreeContext<K, V>): BTreePage<K, V, U>;
    abstract balanced(tree: BTreeContext<K, V>): BTreePage<K, V, U>;
    abstract split(index: number): BTreePage<K, V, U>;
    abstract splitLeft(index: number): BTreePage<K, V, U>;
    abstract splitRight(index: number): BTreePage<K, V, U>;
    abstract reduced(identity: U, accumulator: (result: U, element: V) => U, combiner: (result: U, result2: U) => U): BTreePage<K, V, U>;
    abstract forEach<T, S>(callback: (this: S, key: K, value: V) => T | void, thisArg: S): T | undefined;
    abstract forEachKey<T, S>(callback: (this: S, key: K) => T | void, thisArg: S): T | undefined;
    abstract forEachValue<T, S>(callback: (this: S, value: V) => T | void, thisArg: S): T | undefined;
    keys(): Cursor<K>;
    values(): Cursor<V>;
    abstract entries(): Cursor<[K, V]>;
    reverseKeys(): Cursor<K>;
    reverseValues(): Cursor<V>;
    abstract reverseEntries(): Cursor<[K, V]>;
    static empty<K, V, U>(): BTreeLeaf<K, V, U>;
}

/**
 * Type that accumulates input values of type `I`, and binds an output result
 * of type `O`.
 * @public
 */
export declare interface Builder<I, O> {
    /**
     * Adds one or more input values to this builder.
     */
    push(...inputs: I[]): void;
    /**
     * Returns the output result of this builder.
     */
    bind(): O;
}

/**
 * Endianness of multi-byte words.
 * @public
 */
export declare type ByteOrder = "BE" | "LE";

/** @public */
export declare const ByteOrder: {
    /**
     * Most significant byte first.
     */
    readonly BigEndian: ByteOrder;
    /**
     * Least significant byte first.
     */
    readonly LittleEndian: ByteOrder;
    /**
     * `ByteOrder` of the host machine.
     */
    readonly NativeOrder: ByteOrder;
};

/** @internal */
export declare abstract class ByteOutput<T> extends Output<T> {
    constructor(array: Uint8Array | null, size: number, settings: OutputSettings);
    /** @internal */
    readonly array: Uint8Array | null;
    /** @internal */
    readonly size: number;
    isCont(): boolean;
    isFull(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): Output<T>;
    write(b: number | string): Output<T>;
    writeln(string?: string): Output<T>;
    toUint8Array(): Uint8Array;
    cloneArray(): Uint8Array | null;
    readonly settings: OutputSettings;
    withSettings(settings: AnyOutputSettings): Output<T>;
    /** @internal */
    static expand(n: number): number;
}

/** @internal */
export declare class ByteOutputBuffer extends OutputBuffer<Uint8Array> {
    constructor(array: Uint8Array, index: number, limit: number, part: boolean, settings: OutputSettings);
    /** @internal */
    readonly array: Uint8Array;
    /** @internal */
    readonly part: boolean;
    isCont(): boolean;
    isFull(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): OutputBuffer<Uint8Array>;
    readonly index: number;
    withIndex(index: number): OutputBuffer<Uint8Array>;
    readonly limit: number;
    withLimit(limit: number): OutputBuffer<Uint8Array>;
    get capacity(): number;
    get remaining(): number;
    has(index: number): boolean;
    get(index: number): number;
    set(index: number, token: number): void;
    write(token: number | string): OutputBuffer<Uint8Array>;
    writeln(string?: string): OutputBuffer<Uint8Array>;
    step(offset: number): OutputBuffer<Uint8Array>;
    bind(): Uint8Array;
    readonly settings: OutputSettings;
    withSettings(settings: AnyOutputSettings): OutputBuffer<Uint8Array>;
    clone(): OutputBuffer<Uint8Array>;
    static create(array: Uint8Array, offset?: number, length?: number): OutputBuffer<Uint8Array>;
}

/** @internal */
export declare class ByteOutputUint8Array extends ByteOutput<Uint8Array> {
    constructor(array: Uint8Array | null, size: number, settings: OutputSettings);
    bind(): Uint8Array;
    clone(): Output<Uint8Array>;
}

/** @public */
export declare class ChildrenSelector extends Selector {
    constructor(then: Selector);
    readonly then: Selector;
    forSelected<T>(interpreter: Interpreter, callback: (interpreter: Interpreter) => T | undefined): T | undefined;
    forSelected<T, S>(interpreter: Interpreter, callback: (this: S, interpreter: Interpreter) => T | undefined, thisArg: S): T | undefined;
    mapSelected(interpreter: Interpreter, transform: (interpreter: Interpreter) => Item): Item;
    mapSelected<S>(interpreter: Interpreter, transform: (this: S, interpreter: Interpreter) => Item, thisArg: S): Item;
    substitute(interpreter: AnyInterpreter): Item;
    andThen(then: Selector): Selector;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debugThen<T>(output: Output<T>): Output<T>;
    clone(): Selector;
}

/** @public */
export declare type Class<T> = abstract new (...args: any) => T;

/** @public */
export declare const client: WarpClient;

/** @public */
export declare class ClosedSignal extends WorkerAddressed<ClosedSignal> {
    static readonly tag: string;
}

/** @public */
export declare class CloseSignal extends WorkerAddressed<CloseSignal> {
    static readonly tag: string;
}

/** @public */
export declare const command: typeof client.command;

/** @public */
export declare class CommandMessage extends LaneAddressed<CommandMessage> {
    static readonly tag: string;
}

/** @public */
export declare type Comparator<T> = (a: T, b: T) => number;

/**
 * Type that implements a universal partial order.
 * @public
 */
export declare interface Compare {
    /**
     * Returns the relative order of `this` with respect to `that`. Returns `-1`
     * if `this` orders before `that`; returns `1` if `this` orders after `that`;
     * returns `0` if `this` and `that` are equivalent; and returns `NaN` if
     * `this` is not comparable to `that`.
     */
    compareTo(that: unknown): number;
}

/** @public */
export declare const Compare: {
    (x: unknown, y: unknown): number;
    /**
     * Returns `true` if `object` conforms to the [[Compare]] interface.
     */
    is(object: unknown): object is Compare;
};

/** @public */
export declare class Component<C extends Component<C> = Component<any>> implements HashCode, FastenerContext, Initable<ComponentInit>, Observable {
    constructor();
    get componentType(): Class<Component>;
    /** @override */
    readonly observerType?: Class<ComponentObserver>;
    /** @internal */
    readonly uid: number;
    readonly key: string | undefined;
    /** @internal */
    setKey(key: string | undefined): void;
    /** @internal */
    readonly flags: ComponentFlags;
    /** @internal */
    setFlags(flags: ComponentFlags): void;
    readonly parent: C | null;
    /** @internal */
    attachParent(parent: C, nextSibling: C | null): void;
    protected willAttachParent(parent: C): void;
    protected onAttachParent(parent: C): void;
    protected didAttachParent(parent: C): void;
    /** @internal */
    detachParent(parent: C): void;
    protected willDetachParent(parent: C): void;
    protected onDetachParent(parent: C): void;
    protected didDetachParent(parent: C): void;
    readonly nextSibling: C | null;
    /** @internal */
    setNextSibling(nextSibling: C | null): void;
    readonly previousSibling: C | null;
    /** @internal */
    setPreviousSibling(previousSibling: C | null): void;
    readonly firstChild: C | null;
    /** @internal */
    setFirstChild(firstChild: C | null): void;
    readonly lastChild: C | null;
    /** @internal */
    setLastChild(lastChild: C | null): void;
    forEachChild<T>(callback: (child: C) => T | void): T | undefined;
    forEachChild<T, S>(callback: (this: S, child: C) => T | void, thisArg: S): T | undefined;
    /** @internal */
    readonly childMap: Dictionary<C> | null;
    /** @internal */
    protected insertChildMap(child: C): void;
    /** @internal */
    protected removeChildMap(child: C): void;
    getChild<F extends Class<C>>(key: string, childBound: F): InstanceType<F> | null;
    getChild(key: string, childBound?: Class<C>): C | null;
    setChild(key: string, newChild: C | null): C | null;
    appendChild<Child extends C>(child: Child, key?: string): Child;
    appendChild(child: C, key?: string): C;
    prependChild<Child extends C>(child: Child, key?: string): Child;
    prependChild(child: C, key?: string): C;
    insertChild<Child extends C>(child: Child, target: C | null, key?: string): Child;
    insertChild(child: C, target: C | null, key?: string): C;
    replaceChild<Child extends C>(newChild: C, oldChild: Child): Child;
    replaceChild(newChild: C, oldChild: C): C;
    get insertChildFlags(): ComponentFlags;
    protected willInsertChild(child: C, target: C | null): void;
    protected onInsertChild(child: C, target: C | null): void;
    protected didInsertChild(child: C, target: C | null): void;
    /** @internal */
    cascadeInsert(): void;
    removeChild<Child extends C>(child: Child): Child;
    removeChild(child: C): C;
    removeChild(key: string | C): C | null;
    get removeChildFlags(): ComponentFlags;
    protected willRemoveChild(child: C): void;
    protected onRemoveChild(child: C): void;
    protected didRemoveChild(child: C): void;
    removeChildren(): void;
    remove(): void;
    sortChildren(comparator: Comparator<C>): void;
    getSuper<F extends Class<C>>(superBound: F): InstanceType<F> | null;
    getSuper(superBound: Class<C>): C | null;
    getBase<F extends Class<C>>(baseBound: F): InstanceType<F> | null;
    getBase(baseBound: Class<C>): C | null;
    get mounted(): boolean;
    get mountFlags(): ComponentFlags;
    mount(): void;
    /** @internal */
    cascadeMount(): void;
    protected willMount(): void;
    protected onMount(): void;
    protected didMount(): void;
    /** @internal */
    protected mountChildren(): void;
    unmount(): void;
    /** @internal */
    cascadeUnmount(): void;
    protected willUnmount(): void;
    protected onUnmount(): void;
    protected didUnmount(): void;
    /** @internal */
    protected unmountChildren(): void;
    requireUpdate(updateFlags: ComponentFlags, immediate?: boolean): void;
    /** @internal */
    readonly fasteners: {
        [fastenerName: string]: Fastener | undefined;
    } | null;
    /** @override */
    hasFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): boolean;
    /** @override */
    getFastener<F extends Fastener<any>>(fastenerName: string, fastenerBound: Proto<F>): F | null;
    /** @override */
    getFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): Fastener | null;
    /** @override */
    setFastener(fastenerName: string, newFastener: Fastener | null): void;
    /** @internal */
    protected attachFastener(fastenerName: string, fastener: Fastener): void;
    protected willAttachFastener(fastenerName: string, fastener: Fastener): void;
    protected onAttachFastener(fastenerName: string, fastener: Fastener): void;
    protected didAttachFastener(fastenerName: string, fastener: Fastener): void;
    /** @internal */
    protected detachFastener(fastenerName: string, fastener: Fastener): void;
    protected willDetachFastener(fastenerName: string, fastener: Fastener): void;
    protected onDetachFastener(fastenerName: string, fastener: Fastener): void;
    protected didDetachFastener(fastenerName: string, fastener: Fastener): void;
    /** @override */
    getLazyFastener<F extends Fastener<any>>(fastenerName: string, fastenerBound: Proto<F>): F | null;
    /** @override */
    getLazyFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): Fastener | null;
    /** @override */
    getSuperFastener<F extends Fastener<any>>(fastenerName: string, fastenerBound: Proto<F>): F | null;
    /** @override */
    getSuperFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): Fastener | null;
    /** @internal */
    protected mountFasteners(): void;
    /** @internal */
    protected unmountFasteners(): void;
    protected bindFastener(fastener: Fastener): void;
    /** @internal */
    protected bindChildFasteners(child: C, target: C | null): void;
    /** @internal */
    protected bindChildFastener(fastener: Fastener, child: C, target: C | null): void;
    /** @internal */
    protected unbindChildFasteners(child: C): void;
    /** @internal */
    protected unbindChildFastener(fastener: Fastener, child: C): void;
    /** @internal */
    readonly decoherent: ReadonlyArray<Fastener> | null;
    /** @override */
    decohereFastener(fastener: Fastener): void;
    recohereFasteners(t?: number): void;
    /** @internal */
    readonly observers: ReadonlyArray<ObserverType<this>>;
    /** @override */
    observe(observer: ObserverType<this>): void;
    protected willObserve(observer: ObserverType<this>): void;
    protected onObserve(observer: ObserverType<this>): void;
    protected didObserve(observer: ObserverType<this>): void;
    /** @override */
    unobserve(observer: ObserverType<this>): void;
    protected willUnobserve(observer: ObserverType<this>): void;
    protected onUnobserve(observer: ObserverType<this>): void;
    protected didUnobserve(observer: ObserverType<this>): void;
    forEachObserver<T>(callback: (this: this, observer: ObserverType<this>) => T | void): T | undefined;
    callObservers<O, K extends keyof ObserverMethods<O>>(this: this & {
        readonly observerType?: Class<O>;
    }, key: K, ...args: ObserverParameters<O, K>): void;
    /** @override */
    equals(that: unknown): boolean;
    /** @override */
    hashCode(): number;
    /** @override */
    init(init: ComponentInit): void;
    static create<F extends new () => InstanceType<F>>(this: F): InstanceType<F>;
    static fromInit<F extends Class<InstanceType<F>>>(this: F, init: InitType<InstanceType<F>>): InstanceType<F>;
    static fromAny<F extends Class<InstanceType<F>>>(this: F, value: AnyComponent<InstanceType<F>>): InstanceType<F>;
    /** @internal */
    static uid: () => number;
    /** @internal */
    static readonly MountedFlag: ComponentFlags;
    /** @internal */
    static readonly RemovingFlag: ComponentFlags;
    /** @internal */
    static readonly FlagShift: number;
    /** @internal */
    static readonly FlagMask: ComponentFlags;
    static readonly MountFlags: ComponentFlags;
    static readonly InsertChildFlags: ComponentFlags;
    static readonly RemoveChildFlags: ComponentFlags;
}

/** @public */
export declare interface ComponentClass<C extends Component = Component, U = AnyComponent<C>> extends Function, ComponentFactory<C, U> {
    readonly prototype: C;
}

/** @public */
export declare interface ComponentConstructor<C extends Component = Component, U = AnyComponent<C>> extends ComponentClass<C, U> {
    new (): C;
}

/** @public */
export declare type ComponentCreator<F extends Class<C> & Creatable<InstanceType<F>>, C extends Component = Component> = Class<InstanceType<F>> & Creatable<InstanceType<F>>;

/** @public */
export declare interface ComponentFactory<C extends Component = Component, U = AnyComponent<C>> extends Creatable<C>, FromAny<C, U> {
    fromInit(init: InitType<C>): C;
}

/** @public */
export declare type ComponentFlags = number;

/** @public */
export declare interface ComponentInit {
    /** @internal */
    uid?: never;
    type?: Creatable<Component>;
    key?: string;
    children?: AnyComponent[];
}

/** @public */
export declare interface ComponentObserver<C extends Component = Component> extends Observer<C> {
}

/** @public */
export declare interface ComponentRef<O = unknown, C extends Component = Component> extends ComponentRelation<O, C> {
    (): C | null;
    (component: AnyComponent<C> | null, target?: Component | null, key?: string): O;
    /** @override */
    get fastenerType(): Proto<ComponentRef<any, any>>;
    /** @protected @override */
    onInherit(superFastener: Fastener): void;
    readonly component: C | null;
    getComponent(): C;
    setComponent(component: AnyComponent<C> | null, target?: Component | null, key?: string): C | null;
    attachComponent(component?: AnyComponent<C>, target?: Component | null): C;
    detachComponent(): C | null;
    insertComponent(parent?: Component, component?: AnyComponent<C>, target?: Component | null, key?: string): C;
    removeComponent(): C | null;
    deleteComponent(): C | null;
    /** @internal @override */
    bindComponent(component: Component, target: Component | null): void;
    /** @internal @override */
    unbindComponent(component: Component): void;
    /** @override */
    detectComponent(component: Component): C | null;
    /** @internal */
    get key(): string | undefined;
}

/** @public */
export declare const ComponentRef: ComponentRefFactory<ComponentRef<any, any>>;

/** @public */
export declare interface ComponentRefClass<F extends ComponentRef<any, any> = ComponentRef<any, any>> extends ComponentRelationClass<F> {
}

/** @public */
export declare type ComponentRefDescriptor<O = unknown, C extends Component = Component, I = {}> = ThisType<ComponentRef<O, C> & I> & ComponentRefInit<C> & Partial<I>;

/** @public */
export declare interface ComponentRefFactory<F extends ComponentRef<any, any> = ComponentRef<any, any>> extends ComponentRefClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ComponentRefFactory<F> & I;
    define<O, C extends Component = Component>(className: string, descriptor: ComponentRefDescriptor<O, C>): ComponentRefFactory<ComponentRef<any, C>>;
    define<O, C extends Component = Component>(className: string, descriptor: {
        observes: boolean;
    } & ComponentRefDescriptor<O, C, ObserverType<C>>): ComponentRefFactory<ComponentRef<any, C>>;
    define<O, C extends Component = Component, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ComponentRefDescriptor<O, C, I>): ComponentRefFactory<ComponentRef<any, C> & I>;
    define<O, C extends Component = Component, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & ComponentRefDescriptor<O, C, I & ObserverType<C>>): ComponentRefFactory<ComponentRef<any, C> & I>;
    <O, C extends Component = Component>(descriptor: ComponentRefDescriptor<O, C>): PropertyDecorator;
    <O, C extends Component = Component>(descriptor: {
        observes: boolean;
    } & ComponentRefDescriptor<O, C, ObserverType<C>>): PropertyDecorator;
    <O, C extends Component = Component, I = {}>(descriptor: {
        implements: unknown;
    } & ComponentRefDescriptor<O, C, I>): PropertyDecorator;
    <O, C extends Component = Component, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & ComponentRefDescriptor<O, C, I & ObserverType<C>>): PropertyDecorator;
}

/** @public */
export declare interface ComponentRefInit<C extends Component = Component> extends ComponentRelationInit<C> {
    extends?: {
        prototype: ComponentRef<any, any>;
    } | string | boolean | null;
    key?: string | boolean;
}

/** @internal */
export declare type ComponentRefType<F extends ComponentRef<any, any>> = F extends ComponentRef<any, infer C> ? C : never;

/** @public */
export declare interface ComponentRelation<O = unknown, C extends Component = Component> extends Fastener<O> {
    /** @override */
    get fastenerType(): Proto<ComponentRelation<any, any>>;
    /** @protected */
    initComponent(component: C): void;
    /** @protected */
    willAttachComponent(component: C, target: Component | null): void;
    /** @protected */
    onAttachComponent(component: C, target: Component | null): void;
    /** @protected */
    didAttachComponent(component: C, target: Component | null): void;
    /** @protected */
    deinitComponent(component: C): void;
    /** @protected */
    willDetachComponent(component: C): void;
    /** @protected */
    onDetachComponent(component: C): void;
    /** @protected */
    didDetachComponent(component: C): void;
    /** @internal @protected */
    get parentComponent(): Component | null;
    /** @internal @protected */
    insertChild(parent: Component, child: C, target: Component | null, key: string | undefined): void;
    /** @internal */
    bindComponent(component: Component, target: Component | null): void;
    /** @internal */
    unbindComponent(component: Component): void;
    detectComponent(component: Component): C | null;
    createComponent(): C;
    /** @internal @protected */
    fromAny(value: AnyComponent<C>): C;
    /** @internal @protected */
    get type(): ComponentFactory<C> | undefined;
    /** @internal @protected */
    get binds(): boolean | undefined;
    /** @internal @protected */
    get observes(): boolean | undefined;
    /** @internal @override */
    get lazy(): boolean;
    /** @internal @override */
    get static(): string | boolean;
}

/** @public */
export declare const ComponentRelation: ComponentRelationFactory<ComponentRelation<any, any>>;

/** @public */
export declare interface ComponentRelationClass<F extends ComponentRelation<any, any> = ComponentRelation<any, any>> extends FastenerClass<F> {
}

/** @public */
export declare type ComponentRelationDescriptor<O = unknown, C extends Component = Component, I = {}> = ThisType<ComponentRelation<O, C> & I> & ComponentRelationInit<C> & Partial<I>;

/** @public */
export declare interface ComponentRelationFactory<F extends ComponentRelation<any, any> = ComponentRelation<any, any>> extends ComponentRelationClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ComponentRelationFactory<F> & I;
    define<O, C extends Component = Component>(className: string, descriptor: ComponentRelationDescriptor<O, C>): ComponentRelationFactory<ComponentRelation<any, C>>;
    define<O, C extends Component = Component>(className: string, descriptor: {
        observes: boolean;
    } & ComponentRelationDescriptor<O, C, ObserverType<C>>): ComponentRelationFactory<ComponentRelation<any, C>>;
    define<O, C extends Component = Component, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ComponentRelationDescriptor<O, C, I>): ComponentRelationFactory<ComponentRelation<any, C> & I>;
    define<O, C extends Component = Component, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & ComponentRelationDescriptor<O, C, I & ObserverType<C>>): ComponentRelationFactory<ComponentRelation<any, C> & I>;
    <O, C extends Component = Component>(descriptor: ComponentRelationDescriptor<O, C>): PropertyDecorator;
    <O, C extends Component = Component>(descriptor: {
        observes: boolean;
    } & ComponentRelationDescriptor<O, C, ObserverType<C>>): PropertyDecorator;
    <O, C extends Component = Component, I = {}>(descriptor: {
        implements: unknown;
    } & ComponentRelationDescriptor<O, C, I>): PropertyDecorator;
    <O, C extends Component = Component, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & ComponentRelationDescriptor<O, C, I & ObserverType<C>>): PropertyDecorator;
}

/** @public */
export declare interface ComponentRelationInit<C extends Component = Component> extends FastenerInit {
    extends?: {
        prototype: ComponentRelation<any, any>;
    } | string | boolean | null;
    type?: ComponentFactory<C>;
    binds?: boolean;
    observes?: boolean;
    initComponent?(component: C): void;
    willAttachComponent?(component: C, target: Component | null): void;
    didAttachComponent?(component: C, target: Component | null): void;
    deinitComponent?(component: C): void;
    willDetachComponent?(component: C): void;
    didDetachComponent?(component: C): void;
    parentComponent?: Component | null;
    insertChild?(parent: Component, child: C, target: Component | null, key: string | undefined): void;
    detectComponent?(component: Component): C | null;
    createComponent?(): C;
    fromAny?(value: AnyComponent<C>): C;
}

/** @internal */
export declare type ComponentRelationType<F extends ComponentRelation<any, any>> = F extends ComponentRelation<any, infer C> ? C : never;

/** @public */
export declare interface ComponentSet<O = unknown, C extends Component = Component> extends ComponentRelation<O, C> {
    (component: AnyComponent<C>): O;
    /** @override */
    get fastenerType(): Proto<ComponentSet<any, any>>;
    /** @internal */
    readonly components: {
        readonly [componentId: number]: C | undefined;
    };
    readonly componentCount: number;
    hasComponent(component: Component): boolean;
    addComponent(component?: AnyComponent<C>, target?: Component | null, key?: string): C;
    attachComponent(component?: AnyComponent<C>, target?: Component | null): C;
    detachComponent(component: C): C | null;
    insertComponent(parent?: Component | null, component?: AnyComponent<C>, target?: Component | null, key?: string): C;
    removeComponent(component: C): C | null;
    deleteComponent(component: C): C | null;
    /** @internal @override */
    bindComponent(component: Component, target: Component | null): void;
    /** @internal @override */
    unbindComponent(component: Component): void;
    /** @override */
    detectComponent(component: Component): C | null;
    /** @internal @protected */
    key(component: C): string | undefined;
    get sorted(): boolean;
    /** @internal */
    initSorted(sorted: boolean): void;
    sort(sorted?: boolean): this;
    /** @protected */
    willSort(parent: Component | null): void;
    /** @protected */
    onSort(parent: Component | null): void;
    /** @protected */
    didSort(parent: Component | null): void;
    /** @internal @protected */
    sortChildren(parent: Component): void;
    /** @internal */
    compareChildren(a: Component, b: Component): number;
    /** @internal @protected */
    compare(a: C, b: C): number;
}

/** @public */
export declare const ComponentSet: ComponentSetFactory<ComponentSet<any, any>>;

/** @public */
export declare interface ComponentSetClass<F extends ComponentSet<any, any> = ComponentSet<any, any>> extends ComponentRelationClass<F> {
    /** @internal */
    readonly SortedFlag: FastenerFlags;
    /** @internal @override */
    readonly FlagShift: number;
    /** @internal @override */
    readonly FlagMask: FastenerFlags;
}

/** @public */
export declare type ComponentSetDescriptor<O = unknown, C extends Component = Component, I = {}> = ThisType<ComponentSet<O, C> & I> & ComponentSetInit<C> & Partial<I>;

/** @public */
export declare interface ComponentSetFactory<F extends ComponentSet<any, any> = ComponentSet<any, any>> extends ComponentSetClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ComponentSetFactory<F> & I;
    define<O, C extends Component = Component>(className: string, descriptor: ComponentSetDescriptor<O, C>): ComponentSetFactory<ComponentSet<any, C>>;
    define<O, C extends Component = Component>(className: string, descriptor: {
        observes: boolean;
    } & ComponentSetDescriptor<O, C, ObserverType<C>>): ComponentSetFactory<ComponentSet<any, C>>;
    define<O, C extends Component = Component, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ComponentSetDescriptor<O, C, I>): ComponentSetFactory<ComponentSet<any, C> & I>;
    define<O, C extends Component = Component, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & ComponentSetDescriptor<O, C, I & ObserverType<C>>): ComponentSetFactory<ComponentSet<any, C> & I>;
    <O, C extends Component = Component>(descriptor: ComponentSetDescriptor<O, C>): PropertyDecorator;
    <O, C extends Component = Component>(descriptor: {
        observes: boolean;
    } & ComponentSetDescriptor<O, C, ObserverType<C>>): PropertyDecorator;
    <O, C extends Component = Component, I = {}>(descriptor: {
        implements: unknown;
    } & ComponentSetDescriptor<O, C, I>): PropertyDecorator;
    <O, C extends Component = Component, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & ComponentSetDescriptor<O, C, I & ObserverType<C>>): PropertyDecorator;
}

/** @public */
export declare interface ComponentSetInit<C extends Component = Component> extends ComponentRelationInit<C> {
    extends?: {
        prototype: ComponentSet<any, any>;
    } | string | boolean | null;
    key?(component: C): string | undefined;
    compare?(a: C, b: C): number;
    sorted?: boolean;
    willSort?(parent: Component | null): void;
    didSort?(parent: Component | null): void;
    sortChildren?(parent: Component): void;
    compareChildren?(a: Component, b: Component): number;
}

/** @internal */
export declare type ComponentSetType<F extends ComponentSet<any, any>> = F extends ComponentSet<any, infer C> ? C : never;

/** @public */
export declare class ConditionalOperator extends Operator {
    constructor(ifTerm: Item, thenTerm: Item, elseTerm: Item);
    readonly ifTerm: Item;
    readonly thenTerm: Item;
    readonly elseTerm: Item;
    isConstant(): boolean;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    interpolateTo(that: ConditionalOperator): Interpolator<ConditionalOperator>;
    interpolateTo(that: Item): Interpolator<Item>;
    interpolateTo(that: unknown): Interpolator<Item> | null;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): ConditionalOperator;
}

/** @internal */
export declare interface ConditionalOperatorInterpolator extends Interpolator<ConditionalOperator> {
    /** @internal */
    readonly ifTermInterpolator: Interpolator<Item>;
    /** @internal */
    readonly thenTermInterpolator: Interpolator<Item>;
    /** @internal */
    readonly elseTermInterpolator: Interpolator<Item>;
    readonly 0: ConditionalOperator;
    readonly 1: ConditionalOperator;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const ConditionalOperatorInterpolator: {
    (y0: ConditionalOperator, y1: ConditionalOperator): ConditionalOperatorInterpolator;
    /** @internal */
    prototype: ConditionalOperatorInterpolator;
};

/** @internal */
export declare class ConditionalOutlet extends AbstractOutlet<Value> {
    constructor();
    readonly ifInlet: Inlet<Value>;
    readonly thenInlet: Inlet<Value>;
    readonly elseInlet: Inlet<Value>;
    get(): Value;
}

/** @public */
export declare class ConnectedSignal extends WorkerAddressed<ConnectedSignal> {
    static readonly tag: string;
}

/** @public */
export declare class ConnectSignal extends WorkerAddressed<ConnectSignal> {
    static readonly tag: string;
}

/** @public */
export declare class Constraint implements ConstraintId, Debug {
    constructor(scope: ConstraintScope, expression: ConstraintExpression, relation: ConstraintRelation, strength: ConstraintStrength);
    readonly id: number;
    readonly scope: ConstraintScope;
    readonly expression: ConstraintExpression;
    readonly relation: ConstraintRelation;
    readonly strength: ConstraintStrength;
    isConstrained(): boolean;
    constrain(constrained?: boolean): this;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
}

/** @public */
export declare interface ConstraintAnimator<O = unknown, T = unknown, U = T> extends Animator<O, T, U>, ConstraintVariable {
    /** @internal @override */
    readonly id: number;
    /** @internal @override */
    isExternal(): boolean;
    /** @internal @override */
    isDummy(): boolean;
    /** @internal @override */
    isInvalid(): boolean;
    /** @override */
    isConstant(): boolean;
    /** @internal @override */
    evaluateConstraintVariable(): void;
    /** @internal @override */
    updateConstraintSolution(value: number): void;
    /** @override */
    readonly strength: ConstraintStrength;
    setStrength(strength: AnyConstraintStrength): void;
    /** @override */
    get coefficient(): number;
    /** @override */
    get variable(): ConstraintVariable | null;
    /** @override */
    get terms(): ConstraintMap<ConstraintVariable, number>;
    /** @override */
    get constant(): number;
    /** @override */
    plus(that: AnyConstraintExpression): ConstraintExpression;
    /** @override */
    negative(): ConstraintTerm;
    /** @override */
    minus(that: AnyConstraintExpression): ConstraintExpression;
    /** @override */
    times(scalar: number): ConstraintExpression;
    /** @override */
    divide(scalar: number): ConstraintExpression;
    get constrained(): boolean;
    constrain(constrained?: boolean): this;
    /** @internal */
    readonly conditionCount: number;
    /** @internal @override */
    addConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;
    /** @internal @override */
    removeConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;
    /** @internal */
    get constraining(): boolean;
    /** @internal */
    startConstraining(): void;
    /** @protected */
    willStartConstraining(): void;
    /** @protected */
    onStartConstraining(): void;
    /** @protected */
    didStartConstraining(): void;
    /** @internal */
    stopConstraining(): void;
    /** @protected */
    willStopConstraining(): void;
    /** @protected */
    onStopConstraining(): void;
    /** @protected */
    didStopConstraining(): void;
    /** @internal */
    updateConstraintVariable(): void;
    /** @protected @override */
    onSetValue(newValue: T, oldValue: T): void;
    /** @protected @override */
    onMount(): void;
    /** @protected @override */
    onUnmount(): void;
    /** @override */
    fromAny(value: T | U): T;
    /** @internal @protected */
    toNumber(value: T): number;
}

/** @public */
export declare const ConstraintAnimator: ConstraintAnimatorFactory<ConstraintAnimator<any, any, any>>;

/** @public */
export declare interface ConstraintAnimatorClass<A extends ConstraintAnimator<any, any> = ConstraintAnimator<any, any>> extends AnimatorClass<A> {
    /** @internal */
    readonly ConstrainedFlag: FastenerFlags;
    /** @internal */
    readonly ConstrainingFlag: FastenerFlags;
    /** @internal @override */
    readonly FlagShift: number;
    /** @internal @override */
    readonly FlagMask: FastenerFlags;
}

/** @public */
export declare type ConstraintAnimatorDescriptor<O = unknown, T = unknown, U = T, I = {}> = ThisType<ConstraintAnimator<O, T, U> & I> & ConstraintAnimatorInit<T, U> & Partial<I>;

/** @public */
export declare interface ConstraintAnimatorFactory<A extends ConstraintAnimator<any, any> = ConstraintAnimator<any, any>> extends ConstraintAnimatorClass<A> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ConstraintAnimatorFactory<A> & I;
    specialize(type: unknown): ConstraintAnimatorFactory | null;
    define<O, T, U = T>(className: string, descriptor: ConstraintAnimatorDescriptor<O, T, U>): ConstraintAnimatorFactory<ConstraintAnimator<any, T, U>>;
    define<O, T, U = T, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ConstraintAnimatorDescriptor<O, T, U, I>): ConstraintAnimatorFactory<ConstraintAnimator<any, T, U> & I>;
    <O, T extends number | undefined = number | undefined, U extends number | string | undefined = number | string | undefined>(descriptor: {
        type: typeof Number;
    } & ConstraintAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = T>(descriptor: ({
        type: FromAny<T, U>;
    } | {
        fromAny(value: T | U): T;
    }) & ConstraintAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = T>(descriptor: ConstraintAnimatorDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = T, I = {}>(descriptor: {
        implements: unknown;
    } & ConstraintAnimatorDescriptor<O, T, U, I>): PropertyDecorator;
}

/** @public */
export declare interface ConstraintAnimatorInit<T = unknown, U = T> extends AnimatorInit<T, U> {
    extends?: {
        prototype: ConstraintAnimator<any, any>;
    } | string | boolean | null;
    constrain?: boolean;
    strength?: AnyConstraintStrength;
    willStartConstraining?(): void;
    didStartConstraining?(): void;
    willStopConstraining?(): void;
    didStopConstraining?(): void;
    toNumber?(value: T): number;
}

/** @public */
export declare class ConstraintConstant implements ConstraintTerm, Debug {
    constructor(constant: number);
    isConstant(): boolean;
    get coefficient(): number;
    get variable(): ConstraintVariable | null;
    get terms(): ConstraintMap<ConstraintVariable, number>;
    readonly constant: number;
    plus(that: AnyConstraintExpression): ConstraintExpression;
    negative(): ConstraintTerm;
    minus(that: AnyConstraintExpression): ConstraintExpression;
    times(scalar: number): ConstraintExpression;
    divide(scalar: number): ConstraintExpression;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
}

/** @beta */
export declare interface ConstraintContext {
    activateConstraint(constraint: Constraint): void;
    deactivateConstraint(constraint: Constraint): void;
    activateConstraintVariable(variable: ConstraintVariable): void;
    deactivateConstraintVariable(variable: ConstraintVariable): void;
    setConstraintVariable(variable: ConstraintVariable, state: number): void;
}

/** @internal */
export declare class ConstraintDummy implements ConstraintSymbol {
    constructor();
    readonly id: number;
    isExternal(): boolean;
    isDummy(): boolean;
    isInvalid(): boolean;
    addConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;
    removeConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;
    updateConstraintSolution(value: number): void;
}

/** @internal */
export declare class ConstraintError implements ConstraintSymbol {
    constructor();
    readonly id: number;
    isExternal(): boolean;
    isDummy(): boolean;
    isInvalid(): boolean;
    addConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;
    removeConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;
    updateConstraintSolution(value: number): void;
}

/** @public */
export declare interface ConstraintExpression {
    readonly terms: ConstraintMap<ConstraintVariable, number>;
    readonly constant: number;
    isConstant(): boolean;
    plus(that: AnyConstraintExpression): ConstraintExpression;
    negative(): ConstraintExpression;
    minus(that: AnyConstraintExpression): ConstraintExpression;
    times(scalar: number): ConstraintExpression;
    divide(scalar: number): ConstraintExpression;
}

/** @public */
export declare const ConstraintExpression: {
    fromAny(value: AnyConstraintExpression): ConstraintExpression;
    sum(...expressions: AnyConstraintExpression[]): ConstraintSum;
    product(coefficient: number, variable: ConstraintVariable): ConstraintProduct;
    constant(value: number): ConstraintConstant;
    readonly zero: ConstraintConstant;
};

/** @beta */
export declare class ConstraintGroup {
    constructor(scope: ConstraintScope);
    readonly scope: ConstraintScope;
    constraint(lhs: AnyConstraintExpression, relation: ConstraintRelation, rhs?: AnyConstraintExpression, strength?: AnyConstraintStrength): Constraint;
    readonly constraints: ReadonlyArray<Constraint>;
    hasConstraint(constraint: Constraint): boolean;
    addConstraint(constraint: Constraint): void;
    removeConstraint(constraint: Constraint): void;
    /** @internal */
    enableConstraints(): void;
    /** @internal */
    disableConstraints(): void;
    /** @internal */
    readonly constrained: boolean;
    isConstrained(): boolean;
    constrain(constrained?: boolean): this;
}

/** @public */
export declare interface ConstraintId {
    /** @internal */
    readonly id: number;
}

/** @public */
export declare const ConstraintId: {
    /** @internal */
    next(): number;
};

/** @internal */
export declare class ConstraintInvalid implements ConstraintSymbol {
    get id(): number;
    isExternal(): boolean;
    isDummy(): boolean;
    isInvalid(): boolean;
    addConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;
    removeConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;
    updateConstraintSolution(value: number): void;
}

/** @public */
export declare class ConstraintMap<K extends ConstraintId, V> {
    constructor(index?: {
        [id: number]: number | undefined;
    }, array?: Array<[K, V]>);
    /** @internal */
    readonly index: {
        [id: number]: number | undefined;
    };
    /** @internal */
    readonly array: Array<[K, V]>;
    get size(): number;
    isEmpty(): boolean;
    has(key: K): boolean;
    get(key: K): V | undefined;
    getField(key: K): [K, V] | undefined;
    getEntry(k: number): [K, V] | undefined;
    set(key: K, newValue: V): V | undefined;
    delete(key: K): boolean;
    remove(key: K): V | undefined;
    clear(): void;
    forEach<T>(callback: (key: K, value: V) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, key: K, value: V) => T | void, thisArg: S): T | undefined;
    clone(): ConstraintMap<K, V>;
}

/** @public */
export declare class ConstraintProduct implements ConstraintTerm, Debug {
    constructor(coefficient: number, variable: ConstraintVariable);
    isConstant(): boolean;
    readonly coefficient: number;
    readonly variable: ConstraintVariable;
    get terms(): ConstraintMap<ConstraintVariable, number>;
    get constant(): number;
    plus(that: AnyConstraintExpression): ConstraintExpression;
    negative(): ConstraintTerm;
    minus(that: AnyConstraintExpression): ConstraintExpression;
    times(scalar: number): ConstraintExpression;
    divide(scalar: number): ConstraintExpression;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
}

/** @public */
export declare interface ConstraintProperty<O = unknown, T = unknown, U = T> extends Property<O, T, U>, ConstraintVariable {
    /** @internal @override */
    readonly id: number;
    /** @internal @override */
    isExternal(): boolean;
    /** @internal @override */
    isDummy(): boolean;
    /** @internal @override */
    isInvalid(): boolean;
    /** @override */
    isConstant(): boolean;
    /** @internal @override */
    evaluateConstraintVariable(): void;
    /** @internal @override */
    updateConstraintSolution(value: number): void;
    /** @override */
    readonly strength: ConstraintStrength;
    setStrength(strength: AnyConstraintStrength): void;
    /** @override */
    get coefficient(): number;
    /** @override */
    get variable(): ConstraintVariable | null;
    /** @override */
    get terms(): ConstraintMap<ConstraintVariable, number>;
    /** @override */
    get constant(): number;
    /** @override */
    plus(that: AnyConstraintExpression): ConstraintExpression;
    /** @override */
    negative(): ConstraintTerm;
    /** @override */
    minus(that: AnyConstraintExpression): ConstraintExpression;
    /** @override */
    times(scalar: number): ConstraintExpression;
    /** @override */
    divide(scalar: number): ConstraintExpression;
    get constrained(): boolean;
    constrain(constrained?: boolean): this;
    /** @internal */
    readonly conditionCount: number;
    /** @internal @override */
    addConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;
    /** @internal @override */
    removeConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;
    /** @internal */
    get constraining(): boolean;
    /** @internal */
    startConstraining(): void;
    /** @protected */
    willStartConstraining(): void;
    /** @protected */
    onStartConstraining(): void;
    /** @protected */
    didStartConstraining(): void;
    /** @internal */
    stopConstraining(): void;
    /** @protected */
    willStopConstraining(): void;
    /** @protected */
    onStopConstraining(): void;
    /** @protected */
    didStopConstraining(): void;
    /** @internal */
    updateConstraintVariable(): void;
    /** @protected @override */
    onSetValue(newValue: T, oldValue: T): void;
    /** @protected @override */
    onMount(): void;
    /** @protected @override */
    onUnmount(): void;
    /** @override */
    fromAny(value: T | U): T;
    /** @internal @protected */
    toNumber(value: T): number;
}

/** @public */
export declare const ConstraintProperty: ConstraintPropertyFactory<ConstraintProperty<any, any, any>>;

/** @public */
export declare interface ConstraintPropertyClass<P extends ConstraintProperty<any, any> = ConstraintProperty<any, any>> extends PropertyClass<P> {
    /** @internal */
    readonly ConstrainedFlag: FastenerFlags;
    /** @internal */
    readonly ConstrainingFlag: FastenerFlags;
    /** @internal @override */
    readonly FlagShift: number;
    /** @internal @override */
    readonly FlagMask: FastenerFlags;
}

/** @public */
export declare type ConstraintPropertyDescriptor<O = unknown, T = unknown, U = T, I = {}> = ThisType<ConstraintProperty<O, T, U> & I> & ConstraintPropertyInit<T, U> & Partial<I>;

/** @public */
export declare interface ConstraintPropertyFactory<P extends ConstraintProperty<any, any> = ConstraintProperty<any, any>> extends ConstraintPropertyClass<P> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ConstraintPropertyFactory<P> & I;
    specialize(type: unknown): ConstraintPropertyFactory | null;
    define<O, T, U = T>(className: string, descriptor: ConstraintPropertyDescriptor<O, T, U>): ConstraintPropertyFactory<ConstraintProperty<any, T, U>>;
    define<O, T, U = T, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ConstraintPropertyDescriptor<O, T, U, I>): ConstraintPropertyFactory<ConstraintProperty<any, T, U> & I>;
    <O, T extends number | undefined = number | undefined, U extends number | string | undefined = number | string | undefined>(descriptor: {
        type: typeof Number;
    } & ConstraintPropertyDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = T>(descriptor: ({
        type: FromAny<T, U>;
    } | {
        fromAny(value: T | U): T;
    }) & ConstraintPropertyDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = T>(descriptor: ConstraintPropertyDescriptor<O, T, U>): PropertyDecorator;
    <O, T, U = T, I = {}>(descriptor: {
        implements: unknown;
    } & ConstraintPropertyDescriptor<O, T, U, I>): PropertyDecorator;
}

/** @public */
export declare interface ConstraintPropertyInit<T = unknown, U = T> extends PropertyInit<T, U> {
    extends?: {
        prototype: ConstraintProperty<any, any>;
    } | string | boolean | null;
    constrain?: boolean;
    strength?: AnyConstraintStrength;
    willStartConstraining?(): void;
    didStartConstraining?(): void;
    willStopConstraining?(): void;
    didStopConstraining?(): void;
    toNumber?(value: T): number;
}

/** @public */
export declare type ConstraintRelation = "le" | "eq" | "ge";

/** @internal */
export declare class ConstraintRow {
    constructor(solver: ConstraintSolver, symbol: ConstraintSymbol | null, cells: ConstraintMap<ConstraintSymbol, number>, constant: number);
    readonly solver: ConstraintSolver;
    readonly symbol: ConstraintSymbol | null;
    /** @internal */
    setSymbol(symbol: ConstraintSymbol | null): void;
    readonly cells: ConstraintMap<ConstraintSymbol, number>;
    readonly constant: number;
    /** @internal */
    setConstant(constant: number): void;
    isConstant(): boolean;
    isDummy(): boolean;
    clone(): ConstraintRow;
    add(value: number): number;
    insertSymbol(symbol: ConstraintSymbol, coefficient?: number): void;
    insertRow(that: ConstraintRow, coefficient: number): void;
    removeSymbol(symbol: ConstraintSymbol): void;
    negate(): void;
    solveFor(symbol: ConstraintSymbol): void;
    solveForEx(lhs: ConstraintSymbol, rhs: ConstraintSymbol): void;
    coefficientFor(symbol: ConstraintSymbol): number;
    substitute(symbol: ConstraintSymbol, row: ConstraintRow): void;
    invalidate(): void;
}

/** @public */
export declare interface ConstraintScope {
    constraint(lhs: AnyConstraintExpression, relation: ConstraintRelation, rhs?: AnyConstraintExpression, strength?: AnyConstraintStrength): Constraint;
    hasConstraint(constraint: Constraint): boolean;
    addConstraint(constraint: Constraint): void;
    removeConstraint(constraint: Constraint): void;
    constraintVariable(name: string, value?: number, strength?: AnyConstraintStrength): ConstraintProperty<unknown, number>;
    hasConstraintVariable(variable: ConstraintVariable): boolean;
    addConstraintVariable(variable: ConstraintVariable): void;
    removeConstraintVariable(variable: ConstraintVariable): void;
    setConstraintVariable(variable: ConstraintVariable, state: number): void;
}

/** @public */
export declare const ConstraintScope: {
    is(object: unknown): object is ConstraintScope;
};

/** @internal */
export declare class ConstraintSlack implements ConstraintSymbol {
    constructor();
    readonly id: number;
    isExternal(): boolean;
    isDummy(): boolean;
    isInvalid(): boolean;
    addConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;
    removeConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;
    updateConstraintSolution(value: number): void;
}

/** @public */
export declare class ConstraintSolver implements ConstraintScope {
    constructor();
    /** @internal */
    readonly constraints: ConstraintMap<Constraint, ConstraintTag>;
    /** @internal */
    readonly constraintVariables: ConstraintMap<ConstraintVariable, ConstraintVariableBinding>;
    /** @internal */
    readonly rows: ConstraintMap<ConstraintSymbol, ConstraintRow>;
    /** @internal */
    readonly infeasible: ConstraintSymbol[];
    /** @internal */
    readonly objective: ConstraintRow;
    /** @internal */
    readonly artificial: ConstraintRow | null;
    /** @internal */
    readonly invalidated: ConstraintMap<ConstraintSymbol, ConstraintRow | null>;
    constraint(lhs: AnyConstraintExpression, relation: ConstraintRelation, rhs?: AnyConstraintExpression, strength?: AnyConstraintStrength): Constraint;
    hasConstraint(constraint: Constraint): boolean;
    addConstraint(constraint: Constraint): void;
    /** @internal */
    protected addConstraintRow(constraint: Constraint, row: ConstraintRow, tag: ConstraintTag): void;
    protected willAddConstraint(constraint: Constraint): void;
    protected didAddConstraint(constraint: Constraint): void;
    removeConstraint(constraint: Constraint): void;
    /** @internal */
    protected removeConstraintRow(constraint: Constraint): void;
    protected willRemoveConstraint(constraint: Constraint): void;
    protected didRemoveConstraint(constraint: Constraint): void;
    constraintVariable(name: string, value?: number, strength?: AnyConstraintStrength): ConstraintProperty<unknown, number>;
    hasConstraintVariable(variable: ConstraintVariable): boolean;
    addConstraintVariable(variable: ConstraintVariable): void;
    protected willAddConstraintVariable(variable: ConstraintVariable): void;
    protected didAddConstraintVariable(variable: ConstraintVariable): void;
    removeConstraintVariable(variable: ConstraintVariable): void;
    protected willRemoveConstraintVariable(variable: ConstraintVariable): void;
    protected didRemoveConstraintVariable(variable: ConstraintVariable): void;
    setConstraintVariable(variable: ConstraintVariable, newState: number): void;
    protected willSetConstraintVariable(variable: ConstraintVariable, newState: number, oldState: number): void;
    protected didSetConstraintVariable(variable: ConstraintVariable, newState: number, oldState: number): void;
    /** @internal */
    invalidate(symbol: ConstraintSymbol, row?: ConstraintRow | null): void;
    /** @internal */
    updateSolution(): void;
    private createRow;
    private chooseSubject;
    private addWithArtificialVariable;
    private substitute;
    private optimize;
    private dualOptimize;
    private getEnteringSymbol;
    private getDualEnteringSymbol;
    private getLeavingSymbol;
    private getMarkerLeavingSymbol;
    private removeConstraintEffects;
    private removeMarkerEffects;
    private anyPivotableSymbol;
}

/** @public */
export declare type ConstraintStrength = number;

/** @public */
export declare const ConstraintStrength: {
    readonly Required: number;
    readonly Strong: number;
    readonly Medium: number;
    readonly Weak: number;
    readonly Unbound: number;
    clip(strength: number): number;
    fromAny(strength: AnyConstraintStrength): number;
};

/** @public */
export declare type ConstraintStrengthInit = "required" | "strong" | "medium" | "weak";

/** @public */
export declare class ConstraintSum implements ConstraintExpression, Debug {
    constructor(terms: ConstraintMap<ConstraintVariable, number>, constant: number);
    isConstant(): boolean;
    readonly terms: ConstraintMap<ConstraintVariable, number>;
    readonly constant: number;
    plus(that: AnyConstraintExpression): ConstraintExpression;
    negative(): ConstraintExpression;
    minus(that: AnyConstraintExpression): ConstraintExpression;
    times(scalar: number): ConstraintExpression;
    divide(scalar: number): ConstraintExpression;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
}

/** @public */
export declare interface ConstraintSymbol extends ConstraintId {
    /** @internal */
    isExternal(): boolean;
    /** @internal */
    isDummy(): boolean;
    /** @internal */
    isInvalid(): boolean;
    /** @internal */
    addConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;
    /** @internal */
    removeConstraintCondition(constraint: Constraint, solver: ConstraintSolver): void;
    /** @internal */
    updateConstraintSolution(value: number): void;
}

/** @public */
export declare const ConstraintSymbol: {
    /** @internal */
    readonly invalid: ConstraintSymbol;
};

/** @internal */
export declare interface ConstraintTag {
    readonly marker: ConstraintSymbol;
    readonly other: ConstraintSymbol;
}

/** @public */
export declare interface ConstraintTerm extends ConstraintExpression {
    readonly coefficient: number;
    readonly variable: ConstraintVariable | null;
    negative(): ConstraintTerm;
}

/** @public */
export declare const ConstraintTerm: {
    is(value: unknown): value is ConstraintTerm;
};

/** @public */
export declare interface ConstraintVariable extends ConstraintSymbol, ConstraintTerm {
    readonly name: string;
    readonly strength: ConstraintStrength;
    /** @internal */
    evaluateConstraintVariable(): void;
}

/** @internal */
export declare interface ConstraintVariableBinding {
    readonly constraint: Constraint;
    readonly tag: ConstraintTag;
    state: number;
}

/**
 * Utilities for comparing and hashing constructors.
 * @public
 */
export declare const Constructors: {
    /**
     * Returns the relative order of `x` with respect to `y`. Returns `-1` if
     * the hash code of constructor `x` is less than the hash code of constructor
     * `y`; returns `1` if the hash code of constructor `x` is greater than the
     * hash code of constructor `y`; and returns `0` if `x` and `y` are identical
     * constructors. If either `x` or `y` is `null` or `undefined`, then
     * constructors order before `null`, and `null` orders before `undefined`.
     */
    compare(x: Function | null | undefined, y: Function | null | undefined): number;
    /**
     * Returns a 32-bit hash value for a constructor.
     */
    hash(x: Function | null | undefined): number;
};

/** @public */
export declare interface Consumable {
    readonly consumerType?: Class<Consumer>;
    consume(consumer: ConsumerType<this>): void;
    unconsume(consumer: ConsumerType<this>): void;
}

/** @public */
export declare const Consumable: {
    is(object: unknown): object is Consumable;
};

/** @public */
export declare interface Consumer<O extends Consumable = Consumable> {
}

/** @public */
export declare type ConsumerType<O> = O extends {
    readonly consumerType?: Class<infer T>;
} ? T : never;

/** @public */
export declare interface ContinuousScale<X, Y> extends Scale<X, Y> {
    readonly inverse: Mapping<Y, X>;
    withDomain(domain: Domain<X>): ContinuousScale<X, Y>;
    withDomain(x0: X, x1: X): ContinuousScale<X, Y>;
    overRange(range: Range_2<Y>): ContinuousScale<X, Y>;
    overRange(y0: Y, y1: Y): ContinuousScale<X, Y>;
    clampDomain(xMin: X | undefined, xMax: X | undefined, zMin: number | undefined, zMax: number | undefined, epsilon?: number): ContinuousScale<X, Y>;
    solveDomain(x1: X, y1: Y, x2?: X, y2?: Y, reflect?: boolean, epsilon?: number): ContinuousScale<X, Y>;
    canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
    toString(): string;
}

/** @public */
export declare const ContinuousScale: {
    (): never;
    /** @internal */
    prototype: ContinuousScale<any, any>;
};

/** @public */
export declare interface Creatable<T> {
    create(): T;
}

/** @public */
export declare const Creatable: {
    is<T>(object: unknown): object is Creatable<T>;
};

/** @public */
export declare type CreateType<C> = C extends {
    create(...args: any): infer T;
} ? T : never;

/** @public */
export declare abstract class Cursor<T> implements Iterator_2<T> {
    abstract isEmpty(): boolean;
    abstract head(): T;
    abstract step(): void;
    abstract skip(count: number): void;
    abstract hasNext(): boolean;
    abstract nextIndex(): number;
    abstract next(): {
        value?: T;
        done: boolean;
    };
    abstract hasPrevious(): boolean;
    abstract previousIndex(): number;
    abstract previous(): {
        value?: T;
        done: boolean;
    };
    set(newValue: T): void;
    delete(): void;
    static empty<T>(): Cursor<T>;
    static unary<T>(value: T): Cursor<T>;
    static array<T>(array: ReadonlyArray<T>, index?: number, limit?: number): Cursor<T>;
}

/** @internal */
export declare class CursorArray<T> extends Cursor<T> {
    constructor(array: ReadonlyArray<T>, index: number, limit: number);
    /** @internal */
    readonly array: ReadonlyArray<T>;
    /** @internal */
    index: number;
    /** @internal */
    readonly limit: number;
    isEmpty(): boolean;
    head(): T;
    step(): void;
    skip(count: number): void;
    hasNext(): boolean;
    nextIndex(): number;
    next(): {
        value?: T;
        done: boolean;
    };
    hasPrevious(): boolean;
    previousIndex(): number;
    previous(): {
        value?: T;
        done: boolean;
    };
}

/** @internal */
export declare class CursorEmpty<T> extends Cursor<T> {
    isEmpty(): boolean;
    head(): T;
    step(): void;
    skip(count: number): void;
    hasNext(): boolean;
    nextIndex(): number;
    next(): {
        value?: T;
        done: boolean;
    };
    hasPrevious(): boolean;
    previousIndex(): number;
    previous(): {
        value?: T;
        done: boolean;
    };
}

/** @internal */
export declare class CursorUnary<T> extends Cursor<T> {
    constructor(value: T);
    /** @internal */
    readonly value: T;
    /** @internal */
    index: number;
    isEmpty(): boolean;
    head(): T;
    step(): void;
    skip(count: number): void;
    hasNext(): boolean;
    nextIndex(): number;
    next(): {
        value?: T;
        done: boolean;
    };
    hasPrevious(): boolean;
    previousIndex(): number;
    previous(): {
        value?: T;
        done: boolean;
    };
}

/** @public */
export declare class Data extends Value {
    constructor(array: Uint8Array | null, size: number, flags: number);
    /** @internal */
    readonly array: Uint8Array | null;
    isConstant(): boolean;
    readonly size: number;
    /** @internal */
    readonly flags: number;
    getByte(index: number): number;
    setByte(index: number, value: number): Data;
    /** @internal */
    setByteAliased(index: number, value: number): Data;
    /** @internal */
    setByteMutable(index: number, value: number): Data;
    addByte(value: number): Data;
    /** @internal */
    addByteAliased(value: number): Data;
    /** @internal */
    addByteMutable(value: number): Data;
    addData(data: Data): Data;
    addUint8Array(array: Uint8Array): Data;
    /** @internal */
    addUint8ArrayAliased(array: Uint8Array): Data;
    /** @internal */
    addUint8ArrayMutable(array: Uint8Array): Data;
    clear(): void;
    toUint8Array(): Uint8Array;
    asUint8Array(): Uint8Array | undefined;
    toAny(): AnyData;
    isAliased(): boolean;
    isMutable(): boolean;
    branch(): Data;
    clone(): Data;
    commit(): this;
    writeBase16(output: Output, base16?: Base16): Writer<unknown, unknown>;
    toBase16(base16?: Base16): string;
    writeBase64(output: Output, base64?: Base64): Writer<unknown, unknown>;
    toBase64(base64?: Base64): string;
    interpolateTo(that: Data): Interpolator<Data>;
    interpolateTo(that: Item): Interpolator<Item>;
    interpolateTo(that: unknown): Interpolator<Item> | null;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: Item): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    /** @internal */
    static readonly AliasedFlag: number;
    /** @internal */
    static readonly ImmutableFlag: number;
    static empty(): Data;
    static create(initialCapacity?: number): Data;
    static wrap(value: Uint8Array): Data;
    static fromBase16(input: Input | string): Data;
    static fromBase64(input: Input | string, base64?: Base64): Data;
    static fromAny(value: AnyData): Data;
    static random(size: number): Data;
    static output(): Output<Data>;
    static output(initialCapacity: number): Output<Data>;
    static output(data: Data): Output<Data>;
    /** @internal */
    static expand(n: number): number;
}

/** @public */
export declare const Dataflow: {
    /**
     * Returns an `Outlet` that evaluates the given `expr` in the context of the
     * given `scope`, and updates whenever any dependent expression updates.
     */
    compile(expr: Value, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileSelector(selector: Selector, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileIdentitySelector(scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileGetSelector(selector: GetSelector, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileGetAttrSelector(selector: GetAttrSelector, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileGetItemSelector(selector: GetItemSelector, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileKeysSelector(scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileValuesSelector(scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileChildrenSelector(scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileDescendantsSelector(scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileFilterSelector(selector: FilterSelector, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileOperator(operator: Operator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileConditionalOperator(operator: ConditionalOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileBinaryOperator(operator: BinaryOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileBinaryOutlet(operator: BinaryOperator, outlet: BinaryOutlet, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileOrOperator(operator: OrOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileAndOperator(operator: AndOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileBitwiseOrOperator(operator: BitwiseOrOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileBitwiseXorOperator(operator: BitwiseXorOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileBitwiseAndOperator(operator: BitwiseAndOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileLtOperator(operator: LtOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileLeOperator(operator: LeOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileEqOperator(operator: EqOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileNeOperator(operator: NeOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileGeOperator(operator: GeOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileGtOperator(operator: GtOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compilePlusOperator(operator: PlusOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileMinusOperator(operator: MinusOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileTimesOperator(operator: TimesOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileDivideOperator(operator: DivideOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileModuloOperator(operator: ModuloOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileUnaryOperator(operator: UnaryOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileUnaryOutlet(operator: UnaryOperator, outlet: UnaryOutlet, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileNotOperator(operator: NotOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileBitwiseNotOperator(operator: BitwiseNotOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileNegativeOperator(operator: NegativeOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compilePositiveOperator(operator: PositiveOperator, scope: Outlet<Value>): Outlet<Value>;
    /** @internal */
    compileInvokeOperator(operator: InvokeOperator, scope: Outlet<Value>): Outlet<Value>;
};

/** @internal */
export declare class DataOutput extends Output<Data> {
    constructor(data: Data, settings: OutputSettings);
    /** @internal */
    readonly data: Data;
    isCont(): boolean;
    isFull(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): Output<Data>;
    write(b: number | string): Output<Data>;
    writeln(string?: string): Output<Data>;
    readonly settings: OutputSettings;
    withSettings(settings: AnyOutputSettings): Output<Data>;
    bind(): Data;
    clone(): Output<Data>;
}

/** @internal */
export declare interface DateNumberFactory {
    term(value: number, date: DateTimeInit, input: Input): Parser<DateTimeInit>;
    cont(date: DateTimeInit, value: number, step: number, input: Input): Parser<DateTimeInit>;
}

/** @internal */
export declare interface DateStringFactory {
    term(locale: DateTimeLocale, value: string, date: DateTimeInit, input: Input): Parser<DateTimeInit>;
    cont(locale: DateTimeLocale, date: DateTimeInit, output: Output, input: Input): Parser<DateTimeInit>;
}

/** @public */
export declare class DateTime implements Interpolate<DateTime>, HashCode, Equivalent, Compare, Display {
    constructor(time: number, zone?: TimeZone);
    isDefined(): boolean;
    readonly time: number;
    readonly zone: TimeZone;
    get year(): number;
    withYear(year: number, month?: number, day?: number, hour?: number, minute?: number, second?: number, millisecond?: number): DateTime;
    get month(): number;
    withMonth(month: number, day?: number, hour?: number, minute?: number, second?: number, millisecond?: number): DateTime;
    get day(): number;
    withDay(day: number, hour?: number, minute?: number, second?: number, millisecond?: number): DateTime;
    get hour(): number;
    withHour(hour: number, minute?: number, second?: number, millisecond?: number): DateTime;
    get minute(): number;
    withMinute(minute: number, second?: number, millisecond?: number): DateTime;
    get second(): number;
    withSecond(second: number, millisecond?: number): DateTime;
    get millisecond(): number;
    withMillisecond(millisecond: number): DateTime;
    get weekday(): number;
    /**
     * Returns this date time shifted by the time zone offset.
     * @internal
     */
    toUTCLocalDate(): Date;
    toDate(): Date;
    valueOf(): number;
    interpolateTo(that: DateTime): Interpolator<DateTime>;
    interpolateTo(that: unknown): Interpolator<DateTime> | null;
    compareTo(that: unknown): number;
    equivalentTo(that: AnyDateTime, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    display<T>(output: Output<T>, format?: DateTimeFormat): Output<T>;
    toString(format?: DateTimeFormat): string;
    static current(zone?: AnyTimeZone): DateTime;
    /**
     * Returns this date time shifted back by the time zone offset.
     * @internal
     */
    static fromUTCLocalDate(date: Date, zone: TimeZone): DateTime;
    static fromInit(init: DateTimeInit, zone?: AnyTimeZone): DateTime;
    static fromAny(value: AnyDateTime, zone?: AnyTimeZone): DateTime;
    static fromValue(value: Value): DateTime | null;
    static parse(date: string, zone?: AnyTimeZone): DateTime;
    static time(date: AnyDateTime): number;
    static zone(date: AnyDateTime): TimeZone;
    /** @internal */
    static isInit(value: unknown): value is DateTimeInit;
    /** @internal */
    static isAny(value: unknown): value is AnyDateTime;
    static form(): Form<DateTime, AnyDateTime>;
}

/** @internal */
export declare class DateTimeForm extends Form<DateTime, AnyDateTime> {
    constructor(unit: DateTime | undefined);
    readonly unit: DateTime | undefined;
    withUnit(unit: DateTime | undefined): Form<DateTime, AnyDateTime>;
    mold(date: AnyDateTime): Item;
    cast(value: Value): DateTime | undefined;
}

/** @public */
export declare abstract class DateTimeFormat {
    withLocale(locale: DateTimeLocale): DateTimeFormat;
    format(date: AnyDateTime): string;
    abstract writeDate<T>(output: Output<T>, date: DateTime): Output<T>;
    parse(input: Input | string): DateTime;
    /** @internal */
    parseDate(input: Input, date: DateTimeInit): Parser<DateTime>;
    /** @internal */
    abstract parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit>;
    static get year(): DateTimeFormat;
    static get monthOfYear(): DateTimeFormat;
    static get month(): DateTimeFormat;
    static get shortMonth(): DateTimeFormat;
    static get dayOfMonth(): DateTimeFormat;
    static get weekday(): DateTimeFormat;
    static get shortWeekday(): DateTimeFormat;
    static get hour24(): DateTimeFormat;
    static get hour12(): DateTimeFormat;
    static get period(): DateTimeFormat;
    static get minute(): DateTimeFormat;
    static get second(): DateTimeFormat;
    static get millisecond(): DateTimeFormat;
    static pattern(pattern: string, specifiers?: DateTimeSpecifiers | DateTimeLocale): DateTimeFormat;
    static get iso8601(): DateTimeFormat;
    /** @internal */
    static parseDateNumber(input: Input, factory: DateNumberFactory, desc: string, minDigits: number, maxDigits: number, date: DateTimeInit | undefined, value?: number, step?: number): Parser<DateTimeInit>;
    /** @internal */
    static parseDateString(input: Input, factory: DateStringFactory, locale: DateTimeLocale, date?: DateTimeInit, output?: Output<string>): Parser<DateTimeInit>;
    /** @internal */
    static writeDateNumber2<T>(output: Output<T>, value: number): Output<T>;
    /** @internal */
    static writeDateNumber3<T>(output: Output<T>, value: number): Output<T>;
    /** @internal */
    static writeDateNumber4<T>(output: Output<T>, value: number): Output<T>;
}

/** @public */
export declare interface DateTimeInit {
    year?: number;
    month?: number;
    day?: number;
    hour?: number;
    minute?: number;
    second?: number;
    millisecond?: number;
    zone?: AnyTimeZone;
}

/** @internal */
export declare const DateTimeInterpolator: {
    (d0: DateTime, d1: DateTime): Interpolator<DateTime>;
    /** @internal */
    prototype: Interpolator<DateTime>;
};

/** @public */
export declare class DateTimeLocale {
    readonly periods: ReadonlyArray<string>;
    readonly weekdays: ReadonlyArray<string>;
    readonly shortWeekdays: ReadonlyArray<string>;
    readonly months: ReadonlyArray<string>;
    readonly shortMonths: ReadonlyArray<string>;
    constructor(periods?: ReadonlyArray<string>, weekdays?: ReadonlyArray<string>, shortWeekdays?: ReadonlyArray<string>, months?: ReadonlyArray<string>, shortMonths?: ReadonlyArray<string>);
    static standard(): DateTimeLocale;
    private static readonly Periods;
    private static readonly Weekdays;
    private static readonly ShortWeekdays;
    private static readonly Months;
    private static readonly ShortMonths;
}

/** @internal */
export declare class DateTimeParser extends Parser<DateTime> {
    private readonly dateParser;
    constructor(dateParser: Parser<DateTimeInit>);
    feed(input: Input): Parser<DateTime>;
    static parse(input: Input, dateParser: Parser<DateTimeInit>): Parser<DateTime>;
}

/** @public */
export declare interface DateTimeSpecifiers {
    [symbol: string]: DateTimeFormat | undefined;
    Y: DateTimeFormat;
    m: DateTimeFormat;
    B: DateTimeFormat;
    b: DateTimeFormat;
    d: DateTimeFormat;
    A: DateTimeFormat;
    a: DateTimeFormat;
    H: DateTimeFormat;
    I: DateTimeFormat;
    p: DateTimeFormat;
    M: DateTimeFormat;
    S: DateTimeFormat;
    L: DateTimeFormat;
}

/** @public */
export declare const DateTimeSpecifiers: {
    standard(locale?: DateTimeLocale | undefined): DateTimeSpecifiers;
};

/** @internal */
export declare class DayInterval extends UnitTimeInterval {
    offset(t: AnyDateTime, k?: number): DateTime;
    next(t: AnyDateTime, k?: number): DateTime;
    floor(t: AnyDateTime): DateTime;
    ceil(t: AnyDateTime): DateTime;
    every(k: number): TimeInterval;
    /** @internal */
    static modulo(k: number, d: DateTime): boolean;
}

/** @internal */
export declare class DayOfMonthFormat extends DateTimeFormat {
    writeDate<T>(output: Output<T>, date: DateTime): Output<T>;
    parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit>;
}

/** @internal */
export declare class DayOfMonthParser extends Parser<DateTimeInit> {
    private readonly date;
    private readonly day;
    private readonly step;
    constructor(date?: DateTimeInit, day?: number, step?: number);
    feed(input: Input): Parser<DateTimeInit>;
    static parse(input: Input, date?: DateTimeInit, day?: number, step?: number): Parser<DateTimeInit>;
    static term(day: number, date: DateTimeInit): Parser<DateTimeInit>;
    static cont(date: DateTimeInit, month: number, step: number): Parser<DateTimeInit>;
}

/** @public */
export declare class DeauthedResponse extends HostAddressed<DeauthedResponse> {
    static readonly tag: string;
}

/** @public */
export declare class DeauthRequest extends HostAddressed<DeauthRequest> {
    static readonly tag: string;
}

/**
 * Type that can output a developer readable debug string. `Debug`
 * implementations may use [[Output.settings]] to tailor the format of their
 * debug strings. For example, debug strings may be stylized when
 * [[OutputSettings.isStyled]] returns `true`.
 * @public
 */
export declare interface Debug {
    /**
     * Writes a developer readable, debug-formatted string representation of this
     * object to `output`.
     *
     * @returns the continuation of the `output`.
     * @throws [[OutputException]] if the `output` exits the _cont_ state before
     *         the full debug string has been written.
     */
    debug<T>(output: Output<T>): Output<T>;
}

/** @public */
export declare class DegAngle extends Angle {
    constructor(value: number);
    readonly value: number;
    get units(): AngleUnits;
    degValue(): number;
    gradValue(): number;
    radValue(): number;
    turnValue(): number;
    deg(): DegAngle;
    toCssValue(): CSSUnitValue | null;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static zero(): DegAngle;
}

/** @public */
export declare class DescendantsSelector extends Selector {
    constructor(then: Selector);
    readonly then: Selector;
    forSelected<T>(interpreter: Interpreter, callback: (interpreter: Interpreter) => T | undefined): T | undefined;
    forSelected<T, S>(interpreter: Interpreter, callback: (this: S, interpreter: Interpreter) => T | undefined, thisArg: S): T | undefined;
    mapSelected(interpreter: Interpreter, transform: (interpreter: Interpreter) => Item): Item;
    mapSelected<S>(interpreter: Interpreter, transform: (this: S, interpreter: Interpreter) => Item, thisArg: S): Item;
    substitute(interpreter: AnyInterpreter): Item;
    andThen(then: Selector): Selector;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debugThen<T>(output: Output<T>): Output<T>;
    clone(): Selector;
}

/**
 * Informational message attached to an input location.
 * @public
 */
export declare class Diagnostic implements Display {
    constructor(input: Input, tag: Tag, severity: Severity, message: string | undefined, note: string | undefined, cause: Diagnostic | null);
    /** @internal */
    readonly input: Input;
    /**
     * The location in the `input` to which this diagnostic is attached.
     */
    readonly tag: Tag;
    /**
     * The level of importance of this diagnostic.
     */
    readonly severity: Severity;
    /**
     * The help message that describes this diagnostic.
     */
    readonly message: string | undefined;
    /**
     * An informative comment on the source context to which this diagnostic is attached.
     */
    readonly note: string | undefined;
    /**
     * The `Diagnostic` cause of this diagnostic, forming a linked chain of
     * diagnostics, or `null` if this diagnostic has no cause.
     */
    readonly cause: Diagnostic | null;
    private lineDigits;
    display<T>(output: Output<T>): Output<T>;
    private static display;
    /** @internal */
    static displayMessage<T>(output: Output<T>, severity: Severity, message: string | undefined): Output<T>;
    private static displayAnchor;
    private static displayContext;
    private static displayLines;
    private static displayNote;
    private static displayLine;
    private static displaySingleLine;
    private static displayStartLine;
    private static displayEndLine;
    private static displayMidLine;
    private static displayLineComment;
    private static displayLineLead;
    private static displayLineLeadComment;
    private static displayLineLeadArrow;
    private static displayLineLeadEllipsis;
    private static displayLineLeadNumber;
    private static displayLineText;
    private static consumeLineText;
    private static formatSeverity;
    toString(settings?: OutputSettings): string;
    static create(input: Input, tag: Tag, severity: Severity, cause?: Diagnostic | null): Diagnostic;
    static create(input: Input, tag: Tag, severity: Severity, message: string | undefined, cause?: Diagnostic | null): Diagnostic;
    static create(input: Input, tag: Tag, severity: Severity, message: string | undefined, note: string | undefined, cause?: Diagnostic | null): Diagnostic;
    static message(message: string, input: Input, cause?: Diagnostic | null): Diagnostic;
    static message(message: string, input: Input, note: string, cause?: Diagnostic | null): Diagnostic;
    static message(message: string, input: Input, severity: Severity, cause?: Diagnostic | null): Diagnostic;
    static message(message: string, input: Input, severity?: Severity, note?: string, cause?: Diagnostic | null): Diagnostic;
    static unexpected(input: Input, cause?: Diagnostic | null): Diagnostic;
    static unexpected(input: Input, note: string, cause?: Diagnostic | null): Diagnostic;
    static unexpected(input: Input, severity: Severity, cause?: Diagnostic | null): Diagnostic;
    static unexpected(input: Input, severity?: Severity, note?: string, cause?: Diagnostic | null): Diagnostic;
    static expected(expected: string | number, input: Input, cause?: Diagnostic | null): Diagnostic;
    static expected(expected: string | number, input: Input, note: string, cause?: Diagnostic | null): Diagnostic;
    static expected(expected: string | number, input: Input, severity: Severity, cause?: Diagnostic | null): Diagnostic;
    static expected(expected: string | number, input: Input, severity?: Severity, note?: string, cause?: Diagnostic | null): Diagnostic;
}

/** @public */
export declare type Dictionary<T> = {
    readonly [key: string]: T | undefined;
};

/** @public */
export declare class DisconnectedSignal extends WorkerAddressed<DisconnectedSignal> {
    static readonly tag: string;
}

/** @public */
export declare class DisconnectSignal extends WorkerAddressed<DisconnectSignal> {
    static readonly tag: string;
}

/**
 * Type that can output a human readable display string. `Display`
 * implementations may use [[Output.settings]] to tailor the format of their
 * display strings. For example, display strings may be stylized when
 * [[OutputSettings.isStyled]] returns `true`.
 * @public
 */
export declare interface Display {
    /**
     * Writes a human readable, display-formatted string representation of this
     * object to `output`.
     *
     * @returns the continuation of the `output`.
     * @throws [[OutputException]] if the `output` exits the _cont_ state before
     *         the full display string has been written.
     */
    display<T>(output: Output<T>): Output<T>;
}

/** @public */
export declare class DivideOperator extends BinaryOperator {
    constructor(operand1: Item, operand2: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): DivideOperator;
}

/** @internal */
export declare class DivideOutlet extends BinaryOutlet {
    protected evaluate(argument1: Value, argument2: Value): Item;
}

/** @public */
export declare interface Domain<X> extends Mapping<X, number> {
    readonly 0: X;
    readonly 1: X;
    readonly domain: this;
    readonly range: LinearRange;
    contains(x: X): boolean;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
    toString(): string;
}

/** @public */
export declare const Domain: {
    <X>(x0: X, x1: X): Domain<X>;
    /** @internal */
    prototype: Domain<any>;
    readonly unit: LinearDomain;
};

/** @public */
export declare abstract class Downlink {
    /** @internal */
    constructor(context: DownlinkContext, owner: DownlinkOwner | null, init?: DownlinkInit, hostUri?: Uri, nodeUri?: Uri, laneUri?: Uri, prio?: number, rate?: number, body?: Value, flags?: number, observers?: ReadonlyArray<DownlinkObserver> | DownlinkObserver);
    /** @internal */
    readonly context: DownlinkContext;
    /** @internal */
    readonly owner: DownlinkOwner | null;
    /** @internal */
    readonly ownHostUri: Uri;
    /** @internal */
    readonly ownNodeUri: Uri;
    /** @internal */
    readonly ownLaneUri: Uri;
    /** @internal */
    readonly ownPrio: number;
    /** @internal */
    readonly ownRate: number;
    /** @internal */
    readonly ownBody: Value;
    /** @internal */
    readonly flags: number;
    /** @internal */
    readonly model: DownlinkModel | null;
    /** @internal */
    readonly observers: ReadonlyArray<DownlinkObserver>;
    abstract readonly type: DownlinkType;
    /** @internal */
    protected abstract copy(context: DownlinkContext, owner: DownlinkOwner | null, hostUri: Uri, nodeUri: Uri, laneUri: Uri, prio: number, rate: number, body: Value, flags: number, observers: ReadonlyArray<DownlinkObserver>): Downlink;
    hostUri(): Uri;
    hostUri(hostUri: AnyUri): Downlink;
    nodeUri(): Uri;
    nodeUri(nodeUri: AnyUri): Downlink;
    laneUri(): Uri;
    laneUri(laneUri: AnyUri): Downlink;
    prio(): number;
    prio(prio: number): Downlink;
    rate(): number;
    rate(rate: number): Downlink;
    body(): Value;
    body(body: AnyValue): Downlink;
    keepLinked(): boolean;
    keepLinked(keepLinked: boolean): Downlink;
    keepSynced(): boolean;
    keepSynced(keepSynced: boolean): Downlink;
    observe(observer: DownlinkObserver): this;
    unobserve(observer: unknown): this;
    onEvent(onEvent: DownlinkOnEvent): this;
    onCommand(onCommand: DownlinkOnCommand): this;
    willLink(willLink: DownlinkWillLink): this;
    didLink(didLink: DownlinkDidLink): this;
    willSync(willSync: DownlinkWillSync): this;
    didSync(didSync: DownlinkDidSync): this;
    willUnlink(willUnlink: DownlinkWillUnlink): this;
    didUnlink(didUnlink: DownlinkDidUnlink): this;
    didConnect(didConnect: DownlinkDidConnect): this;
    didDisconnect(didDisconnect: DownlinkDidDisconnect): this;
    didClose(didClose: DownlinkDidClose): this;
    didFail(didFail: DownlinkDidFail): this;
    get connected(): boolean;
    get authenticated(): boolean;
    get linked(): boolean;
    get synced(): boolean;
    get session(): Value;
    /** @internal */
    onEventMessage(message: EventMessage): void;
    /** @internal */
    onCommandMessage(body: Value): void;
    /** @internal */
    onLinkRequest(request?: LinkRequest): void;
    /** @internal */
    onLinkedResponse(response?: LinkedResponse): void;
    /** @internal */
    onSyncRequest(request?: SyncRequest): void;
    /** @internal */
    onSyncedResponse(response?: SyncedResponse): void;
    /** @internal */
    onUnlinkRequest(request?: UnlinkRequest): void;
    /** @internal */
    onUnlinkedResponse(response?: UnlinkedResponse): void;
    /** @internal */
    hostDidConnect(): void;
    /** @internal */
    hostDidDisconnect(): void;
    /** @internal */
    hostDidFail(error: unknown): void;
    command(body: AnyValue): void;
    abstract open(): this;
    close(): void;
    /** @internal */
    openUp(host: Host): void;
    /** @internal */
    closeUp(): void;
    static initForm(): Form<DownlinkInit | undefined>;
}

/** @public */
export declare const downlink: typeof client.downlink;

/** @public */
export declare interface DownlinkContext {
    /** @internal */
    getDownlink(hostUri: Uri, nodeUri: Uri, laneUri: Uri): DownlinkModel | undefined;
    /** @internal */
    openDownlink(downlink: DownlinkModel): void;
    /** @internal */
    unlinkDownlink(downlink: DownlinkModel): void;
    /** @internal */
    closeDownlink(downlink: DownlinkModel): void;
}

/** @public */
export declare type DownlinkDidClose = (downlink: Downlink) => void;

/** @public */
export declare type DownlinkDidConnect = (downlink: Downlink) => void;

/** @public */
export declare type DownlinkDidDisconnect = (downlink: Downlink) => void;

/** @public */
export declare type DownlinkDidFail = (error: unknown, downlink: Downlink) => void;

/** @public */
export declare type DownlinkDidLink = (downlink: Downlink) => void;

/** @public */
export declare type DownlinkDidSync = (downlink: Downlink) => void;

/** @public */
export declare type DownlinkDidUnlink = (downlink: Downlink) => void;

/** @beta */
export declare interface DownlinkFastener<O = unknown> extends Fastener<O>, Consumable {
    /** @override */
    get fastenerType(): Proto<DownlinkFastener<any>>;
    /** @override */
    readonly consumerType?: Class<Consumer>;
    /** @protected @override */
    onInherit(superFastener: Fastener): void;
    /** @internal */
    readonly ownHostUri: Uri | null;
    hostUri(): Uri | null;
    hostUri(hostUri: AnyUri | null): this;
    /** @internal */
    readonly ownNodeUri: Uri | null;
    nodeUri(): Uri | null;
    nodeUri(nodeUri: AnyUri | null): this;
    /** @internal */
    readonly ownLaneUri: Uri | null;
    laneUri(): Uri | null;
    laneUri(laneUri: AnyUri | null): this;
    /** @internal */
    readonly ownPrio: number | undefined;
    prio(): number | undefined;
    prio(prio: number | undefined): this;
    /** @internal */
    readonly ownRate: number | undefined;
    rate(): number | undefined;
    rate(rate: number | undefined): this;
    /** @internal */
    readonly ownBody: Value | null;
    body(): Value | null;
    body(body: AnyValue | null): this;
    /** @internal */
    readonly ownWarp: WarpRef | null;
    warp(): WarpRef | null;
    warp(warp: WarpRef | null): this;
    readonly downlink: Downlink | null;
    /** @internal */
    link(): void;
    /** @internal */
    unlink(): void;
    /** @internal */
    relink(): void;
    /** @internal @abstract */
    createDownlink(warp: WarpRef): Downlink;
    /** @internal */
    bindDownlink(downlink: Downlink): Downlink;
    /** @override */
    recohere(t: number): void;
    /** @internal */
    readonly consumers: ReadonlyArray<ConsumerType<this>>;
    /** @override */
    consume(consumer: ConsumerType<this>): void;
    /** @protected */
    willConsume(consumer: ConsumerType<this>): void;
    /** @protected */
    onConsume(consumer: ConsumerType<this>): void;
    /** @protected */
    didConsume(consumer: ConsumerType<this>): void;
    /** @override */
    unconsume(consumer: ConsumerType<this>): void;
    /** @protected */
    willUnconsume(consumer: ConsumerType<this>): void;
    /** @protected */
    onUnconsume(consumer: ConsumerType<this>): void;
    /** @protected */
    didUnconsume(consumer: ConsumerType<this>): void;
    get consuming(): boolean;
    /** @internal */
    startConsuming(): void;
    /** @protected */
    willStartConsuming(): void;
    /** @protected */
    onStartConsuming(): void;
    /** @protected */
    didStartConsuming(): void;
    /** @internal */
    stopConsuming(): void;
    /** @protected */
    willStopConsuming(): void;
    /** @protected */
    onStopConsuming(): void;
    /** @protected */
    didStopConsuming(): void;
    /** @protected @override */
    onMount(): void;
    /** @protected @override */
    onUnmount(): void;
    /** @internal */
    initDownlink?(downlink: Downlink): Downlink;
    /** @internal */
    initHostUri?(): AnyUri | null;
    /** @internal */
    initNodeUri?(): AnyUri | null;
    /** @internal */
    initLaneUri?(): AnyUri | null;
    /** @internal */
    initPrio?(): number | undefined;
    /** @internal */
    initRate?(): number | undefined;
    /** @internal */
    initBody?(): AnyValue | null;
    /** @internal @protected */
    get consumed(): boolean | undefined;
    /** @internal @override */
    get lazy(): boolean;
    /** @internal @override */
    get static(): string | boolean;
}

/** @beta */
export declare const DownlinkFastener: DownlinkFastenerFactory<DownlinkFastener<any>>;

/** @beta */
export declare interface DownlinkFastenerClass<F extends DownlinkFastener<any> = DownlinkFastener<any>> extends FastenerClass<F> {
    /** @internal */
    readonly ConsumingFlag: FastenerFlags;
    /** @internal */
    readonly PendingFlag: FastenerFlags;
    /** @internal */
    readonly RelinkMask: FastenerFlags;
    /** @internal @override */
    readonly FlagShift: number;
    /** @internal @override */
    readonly FlagMask: FastenerFlags;
}

/** @beta */
export declare interface DownlinkFastenerContext {
    readonly warpProvider: {
        readonly service: WarpService<any>;
    };
    readonly warpRef: {
        readonly value: WarpRef | null;
    };
}

/** @beta */
export declare type DownlinkFastenerDescriptor<O = unknown, I = {}> = ThisType<DownlinkFastener<O> & I> & DownlinkFastenerInit & Partial<I>;

/** @beta */
export declare interface DownlinkFastenerFactory<F extends DownlinkFastener<any> = DownlinkFastener<any>> extends DownlinkFastenerClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): DownlinkFastenerFactory<F> & I;
    define<O>(className: string, descriptor: DownlinkFastenerDescriptor<O>): DownlinkFastenerFactory<DownlinkFastener<any>>;
    define<O, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & DownlinkFastenerDescriptor<O, I>): DownlinkFastenerFactory<DownlinkFastener<any> & I>;
    <O>(descriptor: DownlinkFastenerDescriptor<O>): PropertyDecorator;
    <O, I = {}>(descriptor: {
        implements: unknown;
    } & DownlinkFastenerDescriptor<O, I>): PropertyDecorator;
}

/** @beta */
export declare interface DownlinkFastenerInit extends FastenerInit, DownlinkObserver {
    extends?: {
        prototype: DownlinkFastener<any>;
    } | string | boolean | null;
    consumed?: boolean;
    hostUri?: AnyUri | (() => AnyUri | null);
    nodeUri?: AnyUri | (() => AnyUri | null);
    laneUri?: AnyUri | (() => AnyUri | null);
    prio?: number | (() => number | undefined);
    rate?: number | (() => number | undefined);
    body?: AnyValue | (() => AnyValue | null);
    willConsume?(conssumer: unknown): void;
    didConsume?(conssumer: unknown): void;
    willUnconsume?(conssumer: unknown): void;
    didUnconsume?(conssumer: unknown): void;
    willStartConsuming?(): void;
    didStartConsuming?(): void;
    willStopConsuming?(): void;
    didStopConsuming?(): void;
    initDownlink?(downlink: Downlink): Downlink;
}

/** @internal */
export declare const enum DownlinkFlags {
    KeepLinked = 1,
    KeepSynced = 2,
    KeepLinkedSynced = 3
}

/** @public */
export declare interface DownlinkInit extends DownlinkObserver {
    hostUri?: AnyUri;
    nodeUri?: AnyUri;
    laneUri?: AnyUri;
    prio?: number;
    rate?: number;
    body?: AnyValue;
    type?: DownlinkType;
}

/** @public */
export declare const downlinkList: typeof client.downlinkList;

/** @public */
export declare const downlinkMap: typeof client.downlinkMap;

/** @internal */
export declare abstract class DownlinkModel implements HostDownlink {
    constructor(context: DownlinkContext, hostUri: Uri, nodeUri: Uri, laneUri: Uri, prio?: number, rate?: number, body?: Value);
    readonly context: DownlinkContext;
    readonly hostUri: Uri;
    readonly nodeUri: Uri;
    readonly laneUri: Uri;
    readonly prio: number;
    readonly rate: number;
    readonly body: Value;
    readonly views: ReadonlyArray<Downlink>;
    readonly host: Host | null;
    /** @internal */
    readonly status: number;
    abstract readonly type: DownlinkType;
    keepLinked(): boolean;
    keepSynced(): boolean;
    get unlinkDelay(): number;
    get connected(): boolean;
    get authenticated(): boolean;
    get linked(): boolean;
    get synced(): boolean;
    get session(): Value;
    addDownlink(view: Downlink): void;
    removeDownlink(view: Downlink): void;
    onEventMessage(message: EventMessage, host: Host): void;
    onCommandMessage(body: Value): void;
    onLinkRequest(request: LinkRequest): void;
    onLinkedResponse(response: LinkedResponse, host: Host): void;
    onSyncRequest(request: SyncRequest): void;
    onSyncedResponse(response: SyncedResponse, host: Host): void;
    onUnlinkRequest(request: UnlinkRequest, host: Host): void;
    onUnlinkedResponse(response: UnlinkedResponse, host: Host): void;
    hostDidConnect(host: Host): void;
    hostDidDisconnect(host: Host): void;
    hostDidFail(error: unknown, host: Host): void;
    command(body: AnyValue): void;
    sync(): void;
    link(): void;
    unlink(): void;
    protected doUnlink(): void;
    close(): void;
    openUp(host: Host): void;
    closeUp(): void;
    static readonly Linking: number;
    static readonly Linked: number;
    static readonly Syncing: number;
    static readonly Synced: number;
    static readonly Unlinking: number;
}

/** @public */
export declare interface DownlinkObserver {
    onEvent?: DownlinkOnEvent;
    onCommand?: DownlinkOnCommand;
    willLink?: DownlinkWillLink;
    didLink?: DownlinkDidLink;
    willSync?: DownlinkWillSync;
    didSync?: DownlinkDidSync;
    willUnlink?: DownlinkWillUnlink;
    didUnlink?: DownlinkDidUnlink;
    didConnect?: DownlinkDidConnect;
    didDisconnect?: DownlinkDidDisconnect;
    didClose?: DownlinkDidClose;
    didFail?: DownlinkDidFail;
}

/** @public */
export declare type DownlinkOnCommand = (body: Value, downlink: Downlink) => void;

/** @public */
export declare type DownlinkOnEvent = (body: Value, downlink: Downlink) => void;

/** @public */
export declare interface DownlinkOwner {
    /** @internal */
    addDownlink(downlink: Downlink): void;
    /** @internal */
    removeDownlink(downlink: Downlink): void;
}

/** @public */
export declare abstract class DownlinkRecord extends AbstractRecordOutlet {
    abstract readonly downlink: Downlink;
}

/** @internal */
export declare class DownlinkReifier extends Reifier {
    constructor(warp?: WarpRef | null);
    warp: WarpRef | null;
    reify(item: Item): Item;
    /** @internal */
    reifyField(field: Field): Field;
    /** @internal */
    reifyValue(value: Value): Value;
    /** @internal */
    reifyModel(model: RecordModel): Record_2;
}

/** @public */
export declare class DownlinkStreamlet extends AbstractRecordStreamlet {
    constructor(warp?: WarpRef | null, scope?: StreamletScope<Value> | null);
    warp: WarpRef | null;
    downlink: Downlink | null;
    /** @internal */
    downlinkRecord: DownlinkRecord | null;
    /** @internal */
    inputHostUri: string | undefined;
    /** @internal */
    inputNodeUri: string | undefined;
    /** @internal */
    inputLaneUri: string | undefined;
    /** @internal */
    inputPrio: number | undefined;
    /** @internal */
    inputRate: number | undefined;
    /** @internal */
    inputBody: Value | undefined;
    /** @internal */
    inputType: DownlinkType | undefined;
    hostUri: Inoutlet<Value>;
    nodeUri: Inoutlet<Value>;
    laneUri: Inoutlet<Value>;
    prio: Inoutlet<Value>;
    rate: Inoutlet<Value>;
    bodyValue: Inoutlet<Value>;
    type: Inoutlet<Value>;
    state: Outlet<Value | Map_2<Value, Value>>;
    getOutput(outlet: Outlet<Value> | string): Value | undefined;
    protected onRecohere(version: number): void;
    private static _reifier?;
    /** @beta */
    static reifier(warp?: WarpRef): Reifier;
}

/** @public */
export declare type DownlinkType = "event" | "list" | "map" | "value";

/** @public */
export declare const downlinkValue: typeof client.downlinkValue;

/** @public */
export declare type DownlinkWillLink = (downlink: Downlink) => void;

/** @public */
export declare type DownlinkWillSync = (downlink: Downlink) => void;

/** @public */
export declare type DownlinkWillUnlink = (downlink: Downlink) => void;

/** @public */
export declare interface Easing extends Timing {
    readonly type: string;
    readonly 0: 0;
    readonly 1: 1;
    readonly easing: this;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
    toString(): string;
}

/** @public */
export declare const Easing: {
    (type: string): Easing;
    /** @internal */
    prototype: Easing;
    readonly linear: Easing;
    readonly quadIn: Easing;
    readonly quadOut: Easing;
    readonly quadInOut: Easing;
    readonly cubicIn: Easing;
    readonly cubicOut: Easing;
    readonly cubicInOut: Easing;
    readonly quartIn: Easing;
    readonly quartOut: Easing;
    readonly quartInOut: Easing;
    readonly expoIn: Easing;
    readonly expoOut: Easing;
    readonly expoInOut: Easing;
    readonly circIn: Easing;
    readonly circOut: Easing;
    readonly circInOut: Easing;
    readonly backIn: Easing;
    readonly backOut: Easing;
    readonly backInOut: Easing;
    readonly elasticIn: Easing;
    readonly elasticOut: Easing;
    readonly elasticInOut: Easing;
    readonly bounceIn: Easing;
    readonly bounceOut: Easing;
    readonly bounceInOut: Easing;
    fromAny(value: AnyEasing): Easing;
};

/** @public */
export declare type EasingType = "linear" | "quad-in" | "quad-out" | "quad-in-out" | "cubic-in" | "cubic-out" | "cubic-in-out" | "quart-in" | "quart-out" | "quart-in-out" | "expo-in" | "expo-out" | "expo-in-out" | "circ-in" | "circ-out" | "circ-in-out" | "back-in" | "back-out" | "back-in-out" | "elastic-in" | "elastic-out" | "elastic-in-out" | "bounce-in" | "bounce-out" | "bounce-in-out";

/** @public */
export declare class EmLength extends Length {
    constructor(value: number);
    readonly value: number;
    get units(): LengthUnits;
    pxValue(basis?: LengthBasis | number): number;
    emValue(basis?: LengthBasis | number): number;
    em(basis?: LengthBasis | number): EmLength;
    toCssValue(): CSSUnitValue | null;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static zero(): EmLength;
}

/** @public */
export declare abstract class Envelope<E extends Envelope<E> = Envelope<any>> extends Message<E> {
    abstract readonly node: Uri;
    abstract withNode(node: AnyUri): E;
    abstract readonly lane: Uri;
    abstract withLane(lane: AnyUri): E;
    readonly prio: number;
    withPrio(prio: number): E;
    readonly rate: number;
    withRate(rate: number): E;
    static fromValue(value: Value): Envelope | null;
    static parseRecon(input: string): Envelope | null;
}

/** @public */
export declare class EqOperator extends BinaryOperator {
    constructor(operand1: Item, operand2: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): EqOperator;
}

/** @internal */
export declare class EqOutlet extends BinaryOutlet {
    protected evaluate(argument1: Value, argument2: Value): Item;
}

/**
 * Type that implements a universal equality relation.
 * @public
 */
export declare interface Equals {
    /**
     * Returns `true` if `this` is equal to `that`, otherwise returns `false`.
     */
    equals(that: unknown): boolean;
}

/** @public */
export declare const Equals: {
    (x: unknown, y: unknown): boolean;
    /**
     * Returns `true` if `object` conforms to the [[Equals]] interface.
     */
    is(object: unknown): object is Equals;
};

/**
 * Type that implements a universal equivalence relation.
 * @public
 */
export declare interface Equivalent {
    /**
     * Returns `true` if `this` is equivalent to `that` within some optionally
     * specified error tolerance `epsilon`, otherwise returns `false`.
     */
    equivalentTo(that: unknown, epsilon?: number): boolean;
}

/** @public */
export declare const Equivalent: {
    (x: unknown, y: unknown, epsilon?: number | undefined): boolean;
    /**
     * Returns `true` if `object` conforms to the [[Equivalent]] interface.
     */
    is(object: unknown): object is Equivalent;
    /**
     * Default equivalence tolerance.
     */
    readonly Epsilon: number;
};

/** @public */
export declare class ErrorSignal extends WorkerAddressed<ErrorSignal> {
    static readonly tag: string;
}

/** @public */
export declare class EventDownlink extends Downlink {
    /** @internal */
    constructor(context: DownlinkContext, owner: DownlinkOwner | null, init?: EventDownlinkInit, hostUri?: Uri, nodeUri?: Uri, laneUri?: Uri, prio?: number, rate?: number, body?: Value, flags?: number, observers?: ReadonlyArray<EventDownlinkObserver> | EventDownlinkObserver);
    /** @internal */
    readonly model: EventDownlinkModel | null;
    /** @internal */
    readonly observers: ReadonlyArray<EventDownlinkObserver>;
    get type(): DownlinkType;
    /** @internal */
    protected copy(context: DownlinkContext, owner: DownlinkOwner | null, hostUri: Uri, nodeUri: Uri, laneUri: Uri, prio: number, rate: number, body: Value, flags: number, observers: ReadonlyArray<EventDownlinkObserver>): EventDownlink;
    observe(observer: EventDownlinkObserver): this;
    open(): this;
}

/** @public */
export declare interface EventDownlink {
    hostUri(): Uri;
    hostUri(hostUri: AnyUri): EventDownlink;
    nodeUri(): Uri;
    nodeUri(nodeUri: AnyUri): EventDownlink;
    laneUri(): Uri;
    laneUri(laneUri: AnyUri): EventDownlink;
    prio(): number;
    prio(prio: number): EventDownlink;
    rate(): number;
    rate(rate: number): EventDownlink;
    body(): Value;
    body(body: AnyValue): EventDownlink;
    keepLinked(): boolean;
    keepLinked(keepLinked: boolean): EventDownlink;
    keepSynced(): boolean;
    keepSynced(keepSynced: boolean): EventDownlink;
}

/** @beta */
export declare interface EventDownlinkFastener<O = unknown> extends DownlinkFastener<O> {
    /** @override */
    readonly downlink: EventDownlink | null;
    /** @internal @override */
    createDownlink(warp: WarpRef): EventDownlink;
    /** @internal @override */
    bindDownlink(downlink: EventDownlink): EventDownlink;
    /** @internal */
    initDownlink?(downlink: EventDownlink): EventDownlink;
}

/** @beta */
export declare const EventDownlinkFastener: EventDownlinkFastenerFactory<EventDownlinkFastener<any>>;

/** @beta */
export declare interface EventDownlinkFastenerClass<F extends EventDownlinkFastener<any> = EventDownlinkFastener<any>> extends DownlinkFastenerClass<F> {
}

/** @beta */
export declare type EventDownlinkFastenerDescriptor<O = unknown, I = {}> = ThisType<EventDownlinkFastener<O> & I> & EventDownlinkFastenerInit & Partial<I>;

/** @beta */
export declare interface EventDownlinkFastenerFactory<F extends EventDownlinkFastener<any> = EventDownlinkFastener<any>> extends EventDownlinkFastenerClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): EventDownlinkFastenerFactory<F> & I;
    define<O>(className: string, descriptor: EventDownlinkFastenerDescriptor<O>): EventDownlinkFastenerFactory<EventDownlinkFastener<any>>;
    define<O, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & EventDownlinkFastenerDescriptor<O, I>): EventDownlinkFastenerFactory<EventDownlinkFastener<any> & I>;
    <O>(descriptor: EventDownlinkFastenerDescriptor<O>): PropertyDecorator;
    <O, I = {}>(descriptor: {
        implements: unknown;
    } & EventDownlinkFastenerDescriptor<O, I>): PropertyDecorator;
}

/** @beta */
export declare interface EventDownlinkFastenerInit extends DownlinkFastenerInit, DownlinkObserver {
    extends?: {
        prototype: EventDownlinkFastener<any>;
    } | string | boolean | null;
    initDownlink?(downlink: EventDownlink): EventDownlink;
}

/** @public */
export declare interface EventDownlinkInit extends EventDownlinkObserver, DownlinkInit {
}

/** @internal */
export declare class EventDownlinkModel extends DownlinkModel {
    constructor(context: DownlinkContext, hostUri: Uri, nodeUri: Uri, laneUri: Uri, prio?: number, rate?: number, body?: Value);
    views: ReadonlyArray<EventDownlink>;
    get type(): DownlinkType;
}

/** @public */
export declare interface EventDownlinkObserver extends DownlinkObserver {
}

/** @public */
export declare class EventMessage extends LaneAddressed<EventMessage> {
    static readonly tag: string;
}

/** @public */
export declare abstract class Expression extends Value {
    /** @internal */
    constructor();
    conditional(thenTerm: Value, elseTerm: Value): Value;
    conditional(thenTerm: AnyItem, elseTerm: AnyItem): Item;
    or(that: AnyItem): Operator;
    and(that: AnyItem): Operator;
    bitwiseOr(that: AnyItem): Operator;
    bitwiseXor(that: AnyItem): Operator;
    bitwiseAnd(that: AnyItem): Operator;
    lt(that: AnyItem): Operator;
    le(that: AnyItem): Operator;
    eq(that: AnyItem): Operator;
    ne(that: AnyItem): Operator;
    ge(that: AnyItem): Operator;
    gt(that: AnyItem): Operator;
    plus(that: AnyItem): Operator;
    minus(that: AnyItem): Operator;
    times(that: AnyItem): Operator;
    divide(that: AnyItem): Operator;
    modulo(that: AnyItem): Operator;
    not(): Operator;
    bitwiseNot(): Operator;
    negative(): Operator;
    positive(): Operator;
    inverse(): Operator;
    toAny(): AnyValue;
}

/** @public */
export declare class Extant extends Value {
    /** @internal */
    private constructor();
    /**
     * Always returns `true` because `Extant` is a defined value.
     */
    isDefined(): boolean;
    /**
     * Always returns `false` because `Extant` is not a distinct value.
     */
    isDistinct(): boolean;
    /**
     * Always returns `false` because `Extant` is not a definite value.
     */
    isDefinite(): boolean;
    isConstant(): boolean;
    /**
     * Always returns an empty `Record` because `Extant` is not a distinct value.
     */
    unflattened(): Record_2;
    not(): Value;
    /**
     * Always returns the empty `string` because `Extant` behaves like an empty
     * `Record`, which converts to a `string` by concatenating the string values
     * of all its members, if all its members convert to string values.
     */
    stringValue(): string;
    /**
     * Always returns the empty `string` because `Extant` behaves like an empty
     * `Record`, which converts to a `string` by concatenating the string values
     * of all its members, if all its members convert to string values.
     */
    stringValue<T>(orElse: T): string;
    /**
     * Always returns `true` because `Extant` behaves like a truthy value.
     */
    booleanValue(): boolean;
    /**
     * Always returns `true` because `Extant` behaves like a truthy value.
     */
    booleanValue<T>(orElse: T): boolean;
    toAny(): AnyExtant;
    interpolateTo(that: Extant): Interpolator<Extant>;
    interpolateTo(that: Item): Interpolator<Item>;
    interpolateTo(that: unknown): Interpolator<Item> | null;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    static extant(): Extant;
    static fromAny(value: AnyExtant): Extant;
}

/** @public */
export declare interface Fastener<O = unknown> {
    readonly owner: O;
    /** @internal */
    init(): void;
    /** @override */
    get fastenerType(): Proto<Fastener<any>>;
    get name(): string;
    /** @internal */
    readonly flags: FastenerFlags;
    /** @internal */
    setFlags(flags: FastenerFlags): void;
    get affinity(): Affinity;
    hasAffinity(affinity: Affinity): boolean;
    /** @internal */
    initAffinity(affinity: Affinity): void;
    /** @internal */
    minAffinity(affinity: Affinity): boolean;
    setAffinity(affinity: Affinity): void;
    /** @protected */
    willSetAffinity(newAffinity: Affinity, oldAffinity: Affinity): void;
    /** @protected */
    onSetAffinity(newAffinity: Affinity, oldAffinity: Affinity): void;
    /** @protected */
    didSetAffinity(newAffinity: Affinity, oldAffinity: Affinity): void;
    get inherits(): boolean;
    /** @internal */
    initInherits(inherits: string | boolean): void;
    setInherits(inherits: string | boolean): void;
    /** @protected */
    willSetInherits(inherits: boolean, superName: string | undefined): void;
    /** @protected */
    onSetInherits(inherits: boolean, superName: string | undefined): void;
    /** @protected */
    didSetInherits(inherits: boolean, superName: string | undefined): void;
    get inherited(): boolean;
    /** @internal */
    setInherited(inherited: boolean, superFastener: Fastener): void;
    /** @protected */
    willInherit(superFastener: Fastener): void;
    /** @protected */
    onInherit(superFastener: Fastener): void;
    /** @protected */
    didInherit(superFastener: Fastener): void;
    /** @protected */
    willUninherit(superFastener: Fastener): void;
    /** @protected */
    onUninherit(superFastener: Fastener): void;
    /** @protected */
    didUninherit(superFastener: Fastener): void;
    get superName(): string | undefined;
    get superFastener(): Fastener | null;
    /** @internal */
    getSuperFastener(): Fastener | null;
    /** @internal */
    bindSuperFastener(): void;
    /** @protected */
    willBindSuperFastener(superFastener: Fastener): void;
    /** @protected */
    onBindSuperFastener(superFastener: Fastener): void;
    /** @protected */
    didBindSuperFastener(superFastener: Fastener): void;
    /** @internal */
    unbindSuperFastener(): void;
    /** @protected */
    willUnbindSuperFastener(superFastener: Fastener): void;
    /** @protected */
    onUnbindSuperFastener(superFastener: Fastener): void;
    /** @protected */
    didUnbindSuperFastener(superFastener: Fastener): void;
    /** @internal */
    attachSubFastener(subFastener: Fastener): void;
    /** @internal */
    detachSubFastener(subFastener: Fastener): void;
    get coherent(): boolean;
    /** @internal */
    setCoherent(coherent: boolean): void;
    /** @internal */
    decohere(): void;
    /** @internal */
    recohere(t: number): void;
    get mounted(): boolean;
    /** @internal */
    mount(): void;
    /** @protected */
    willMount(): void;
    /** @protected */
    onMount(): void;
    /** @protected */
    didMount(): void;
    /** @internal */
    unmount(): void;
    /** @protected */
    willUnmount(): void;
    /** @protected */
    onUnmount(): void;
    /** @protected */
    didUnmount(): void;
    /** @override */
    toString(): string;
    /** @internal */
    get lazy(): boolean;
    /** @internal */
    get static(): string | boolean;
    /** @internal @protected */
    get binds(): boolean | undefined;
}

/** @public */
export declare const Fastener: FastenerFactory<Fastener<any>>;

/** @public */
export declare interface FastenerClass<F extends Fastener<any> = Fastener<any>> extends Function {
    /** @internal */
    prototype: F;
    /** @internal */
    contextClass?: FastenerContextClass;
    create(owner: FastenerOwner<F>): F;
    construct(fastenerClass: {
        prototype: F;
    }, fastener: F | null, owner: FastenerOwner<F>): F;
    /** @internal */
    readonly MountedFlag: FastenerFlags;
    /** @internal */
    readonly InheritsFlag: FastenerFlags;
    /** @internal */
    readonly InheritedFlag: FastenerFlags;
    /** @internal */
    readonly DecoherentFlag: FastenerFlags;
    /** @internal */
    readonly FlagShift: number;
    /** @internal */
    readonly FlagMask: FastenerFlags;
}

/** @public */
export declare interface FastenerContext {
    hasFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): boolean;
    getFastener<F extends Fastener<any>>(fastenerName: string, fastenerBound: Proto<F>): F | null;
    getFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): Fastener | null;
    setFastener(fastenerName: string, fastener: Fastener | null): void;
    getLazyFastener<F extends Fastener<any>>(fastenerName: string, fastenerBound: Proto<F>): F | null;
    getLazyFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): Fastener | null;
    getSuperFastener<F extends Fastener<any>>(fastenerName: string, fastenerBound: Proto<F>): F | null;
    getSuperFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): Fastener | null;
    decohereFastener?(fastener: Fastener): void;
    requireUpdate?(updateFlags: number): void;
}

/** @public */
export declare const FastenerContext: {
    getLazyFastener<F extends Fastener<any>>(fastenerContext: FastenerContext, fastenerName: string, fastenerBound: Proto<F>): F | null;
    getLazyFastener(fastenerContext: FastenerContext, fastenerName: string, fastenerBound?: Proto<Fastener<unknown>> | null | undefined): Fastener | null;
    getFastenerClass<F_1 extends Fastener<any>>(contextClass: FastenerContextClass, fastenerName: string, fastenerBound: Proto<F_1>): FastenerClass | null;
    getFastenerClass(contextClass: FastenerContextClass, fastenerName: string, fastenerBound?: Proto<Fastener<unknown>> | null | undefined): FastenerClass | null;
    getSuperFastenerClass(contextClass: FastenerContextClass, fastenerName: string, fastenerBound?: Proto<Fastener<unknown>> | null | undefined): FastenerClass;
    decorate(factory: FastenerFactory, descriptor: FastenerDescriptor, target: Object, propertyKey: string | symbol): void;
    decorator(factory: FastenerFactory, descriptor: FastenerDescriptor): PropertyDecorator;
    init(fastenerContext: FastenerContext): void;
    /** @internal */
    has<K extends keyof FastenerContext>(object: unknown, key: K): object is Required<Pick<FastenerContext, K>>;
    /** @internal */
    is(object: unknown): object is FastenerContext;
};

/** @public */
export declare interface FastenerContextClass {
    /** @internal */
    fastenerClassMap?: {
        [fastenerName: string]: FastenerClass | undefined;
    };
    /** @internal */
    fastenerClassInitMap?: {
        [fastenerName: string]: FastenerClass | undefined;
    };
}

/** @public */
export declare type FastenerDescriptor<O = unknown, I = {}> = ThisType<Fastener<O> & I> & FastenerInit & Partial<I>;

/** @public */
export declare interface FastenerFactory<F extends Fastener<any> = Fastener<any>> extends FastenerClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): FastenerFactory<F> & I;
    define<O>(className: string, descriptor: FastenerDescriptor<O>): FastenerFactory<Fastener<any>>;
    define<O, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & FastenerDescriptor<O, I>): FastenerFactory<Fastener<any> & I>;
    <O>(descriptor: FastenerDescriptor<O>): PropertyDecorator;
    <O, I = {}>(descriptor: {
        implements: unknown;
    } & FastenerDescriptor<O, I>): PropertyDecorator;
}

/** @public */
export declare type FastenerFlags = number;

/** @public */
export declare interface FastenerInit {
    extends?: {
        prototype: Fastener<any>;
    } | string | boolean | null;
    implements?: unknown;
    name?: string;
    lazy?: boolean;
    static?: string | boolean;
    affinity?: Affinity;
    inherits?: string | boolean;
    init?(): void;
    willSetAffinity?(newAffinity: Affinity, oldAffinity: Affinity): void;
    didSetAffinity?(newAffinity: Affinity, oldAffinity: Affinity): void;
    willSetInherits?(inherits: boolean, superName: string | undefined): void;
    didSetInherits?(inherits: boolean, superName: string | undefined): void;
    willInherit?(superFastener: Fastener): void;
    didInherit?(superFastener: Fastener): void;
    willUninherit?(superFastener: Fastener): void;
    didUninherit?(superFastener: Fastener): void;
    willBindSuperFastener?(superFastener: Fastener): void;
    didBindSuperFastener?(superFastener: Fastener): void;
    willUnbindSuperFastener?(superFastener: Fastener): void;
    didUnbindSuperFastener?(superFastener: Fastener): void;
    willMount?(): void;
    didMount?(): void;
    willUnmount?(): void;
    didUnmount?(): void;
}

/** @public */
export declare type FastenerOwner<F> = F extends Fastener<infer O> ? O : never;

/** @public */
export declare abstract class Field extends Item {
    /** @internal */
    constructor();
    /**
     * Always returns `true` because a `Field` can never be [[Absent]].
     */
    isDefined(): boolean;
    /**
     * Always returns `true` because a `Field` can be neither [[Extant]] nor
     * [[Absent]].
     */
    isDistinct(): boolean;
    /**
     * Always returns `true` because a `Field` cannot be one of:
     * an empty `Record`, `False`, `Extant`, or `Absent`.
     */
    isDefinite(): boolean;
    /**
     * Returns the key component of this `Field`.
     */
    abstract readonly key: Value;
    /**
     * Returns the value component of this `Field`.
     */
    abstract readonly value: Value;
    /**
     * Sets the value of this `Field` to the new `value`, returning the old value.
     *
     * @throws `Error` if this `Field` is immutable.
     */
    abstract setValue(value: AnyValue): Value;
    /**
     * Returns a copy of this `Field` with the updated `value`.
     */
    abstract updatedValue(value: AnyValue): Field;
    /**
     * Returns the value component of this `Field`.
     */
    toValue(): Value;
    /**
     * Always returns `undefined` because a `Field` can't be a `Record`, so it
     * can't have a first member `Attr` whose key string could be returned.
     */
    get tag(): string | undefined;
    /**
     * Always returns the value component of this `Field`.
     */
    get target(): Value;
    /**
     * Always returns [[Absent]] because a `Field` can't be flattened into a
     * `Value`.
     */
    flattened(): Value;
    /**
     * Returns a `Record` containing just this `Field`.
     */
    unflattened(): Record_2;
    /**
     * Always returns [[Absent]] because a `Field` can't be a `Record`, so it
     * can't have a head `Attr` whose value could be returned if its key were
     * equal to the `tag`.
     */
    header(tag: string): Value;
    /**
     * Always returns `undefined` because a `Field` can't be a `Record`, so it
     * can't have a head `Attr` whose value could be returned as a `Record` if
     * its key were equal to the `tag`.
     */
    headers(tag: string): Record_2 | undefined;
    /**
     * Always returns [[Absent]] because a `Field` can't be a `Record`, so it
     * can't have a first member.
     */
    head(): Item;
    /**
     * Always returns an empty `Record` because a `Field` can't itself be a
     * `Record`, so it can't have any non-first members.
     */
    tail(): Record_2;
    /**
     * Always returns [[Absent]] because a `Field` can't be a `Record`, so it
     * can't have any non-first members to flatten, and because a `Field` isn't
     * a distinct `Value`, so it can't return `Extant`.
     */
    body(): Value;
    /**
     * Always returns `0` because a `Field` can't be a `Record`, so it can't
     * contain any members.
     */
    get length(): number;
    /**
     * Always returns `false` because a `Field` can't be a `Record`, so it can't
     * have a `Field` member whose key is equal to the given `key`.
     */
    has(key: AnyValue): boolean;
    /**
     * Always returns [[Absent]] because a `Field` can't be a `Record`, so it
     * can't have a `Field` member whose key is equal to the given `key`.
     */
    get(key: AnyValue): Value;
    /**
     * Always returns [[Absent]] because a `Field` can't be a `Record`, so it
     * can't have an `Attr` member whose key is equal to the given `key`.
     */
    getAttr(key: AnyText): Value;
    /**
     * Always returns [[Absent]] because a `Field` can't be a `Record`, so it
     * can't have a `Slot` member whose key is equal to the given `key`.
     */
    getSlot(key: AnyValue): Value;
    /**
     * Always returns `undefined` because a `Field` can't be a `Record`, so it
     * can't have a `Field` member whose key is equal to the given `key`.
     */
    getField(key: AnyValue): Field | undefined;
    /**
     * Always returns [[Absent]] because a `Field` can't be a `Record`, so it
     * can't have a member at the given `index`.
     */
    getItem(index: AnyNum): Item;
    deleted(key: AnyValue): Field;
    conditional(thenTerm: Field, elseTerm: Field): Field;
    conditional(thenTerm: AnyItem, elseTerm: AnyItem): Item;
    or(that: Field): Field;
    or(that: AnyItem): Item;
    and(that: Field): Field;
    and(that: AnyItem): Item;
    lambda(template: Value): Value;
    /**
     * Converts the value of this `Field` into a `string` value, if possible.
     *
     * @throws `Error` if the value of this `Field` can't be converted into a
     *         `string` value.
     */
    stringValue(): string | undefined;
    /**
     * Converts the value of this `Field` into a `string` value, if possible;
     * otherwise returns `orElse` if the value of this `Field` can't be converted
     * into a `string` value.
     */
    stringValue<T>(orElse: T): string | T;
    /**
     * Converts the value of this `Field` into a `number` value, if possible.
     *
     * @throws `Error` if the value of this `Field` can't be converted into a
     *         `number` value.
     */
    numberValue(): number | undefined;
    /**
     * Converts the value of this `Field` into a `number` value, if possible;
     * otherwise returns `orElse` if the value of this `Field` can't be converted
     * into a `number` value.
     */
    numberValue<T>(orElse: T): number | T;
    /**
     * Converts the value of this `Field` into a `boolean` value, if possible.
     *
     * @throws `Error` if the value of this `Field` can't be converted into a
     *         `boolean` value.
     */
    booleanValue(): boolean | undefined;
    /**
     * Converts the value of this `Field` into a `boolean` value, if possible;
     * otherwise returns `orElse` if the value of this `Field` can't be converted
     * into a `boolean` value.
     */
    booleanValue<T>(orElse: T): boolean | T;
    abstract toAny(): AnyField;
    abstract branch(): Field;
    abstract clone(): Field;
    abstract commit(): this;
    interpolateTo(that: Field): Interpolator<Field>;
    interpolateTo(that: Item): Interpolator<Item>;
    interpolateTo(that: unknown): Interpolator<Item> | null;
    /** @internal */
    static readonly ImmutableFlag: number;
    static of(key: AnyValue, value?: AnyValue): Field;
    static fromAny(field: AnyField): Field;
}

/** @internal */
export declare interface FieldInterpolator extends Interpolator<Field> {
    /** @internal */
    readonly keyInterpolator: Interpolator<Value>;
    /** @internal */
    readonly valueInterpolator: Interpolator<Value>;
    readonly 0: Field;
    readonly 1: Field;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const FieldInterpolator: {
    (y0: Field, y1: Field): FieldInterpolator;
    /** @internal */
    prototype: FieldInterpolator;
};

/** @public */
export declare class FilterFieldsCombinator<K, V, I> extends FilterFieldsOperator<K, V, I> {
    constructor(func: FilterFieldsFunction<K, V>);
    /** @internal */
    readonly func: FilterFieldsFunction<K, V>;
    evaluate(key: K, value: V): boolean;
}

/** @public */
export declare type FilterFieldsFunction<K, V> = (key: K, value: V) => boolean;

/** @public */
export declare abstract class FilterFieldsOperator<K, V, I> extends AbstractMapInletMapOutlet<K, K, V, V, I, Map_2<K, V>> {
    has(key: K): boolean;
    get(): Map_2<K, V>;
    get(key: K): V | undefined;
    keyIterator(): Iterator_2<K>;
    protected onDecohereOutputKey(key: K, effect: KeyEffect): void;
    protected onRecohereOutputKey(key: K, effect: KeyEffect, version: number): void;
    protected willRecohereInputKey(key: K, effect: KeyEffect, version: number): KeyEffect;
    abstract evaluate(key: K, value: V): boolean;
}

/** @public */
export declare class FilterSelector extends Selector {
    constructor(predicate: Selector, then: Selector);
    readonly predicate: Selector;
    readonly then: Selector;
    forSelected<T>(interpreter: Interpreter, callback: (interpreter: Interpreter) => T | undefined): T | undefined;
    forSelected<T, S>(interpreter: Interpreter, callback: (this: S, interpreter: Interpreter) => T | undefined, thisArg: S): T | undefined;
    mapSelected(interpreter: Interpreter, transform: (interpreter: Interpreter) => Item): Item;
    mapSelected<S>(interpreter: Interpreter, transform: (this: S, interpreter: Interpreter) => Item, thisArg: S): Item;
    substitute(interpreter: AnyInterpreter): Item;
    protected filterSelected(interpreter: Interpreter): boolean;
    protected selected(interpreter: Interpreter): null;
    andThen(then: Selector): Selector;
    filter(predicate?: AnyItem): Selector;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debugThen<T>(output: Output<T>): Output<T>;
    clone(): Selector;
}

/** @internal */
export declare class FilterTimeInterval extends TimeInterval {
    private readonly unit;
    private readonly predicate;
    constructor(unit: TimeInterval, predicate: (d: DateTime) => boolean);
    offset(t: AnyDateTime, k?: number): DateTime;
    floor(t: AnyDateTime): DateTime;
}

/**
 * Transformation between a structurally typed [Item] and a nominally typed
 * JavaScript object.
 * @public
 */
export declare abstract class Form<T, U = never> {
    /**
     * Returns the key of the tag attribute that distinguishes structures of this
     * `Form`; returns `undefined` if this `Form` has no distinguishing tag
     * attribute. Used to accelerate distrcrimination of polymorphic structural
     * types with nominal type hints.
     */
    readonly tag: string | undefined;
    /**
     * Returns a version of this `Form` that requires a head [Attr] with the
     * given `tag` name.
     */
    withTag(tag: string | undefined): Form<T, U>;
    /**
     * Returns a default–possibly `undefined`–value of type `T`. Used as the
     * fallback return value when [Item.coerce coercing] an invalid structural
     * value.
     */
    readonly unit: T | undefined;
    /**
     * Returns a version of this `Form` with the given `unit` value.
     */
    withUnit(unit: T | undefined): Form<T, U>;
    /**
     * Converts a nominally typed JavaScript `object` into its structurally typed
     * equivalent, optionally based on the provided prototype `item`.
     */
    abstract mold(object: T | U, item?: Item): Item;
    /**
     * Converts a structurally typed `item` into a nominally typed JavaScript
     * object, optionally based on the provided prototype `object`.
     */
    abstract cast(item: Item, object?: T): T | undefined;
    static forString(): Form<string>;
    static forNumber(): Form<number>;
    static forBoolean(): Form<boolean>;
    static forAny(): Form<AnyItem>;
    static forItem(): Form<Item, AnyItem>;
    static forValue(): Form<Value, AnyValue>;
}

/**
 * utility functions for formatting values.
 * @public
 */
export declare const Format: {
    /**
     * The operting system specific string used to separate lines of text.
     */
    readonly lineSeparator: string;
    /**
     * Returns the human-readable [[Display]] string for the givem `object`,
     * output using the given `settings`. Delegates to [[Display.displa]],
     * if `object` implements `Display`; otherwise returns the result of
     * `Object.toString`.
     */
    display(object: unknown, settings?: AnyOutputSettings | undefined): string;
    /**
     * Returns the developer-readable [[Debug]] string for the givem `object`,
     * output using the given `settings`. Delegates to [[Debug.debug]], if
     * `object` implements `Debug`; returns a JavaScript string literal, if
     * `object` is a `string`, and returns a JavaScript number literal, if
     * `object` is a `number`; otherwise returns the result of `Object.toString`.
     */
    debug(object: unknown, settings?: AnyOutputSettings | undefined): string;
    /**
     * Writes the code points of the human-readable [[Display]] string for the
     * given `object` to `output`. Assumes `output` is a Unicode `Output` writer
     * with sufficient capacity. Delegates to [[Display.display]], if `object`
     * implements `Display`; otherwise writes the result of `Object.toString`.
     *
     * @returns the continuation of the `output`.
     * @throws [[OutputException]] if the `output` exits the _cont_ state before
     *         the full display string has been written.
     */
    displayAny<T>(output: Output<T>, object: unknown): Output<T>;
    /**
     * Writes the code points of the developer-readable [[Debug]] string for the
     * given `object` to `output`. Assumes `output` is a Unicode `Output` writer
     * with sufficient capacity. Delegates to [[Debug.debug]], if `object`
     * implements `Debug`; writes a JavaScript string literal, if `object` is a
     * `string`, and writes a JavaScript number literal, if `object` is a
     * `number`; otherwise writes the result of `Object.toString`.
     *
     * @returns the continuation of the `output`.
     * @throws [[OutputException]] if the `output` exits the _cont_ state before
     *         the full debug string has been written.
     */
    debugAny<T_1>(output: Output<T_1>, object: unknown): Output<T_1>;
    /**
     * Writes the code points of the numeric string for the given `value`
     * to `output`.
     *
     * @returns the continuation of the `output`.
     */
    displayNumber<T_2>(output: Output<T_2>, value: number): Output<T_2>;
    /**
     * Writes the code points of the JavaScript numeric literal for the given
     * `value` to `output`.
     *
     * @returns the continuation of the `output`.
     */
    debugNumber<T_3>(output: Output<T_3>, value: number): Output<T_3>;
    /**
     * Writes the code points of the JavaScript character literal for the given
     * `character` to `output`.
     *
     * @returns the continuation of the `output`.
     */
    debugChar<T_4>(output: Output<T_4>, character: number): Output<T_4>;
    /**
     * Writes the code points of the JavaScript string literal for the given
     * `string` to `output`.
     *
     * @returns the continuation of the `output`.
     */
    debugString<T_5>(output: Output<T_5>, string: string): Output<T_5>;
    /** @internal */
    encodeHex(x: number): number;
    /**
     * Returns a string representation of `value` scaled by its SI magnitude,
     * keeping at most `precision` digits past the decimal place, appended with
     * the appropriate SI prefix.
     */
    prefix(value: number, precision?: number | undefined): string;
    decimal(value: number, precision?: number | undefined): string;
    /** @internal */
    trimTrailingZeros(s: string): string;
    /**
     * Returns a string representation of the duration represented by the given
     * number of milliseconds.
     */
    duration(millis: number, separator?: string | undefined): string;
};

/** @public */
export declare class FormException extends Error {
    constructor(message?: string);
}

/** @public */
export declare interface FromAny<T, U = never> {
    fromAny(value: T | U): T;
}

/** @public */
export declare const FromAny: {
    /**
     * Returns `true` if `object` conforms to the [[FromAny]] interface.
     */
    is<T, U = never>(object: unknown): object is FromAny<T, U>;
};

/** @public */
export declare abstract class Func extends Expression {
    /** @internal */
    constructor();
    isConstant(): boolean;
    abstract invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item;
    expand(args: Value, interpreter: Interpreter, operator: InvokeOperator): Item | undefined;
}

/**
 * Utilities for comparing and hashing functions.
 * @public
 */
export declare const Functions: {
    /**
     * Returns the relative order of `x` with respect to `y`. Returns `-1` if
     * the hash code of function `x` is less than the hash code of function `y`;
     * returns `1` if the hash code of function `x` is greater than the hash code
     * of function `y`; and returns `0` if `x` and `y` are identical functions.
     * If either `x` or `y` is `null` or `undefined`, then functions order before
     * `null`, and `null` orders before `undefined`.
     */
    compare(x: Function | null | undefined, y: Function | null | undefined): number;
    /**
     * Returns a 32-bit hash value for a function.
     */
    hash(x: Function | null | undefined): number;
};

/** @public */
export declare interface GenericStreamlet<I = unknown, O = I> extends Streamlet<I, O> {
    getOutput(outlet: Outlet<O>): O | undefined;
    willDecohereInlet(inlet: Inlet<I>): void;
    didDecohereInlet(inlet: Inlet<I>): void;
    willRecohereInlet(inlet: Inlet<I>, version: number): void;
    didRecohereInlet(inlet: Inlet<I>, version: number): void;
    willDecohereOutlet(outlet: Outlet<O>): void;
    didDecohereOutlet(outlet: Outlet<O>): void;
    willRecohereOutlet(outlet: Outlet<O>, version: number): void;
    didRecohereOutlet(outlet: Outlet<O>, version: number): void;
}

/** @public */
export declare class GeoBox extends GeoShape implements Interpolate<GeoBox>, HashCode, Equivalent, Debug {
    constructor(lngMin: number, latMin: number, lngMax: number, latMax: number);
    isDefined(): boolean;
    readonly lngMin: number;
    readonly latMin: number;
    readonly lngMax: number;
    readonly latMax: number;
    get west(): number;
    get south(): number;
    get east(): number;
    get north(): number;
    get southWest(): GeoPoint;
    get northWest(): GeoPoint;
    get southEast(): GeoPoint;
    get northEast(): GeoPoint;
    get center(): GeoPoint;
    contains(that: AnyGeoPoint | AnyGeoBox): boolean;
    contains(lng: number, lat: number): boolean;
    /** @internal */
    containsPoint(that: GeoPoint): boolean;
    /** @internal */
    containsSegment(that: GeoSegment): boolean;
    /** @internal */
    containsTile(that: GeoTile): boolean;
    /** @internal */
    containsBox(that: GeoBox): boolean;
    intersects(that: AnyGeoPoint | AnyGeoBox): boolean;
    /** @internal */
    intersectsPoint(that: GeoPoint): boolean;
    /** @internal */
    intersectsSegment(that: GeoSegment): boolean;
    /** @internal */
    intersectsTile(that: GeoTile): boolean;
    /** @internal */
    intersectsBox(that: GeoBox): boolean;
    union(that: AnyGeoShape): GeoBox;
    project(f: GeoProjection): R2Box;
    get bounds(): GeoBox;
    toAny(): GeoBoxInit;
    interpolateTo(that: GeoBox): Interpolator<GeoBox>;
    interpolateTo(that: unknown): Interpolator<GeoBox> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static undefined(): GeoBox;
    static globe(): GeoBox;
    static of(lngMin: number, latMin: number, lngMax?: number, latMax?: number): GeoBox;
    static fromInit(value: GeoBoxInit): GeoBox;
    static fromAny(value: AnyGeoBox): GeoBox;
    /** @internal */
    static isInit(value: unknown): value is GeoBoxInit;
    /** @internal */
    static isAny(value: unknown): value is AnyGeoBox;
}

/** @public */
export declare interface GeoBoxInit {
    lngMin: number;
    latMin: number;
    lngMax: number;
    latMax: number;
}

/** @internal */
export declare const GeoBoxInterpolator: {
    (s0: GeoBox, s1: GeoBox): Interpolator<GeoBox>;
    /** @internal */
    prototype: Interpolator<GeoBox>;
};

/** @public */
export declare abstract class GeoCurve extends GeoShape implements Equals, Equivalent {
    abstract interpolateLng(u: number): number;
    abstract interpolateLat(u: number): number;
    abstract interpolate(u: number): GeoPoint;
    abstract split(u: number): [GeoCurve, GeoCurve];
    abstract project(f: GeoProjection): R2Curve;
    abstract forEachCoord<R>(callback: (lng: number, lat: number) => R | void): R | undefined;
    abstract forEachCoord<R, S>(callback: (this: S, lng: number, lat: number) => R | void, thisArg: S): R | undefined;
    abstract forEachCoordRest<R>(callback: (lng: number, lat: number) => R | void): R | undefined;
    abstract forEachCoordRest<R, S>(callback: (this: S, lng: number, lat: number) => R | void, thisArg: S): R | undefined;
    abstract equivalentTo(that: unknown, epsilon?: number): boolean;
    abstract equals(that: unknown): boolean;
}

/** @public */
export declare interface GeoCurveContext {
    moveTo(lng: number, lat: number): void;
    lineTo(lng: number, lat: number): void;
}

/** @public */
export declare class GeoGroup<S extends GeoShape = GeoShape> extends GeoShape implements Equals, Equivalent, Debug {
    constructor(shapes: ReadonlyArray<S>);
    isDefined(): boolean;
    readonly shapes: ReadonlyArray<S>;
    get lngMin(): number;
    get latMin(): number;
    get lngMax(): number;
    get latMax(): number;
    contains(that: AnyGeoShape): boolean;
    contains(x: number, y: number): boolean;
    intersects(that: AnyGeoShape): boolean;
    project(f: GeoProjection): R2Group;
    /** @internal */
    readonly boundingBox: GeoBox | null;
    get bounds(): GeoBox;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static empty<S extends GeoShape>(): GeoGroup<S>;
    static of<S extends GeoShape>(...shapes: S[]): GeoGroup<S>;
}

/** @public */
export declare type GeoJson = GeoJsonGeometry | GeoJsonFeature | GeoJsonFeatureCollection;

/** @public */
export declare const GeoJson: {
    is(value: unknown): value is GeoJson;
    toShape(geometry: GeoJsonGeometry): GeoShape;
    toShape(feature: GeoJsonFeature): GeoShape | null;
    toShape(collection: GeoJsonFeatureCollection): Array<GeoShape | null>;
    toShape(object: GeoJson): GeoShape | null | Array<GeoShape | null>;
};

/** @public */
export declare type GeoJsonBbox = [number, number, number, number] | [number, number, number, number, number, number];

/** @public */
export declare interface GeoJsonFeature<G extends GeoJsonGeometry = GeoJsonGeometry, P = GeoJsonProperties> extends GeoJsonObject {
    type: "Feature";
    geometry: G | null;
    properties: P | null;
    id?: string | number;
}

/** @public */
export declare const GeoJsonFeature: {
    is(value: unknown): value is GeoJsonFeature<GeoJsonGeometry, GeoJsonProperties>;
    toShape(feature: GeoJsonFeature<GeoJsonGeometry, GeoJsonProperties>): GeoShape | null;
};

/** @public */
export declare interface GeoJsonFeatureCollection<G extends GeoJsonGeometry = GeoJsonGeometry, P = GeoJsonProperties> extends GeoJsonObject {
    type: "FeatureCollection";
    features: GeoJsonFeature<G, P>[];
}

/** @public */
export declare const GeoJsonFeatureCollection: {
    is(value: unknown): value is GeoJsonFeatureCollection<GeoJsonGeometry, GeoJsonProperties>;
    toShapes(object: GeoJsonFeatureCollection<GeoJsonGeometry, GeoJsonProperties>): Array<GeoShape | null>;
};

/** @public */
export declare type GeoJsonGeometry = GeoJsonPoint | GeoJsonMultiPoint | GeoJsonLineString | GeoJsonMultiLineString | GeoJsonPolygon | GeoJsonMultiPolygon | GeoJsonGeometryCollection;

/** @public */
export declare const GeoJsonGeometry: {
    is(value: unknown): value is GeoJsonGeometry;
    toShape(object: GeoJsonGeometry): GeoShape;
};

/** @public */
export declare interface GeoJsonGeometryCollection extends GeoJsonGeometryObject {
    readonly type: "GeometryCollection";
    geometries: GeoJsonGeometry[];
}

/** @public */
export declare const GeoJsonGeometryCollection: {
    is(value: unknown): value is GeoJsonGeometryCollection;
    toShape(object: GeoJsonGeometryCollection): GeoGroup;
};

/** @public */
export declare interface GeoJsonGeometryObject extends GeoJsonObject {
    type: GeoJsonGeometryType;
}

/** @public */
export declare type GeoJsonGeometryType = "Point" | "MultiPoint" | "LineString" | "MultiLineString" | "Polygon" | "MultiPolygon" | "GeometryCollection";

/** @public */
export declare interface GeoJsonLineString extends GeoJsonGeometryObject {
    readonly type: "LineString";
    coordinates: GeoJsonPosition[];
}

/** @public */
export declare const GeoJsonLineString: {
    is(value: unknown): value is GeoJsonLineString;
    toShape(object: GeoJsonLineString): GeoSpline;
};

/** @public */
export declare interface GeoJsonMultiLineString extends GeoJsonGeometryObject {
    readonly type: "MultiLineString";
    coordinates: GeoJsonPosition[][];
}

/** @public */
export declare const GeoJsonMultiLineString: {
    is(value: unknown): value is GeoJsonMultiLineString;
    toShape(object: GeoJsonMultiLineString): GeoGroup<GeoSpline>;
};

/** @public */
export declare interface GeoJsonMultiPoint extends GeoJsonGeometryObject {
    readonly type: "MultiPoint";
    coordinates: GeoJsonPosition[];
}

/** @public */
export declare const GeoJsonMultiPoint: {
    is(value: unknown): value is GeoJsonMultiPoint;
    toShape(object: GeoJsonMultiPoint): GeoGroup<GeoPoint>;
};

/** @public */
export declare interface GeoJsonMultiPolygon extends GeoJsonGeometryObject {
    readonly type: "MultiPolygon";
    coordinates: GeoJsonPosition[][][];
}

/** @public */
export declare const GeoJsonMultiPolygon: {
    is(value: unknown): value is GeoJsonMultiPolygon;
    toShape(object: GeoJsonMultiPolygon): GeoGroup<GeoPath>;
};

/** @public */
export declare interface GeoJsonObject {
    type: GeoJsonType;
    bbox?: GeoJsonBbox;
}

/** @public */
export declare interface GeoJsonPoint extends GeoJsonGeometryObject {
    readonly type: "Point";
    coordinates: GeoJsonPosition;
}

/** @public */
export declare const GeoJsonPoint: {
    is(value: unknown): value is GeoJsonPoint;
    toShape(object: GeoJsonPoint): GeoPoint;
};

/** @public */
export declare interface GeoJsonPolygon extends GeoJsonGeometryObject {
    readonly type: "Polygon";
    coordinates: GeoJsonPosition[][];
}

/** @public */
export declare const GeoJsonPolygon: {
    is(value: unknown): value is GeoJsonPolygon;
    toShape(object: GeoJsonPolygon): GeoPath;
};

/** @public */
export declare type GeoJsonPosition = [number, number] | [number, number, number];

/** @public */
export declare type GeoJsonProperties = {
    [name: string]: unknown;
};

/** @public */
export declare type GeoJsonType = GeoJsonGeometryType | "Feature" | "FeatureCollection";

/** @public */
export declare class GeoPath extends GeoShape implements Equals, Equivalent, Debug {
    constructor(splines: ReadonlyArray<GeoSpline>);
    isDefined(): boolean;
    readonly splines: ReadonlyArray<GeoSpline>;
    get lngMin(): number;
    get latMin(): number;
    get lngMax(): number;
    get latMax(): number;
    interpolateLng(u: number): number;
    interpolateLat(u: number): number;
    interpolate(u: number): GeoPoint;
    contains(that: AnyGeoShape): boolean;
    contains(x: number, y: number): boolean;
    intersects(that: AnyGeoShape): boolean;
    split(u: number): [GeoPath, GeoPath];
    subdivide(u: number): GeoPath;
    project(f: GeoProjection): R2Path;
    /** @internal */
    readonly boundingBox: GeoBox | null;
    get bounds(): GeoBox;
    centroid(): GeoPoint;
    forEachCoord<R>(callback: (lng: number, lat: number) => R | void): R | undefined;
    forEachCoord<R, S>(callback: (this: S, lng: number, lat: number) => R | void, thisArg: S): R | undefined;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static empty(): GeoPath;
    static of(...splines: GeoSpline[]): GeoPath;
    static open(...curves: GeoCurve[]): GeoPath;
    static closed(...curves: GeoCurve[]): GeoPath;
    static fromPoints(points: GeoSplinePoints): GeoPath;
    static fromSplines(values: GeoPathSplines): GeoPath;
    static fromAny(value: AnyGeoPath): GeoPath;
    static fromAny(value: AnyGeoShape): GeoShape;
    static builder(): GeoPathBuilder;
    /** @internal */
    static isSplines(value: unknown): value is GeoPathSplines;
    /** @internal */
    static isAnyPath(value: unknown): value is AnyGeoPath;
}

/** @public */
export declare class GeoPathBuilder implements GeoPathContext {
    /** @internal */
    splines: GeoSpline[];
    /** @internal */
    builder: GeoSplineBuilder | null;
    constructor();
    moveTo(lng: number, lat: number): void;
    closePath(): void;
    lineTo(lng: number, lat: number): void;
    bind(): GeoPath;
}

/** @public */
export declare interface GeoPathContext extends GeoSplineContext {
}

/** @public */
export declare type GeoPathSplines = ReadonlyArray<AnyGeoSpline>;

/** @public */
export declare class GeOperator extends BinaryOperator {
    constructor(operand1: Item, operand2: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): GeOperator;
}

/**
 * A geographic point represented by a WGS84 longitude and latitude.
 * @public
 */
export declare class GeoPoint extends GeoShape implements Interpolate<GeoPoint>, HashCode, Equivalent, Debug {
    constructor(lng: number, lat: number);
    isDefined(): boolean;
    readonly lng: number;
    readonly lat: number;
    get lngMin(): number;
    get latMin(): number;
    get lngMax(): number;
    get latMax(): number;
    contains(that: AnyGeoShape): boolean;
    contains(lng: number, lat: number): boolean;
    intersects(that: AnyGeoShape): boolean;
    project(f: GeoProjection): R2Point;
    normalized(): GeoPoint;
    toAny(): GeoPointInit;
    interpolateTo(that: GeoPoint): Interpolator<GeoPoint>;
    interpolateTo(that: unknown): Interpolator<GeoPoint> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static origin(): GeoPoint;
    static undefined(): GeoPoint;
    static of(lng: number, lat: number): GeoPoint;
    static fromInit(value: GeoPointInit): GeoPoint;
    static fromTuple(value: GeoPointTuple): GeoPoint;
    static fromAny(value: AnyGeoPoint): GeoPoint;
    static normalized(lng: number, lat: number): GeoPoint;
    /** @internal */
    static normalizeLng(lng: number): number;
    /** @internal */
    static normalizeLat(lat: number): number;
    /** @internal */
    static isInit(value: unknown): value is GeoPointInit;
    /** @internal */
    static isTuple(value: unknown): value is GeoPointTuple;
    /** @internal */
    static isAny(value: unknown): value is AnyGeoPoint;
}

/** @public */
export declare interface GeoPointInit {
    lng: number;
    lat: number;
}

/** @internal */
export declare const GeoPointInterpolator: {
    (p0: GeoPoint, p1: GeoPoint): Interpolator<GeoPoint>;
    /** @internal */
    prototype: Interpolator<GeoPoint>;
};

/** @public */
export declare type GeoPointTuple = [number, number];

/** @public */
export declare interface GeoProjection {
    project(lnglat: AnyGeoPoint): R2Point;
    project(lng: number, lat: number): R2Point;
    unproject(point: AnyR2Point): GeoPoint;
    unproject(x: number, y: number): GeoPoint;
}

/** @public */
export declare const GeoProjection: {
    is(object: unknown): object is GeoProjection;
};

/** @public */
export declare class GeoSegment extends GeoCurve implements Interpolate<GeoSegment>, HashCode, Debug {
    constructor(lng0: number, lat0: number, lng1: number, lat1: number);
    isDefined(): boolean;
    readonly lng0: number;
    readonly lat0: number;
    readonly lng1: number;
    readonly lat1: number;
    get lngMin(): number;
    get latMin(): number;
    get lngMax(): number;
    get latMax(): number;
    interpolateLng(u: number): number;
    interpolateLat(u: number): number;
    interpolate(u: number): GeoPoint;
    contains(that: AnyGeoShape): boolean;
    contains(lng: number, lat: number): boolean;
    /** @internal */
    containsPoint(that: GeoPoint): boolean;
    /** @internal */
    containsSegment(that: GeoSegment): boolean;
    intersects(that: AnyGeoShape): boolean;
    /** @internal */
    intersectsPoint(that: GeoPoint): boolean;
    /** @internal */
    intersectsSegment(that: GeoSegment): boolean;
    split(u: number): [GeoSegment, GeoSegment];
    project(f: GeoProjection): R2Segment;
    forEachCoord<R>(callback: (lng: number, lat: number) => R | void): R | undefined;
    forEachCoord<R, S>(callback: (this: S, lng: number, lat: number) => R | void, thisArg: S): R | undefined;
    forEachCoordRest<R>(callback: (lng: number, lat: number) => R | void): R | undefined;
    forEachCoordRest<R, S>(callback: (this: S, lng: number, lat: number) => R | void, thisArg: S): R | undefined;
    toAny(): GeoSegmentInit;
    interpolateTo(that: GeoSegment): Interpolator<GeoSegment>;
    interpolateTo(that: unknown): Interpolator<GeoSegment> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static of(lng0: number, lat0: number, lng1: number, lat1: number): GeoSegment;
    static fromInit(value: GeoSegmentInit): GeoSegment;
    static fromAny(value: AnyGeoSegment): GeoSegment;
    /** @internal */
    static isInit(value: unknown): value is GeoSegmentInit;
    /** @internal */
    static isAny(value: unknown): value is AnyGeoSegment;
}

/** @public */
export declare interface GeoSegmentInit {
    lng0: number;
    lat0: number;
    lng1: number;
    lat1: number;
}

/** @internal */
export declare const GeoSegmentInterpolator: {
    (s0: GeoSegment, s1: GeoSegment): Interpolator<GeoSegment>;
    /** @internal */
    prototype: Interpolator<GeoSegment>;
};

/** @public */
export declare abstract class GeoShape implements Equals {
    abstract readonly lngMin: number;
    abstract readonly latMin: number;
    abstract readonly lngMax: number;
    abstract readonly latMax: number;
    abstract contains(that: AnyGeoShape): boolean;
    abstract contains(lng: number, lat: number): boolean;
    abstract intersects(that: AnyGeoShape): boolean;
    union(that: AnyGeoShape): GeoShape;
    abstract project(f: GeoProjection): R2Shape;
    get bounds(): GeoBox;
    abstract equals(that: unknown): boolean;
    static fromAny(value: AnyGeoShape): GeoShape;
    /** @internal */
    static isAny(value: unknown): value is AnyGeoShape;
}

/** @public */
export declare class GeoSpline extends GeoCurve implements Debug {
    constructor(curves: ReadonlyArray<GeoCurve>, closed: boolean);
    readonly curves: ReadonlyArray<GeoCurve>;
    /** @internal */
    readonly closed: boolean;
    isDefined(): boolean;
    isClosed(): boolean;
    get lngMin(): number;
    get latMin(): number;
    get lngMax(): number;
    get latMax(): number;
    interpolateLng(u: number): number;
    interpolateLat(u: number): number;
    interpolate(u: number): GeoPoint;
    contains(that: AnyGeoShape): boolean;
    contains(lng: number, lat: number): boolean;
    intersects(that: AnyGeoShape): boolean;
    split(u: number): [GeoSpline, GeoSpline];
    subdivide(u: number): GeoSpline;
    project(f: GeoProjection): R2Spline;
    /** @internal */
    readonly boundingBox: GeoBox | null;
    get bounds(): GeoBox;
    forEachCoord<R>(callback: (lng: number, lat: number) => R | void): R | undefined;
    forEachCoord<R, S>(callback: (this: S, lng: number, lat: number) => R | void, thisArg: S): R | undefined;
    forEachCoordRest<R>(callback: (lng: number, lat: number) => R | void): R | undefined;
    forEachCoordRest<R, S>(callback: (this: S, lng: number, lat: number) => R | void, thisArg: S): R | undefined;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static empty(): GeoSpline;
    static open(...curves: GeoCurve[]): GeoSpline;
    static closed(...curves: GeoCurve[]): GeoSpline;
    static fromPoints(points: GeoSplinePoints): GeoSpline;
    static fromAny(value: AnyGeoSpline): GeoSpline;
    static fromAny(value: AnyGeoShape): GeoShape;
    static builder(): GeoSplineBuilder;
    /** @internal */
    static isPoints(value: unknown): value is GeoSplinePoints;
    /** @internal */
    static isAnySpline(value: unknown): value is AnyGeoSpline;
}

/** @public */
export declare class GeoSplineBuilder implements GeoSplineContext {
    /** @internal */
    curves: GeoCurve[];
    /** @internal */
    closed: boolean;
    /** @internal */
    aliased: boolean;
    /** @internal */
    lng0: number;
    /** @internal */
    lat0: number;
    /** @internal */
    lng: number;
    /** @internal */
    lat: number;
    constructor();
    private dealias;
    moveTo(lng: number, lat: number): void;
    closePath(): void;
    lineTo(lng: number, lat: number): void;
    bind(): GeoSpline;
}

/** @public */
export declare interface GeoSplineContext extends GeoCurveContext {
    closePath(): void;
}

/** @public */
export declare type GeoSplinePoints = ReadonlyArray<AnyGeoPoint>;

/** @public */
export declare class GeoTile extends GeoShape implements HashCode, Equivalent, Debug {
    constructor(x: number, y: number, z: number);
    readonly x: number;
    readonly y: number;
    readonly z: number;
    get lngMin(): number;
    get latMin(): number;
    get lngMax(): number;
    get latMax(): number;
    get west(): number;
    get south(): number;
    get east(): number;
    get north(): number;
    get southWest(): GeoPoint;
    get northWest(): GeoPoint;
    get southEast(): GeoPoint;
    get northEast(): GeoPoint;
    get center(): GeoPoint;
    get southWestTile(): GeoTile;
    get northWestTile(): GeoTile;
    get southEastTile(): GeoTile;
    get northEastTile(): GeoTile;
    get parentTile(): GeoTile;
    contains(that: AnyGeoShape): boolean;
    contains(lng: number, lat: number): boolean;
    /** @internal */
    containsPoint(that: GeoPoint): boolean;
    /** @internal */
    containsSegment(that: GeoSegment): boolean;
    /** @internal */
    containsTile(that: GeoTile): boolean;
    /** @internal */
    containsBox(that: GeoBox): boolean;
    intersects(that: AnyGeoShape): boolean;
    /** @internal */
    intersectsPoint(that: GeoPoint): boolean;
    /** @internal */
    intersectsSegment(that: GeoSegment): boolean;
    /** @internal */
    intersectsTile(that: GeoTile): boolean;
    /** @internal */
    intersectsBox(that: GeoBox): boolean;
    project(f: GeoProjection): R2Box;
    toAny(): GeoTileInit;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static root(): GeoTile;
    static of(x: number, y: number, z: number): GeoTile;
    static fromInit(value: GeoTileInit): GeoTile;
    static fromTuple(value: GeoTileTuple): GeoTile;
    static fromAny(value: AnyGeoTile): GeoTile;
    /** @internal */
    static isInit(value: unknown): value is GeoTileInit;
    /** @internal */
    static isTuple(value: unknown): value is GeoTileTuple;
    /** @internal */
    static isAny(value: unknown): value is AnyGeoTile;
    /** @internal */
    static unprojectX(x: number): number;
    /** @internal */
    static unprojectY(y: number): number;
}

/** @public */
export declare interface GeoTileInit {
    x: number;
    y: number;
    z: number;
}

/** @public */
export declare type GeoTileTuple = [number, number, number];

/** @internal */
export declare class GeOutlet extends BinaryOutlet {
    protected evaluate(argument1: Value, argument2: Value): Item;
}

/** @public */
export declare class GetAttrSelector extends Selector {
    constructor(key: Text_2, then: Selector);
    readonly item: Text_2;
    readonly then: Selector;
    forSelected<T>(interpreter: Interpreter, callback: (interpreter: Interpreter) => T | undefined): T | undefined;
    forSelected<T, S>(interpreter: Interpreter, callback: (this: S, interpreter: Interpreter) => T | undefined, thisArg: S): T | undefined;
    /** @internal */
    static forSelected<T, S>(key: Text_2, then: Selector, interpreter: Interpreter, callback: (this: S | undefined, interpreter: Interpreter) => T | undefined, thisArg?: S): T | undefined;
    mapSelected(interpreter: Interpreter, transform: (interpreter: Interpreter) => Item): Item;
    mapSelected<S>(interpreter: Interpreter, transform: (this: S, interpreter: Interpreter) => Item, thisArg: S): Item;
    substitute(interpreter: AnyInterpreter): Item;
    /** @internal */
    static substitute(key: Text_2, then: Selector, interpreter: Interpreter): Item | undefined;
    andThen(then: Selector): Selector;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debugThen<T>(output: Output<T>): Output<T>;
    clone(): Selector;
}

/** @public */
export declare class GetItemSelector extends Selector {
    constructor(index: Num, then: Selector);
    readonly item: Num;
    readonly then: Selector;
    forSelected<T>(interpreter: Interpreter, callback: (interpreter: Interpreter) => T | undefined): T | undefined;
    forSelected<T, S>(interpreter: Interpreter, callback: (this: S, interpreter: Interpreter) => T | undefined, thisArg: S): T | undefined;
    mapSelected(interpreter: Interpreter, transform: (interpreter: Interpreter) => Item): Item;
    mapSelected<S>(interpreter: Interpreter, transform: (this: S, interpreter: Interpreter) => Item, thisArg: S): Item;
    substitute(interpreter: AnyInterpreter): Item;
    andThen(then: Selector): Selector;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debugThen<T>(output: Output<T>): Output<T>;
    clone(): Selector;
}

/** @internal */
export declare class GetOutlet extends AbstractOutlet<Value> {
    constructor();
    readonly keyInlet: OutletInlet<Value>;
    readonly mapInlet: OutletMapInlet<Value, Value, unknown>;
    get(): Value;
}

/** @public */
export declare class GetSelector extends Selector {
    constructor(key: Value, then: Selector);
    readonly item: Value;
    readonly then: Selector;
    forSelected<T>(interpreter: Interpreter, callback: (interpreter: Interpreter) => T | undefined): T | undefined;
    forSelected<T, S>(interpreter: Interpreter, callback: (this: S, interpreter: Interpreter) => T | undefined, thisArg: S): T | undefined;
    /** @internal */
    static forSelected<T, S>(key: Value, then: Selector, interpreter: Interpreter, callback: (this: S | undefined, interpreter: Interpreter) => T, thisArg?: S): T | undefined;
    mapSelected(interpreter: Interpreter, transform: (interpreter: Interpreter) => Item): Item;
    mapSelected<S>(interpreter: Interpreter, transform: (this: S, interpreter: Interpreter) => Item, thisArg: S): Item;
    substitute(interpreter: AnyInterpreter): Item;
    /** @internal */
    static substitute(key: Value, then: Selector, interpreter: Interpreter): Item | undefined;
    andThen(then: Selector): Selector;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debugThen<T>(output: Output<T>): Output<T>;
    clone(): Selector;
}

/** @public */
export declare class GradAngle extends Angle {
    constructor(value: number);
    readonly value: number;
    get units(): AngleUnits;
    degValue(): number;
    gradValue(): number;
    radValue(): number;
    turnValue(): number;
    grad(): GradAngle;
    toCssValue(): CSSUnitValue | null;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static zero(): GradAngle;
}

/** @public */
export declare class GtOperator extends BinaryOperator {
    constructor(operand1: Item, operand2: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): GtOperator;
}

/** @internal */
export declare class GtOutlet extends BinaryOutlet {
    protected evaluate(argument1: Value, argument2: Value): Item;
}

/**
 * Type that is convertible to a hash value consistent with its universal
 * equality relation.
 * @public
 */
export declare interface HashCode extends Equals {
    /**
     * Returns a 32-bit hash value for this object.
     */
    hashCode(): number;
}

/** @public */
export declare const HashCode: {
    (x: HashCode | null | undefined): number;
    /**
     * Returns `true` if `object` conforms to the [[HashCode]] interface.
     */
    is(object: unknown): object is HashCode;
};

/**
 * A hashed generational cache map discards the least recently used value
 * with the worst hit rate per hash bucket. HashGenCacheMap is an LRFU cache
 * with O(1) access time.
 *
 * Maintaining four "generations" of cached values per hash bucket, the cache
 * discards from the younger generations based on least recent usage, and
 * promotes younger generations to older generations based on most frequent
 * usage. Cache misses count as negative usage of the older generations,
 * biasing the cache against least recently used values with poor hit rates.
 *
 * @public
 */
export declare class HashGenCacheMap<K, V> {
    /** @internal */
    readonly buckets: Array<HashGenCacheMapBucket<K, V> | undefined>;
    /** @internal */
    gen4Hits: number;
    /** @internal */
    gen3Hits: number;
    /** @internal */
    gen2Hits: number;
    /** @internal */
    gen1Hits: number;
    /** @internal */
    misses: number;
    constructor(size: number);
    get(key: K): V | undefined;
    put(key: K, value: V): V;
    remove(key: K): V | undefined;
    clear(): void;
    /** @internal */
    hits(): number;
    hitRatio(): number;
}

/** @internal */
export declare class HashGenCacheMapBucket<K, V> {
    /** @internal */
    gen4Key: K | undefined;
    /** @internal */
    gen4Val: V | undefined;
    /** @internal */
    gen4Weight: number;
    /** @internal */
    gen3Key: K | undefined;
    /** @internal */
    gen3Val: V | undefined;
    /** @internal */
    gen3Weight: number;
    /** @internal */
    gen2Key: K | undefined;
    /** @internal */
    gen2Val: V | undefined;
    /** @internal */
    gen2Weight: number;
    /** @internal */
    gen1Key: K | undefined;
    /** @internal */
    gen1Val: V | undefined;
    /** @internal */
    gen1Weight: number;
    constructor(gen4Key?: K, gen4Val?: V, gen4Weight?: number, gen3Key?: K, gen3Val?: V, gen3Weight?: number, gen2Key?: K, gen2Val?: V, gen2Weight?: number, gen1Key?: K, gen1Val?: V, gen1Weight?: number);
}

/**
 * A hashed generational cache set discards the least recently used value
 * with the worst hit rate per hash bucket. HashGenCacheSet is a LRFU cache
 * with O(1) access time.
 *
 * Maintaining four "generations" of cached values per hash bucket, the cache
 * discards from the younger generations based on least recent usage, and
 * promotes younger generations to older generations based on most frequent
 * usage. Cache misses count as negative usage of the older generations,
 * biasing the cache against least recently used values with poor hit rates.
 *
 * The cache soft references the older generations, and weak references the
 * younger generations; the garbage collector can reclaim the entire cache,
 * but will preferentially wipe the younger cache generations before the older
 * cache generations.
 *
 * @public
 */
export declare class HashGenCacheSet<T> {
    /** @internal */
    readonly buckets: Array<HashGenCacheSetBucket<T> | undefined>;
    /** @internal */
    gen4Hits: number;
    /** @internal */
    gen3Hits: number;
    /** @internal */
    gen2Hits: number;
    /** @internal */
    gen1Hits: number;
    /** @internal */
    misses: number;
    constructor(size: number);
    put(value: T): T;
    remove(value: T): boolean;
    clear(): void;
    /** @internal */
    get hits(): number;
    get hitRatio(): number;
}

/** @internal */
export declare class HashGenCacheSetBucket<T> {
    /** @internal */
    gen4Val: T | undefined;
    /** @internal */
    gen4Weight: number;
    /** @internal */
    gen3Val: T | undefined;
    /** @internal */
    gen3Weight: number;
    /** @internal */
    gen2Val: T | undefined;
    /** @internal */
    gen2Weight: number;
    /** @internal */
    gen1Val: T | undefined;
    /** @internal */
    gen1Weight: number;
    constructor(gen4Val?: T, gen4Weight?: number, gen3Val?: T, gen3Weight?: number, gen2Val?: T, gen2Weight?: number, gen1Val?: T, gen1Weight?: number);
}

/** @public */
export declare abstract class Host {
    abstract readonly hostUri: Uri;
    /** @internal */
    abstract readonly unlinkDelay: number;
    abstract get connected(): boolean;
    abstract get authenticated(): boolean;
    abstract readonly session: Value;
    /** @internal */
    abstract resolve(relative: AnyUri): Uri;
    /** @internal */
    abstract unresolve(absolute: AnyUri): Uri;
    abstract authenticate(credentials: AnyValue): void;
    /** @internal */
    abstract openDownlink(downlink: HostDownlink): void;
    /** @internal */
    abstract unlinkDownlink(downlink: HostDownlink): void;
    /** @internal */
    abstract closeDownlink(downlink: HostDownlink): void;
    abstract command(nodeUri: AnyUri, laneUri: AnyUri, body: AnyValue): void;
    /** @internal */
    abstract open(): void;
    /** @internal */
    abstract close(): void;
    /** @internal */
    abstract closeUp(): void;
    /** @internal */
    abstract push(envelope: Envelope): void;
}

/** @public */
export declare abstract class HostAddressed<E extends HostAddressed<E> = HostAddressed<any>> extends Envelope<E> {
    constructor(body: Value);
    get node(): Uri;
    withNode(node: AnyUri): E;
    get lane(): Uri;
    withLane(lane: AnyUri): E;
    readonly body: Value;
    withBody(body: AnyValue): E;
    protected copy(body: Value): E;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toValue(): Value;
    static fromValue<F extends HostAddressedConstructor<InstanceType<F>>>(this: F, value: Value): InstanceType<F> | null;
    static create<F extends HostAddressedConstructor<InstanceType<F>>>(this: F, body?: AnyValue): InstanceType<F>;
}

/** @public */
export declare interface HostAddressedConstructor<E extends HostAddressed<E> = HostAddressed<any>> {
    new (body: Value): E;
    readonly tag: string;
}

/** @public */
export declare interface HostContext {
    readonly online: boolean;
    /** @internal */
    hostDidConnect(host: Host): void;
    /** @internal */
    hostDidAuthenticate(body: Value, host: Host): void;
    /** @internal */
    hostDidDeauthenticate(body: Value, host: Host): void;
    /** @internal */
    hostDidDisconnect(host: Host): void;
    /** @internal */
    hostDidFail(error: unknown, host: Host): void;
    /** @internal */
    closeHost(host: Host): void;
}

/** @internal */
export declare interface HostDownlink {
    readonly nodeUri: Uri;
    readonly laneUri: Uri;
    onEventMessage(message: EventMessage, hsot: Host): void;
    onLinkedResponse(response: LinkedResponse, hsot: Host): void;
    onSyncedResponse(response: SyncedResponse, hsot: Host): void;
    onUnlinkRequest(request: UnlinkRequest, host: Host): void;
    onUnlinkedResponse(response: UnlinkedResponse, hsot: Host): void;
    hostDidConnect(host: Host): void;
    hostDidDisconnect(host: Host): void;
    hostDidFail(error: unknown, host: Host): void;
    openUp(host: Host): void;
    closeUp(host: Host): void;
}

/** @public */
export declare interface HostOptions {
    credentials?: Value;
    unlinkDelay?: number;
    maxReconnectTimeout?: number;
    idleTimeout?: number;
    sendBufferSize?: number;
    protocols?: string | string[];
    WebSocket?: typeof WebSocket;
    worker?: boolean;
}

/** @public */
export declare class HostRef extends BaseRef {
    constructor(context: RefContext, hostUri: Uri);
    readonly hostUri: Uri;
    hostRef(hostUri: AnyUri): HostRef;
    nodeRef(nodeUri: AnyUri): NodeRef;
    laneRef(nodeUri: AnyUri, laneUri: AnyUri): LaneRef;
    downlink(init?: EventDownlinkInit): EventDownlink;
    downlinkList(init?: ListDownlinkInit<Value, AnyValue>): ListDownlink<Value, AnyValue>;
    downlinkList<V extends VU, VU = never>(init?: ListDownlinkInit<V, VU>): ListDownlink<V, VU>;
    downlinkMap(init?: MapDownlinkInit<Value, Value, AnyValue, AnyValue>): MapDownlink<Value, Value, AnyValue, AnyValue>;
    downlinkMap<K extends KU, V extends VU, KU = never, VU = never>(init?: MapDownlinkInit<K, V, KU, VU>): MapDownlink<K, V, KU, VU>;
    downlinkValue(init?: ValueDownlinkInit<Value, AnyValue>): ValueDownlink<Value, AnyValue>;
    downlinkValue<V extends VU, VU = never>(init?: ValueDownlinkInit<V, VU>): ValueDownlink<V, VU>;
    command(nodeUri: AnyUri, laneUri: AnyUri, body: AnyValue): void;
}

/** @public */
export declare const hostRef: typeof client.hostRef;

/** @internal */
export declare class Hour12Format extends DateTimeFormat {
    writeDate<T>(output: Output<T>, date: DateTime): Output<T>;
    parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit>;
}

/** @internal */
export declare class Hour12Parser extends Parser<DateTimeInit> {
    private readonly date;
    private readonly hour;
    private readonly step;
    constructor(date?: DateTimeInit, hour?: number, step?: number);
    feed(input: Input): Parser<DateTimeInit>;
    static parse(input: Input, date?: DateTimeInit, hour?: number, step?: number): Parser<DateTimeInit>;
    static term(hour: number, date: DateTimeInit): Parser<DateTimeInit>;
    static cont(date: DateTimeInit, hour: number, step: number): Parser<DateTimeInit>;
}

/** @internal */
export declare class Hour24Format extends DateTimeFormat {
    writeDate<T>(output: Output<T>, date: DateTime): Output<T>;
    parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit>;
}

/** @internal */
export declare class Hour24Parser extends Parser<DateTimeInit> {
    private readonly date;
    private readonly hour;
    private readonly step;
    constructor(date?: DateTimeInit, hour?: number, step?: number);
    feed(input: Input): Parser<DateTimeInit>;
    static parse(input: Input, date?: DateTimeInit, hour?: number, step?: number): Parser<DateTimeInit>;
    static term(hour: number, date: DateTimeInit): Parser<DateTimeInit>;
    static cont(date: DateTimeInit, hour: number, step: number): Parser<DateTimeInit>;
}

/** @internal */
export declare class HourInterval extends UnitTimeInterval {
    offset(d: AnyDateTime, k?: number): DateTime;
    next(d: AnyDateTime, k?: number): DateTime;
    floor(d: AnyDateTime): DateTime;
    ceil(d: AnyDateTime): DateTime;
    every(k: number): TimeInterval;
    /** @internal */
    static modulo(k: number, d: DateTime): boolean;
}

/**
 * Utilities for working with ECMAScript identifiers.
 * @public
 */
export declare const Identifiers: {
    /** @internal */
    isStartChar(c: number): boolean;
    /** @internal */
    isPartChar(c: number): boolean;
    isValid(identifier: string): boolean;
    isReserved(identifier: string): boolean;
};

/**
 * Utilities for comparing and hashing object identities.
 * @public
 */
export declare const Identity: {
    /**
     * Returns the relative order of `x` with respect to `y`. Returns `-1` if
     * the hash code of object `x` is less than the hash code of object `y`;
     * returns `1` if the hash code of object `x` is greater than the hash code
     * of object `y`; and returns `0` if `x` and `y` are identical objects.
     * If either `x` or `y` is `null` or `undefined`, then objects order before
     * `null`, and `null` orders before `undefined`.
     */
    compare(x: object | null | undefined, y: object | null | undefined): number;
    /**
     * Returns a unique 32-bit hash value for a particular object instance.
     */
    hash(x: object | null | undefined): number;
};

/** @internal */
export declare interface IdentityInterpolator<Y> extends Interpolator<Y> {
    /** @internal */
    readonly value: Y;
    readonly 0: Y;
    readonly 1: Y;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const IdentityInterpolator: {
    <Y>(value: Y): IdentityInterpolator<Y>;
    /** @internal */
    prototype: IdentityInterpolator<any>;
};

/** @public */
export declare class IdentitySelector extends Selector {
    get then(): Selector;
    forSelected<T>(interpreter: Interpreter, callback: (interpreter: Interpreter) => T | undefined): T | undefined;
    forSelected<T, S>(interpreter: Interpreter, callback: (this: S, interpreter: Interpreter) => T | undefined, thisArg: S): T | undefined;
    mapSelected(interpreter: Interpreter, transform: (interpreter: Interpreter) => Item): Item;
    mapSelected<S>(interpreter: Interpreter, transform: (this: S, interpreter: Interpreter) => Item, thisArg: S): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get(key: AnyValue): Selector;
    getAttr(key: AnyText): Selector;
    getItem(index: AnyNum): Selector;
    andThen(then: Selector): Selector;
    keys(): Selector;
    values(): Selector;
    children(): Selector;
    descendants(): Selector;
    filter(predicate?: AnyItem): Selector;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debugThen<T>(output: Output<T>): Output<T>;
    clone(): Selector;
}

/** @public */
export declare class IdentityTransform extends Transform {
    transform(that: Transform): Transform;
    transform(x: number, y: number): R2Point;
    transformX(x: number, y: number): number;
    transformY(x: number, y: number): number;
    inverse(): Transform;
    toAffine(): AffineTransform;
    toCssValue(): CSSStyleValue | null;
    toValue(): Value;
    interpolateTo(that: IdentityTransform): Interpolator<IdentityTransform>;
    interpolateTo(that: Transform): Interpolator<Transform>;
    interpolateTo(that: unknown): Interpolator<Transform> | null;
    conformsTo(that: Transform): boolean;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static fromValue(value: Value): IdentityTransform | null;
}

/** @public */
export declare function In(name: string): PropertyDecorator;

/** @public */
export declare function In(options: InletOptions): PropertyDecorator;

/** @public */
export declare function In(target: unknown, key: string): void;

/** @public */
export declare interface Initable<T> {
    init(init: T): void;
}

/** @public */
export declare const Initable: {
    is<T>(object: unknown): object is Initable<T>;
};

/** @public */
export declare type InitType<I> = I extends {
    init(init: infer T): any;
} ? T : never;

/**
 * Input connector into a [[Streamlet]]. An `Inlet` represents a source from
 * which a `Streamlet` acquires state.
 *
 * In order for an `Inlet` to provide state to its `Streamlet`, it must bind to
 * an [[input]] source. The input source of an `Inlet` is an [[Outlet]] of
 * some other `Streamlet`. The [[bindInput]] method "plugs" the `Inlet` into
 * an `Outlet`. The [[unbindInput]] method "unplugs" the `Inlet` from its
 * connected `Outlet`.
 *
 * The state of an `Inlet` has an integral _version_. When its version is
 * negative, the state of the `Inlet` is considered _decoherent_. When any
 * state on which an `Inlet` transitively depends changes, the `Inlet` will be
 * [[decohereOutput decohered]]. Decoherence does not immediately cause an
 * `Inlet` to recompute its state. Instead, a separate [[recohereOutput
 * recohere]] step causes all of the decoherent paths in the dataflow graph
 * passing through the `Inlet` to make their states coherent again.
 *
 * @public
 */
export declare interface Inlet<I = unknown> {
    /**
     * The `Outlet` from which this `Inlet` acquires its state, or `null` if
     * this `Inlet` is disconnected.
     */
    readonly input: Outlet<I> | null;
    /**
     * Connects this `Inlet` to an `Outlet` from which it will  acquire its
     * state. If this `Inlet` is already connected, it will first disconnect
     * from its existing input. Then, after updating its [[input]] property,
     * the `Inlet` will invoke [[Outlet.bindOutput]] on its new `input`.
     */
    bindInput(input: Outlet<I> | null): void;
    /**
     * Disconnects this `Inlet` from its input `Outlet`, if connected. After
     * setting its [[input]] property to `null`, the `Inlet` will invoke
     * [[Outlet.unbindOutput]] on its old input, if defined.
     */
    unbindInput(): void;
    /**
     * Disconnects all `Inlet`s dominated by this `Inlet` in the dataflow
     * dependency graph. Used to recursively clean up chains of combinators
     * terminating at this `Inlet`.
     */
    disconnectInputs(): void;
    /**
     * Disconnects all `Outlet`s dominated by this `Inlet` in the dataflow graph.
     * Used to recursively clean up chains of combinators passing through this
     * `Inlet`.
     */
    disconnectOutputs(): void;
    /**
     * Marks this `Inlet`—and the `Streamlet` to which this `Inlet` is attached—as
     * having decoherent state. Decohering an `Inlet` will recursively decohere
     * all streamlets that transitively depend on the state of this `Inlet`.
     * Decohering an `Inlet` does not cause its state to be recomputed. A
     * subsequent [[recohereOutput]] call will eventually make the state of the
     * `Inlet` coherent again.
     */
    decohereOutput(): void;
    /**
     * Updates the state of this `Inlet` to make it consistent with the target
     * `version`. The `Inlet` only needs to update if its current `version`
     * differs from the target `version`. To update its state, the `Inlet` first
     * invokes [[Outlet.recohereInput]] on its [[input]], to ensure that its
     * input is coherent. It then invokes [[Streamlet.recohere]] on the
     * `Streamlet` to which it's attached, causing the `Streamlet` to make its
     * own state coherent again.
     */
    recohereOutput(version: number): void;
}

/** @public */
export declare const Inlet: {
    is<I>(object: unknown): object is Inlet<I>;
};

/** @internal */
export declare class InletDescriptor {
    readonly key: string;
    readonly name: string;
    readonly type: InletType;
    constructor(key: string, name: string, type: InletType);
}

/** @public */
export declare interface InletOptions {
    name?: string;
    type?: InletType;
}

/** @public */
export declare type InletType = "value" | "map";

/** @public */
export declare function Inout(name: string): PropertyDecorator;

/** @public */
export declare function Inout(options: InoutletOptions): PropertyDecorator;

/** @public */
export declare function Inout(target: unknown, key: string): void;

/** @public */
export declare interface Inoutlet<I = unknown, O = I> extends Inlet<I>, Outlet<O> {
    /**
     * Disconnects all `Inlet`s dominated by this `Inoutlet` in the dataflow
     * dependency graph. Used to recursively clean up chains of combinators
     * passing through this `Inoutlet`.
     */
    disconnectInputs(): void;
    /**
     * Disconnects all `Inlets`s dominated by this `Inoutlet` in the dataflow
     * graph. Used to recursively clean up chains of combinators passing through
     * this `Inoutlet`.
     */
    disconnectOutputs(): void;
}

/** @internal */
export declare class InoutletDescriptor {
    readonly key: string;
    readonly name: string;
    readonly type: InoutletType;
    constructor(key: string, name: string, type: InoutletType);
}

/** @public */
export declare interface InoutletOptions {
    name?: string;
    type?: InoutletType;
}

/** @public */
export declare type InoutletType = "value" | "map";

/**
 * Non-blocking token stream reader, with single token lookahead.
 * `Input` enables incremental, interruptible parsing of network protocols and
 * data formats.
 *
 * ### Input tokens
 * Input tokens are modeled as primitive numbers, commonly representing Unicode
 * code points, or raw octets; each `Input` implementation specifies the
 * semantic type of its tokens. The [[head]]  method peeks at the lookahead
 * token, without consuming it, and the [[step]] method advances the input to
 * the next token.
 *
 * ### Input states
 * An `Input` reader is always in one of three states: _cont_​inue, _empty_, or
 * _done_. The _cont_ state indicates that a lookahead token is immediately
 * available; the _empty_ state indicates that no additional tokens are
 * available at this time, but that the stream may logically resume at some
 * point in the future; and the _done_ state indicates that the stream has
 * terminated. [[isCont]] returns `true` when in the _cont_ state; [[isEmpty]]
 * returns `true` when in the _empty_ state; and [[isDone]] returns `true` when
 * in the _done_ state.
 *
 * ### Non-blocking behavior
 * `Input` readers never block. An `Input` reader that would otherwise block
 * awaiting additional input instead enters the _empty_ state, signaling the
 * input consumer to back off processing the input, but to remain prepared to
 * process additional input in the future. An `Input` reader enters the _done_
 * state when it encounters the final end of its input, signaling the input
 * consumer to stop processing. [[Input.empty]] returns an `Input` reader in
 * the _empty_ state. [[Input.done]] returns an `Input` reader in the _done_
 * state.
 *
 * ### Position tracking
 * The logical position of the lookahead token is made available via the
 * [[mark]] method, with optimized callouts for the byte [[offset]], one-based
 * [[line]] number, and one-based [[column]] in the current line. The [[id]]
 * method returns a diagnostic identifier for the token stream.
 *
 * ### Cloning
 * An `Input` reader may be [[clone cloned]] to provide an indepently mutable
 * position into a shared token stream. Not all `Input` implementations
 * support cloning.
 *
 * @see [[InputSettings]]
 * @see [[Parser]]
 * @public
 */
export declare abstract class Input {
    /**
     * Returns `true` when a [[head lookahead]] token is immediately available.
     * i.e. this `Input` is in the _cont_ state.
     */
    abstract isCont(): boolean;
    /**
     * Returns `true` when no lookahead token is currently available, but
     * additional input may be available at some point in the future, i.e. this
     * `Input` is in the _empty_ state.
     */
    abstract isEmpty(): boolean;
    /**
     * Returns `true` when no lookahead token is currently available, and no
     * additional input will ever become available, i.e. this `Input` is in
     * the _done_ state.
     */
    abstract isDone(): boolean;
    /**
     * Returns `true` when no lookahead token is currently available due to an
     * error with the token stream. i.e. this `Input` is in the `error` state.
     * When `true`, `trap()` will return the input error
     */
    abstract isError(): boolean;
    /**
     * Returns `true` if this is a partial `Input` will that enter the _empty_
     * state after it consumes the last available input token.
     */
    abstract isPart(): boolean;
    /**
     * Returns a partial `Input` equivalent to this `Input`, if `part` is `true`;
     * returns a final `Input` equivalent to this `Input` if `part` is `false`.
     * The caller's reference to this `Input` should be replaced by the returned
     * `Input`
     */
    abstract asPart(part: boolean): Input;
    /**
     * Returns the current lookahead token, if this `Input` is in the
     * _cont_ state.
     *
     * @throws [[InputException]] if this `Input` is not in the _cont_ state.
     */
    abstract head(): number;
    /**
     * Advances to the next token, if this `Input` is in the _cont_ state.
     *
     * @throws `Error` if this `Input` is not in the _cont_ state.
     */
    abstract step(): Input;
    /**
     * Sets the position of this `Input` to the given `mark`. Rewinds to the
     * start of this `Input`, if `mark` is `undefined`.
     *
     * @throws [[InputException]] if this `Input` does not support seeking,
     *         or is unable to reposition to the `mark`.
     */
    abstract seek(mark?: Mark): Input;
    /**
     * Returns the input error when in the _error_ state
     *
     * @throws InputException if the `Input` is not the _error_state
     */
    trap(): Error;
    /**
     * An informative identifier for this token stream, or `undefined` if this
     * stream is unidentified.
     */
    abstract readonly id: string | undefined;
    /**
     * Returns an `Input` equivalent to this `Input`, but logically identified
     * by the given–possibly `undefined`–`id`. The caller's reference to this
     * `Input` should be replaced by the returned `Input`.
     */
    abstract withId(id: string | undefined): Input;
    /**
     * The position of the current lookahead token, relative to the start
     * of the stream.
     */
    abstract readonly mark: Mark;
    /**
     * Returns an `Input` equivalent to this `Input`, but logically positioned
     * at the given `mark`. The physical position in the input stream is not
     * modified. The caller's reference to this `Input` should be replaced by
     * the returned `Input`.
     */
    abstract withMark(mark: Mark): Input;
    /**
     * The byte offset of the current lookahead token, relative to the start
     * of the stream.
     */
    abstract readonly offset: number;
    /**
     * The one-based line number of the current lookahead token, relative to
     * the start of the stream.
     */
    abstract readonly line: number;
    /**
     * The one-based column number of the current lookahead token, relative to
     * the current line in the stream.
     */
    abstract readonly column: number;
    /**
     * The `InputSettings` used to configure the behavior of input consumers
     * that read from this `Input`.
     */
    abstract readonly settings: InputSettings;
    /**
     * Returns a clone of this `Input` with the given `settings`.
     *
     * @throws `Error` if this `Input` reader cannot be cloned.
     */
    abstract withSettings(settings: AnyInputSettings): Input;
    /**
     * Returns an independently positioned view into the token stream,
     * initialized with identical state to this `Input`.
     *
     * @throws `Error` if this `Input` reader cannot be cloned.
     */
    abstract clone(): Input;
    /**
     * Returns an `Input` reader in the _empty_ state.
     */
    static empty(): Input;
    /**
     * Returns an `Input` reader in the _done_ state.
     */
    static done(): Input;
    /**
     * Returns an `Input` in the _error_ state that traps the given `error`.
     */
    static error(error: Error): Input;
}

/**
 * Non-blocking token stream buffer.
 * @public
 */
export declare abstract class InputBuffer extends Input {
    abstract asPart(part: boolean): InputBuffer;
    abstract readonly index: number;
    abstract withIndex(index: number): InputBuffer;
    abstract readonly limit: number;
    abstract withLimit(limit: number): InputBuffer;
    abstract readonly capacity: number;
    abstract readonly remaining: number;
    abstract has(index: number): boolean;
    abstract get(index: number): number;
    abstract set(index: number, token: number): void;
    abstract step(offset?: number): InputBuffer;
    abstract seek(mark: Mark): InputBuffer;
    abstract withId(id: string | undefined): InputBuffer;
    abstract withMark(mark: Mark): InputBuffer;
    abstract withSettings(settings: AnyInputSettings): InputBuffer;
    abstract clone(): InputBuffer;
    /**
     * Returns an `InputBuffer` in the _empty_ state.
     */
    static empty(): InputBuffer;
    /**
     * Returns an `InputBuffer` in the _done_ state.
     */
    static done(): InputBuffer;
    /**
     * Returns an `InputBuffer` in the _error_ state that traps the given `error`.
     */
    static error(error: Error): InputBuffer;
}

/** @internal */
export declare class InputBufferDone extends InputBuffer {
    constructor(id: string | undefined, mark: Mark, settings: InputSettings);
    isCont(): boolean;
    isEmpty(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): InputBuffer;
    get index(): number;
    withIndex(index: number): InputBuffer;
    get limit(): number;
    withLimit(limit: number): InputBuffer;
    get capacity(): number;
    get remaining(): number;
    has(index: number): boolean;
    get(index: number): number;
    set(index: number, token: number): void;
    head(): number;
    step(offset?: number): InputBuffer;
    seek(mark: Mark): InputBuffer;
    readonly id: string | undefined;
    withId(id: string | undefined): InputBuffer;
    readonly mark: Mark;
    withMark(mark: Mark): InputBuffer;
    get offset(): number;
    get line(): number;
    get column(): number;
    readonly settings: InputSettings;
    withSettings(settings: AnyInputSettings): InputBuffer;
    clone(): InputBuffer;
}

/** @internal */
export declare class InputBufferEmpty extends InputBuffer {
    constructor(id: string | undefined, mark: Mark, settings: InputSettings);
    isCont(): boolean;
    isEmpty(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): InputBuffer;
    get index(): number;
    withIndex(index: number): InputBuffer;
    get limit(): number;
    withLimit(limit: number): InputBuffer;
    get capacity(): number;
    get remaining(): number;
    has(index: number): boolean;
    get(index: number): number;
    set(index: number, token: number): void;
    head(): number;
    step(offset?: number): InputBuffer;
    seek(mark: Mark): InputBuffer;
    readonly id: string | undefined;
    withId(id: string | undefined): InputBuffer;
    readonly mark: Mark;
    withMark(mark: Mark): InputBuffer;
    get offset(): number;
    get line(): number;
    get column(): number;
    readonly settings: InputSettings;
    withSettings(settings: AnyInputSettings): InputBuffer;
    clone(): InputBuffer;
}

/** @internal */
export declare class InputBufferError extends InputBuffer {
    /** @internal */
    readonly error: Error;
    constructor(error: Error, id: string | undefined, mark: Mark, settings: InputSettings);
    isCont(): boolean;
    isEmpty(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): InputBuffer;
    get index(): number;
    withIndex(index: number): InputBuffer;
    get limit(): number;
    withLimit(limit: number): InputBuffer;
    get capacity(): number;
    get remaining(): number;
    has(index: number): boolean;
    get(index: number): number;
    set(index: number, token: number): void;
    head(): number;
    step(offset?: number): InputBuffer;
    trap(): Error;
    seek(mark: Mark): InputBuffer;
    readonly id: string | undefined;
    withId(id: string | undefined): InputBuffer;
    readonly mark: Mark;
    withMark(mark: Mark): InputBuffer;
    get offset(): number;
    get line(): number;
    get column(): number;
    readonly settings: InputSettings;
    withSettings(settings: AnyInputSettings): InputBuffer;
    clone(): InputBuffer;
}

/** @internal */
export declare class InputDone extends Input {
    constructor(id: string | undefined, mark: Mark, settings: InputSettings);
    isCont(): boolean;
    isEmpty(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): Input;
    head(): number;
    step(): Input;
    seek(mark?: Mark): Input;
    readonly id: string | undefined;
    withId(id: string | undefined): Input;
    readonly mark: Mark;
    withMark(mark: Mark): Input;
    get offset(): number;
    get line(): number;
    get column(): number;
    readonly settings: InputSettings;
    withSettings(settings: AnyInputSettings): Input;
    clone(): Input;
}

/** @internal */
export declare class InputEmpty extends Input {
    constructor(id: string | undefined, mark: Mark, settings: InputSettings);
    isCont(): boolean;
    isEmpty(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): Input;
    head(): number;
    step(): Input;
    seek(mark?: Mark): Input;
    readonly id: string | undefined;
    withId(id: string | undefined): Input;
    readonly mark: Mark;
    withMark(mark: Mark): Input;
    get offset(): number;
    get line(): number;
    get column(): number;
    readonly settings: InputSettings;
    withSettings(settings: AnyInputSettings): Input;
    clone(): Input;
}

/** @internal */
export declare class InputError extends Input {
    /** @internal */
    readonly error: Error;
    constructor(error: Error, id: string | undefined, mark: Mark, settings: InputSettings);
    isCont(): boolean;
    isEmpty(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): Input;
    head(): number;
    step(): Input;
    trap(): Error;
    seek(mark?: Mark): Input;
    readonly id: string | undefined;
    withId(id: string | undefined): Input;
    readonly mark: Mark;
    withMark(mark: Mark): Input;
    get offset(): number;
    get line(): number;
    get column(): number;
    readonly settings: InputSettings;
    withSettings(settings: AnyInputSettings): Input;
    clone(): Input;
}

/**
 * Thrown when reading invalid [[Input]].
 * @public
 */
export declare class InputException extends Error {
    constructor(message?: string);
}

/**
 * [[Input]] consumption parameters. `InputSettings` provide contextual
 * configuration parameters to input consumers, such as [[Parser Parsers]].
 * @public
 */
export declare class InputSettings implements HashCode, Debug {
    protected constructor(stripped: boolean);
    /** @internal */
    readonly stripped: boolean;
    /**
     * Returns `true` if input consumers should not include diagnostic metadata
     * in generated output.
     */
    isStripped(): boolean;
    /**
     * Returns a copy of these settings with the given `stripped` flag.
     */
    asStripped(stripped: boolean): InputSettings;
    protected copy(stripped: boolean): InputSettings;
    protected canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    /**
     * Returns `InputSettings` configured to include diagnostic metadata in
     * generated output.
     */
    static standard(): InputSettings;
    /**
     * Returns `InputSettings` configured to omit diagnostic metadata in
     * generated output.
     */
    static stripped(): InputSettings;
    /**
     * Returns `InputSettings` configured to not include diagnostic metadata in
     * generated output, if `isStripped` is `true`.
     */
    static create(isStripped?: boolean): InputSettings;
    /**
     * Converts the loosely typed `settings` to an instance of `InputSettings`.
     */
    static fromAny(settings: AnyInputSettings | undefined): InputSettings;
}

/**
 * [[InputSettings]] object initializer.
 * @public
 */
export declare interface InputSettingsInit {
    isStripped?: boolean;
}

/**
 * Type that can be [[Interpolator interpolated]] to values of type `T`.
 * @public
 */
export declare interface Interpolate<T = unknown> {
    /**
     * Returns an [[Interpolator]] function that blends between `this` value and
     * `that` value, if possible; otherwise returns `null` if `this` is unable to
     * construct an interpolator to `that`.
     */
    interpolateTo(that: unknown): Interpolator<T> | null;
}

/** @public */
export declare const Interpolate: {
    <T>(x: Interpolate<T> | null | undefined, y: unknown): Interpolator<T> | null;
    (x: unknown, y: unknown): Interpolator | null;
    /**
     * Returns `true` if `object` conforms to the [[Interpolate]] interface.
     */
    is(object: unknown): object is Interpolate<unknown>;
};

/** @public */
export declare interface Interpolator<Y = unknown> extends Range_2<Y>, Interpolate<Interpolator<Y>> {
    readonly 0: Y;
    readonly 1: Y;
    map<FY>(transform: (y: Y) => FY): Interpolator<FY>;
    interpolateTo(that: Interpolator<Y>): Interpolator<Interpolator<Y>>;
    interpolateTo(that: unknown): Interpolator<Interpolator<Y>> | null;
    canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
    toString(): string;
}

/** @public */
export declare const Interpolator: {
    <Y>(y0: Y, y1: Y): Interpolator<Y>;
    (y0: unknown, y1: unknown): Interpolator<unknown>;
    /** @internal */
    prototype: Interpolator<any>;
};

/** @internal */
export declare const InterpolatorInterpolator: {
    <Y>(y0: Interpolator<Y>, y1: Interpolator<Y>): Interpolator<Interpolator<Y>>;
    /** @internal */
    prototype: Interpolator<any>;
};

/** @internal */
export declare interface InterpolatorMap<Y, FY> extends Interpolator<FY> {
    /** @internal */
    readonly interpolator: Interpolator<Y>;
    /** @internal */
    readonly transform: (y: Y) => FY;
    readonly 0: FY;
    readonly 1: FY;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const InterpolatorMap: {
    <Y, FY>(interpolator: Interpolator<Y>, transform: (y: Y) => FY): InterpolatorMap<Y, FY>;
    /** @internal */
    prototype: InterpolatorMap<any, any>;
};

/** @public */
export declare class Interpreter {
    constructor(settings?: InterpreterSettings, scopeStack?: Item[] | null, scopeDepth?: number);
    readonly settings: InterpreterSettings;
    withSettings(settings: InterpreterSettings): this;
    /** @internal */
    readonly scopeStack: Item[] | null;
    readonly scopeDepth: number;
    peekScope(): Item;
    getScope(index: number): Item;
    pushScope(scope: Item): void;
    popScope(): Item;
    swapScope(newScope: Item): Item;
    willOperate(operator: Operator): void;
    didOperate(operator: Operator, result: Item): void;
    willSelect(selector: Selector): void;
    didSelect(selector: Selector, result: unknown): void;
    willTransform(selector: Selector): void;
    didTransform(selector: Selector, result: Item): void;
    static of(...objects: AnyItem[]): Interpreter;
    static fromAny(interpreter: AnyInterpreter, globalScope?: Item): Interpreter;
    private static expand;
}

/** @public */
export declare class InterpreterException extends Error {
    constructor(message?: string);
}

/** @public */
export declare class InterpreterSettings implements Debug, HashCode {
    constructor(maxScopeDepth: number);
    readonly maxScopeDepth: number;
    withMaxScopeDepth(maxScopeDepth: number): InterpreterSettings;
    protected copy(maxScopeDepth: number): InterpreterSettings;
    protected canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static standard(): InterpreterSettings;
}

/**
 * [[InterpreterSettings]] object initializer.
 * @public
 */
export declare interface InterpreterSettingsInit {
    maxScopeDepth?: number;
}

/** @public */
export declare class InvokeOperator extends Operator {
    constructor(func: Value, args: Value);
    readonly func: Value;
    readonly args: Value;
    readonly state: unknown;
    setState(state: unknown): void;
    isConstant(): boolean;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    interpolateTo(that: InvokeOperator): Interpolator<InvokeOperator>;
    interpolateTo(that: Item): Interpolator<Item>;
    interpolateTo(that: unknown): Interpolator<Item> | null;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): InvokeOperator;
}

/** @internal */
export declare interface InvokeOperatorInterpolator extends Interpolator<InvokeOperator> {
    /** @internal */
    readonly funcInterpolator: Interpolator<Item>;
    /** @internal */
    readonly argsInterpolator: Interpolator<Item>;
    readonly 0: InvokeOperator;
    readonly 1: InvokeOperator;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const InvokeOperatorInterpolator: {
    (y0: InvokeOperator, y1: InvokeOperator): InvokeOperatorInterpolator;
    /** @internal */
    prototype: InvokeOperatorInterpolator;
};

/** @internal */
export declare class InvokeOutlet extends AbstractOutlet<Value> {
    constructor(scope: Record_2);
    /** @internal */
    readonly scope: Record_2;
    readonly funcInlet: Inlet<Value>;
    readonly argsInlet: Inlet<Value>;
    get(): Value;
}

/** @public */
export declare abstract class Item implements Interpolate<Item>, HashCode, Equivalent, Compare, Debug, Display {
    /** @internal */
    constructor();
    /**
     * Returns `true` if this `Item` is not [[Absent]].
     */
    abstract isDefined(): boolean;
    /**
     * Returns `true` if this `Item` is neither [[Extant]] nor [[Absent]].
     */
    abstract isDistinct(): boolean;
    /**
     * Returns `true` if this `Item` is not one of: an empty `Record`, `False`,
     * `Extant`, or `Absent`.
     */
    abstract isDefinite(): boolean;
    /**
     * Returns `true` if this `Item` always [[Item.evaluate evaluates]] to the
     * same `Item`.
     */
    abstract isConstant(): boolean;
    /**
     * Returns the key component of this `Item`, if this `Item` is a [[Field]];
     * otherwise returns [[Absent]] if this `Item` is a `Value`.
     */
    abstract readonly key: Value;
    /**
     * Returns the value component of this `Item`, if this `Item` is a [[Field]];
     * otherwise returns `this` if this `Item` is a `Value`.
     */
    abstract toValue(): Value;
    /**
     * Returns the `key` string of the first member of this `Item`, if this `Item`
     * is a [[Record]], and its first member is an [[Attr]]; otherwise returns
     * `undefined` if this `Item` is not a `Record`, or if this `Item` is a
     * `Record` whose first member is not an `Attr`.
     *
     * Used to concisely get the name of the discriminating attribute of a
     * structure. The `tag` can be used to discern the nominal type of a
     * polymorphic structure, similar to an XML element tag.
     */
    abstract readonly tag: string | undefined;
    /**
     * Returns the [[Item.flattened flattened]] members of this `Item` after all
     * attributes have been removed, if this `Item` is a [[Record]]; otherwise
     * returns `this` if this `Item` is a non-`Record` `Value`, or returns
     * the value component if this `Item` is a `Field`.
     *
     * Used to concisely get the scalar value of an attributed structure. An
     * attributed structure is a `Record` with one or more attributes that modify
     * one or more other members.
     */
    abstract readonly target: Value;
    /**
     * Returns the sole member of this `Item`, if this `Item` is a [[Record]]
     * with exactly one member, and its member is a `Value`; returns [[Extant]]
     * if this `Item` is an empty `Record`; returns [[Absent]] if this `Item` is
     * a `Field`; otherwise returns `this` if this `Item` is a `Record` with more
     * than one member, or if this `Item` is a non-`Record` `Value`.
     *
     * Used to convert a unary `Record` into its member `Value`. Facilitates
     * writing code that treats a unary `Record` equivalently to a bare `Value`.
     */
    abstract flattened(): Value;
    /**
     * Returns `this` if this `Item` is a [[Record]]; returns a `Record`
     * containing just this `Item`, if this `Item` is [[Item.isDistinct
     * distinct]]; otherwise returns an empty `Record` if this `Item` is
     * [[Extant]] or [[Absent]]. Facilitates writing code that treats a bare
     * `Value` equivalently to a unary `Record`.
     */
    abstract unflattened(): Record_2;
    /**
     * Returns the value of the first member of this `Item`, if this `Item` is a
     * [[Record]], and its first member is an [[Attr]] whose `key` string is
     * equal to `tag`; otherwise returns [[Absent]] if this `Item` is not a
     * `Record`, or if this `Item` is a `Record` whose first member is not an
     * `Attr`, or if this `Item` is a `Record` whose first member is an `Attr`
     * whose `key` does not equal the `tag`.
     *
     * Used to conditionally get the value of the head `Attr` of a structure, if
     * and only if the key string of the head `Attr` is equal to the `tag`. Can
     * be used to check if a structure might conform to a nominal type named
     * `tag`, while simultaneously getting the value of the `tag` attribute.
     */
    abstract header(tag: string): Value;
    /**
     * Returns the [[Item.unflattened unflattened]] [[Item.header header]] of
     * this `Item`, if this `Item` is a [[Record]], and its first member is an
     * [[Attr]] whose `key` string is equal to `tag`; otherwise returns
     * `undefined`.
     *
     * The `headers` of the `tag` attribute of a structure are like the
     * attributes of an XML element tag; through unlike an XML element, `tag`
     * attribute headers are not limited to string keys and values.
     */
    abstract headers(tag: string): Record_2 | undefined;
    /**
     * Returns the first member of this `Item`, if this `Item` is a non-empty
     * [[Record]]; otherwise returns [[Absent]].
     */
    abstract head(): Item;
    /**
     * Returns a view of all but the first member of this `Item`, if this `Item`
     * is a non-empty [[Record]]; otherwise returns an empty `Record` if this
     * `Item` is not a `Record`, or if this `Item` is itself an empty `Record`.
     */
    abstract tail(): Record_2;
    /**
     * Returns the [[Record.flattened flattened]] [[Item.tail tail]] of this
     * `Item`. Used to recursively deconstruct a structure, terminating with its
     * last `Value`, rather than a unary `Record` containing its last value, if
     * the structure ends with a `Value` member.
     */
    abstract body(): Value;
    /**
     * Returns the number of members contained in this `Item`, if this `Item` is
     * a [[Record]]; otherwise returns `0` if this `Item` is not a `Record`.
     */
    abstract readonly length: number;
    /**
     * Returns `true` if this `Item` is a [[Record]] that has a [[Field]] member
     * with a key that is equal to the given `key`; otherwise returns `false` if
     * this `Item` is not a `Record`, or if this `Item` is a `Record`, but has no
     * `Field` member with a key equal to the given `key`.
     */
    abstract has(key: AnyValue): boolean;
    /**
     * Returns the value of the last [[Field]] member of this `Item` whose key
     * is equal to the given `key`; returns [[Absent]] if this `Item` is not a
     * [[Record]], or if this `Item` is a `Record`, but has no `Field` member
     * with a key equal to the given `key`.
     */
    abstract get(key: AnyValue): Value;
    /**
     * Returns the value of the last [[Attr]] member of this `Item` whose key
     * is equal to the given `key`; returns [[Absent]] if this `Item` is not a
     * [[Record]], or if this `Item` is a `Record`, but has no `Attr` member
     * with a key equal to the given `key`.
     */
    abstract getAttr(key: AnyText): Value;
    /**
     * Returns the value of the last [[Slot]] member of this `Item` whose key
     * is equal to the given `key`; returns [[Absent]] if this `Item` is not a
     * [[Record]], or if this `Item` is a `Record`, but has no `Slot` member
     * with a key equal to the given `key`.
     */
    abstract getSlot(key: AnyValue): Value;
    /**
     * Returns the last [[Field]] member of this `Item` whose key is equal to the
     * given `key`; returns `undefined` if this `Item` is not a [[Record]], or if
     * this `Item` is a `Record`, but has no `Field` member with a `key` equal to
     * the given `key`.
     */
    abstract getField(key: AnyValue): Field | undefined;
    /**
     * Returns the member of this `Item` at the given `index`, if this `Item` is
     * a [[Record]], and the `index` is greater than or equal to zero, and less
     * than the [[Record.length length]] of the `Record`; otherwise returns
     * [[Absent]] if this `Item` is not a `Record`, or if this `Item` is a
     * `Record`, but the `index` is out of bounds.
     */
    abstract getItem(index: AnyNum): Item;
    updated(key: AnyValue, value: AnyValue): Record_2;
    updatedAttr(key: AnyText, value: AnyValue): Record_2;
    updatedSlot(key: AnyValue, value: AnyValue): Record_2;
    appended(...items: AnyItem[]): Record_2;
    prepended(...items: AnyItem[]): Record_2;
    abstract deleted(key: AnyValue): Item;
    concat(...items: AnyItem[]): Record_2;
    abstract conditional(thenTerm: Item, elseTerm: Item): Item;
    abstract or(that: Item): Item;
    abstract and(that: Item): Item;
    abstract bitwiseOr(that: AnyItem): Item;
    abstract bitwiseXor(that: AnyItem): Item;
    abstract bitwiseAnd(that: AnyItem): Item;
    lt(that: AnyItem): Item;
    le(that: AnyItem): Item;
    eq(that: AnyItem): Item;
    ne(that: AnyItem): Item;
    ge(that: AnyItem): Item;
    gt(that: AnyItem): Item;
    abstract plus(that: AnyItem): Item;
    abstract minus(that: AnyItem): Item;
    abstract times(that: AnyItem): Item;
    abstract divide(that: AnyItem): Item;
    abstract modulo(that: AnyItem): Item;
    abstract not(): Item;
    abstract bitwiseNot(): Item;
    abstract negative(): Item;
    abstract positive(): Item;
    abstract inverse(): Item;
    invoke(args: Value): Item;
    abstract lambda(template: Value): Value;
    filter(predicate?: AnyItem): Selector;
    max(that: Item): Item;
    min(that: Item): Item;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    /**
     * Converts this `Item` into a `string` value, if possible; otherwise returns
     * `undefined` if this `Item` can't be converted into a `string` value.
     */
    abstract stringValue(): string | undefined;
    /**
     * Converts this `Item` into a `string` value, if possible; otherwise returns
     * `orElse` if this `Item` can't be converted into a `string` value.
     */
    abstract stringValue<T>(orElse: T): string | T;
    /**
     * Converts this `Item` into a `number` value, if possible; otherwise returns
     * `undefined` if this `Item` can't be converted into a `number` value.
     */
    abstract numberValue(): number | undefined;
    /**
     * Converts this `Item` into a `number` value, if possible; otherwise returns
     * `orElse` if this `Item` can't be converted into a `number` value.
     */
    abstract numberValue<T>(orElse: T): number | T;
    /**
     * Converts this `Item` into a `boolean` value, if possible; otherwise returns
     * `undefined` if this `Item` can't be converted into a `boolean` value.
     */
    abstract booleanValue(): boolean | undefined;
    /**
     * Converts this `Item` into a `boolean` value, if possible; otherwise returns
     * `orElse` if this `Item` can't be converted into a `boolean` value.
     */
    abstract booleanValue<T>(orElse: T): boolean | T;
    cast<T>(form: Form<T, unknown>): T | undefined;
    cast<T, E = T>(form: Form<T, unknown>, orElse: E): T | E;
    coerce<T>(form: Form<T, unknown>): T;
    coerce<T, E = T>(form: Form<T, unknown>, orElse: E): T | E;
    abstract toAny(): AnyItem;
    abstract isAliased(): boolean;
    abstract isMutable(): boolean;
    abstract alias(): void;
    abstract branch(): Item;
    abstract clone(): Item;
    abstract commit(): this;
    /** @internal */
    get precedence(): number;
    forEach<T>(callback: (item: Item, index: number) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, item: Item, index: number) => T | void, thisArg: S): T | undefined;
    iterator(): Cursor<Item>;
    interpolateTo(that: Item): Interpolator<Item>;
    interpolateTo(that: unknown): Interpolator<Item> | null;
    /**
     * Returns the heterogeneous sort order of this `Item`. Used to impose a
     * total order on the set of all items. When comparing two items of
     * different types, the items order according to their `typeOrder`.
     */
    abstract readonly typeOrder: number;
    abstract compareTo(that: unknown): number;
    abstract equivalentTo(that: unknown, epsilon?: number): boolean;
    abstract keyEquals(key: unknown): boolean;
    abstract equals(that: unknown): boolean;
    abstract hashCode(): number;
    abstract debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    toString(): string;
    static empty(): Item;
    static extant(): Item;
    static absent(): Item;
    static fromAny(item: AnyItem): Item;
    static globalScope(): Item;
}

/** @internal */
export declare class ItemForm extends Form<Item, AnyItem> {
    constructor(unit?: Item);
    readonly unit: Item | undefined;
    withUnit(unit: Item | undefined): Form<Item>;
    mold(object: AnyItem, item?: Item): Item;
    cast(item: Item, object?: Item): Item | undefined;
}

/** @internal */
export declare const ItemInterpolator: {
    <Y extends Item>(y0: Y, y1: Y): Interpolator<Y>;
    /** @internal */
    prototype: Interpolator<any>;
};

/** @public */
declare interface Iterator_2<T> {
    next(): {
        value?: T;
        done: boolean;
    };
}
export { Iterator_2 as Iterator }

/** @public */
export declare const enum KeyEffect {
    Update = 0,
    Remove = 1
}

/** @public */
export declare class KeyOutlet<K, V> extends AbstractOutlet<V> {
    constructor(input: MapOutlet<K, V, unknown>, key: K);
    readonly input: MapOutlet<K, V, unknown>;
    readonly key: K;
    get(): V | undefined;
}

/** @internal */
export declare class KeysCursor<K, V> extends Cursor<K> {
    constructor(cursor: Cursor<[K, V]>);
    /** @internal */
    readonly cursor: Cursor<[K, V]>;
    isEmpty(): boolean;
    head(): K;
    step(): void;
    skip(count: number): void;
    hasNext(): boolean;
    nextIndex(): number;
    next(): {
        value?: K;
        done: boolean;
    };
    hasPrevious(): boolean;
    previousIndex(): number;
    previous(): {
        value?: K;
        done: boolean;
    };
    delete(): void;
}

/** @public */
export declare class KeysSelector extends Selector {
    constructor(then: Selector);
    readonly then: Selector;
    forSelected<T>(interpreter: Interpreter, callback: (interpreter: Interpreter) => T | undefined): T | undefined;
    forSelected<T, S>(interpreter: Interpreter, callback: (this: S, interpreter: Interpreter) => T | undefined, thisArg: S): T | undefined;
    mapSelected(interpreter: Interpreter, transform: (interpreter: Interpreter) => Item): Item;
    mapSelected<S>(interpreter: Interpreter, transform: (this: S, interpreter: Interpreter) => Item, thisArg: S): Item;
    substitute(interpreter: AnyInterpreter): Item;
    andThen(then: Selector): Selector;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debugThen<T>(output: Output<T>): Output<T>;
    clone(): Selector;
}

/** @public */
export declare class LambdaFunc extends Func {
    constructor(bindings: Value, template: Value);
    readonly bindings: Value;
    readonly template: Value;
    get precedence(): number;
    invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
}

/** @public */
export declare abstract class LaneAddressed<E extends LaneAddressed<E> = LaneAddressed<any>> extends Envelope<E> {
    constructor(node: Uri, lane: Uri, body: Value);
    readonly node: Uri;
    withNode(node: AnyUri): E;
    readonly lane: Uri;
    withLane(lane: AnyUri): E;
    readonly body: Value;
    withBody(body: AnyValue): E;
    protected copy(node: Uri, lane: Uri, body: Value): E;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toValue(): Value;
    static fromValue<S extends LaneAddressedConstructor<InstanceType<S>>>(this: S, value: Value): InstanceType<S> | null;
    static create<S extends LaneAddressedConstructor<InstanceType<S>>>(this: S, node: AnyUri, lane: AnyUri, body?: AnyValue): InstanceType<S>;
}

/** @public */
export declare interface LaneAddressedConstructor<E extends LaneAddressed<E> = LaneAddressed<any>> {
    new (node: Uri, lane: Uri, body: Value): E;
    readonly tag: string;
}

/** @public */
export declare class LaneRef extends BaseRef {
    constructor(context: RefContext, hostUri: Uri, nodeUri: Uri, laneUri: Uri);
    readonly hostUri: Uri;
    readonly nodeUri: Uri;
    readonly laneUri: Uri;
    hostRef(hostUri: AnyUri): HostRef;
    nodeRef(nodeUri: AnyUri): NodeRef;
    laneRef(laneUri: AnyUri): LaneRef;
    downlink(init?: EventDownlinkInit): EventDownlink;
    downlinkList(init?: ListDownlinkInit<Value, AnyValue>): ListDownlink<Value, AnyValue>;
    downlinkList<V extends VU, VU = never>(init?: ListDownlinkInit<V, VU>): ListDownlink<V, VU>;
    downlinkMap(init?: MapDownlinkInit<Value, Value, AnyValue, AnyValue>): MapDownlink<Value, Value, AnyValue, AnyValue>;
    downlinkMap<K extends KU, V extends VU, KU = never, VU = never>(init?: MapDownlinkInit<K, V, KU, VU>): MapDownlink<K, V, KU, VU>;
    downlinkValue(init?: ValueDownlinkInit<Value, AnyValue>): ValueDownlink<Value, AnyValue>;
    downlinkValue<V extends VU, VU = never>(init?: ValueDownlinkInit<V, VU>): ValueDownlink<V, VU>;
    command(body: AnyValue): void;
}

/** @public */
export declare const laneRef: typeof client.laneRef;

/**
 * Decorator that memoizes the computed value of a getter or nullary method.
 * @public
 */
export declare const Lazy: MethodDecorator;

/** @public */
export declare abstract class Length implements Interpolate<Length>, HashCode, Equivalent, Compare, Debug {
    isDefined(): boolean;
    abstract readonly value: number;
    abstract readonly units: LengthUnits;
    plus(that: AnyLength, units?: LengthUnits, basis?: LengthBasis | number): Length;
    negative(units?: LengthUnits, basis?: LengthBasis | number): Length;
    minus(that: AnyLength, units?: LengthUnits, basis?: LengthBasis | number): Length;
    times(scalar: number, units?: LengthUnits, basis?: LengthBasis | number): Length;
    divide(scalar: number, units?: LengthUnits, basis?: LengthBasis | number): Length;
    combine(that: AnyLength, scalar?: number, units?: LengthUnits, basis?: LengthBasis | number): Length;
    abstract pxValue(basis?: LengthBasis | number): number;
    emValue(basis?: LengthBasis | number): number;
    remValue(basis?: LengthBasis | number): number;
    pctValue(basis?: LengthBasis | number): number;
    px(basis?: LengthBasis | number): PxLength;
    em(basis?: LengthBasis | number): EmLength;
    rem(basis?: LengthBasis | number): RemLength;
    pct(basis?: LengthBasis | number): PctLength;
    toValue(): Value;
    toValue(units: LengthUnits, basis?: LengthBasis | number): number;
    to(units: LengthUnits, basis?: LengthBasis | number): Length;
    abstract toCssValue(): CSSUnitValue | null;
    interpolateTo(that: Length): Interpolator<Length>;
    interpolateTo(that: unknown): Interpolator<Length> | null;
    abstract compareTo(that: unknown): number;
    abstract equivalentTo(that: unknown, epsilon?: number): boolean;
    abstract equals(that: unknown): boolean;
    abstract hashCode(): number;
    abstract debug<T>(output: Output<T>): Output<T>;
    abstract toString(): string;
    static zero(units?: LengthUnits): Length;
    static px(value: number): PxLength;
    static em(value: number): EmLength;
    static rem(value: number): RemLength;
    static pct(value: number): PctLength;
    static unitless(value: number): UnitlessLength;
    static create(value: number, units?: LengthUnits): Length;
    static fromCssValue(value: CSSStyleValue): Length;
    static fromAny(value: AnyLength, defaultUnits?: LengthUnits): Length;
    static fromValue(value: Value): Length | null;
    static parse(string: string, defaultUnits?: LengthUnits): Length;
    static form(): Form<Length, AnyLength>;
    /** @internal */
    static isAny(value: unknown): value is AnyLength;
    /** @internal */
    static emUnit(basis?: LengthBasis | number): number;
    /** @internal */
    static remUnit(basis?: LengthBasis | number): number;
    /** @internal */
    static pctUnit(basis?: LengthBasis | number): number;
}

/** @public */
export declare interface LengthBasis {
    emUnit?: Node | number;
    remUnit?: number;
    pctUnit?: number;
}

/** @public */
export declare class LengthException extends Error {
    constructor(message?: string);
}

/** @internal */
export declare class LengthForm extends Form<Length, AnyLength> {
    constructor(defaultUnits: LengthUnits | undefined, unit: Length | undefined);
    readonly defaultUnits: LengthUnits | undefined;
    readonly unit: Length | undefined;
    withUnit(unit: Length | undefined): Form<Length, AnyLength>;
    mold(length: AnyLength): Item;
    cast(item: Item): Length | undefined;
}

/** @internal */
export declare const LengthInterpolator: {
    (l0: Length, l1: Length): Interpolator<Length>;
    /** @internal */
    prototype: Interpolator<Length>;
};

/** @internal */
export declare class LengthParser extends Parser<Length> {
    private readonly defaultUnits;
    private readonly valueParser;
    private readonly unitsOutput;
    private readonly step;
    constructor(defaultUnits?: LengthUnits, valueParser?: Parser<number>, unitsOutput?: Output<string>, step?: number);
    feed(input: Input): Parser<Length>;
    static parse(input: Input, defaultUnits?: LengthUnits, valueParser?: Parser<number>, unitsOutput?: Output<string>, step?: number): Parser<Length>;
}

/** @public */
export declare type LengthUnits = "px" | "em" | "rem" | "%" | "";

/** @public */
export declare class LeOperator extends BinaryOperator {
    constructor(operand1: Item, operand2: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): LeOperator;
}

/** @internal */
export declare class LeOutlet extends BinaryOutlet {
    protected evaluate(argument1: Value, argument2: Value): Item;
}

/** @public */
export declare interface LinearDomain extends Domain<number>, Interpolate<LinearDomain> {
    readonly 0: number;
    readonly 1: number;
    readonly inverse: LinearRange;
    contains(x: number): boolean;
    interpolateTo(that: LinearDomain): Interpolator<LinearDomain>;
    interpolateTo(that: unknown): Interpolator<LinearDomain> | null;
    canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
    toString(): string;
}

/** @public */
export declare const LinearDomain: {
    (x0: number, x1: number): LinearDomain;
    /** @internal */
    prototype: LinearDomain;
};

/** @internal */
export declare const LinearDomainInterpolator: {
    (x0: LinearDomain, x1: LinearDomain): Interpolator<LinearDomain>;
    /** @internal */
    prototype: Interpolator<LinearDomain>;
};

/** @public */
export declare interface LinearRange extends Range_2<number>, Interpolate<LinearRange> {
    readonly 0: number;
    readonly 1: number;
    readonly inverse: LinearDomain;
    interpolateTo(that: LinearRange): Interpolator<LinearRange>;
    interpolateTo(that: unknown): Interpolator<LinearRange> | null;
    canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
    toString(): string;
}

/** @public */
export declare const LinearRange: {
    (y0: number, y1: number): LinearRange;
    /** @internal */
    prototype: LinearRange;
};

/** @internal */
export declare const LinearRangeInterpolator: {
    (y0: LinearRange, y1: LinearRange): Interpolator<LinearRange>;
    /** @internal */
    prototype: Interpolator<LinearRange>;
};

/** @public */
export declare interface LinearScale extends ContinuousScale<number, number>, Interpolate<LinearScale> {
    readonly domain: LinearDomain;
    readonly range: LinearRange;
    readonly inverse: LinearScale;
    withDomain(domain: LinearDomain): LinearScale;
    withDomain(x0: number, x1: number): LinearScale;
    overRange(range: LinearRange): LinearScale;
    overRange(y0: number, y1: number): LinearScale;
    clampDomain(xMin: number | undefined, xMax: number | undefined, zMin: number | undefined, zMax: number | undefined, epsilon?: number): LinearScale;
    solveDomain(x1: number, y1: number, x2?: number, y2?: number, reflect?: boolean, epsilon?: number): LinearScale;
    interpolateTo(that: LinearScale): Interpolator<LinearScale>;
    interpolateTo(that: unknown): Interpolator<LinearScale> | null;
    canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
    toString(): string;
}

/** @public */
export declare const LinearScale: {
    (domain: LinearDomain, range: LinearRange): LinearScale;
    /** @internal */
    prototype: LinearScale;
};

/** @internal */
export declare const LinearScaleInterpolator: {
    (s0: LinearScale, s1: LinearScale): Interpolator<LinearScale>;
    /** @internal */
    prototype: Interpolator<LinearScale>;
};

/** @public */
export declare abstract class LinkAddressed<E extends LinkAddressed<E> = LinkAddressed<any>> extends Envelope {
    constructor(node: Uri, lane: Uri, prio: number, rate: number, body: Value);
    readonly node: Uri;
    withNode(node: AnyUri): E;
    readonly lane: Uri;
    withLane(lane: AnyUri): E;
    readonly prio: number;
    withPrio(prio: number): E;
    readonly rate: number;
    withRate(rate: number): E;
    readonly body: Value;
    withBody(body: AnyValue): E;
    protected copy(node: Uri, lane: Uri, prio: number, rate: number, body: Value): E;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toValue(): Value;
    static fromValue<S extends LinkAddressedConstructor<InstanceType<S>>>(this: S, value: Value): InstanceType<S> | null;
    static create<S extends LinkAddressedConstructor<InstanceType<S>>>(this: S, node: AnyUri, lane: AnyUri, prio?: number, rate?: number, body?: AnyValue): InstanceType<S>;
}

/** @public */
export declare interface LinkAddressedConstructor<E extends LinkAddressed<E> = LinkAddressed<any>> {
    new (node: Uri, lane: Uri, prio: number, rate: number, body: Value): E;
    readonly tag: string;
}

/** @public */
export declare class LinkedResponse extends LinkAddressed<LinkedResponse> {
    static readonly tag: string;
}

/** @public */
export declare class LinkRequest extends LinkAddressed<LinkRequest> {
    static readonly tag: string;
}

/** @public */
export declare class ListDownlink<V, VU = never> extends Downlink {
    /** @internal */
    constructor(context: DownlinkContext, owner: DownlinkOwner | null, init?: ListDownlinkInit<V, VU>, hostUri?: Uri, nodeUri?: Uri, laneUri?: Uri, prio?: number, rate?: number, body?: Value, flags?: number, observers?: ReadonlyArray<ListDownlinkObserver<V, VU>> | ListDownlinkObserver<V, VU>, valueForm?: Form<V, VU>, state0?: STree<Value, Value> | null);
    /** @internal */
    readonly model: ListDownlinkModel | null;
    /** @internal */
    readonly observers: ReadonlyArray<ListDownlinkObserver<V, VU>>;
    /** @internal */
    readonly ownValueForm: Form<V, VU>;
    /** @internal */
    readonly state0: STree<Value, Value> | null;
    get type(): DownlinkType;
    /** @internal */
    protected copy<V, VU>(context: DownlinkContext, owner: DownlinkOwner | null, hostUri: Uri, nodeUri: Uri, laneUri: Uri, prio: number, rate: number, body: Value, flags: number, observers: ReadonlyArray<ListDownlinkObserver<V, VU>>, valueForm?: Form<V, VU>, state0?: STree<Value, Value> | null): ListDownlink<V, VU>;
    valueForm(): Form<V, VU>;
    valueForm<V2, V2U = never>(valueForm: Form<V2, V2U>): ListDownlink<V2, V2U>;
    get length(): number;
    isEmpty(): boolean;
    get(index: number, id?: Value): V;
    getEntry(index: number, id?: Value): [V, Value] | undefined;
    set(index: number, newObject: V | VU, id?: Value): this;
    insert(index: number, newObject: V | VU, id?: Value): this;
    remove(index: number, id?: Value): this;
    push(...newObjects: (V | VU)[]): number;
    pop(): V;
    unshift(...newObjects: (V | VU)[]): number;
    shift(): V;
    move(fromIndex: number, toIndex: number, id?: Value): this;
    splice(start: number, deleteCount?: number, ...newObjects: (V | VU)[]): V[];
    clear(): void;
    forEach<T, S>(callback: (value: V, index: number, id: Value) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, value: V, index: number, id: Value) => T | void, thisArg: S): T | undefined;
    values(): Cursor<V>;
    keys(): Cursor<Value>;
    entries(): Cursor<[Value, V]>;
    snapshot(): STree<Value, Value>;
    setState(state: STree<Value, Value>): void;
    observe(observer: ListDownlinkObserver<V, VU>): this;
    willUpdate(willUpdate: ListDownlinkWillUpdate<V, VU>): this;
    didUpdate(didUpdate: ListDownlinkDidUpdate<V, VU>): this;
    willMove(willMove: ListDownlinkWillMove<V, VU>): this;
    didMove(didMove: ListDownlinkDidMove<V, VU>): this;
    willRemove(willRemove: ListDownlinkWillRemove<V, VU>): this;
    didRemove(didRemove: ListDownlinkDidRemove<V, VU>): this;
    willDrop(willDrop: ListDownlinkWillDrop<V, VU>): this;
    didDrop(didDrop: ListDownlinkDidDrop<V, VU>): this;
    willTake(willTake: ListDownlinkWillTake<V, VU>): this;
    didTake(didTake: ListDownlinkDidTake<V, VU>): this;
    willClear(willClear: ListDownlinkWillClear<V, VU>): this;
    didClear(didClear: ListDownlinkDidClear<V, VU>): this;
    /** @internal */
    listWillUpdate(index: number, newValue: Value): Value;
    /** @internal */
    listDidUpdate(index: number, newValue: Value, oldValue: Value): void;
    /** @internal */
    listWillMove(fromIndex: number, toIndex: number, value: Value): void;
    /** @internal */
    listDidMove(fromIndex: number, toIndex: number, value: Value): void;
    /** @internal */
    listWillRemove(index: number): void;
    /** @internal */
    listDidRemove(index: number, oldValue: Value): void;
    /** @internal */
    listWillDrop(lower: number): void;
    /** @internal */
    listDidDrop(lower: number): void;
    /** @internal */
    listWillTake(upper: number): void;
    /** @internal */
    listDidTake(upper: number): void;
    /** @internal */
    listWillClear(): void;
    /** @internal */
    listDidClear(): void;
    initialState(): STree<Value, Value> | null;
    initialState(state0: STree<Value, Value> | null): ListDownlink<V, VU>;
    /** @internal */
    protected didAliasModel(): void;
    open(): this;
}

/** @public */
export declare interface ListDownlink<V, VU> {
    hostUri(): Uri;
    hostUri(hostUri: AnyUri): ListDownlink<V, VU>;
    nodeUri(): Uri;
    nodeUri(nodeUri: AnyUri): ListDownlink<V, VU>;
    laneUri(): Uri;
    laneUri(laneUri: AnyUri): ListDownlink<V, VU>;
    prio(): number;
    prio(prio: number): ListDownlink<V, VU>;
    rate(): number;
    rate(rate: number): ListDownlink<V, VU>;
    body(): Value;
    body(body: AnyValue): ListDownlink<V, VU>;
    keepLinked(): boolean;
    keepLinked(keepLinked: boolean): ListDownlink<V, VU>;
    keepSynced(): boolean;
    keepSynced(keepSynced: boolean): ListDownlink<V, VU>;
}

/** @public */
export declare type ListDownlinkDidClear<V, VU = never> = (downlink: ListDownlink<V, VU>) => void;

/** @public */
export declare type ListDownlinkDidDrop<V, VU = never> = (lower: number, downlink: ListDownlink<V, VU>) => void;

/** @public */
export declare type ListDownlinkDidMove<V, VU = never> = (fromIndex: number, toIndex: number, value: V, downlink: ListDownlink<V, VU>) => void;

/** @public */
export declare type ListDownlinkDidRemove<V, VU = never> = (index: number, oldValue: V, downlink: ListDownlink<V, VU>) => void;

/** @public */
export declare type ListDownlinkDidTake<V, VU = never> = (upper: number, downlink: ListDownlink<V, VU>) => void;

/** @public */
export declare type ListDownlinkDidUpdate<V, VU = never> = (index: number, newValue: V, oldValue: V, downlink: ListDownlink<V, VU>) => void;

/** @beta */
export declare interface ListDownlinkFastener<O = unknown, V = unknown, VU = V> extends DownlinkFastener<O> {
    (index: number): V | undefined;
    (index: number, newObject: V | VU): O;
    /** @internal */
    readonly ownValueForm: Form<V, VU> | null;
    get length(): number;
    valueForm(): Form<V, VU> | null;
    valueForm(valueForm: Form<V, VU> | null): this;
    isEmpty(): boolean;
    get(index: number, id?: Value): V | undefined;
    getEntry(index: number, id?: Value): [V, Value] | undefined;
    set(index: number, newObject: V | VU, id?: Value): this;
    insert(index: number, newObject: V | VU, id?: Value): this;
    remove(index: number, id?: Value): this;
    push(...newObjects: (V | VU)[]): number;
    pop(): V | undefined;
    unshift(...newObjects: (V | VU)[]): number;
    shift(): V | undefined;
    move(fromIndex: number, toIndex: number, id?: Value): this;
    splice(start: number, deleteCount?: number, ...newObjects: (V | VU)[]): V[];
    clear(): void;
    forEach<T>(callback: (value: V, index: number, id: Value) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, value: V, index: number, id: Value) => T | void, thisArg: S): T | undefined;
    values(): Cursor<V>;
    keys(): Cursor<Value>;
    entries(): Cursor<[Value, V]>;
    /** @override */
    readonly downlink: ListDownlink<V, VU> | null;
    /** @internal @override */
    createDownlink(warp: WarpRef): ListDownlink<V, VU>;
    /** @internal @override */
    bindDownlink(downlink: ListDownlink<V, VU>): ListDownlink<V, VU>;
    /** @internal */
    initDownlink?(downlink: ListDownlink<V, VU>): ListDownlink<V, VU>;
}

/** @beta */
export declare const ListDownlinkFastener: ListDownlinkFastenerFactory<ListDownlinkFastener<any, any, any>>;

/** @beta */
export declare interface ListDownlinkFastenerClass<F extends ListDownlinkFastener<any, any> = ListDownlinkFastener<any, any>> extends DownlinkFastenerClass<F> {
}

/** @beta */
export declare type ListDownlinkFastenerDescriptor<O = unknown, V = unknown, VU = V, I = {}> = ThisType<ListDownlinkFastener<O, V, VU> & I> & ListDownlinkFastenerInit<V, VU> & Partial<I>;

/** @beta */
export declare interface ListDownlinkFastenerFactory<F extends ListDownlinkFastener<any, any> = ListDownlinkFastener<any, any>> extends ListDownlinkFastenerClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ListDownlinkFastenerFactory<F> & I;
    define<O, V extends Value = Value, VU extends AnyValue = AnyValue>(className: string, descriptor: ListDownlinkFastenerDescriptor<O, V, VU>): ListDownlinkFastenerFactory<ListDownlinkFastener<any, V, VU>>;
    define<O, V, VU = V>(className: string, descriptor: {
        valueForm: Form<V, VU>;
    } & ListDownlinkFastenerDescriptor<O, V, VU>): ListDownlinkFastenerFactory<ListDownlinkFastener<any, V, VU>>;
    define<O, V extends Value, VU extends AnyValue = AnyValue, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ListDownlinkFastenerDescriptor<O, V, VU, I>): ListDownlinkFastenerFactory<ListDownlinkFastener<any, V, VU> & I>;
    define<O, V, VU = V, I = {}>(className: string, descriptor: {
        implements: unknown;
        valueForm: Form<V, VU>;
    } & ListDownlinkFastenerDescriptor<O, V, VU, I>): ListDownlinkFastenerFactory<ListDownlinkFastener<any, V, VU> & I>;
    <O, V extends Value = Value, VU extends AnyValue = AnyValue>(descriptor: ListDownlinkFastenerDescriptor<O, V, VU>): PropertyDecorator;
    <O, V, VU = V>(descriptor: {
        valueForm: Form<V, VU>;
    } & ListDownlinkFastenerDescriptor<O, V, VU>): PropertyDecorator;
    <O, V extends Value, VU extends AnyValue = AnyValue, I = {}>(descriptor: {
        implements: unknown;
    } & ListDownlinkFastenerDescriptor<O, V, VU, I>): PropertyDecorator;
    <O, V, VU = V, I = {}>(descriptor: {
        implements: unknown;
        valueForm: Form<V, VU>;
    } & ListDownlinkFastenerDescriptor<O, V, VU, I>): PropertyDecorator;
}

/** @beta */
export declare interface ListDownlinkFastenerInit<V = unknown, VU = V> extends DownlinkFastenerInit, ListDownlinkObserver<V, VU> {
    extends?: {
        prototype: ListDownlinkFastener<any, any>;
    } | string | boolean | null;
    valueForm?: Form<V, VU>;
    initDownlink?(downlink: ListDownlink<V, VU>): ListDownlink<V, VU>;
}

/** @internal */
export declare type ListDownlinkFastenerInitType<F extends ListDownlinkFastener<any, any>> = F extends ListDownlinkFastener<any, infer V, infer VU> ? V | VU : never;

/** @internal */
export declare type ListDownlinkFastenerType<F extends ListDownlinkFastener<any, any>> = F extends ListDownlinkFastener<any, infer V, any> ? V : never;

/** @public */
export declare interface ListDownlinkInit<V, VU = never> extends ListDownlinkObserver<V, VU>, DownlinkInit {
    valueForm?: Form<V, VU>;
}

/** @internal */
export declare class ListDownlinkModel extends DownlinkModel {
    constructor(context: DownlinkContext, hostUri: Uri, nodeUri: Uri, laneUri: Uri, prio?: number, rate?: number, body?: Value, state?: STree<Value, Value>);
    readonly views: ReadonlyArray<ListDownlink<unknown>>;
    /** @internal */
    readonly state: STree<Value, Value>;
    get type(): DownlinkType;
    get length(): number;
    isEmpty(): boolean;
    get(index: number, key?: Value): Value;
    getEntry(index: number, key?: Value): [Value, Value] | undefined;
    set(index: number, newValue: Value, key?: Value): this;
    insert(index: number, newValue: Value, key?: Value): this;
    remove(index: number, key?: Value): this;
    push(...newValues: Value[]): number;
    pop(): Value;
    unshift(...newValues: Value[]): number;
    shift(): Value;
    move(fromIndex: number, toIndex: number, key?: Value): this;
    splice(start: number, deleteCount?: number, ...newValues: Value[]): Value[];
    clear(): void;
    forEach<T>(callback: (value: Value, index: number, key: Value) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, value: Value, index: number, key: Value) => T | void, thisArg: S): T | undefined;
    values(): Cursor<Value>;
    keys(): Cursor<Value>;
    entries(): Cursor<[Value, Value]>;
    snapshot(): STree<Value, Value>;
    setState(state: STree<Value, Value>): void;
    onEventMessage(message: EventMessage, host: Host): void;
    protected onInsertEvent(index: number, newValue: Value, key: Value): void;
    protected onUpdateEvent(index: number, newValue: Value, key: Value): void;
    protected onMoveEvent(fromIndex: number, toIndex: number, key: Value): void;
    protected onRemoveEvent(index: number, key: Value): void;
    protected onDropEvent(lower: number): void;
    protected onTakeEvent(upper: number): void;
    protected onClearEvent(): void;
    protected listWillUpdate(index: number, newValue: Value): Value;
    protected listDidUpdate(index: number, newValue: Value, oldValue: Value): void;
    protected listWillMove(fromIndex: number, toIndex: number, value: Value): void;
    protected listDidMove(fromIndex: number, toIndex: number, value: Value): void;
    protected listWillRemove(index: number): void;
    protected listDidRemove(index: number, oldValue: Value): void;
    protected listWillDrop(lower: number): void;
    protected listDidDrop(lower: number): void;
    protected listWillTake(upper: number): void;
    protected listDidTake(upper: number): void;
    protected listWillClear(): void;
    protected listDidClear(): void;
}

/** @public */
export declare interface ListDownlinkObserver<V, VU = never> extends DownlinkObserver {
    willUpdate?: ListDownlinkWillUpdate<V, VU>;
    didUpdate?: ListDownlinkDidUpdate<V, VU>;
    willMove?: ListDownlinkWillMove<V, VU>;
    didMove?: ListDownlinkDidMove<V, VU>;
    willRemove?: ListDownlinkWillRemove<V, VU>;
    didRemove?: ListDownlinkDidRemove<V, VU>;
    willDrop?: ListDownlinkWillDrop<V, VU>;
    didDrop?: ListDownlinkDidDrop<V, VU>;
    willTake?: ListDownlinkWillTake<V, VU>;
    didTake?: ListDownlinkDidTake<V, VU>;
    willClear?: ListDownlinkWillClear<V, VU>;
    didClear?: ListDownlinkDidClear<V, VU>;
}

/** @public */
export declare class ListDownlinkRecord extends DownlinkRecord {
    constructor(downlink: ListDownlink<Value, AnyValue>);
    readonly downlink: ListDownlink<Value, AnyValue>;
    isEmpty(): boolean;
    isArray(): boolean;
    isObject(): boolean;
    get length(): number;
    has(key: AnyValue): boolean;
    get(): Record_2;
    get(key: AnyValue): Value;
    getAttr(key: AnyText): Value;
    getSlot(key: AnyValue): Value;
    getItem(index: AnyNum): Item;
    set(key: AnyValue, newValue: AnyValue): this;
    setAttr(key: AnyText, newValue: AnyValue): this;
    setSlot(key: AnyValue, newValue: AnyValue): this;
    setItem(index: AnyNum, newItem: AnyItem): this;
    push(...newItems: AnyItem[]): number;
    splice(start: number, deleteCount?: number, ...newItems: AnyItem[]): Item[];
    delete(key: AnyValue): Item;
    clear(): void;
    forEach<T>(callback: (item: Item, index: number) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, item: Item, index: number) => T | void, thisArg: S): T | undefined;
    keyIterator(): Cursor<Value>;
}

/** @public */
export declare type ListDownlinkWillClear<V, VU = never> = (downlink: ListDownlink<V, VU>) => void;

/** @public */
export declare type ListDownlinkWillDrop<V, VU = never> = (lower: number, downlink: ListDownlink<V, VU>) => void;

/** @public */
export declare type ListDownlinkWillMove<V, VU = never> = (fromIndex: number, toIndex: number, value: V, downlink: ListDownlink<V, VU>) => void;

/** @public */
export declare type ListDownlinkWillRemove<V, VU = never> = (index: number, downlink: ListDownlink<V, VU>) => void;

/** @public */
export declare type ListDownlinkWillTake<V, VU = never> = (upper: number, downlink: ListDownlink<V, VU>) => void;

/** @public */
export declare type ListDownlinkWillUpdate<V, VU = never> = (index: number, newValue: V, downlink: ListDownlink<V, VU>) => V | void;

/** @public */
export declare class LiteralSelector extends Selector {
    constructor(item: Item, then: Selector);
    readonly item: Item;
    readonly then: Selector;
    forSelected<T>(interpreter: Interpreter, callback: (interpreter: Interpreter) => T | undefined): T | undefined;
    forSelected<T, S>(interpreter: Interpreter, callback: (this: S, interpreter: Interpreter) => T | undefined, thisArg: S): T | undefined;
    mapSelected(interpreter: Interpreter, transform: (interpreter: Interpreter) => Item): Item;
    mapSelected<S>(interpreter: Interpreter, transform: (this: S, interpreter: Interpreter) => Item, thisArg: S): Item;
    substitute(interpreter: AnyInterpreter): Item;
    andThen(then: Selector): Selector;
    get precedence(): number;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    debugThen<T>(output: Output<T>): Output<T>;
    clone(): Selector;
}

/** @public */
export declare class LtOperator extends BinaryOperator {
    constructor(operand1: Item, operand2: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): LtOperator;
}

/** @internal */
export declare class LtOutlet extends BinaryOutlet {
    protected evaluate(argument1: Value, argument2: Value): Item;
}

/** @public */
declare interface Map_2<K = unknown, V = unknown> {
    readonly size: number;
    isEmpty(): boolean;
    has(key: K): boolean;
    get(key: K): V | undefined;
    set(key: K, newValue: V): this;
    delete(key: K): boolean;
    clear(): void;
    forEach<T>(callback: (key: K, value: V) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, key: K, value: V) => T | void, thisArg: S): T | undefined;
    keys(): Iterator_2<K>;
    values(): Iterator_2<V>;
    entries(): Iterator_2<[K, V]>;
}
export { Map_2 as Map }

/** @public */
export declare class MapDownlink<K, V, KU = never, VU = never> extends Downlink implements OrderedMap<K, V>, MapInlet<K, V, Map_2<K, V>>, MapOutlet<K, V, MapDownlink<K, V, KU, VU>> {
    /** @internal */
    constructor(context: DownlinkContext, owner: DownlinkOwner | null, init?: MapDownlinkInit<K, V, KU, VU>, hostUri?: Uri, nodeUri?: Uri, laneUri?: Uri, prio?: number, rate?: number, body?: Value, flags?: number, observers?: ReadonlyArray<MapDownlinkObserver<K, V, KU, VU>> | MapDownlinkObserver<K, V, KU, VU>, keyForm?: Form<K, KU>, valueForm?: Form<V, VU>, state0?: BTree<Value, Value> | null);
    /** @internal */
    readonly model: MapDownlinkModel | null;
    /** @internal */
    readonly observers: ReadonlyArray<MapDownlinkObserver<K, V, KU, VU>>;
    /** @internal */
    readonly ownKeyForm: Form<K, KU>;
    /** @internal */
    readonly ownValueForm: Form<V, VU>;
    /** @internal */
    readonly state0: BTree<Value, Value> | null;
    get type(): DownlinkType;
    /** @internal */
    protected copy<K, V, KU, VU>(context: DownlinkContext, owner: DownlinkOwner | null, hostUri: Uri, nodeUri: Uri, laneUri: Uri, prio: number, rate: number, body: Value, flags: number, observers: ReadonlyArray<MapDownlinkObserver<K, V, KU, VU>>, keyForm?: Form<K, KU>, valueForm?: Form<V, VU>, state0?: BTree<Value, Value> | null): MapDownlink<K, V, KU, VU>;
    keyForm(): Form<K, KU>;
    keyForm<K2, K2U = never>(keyForm: Form<K2, K2U>): MapDownlink<K2, V, K2U, VU>;
    valueForm(): Form<V, VU>;
    valueForm<V2, V2U = never>(valueForm: Form<V2, V2U>): MapDownlink<K, V2, KU, V2U>;
    get size(): number;
    isEmpty(): boolean;
    has(key: K | KU): boolean;
    get(): MapDownlink<K, V, KU, VU>;
    get(key: K | KU): V;
    getEntry(index: number): [K, V] | undefined;
    firstKey(): K | undefined;
    firstValue(): V | undefined;
    firstEntry(): [K, V] | undefined;
    lastKey(): K | undefined;
    lastValue(): V | undefined;
    lastEntry(): [K, V] | undefined;
    nextKey(keyObject: K): K | undefined;
    nextValue(keyObject: K): V | undefined;
    nextEntry(keyObject: K): [K, V] | undefined;
    previousKey(keyObject: K): K | undefined;
    previousValue(keyObject: K): V | undefined;
    previousEntry(keyObject: K): [K, V] | undefined;
    set(key: K | KU, newValue: V | VU): this;
    delete(key: K | KU): boolean;
    drop(lower: number): this;
    take(upper: number): this;
    clear(): void;
    forEach<T>(callback: (key: K, value: V) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, key: K, value: V) => T | void, thisArg: S): T | undefined;
    keys(): Cursor<K>;
    values(): Cursor<V>;
    entries(): Cursor<[K, V]>;
    snapshot(): BTree<Value, Value>;
    setState(state: BTree<Value, Value>): void;
    observe(observer: MapDownlinkObserver<K, V, KU, VU>): this;
    willUpdate(willUpdate: MapDownlinkWillUpdate<K, V, KU, VU>): this;
    didUpdate(didUpdate: MapDownlinkDidUpdate<K, V, KU, VU>): this;
    willRemove(willRemove: MapDownlinkWillRemove<K, V, KU, VU>): this;
    didRemove(didRemove: MapDownlinkDidRemove<K, V, KU, VU>): this;
    willDrop(willDrop: MapDownlinkWillDrop<K, V, KU, VU>): this;
    didDrop(didDrop: MapDownlinkDidDrop<K, V, KU, VU>): this;
    willTake(willTake: MapDownlinkWillTake<K, V, KU, VU>): this;
    didTake(didTake: MapDownlinkDidTake<K, V, KU, VU>): this;
    willClear(willClear: MapDownlinkWillClear<K, V, KU, VU>): this;
    didClear(didClear: MapDownlinkDidClear<K, V, KU, VU>): this;
    /** @internal */
    mapWillUpdate(key: Value, newValue: Value): Value;
    /** @internal */
    mapDidUpdate(key: Value, newValue: Value, oldValue: Value): void;
    /** @internal */
    mapWillRemove(key: Value): void;
    /** @internal */
    mapDidRemove(key: Value, oldValue: Value): void;
    /** @internal */
    mapWillDrop(lower: number): void;
    /** @internal */
    mapDidDrop(lower: number): void;
    /** @internal */
    mapWillTake(upper: number): void;
    /** @internal */
    mapDidTake(upper: number): void;
    /** @internal */
    mapWillClear(): void;
    /** @internal */
    mapDidClear(): void;
    initialState(): BTree<Value, Value> | null;
    initialState(state0: BTree<Value, Value> | null): MapDownlink<K, V, KU, VU>;
    /** @internal */
    protected didAliasModel(): void;
    open(): this;
    keyIterator(): Cursor<K>;
    readonly input: MapOutlet<K, V, Map_2<K, V>> | null;
    /** @internal */
    readonly effects: BTree<K, KeyEffect>;
    /** @internal */
    readonly outlets: BTree<K, KeyOutlet<K, V>>;
    /** @internal */
    readonly outputs: ReadonlyArray<Inlet<MapDownlink<K, V, KU, VU>>>;
    /** @internal */
    readonly version: number;
    bindInput(newInput: MapOutlet<K, V, Map_2<K, V>>): void;
    unbindInput(): void;
    disconnectInputs(): void;
    outlet(key: K): Outlet<V>;
    outputIterator(): Cursor<Inlet<MapDownlink<K, V, KU, VU>>>;
    bindOutput(output: Inlet<MapDownlink<K, V, KU, VU>>): void;
    unbindOutput(output: Inlet<MapDownlink<K, V, KU, VU>>): void;
    unbindOutputs(): void;
    disconnectOutputs(): void;
    decohereOutputKey(key: K, effect: KeyEffect): void;
    decohereInputKey(key: K, effect: KeyEffect): void;
    decohereKey(key: K, effect: KeyEffect): void;
    decohereOutput(): void;
    decohereInput(): void;
    decohere(): void;
    recohereOutputKey(key: K, version: number): void;
    recohereInputKey(key: K, version: number): void;
    recohereKey(key: K, version: number): void;
    recohereOutput(version: number): void;
    recohereInput(version: number): void;
    recohere(version: number): void;
    protected willDecohereKey(key: K, effect: KeyEffect): void;
    protected onDecohereKey(key: K, effect: KeyEffect): void;
    protected didDecohereKey(key: K, effect: KeyEffect): void;
    protected willDecohere(): void;
    protected onDecohere(): void;
    protected didDecohere(): void;
    protected willRecohereKey(key: K, effect: KeyEffect, version: number): void;
    protected onRecohereKey(key: K, effect: KeyEffect, version: number): void;
    protected didRecohereKey(key: K, effect: KeyEffect, version: number): void;
    protected willRecohere(version: number): void;
    protected onRecohere(version: number): void;
    protected didRecohere(version: number): void;
}

/** @public */
export declare interface MapDownlink<K, V, KU, VU> {
    hostUri(): Uri;
    hostUri(hostUri: AnyUri): MapDownlink<K, V, KU, VU>;
    nodeUri(): Uri;
    nodeUri(nodeUri: AnyUri): MapDownlink<K, V, KU, VU>;
    laneUri(): Uri;
    laneUri(laneUri: AnyUri): MapDownlink<K, V, KU, VU>;
    prio(): number;
    prio(prio: number): MapDownlink<K, V, KU, VU>;
    rate(): number;
    rate(rate: number): MapDownlink<K, V, KU, VU>;
    body(): Value;
    body(body: AnyValue): MapDownlink<K, V, KU, VU>;
    keepLinked(): boolean;
    keepLinked(keepLinked: boolean): MapDownlink<K, V, KU, VU>;
    keepSynced(): boolean;
    keepSynced(keepSynced: boolean): MapDownlink<K, V, KU, VU>;
}

/** @public */
export declare interface MapDownlink<K, V, KU, VU> extends MapOutletCombinators<K, V, MapDownlink<K, V, KU, VU>> {
}

/** @public */
export declare type MapDownlinkDidClear<K, V, KU = never, VU = never> = (downlink: MapDownlink<K, V, KU, VU>) => void;

/** @public */
export declare type MapDownlinkDidDrop<K, V, KU = never, VU = never> = (lower: number, downlink: MapDownlink<K, V, KU, VU>) => void;

/** @public */
export declare type MapDownlinkDidRemove<K, V, KU = never, VU = never> = (key: K, oldValue: V, downlink: MapDownlink<K, V, KU, VU>) => void;

/** @public */
export declare type MapDownlinkDidTake<K, V, KU = never, VU = never> = (upper: number, downlink: MapDownlink<K, V, KU, VU>) => void;

/** @public */
export declare type MapDownlinkDidUpdate<K, V, KU = never, VU = never> = (key: K, newValue: V, oldValue: V, downlink: MapDownlink<K, V, KU, VU>) => void;

/** @beta */
export declare interface MapDownlinkFastener<O = unknown, K = unknown, V = unknown, KU = K, VU = V> extends DownlinkFastener<O> {
    (key: K | KU): V | undefined;
    (key: K | KU, value: V | VU): O;
    /** @internal */
    ownKeyForm: Form<K, KU> | null;
    keyForm(): Form<K, KU> | null;
    keyForm(keyForm: Form<K, KU> | null): this;
    /** @internal */
    readonly ownValueForm: Form<V, VU> | null;
    valueForm(): Form<V, VU> | null;
    valueForm(valueForm: Form<V, VU> | null): this;
    get size(): number;
    isEmpty(): boolean;
    has(key: K | KU): boolean;
    get(key: K | KU): V | undefined;
    getEntry(index: number): [K, V] | undefined;
    firstKey(): K | undefined;
    firstValue(): V | undefined;
    firstEntry(): [K, V] | undefined;
    lastKey(): K | undefined;
    lastValue(): V | undefined;
    lastEntry(): [K, V] | undefined;
    nextKey(keyObject: K): K | undefined;
    nextValue(keyObject: K): V | undefined;
    nextEntry(keyObject: K): [K, V] | undefined;
    previousKey(keyObject: K): K | undefined;
    previousValue(keyObject: K): V | undefined;
    previousEntry(keyObject: K): [K, V] | undefined;
    set(key: K | KU, newValue: V | VU): this;
    delete(key: K | KU): boolean;
    drop(lower: number): this;
    take(upper: number): this;
    clear(): void;
    forEach<T>(callback: (key: K, value: V) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, key: K, value: V) => T | void, thisArg: S): T | undefined;
    keys(): Cursor<K>;
    values(): Cursor<V>;
    entries(): Cursor<[K, V]>;
    /** @override */
    readonly downlink: MapDownlink<K, V, KU, VU> | null;
    /** @internal @override */
    createDownlink(warp: WarpRef): MapDownlink<K, V, KU, VU>;
    /** @internal @override */
    bindDownlink(downlink: MapDownlink<K, V, KU, VU>): MapDownlink<K, V, KU, VU>;
    /** @internal */
    initDownlink?(downlink: MapDownlink<K, V, KU, VU>): MapDownlink<K, V, KU, VU>;
}

/** @beta */
export declare const MapDownlinkFastener: MapDownlinkFastenerFactory<MapDownlinkFastener<any, any, any, any, any>>;

/** @beta */
export declare interface MapDownlinkFastenerClass<F extends MapDownlinkFastener<any, any, any> = MapDownlinkFastener<any, any, any>> extends DownlinkFastenerClass<F> {
}

/** @beta */
export declare type MapDownlinkFastenerDescriptor<O = unknown, K = unknown, V = unknown, KU = K, VU = V, I = {}> = ThisType<MapDownlinkFastener<O, K, V, KU, VU> & I> & MapDownlinkFastenerInit<K, V, KU, VU> & Partial<I>;

/** @beta */
export declare interface MapDownlinkFastenerFactory<F extends MapDownlinkFastener<any, any, any> = MapDownlinkFastener<any, any, any>> extends MapDownlinkFastenerClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): MapDownlinkFastenerFactory<F> & I;
    define<O, K extends Value = Value, V extends Value = Value, KU extends AnyValue = AnyValue, VU extends AnyValue = AnyValue>(className: string, descriptor: MapDownlinkFastenerDescriptor<O, K, V, KU, VU>): MapDownlinkFastenerFactory<MapDownlinkFastener<any, K, V, KU, VU>>;
    define<O, K = unknown, V extends Value = Value, KU = K, VU extends AnyValue = AnyValue>(className: string, descriptor: {
        keyForm: Form<K, KU>;
    } & MapDownlinkFastenerDescriptor<O, K, V, KU, VU>): MapDownlinkFastenerFactory<MapDownlinkFastener<any, K, V, KU, VU>>;
    define<O, K extends Value = Value, V = unknown, KU extends AnyValue = AnyValue, VU = V>(className: string, descriptor: {
        valueForm: Form<V, VU>;
    } & MapDownlinkFastenerDescriptor<O, K, V, KU, VU>): MapDownlinkFastenerFactory<MapDownlinkFastener<any, K, V, KU, VU>>;
    define<O, K, V, KU = K, VU = V>(className: string, escriptor: {
        keyForm: Form<K, KU>;
        valueForm: Form<V, VU>;
    } & MapDownlinkFastenerDescriptor<O, K, V, KU, VU>): MapDownlinkFastenerFactory<MapDownlinkFastener<any, K, V, KU, VU>>;
    define<O, K extends Value = Value, V extends Value = Value, KU extends AnyValue = AnyValue, VU extends AnyValue = AnyValue, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & MapDownlinkFastenerDescriptor<O, V, VU, I>): MapDownlinkFastenerFactory<MapDownlinkFastener<any, K, V, KU, VU> & I>;
    define<O, K = unknown, V extends Value = Value, KU = K, VU extends AnyValue = AnyValue, I = {}>(className: string, descriptor: {
        implements: unknown;
        keyForm: Form<K, KU>;
    } & MapDownlinkFastenerDescriptor<O, K, V, KU, VU, I>): MapDownlinkFastenerFactory<MapDownlinkFastener<any, K, V, KU, VU> & I>;
    define<O, K extends Value = Value, V = unknown, KU extends AnyValue = AnyValue, VU = V, I = {}>(className: string, descriptor: {
        implements: unknown;
        valueForm: Form<V, VU>;
    } & MapDownlinkFastenerDescriptor<O, K, V, KU, VU, I>): MapDownlinkFastenerFactory<MapDownlinkFastener<any, K, V, KU, VU> & I>;
    define<O, K, V, KU = K, VU = V, I = {}>(className: string, descriptor: {
        implements: unknown;
        keyForm: Form<K, KU>;
        valueForm: Form<V, VU>;
    } & MapDownlinkFastenerDescriptor<O, K, V, KU, VU, I>): MapDownlinkFastenerFactory<MapDownlinkFastener<any, K, V, KU, VU> & I>;
    <O, K extends Value = Value, V extends Value = Value, KU extends AnyValue = AnyValue, VU extends AnyValue = AnyValue>(descriptor: MapDownlinkFastenerDescriptor<O, K, V, KU, VU>): PropertyDecorator;
    <O, K = unknown, V extends Value = Value, KU = K, VU extends AnyValue = AnyValue>(descriptor: {
        keyForm: Form<K, KU>;
    } & MapDownlinkFastenerDescriptor<O, K, V, KU, VU>): PropertyDecorator;
    <O, K extends Value = Value, V = unknown, KU extends AnyValue = AnyValue, VU = V>(descriptor: {
        valueForm: Form<V, VU>;
    } & MapDownlinkFastenerDescriptor<O, K, V, KU, VU>): PropertyDecorator;
    <O, K, V, KU = K, VU = V>(descriptor: {
        keyForm: Form<K, KU>;
        valueForm: Form<V, VU>;
    } & MapDownlinkFastenerDescriptor<O, K, V, KU, VU>): PropertyDecorator;
    <O, K extends Value = Value, V extends Value = Value, KU extends AnyValue = AnyValue, VU extends AnyValue = AnyValue, I = {}>(descriptor: {
        implements: unknown;
    } & MapDownlinkFastenerDescriptor<O, K, V, KU, VU, I>): PropertyDecorator;
    <O, K = unknown, V extends Value = Value, KU = K, VU extends AnyValue = AnyValue, I = {}>(descriptor: {
        implements: unknown;
        keyForm: Form<K, KU>;
    } & MapDownlinkFastenerDescriptor<O, K, V, KU, VU, I>): PropertyDecorator;
    <O, K extends Value = Value, V = unknown, KU extends AnyValue = AnyValue, VU = V, I = {}>(descriptor: {
        implements: unknown;
        valueForm: Form<V, VU>;
    } & MapDownlinkFastenerDescriptor<O, K, V, KU, VU, I>): PropertyDecorator;
    <O, K, V, KU = K, VU = V, I = {}>(descriptor: {
        implements: unknown;
        keyForm: Form<K, KU>;
        valueForm: Form<V, VU>;
    } & MapDownlinkFastenerDescriptor<O, K, V, KU, VU, I>): PropertyDecorator;
}

/** @beta */
export declare interface MapDownlinkFastenerInit<K = unknown, V = unknown, KU = K, VU = V> extends DownlinkFastenerInit, MapDownlinkObserver<K, V, KU, VU> {
    extends?: {
        prototype: MapDownlinkFastener<any, any, any>;
    } | string | boolean | null;
    keyForm?: Form<K, KU>;
    valueForm?: Form<V, VU>;
    initDownlink?(downlink: MapDownlink<K, V, KU, VU>): MapDownlink<K, V, KU, VU>;
}

/** @internal */
export declare type MapDownlinkFastenerKeyInitType<F extends MapDownlinkFastener<any, any, any>> = F extends MapDownlinkFastener<any, infer K, infer KU, any, any> ? K | KU : never;

/** @internal */
export declare type MapDownlinkFastenerKeyType<F extends MapDownlinkFastener<any, any, any>> = F extends MapDownlinkFastener<any, infer K, any, any, any> ? K : never;

/** @internal */
export declare type MapDownlinkFastenerValueInitType<F extends MapDownlinkFastener<any, any, any>> = F extends MapDownlinkFastener<any, any, any, infer V, infer VU> ? V | VU : never;

/** @internal */
export declare type MapDownlinkFastenerValueType<F extends MapDownlinkFastener<any, any, any>> = F extends MapDownlinkFastener<any, any, any, infer V, any> ? V : never;

/** @public */
export declare interface MapDownlinkInit<K, V, KU = never, VU = never> extends MapDownlinkObserver<K, V, KU, VU>, DownlinkInit {
    keyForm?: Form<K, KU>;
    valueForm?: Form<V, VU>;
}

/** @internal */
export declare class MapDownlinkModel extends DownlinkModel {
    constructor(context: DownlinkContext, hostUri: Uri, nodeUri: Uri, laneUri: Uri, prio?: number, rate?: number, body?: Value, state?: BTree<Value, Value>);
    readonly views: ReadonlyArray<MapDownlink<unknown, unknown>>;
    /** @internal */
    readonly state: BTree<Value, Value>;
    get type(): DownlinkType;
    get size(): number;
    isEmpty(): boolean;
    has(key: Value): boolean;
    get(key: Value): Value;
    getEntry(index: number): [Value, Value] | undefined;
    set(key: Value, newValue: Value): this;
    delete(key: Value): boolean;
    drop(lower: number): this;
    take(upper: number): this;
    clear(): void;
    forEach<T>(callback: (key: Value, value: Value) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, key: Value, value: Value) => T | void, thisArg: S): T | undefined;
    keys(): Cursor<Value>;
    values(): Cursor<Value>;
    entries(): Cursor<[Value, Value]>;
    snapshot(): BTree<Value, Value>;
    setState(state: BTree<Value, Value>): void;
    onEventMessage(message: EventMessage, host: Host): void;
    protected onUpdateEvent(key: Value, newValue: Value): void;
    protected onRemoveEvent(key: Value): void;
    protected onDropEvent(lower: number): void;
    protected onTakeEvent(upper: number): void;
    protected onClearEvent(): void;
    protected mapWillUpdate(key: Value, newValue: Value): Value;
    protected mapDidUpdate(key: Value, newValue: Value, oldValue: Value): void;
    protected mapWillRemove(key: Value): void;
    protected mapDidRemove(key: Value, oldValue: Value): void;
    protected mapWillDrop(lower: number): void;
    protected mapDidDrop(lower: number): void;
    protected mapWillTake(upper: number): void;
    protected mapDidTake(upper: number): void;
    protected mapWillClear(): void;
    protected mapDidClear(): void;
}

/** @public */
export declare interface MapDownlinkObserver<K, V, KU = never, VU = never> extends DownlinkObserver {
    willUpdate?: MapDownlinkWillUpdate<K, V, KU, VU>;
    didUpdate?: MapDownlinkDidUpdate<K, V, KU, VU>;
    willRemove?: MapDownlinkWillRemove<K, V, KU, VU>;
    didRemove?: MapDownlinkDidRemove<K, V, KU, VU>;
    willDrop?: MapDownlinkWillDrop<K, V, KU, VU>;
    didDrop?: MapDownlinkDidDrop<K, V, KU, VU>;
    willTake?: MapDownlinkWillTake<K, V, KU, VU>;
    didTake?: MapDownlinkDidTake<K, V, KU, VU>;
    willClear?: MapDownlinkWillClear<K, V, KU, VU>;
    didClear?: MapDownlinkDidClear<K, V, KU, VU>;
}

/** @public */
export declare class MapDownlinkRecord extends DownlinkRecord implements MapDownlinkObserver<Value, Value, AnyValue, AnyValue> {
    constructor(downlink: MapDownlink<Value, Value, AnyValue, AnyValue>);
    readonly downlink: MapDownlink<Value, Value, AnyValue, AnyValue>;
    isEmpty(): boolean;
    isArray(): boolean;
    isObject(): boolean;
    get length(): number;
    has(key: AnyValue): boolean;
    get(): Record_2;
    get(key: AnyValue): Value;
    getAttr(key: AnyText): Value;
    getSlot(key: AnyValue): Value;
    getItem(index: AnyNum): Item;
    set(key: AnyValue, newValue: AnyValue): this;
    setAttr(key: AnyText, newValue: AnyValue): this;
    setSlot(key: AnyValue, newValue: AnyValue): this;
    setItem(index: number, newItem: AnyItem): this;
    push(...newItems: AnyItem[]): number;
    splice(start: number, deleteCount?: number, ...newItems: AnyItem[]): Item[];
    delete(key: AnyValue): Item;
    clear(): void;
    forEach<T>(callback: (item: Item, index: number) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, item: Item, index: number) => T | void, thisArg: S): T | undefined;
    keyIterator(): Cursor<Value>;
    didUpdate(key: Value, newValue: Value, oldValue: Value): void;
    didRemove(key: Value, oldValue: Value): void;
    didDrop(lower: number): void;
    didTake(upper: number): void;
    didClear(): void;
}

/** @public */
export declare type MapDownlinkWillClear<K, V, KU = never, VU = never> = (downlink: MapDownlink<K, V, KU, VU>) => void;

/** @public */
export declare type MapDownlinkWillDrop<K, V, KU = never, VU = never> = (lower: number, downlink: MapDownlink<K, V, KU, VU>) => void;

/** @public */
export declare type MapDownlinkWillRemove<K, V, KU = never, VU = never> = (key: K, downlink: MapDownlink<K, V, KU, VU>) => void;

/** @public */
export declare type MapDownlinkWillTake<K, V, KU = never, VU = never> = (upper: number, downlink: MapDownlink<K, V, KU, VU>) => void;

/** @public */
export declare type MapDownlinkWillUpdate<K, V, KU = never, VU = never> = (key: K, newValue: V, downlink: MapDownlink<K, V, KU, VU>) => V | void;

/** @public */
export declare class MapFieldValuesCombinator<K, VI, VO, I> extends MapFieldValuesOperator<K, VI, VO, I> {
    constructor(func: MapFieldValuesFunction<K, VI, VO>);
    /** @internal */
    readonly func: MapFieldValuesFunction<K, VI, VO>;
    evaluate(key: K, value: VI | undefined): VO | undefined;
}

/** @public */
export declare type MapFieldValuesFunction<K, VI, VO> = (key: K, value: VI) => VO;

/** @public */
export declare abstract class MapFieldValuesOperator<K, VI, VO, I> extends AbstractMapInoutlet<K, VI, VO, I, Map_2<K, VO>> {
    has(key: K): boolean;
    get(): Map_2<K, VO>;
    get(key: K): VO | undefined;
    keyIterator(): Iterator_2<K>;
    abstract evaluate(key: K, value: VI | undefined): VO | undefined;
}

/**
 * Input connector into a `Streamlet` for a key-value map state.
 * @public
 */
export declare interface MapInlet<K, V, I> extends Inlet<I> {
    /**
     * Marks this `MapInlet` as needing an `effect` applied to a given `key`.
     * Decohering an individual key decoheres the entire state of the `Inlet`.
     * But only the decoherent keys need to be updated in order to recohere the
     * overall state of the `Inlet`.
     */
    decohereOutputKey(key: K, effect: KeyEffect): void;
    /**
     * Updates the state of an individual `key` in this `MapInlet` to make it
     * consistent with the target `version`. The `MapInlet` only needs to update
     * if the current `version` differs from the target `version`. To update the
     * state of a key, the `MapInlet` first invokes [[MapOutlet.recohereInputKey]]
     * on its [[input]], if its input is a `MapOutlet`, or it invokes
     * [[Outlet.recohereInput]], if its input is not a `MapOutlet`. Then,
     * if all decoherent keys have been recohered, the `MapInlet` invokes
     * [[Streamlet.recohere]] on its attached streamlet.
     */
    recohereOutputKey(key: K, version: number): void;
}

/** @public */
export declare const MapInlet: {
    is<K, V, I>(object: unknown): object is MapInlet<K, V, I>;
};

/** @public */
export declare interface MapInletMapOutlet<KI, KO, VI, VO, I, O> extends MapInlet<KI, VI, I>, MapOutlet<KO, VO, O> {
}

/** @public */
export declare interface MapInletOutlet<K, V, I, O> extends MapInlet<K, V, I>, Outlet<O> {
}

/** @public */
export declare interface MapInoutlet<K, VI, VO, I, O> extends Inoutlet<I, O>, MapInlet<K, VI, I>, MapOutlet<K, VO, O> {
    /**
     * Returns the current state of this `Outlet`.
     */
    get(): O | undefined;
    /**
     * Returns the value assocaited with the given `key` in the current state of
     * this `MapOutlet`, if defined; otherwise returns `null`.
     */
    get(key: K): VO | undefined;
    memoize(): MapOutlet<K, VO, O>;
    map<O2>(func: MapValueFunction<O, O2>): Outlet<O2>;
    map<V2>(func: MapFieldValuesFunction<K, VO, V2>): MapOutlet<K, V2, Map_2<K, V2>>;
    watch(func: WatchValueFunction<O>): this;
    watch(func: WatchFieldsFunction<K, VO>): this;
}

/** @public */
export declare class MapInput<K, V> extends AbstractMapOutlet<K, V, Map_2<K, V>> {
    constructor(state?: BTree<K, V>);
    /** @internal */
    readonly state: BTree<K, V>;
    has(key: K): boolean;
    get(): Map_2<K, V> | undefined;
    get(key: K): V | undefined;
    set(key: K, newValue: V): V | undefined;
    delete(key: K): this;
    keyIterator(): Cursor<K>;
}

/**
 * Output connector from a [[Streamlet]] for a key-value map state.
 * @public
 */
export declare interface MapOutlet<K, V, O> extends Outlet<O>, MapOutletCombinators<K, V, O> {
    /**
     * Returns `true` if the current state of this `MapOutlet` contains the given
     * `key`; otherwise returns `false`.
     */
    has(key: K): boolean;
    /**
     * Returns the current state of this `Outlet`.
     */
    get(): O | undefined;
    /**
     * Returns the value assocaited with the given `key` in the current state of
     * this `MapOutlet`, if defined; otherwise returns `undefined`.
     */
    get(key: K): V | undefined;
    /**
     * Returns an `Iterator` over the keys in the current state of this `MapOutlet`.
     */
    keyIterator(): Iterator_2<K>;
    /**
     * Returns an `Outlet` that updates when the specified `key` updates.
     */
    outlet(key: K): Outlet<V>;
    /**
     * Marks this `MapOutlet` as needing an `effect` applied to a given `key`.
     * Decohering an individual key decoheres the entire state of the `Outlet`.
     * But only the decoherent keys need to be updated in order to recohere the
     * overall state of the `Outlet`.
     */
    decohereInputKey(key: K, effect: KeyEffect): void;
    /**
     * Updates the state of an individual `key` in this `MapOutlet` to make it
     * consistent with the target `version`. The `MapOutlet` only needs to
     * update if its current `version` differs from the target `version`.
     * To update the state of a key, the `MapOutlet` first invokes
     * [[Streamlet.recohere]] on its attached streamlets. Then, for each
     * dependent output, it invokes [[MapInlet.recohereOutputKey]], if the
     * dependent output is a [[MapInlet]], or it invokes [[Inlet.recohere]],
     * if the dependent output is not a `MapInlet`.
     */
    recohereInputKey(key: K, version: number): void;
    memoize(): MapOutlet<K, V, O>;
    filter(func: FilterFieldsFunction<K, V>): MapOutlet<K, V, Map_2<K, V>>;
    map<O2>(func: MapValueFunction<O, O2>): Outlet<O2>;
    map<V2>(func: MapFieldValuesFunction<K, V, V2>): MapOutlet<K, V2, Map_2<K, V2>>;
    reduce<U>(identity: U, accumulator: (result: U, element: V) => U, combiner: (result: U, result2: U) => U): Outlet<U>;
    watch(func: WatchValueFunction<O>): this;
    watch(func: WatchFieldsFunction<K, V>): this;
}

/** @public */
export declare const MapOutlet: {
    is<K, V, I>(object: unknown): object is MapOutlet<K, V, I>;
};

/** @public */
export declare interface MapOutletCombinators<K, V, O> extends OutletCombinators<O> {
    memoize(): MapOutlet<K, V, O>;
    filter(func: FilterFieldsFunction<K, V>): MapOutlet<K, V, Map_2<K, V>>;
    map<O2>(func: MapValueFunction<O, O2>): Outlet<O2>;
    map<V2>(func: MapFieldValuesFunction<K, V, V2>): MapOutlet<K, V2, Map_2<K, V2>>;
    reduce<U>(identity: U, accumulator: (result: U, element: V) => U, combiner: (result: U, result2: U) => U): Outlet<U>;
    watch(func: WatchValueFunction<O>): this;
    watch(func: WatchFieldsFunction<K, V>): this;
}

/** @public */
export declare const MapOutletCombinators: {
    define<K, V, O>(prototype: MapOutletCombinators<K, V, O>): void;
    /** @internal */
    memoize<K_1, V_1, O_1>(this: MapOutlet<K_1, V_1, O_1>): MapOutlet<K_1, V_1, O_1>;
    /** @internal */
    filter<K_2, V_2, O_2>(this: MapOutlet<K_2, V_2, O_2>, func: FilterFieldsFunction<K_2, V_2>): MapOutlet<K_2, V_2, Map_2<K_2, V_2>>;
    /** @internal */
    map<K_3, V_3, O_3, O2>(this: MapOutlet<K_3, V_3, O_3>, func: MapValueFunction<O_3, O2>): Outlet<O2>;
    /** @internal */
    map<K_4, V_4, O_4, V2>(this: MapOutlet<K_4, V_4, O_4>, func: MapFieldValuesFunction<K_4, V_4, V2>): MapOutlet<K_4, V2, Map_2<K_4, V2>>;
    /** @internal */
    reduce<K_5, V_5, O_5, U>(this: MapOutlet<K_5, V_5, O_5>, identity: U, accumulator: (result: U, element: V_5) => U, combiner: (result: U, result2: U) => U): Outlet<U>;
    /** @internal */
    watch<K_6, V_6, O_6>(this: MapOutlet<K_6, V_6, O_6>, func: WatchValueFunction<O_6>): MapOutlet<K_6, V_6, O_6>;
    /** @internal */
    watch<K_7, V_7, O_7>(this: MapOutlet<K_7, V_7, O_7>, func: WatchFieldsFunction<K_7, V_7>): MapOutlet<K_7, V_7, O_7>;
};

/** @public */
export declare class MapOutput<K, V> extends AbstractMapInlet<K, V, Map_2<K, V>> {
    constructor();
    /** @internal */
    readonly state: BTree<K, V>;
    get(): Map_2<K, V>;
    protected onRecohereOutputKey(key: K, effect: KeyEffect, version: number): void;
}

/** @public */
export declare interface Mapping<X, Y> extends Equals, Equivalent {
    (x: X): Y;
    readonly domain: Domain<X>;
    readonly range: Range_2<Y>;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
    toString(): string;
}

/** @public */
export declare const Mapping: {
    <X, Y>(domain: Domain<X>, range: Range_2<Y>): Mapping<X, Y>;
    /** @internal */
    prototype: Mapping<any, any>;
};

/** @public */
export declare class MapValueCombinator<I, O> extends MapValueOperator<I, O> {
    constructor(func: MapValueFunction<I, O>);
    /** @internal */
    readonly func: MapValueFunction<I, O>;
    evaluate(value: I | undefined): O | undefined;
}

/** @public */
export declare type MapValueFunction<I, O> = (value: I) => O;

/** @public */
export declare abstract class MapValueOperator<I, O> extends AbstractInoutlet<I, O> {
    get(): O | undefined;
    abstract evaluate(value: I | undefined): O | undefined;
}

/**
 * Description of a source position, identified by byte offset, line, and
 * column number, with an optional note.
 * @public
 */
export declare class Mark extends Tag {
    /** @internal */
    constructor(offset: number, line: number, column: number, note: string | undefined);
    /**
     * The zero-based byte offset of this position.
     */
    readonly offset: number;
    /**
     * The one-based line number of this position.
     */
    readonly line: number;
    /**
     * The one-based column number of this position.
     */
    readonly column: number;
    /**
     * The note attached to the marked position, or `null` if this position has
     * no attached note.
     */
    readonly note: string | undefined;
    withNote(note: string | undefined): Mark;
    /**
     * Returns this position, if its byte offset is less than or equal to
     * `that` position; otherwise returns `that` position.
     */
    min(that: Mark): Mark;
    /**
     * Returns this position, if its byte offset is greater than or equal to
     * `that` position; otherwise returns `that` position.
     */
    max(that: Mark): Mark;
    get start(): Mark;
    get end(): Mark;
    union(that: Tag): Tag;
    shift(mark: Mark): Mark;
    equals(that: unknown): boolean;
    hashCode(): number;
    display<T>(output: Output<T>): Output<T>;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    /**
     * Returns a `Mark` at byte offset `0`, line `1`, and column `1`, with no
     * attached note.
     */
    static get zero(): Mark;
    /**
     * Returns a new `Mark` at the given zero-based byte `offset`, one-based
     * `line` number, and one-based `column` number, with an optionally attached
     * `note`.
     */
    static at(offset: number, line: number, column: number, note?: string | undefined): Mark;
}

/** @public */
export declare const MathModule: {
    readonly max: Func;
    readonly min: Func;
    readonly abs: Func;
    readonly ceil: Func;
    readonly floor: Func;
    readonly round: Func;
    readonly sqrt: Func;
    readonly pow: Func;
    readonly rate: Func;
    readonly random: Func;
    readonly scope: Record_2;
};

/** @internal */
export declare type MemberAnimatorInit<O, K extends keyof O> = O[K] extends Animator<any, infer T, infer U> ? T | U : never;

/** @internal */
export declare type MemberAnimatorInitMap<O> = {
    -readonly [K in keyof O as O[K] extends Property<any, any> ? K : never]?: MemberAnimatorInit<O, K>;
};

/** @internal */
export declare type MemberAnimatorValue<O, K extends keyof O> = O[K] extends Animator<any, infer T> ? T : never;

/** @internal */
export declare type MemberAnimatorValueInit<O, K extends keyof O> = O[K] extends Animator<any, any, infer U> ? U : never;

/** @internal */
export declare type MemberFastener<O, K extends keyof MemberFasteners<O, F>, F extends Fastener<any> = Fastener<any>> = MemberFasteners<O, F>[K] extends F ? MemberFasteners<O, F>[K] : never;

/** @internal */
export declare type MemberFastenerClass<O, K extends keyof MemberFasteners<O, F>, F extends Fastener<any> = Fastener<any>> = MemberFasteners<O, F>[K] extends F ? FastenerClass<MemberFasteners<O, F>[K]> : never;

/** @internal */
export declare type MemberFasteners<O, F extends Fastener<any> = Fastener<any>> = {
    [K in keyof O as O[K] extends F ? K : never]: O[K];
};

/** @internal */
export declare type MemberPropertyInit<O, K extends keyof O> = O[K] extends Property<any, infer T, infer U> ? T | U : never;

/** @internal */
export declare type MemberPropertyInitMap<O> = {
    -readonly [K in keyof O as O[K] extends Property ? K : never]?: MemberPropertyInit<O, K>;
};

/** @internal */
export declare type MemberPropertyValue<O, K extends keyof O> = O[K] extends Property<any, infer T> ? T : never;

/** @internal */
export declare type MemberPropertyValueInit<O, K extends keyof O> = O[K] extends Property<any, any, infer U> ? U : never;

/** @internal */
export declare type MemberProviderService<O, K extends keyof O> = O[K] extends Provider<any, infer S> ? S : never;

/** @public */
export declare class MemoizeMapCombinator<K, V, IO> extends AbstractMapInoutlet<K, V, V, IO, IO> {
    constructor();
    /** @internal */
    readonly state: IO | undefined;
    /** @internal */
    readonly cache: BTree<K, V>;
    has(key: K): boolean;
    get(): IO | undefined;
    get(key: K): V | undefined;
    keyIterator(): Iterator_2<K>;
    protected onRecohereKey(key: K, effect: KeyEffect, version: number): void;
    protected onRecohere(version: number): void;
    memoize(): MapOutlet<K, V, IO>;
}

/** @public */
export declare class MemoizeValueCombinator<IO> extends AbstractInoutlet<IO, IO> {
    constructor();
    /** @internal */
    readonly state: IO | undefined;
    get(): IO | undefined;
    protected onRecohere(version: number): void;
    memoize(): Outlet<IO>;
}

/** @public */
export declare abstract class Message<M extends Message<M> = Message<any>> implements HashCode, Debug {
    get tag(): string;
    abstract readonly body: Value;
    abstract withBody(body: AnyValue): M;
    abstract toValue(): Value;
    toAny(): AnyValue;
    toRecon(): string;
    abstract equals(that: unknown): boolean;
    abstract hashCode(): number;
    abstract debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static readonly tag?: string;
    static fromValue(value: Value): Message | null;
    static parseRecon(input: string): Message | null;
}

/** @beta */
export declare type MethodParameters<O, K extends keyof Methods<O>> = Methods<O>[K] extends (...args: infer P) => any ? P : never;

/** @beta */
export declare type MethodReturnType<O, K extends keyof Methods<O>> = Methods<O>[K] extends (...args: any) => infer R ? R : never;

/** @beta */
export declare type Methods<O> = {
    [K in keyof O as O[K] extends (...args: any) => any ? K : never]: O[K];
};

/** @internal */
export declare class MillisecondFormat extends DateTimeFormat {
    writeDate<T>(output: Output<T>, date: DateTime): Output<T>;
    parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit>;
}

/** @internal */
export declare class MillisecondInterval extends UnitTimeInterval {
    offset(d: AnyDateTime, k?: number): DateTime;
    next(d: AnyDateTime, k?: number): DateTime;
    floor(d: AnyDateTime): DateTime;
    ceil(d: AnyDateTime): DateTime;
    every(k: number): TimeInterval;
}

/** @internal */
export declare class MillisecondParser extends Parser<DateTimeInit> {
    private readonly date;
    private readonly millisecond;
    private readonly step;
    constructor(date?: DateTimeInit, millisecond?: number, step?: number);
    feed(input: Input): Parser<DateTimeInit>;
    static parse(input: Input, date?: DateTimeInit, millisecond?: number, step?: number): Parser<DateTimeInit>;
    static term(millisecond: number, date: DateTimeInit): Parser<DateTimeInit>;
    static cont(date: DateTimeInit, millisecond: number, step: number): Parser<DateTimeInit>;
}

/** @internal */
export declare class MillisecondsInterval extends TimeInterval {
    private readonly stride;
    constructor(stride: number);
    offset(d: AnyDateTime, k?: number): DateTime;
    next(d: AnyDateTime, k?: number): DateTime;
    floor(d: AnyDateTime): DateTime;
    ceil(d: AnyDateTime): DateTime;
}

/** @public */
export declare class MinusOperator extends BinaryOperator {
    constructor(operand1: Item, operand2: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): MinusOperator;
}

/** @internal */
export declare class MinusOutlet extends BinaryOutlet {
    protected evaluate(argument1: Value, argument2: Value): Item;
}

/** @internal */
export declare class MinuteFormat extends DateTimeFormat {
    writeDate<T>(output: Output<T>, date: DateTime): Output<T>;
    parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit>;
}

/** @internal */
export declare class MinuteInterval extends UnitTimeInterval {
    offset(d: AnyDateTime, k?: number): DateTime;
    next(d: AnyDateTime, k?: number): DateTime;
    floor(d: AnyDateTime): DateTime;
    ceil(d: AnyDateTime): DateTime;
    every(k: number): TimeInterval;
    /** @internal */
    static modulo(k: number, d: DateTime): boolean;
}

/** @internal */
export declare class MinuteParser extends Parser<DateTimeInit> {
    private readonly date;
    private readonly minute;
    private readonly step;
    constructor(date?: DateTimeInit, minute?: number, step?: number);
    feed(input: Input): Parser<DateTimeInit>;
    static parse(input: Input, date?: DateTimeInit, minute?: number, step?: number): Parser<DateTimeInit>;
    static term(minute: number, date: DateTimeInit): Parser<DateTimeInit>;
    static cont(date: DateTimeInit, minute: number, step: number): Parser<DateTimeInit>;
}

/** @public */
export declare class ModuloOperator extends BinaryOperator {
    constructor(operand1: Item, operand2: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): ModuloOperator;
}

/** @internal */
export declare class ModuloOutlet extends BinaryOutlet {
    protected evaluate(argument1: Value, argument2: Value): Item;
}

/** @internal */
export declare class MonthFormat extends DateTimeFormat {
    private readonly locale;
    constructor(locale: DateTimeLocale);
    withLocale(locale: DateTimeLocale): DateTimeFormat;
    writeDate<T>(output: Output<T>, date: DateTime): Output<T>;
    parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit>;
}

/** @internal */
export declare class MonthInterval extends UnitTimeInterval {
    offset(t: AnyDateTime, k?: number): DateTime;
    next(t: AnyDateTime, k?: number): DateTime;
    floor(t: AnyDateTime): DateTime;
    ceil(t: AnyDateTime): DateTime;
    every(k: number): TimeInterval;
    /** @internal */
    static modulo(k: number, d: DateTime): boolean;
}

/** @internal */
export declare class MonthOfYearFormat extends DateTimeFormat {
    writeDate<T>(output: Output<T>, date: DateTime): Output<T>;
    parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit>;
}

/** @internal */
export declare class MonthOfYearParser extends Parser<DateTimeInit> {
    private readonly date;
    private readonly month;
    private readonly step;
    constructor(date?: DateTimeInit, month?: number, step?: number);
    feed(input: Input): Parser<DateTimeInit>;
    static parse(input: Input, date?: DateTimeInit, month?: number, step?: number): Parser<DateTimeInit>;
    static term(month: number, date: DateTimeInit): Parser<DateTimeInit>;
    static cont(date: DateTimeInit, month: number, step: number): Parser<DateTimeInit>;
}

/** @internal */
export declare class MonthParser extends Parser<DateTimeInit> {
    private readonly locale;
    private readonly date;
    private readonly output;
    constructor(locale: DateTimeLocale, date?: DateTimeInit, output?: Output<string>);
    feed(input: Input): Parser<DateTimeInit>;
    static parse(input: Input, locale: DateTimeLocale, date?: DateTimeInit, output?: Output<string>): Parser<DateTimeInit>;
    static term(locale: DateTimeLocale, value: string, date: DateTimeInit, input: Input): Parser<DateTimeInit>;
    static cont(locale: DateTimeLocale, date: DateTimeInit, output: Output<string>): Parser<DateTimeInit>;
}

/**
 * 32-bit [MurmurHash](https://en.wikipedia.org/wiki/MurmurHash) algorithm,
 * version 3.
 * @public
 */
export declare const Murmur3: {
    /**
     * Mixes a new hash `value` into the accumulated hash `code`,
     * and returns the accumulated hash value.
     */
    mix(code: number, value: number): number;
    /**
     * Mixes each consecutive 4-byte word of `array` into `code`,
     * and returns the accumulated hash value.
     */
    mixUint8Array(code: number, array: Uint8Array): number;
    /** @internal */
    mixUint8ArrayBE(code: number, array: Uint8Array): number;
    /** @internal */
    mixUInt8ArrayLE(code: number, array: Uint8Array): number;
    /**
     * Mixes each consecutive 4-byte word of the UTF-8 encoding of `string`
     * into `code`, and returns the accumulated hash value.
     */
    mixString(code: number, string: string): number;
    /** @internal */
    mixStringBE(code: number, string: string): number;
    /** @internal */
    mixStringLE(code: number, string: string): number;
    /**
     * Finalizes a hash `code`.
     */
    mash(code: number): number;
    /** @internal */
    rotl(value: number, distance: number): number;
};

/** @public */
export declare type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};

/** @public */
export declare type MutableDictionary<T> = {
    [key: string]: T | undefined;
};

/** @public */
export declare class NegativeOperator extends UnaryOperator {
    constructor(operand: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): NegativeOperator;
}

/** @internal */
export declare class NegativeOutlet extends UnaryOutlet {
    protected evaluate(argument: Value): Item;
}

/** @public */
export declare class NeOperator extends BinaryOperator {
    constructor(operand1: Item, operand2: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): NeOperator;
}

/** @internal */
export declare class NeOutlet extends BinaryOutlet {
    protected evaluate(argument1: Value, argument2: Value): Item;
}

/** @internal */
export declare abstract class NodeCursor<T, P> extends Cursor<T> {
    constructor(pages: ReadonlyArray<P>, index: number, childIndex: number, childCursor: Cursor<T> | null);
    /** @internal */
    readonly pages: ReadonlyArray<P>;
    /** @internal */
    index: number;
    /** @internal */
    childIndex: number;
    /** @internal */
    childCursor: Cursor<T> | null;
    protected abstract pageSize(page: P): number;
    protected abstract pageCursor(page: P): Cursor<T>;
    protected abstract reversePageCursor(page: P): Cursor<T>;
    isEmpty(): boolean;
    head(): T;
    step(): void;
    skip(count: number): void;
    hasNext(): boolean;
    nextIndex(): number;
    next(): {
        value?: T;
        done: boolean;
    };
    hasPrevious(): boolean;
    previousIndex(): number;
    previous(): {
        value?: T;
        done: boolean;
    };
    set(newValue: T): void;
    delete(): void;
}

/** @public */
export declare class NodeRef extends BaseRef {
    constructor(context: RefContext, hostUri: Uri, nodeUri: Uri);
    readonly hostUri: Uri;
    readonly nodeUri: Uri;
    hostRef(hostUri: AnyUri): HostRef;
    nodeRef(nodeUri: AnyUri): NodeRef;
    laneRef(laneUri: AnyUri): LaneRef;
    downlink(init?: EventDownlinkInit): EventDownlink;
    downlinkList(init?: ListDownlinkInit<Value, AnyValue>): ListDownlink<Value, AnyValue>;
    downlinkList<V extends VU, VU = never>(init?: ListDownlinkInit<V, VU>): ListDownlink<V, VU>;
    downlinkMap(init?: MapDownlinkInit<Value, Value, AnyValue, AnyValue>): MapDownlink<Value, Value, AnyValue, AnyValue>;
    downlinkMap<K extends KU, V extends VU, KU = never, VU = never>(init?: MapDownlinkInit<K, V, KU, VU>): MapDownlink<K, V, KU, VU>;
    downlinkValue(init?: ValueDownlinkInit<Value, AnyValue>): ValueDownlink<Value, AnyValue>;
    downlinkValue<V extends VU, VU = never>(init?: ValueDownlinkInit<V, VU>): ValueDownlink<V, VU>;
    command(laneUri: AnyUri, body: AnyValue): void;
}

/** @public */
export declare const nodeRef: typeof client.nodeRef;

/** @public */
export declare class NotOperator extends UnaryOperator {
    constructor(operand: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: Item): number;
    equivalentTo(that: Item, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): NotOperator;
}

/** @internal */
export declare class NotOutlet extends UnaryOutlet {
    protected evaluate(argument: Value): Item;
}

/** @public */
export declare class Num extends Value {
    private constructor();
    isConstant(): boolean;
    readonly value: number;
    /** @internal */
    readonly flags: number;
    isNaN(): boolean;
    isInfinite(): boolean;
    isUint32(): boolean;
    isUint64(): boolean;
    stringValue(): string;
    stringValue<T>(orElse: T): string;
    numberValue(): number;
    numberValue<T>(orElse: T): number;
    booleanValue(): boolean;
    booleanValue<T>(orElse: T): boolean;
    toAny(): AnyNum;
    valueOf(): number;
    bitwiseOr(that: AnyValue): Value;
    bitwiseOr(that: AnyItem): Item;
    bitwiseXor(that: AnyValue): Value;
    bitwiseXor(that: AnyItem): Item;
    bitwiseAnd(that: AnyValue): Value;
    bitwiseAnd(that: AnyItem): Item;
    plus(that: AnyValue): Value;
    plus(that: AnyItem): Item;
    minus(that: AnyValue): Value;
    minus(that: AnyItem): Item;
    times(that: AnyValue): Value;
    times(that: AnyItem): Item;
    divide(that: AnyValue): Value;
    divide(that: AnyItem): Item;
    modulo(that: AnyValue): Value;
    modulo(that: AnyItem): Item;
    bitwiseNot(): Value;
    negative(): Value;
    positive(): Value;
    inverse(): Value;
    abs(): Num;
    ceil(): Num;
    floor(): Num;
    round(): Num;
    sqrt(): Num;
    pow(that: AnyNum): Num;
    max(that: Num): Num;
    max(that: Item): Item;
    min(that: Num): Num;
    min(that: Item): Item;
    interpolateTo(that: Num): Interpolator<Num>;
    interpolateTo(that: Item): Interpolator<Item>;
    interpolateTo(that: unknown): Interpolator<Item> | null;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    /** @internal */
    static readonly Uint32Flag: number;
    /** @internal */
    static readonly Uint64Flag: number;
    /** @internal */
    static readonly TypeMask = 3;
    static get zero(): Num;
    static get negativeZero(): Num;
    static get one(): Num;
    static get negativeOne(): Num;
    static get nan(): Num;
    static uint32(value: number): Num;
    static uint64(value: number): Num;
    static from(value: number): Num;
    static fromAny(value: AnyNum): Num;
    static parse(value: string): Num;
    /** @internal */
    static get cache(): HashGenCacheSet<Num>;
}

/** @internal */
export declare const NumberAnimator: AnimatorFactory<Animator<any, number | null | undefined, string | number | null | undefined>>;

/** @internal */
export declare class NumberForm extends Form<number> {
    constructor(unit?: number);
    readonly unit: number | undefined;
    withUnit(unit: number | undefined): Form<number>;
    mold(object: number, item?: Item): Item;
    cast(item: Item, object?: number): number | undefined;
}

/** @internal */
export declare const NumberInterpolator: {
    (y0: number, y1: number): Interpolator<number>;
    /** @internal */
    prototype: Interpolator<number>;
};

/** @internal */
export declare const NumberProperty: PropertyFactory<Property<any, number | null | undefined, string | number | null | undefined>>;

/**
 * Utilities for comparing and hashing numbers.
 * @public
 */
export declare const Numbers: {
    /**
     * Returns `true` if `x` and `y` are equal numbers, or if both are `NaN`;
     * otherwise returns `x === y` if either `x` or `y` is not defined.
     */
    equal(x: number | null | undefined, y: number | null | undefined): boolean;
    /**
     * Returns `true` if `x` and `y` are both defined, and the difference between
     * the two is less than `epsilon`, or if both are `NaN`; otherwise returns
     * `x === y` if either `x` or `y` is not defined.
     */
    equivalent(x: number | null | undefined, y: number | null | undefined, epsilon?: number | undefined): boolean;
    /**
     * Returns the relative order of `x` with respect to `y`. Returns `-1` if
     * the number `x` less than the number `y`; returns `1` if the number `x` is
     * greater than the number `y`; and returns `0` if `x` and `y` are equal
     * numbers, or if both are `NaN`. If either `x` or `y` is `NaN`, `null`,
     * or `undefined`, then numbers order before `NaN`, `NaN` orders before
     * `null`, and `null` orders before `undefined`.
     */
    compare(x: number | null | undefined, y: number | null | undefined): number;
    /**
     * Returns a 32-bit hash value for the number `x`, if defined; otherwise
     * returns `0` or `1` if `x` is `undefined` or `null`, respectively.
     */
    hash(x: number | null | undefined): number;
};

/** @internal */
export declare const NumInterpolator: {
    (y0: Num, y1: Num): Interpolator<Num>;
    /** @internal */
    prototype: Interpolator<Num>;
};

/**
 * Utilities for comparing and hashing structural objects.
 * @public
 */
export declare const Objects: {
    /**
     * Returns `true` if `x` and `y` are structurally equal objects; otherwise
     * returns `x === y` if either `x` or `y` is not an object.
     */
    equal(x: object | null | undefined, y: object | null | undefined): boolean;
    /**
     * Returns `true` if `x` and `y` are structurally [[Equivalent.equivalentTo
     * equivalent]] objects; otherwise returns `x === y` if either `x` or `y` is
     * not an object.
     */
    equivalent(x: object | null | undefined, y: object | null | undefined, epsilon?: number | undefined): boolean;
    /**
     * Returns the relative order of `x` with respect to `y`. Returns `-1` if
     * the entries of object `x` order lexicographically before the entries of
     * object `y`; returns `1` if the entries of object `x` order
     * lexicographically after the entries of object `y`; and returns `0` if `x`
     * and `y` are equal objects. If either `x` or `y` is `null` or `undefined`,
     * then objects order before `null`, and `null` orders before `undefined`.
     */
    compare(x: object | null | undefined, y: object | null | undefined): number;
    /**
     * Returns a 32-bit hash value for the entries of object `x`, if defined;
     * otherwise returns `0` or `1` if `x` is `undefined` or `null`, respectively.
     */
    hash(x: object | null | undefined): number;
};

/** @public */
export declare interface Observable {
    readonly observerType?: Class<Observer>;
    observe(observer: ObserverType<this>): void;
    unobserve(observer: ObserverType<this>): void;
}

/** @public */
export declare const Observable: {
    is(object: unknown): object is Observable;
};

/** @public */
export declare interface Observer<O extends Observable = Observable> {
}

/** @public */
export declare type ObserverMethod<O, K extends keyof ObserverMethods<O>> = ObserverMethods<O>[K] extends ((...args: any) => any) | undefined ? ObserverMethods<O>[K] : never;

/** @public */
export declare type ObserverMethods<O> = {
    [K in keyof O as O[K] extends ((...args: any) => any) | undefined ? K : never]: O[K];
};

/** @public */
export declare type ObserverParameters<O, K extends keyof ObserverMethods<O>> = ObserverMethods<O>[K] extends ((...args: infer P) => any) | undefined ? P : never;

/** @public */
export declare type ObserverReturnType<O, K extends keyof ObserverMethods<O>> = ObserverMethods<O>[K] extends ((...args: any) => infer R) | undefined ? R : never;

/** @public */
export declare type ObserverType<O> = O extends {
    readonly observerType?: Class<infer T>;
} ? T : never;

/** @public */
export declare class OpenedSignal extends WorkerAddressed<OpenedSignal> {
    static readonly tag: string;
}

/** @public */
export declare class OpenSignal extends WorkerAddressed<OpenSignal> {
    static readonly tag: string;
}

/** @public */
export declare abstract class Operator extends Expression {
    /** @internal */
    constructor();
    static binary(operand1: Item, operator: string, operand2: Item): BinaryOperator;
    static unary(operator: string, operand: Item): UnaryOperator;
}

/** @public */
export declare interface OrderedMap<K = unknown, V = unknown> extends Map_2<K, V> {
    getEntry(index: number): [K, V] | undefined;
    firstKey(): K | undefined;
    firstValue(): V | undefined;
    firstEntry(): [K, V] | undefined;
    lastKey(): K | undefined;
    lastValue(): V | undefined;
    lastEntry(): [K, V] | undefined;
    nextKey(key: K): K | undefined;
    nextValue(key: K): V | undefined;
    nextEntry(key: K): [K, V] | undefined;
    previousKey(key: K): K | undefined;
    previousValue(key: K): V | undefined;
    previousEntry(key: K): [K, V] | undefined;
}

/** @public */
export declare class OrOperator extends BinaryOperator {
    constructor(operand1: Item, operand2: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): OrOperator;
}

/** @internal */
export declare class OrOutlet extends AbstractOutlet<Value> {
    constructor();
    readonly operand1Inlet: Inlet<Value>;
    readonly operand2Inlet: Inlet<Value>;
    get(): Value;
}

/** @public */
export declare function Out(name: string): PropertyDecorator;

/** @public */
export declare function Out(options: OutletOptions): PropertyDecorator;

/** @public */
export declare function Out(target: unknown, key: string): void;

/**
 * Output connector from a [[Streamlet]]. An `Outlet` represents a sink to
 * which a `Streamlet` provides state.
 *
 * An `Outlet` has a one-to-many relationship with a set of output sinks.
 * An output sink of an `Outlet` is an `Inlet` of some other `Streamlet`.
 * The [[bindOutput]] method "plugs" an `Inlet` into the `Outlet`.
 * The [[unbindOutput]] method "unplugs" an `Inlet` from the `Outlet`.
 *
 * @public
 */
export declare interface Outlet<O = unknown> extends OutletCombinators<O> {
    /**
     * Returns the current state of this `Outlet`.
     */
    get(): O | undefined;
    /**
     * Returns an `Iterator` over the set of `Inlet`s that depend on the state of
     * this `Outlet`.
     */
    outputIterator(): Iterator_2<Inlet<O>>;
    /**
     * Adds an `output` to the set of `Inlet`s that depend on the state of this
     * `Outlet`. The `output` will be decohered when the state of this
     * `Outlet` is decohered, and recohered when this `Outlet` is recohered.
     */
    bindOutput(output: Inlet<O>): void;
    /**
     * Removes an `output` from the set of `Inlet`s that depend on the state of
     * this `Outlet`.
     */
    unbindOutput(output: Inlet<O>): void;
    /**
     * Disconnects all outputs from this `Outlet` by invoking
     * [[Inlet.unbindInput]] on each `Inelt` that depends on the state of this
     * `Outlet`.
     */
    unbindOutputs(): void;
    /**
     * Disconnects all `Outlet`s dominated by this `Outlet` in the dataflow
     * graph. Used to recursively clean up chains of combinators originating
     * from this `Inlet`.
     */
    disconnectOutputs(): void;
    /**
     * Disconnects all `Inlet`s dominated by this `Outlet` in the dataflow
     * dependency graph. Used to recursively clean up chains of combinators
     * passing through this `Outlet`.
     */
    disconnectInputs(): void;
    /**
     * Marks this `Outlet`—and all [[outputIterator outputs]] that depend on the
     * state of this `Outlet`—as having decoherent state.
     */
    decohereInput(): void;
    /**
     * Updates the state of this `Outlet` to make it consistent with the target
     * `version`. The `Outlet` only needs to update if its current `version`
     * differs from the target `version`. To update its state, the `Outlet`
     * first invokes [[Streamlet.recohere]] on the `Streamlet` to which
     * it's attached. It then invokes [[Inlet.recohereOutput]] on each of its
     * dependent [[outputIterator outputs]].
     */
    recohereInput(version: number): void;
    memoize(): Outlet<O>;
    map<O2>(func: MapValueFunction<O, O2>): Outlet<O2>;
    watch(func: WatchValueFunction<O>): this;
}

/** @public */
export declare const Outlet: {
    is<O>(object: unknown): object is Outlet<O>;
};

/** @public */
export declare interface OutletCombinators<O> {
    memoize(): Outlet<O>;
    map<O2>(func: MapValueFunction<O, O2>): Outlet<O2>;
    watch(func: WatchValueFunction<O>): this;
}

/** @public */
export declare const OutletCombinators: {
    define<O>(prototype: OutletCombinators<O>): void;
    /** @internal */
    memoize<O_1>(this: Outlet<O_1>): Outlet<O_1>;
    /** @internal */
    map<O_2, O2>(this: Outlet<O_2>, func: MapValueFunction<O_2, O2>): Outlet<O2>;
    /** @internal */
    watch<O_3>(this: Outlet<O_3>, func: WatchValueFunction<O_3>): Outlet<O_3>;
};

/** @internal */
export declare class OutletDescriptor {
    readonly key: string;
    readonly name: string;
    readonly type: OutletType;
    constructor(key: string, name: string, type: OutletType);
}

/**
 * An `Inlet` that decoheres a parameterized `Outlet` whenever the `Inlet`
 * decoheres, and that recoheres the parameterized `Outlet` whenever the
 * `Inlet` recoheres.
 * @public
 */
export declare class OutletInlet<I> extends AbstractInlet<I> {
    constructor(outlet: Outlet<unknown>);
    readonly outlet: Outlet<unknown>;
    protected onDecohereOutput(): void;
    protected onRecohereOutput(version: number): void;
}

/**
 * A `MapInlet` that decoheres a parameterized `Outlet` whenever the
 * `MapInlet` decoheres, and that recoheres the parameterized `Outlet`
 * whenever the `MapInlet` recoheres.
 * @public
 */
export declare class OutletMapInlet<K, V, O> extends AbstractMapInlet<K, V, O> {
    constructor(outlet: Outlet<unknown>);
    readonly outlet: Outlet<unknown>;
    protected onDecohereOutputKey(key: K, effect: KeyEffect): void;
    protected onDecohereOutput(): void;
    protected onRecohereOutputKey(key: K, effect: KeyEffect, version: number): void;
    protected onRecohereOutput(version: number): void;
}

/** @public */
export declare interface OutletOptions {
    name?: string;
    type?: OutletType;
}

/** @public */
export declare type OutletType = "value" | "map";

/**
 * Non-blocking token stream writer. `Output` enables incremental,
 * interruptible writing of network protocols and data formats.
 *
 * ### Output tokens
 * Output tokens are modeled as primitive numbers, commonly representing
 * Unicode code points, or raw octets; each `Output` implementation specifies
 * the semantic type of its tokens.
 *
 * ### Output states
 * An `Output` writer is always in one of three states: _cont_​inue, _full_,
 * or _done_. The _cont_ state indicates that the stream is ready to write a
 * single token; the _full_ state indicates that the stream is unable to write
 * additional tokens at this time, but that the stream may logically resume at
 * some point in the future; and the _done_ state indicates that the stream has
 * terminated, and that [[bind]] will return the output result. [[isCont]]
 * returns `true` when in the _cont_ state; [[isFull]] returns `true` when in
 * the _full_ state; and [[isDone]] returns `true` when in the _done_ state.
 *
 * ### Output results
 * An `Output` writer yields a value of type `T`, obtained via the [[bind]]
 * method, representing some implementation defined result of writing the
 * output. For example, an `Output<string>` implementation may–but is not
 * required to–yield a `string` containing all code points written to the
 * output.
 *
 * ### Non-blocking behavior
 * `Output` writers never block. An `Output` writer that would otherwise block
 * writing additional output instead enters the _full_ state, signaling the
 * output generator to back off producing the output, but to remain prepared to
 * produce additional output in the future. An `Output` writer enters the
 * _done_ state when it encounters the final end of its output, signaling to
 * the output generator to stop producing.
 *
 * ### Output settings
 * An output generator may alter the tokens it produces based on its `Output`
 * writer's [[settings]]. Uses include pretty printing and styling generated
 * output. [[OutputSettings]] subclasses can provide additional parameters
 * understood by specialized output producers.
 *
 * ### Cloning
 * An `Output` writer may be [[clone cloned]] to branch the token stream in an
 * implementation specified manner. Not all `Output` implementations support
 * cloning.
 *
 * @see [[OutputSettings]]
 * @see [[Writer]]
 * @public
 */
export declare abstract class Output<T = unknown> implements Builder<number, T> {
    /**
     * Returns `true` when the next [[write write(number)]] will succeed.
     * i.e. this `Output` is in the _cont_ state.
     */
    abstract isCont(): boolean;
    /**
     * Returns `true` when an immediate `write` will fail, but writes may succeed
     * at some point in the future, i.e. this `Output` is in the _full_ state.
     */
    abstract isFull(): boolean;
    /**
     * Returns `true` when no `write` will ever again suucced.
     * i.e. this `Output` is in the _done_ state.
     */
    abstract isDone(): boolean;
    /**
     * Returns `true` when an immediate `write` will fail due to an
     * error with the token stream. i.e. this `Output` is in the `error` state.
     * When `true`, `trap()` will return the output error.
     */
    abstract isError(): boolean;
    /**
     * Returns `true` if this is a partial `Output` that will enter
     * the `full` state when it is unable to write additional tokens.
     */
    abstract isPart(): boolean;
    /**
     * Returns a partial `Output` equivalent to this `Output`, if `part` is `true`;
     * returns a final `Output` equivalent to this `Output` if `part` is `false`.
     * The caller's reference to this `Output` should be replaced by the returned
     * `Output`.
     */
    abstract asPart(part: boolean): Output<T>;
    /**
     * Writes a single `token` to the stream, if this `Output` is in the
     * _cont_ state.
     *
     * @returns `this`
     * @throws [[OutputException]] if this `Output` is not in the _cont_ state.
     */
    abstract write(token: number): Output<T>;
    /**
     * Writes the code points of the given `string`. Assumes this is a Unicode
     * `Output` writer with sufficient capacity.
     *
     * @returns `this`
     * @throws [[OutputException]] if this `Output` exits the _cont_ state before
     *         the full `string` has been written.
     */
    abstract write(string: string): Output<T>;
    /**
     * Writes the code points of the given `string`, followed by the code points
     * of the `settings`' [[OutputSettings.lineSeparator line separator].
     * Assumes this is a Unicode `Output` writer with sufficient capacity.
     *
     * @returns `this`
     * @throws [[OutputException]] if this `Output` exits the _cont_ state before
     *         the full `string` and line separator has been written.
     */
    writeln(string?: string): Output<T>;
    /**
     * Writes the code points of the human-readable [[Display]] string of the
     * given `object`. Assumes this is a Unicode `Output` writer with sufficient
     * capacity.
     *
     * @returns the continuation of the `output`.
     * @throws [[OutputException]] if this `Output` exits the _cont_ state before
     *         the full display string has been written.
     */
    display(object: unknown): Output<T>;
    /**
     * Writes the code points of the developer-readable [[Debug]] string of the
     * given `object`. Assumes this is a Unicode `Output` writer with sufficient
     * capacity.
     *
     * @returns the continuation of the `output`.
     * @throws [[OutputException]] if this `Output` exits the _cont_ state before
     *         the full debug string has been written.
     */
    debug(object: unknown): Output<T>;
    /**
     * Writes any internally buffered state to the underlying output stream.
     */
    flush(): Output<T>;
    push(...tokens: number[]): void;
    /**
     * The `OutputSettings` used to configure the behavior of output producers
     * that write to this `Output`.
     */
    abstract readonly settings: OutputSettings;
    /**
     * Updates the `settings` associated with this `Output`.
     *
     * @returns `this`
     */
    abstract withSettings(settings: AnyOutputSettings): Output<T>;
    /**
     * Returns the implementation-defined result of writing the output.
     */
    abstract bind(): T;
    /**
     * Returns the output error. Only guaranteed to return an error when in the
     * _error_ state.
     *
     * @throws OutputException if this `Output` is not in the _error_ state.
     */
    trap(): Error;
    /**
     * Returns an implementation-defined branch of the token stream.
     *
     * @throws `Error` if this `Output` writer cannot be cloned.
     */
    clone(): Output<T>;
    /**
     * Return an `Output` in the _full_ state.
     */
    static full(): Output<never>;
    /**
     * Returns an `Output` in the _done_ state.
     */
    static done(): Output<never>;
    /**
     * Return an `Output` in the _error_ state that traps the given `error`.
     */
    static error(error: Error): Output<never>;
}

/**
 * Non-blocking token stream buffer.
 * @public
 */
export declare abstract class OutputBuffer<T = unknown> extends Output<T> {
    abstract asPart(part: boolean): OutputBuffer<T>;
    abstract readonly index: number;
    abstract withIndex(index: number): OutputBuffer<T>;
    abstract readonly limit: number;
    abstract withLimit(limit: number): OutputBuffer<T>;
    abstract readonly capacity: number;
    abstract readonly remaining: number;
    abstract has(index: number): boolean;
    abstract get(index: number): number;
    abstract set(index: number, token: number): void;
    abstract write(token: number): OutputBuffer<T>;
    abstract write(string: string): OutputBuffer<T>;
    writeln(string?: string): OutputBuffer<T>;
    abstract step(offset?: number): OutputBuffer<T>;
    flush(): OutputBuffer<T>;
    abstract withSettings(settings: AnyOutputSettings): Output<T>;
    clone(): OutputBuffer<T>;
    /**
     * Returns an `OutputBuffer` in the _full_ state.
     */
    static full(): OutputBuffer<never>;
    /**
     * Returns an `OutputBuffer` in the _done_ state.
     */
    static done(): OutputBuffer<never>;
    /**
     * Returns an `OutputBuffer` in the _error_ state that traps the given `error`.
     */
    static error(error: Error): OutputBuffer<never>;
}

/** @internal */
export declare class OutputBufferDone extends OutputBuffer<never> {
    constructor(settings: OutputSettings);
    isCont(): boolean;
    isFull(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): OutputBuffer<never>;
    get index(): number;
    withIndex(index: number): OutputBuffer<never>;
    get limit(): number;
    withLimit(limit: number): OutputBuffer<never>;
    get capacity(): number;
    get remaining(): number;
    has(index: number): boolean;
    get(index: number): number;
    set(index: number, token: number): void;
    write(token: number): OutputBuffer<never>;
    write(string: string): OutputBuffer<never>;
    writeln(string?: string): OutputBuffer<never>;
    step(offset?: number): OutputBuffer<never>;
    bind(): never;
    readonly settings: OutputSettings;
    withSettings(settings: AnyOutputSettings): OutputBuffer<never>;
    clone(): OutputBuffer<never>;
}

/** @internal */
export declare class OutputBufferError extends OutputBuffer<never> {
    /** @internal */
    readonly error: Error;
    constructor(error: Error, settings: OutputSettings);
    isCont(): boolean;
    isFull(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): OutputBuffer<never>;
    get index(): number;
    withIndex(index: number): OutputBuffer<never>;
    get limit(): number;
    withLimit(limit: number): OutputBuffer<never>;
    get capacity(): number;
    get remaining(): number;
    has(index: number): boolean;
    get(index: number): number;
    set(index: number, token: number): void;
    write(token: number): OutputBuffer<never>;
    write(string: string): OutputBuffer<never>;
    writeln(string?: string): OutputBuffer<never>;
    step(offset?: number): OutputBuffer<never>;
    bind(): never;
    trap(): Error;
    readonly settings: OutputSettings;
    withSettings(settings: AnyOutputSettings): OutputBuffer<never>;
    clone(): OutputBuffer<never>;
}

/** @internal */
export declare class OutputBufferFull extends OutputBuffer<never> {
    constructor(settings: OutputSettings);
    isCont(): boolean;
    isFull(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): OutputBuffer<never>;
    get index(): number;
    withIndex(index: number): OutputBuffer<never>;
    get limit(): number;
    withLimit(limit: number): OutputBuffer<never>;
    get capacity(): number;
    get remaining(): number;
    has(index: number): boolean;
    get(index: number): number;
    set(index: number, token: number): void;
    write(token: number): OutputBuffer<never>;
    write(string: string): OutputBuffer<never>;
    writeln(string?: string): OutputBuffer<never>;
    step(offset?: number): OutputBuffer<never>;
    bind(): never;
    readonly settings: OutputSettings;
    withSettings(settings: AnyOutputSettings): OutputBuffer<never>;
    clone(): OutputBuffer<never>;
}

/** @internal */
export declare class OutputDone extends Output<never> {
    constructor(settings: OutputSettings);
    isCont(): boolean;
    isFull(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): Output<never>;
    write(token: number): Output<never>;
    write(string: string): Output<never>;
    writeln(string?: string): Output<never>;
    bind(): never;
    readonly settings: OutputSettings;
    withSettings(settings: AnyOutputSettings): Output<never>;
    clone(): Output<never>;
}

/** @internal */
export declare class OutputError extends Output<never> {
    /** @internal */
    readonly error: Error;
    constructor(error: Error, settings: OutputSettings);
    isCont(): boolean;
    isFull(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): Output<never>;
    write(token: number): Output<never>;
    write(string: string): Output<never>;
    writeln(string?: string): Output<never>;
    bind(): never;
    trap(): Error;
    readonly settings: OutputSettings;
    withSettings(settings: AnyOutputSettings): Output<never>;
    clone(): Output<never>;
}

/**
 * Thrown when writing invalid [[Output]].
 * @public
 */
export declare class OutputException extends Error {
    constructor(message?: string);
}

/** @internal */
export declare class OutputFull extends Output<never> {
    constructor(settings: OutputSettings);
    isCont(): boolean;
    isFull(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): Output<never>;
    write(token: number): Output<never>;
    write(string: string): Output<never>;
    writeln(string?: string): Output<never>;
    bind(): never;
    readonly settings: OutputSettings;
    withSettings(settings: AnyOutputSettings): Output<never>;
    clone(): Output<never>;
}

/**
 * [[Output]] production parameters. `OutputSettings` provide contextual
 * configuration parameters to output producers, such as [[Writer Writers]].
 * Uses include enabling pretty printing and styling generated output.
 * Subclasses can provide additional parameters understood by specialized
 * output producers.
 * @public
 */
export declare class OutputSettings implements Debug, HashCode {
    protected constructor(lineSeparator: string, pretty: boolean, styled: boolean, precision: number);
    /**
     * The Unicode code point sequence used to separate lines of text.
     * Defaults to the runtime operating system's line separator.
     */
    readonly lineSeparator: string;
    /**
     * Returns a copy of these settings with the given `lineSeparator`.
     */
    withLineSeparator(lineSeparator: string | undefined): string | OutputSettings;
    /** @internal */
    readonly pretty: boolean;
    /**
     * Returns `true` if output producers should pretty print their output,
     * when possible.
     */
    isPretty(): boolean;
    /**
     * Returns a copy of these settings with the given `pretty` flag.
     */
    asPretty(pretty: boolean): OutputSettings;
    /** @internal */
    readonly styled: boolean;
    /**
     * Returns `true` if output producers should style their output,
     * when possible.
     */
    isStyled(): boolean;
    /**
     * Returns a copy of these settings with the given `styled` flag.
     */
    asStyled(styled: boolean): OutputSettings;
    /**
     * Returns the numeric precision output producers should use
     * when formatting numbers.
     */
    readonly precision: number;
    /**
     * Returns a copy of these settings with the given numeric `precision`.
     */
    withPrecision(precision: number): OutputSettings;
    protected copy(lineSeparator: string | undefined, pretty: boolean, styled: boolean, precision: number): OutputSettings;
    protected canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    /**
     * Returns `OutputSettings` configured with the system line separator,
     * pretty printing disabled, and styling disabled.
     */
    static standard(): OutputSettings;
    /**
     * Returns `OutputSettings` configured with the system line separator,
     * pretty printing enabled, and styling disabled.
     */
    static pretty(): OutputSettings;
    /**
     * Returns `OutputSettings` configured with the system line separator,
     * pretty printing disabled, and styling enabled.
     */
    static styled(): OutputSettings;
    /**
     * Returns `OutputSettings` configured with the system line separator,
     * pretty printing enabled, and styling enabled.
     */
    static prettyStyled(): OutputSettings;
    /**
     * Returns `OutputSettings` configured with the given `lineSeparator`, pretty
     * rinting enabled if `isPretty` is `true`, styling enabled if `isStyled` is
     * `true`, and with the given numeric `precision`.
     */
    static create(lineSeparator?: string, pretty?: boolean, styled?: boolean, precision?: number): OutputSettings;
    /**
     * Converts a settings `init` object to an instance of `OutputSettings`.
     */
    static fromInit(init: OutputSettingsInit): OutputSettings;
    /**
     * Converts a loosely typed settings `value` to an instance of `OutputSettings`.
     */
    static fromAny(value: AnyOutputSettings | undefined): OutputSettings;
}

/**
 * [[OutputSettings]] object initializer.
 * @public
 */
export declare interface OutputSettingsInit {
    lineSeparator?: string;
    isPretty?: boolean;
    isStyled?: boolean;
    precision?: number;
}

/**
 * Stylized text output utility functions.
 * @public
 */
export declare const OutputStyle: {
    /**
     * Writes the ASCII reset escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    reset<T>(output: Output<T>): Output<T>;
    /**
     * Writes the ASCII bold (increased intensity) escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    bold<T_1>(output: Output<T_1>): Output<T_1>;
    /**
     * Writes the ASCII faint (decreased intensity) escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    faint<T_2>(output: Output<T_2>): Output<T_2>;
    /**
     * Writes the ASCII black foreground color escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    black<T_3>(output: Output<T_3>): Output<T_3>;
    /**
     * Writes the ASCII red foreground color escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    red<T_4>(output: Output<T_4>): Output<T_4>;
    /**
     * Writes the ASCII green foreground color escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    green<T_5>(output: Output<T_5>): Output<T_5>;
    /**
     * Writes the ASCII yellow foreground color escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    yellow<T_6>(output: Output<T_6>): Output<T_6>;
    /**
     * Writes the ASCII blue foreground color escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    blue<T_7>(output: Output<T_7>): Output<T_7>;
    /**
     * Writes the ASCII magenta foreground color escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    magenta<T_8>(output: Output<T_8>): Output<T_8>;
    /**
     * Writes the ASCII cyan foreground color escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    cyan<T_9>(output: Output<T_9>): Output<T_9>;
    /**
     * Writes the ASCII gray foreground color escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    gray<T_10>(output: Output<T_10>): Output<T_10>;
    /**
     * Writes the ASCII bold black foreground color escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    blackBold<T_11>(output: Output<T_11>): Output<T_11>;
    /**
     * Writes the ASCII bold red foreground color escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    redBold<T_12>(output: Output<T_12>): Output<T_12>;
    /**
     * Writes the ASCII bold green foreground color escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    greenBold<T_13>(output: Output<T_13>): Output<T_13>;
    /**
     * Writes the ASCII bold yellow foreground color escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    yellowBold<T_14>(output: Output<T_14>): Output<T_14>;
    /**
     * Writes the ASCII bold blue foreground color escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    blueBold<T_15>(output: Output<T_15>): Output<T_15>;
    /**
     * Writes the ASCII bold magenta foreground color escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    magentaBold<T_16>(output: Output<T_16>): Output<T_16>;
    /**
     * Writes the ASCII bold cyan foreground color escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    cyanBold<T_17>(output: Output<T_17>): Output<T_17>;
    /**
     * Writes the ASCII bold gray foreground color escape code to `output`,
     * if [[OutputSettings.isStyled `output.settings.isStyled()`]] is `true`.
     *
     * @returns the continuation of the `output`.
     */
    grayBold<T_18>(output: Output<T_18>): Output<T_18>;
};

/**
 * Type that accumulates pairs of input values, and binds an output result of
 * type `O`.
 * @public
 */
export declare interface PairBuilder<K, V, O> {
    /**
     * Adds an input pair to this builder, returning `true` if the state of the
     * builder changed.
     */
    add(key: K, value: V): void;
    /**
     * Returns the output result of this builder.
     */
    bind(): O;
}

/**
 * Continuation of how to parse subsequent [[Input]] tokens from a stream.
 * `Parser` enables efficient, interruptible parsing of network protocols and
 * data formats, without intermediate buffering.
 *
 * ### Input tokens
 * A `Parser` reads tokens from an `Input` reader. Input tokens are modeled as
 * primitive numbers, commonly representing Unicode code points, or raw octets.
 * Each `Parser` implementation specifies the semantic type of input tokens it
 * consumes.
 *
 * ### Parser states
 * A `Parser` is always in one of three states: _cont_​inue, _done_, or _error_.
 * The _cont_ state indicates that [[feed]] is ready to consume `Input`; the
 * _done_ state indicates that parsing terminated successfully, and that
 * [[bind]] will return the parsed result; the _error_ state indicates that
 * parsing terminated in failure, and that [[trap]] will return the parse error.
 * `Parser` subclasses default to the _cont_ state.
 *
 * ### Feeding input
 * The [[feed]] method incrementally parses as much `Input` as it can, before
 * returning another `Parser` that represents the continuation of how to parse
 * additional `Input`. The `Input` passed to `feed` is only guaranteed to be
 * valid for the duration of the method call; references to the provided `Input`
 * instance must not be stored.
 *
 * ### Parser results
 * A `Parser` produces a parsed result of type `O`, obtained via the [[bind]]
 * method. `bind` is only guaranteed to return a result when in the _done_
 * state; though `bind` may optionally make available partial results in other
 * states. A failed `Parser` provides a parse error via the [[trap]] method.
 * `trap` is only guaranteed to return an error when in the _error_ state.
 *
 * ### Continuations
 * A `Parser` instance represents a continuation of how to parse remaining
 * `Input`. Rather than parsing a complete input in one go, a `Parser` takes
 * an `Input` chunk and returns another `Parser` instance that knows how to
 * parse subsequent `Input` chunks. This enables non-blocking, incremental
 * parsing that can be interrupted whenever an `Input` reader runs out of
 * immediately available data. A `Parser` terminates by returning a
 * continuation in either the _done_ state, or the _error_ state.
 * [[Parser.done]] returns a `Parser` in the _done_ state. [[Parser.error]]
 * returns a `Parser` in the _error_ state.
 *
 * ### Iteratees
 * `Parser` is an [Iteratee](https://en.wikipedia.org/wiki/Iteratee). Though
 * unlike strictly functional iteratees, a `Parser` statefully iterates over
 * its `Input`, rather than allocating an object for each incremental input
 * continutaion. This internal mutability minimizes garbage collector memory
 * pressure, without violating the functional Iteratee abstraction, provided
 * that `feed` logically takes exclusive ownership of its `Input` when invoked,
 * and logically returns ownership of the `Input` in a state that's consistent
 * with the returned `Parser` continuation.
 *
 * ### Immutability
 * A `Parser` should be immutable. Specifically, an invocation of `feed`
 * should not alter the behavior of future calls to `feed` on the same `Parser`
 * instance. A `Parser` should only mutate its internal state if it's essential
 * to do so, such as for critical path performance reasons.
 *
 * ### Backtracking
 * `feed` can internally [[Input.clone clone]] its `Input`, if it might need to
 * backtrack. Keep in mind that, because `Input` is only valid for the duration
 * of a call to `feed`, input must be internally buffered if it needs to be
 * preserved between `feed` invocations.
 *
 * ### Forking
 * The [[fork]] method passes an out-of-band condition to a `Parser`, yielding
 * a `Parser` continuation whose behavior may be altered by the given condition.
 * For example, an HTML `Parser` might `fork` an inner text parser to directly
 * parse an embedded micro format out of an HTML element, based on some
 * out-of-band schema information. The types of conditions accepted by `fork`,
 * and their intended semantics, are implementation defined.
 *
 * @public
 */
export declare abstract class Parser<O> {
    /**
     * Returns `true` when [[feed]] is able to consume `Input`, i.e. this
     * `Parser` is in the _cont_ state.
     */
    isCont(): boolean;
    /**
     * Returns `true` when parsing has terminated successfully, and [[bind]] will
     * return the parsed result, i.e. this `Parser` is in the _done_ state.
     */
    isDone(): boolean;
    /**
     * Returns `true` when parsing has terminated in failure, and [[trap]] will
     * return the parse error, i.e. this `Parser` is in the _error_ state.
     */
    isError(): boolean;
    /**
     * Incrementally parses as much `input` as possible, and returns another
     * `Parser` that represents the continuation of how to parse additional
     * `Input`. If `input` enters the _done_ state, `feed` _must_ return a
     * terminated `Parser`, i.e. a `Parser` in the _done_ state, or in the
     * _error_ state. The given `input` is only guaranteed to be valid for the
     * duration of the method call; references to `input` must not be stored.
     */
    abstract feed(input: Input): Parser<O>;
    /**
     * Returns a `Parser` continuation whose behavior may be altered by the
     * given out-of-band `condition`.
     */
    fork(condition: unknown): Parser<O>;
    /**
     * Returns the parsed result. Only guaranteed to return a result when in the
     * _done_ state.
     *
     * @throws `Error` if this `Parser` is not in the _done_ state.
     */
    bind(): O;
    /**
     * Returns the parse error. Only guaranteed to return an error when in the
     * _error_ state.
     *
     * @throws `Error` if this `Parser` is not in the _error_ state.
     */
    trap(): Error;
    /**
     * Casts an errored `Parser` to a different output type. A `Parser` in the
     * _error_ state can have any output type.
     *
     * @throws `ParserException` if this `Parser` is not in the _error_ state.
     */
    asError<O2>(): Parser<O2>;
    /**
     * Returns a `Parser` in the _done_ state that binds the given parsed `value`.
     */
    static done<O>(value: O): Parser<O>;
    /**
     * Returns a `Parser` in the _error_ state that `trap`s the given parse `error`.
     */
    static error<O>(error: Error | Diagnostic): Parser<O>;
}

/** @internal */
export declare class ParserDone<O> extends Parser<O> {
    /** @internal */
    readonly value: O;
    constructor(value: O);
    isCont(): boolean;
    isDone(): boolean;
    feed(input: Input): Parser<O>;
    bind(): O;
}

/** @internal */
export declare class ParserError extends Parser<never> {
    /** @internal */
    readonly error: Error;
    constructor(error: Error);
    isCont(): boolean;
    isError(): boolean;
    feed(input: Input): Parser<never>;
    bind(): never;
    trap(): Error;
    asError<O2>(): Parser<O2>;
}

/**
 * Thrown when a [[Parser]] parses invalid syntax.
 * @public
 */
export declare class ParserException extends Error {
    constructor(message?: Diagnostic | string);
    readonly diagnostic: Diagnostic | null;
    toString(): string;
}

/** @internal */
export declare class PatternFormat extends DateTimeFormat {
    private readonly pattern;
    private readonly specifiers;
    constructor(pattern: string, specifiers: DateTimeSpecifiers);
    writeDate<T>(output: Output<T>, date: DateTime): Output<T>;
    parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit>;
}

/** @internal */
export declare class PatternParser extends Parser<DateTimeInit> {
    private readonly pattern;
    private readonly specifiers;
    private readonly date;
    private readonly dateParser;
    private readonly step;
    constructor(pattern: string, specifiers: DateTimeSpecifiers, date?: DateTimeInit, dateParser?: Parser<DateTimeInit>, step?: number);
    feed(input: Input): Parser<DateTimeInit>;
    static parse(input: Input, pattern: string, specifiers: DateTimeSpecifiers, date?: DateTimeInit, dateParser?: Parser<DateTimeInit>, step?: number): Parser<DateTimeInit>;
}

/** @public */
export declare class PctLength extends Length {
    constructor(value: number);
    readonly value: number;
    get units(): LengthUnits;
    pxValue(basis?: LengthBasis | number): number;
    pctValue(basis?: LengthBasis | number): number;
    pct(basis?: LengthBasis | number): PctLength;
    toCssValue(): CSSUnitValue | null;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static zero(): PctLength;
}

/** @internal */
export declare class PeriodFormat extends DateTimeFormat {
    private readonly locale;
    constructor(locale: DateTimeLocale);
    withLocale(locale: DateTimeLocale): DateTimeFormat;
    writeDate<T>(output: Output<T>, date: DateTime): Output<T>;
    parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit>;
}

/** @internal */
export declare class PeriodParser extends Parser<DateTimeInit> {
    private readonly locale;
    private readonly date;
    private readonly output;
    constructor(locale: DateTimeLocale, date?: DateTimeInit, output?: Output<string>);
    feed(input: Input): Parser<DateTimeInit>;
    static parse(input: Input, locale: DateTimeLocale, date?: DateTimeInit, output?: Output<string>): Parser<DateTimeInit>;
    static term(locale: DateTimeLocale, value: string, date: DateTimeInit, input: Input): Parser<DateTimeInit>;
    static cont(locale: DateTimeLocale, date: DateTimeInit, output: Output<string>): Parser<DateTimeInit>;
}

/** @public */
export declare class PlusOperator extends BinaryOperator {
    constructor(operand1: Item, operand2: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): PlusOperator;
}

/** @internal */
export declare class PlusOutlet extends BinaryOutlet {
    protected evaluate(argument1: Value, argument2: Value): Item;
}

/** @public */
export declare class PositiveOperator extends UnaryOperator {
    constructor(operand: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): PositiveOperator;
}

/** @internal */
export declare class PositiveOutlet extends UnaryOutlet {
    protected evaluate(argument: Value): Item;
}

/** @public */
export declare interface Property<O = unknown, T = unknown, U = T> extends Fastener<O> {
    (): T;
    (value: T | U, affinity?: Affinity): O;
    /** @override */
    get fastenerType(): Proto<Property<any, any>>;
    /** @internal @override */
    setInherited(inherited: boolean, superFastener: Property<unknown, T>): void;
    /** @protected @override */
    willInherit(superFastener: Property<unknown, T>): void;
    /** @protected @override */
    onInherit(superFastener: Property<unknown, T>): void;
    /** @protected @override */
    didInherit(superFastener: Property<unknown, T>): void;
    /** @protected @override */
    willUninherit(superFastener: Property<unknown, T>): void;
    /** @protected @override */
    onUninherit(superFastener: Property<unknown, T>): void;
    /** @protected @override */
    didUninherit(superFastener: Property<unknown, T>): void;
    /** @override */
    readonly superFastener: Property<unknown, T> | null;
    /** @internal @override */
    getSuperFastener(): Property<unknown, T> | null;
    /** @protected @override */
    willBindSuperFastener(superFastener: Property<unknown, T>): void;
    /** @protected @override */
    onBindSuperFastener(superFastener: Property<unknown, T>): void;
    /** @protected @override */
    didBindSuperFastener(superFastener: Property<unknown, T>): void;
    /** @protected @override */
    willUnbindSuperFastener(superFastener: Property<unknown, T>): void;
    /** @protected @override */
    onUnbindSuperFastener(superFastener: Property<unknown, T>): void;
    /** @protected @override */
    didUnbindSuperFastener(superFastener: Property<unknown, T>): void;
    /** @internal */
    readonly subFasteners: ReadonlyArray<Property<unknown, T>> | null;
    /** @internal @override */
    attachSubFastener(subFastener: Property<unknown, T>): void;
    /** @internal @override */
    detachSubFastener(subFastener: Property<unknown, T>): void;
    get superValue(): T | undefined;
    getSuperValue(): NonNullable<T>;
    getSuperValueOr<E>(elseValue: E): NonNullable<T> | E;
    transformSuperValue(superValue: T): T;
    readonly value: T;
    getValue(): NonNullable<T>;
    getValueOr<E>(elseValue: E): NonNullable<T> | E;
    transformValue(value: T): T;
    setValue(newValue: T | U, affinity?: Affinity): void;
    /** @protected */
    willSetValue(newValue: T, oldValue: T): void;
    /** @protected */
    onSetValue(newValue: T, oldValue: T): void;
    /** @protected */
    didSetValue(newValue: T, oldValue: T): void;
    /** @internal @protected */
    decohereSubFasteners(): void;
    /** @internal @protected */
    decohereSubFastener(subFastener: Property<unknown, T>): void;
    /** @override */
    recohere(t: number): void;
    get updateFlags(): number | undefined;
    /** @internal */
    definedValue(value: T): boolean;
    /** @internal */
    equalValues(newValue: T, oldValue: T | undefined): boolean;
    /** @internal */
    fromAny(value: T | U): T;
}

/** @public */
export declare const Property: PropertyFactory<Property<any, any, any>>;

/** @public */
export declare interface PropertyClass<P extends Property<any, any> = Property<any, any>> extends FastenerClass<P> {
}

/** @public */
declare type PropertyDescriptor_2<O = unknown, T = unknown, U = T, I = {}> = ThisType<Property<O, T, U> & I> & PropertyInit<T, U> & Partial<I>;
export { PropertyDescriptor_2 as PropertyDescriptor }

/** @public */
export declare interface PropertyFactory<P extends Property<any, any> = Property<any, any>> extends PropertyClass<P> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): PropertyFactory<P> & I;
    specialize(type: unknown): PropertyFactory | null;
    define<O, T, U = T>(className: string, descriptor: PropertyDescriptor_2<O, T, U>): PropertyFactory<Property<any, T, U>>;
    define<O, T, U = T, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & PropertyDescriptor_2<O, T, U, I>): PropertyFactory<Property<any, T, U> & I>;
    <O, T extends string | undefined = string | undefined, U extends string | undefined = string | undefined>(descriptor: {
        type: typeof String;
    } & PropertyDescriptor_2<O, T, U>): PropertyDecorator;
    <O, T extends number | undefined = number | undefined, U extends number | string | undefined = number | string | undefined>(descriptor: {
        type: typeof Number;
    } & PropertyDescriptor_2<O, T, U>): PropertyDecorator;
    <O, T extends boolean | undefined = boolean | undefined, U extends boolean | string | undefined = boolean | string | undefined>(descriptor: {
        type: typeof Boolean;
    } & PropertyDescriptor_2<O, T, U>): PropertyDecorator;
    <O, T, U = T>(descriptor: ({
        type: FromAny<T, U>;
    } | {
        fromAny(value: T | U): T;
    }) & PropertyDescriptor_2<O, T, U>): PropertyDecorator;
    <O, T, U = T>(descriptor: PropertyDescriptor_2<O, T, U>): PropertyDecorator;
    <O, T, U = T, I = {}>(descriptor: {
        implements: unknown;
    } & PropertyDescriptor_2<O, T, U, I>): PropertyDecorator;
}

/** @public */
export declare interface PropertyInit<T = unknown, U = T> extends FastenerInit {
    extends?: {
        prototype: Property<any, any>;
    } | string | boolean | null;
    type?: unknown;
    value?: T | U;
    updateFlags?: number;
    willInherit?(superFastener: Property<unknown, T>): void;
    didInherit?(superFastener: Property<unknown, T>): void;
    willUninherit?(superFastener: Property<unknown, T>): void;
    didUninherit?(superFastener: Property<unknown, T>): void;
    willBindSuperFastener?(superFastener: Property<unknown, T>): void;
    didBindSuperFastener?(superFastener: Property<unknown, T>): void;
    willUnbindSuperFastener?(superFastener: Property<unknown, T>): void;
    didUnbindSuperFastener?(superFastener: Property<unknown, T>): void;
    transformSuperValue?(superValue: T): T;
    transformValue?(value: T): T;
    willSetValue?(newValue: T, oldValue: T): void;
    didSetValue?(newValue: T, oldValue: T): void;
    initValue?(): T | U;
    definedValue?(value: T): boolean;
    equalValues?(newValue: T, oldValue: T | undefined): boolean;
    fromAny?(value: T | U): T;
}

/** @internal */
export declare type PropertyValue<P extends Property<any, any>> = P extends Property<any, infer T> ? T : never;

/** @internal */
export declare type PropertyValueInit<P extends Property<any, any>> = P extends Property<any, infer T, infer U> ? T | U : never;

/** @public */
export declare interface Proto<T> extends Function {
    readonly prototype: T;
}

/** @public */
export declare type ProtoType<P> = P extends {
    readonly prototype: infer T;
} ? T : never;

/** @public */
export declare interface Provider<O = unknown, S = unknown> extends Fastener<O> {
    (): S;
    /** @override */
    get fastenerType(): Proto<Provider<any, any>>;
    /** @internal @override */
    setInherited(inherited: boolean, superFastener: Provider<unknown, S>): void;
    /** @protected @override */
    willInherit(superFastener: Provider<unknown, S>): void;
    /** @protected @override */
    onInherit(superFastener: Provider<unknown, S>): void;
    /** @protected @override */
    didInherit(superFastener: Provider<unknown, S>): void;
    /** @protected @override */
    willUninherit(superFastener: Provider<unknown, S>): void;
    /** @protected @override */
    onUninherit(superFastener: Provider<unknown, S>): void;
    /** @protected @override */
    didUninherit(superFastener: Provider<unknown, S>): void;
    /** @override */
    get superFastener(): Provider<unknown, S> | null;
    /** @internal @override */
    getSuperFastener(): Provider<unknown, S> | null;
    /** @protected @override */
    willBindSuperFastener(superFastener: Provider<unknown, S>): void;
    /** @protected @override */
    onBindSuperFastener(superFastener: Provider<unknown, S>): void;
    /** @protected @override */
    didBindSuperFastener(superFastener: Provider<unknown, S>): void;
    /** @protected @override */
    willUnbindSuperFastener(superFastener: Provider<unknown, S>): void;
    /** @protected @override */
    onUnbindSuperFastener(superFastener: Provider<unknown, S>): void;
    /** @protected @override */
    didUnbindSuperFastener(superFastener: Provider<unknown, S>): void;
    /** @internal @override */
    attachSubFastener(subFastener: Provider<unknown, S>): void;
    /** @internal @override */
    detachSubFastener(subFastener: Provider<unknown, S>): void;
    readonly service: S;
    getService(): NonNullable<S>;
    getServiceOr<E>(elseService: E): NonNullable<S> | E;
    /** @internal */
    setService(service: S): S;
    /** @protected */
    initService(service: S): void;
    /** @protected */
    willAttachService(service: S): void;
    /** @protected */
    onAttachService(service: S): void;
    /** @protected */
    didAttachService(service: S): void;
    /** @protected */
    deinitService(service: S): void;
    /** @protected */
    willDetachService(service: S): void;
    /** @protected */
    onDetachService(service: S): void;
    /** @protected */
    didDetachService(service: S): void;
    /** @internal */
    createService(): S;
    /** @protected @override */
    onMount(): void;
    /** @protected @override */
    onUnmount(): void;
    /** @internal */
    get observes(): boolean | undefined;
}

/** @public */
export declare const Provider: ProviderFactory<Provider<any, any>>;

/** @public */
export declare interface ProviderClass<P extends Provider<any, any> = Provider<any, any>> extends FastenerClass<P> {
}

/** @public */
export declare type ProviderDescriptor<O = unknown, S = unknown, I = {}> = ThisType<Provider<O, S> & I> & ProviderInit<S> & Partial<I>;

/** @public */
export declare interface ProviderFactory<P extends Provider<any, any> = Provider<any, any>> extends ProviderClass<P> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ProviderFactory<P> & I;
    define<O, S>(className: string, descriptor: ProviderDescriptor<O, S>): ProviderFactory;
    define<O, S extends Observable>(className: string, descriptor: {
        observes: boolean;
    } & ProviderDescriptor<O, S, ObserverType<S>>): ProviderFactory<Provider<any, S>>;
    define<O, S, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ProviderDescriptor<O, S, I>): ProviderFactory<Provider<any, S> & I>;
    define<O, S extends Observable, I = {}>(className: string, descriptor: {
        implements: unknown;
        observes: boolean;
    } & ProviderDescriptor<O, S, I & ObserverType<S>>): ProviderFactory<Provider<any, S> & I>;
    <O, S>(descriptor: ProviderDescriptor<O, S>): PropertyDecorator;
    <O, S extends Observable>(descriptor: {
        observes: boolean;
    } & ProviderDescriptor<O, S, ObserverType<S>>): PropertyDecorator;
    <O, S, I = {}>(descriptor: {
        implements: unknown;
    } & ProviderDescriptor<O, S, I>): PropertyDecorator;
    <O, S extends Observable, I = {}>(descriptor: {
        implements: unknown;
        observes: boolean;
    } & ProviderDescriptor<O, S, I & ObserverType<S>>): PropertyDecorator;
}

/** @public */
export declare interface ProviderInit<S = unknown> extends FastenerInit {
    extends?: {
        prototype: Provider<any, any>;
    } | string | boolean | null;
    type?: unknown;
    observes?: boolean;
    initService?(service: S): void;
    willAttachService?(service: S): void;
    didAttachService?(service: S): void;
    deinitService?(service: S): void;
    willDetachService?(service: S): void;
    didDetachService?(service: S): void;
    willInherit?(superFastener: Provider<unknown, S>): void;
    didInherit?(superFastener: Provider<unknown, S>): void;
    willUninherit?(superFastener: Provider<unknown, S>): void;
    didUninherit?(superFastener: Provider<unknown, S>): void;
    willBindSuperFastener?(superFastener: Provider<unknown, S>): void;
    didBindSuperFastener?(superFastener: Provider<unknown, S>): void;
    willUnbindSuperFastener?(superFastener: Provider<unknown, S>): void;
    didUnbindSuperFastener?(superFastener: Provider<unknown, S>): void;
    service?: S;
    createService?(): S;
}

/** @internal */
export declare type ProviderService<P extends Provider<any, any>> = P extends Provider<any, infer S> ? S : never;

/** @public */
export declare class PxLength extends Length {
    constructor(value: number);
    readonly value: number;
    get units(): LengthUnits;
    pxValue(basis?: LengthBasis | number): number;
    px(basis?: LengthBasis | number): PxLength;
    toCssValue(): CSSUnitValue | null;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static zero(): PxLength;
}

/** @public */
export declare abstract class R2BezierCurve extends R2Curve {
    abstract transform(f: R2Function): R2BezierCurve;
}

/** @public */
export declare class R2Box extends R2Shape implements Interpolate<R2Box>, HashCode, Equivalent, Debug {
    constructor(xMin: number, yMin: number, xMax: number, yMax: number);
    isDefined(): boolean;
    readonly xMin: number;
    readonly yMin: number;
    readonly xMax: number;
    readonly yMax: number;
    get x(): number;
    get y(): number;
    get width(): number;
    get height(): number;
    get top(): number;
    get right(): number;
    get bottom(): number;
    get left(): number;
    get center(): R2Point;
    contains(that: AnyR2Shape): boolean;
    contains(x: number, y: number): boolean;
    /** @internal */
    containsPoint(that: R2Point): boolean;
    /** @internal */
    containsSegment(that: R2Segment): boolean;
    /** @internal */
    containsBox(that: R2Box): boolean;
    /** @internal */
    containsCircle(that: R2Circle): boolean;
    intersects(that: AnyR2Shape): boolean;
    /** @internal */
    intersectsPoint(that: R2Point): boolean;
    /** @internal */
    intersectsSegment(that: R2Segment): boolean;
    /** @internal */
    static hitX: number;
    /** @internal */
    static hitY: number;
    static intersectsSegment(d0: number, d1: number, x0: number, y0: number, x1: number, y1: number): boolean;
    /** @internal */
    intersectsBox(that: R2Box): boolean;
    /** @internal */
    intersectsCircle(that: R2Circle): boolean;
    union(that: AnyR2Shape): R2Box;
    transform(f: R2Function): R2Box;
    get bounds(): R2Box;
    toAny(): R2BoxInit;
    interpolateTo(that: R2Box): Interpolator<R2Box>;
    interpolateTo(that: unknown): Interpolator<R2Box> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static undefined(): R2Box;
    static of(xMin: number, yMin: number, xMax?: number, yMax?: number): R2Box;
    static fromInit(value: R2BoxInit): R2Box;
    static fromAny(value: AnyR2Box): R2Box;
    /** @internal */
    static isInit(value: unknown): value is R2BoxInit;
    /** @internal */
    static isAny(value: unknown): value is AnyR2Box;
}

/** @public */
export declare interface R2BoxInit {
    xMin: number;
    yMin: number;
    xMax: number;
    yMax: number;
}

/** @internal */
export declare const R2BoxInterpolator: {
    (s0: R2Box, s1: R2Box): Interpolator<R2Box>;
    /** @internal */
    prototype: Interpolator<R2Box>;
};

/** @public */
export declare class R2Circle extends R2Shape implements Interpolate<R2Circle>, HashCode, Equivalent, Debug {
    constructor(cx: number, cy: number, r: number);
    isDefined(): boolean;
    readonly cx: number;
    readonly cy: number;
    readonly r: number;
    get xMin(): number;
    get yMin(): number;
    get xMax(): number;
    get yMax(): number;
    contains(that: AnyR2Shape): boolean;
    contains(x: number, y: number): boolean;
    /** @internal */
    containsPoint(that: R2Point): boolean;
    /** @internal */
    containsSegment(that: R2Segment): boolean;
    /** @internal */
    containsBox(that: R2Box): boolean;
    /** @internal */
    containsCircle(that: R2Circle): boolean;
    intersects(that: AnyR2Shape): boolean;
    /** @internal */
    intersectsPoint(that: R2Point): boolean;
    /** @internal */
    intersectsSegment(that: R2Segment): boolean;
    /** @internal */
    intersectsBox(that: R2Box): boolean;
    /** @internal */
    intersectsCircle(that: R2Circle): boolean;
    transform(f: R2Function): R2Circle;
    toAny(): R2CircleInit;
    interpolateTo(that: R2Circle): Interpolator<R2Circle>;
    interpolateTo(that: unknown): Interpolator<R2Circle> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static of(cx: number, cy: number, r: number): R2Circle;
    static fromInit(value: R2CircleInit): R2Circle;
    static fromAny(value: AnyR2Circle): R2Circle;
    /** @internal */
    static isInit(value: unknown): value is R2CircleInit;
    /** @internal */
    static isAny(value: unknown): value is AnyR2Circle;
}

/** @public */
export declare interface R2CircleInit {
    cx: number;
    cy: number;
    r: number;
}

/** @internal */
export declare const R2CircleInterpolator: {
    (s0: R2Circle, s1: R2Circle): Interpolator<R2Circle>;
    /** @internal */
    prototype: Interpolator<R2Circle>;
};

/** @public */
export declare class R2CubicCurve extends R2BezierCurve implements Debug {
    constructor(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number);
    isDefined(): boolean;
    readonly x0: number;
    readonly y0: number;
    readonly x1: number;
    readonly y1: number;
    readonly x2: number;
    readonly y2: number;
    readonly x3: number;
    readonly y3: number;
    get xMin(): number;
    get yMin(): number;
    get xMax(): number;
    get yMax(): number;
    interpolateX(u: number): number;
    interpolateY(u: number): number;
    interpolate(u: number): R2Point;
    contains(that: AnyR2Shape): boolean;
    contains(x: number, y: number): boolean;
    intersects(that: AnyR2Shape): boolean;
    split(u: number): [R2CubicCurve, R2CubicCurve];
    transform(f: R2Function): R2CubicCurve;
    drawMove(context: R2CurveContext): void;
    drawRest(context: R2CurveContext): void;
    transformDrawMove(context: R2CurveContext, f: R2Function): void;
    transformDrawRest(context: R2CurveContext, f: R2Function): void;
    writeMove<T>(output: Output<T>): Output<T>;
    writeRest<T>(output: Output<T>): Output<T>;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
}

/** @internal */
export declare class R2CubicCurveParser extends Parser<R2CubicCurve> {
    private readonly x0Parser;
    private readonly y0Parser;
    private readonly x1Parser;
    private readonly y1Parser;
    private readonly x2Parser;
    private readonly y2Parser;
    private readonly x3Parser;
    private readonly y3Parser;
    private readonly command;
    private readonly step;
    constructor(x0Parser?: Parser<number>, y0Parser?: Parser<number>, x1Parser?: Parser<number>, y1Parser?: Parser<number>, x2Parser?: Parser<number>, y2Parser?: Parser<number>, x3Parser?: Parser<number>, y3Parser?: Parser<number>, command?: number, step?: number);
    feed(input: Input): Parser<R2CubicCurve>;
    static parse(input: Input, x0Parser?: Parser<number>, y0Parser?: Parser<number>, x1Parser?: Parser<number>, y1Parser?: Parser<number>, x2Parser?: Parser<number>, y2Parser?: Parser<number>, x3Parser?: Parser<number>, y3Parser?: Parser<number>, command?: number, step?: number): Parser<R2CubicCurve>;
    static parseRest(input: Input, command?: number, x0Parser?: Parser<number>, y0Parser?: Parser<number>, x1Parser?: Parser<number>, y1Parser?: Parser<number>): Parser<R2CubicCurve>;
}

/** @public */
export declare abstract class R2Curve extends R2Shape implements Equals, Equivalent {
    abstract interpolateX(u: number): number;
    abstract interpolateY(u: number): number;
    abstract interpolate(u: number): R2Point;
    abstract split(u: number): [R2Curve, R2Curve];
    abstract transform(f: R2Function): R2Curve;
    abstract drawMove(context: R2CurveContext): void;
    abstract drawRest(context: R2CurveContext): void;
    draw(context: R2CurveContext): void;
    abstract transformDrawMove(context: R2CurveContext, f: R2Function): void;
    abstract transformDrawRest(context: R2CurveContext, f: R2Function): void;
    transformDraw(context: R2CurveContext, f: R2Function): void;
    abstract writeMove<T>(output: Output<T>): Output<T>;
    abstract writeRest<T>(output: Output<T>): Output<T>;
    writePath<T>(output: Output<T>): Output<T>;
    toPathString(outputSettings?: AnyOutputSettings): string;
    abstract equivalentTo(that: unknown, epsilon?: number): boolean;
    abstract equals(that: unknown): boolean;
    static linear(x0: number, y0: number, x1: number, y1: number): R2Curve;
    static quadratic(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number): R2Curve;
    static cubic(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): R2Curve;
    static elliptic(cx: number, cy: number, rx: number, ry: number, phi: number, a0: number, da: number): R2Curve;
    static parse(string: string): R2Curve;
}

/** @public */
export declare interface R2CurveContext {
    moveTo(x: number, y: number): void;
    lineTo(x: number, y: number): void;
    quadraticCurveTo(x1: number, y1: number, x: number, y: number): void;
    bezierCurveTo(x1: number, y1: number, x2: number, y2: number, x: number, y: number): void;
    arcTo(x1: number, y1: number, x2: number, y2: number, r: number): void;
    arc(cx: number, cy: number, r: number, a0: number, a1: number, ccw?: boolean): void;
    ellipse(cx: number, cy: number, rx: number, ry: number, phi: number, a0: number, a1: number, ccw?: boolean): void;
}

/** @internal */
export declare class R2CurveParser extends Parser<R2Curve> {
    private readonly x0Parser;
    private readonly y0Parser;
    private readonly command;
    private readonly step;
    constructor(x0Parser?: Parser<number>, y0Parser?: Parser<number>, command?: number, step?: number);
    feed(input: Input): Parser<R2Curve>;
    static parse(input: Input, x0Parser?: Parser<number>, y0Parser?: Parser<number>, command?: number, step?: number): Parser<R2Curve>;
}

/** @public */
export declare class R2EllipticCurve extends R2Curve implements Debug {
    constructor(cx: number, cy: number, rx: number, ry: number, phi: number, a0: number, da: number);
    readonly cx: number;
    readonly cy: number;
    readonly rx: number;
    readonly ry: number;
    readonly phi: number;
    readonly a0: number;
    readonly da: number;
    get xMin(): number;
    get yMin(): number;
    get xMax(): number;
    get yMax(): number;
    interpolateX(u: number): number;
    interpolateY(u: number): number;
    interpolate(u: number): R2Point;
    contains(that: AnyR2Shape): boolean;
    contains(x: number, y: number): boolean;
    intersects(that: AnyR2Shape): boolean;
    split(u: number): [R2EllipticCurve, R2EllipticCurve];
    transform(f: R2Function): R2EllipticCurve;
    drawMove(context: R2CurveContext): void;
    drawRest(context: R2CurveContext): void;
    transformDrawMove(context: R2CurveContext, f: R2Function): void;
    transformDrawRest(context: R2CurveContext, f: R2Function): void;
    writeMove<T>(output: Output<T>): Output<T>;
    writeRest<T>(output: Output<T>): Output<T>;
    toEndpoints(): {
        x0: number;
        y0: number;
        rx: number;
        ry: number;
        phi: number;
        large: boolean;
        sweep: boolean;
        x1: number;
        y1: number;
    };
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static fromEndpoints(x0: number, y0: number, rx: number, ry: number, phi: number, large: boolean, sweep: boolean, x1: number, y1: number): R2EllipticCurve;
}

/** @internal */
export declare class R2EllipticCurveParser extends Parser<R2EllipticCurve> {
    private readonly x0Parser;
    private readonly y0Parser;
    private readonly rxParser;
    private readonly ryParser;
    private readonly phiParser;
    private readonly large;
    private readonly sweep;
    private readonly x1Parser;
    private readonly y1Parser;
    private readonly command;
    private readonly step;
    constructor(x0Parser?: Parser<number>, y0Parser?: Parser<number>, rxParser?: Parser<number>, ryParser?: Parser<number>, phiParser?: Parser<number>, large?: boolean, sweep?: boolean, x1Parser?: Parser<number>, y1Parser?: Parser<number>, command?: number, step?: number);
    feed(input: Input): Parser<R2EllipticCurve>;
    static parse(input: Input, x0Parser?: Parser<number>, y0Parser?: Parser<number>, rxParser?: Parser<number>, ryParser?: Parser<number>, phiParser?: Parser<number>, large?: boolean, sweep?: boolean, x1Parser?: Parser<number>, y1Parser?: Parser<number>, command?: number, step?: number): Parser<R2EllipticCurve>;
    static parseRest(input: Input, command?: number, x0Parser?: Parser<number>, y0Parser?: Parser<number>): Parser<R2EllipticCurve>;
}

/** @public */
export declare interface R2Function {
    transformX(x: number, y: number): number;
    transformY(x: number, y: number): number;
}

/** @public */
export declare class R2Group<S extends R2Shape = R2Shape> extends R2Shape implements Equals, Equivalent, Debug {
    constructor(shapes: ReadonlyArray<S>);
    readonly shapes: ReadonlyArray<S>;
    isDefined(): boolean;
    get xMin(): number;
    get yMin(): number;
    get xMax(): number;
    get yMax(): number;
    contains(that: AnyR2Shape): boolean;
    contains(x: number, y: number): boolean;
    intersects(that: AnyR2Shape): boolean;
    transform(f: R2Function): R2Group;
    /** @internal */
    readonly boundingBox: R2Box | null;
    get bounds(): R2Box;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static empty<S extends R2Shape>(): R2Group<S>;
    static of<S extends R2Shape>(...shapes: S[]): R2Group<S>;
}

/** @public */
export declare interface R2Operator extends R2Function {
    inverse(): R2Operator;
}

/** @public */
export declare class R2Path extends R2Shape implements Equals, Equivalent, Debug {
    constructor(splines: ReadonlyArray<R2Spline>);
    readonly splines: ReadonlyArray<R2Spline>;
    isDefined(): boolean;
    get xMin(): number;
    get yMin(): number;
    get xMax(): number;
    get yMax(): number;
    interpolateX(u: number): number;
    interpolateY(u: number): number;
    interpolate(u: number): R2Point;
    contains(that: AnyR2Shape): boolean;
    contains(x: number, y: number): boolean;
    intersects(that: AnyR2Shape): boolean;
    split(u: number): [R2Path, R2Path];
    subdivide(u: number): R2Path;
    transform(f: R2Function): R2Path;
    /** @internal */
    readonly boundingBox: R2Box | null;
    get bounds(): R2Box;
    draw(context: R2PathContext): void;
    transformDraw(context: R2PathContext, f: R2Function): void;
    writePath<T>(output: Output<T>): Output<T>;
    /** @internal */
    readonly pathString: string | undefined;
    toPathString(outputSettings?: AnyOutputSettings): string;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toAttributeString(): string;
    toString(): string;
    static empty(): R2Path;
    static of(...splines: R2Spline[]): R2Path;
    static open(...curves: R2Curve[]): R2Path;
    static closed(...curves: R2Curve[]): R2Path;
    static fromAny(value: AnyR2Path | AnyR2Shape): R2Path;
    static builder(): R2PathBuilder;
    static parse(string: string): R2Path;
}

/** @public */
export declare class R2PathBuilder implements R2PathContext {
    /** @internal */
    splines: R2Spline[];
    /** @internal */
    builder: R2SplineBuilder | null;
    constructor();
    moveTo(x: number, y: number): void;
    closePath(): void;
    lineTo(x: number, y: number): void;
    quadraticCurveTo(x1: number, y1: number, x: number, y: number): void;
    bezierCurveTo(x1: number, y1: number, x2: number, y2: number, x: number, y: number): void;
    arcTo(x1: number, y1: number, x2: number, y2: number, r: number): void;
    arc(cx: number, cy: number, r: number, a0: number, a1: number, ccw?: boolean): void;
    ellipse(cx: number, cy: number, rx: number, ry: number, phi: number, a0: number, a1: number, ccw?: boolean): void;
    rect(x: number, y: number, w: number, h: number): void;
    bind(): R2Path;
}

/** @public */
export declare interface R2PathContext extends R2SplineContext {
}

/** @internal */
export declare class R2PathParser extends Parser<R2Path> {
    private readonly splineParser;
    private readonly splines;
    private readonly step;
    constructor(splineParser?: Parser<R2Spline>, splines?: R2Spline[], step?: number);
    feed(input: Input): Parser<R2Path>;
    static parse(input: Input, splineParser?: Parser<R2Spline>, splines?: R2Spline[], step?: number): Parser<R2Path>;
}

/** @public */
export declare class R2Point extends R2Shape implements Interpolate<R2Point>, HashCode, Equivalent, Debug {
    constructor(x: number, y: number);
    isDefined(): boolean;
    readonly x: number;
    readonly y: number;
    get xMin(): number;
    get yMin(): number;
    get xMax(): number;
    get yMax(): number;
    plus(vector: AnyR2Vector): R2Point;
    minus(vector: R2Vector): R2Point;
    minus(that: R2Point): R2Vector;
    contains(that: AnyR2Shape): boolean;
    contains(x: number, y: number): boolean;
    intersects(that: AnyR2Shape): boolean;
    transform(f: R2Function): R2Point;
    toAny(): R2PointInit;
    interpolateTo(that: R2Point): Interpolator<R2Point>;
    interpolateTo(that: unknown): Interpolator<R2Point> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static origin(): R2Point;
    static undefined(): R2Point;
    static of(x: number, y: number): R2Point;
    static fromInit(value: R2PointInit): R2Point;
    static fromTuple(value: R2PointTuple): R2Point;
    static fromAny(value: AnyR2Point): R2Point;
    /** @internal */
    static isInit(value: unknown): value is R2PointInit;
    /** @internal */
    static isTuple(value: unknown): value is R2PointTuple;
    /** @internal */
    static isAny(value: unknown): value is AnyR2Point;
}

/** @public */
export declare interface R2PointInit {
    x: number;
    y: number;
}

/** @internal */
export declare const R2PointInterpolator: {
    (p0: R2Point, p1: R2Point): Interpolator<R2Point>;
    /** @internal */
    prototype: Interpolator<R2Point>;
};

/** @public */
export declare type R2PointTuple = [number, number];

/** @public */
export declare class R2QuadraticCurve extends R2BezierCurve implements Debug {
    constructor(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number);
    isDefined(): boolean;
    readonly x0: number;
    readonly y0: number;
    readonly x1: number;
    readonly y1: number;
    readonly x2: number;
    readonly y2: number;
    get xMin(): number;
    get yMin(): number;
    get xMax(): number;
    get yMax(): number;
    interpolateX(u: number): number;
    interpolateY(u: number): number;
    interpolate(u: number): R2Point;
    contains(that: AnyR2Shape): boolean;
    contains(x: number, y: number): boolean;
    intersects(that: AnyR2Shape): boolean;
    split(u: number): [R2QuadraticCurve, R2QuadraticCurve];
    transform(f: R2Function): R2QuadraticCurve;
    drawMove(context: R2CurveContext): void;
    drawRest(context: R2CurveContext): void;
    transformDrawMove(context: R2CurveContext, f: R2Function): void;
    transformDrawRest(context: R2CurveContext, f: R2Function): void;
    writeMove<T>(output: Output<T>): Output<T>;
    writeRest<T>(output: Output<T>): Output<T>;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
}

/** @internal */
export declare class R2QuadraticCurveParser extends Parser<R2QuadraticCurve> {
    private readonly x0Parser;
    private readonly y0Parser;
    private readonly x1Parser;
    private readonly y1Parser;
    private readonly x2Parser;
    private readonly y2Parser;
    private readonly command;
    private readonly step;
    constructor(x0Parser?: Parser<number>, y0Parser?: Parser<number>, x1Parser?: Parser<number>, y1Parser?: Parser<number>, x2Parser?: Parser<number>, y2Parser?: Parser<number>, command?: number, step?: number);
    feed(input: Input): Parser<R2QuadraticCurve>;
    static parse(input: Input, x0Parser?: Parser<number>, y0Parser?: Parser<number>, x1Parser?: Parser<number>, y1Parser?: Parser<number>, x2Parser?: Parser<number>, y2Parser?: Parser<number>, command?: number, step?: number): Parser<R2QuadraticCurve>;
    static parseRest(input: Input, command?: number, x0Parser?: Parser<number>, y0Parser?: Parser<number>, x1Parser?: Parser<number>, y1Parser?: Parser<number>): Parser<R2QuadraticCurve>;
}

/** @public */
export declare class R2Segment extends R2BezierCurve implements Interpolate<R2Segment>, HashCode, Debug {
    constructor(x0: number, y0: number, x1: number, y1: number);
    isDefined(): boolean;
    readonly x0: number;
    readonly y0: number;
    readonly x1: number;
    readonly y1: number;
    get xMin(): number;
    get yMin(): number;
    get xMax(): number;
    get yMax(): number;
    interpolateX(u: number): number;
    interpolateY(u: number): number;
    interpolate(u: number): R2Point;
    contains(that: AnyR2Shape): boolean;
    contains(x: number, y: number): boolean;
    /** @internal */
    containsPoint(that: R2Point): boolean;
    /** @internal */
    containsSegment(that: R2Segment): boolean;
    /** @internal */
    static contains(ax: number, ay: number, bx: number, by: number, cx: number, cy: number): boolean;
    intersects(that: AnyR2Shape): boolean;
    /** @internal */
    intersectsPoint(that: R2Point): boolean;
    /** @internal */
    intersectsSegment(that: R2Segment): boolean;
    /** @internal */
    static intersects(px: number, py: number, rx: number, ry: number, qx: number, qy: number, sx: number, sy: number): boolean;
    split(u: number): [R2Segment, R2Segment];
    transform(f: R2Function): R2Segment;
    toAny(): R2SegmentInit;
    drawMove(context: R2CurveContext): void;
    drawRest(context: R2CurveContext): void;
    transformDrawMove(context: R2CurveContext, f: R2Function): void;
    transformDrawRest(context: R2CurveContext, f: R2Function): void;
    writeMove<T>(output: Output<T>): Output<T>;
    writeRest<T>(output: Output<T>): Output<T>;
    interpolateTo(that: R2Segment): Interpolator<R2Segment>;
    interpolateTo(that: unknown): Interpolator<R2Segment> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static of(x0: number, y0: number, x1: number, y1: number): R2Segment;
    static fromInit(value: R2SegmentInit): R2Segment;
    static fromAny(value: AnyR2Segment): R2Segment;
    /** @internal */
    static isInit(value: unknown): value is R2SegmentInit;
    /** @internal */
    static isAny(value: unknown): value is AnyR2Segment;
}

/** @public */
export declare interface R2SegmentInit {
    x0: number;
    y0: number;
    x1: number;
    y1: number;
}

/** @internal */
export declare const R2SegmentInterpolator: {
    (s0: R2Segment, s1: R2Segment): Interpolator<R2Segment>;
    /** @internal */
    prototype: Interpolator<R2Segment>;
};

/** @internal */
export declare class R2SegmentParser extends Parser<R2Segment> {
    private readonly x0Parser;
    private readonly y0Parser;
    private readonly x1Parser;
    private readonly y1Parser;
    private readonly command;
    private readonly step;
    constructor(x0Parser?: Parser<number>, y0Parser?: Parser<number>, x1Parser?: Parser<number>, y1Parser?: Parser<number>, command?: number, step?: number);
    feed(input: Input): Parser<R2Segment>;
    static parse(input: Input, x0Parser?: Parser<number>, y0Parser?: Parser<number>, x1Parser?: Parser<number>, y1Parser?: Parser<number>, command?: number, step?: number): Parser<R2Segment>;
    static parseRest(input: Input, command?: number, x0Parser?: Parser<number>, y0Parser?: Parser<number>): Parser<R2Segment>;
}

/** @public */
export declare abstract class R2Shape {
    abstract readonly xMin: number;
    abstract readonly yMin: number;
    abstract readonly xMax: number;
    abstract readonly yMax: number;
    abstract contains(that: AnyR2Shape): boolean;
    abstract contains(x: number, y: number): boolean;
    abstract intersects(that: AnyR2Shape): boolean;
    union(that: AnyR2Shape): R2Shape;
    abstract transform(f: R2Function): R2Shape;
    get bounds(): R2Box;
    static fromAny(value: AnyR2Shape): R2Shape;
    /** @internal */
    static isAny(value: unknown): value is AnyR2Shape;
}

/** @public */
export declare class R2Spline extends R2Curve implements Debug {
    constructor(curves: ReadonlyArray<R2Curve>, closed: boolean);
    readonly curves: ReadonlyArray<R2Curve>;
    /** @internal */
    readonly closed: boolean;
    isDefined(): boolean;
    isClosed(): boolean;
    get xMin(): number;
    get yMin(): number;
    get xMax(): number;
    get yMax(): number;
    interpolateX(u: number): number;
    interpolateY(u: number): number;
    interpolate(u: number): R2Point;
    contains(that: AnyR2Shape): boolean;
    contains(x: number, y: number): boolean;
    intersects(that: AnyR2Shape): boolean;
    split(u: number): [R2Spline, R2Spline];
    subdivide(u: number): R2Spline;
    transform(f: R2Function): R2Spline;
    /** @internal */
    readonly boundingBox: R2Box | null;
    get bounds(): R2Box;
    drawMove(context: R2SplineContext): void;
    drawRest(context: R2SplineContext): void;
    transformDrawMove(context: R2SplineContext, f: R2Function): void;
    transformDrawRest(context: R2SplineContext, f: R2Function): void;
    writeMove<T>(output: Output<T>): Output<T>;
    writeRest<T>(output: Output<T>): Output<T>;
    /** @internal */
    readonly pathString: string | undefined;
    toPathString(outputSettings?: AnyOutputSettings): string;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static empty(): R2Spline;
    static open(...curves: R2Curve[]): R2Spline;
    static closed(...curves: R2Curve[]): R2Spline;
    static builder(): R2SplineBuilder;
    static parse(string: string): R2Spline;
}

/** @public */
export declare class R2SplineBuilder implements R2SplineContext {
    /** @internal */
    curves: R2Curve[];
    /** @internal */
    closed: boolean;
    /** @internal */
    aliased: boolean;
    /** @internal */
    x0: number;
    /** @internal */
    y0: number;
    /** @internal */
    x: number;
    /** @internal */
    y: number;
    constructor();
    private dealias;
    moveTo(x: number, y: number): void;
    closePath(): void;
    lineTo(x: number, y: number): void;
    quadraticCurveTo(x1: number, y1: number, x: number, y: number): void;
    bezierCurveTo(x1: number, y1: number, x2: number, y2: number, x: number, y: number): void;
    arcTo(x1: number, y1: number, x2: number, y2: number, r: number): void;
    private static intersection;
    arc(cx: number, cy: number, r: number, a0: number, a1: number, ccw?: boolean): void;
    ellipse(cx: number, cy: number, rx: number, ry: number, phi: number, a0: number, a1: number, ccw?: boolean): void;
    rect(x: number, y: number, w: number, h: number): void;
    bind(): R2Spline;
}

/** @public */
export declare interface R2SplineContext extends R2CurveContext {
    rect(x: number, y: number, w: number, h: number): void;
    closePath(): void;
}

/** @internal */
export declare class R2SplineParser extends Parser<R2Spline> {
    private readonly xParser;
    private readonly yParser;
    private readonly x0Parser;
    private readonly y0Parser;
    private readonly curveParser;
    private readonly curves;
    private readonly command;
    private readonly step;
    constructor(xParser?: Parser<number>, yParser?: Parser<number>, x0Parser?: Parser<number>, y0Parser?: Parser<number>, curveParser?: Parser<R2Curve>, curves?: R2Curve[], command?: number, step?: number);
    feed(input: Input): Parser<R2Spline>;
    static parse(input: Input, xParser?: Parser<number>, yParser?: Parser<number>, x0Parser?: Parser<number>, y0Parser?: Parser<number>, curveParser?: Parser<R2Curve>, curves?: R2Curve[], command?: number, step?: number): Parser<R2Spline>;
}

/** @public */
export declare class R2Vector implements Interpolate<R2Vector>, HashCode, Equivalent, Debug {
    constructor(x: number, y: number);
    isDefined(): boolean;
    readonly x: number;
    readonly y: number;
    plus(that: AnyR2Vector): R2Vector;
    negative(): R2Vector;
    minus(that: AnyR2Vector): R2Vector;
    times(scalar: number): R2Vector;
    toAny(): R2VectorInit;
    interpolateTo(that: R2Vector): Interpolator<R2Vector>;
    interpolateTo(that: unknown): Interpolator<R2Vector> | null;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static zero(): R2Vector;
    static of(x: number, y: number): R2Vector;
    static fromInit(init: R2VectorInit): R2Vector;
    static fromAny(value: AnyR2Vector): R2Vector;
    /** @internal */
    static isInit(value: unknown): value is R2VectorInit;
    /** @internal */
    static isAny(value: unknown): value is AnyR2Vector;
}

/** @public */
export declare interface R2VectorInit {
    x: number;
    y: number;
}

/** @internal */
export declare const R2VectorInterpolator: {
    (v0: R2Vector, v1: R2Vector): Interpolator<R2Vector>;
    /** @internal */
    prototype: Interpolator<R2Vector>;
};

/** @public */
export declare class RadAngle extends Angle {
    constructor(value: number);
    readonly value: number;
    get units(): AngleUnits;
    degValue(): number;
    gradValue(): number;
    radValue(): number;
    turnValue(): number;
    rad(): RadAngle;
    toCssValue(): CSSUnitValue | null;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static zero(): RadAngle;
}

/** @public */
export declare const Random: {
    fillBytes(array: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array): void;
};

/** @public */
declare interface Range_2<Y> extends Mapping<number, Y> {
    readonly 0: Y;
    readonly 1: Y;
    readonly domain: LinearDomain;
    readonly range: this;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
    toString(): string;
}

/** @public */
declare const Range_2: {
    <Y>(y0: Y, y1: Y): Range_2<Y>;
    /** @internal */
    prototype: Range_2<any>;
    readonly unit: LinearRange;
};
export { Range_2 as Range }

/**
 * Factory for constructing Recon parsers and writers.
 * @public
 */
export declare const Recon: {
    structureParser(): ReconParser<Item, Value>;
    structureWriter(): ReconWriter<Item, Value>;
    parse(recon: string): Value;
    parser(): Parser<Value>;
    sizeOf(item: Item): number;
    sizeOfBlock(item: Item): number;
    write(output: Output, item: Item): Writer;
    writeBlock(output: Output, item: Item): Writer;
    toString(item: Item): string;
    toBlockString(item: Item): string;
    toData(item: Item): Data;
    toBlockData(item: Item): Data;
    /** @internal */
    isSpace(c: number): boolean;
    /** @internal */
    isNewline(c: number): boolean;
    /** @internal */
    isWhitespace(c: number): boolean;
    /** @internal */
    isIdentStartChar(c: number): boolean;
    /** @internal */
    isIdentChar(c: number): boolean;
};

/**
 * Factory for constructing Recon parsers and parse trees.
 * @public
 */
export declare abstract class ReconParser<I, V> {
    abstract isDistinct(value: V): boolean;
    abstract item(value: V): I;
    abstract value(item: I): V;
    abstract attr(key: V, value: V): I;
    abstract attr(key: V): I;
    abstract slot(key: V, value: V): I;
    abstract slot(key: V): I;
    abstract valueBuilder(): Builder<I, V>;
    abstract recordBuilder(): Builder<I, V>;
    abstract dataOutput(): Output<V>;
    abstract textOutput(): Output<V>;
    abstract ident(value: V): V;
    abstract num(value: number | string): V;
    abstract uint32(value: number): V;
    abstract uint64(value: number): V;
    abstract bool(value: boolean): V;
    abstract selector(): V;
    abstract extant(): V;
    abstract absent(): V;
    abstract conditional(ifTerm: V, thenTerm: V, elseTerm: V): V;
    abstract or(lhs: V, rhs: V): V;
    abstract and(lhs: V, rhs: V): V;
    abstract bitwiseOr(lhs: V, rhs: V): V;
    abstract bitwiseXor(lhs: V, rhs: V): V;
    abstract bitwiseAnd(lhs: V, rhs: V): V;
    abstract lt(lhs: V, rhs: V): V;
    abstract le(lhs: V, rhs: V): V;
    abstract eq(lhs: V, rhs: V): V;
    abstract ne(lhs: V, rhs: V): V;
    abstract ge(lhs: V, rhs: V): V;
    abstract gt(lhs: V, rhs: V): V;
    abstract plus(lhs: V, rhs: V): V;
    abstract minus(lhs: V, rhs: V): V;
    abstract times(lhs: V, rhs: V): V;
    abstract divide(lhs: V, rhs: V): V;
    abstract modulo(lhs: V, rhs: V): V;
    abstract not(rhs: V): V;
    abstract bitwiseNot(rhs: V): V;
    abstract negative(rhs: V): V;
    abstract positive(rhs: V): V;
    abstract invoke(func: V, args: V): V;
    abstract lambda(bindings: V, template: V): V;
    abstract get(selector: V, key: V): V;
    abstract getAttr(selector: V, key: V): V;
    abstract getItem(selector: V, index: V): I;
    abstract children(selector: V): V;
    abstract descendants(selector: V): V;
    abstract keys(selector: V): V;
    abstract values(selector: V): V;
    abstract filter(selector: V, predicate: V): V;
    parseBlock(input: Input): Parser<V>;
    parseAttr(input: Input): Parser<I>;
    parseBlockItem(input: Input): Parser<V>;
    parseInlineItem(input: Input): Parser<V>;
    parseRecord(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseMarkup(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseData(input: Input): Parser<V>;
    parseIdent(input: Input): Parser<V>;
    parseString(input: Input): Parser<V>;
    parseRawString(input: Input): Parser<V>;
    parseNumber(input: Input): Parser<V>;
    parseInteger(input: Input): Parser<V>;
    parseBlockExpression(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseLambdaFunc(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseConditionalOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseOrOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseAndOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseBitwiseOrOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseBitwiseXorOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseBitwiseAndOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseComparisonOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseAttrExpression(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseAdditiveOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseMultiplicativeOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parsePrefixOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseInvokeOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parsePrimary(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseLiteral(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseSelector(input: Input, builder?: Builder<I, V>): Parser<V>;
    blockParser(): Parser<V>;
    parseBlockString(string: string): V;
}

/** @public */
export declare class ReconStructureParser extends ReconParser<Item, Value> {
    isDistinct(value: Value): boolean;
    item(value: Value): Item;
    value(item: Item): Value;
    attr(key: Value, value?: Value): Item;
    slot(key: Value, value?: Value): Item;
    valueBuilder(): Builder<Item, Value>;
    recordBuilder(): Builder<Item, Value>;
    dataOutput(): Output<Value>;
    textOutput(): Output<Value>;
    ident(value: Value): Value;
    num(value: number | string): Value;
    uint32(value: number): Value;
    uint64(value: number): Value;
    bool(value: boolean): Value;
    selector(): Value;
    extant(): Value;
    absent(): Value;
    conditional(ifTerm: Value, thenTerm: Value, elseTerm: Value): Value;
    or(lhs: Value, rhs: Value): Value;
    and(lhs: Value, rhs: Value): Value;
    bitwiseOr(lhs: Value, rhs: Value): Value;
    bitwiseXor(lhs: Value, rhs: Value): Value;
    bitwiseAnd(lhs: Value, rhs: Value): Value;
    lt(lhs: Value, rhs: Value): Value;
    le(lhs: Value, rhs: Value): Value;
    eq(lhs: Value, rhs: Value): Value;
    ne(lhs: Value, rhs: Value): Value;
    ge(lhs: Value, rhs: Value): Value;
    gt(lhs: Value, rhs: Value): Value;
    plus(lhs: Value, rhs: Value): Value;
    minus(lhs: Value, rhs: Value): Value;
    times(lhs: Value, rhs: Value): Value;
    divide(lhs: Value, rhs: Value): Value;
    modulo(lhs: Value, rhs: Value): Value;
    not(rhs: Value): Value;
    bitwiseNot(rhs: Value): Value;
    negative(rhs: Value): Value;
    positive(rhs: Value): Value;
    invoke(func: Value, args: Value): Value;
    lambda(bindings: Value, template: Value): Value;
    get(selector: Value, key: Value): Value;
    getAttr(selector: Value, key: Value): Value;
    getItem(selector: Value, index: Value): Item;
    children(selector: Value): Value;
    descendants(selector: Value): Value;
    keys(selector: Value): Value;
    values(selector: Value): Value;
    filter(selector: Value, predicate: Value): Value;
}

/** @public */
export declare class ReconStructureWriter extends ReconWriter<Item, Value> {
    isField(item: Item): boolean;
    isAttr(item: Item): boolean;
    isSlot(item: Item): boolean;
    isValue(item: Item): boolean;
    isRecord(item: Item): boolean;
    isText(item: Item): boolean;
    isNum(item: Item): boolean;
    isBool(item: Item): boolean;
    isExpression(item: Item): boolean;
    isExtant(item: Item): boolean;
    items(item: Item): Cursor<Item>;
    item(value: Value): Item;
    key(item: Item): Value;
    value(item: Item): Value;
    string(item: Item): string;
    precedence(item: Item): number;
    sizeOfItem(item: Item): number;
    writeItem(output: Output, item: Item): Writer;
    sizeOfValue(value: Value): number;
    writeValue(output: Output, value: Value): Writer;
    sizeOfSelector(selector: Selector): number;
    writeSelector(output: Output, selector: Selector): Writer;
    sizeOfOperator(operator: Operator): number;
    writeOperator(output: Output, operator: Operator): Writer;
    sizeOfFunc(func: Func): number;
    writeFunc(output: Output, func: Func): Writer;
    sizeOfBlockItem(item: Item): number;
    writeBlockItem(output: Output, item: Item): Writer;
    sizeOfBlockValue(value: Value): number;
    writeBlockValue(output: Output, value: Value): Writer;
    sizeOfThen(then: Value): number;
    writeThen(output: Output, then: Value): Writer;
}

/**
 * Factory for constructing Recon writers.
 * @public
 */
export declare abstract class ReconWriter<I, V> {
    abstract isField(item: I): boolean;
    abstract isAttr(item: I): boolean;
    abstract isSlot(item: I): boolean;
    abstract isValue(item: I): boolean;
    abstract isRecord(item: I): boolean;
    abstract isText(item: I): boolean;
    abstract isNum(item: I): boolean;
    abstract isBool(item: I): boolean;
    abstract isExpression(item: I): boolean;
    abstract isExtant(item: I): boolean;
    abstract items(item: I): Cursor<I>;
    abstract item(value: V): I;
    abstract key(item: I): V;
    abstract value(item: I): V;
    abstract string(item: I): string;
    abstract precedence(item: I): number;
    abstract sizeOfItem(item: I): number;
    abstract writeItem(output: Output, item: I): Writer;
    abstract sizeOfValue(value: V): number;
    abstract writeValue(output: Output, value: V): Writer;
    abstract sizeOfBlockValue(value: V): number;
    abstract writeBlockValue(output: Output, value: V): Writer;
    sizeOfAttr(key: V, value: V): number;
    writeAttr(output: Output, key: V, value: V): Writer;
    sizeOfSlot(key: V, value: V): number;
    writeSlot(output: Output, key: V, value: V): Writer;
    abstract sizeOfBlockItem(item: I): number;
    abstract writeBlockItem(output: Output, item: I): Writer;
    sizeOfBlock(item: I): number;
    sizeOfBlock(items: Cursor<I>, inBlock: boolean, inMarkup: boolean): number;
    writeBlock(output: Output, item: I): Writer;
    writeBlock(output: Output, items: Cursor<I>, inBlock: boolean, inMarkup: boolean): Writer;
    sizeOfRecord(item: I): number;
    writeRecord(output: Output, item: I): Writer;
    sizeOfPrimary(value: V): number;
    writePrimary(output: Output, value: V): Writer;
    isBlockSafe(items: Cursor<I>): boolean;
    isMarkupSafe(items: Cursor<I>): boolean;
    sizeOfMarkupText(item: I | string): number;
    writeMarkupText(output: Output, item: I | string): Writer;
    sizeOfData(length: number): number;
    writeData(output: Output, value: Uint8Array | undefined): Writer;
    isIdent(value: I | string): boolean;
    sizeOfText(value: string): number;
    writeText(output: Output, value: string): Writer;
    sizeOfNum(value: number): number;
    writeNum(output: Output, value: number): Writer;
    sizeOfUint32(value: number): number;
    writeUint32(output: Output, value: number): Writer;
    sizeOfUint64(value: number): number;
    writeUint64(output: Output, value: number): Writer;
    sizeOfBool(value: boolean): number;
    writeBool(output: Output, value: boolean): Writer;
    sizeOfLambdaFunc(bindings: V, template: V): number;
    writeLambdaFunc(output: Output, bindings: V, template: V): Writer;
    sizeOfConditionalOperator(ifTerm: I, thenTerm: I, elseTerm: I, precedence: number): number;
    writeConditionalOperator(output: Output, ifTerm: I, thenTerm: I, elseTerm: I, precedence: number): Writer;
    sizeOfInfixOperator(lhs: I, operator: string, rhs: I, precedence: number): number;
    writeInfixOperator(output: Output, lhs: I, operator: string, rhs: I, precedence: number): Writer;
    sizeOfPrefixOperator(operator: string, rhs: I, precedence: number): number;
    writePrefixOperator(output: Output, operator: string, rhs: I, precedence: number): Writer;
    sizeOfInvokeOperator(func: V, args: V): number;
    writeInvokeOperator(output: Output, func: V, args: V): Writer;
    abstract sizeOfThen(then: V): number;
    abstract writeThen(output: Output, then: V): Writer;
    sizeOfIdentitySelector(): number;
    writeIdentitySelector(output: Output): Writer;
    sizeOfThenIdentitySelector(): number;
    writeThenIdentitySelector(output: Output): Writer;
    sizeOfLiteralSelector(item: I, then: V): number;
    writeLiteralSelector(output: Output, item: I, then: V): Writer;
    sizeOfThenLiteralSelector(item: I, then: V): number;
    writeThenLiteralSelector(output: Output, item: I, then: V): Writer;
    sizeOfGetSelector(key: V, then: V): number;
    writeGetSelector(output: Output, key: V, then: V): Writer;
    sizeOfThenGetSelector(key: V, then: V): number;
    writeThenGetSelector(output: Output, key: V, then: V): Writer;
    sizeOfGetAttrSelector(key: V, then: V): number;
    writeGetAttrSelector(output: Output, key: V, then: V): Writer;
    sizeOfThenGetAttrSelector(key: V, then: V): number;
    writeThenGetAttrSelector(output: Output, key: V, then: V): Writer;
    sizeOfGetItemSelector(index: V, then: V): number;
    writeGetItemSelector(output: Output, index: V, then: V): Writer;
    sizeOfThenGetItemSelector(index: V, then: V): number;
    writeThenGetItemSelector(output: Output, index: V, then: V): Writer;
    sizeOfKeysSelector(then: V): number;
    writeKeysSelector(output: Output, then: V): Writer;
    sizeOfThenKeysSelector(then: V): number;
    writeThenKeysSelector(output: Output, then: V): Writer;
    sizeOfValuesSelector(then: V): number;
    writeValuesSelector(output: Output, then: V): Writer;
    sizeOfThenValuesSelector(then: V): number;
    writeThenValuesSelector(output: Output, then: V): Writer;
    sizeOfChildrenSelector(then: V): number;
    writeChildrenSelector(output: Output, then: V): Writer;
    sizeOfThenChildrenSelector(then: V): number;
    writeThenChildrenSelector(output: Output, then: V): Writer;
    sizeOfDescendantsSelector(then: V): number;
    writeDescendantsSelector(output: Output, then: V): Writer;
    sizeOfThenDescendantsSelector(then: V): number;
    writeThenDescendantsSelector(output: Output, then: V): Writer;
    sizeOfFilterSelector(predicate: V, then: V): number;
    writeFilterSelector(output: Output, predicate: V, then: V): Writer;
    sizeOfThenFilterSelector(predicate: V, then: V): number;
    writeThenFilterSelector(output: Output, predicate: V, then: V): Writer;
    sizeOfExtant(): number;
    writeExtant(output: Output): Writer;
    sizeOfAbsent(): number;
    writeAbsent(output: Output): Writer;
}

/** @public */
declare abstract class Record_2 extends Value implements Builder<Item, Record_2> {
    /** @internal */
    constructor();
    isDefinite(): boolean;
    /**
     * Returns `true` if this `Record` has no members.
     */
    abstract isEmpty(): boolean;
    /**
     * Returns `true` if this `Record` has only [[Value]] members–no `Field`
     * members.
     */
    isArray(): boolean;
    /**
     * Returns `true` if this `Record` has only [[Field]] members–no `Value`
     * members.
     */
    isObject(): boolean;
    /**
     * Returns the number of members contained in this `Record`.
     */
    abstract get length(): number;
    /**
     * Returns the number of [[Field]] members contained in this `Record`.
     */
    readonly fieldCount: number;
    /**
     * Returns the number of [[Value]] members contained in this `Record`.
     */
    get valueCount(): number;
    isConstant(): boolean;
    /**
     * Returns the `key` string of the first member of this `Record`, if the
     * first member is an [[Attr]]; otherwise returns `undefined` if the first
     * member is not an `Attr`.
     *
     * Used to concisely get the name of the discriminating attribute of a
     * structure. The `tag` can be used to discern the nominal type of a
     * polymorphic structure, similar to an XML element tag.
     */
    get tag(): string | undefined;
    /**
     * Returns the [[Record.flattened flattened]] members of this `Record` after
     * all attributes have been removed.
     *
     * Used to concisely get the scalar value of an attributed structure. An
     * attributed structure is a `Record` with one or more attributes that modify
     * one or more other members.
     */
    get target(): Value;
    /**
     * Returns the sole member of this `Record`, if this `Record` has exactly one
     * member, and its member is a `Value`; returns [[Extant]] if this `Record`
     * is empty; otherwise returns `this` if this `Record` has more than one
     * member.
     *
     * Used to convert a unary `Record` into its member `Value`. Facilitates
     * writing code that treats a unary `Record` equivalently to a bare `Value`.
     */
    flattened(): Value;
    /**
     * Returns this `Record`.
     */
    unflattened(): Record_2;
    /**
     * Returns the value of the first member of this `Record`, if the first
     * member is an [[Attr]] whose `key` string is equal to `tag`; otherwise
     * returns [[Absent]] if the first member of this `Record` is not an `Attr`,
     * or if the first member of this `Record` is an `Attr` whose `key` does not
     * equal the `tag`.
     *
     * Used to conditionally get the value of the head `Attr` of a structure, if
     * and only if the key string of the head `Attr` is equal to the `tag`. Can
     * be used to check if a structure might conform to a nominal type named
     * `tag`, while simultaneously getting the value of the `tag` attribute.
     */
    header(tag: string): Value;
    /**
     * Returns the [[Record.unflattened unflattened]] [[Record.header header]] of
     * this `Record`. The `headers` of the `tag` attribute of a structure are
     * like the attributes of an XML element tag; through unlike an XML element,
     * `tag` attribute headers are not limited to string keys and values.
     */
    headers(tag: string): Record_2 | undefined;
    /**
     * Returns the first member of this `Record`, if this `Record` is non-empty;
     * otherwise returns [[Absent]].
     */
    head(): Item;
    /**
     * Returns a view of all but the first member of this `Record`, if this
     * `Record` is non-empty; otherwise returns an empty `Record`, if this
     * `Record` is itself empty.
     */
    tail(): Record_2;
    /**
     * Returns the [[Record.flattened flattened]] [[Record.tail tail]] of this
     * `Record`. Used to recursively deconstruct a structure, terminating
     * with its last `Value`, rather than a unary `Record` containing its last
     * value, if the structure ends with a `Value` member.
     */
    body(): Value;
    /**
     * Returns `true` if this `Record` has a [[Field]] member with a key that is
     * equal to the given `key`; otherwise returns `false` if this `Record` has
     * no `Field` member with a key equal to the given `key`.
     */
    has(key: AnyValue): boolean;
    indexOf(item: AnyItem, index?: number): number;
    lastIndexOf(item: AnyItem, index?: number): number;
    /**
     * Returns the value of the last [[Field]] member of this `Record` whose key
     * is equal to the given `key`; returns [[Absent]] if this `Record` has no
     * `Field` member with a key equal to the given `key`.
     */
    get(key: AnyValue): Value;
    /**
     * Returns the value of the last [[Attr]] member of this `Record` whose key
     * is equal to the given `key`; returns [[Absent]] if this `Record` has no
     * `Attr` member with a key equal to the given `key`.
     */
    getAttr(key: AnyText): Value;
    /**
     * Returns the value of the last [[Slot]] member of this `Record` whose key
     * is equal to the given `key`; returns [[Absent]] if this `Record` has no
     * `Slot` member with a key equal to the given `key`.
     */
    getSlot(key: AnyValue): Value;
    /**
     * Returns the last [[Field]] member of this `Record` whose key is equal to
     * the given `key`; returns `undefined` if this `Record` has no `Field` member
     * with a `key` equal to the given `key`.
     */
    getField(key: AnyValue): Field | undefined;
    /**
     * Returns the member of this `Record` at the given `index`, if the `index`
     * is greater than or equal to zero, and less than the [[Record.length
     * length]] of this `Record`; otherwise returns [[Absent]] if the `index` is
     * out of bounds.
     */
    abstract getItem(index: AnyNum): Item;
    set(key: AnyValue, newValue: AnyValue): this;
    setAttr(key: AnyText, newValue: AnyValue): this;
    setSlot(key: AnyValue, newValue: AnyValue): this;
    /**
     * Replaces the member of this `Record` at the given `index` with a new
     * `item`, returning `this` `Record`, if the `index` is greater than or
     * equal to zero, and less than the [[Record.length length]] of this `Record`.
     *
     * @throws `Error` if this is an immutable `Record`.
     * @throws `RangeError` if the `index` is out of bounds.
     */
    abstract setItem(index: number, item: AnyItem): this;
    updated(key: AnyValue, value: AnyValue): Record_2;
    updatedAttr(key: AnyText, value: AnyValue): Record_2;
    updatedSlot(key: AnyValue, value: AnyValue): Record_2;
    abstract push(...items: AnyItem[]): number;
    abstract splice(start: number, deleteCount?: number, ...newItems: AnyItem[]): Item[];
    abstract delete(key: AnyValue): Item;
    abstract clear(): void;
    appended(...items: AnyItem[]): Record_2;
    prepended(...items: AnyItem[]): Record_2;
    deleted(key: AnyValue): Record_2;
    concat(...items: AnyItem[]): Record_2;
    slice(lower?: number, upper?: number): Record_2;
    attr(key: AnyText, value?: AnyValue): this;
    slot(key: AnyValue, value?: AnyValue): this;
    item(item: AnyItem): this;
    items(...items: AnyItem[]): this;
    evaluate(interpreter: AnyInterpreter): Record_2;
    substitute(interpreter: AnyInterpreter): Record_2;
    stringValue(): string | undefined;
    stringValue<T>(orElse: T): string | T;
    toAny(): AnyValue;
    toArray(): AnyItem[];
    toObject(): {
        [key: string]: AnyValue;
    };
    isAliased(): boolean;
    isMutable(): boolean;
    alias(): void;
    branch(): Record_2;
    clone(): Record_2;
    commit(): this;
    bind(): Record_2;
    subRecord(lower?: number, upper?: number): Record_2;
    abstract forEach<T>(callback: (item: Item, index: number) => T | void): T | undefined;
    abstract forEach<T, S>(callback: (this: S, item: Item, index: number) => T | void, thisArg: S): T | undefined;
    iterator(): Cursor<Item>;
    interpolateTo(that: Record_2): Interpolator<Record_2>;
    interpolateTo(that: Item): Interpolator<Item>;
    interpolateTo(that: unknown): Interpolator<Item> | null;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    /** @internal */
    static readonly AliasedFlag: number;
    /** @internal */
    static readonly ImmutableFlag: number;
    static empty(): Record_2;
    static create(initialCapacity?: number): Record_2;
    static of(...items: AnyItem[]): Record_2;
    static fromAny(value: AnyRecord): Record_2;
    static fromArray(array: {
        [index: number]: AnyItem;
        length?: number;
    }): Record_2;
    static fromObject(object: {
        [key: string]: AnyValue;
    }): Record_2;
    /** @internal */
    static expand(n: number): number;
}
export { Record_2 as Record }

/** @internal */
export declare class RecordCursor extends Cursor<Item> {
    constructor(record: Record_2, lower?: number, upper?: number, index?: number);
    /** @internal */
    readonly record: Record_2;
    /** @internal */
    readonly lower: number;
    /** @internal */
    readonly upper: number;
    /** @internal */
    readonly index: number;
    /** @internal */
    readonly direction: number;
    isEmpty(): boolean;
    head(): Item;
    step(): void;
    skip(count: number): void;
    hasNext(): boolean;
    nextIndex(): number;
    next(): {
        value?: Item;
        done: boolean;
    };
    hasPrevious(): boolean;
    previousIndex(): number;
    previous(): {
        value?: Item;
        done: boolean;
    };
    set(newItem: Item): void;
    delete(): void;
}

/** @internal */
export declare class RecordFieldUpdater extends AbstractInlet<Value> {
    constructor(record: Record_2, key: Value);
    readonly record: Record_2;
    readonly key: Value;
    protected onDecohereOutput(): void;
    protected onRecohereOutput(version: number): void;
}

/** @internal */
export declare interface RecordInterpolator extends Interpolator<Record_2> {
    /** @internal */
    readonly interpolators: ReadonlyArray<Interpolator<Item>>;
    readonly 0: Record_2;
    readonly 1: Record_2;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const RecordInterpolator: {
    (y0: Record_2, y1: Record_2): RecordInterpolator;
    /** @internal */
    prototype: RecordInterpolator;
};

/** @internal */
export declare class RecordMap extends Record_2 {
    constructor(array: Array<Item> | null, table: Array<Field> | null, length: number, fieldCount: number, flags: number);
    /** @internal */
    readonly array: Array<Item> | null;
    /** @internal */
    readonly table: Array<Field> | null;
    isEmpty(): boolean;
    readonly length: number;
    readonly fieldCount: number;
    get valueCount(): number;
    /** @internal */
    readonly flags: number;
    isConstant(): boolean;
    get tag(): string | undefined;
    get target(): Value;
    head(): Item;
    tail(): Record_2;
    body(): Value;
    has(key: AnyValue): boolean;
    indexOf(item: AnyItem, index?: number): number;
    lastIndexOf(item: AnyItem, index?: number): number;
    get(key: AnyValue): Value;
    getAttr(key: AnyText): Value;
    getSlot(key: AnyValue): Value;
    getField(key: AnyValue): Field | undefined;
    getItem(index: AnyNum): Item;
    set(key: AnyValue, newValue: Value): this;
    /** @internal */
    setAliased(key: Value, newValue: Value): void;
    /** @internal */
    setMutable(key: Value, newValue: Value): void;
    /** @internal */
    updateMutable(key: Value, newValue: Value): void;
    setAttr(key: AnyText, newValue: Value): this;
    /** @internal */
    setAttrAliased(key: Text_2, newValue: Value): void;
    /** @internal */
    setAttrMutable(key: Text_2, newValue: Value): void;
    /** @internal */
    updateAttrMutable(key: Text_2, newValue: Value): void;
    setSlot(key: AnyValue, newValue: Value): this;
    /** @internal */
    setSlotAliased(key: Value, newValue: Value): void;
    /** @internal */
    setSlotMutable(key: Value, newValue: Value): void;
    /** @internal */
    updateSlotMutable(key: Value, newValue: Value): void;
    setItem(index: number, newItem: AnyItem): this;
    /** @internal */
    setItemAliased(index: number, newItem: Item): void;
    /** @internal */
    setItemMutable(index: number, newItem: Item): void;
    updated(key: AnyValue, newValue: AnyValue): Record_2;
    updatedAttr(key: AnyText, newValue: AnyValue): Record_2;
    updatedSlot(key: AnyValue, newValue: AnyValue): Record_2;
    push(...newItems: AnyItem[]): number;
    /** @internal */
    pushAliased(...newItems: AnyItem[]): void;
    /** @internal */
    pushMutable(...newItems: AnyItem[]): void;
    splice(start: number, deleteCount?: number, ...newItems: AnyItem[]): Item[];
    /** @internal */
    spliceAliased(start: number, deleteCount: number, ...newItems: AnyItem[]): Item[];
    /** @internal */
    spliceMutable(start: number, deleteCount: number, ...newItems: AnyItem[]): Item[];
    delete(key: AnyValue): Item;
    /** @internal */
    deleteAliased(key: Value): Item;
    /** @internal */
    deleteMutable(key: Value): Item;
    clear(): void;
    isAliased(): boolean;
    isMutable(): boolean;
    alias(): void;
    branch(): RecordMap;
    clone(): RecordMap;
    commit(): this;
    hashTable(): Array<Field> | null;
    /** @internal */
    static put(table: Field[] | null, field: Field): void;
    evaluate(interpreter: AnyInterpreter): Record_2;
    substitute(interpreter: AnyInterpreter): Record_2;
    subRecord(lower?: number, upper?: number): Record_2;
    forEach<T>(callback: (item: Item, index: number) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, item: Item, index: number) => T | void, thisArg: S): T | undefined;
    static empty(): RecordMap;
    static create(initialCapacity?: number): RecordMap;
    static of(...items: AnyItem[]): RecordMap;
}

/** @internal */
export declare class RecordMapView extends Record_2 {
    constructor(record: RecordMap, lower: number, upper: number);
    /** @internal */
    readonly record: RecordMap;
    /** @internal */
    readonly lower: number;
    /** @internal */
    readonly upper: number;
    isEmpty(): boolean;
    isArray(): boolean;
    isObject(): boolean;
    get length(): number;
    readonly fieldCount: number;
    get valueCount(): number;
    isConstant(): boolean;
    get tag(): string | undefined;
    get target(): Value;
    head(): Item;
    tail(): Record_2;
    body(): Value;
    indexOf(item: AnyItem, index?: number): number;
    lastIndexOf(item: AnyItem, index?: number): number;
    getItem(index: AnyNum): Item;
    setItem(index: number, newItem: AnyItem): this;
    /** @internal */
    setItemAliased(index: number, newItem: Item): void;
    /** @internal */
    setItemMutable(index: number, newItem: Item): void;
    push(...newItems: AnyItem[]): number;
    /** @internal */
    pushAliased(...newItems: AnyItem[]): void;
    /** @internal */
    pushMutable(...newItems: AnyItem[]): void;
    splice(start: number, deleteCount?: number, ...newItems: AnyItem[]): Item[];
    delete(key: AnyValue): Item;
    /** @internal */
    deleteAliased(key: Value): Item;
    /** @internal */
    deleteMutable(key: Value): Item;
    clear(): void;
    /** @internal */
    clearAliased(): void;
    /** @internal */
    clearMutable(): void;
    isAliased(): boolean;
    isMutable(): boolean;
    alias(): void;
    branch(): RecordMap;
    clone(): RecordMap;
    commit(): this;
    subRecord(lower?: number, upper?: number): Record_2;
    forEach<T>(callback: (item: Item, index: number) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, item: Item, index: number) => T | void, thisArg?: S): T | undefined;
}

/** @public */
export declare class RecordModel extends AbstractRecordOutlet {
    constructor(state?: Record_2);
    /** @internal */
    readonly state: Record_2;
    /** @internal */
    readonly fieldUpdaters: BTree<Value, RecordFieldUpdater>;
    isEmpty(): boolean;
    isArray(): boolean;
    isObject(): boolean;
    get length(): number;
    readonly fieldCount: number;
    get valueCount(): number;
    has(key: AnyValue): boolean;
    hasOwn(key: AnyValue): boolean;
    indexOf(item: AnyItem, index?: number): number;
    lastIndexOf(item: AnyItem, index?: number): number;
    get(): Record_2;
    get(key: AnyValue): Value;
    getAttr(key: AnyText): Value;
    getSlot(key: AnyValue): Value;
    getField(key: AnyValue): Field | undefined;
    getItem(index: AnyNum): Item;
    bindValue(key: Value, expr: Value): void;
    set(key: AnyValue, newValue: AnyValue): this;
    setAttr(key: AnyText, newValue: AnyValue): this;
    setSlot(key: AnyValue, newValue: AnyValue): this;
    setItem(index: number, newItem: AnyItem): this;
    push(...newItems: AnyItem[]): number;
    splice(start: number, deleteCount?: number, ...newItems: AnyItem[]): Item[];
    delete(key: AnyValue): Item;
    clear(): void;
    forEach<T>(callback: (item: Item, index: number) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, item: Item, index: number) => T | void, thisArg: S): T | undefined;
    keyIterator(): Cursor<Value>;
    disconnectInputs(): void;
    memoize(): MapOutlet<Value, Value, Record_2>;
    materialize(record: Record_2): void;
    materializeItem(item: Item): void;
    materializeField(field: Field): void;
    materializeValue(value: Value): void;
    compile(record: Record_2): void;
    compileItem(item: Item, index: number): void;
    compileField(field: Field, index: number): void;
    compileValue(value: Value, index: number): void;
    /** @beta */
    reify(reifier?: Reifier | null): void;
    /** @beta */
    reifyItem(item: Item, reifier: Reifier | null): Item;
    static from(record: Record_2): RecordModel;
    static of(...items: AnyItem[]): RecordModel;
    static globalScope(): RecordModel;
}

/** @public */
export declare interface RecordOutlet extends Outlet<Record_2>, MapOutlet<Value, Value, Record_2>, StreamletScope<Value> {
    outlet(key: Value | string): Outlet<Value>;
    get(): Record_2;
    get(key: Value): Value;
    memoize(): MapOutlet<Value, Value, Record_2>;
    map<O2>(func: MapValueFunction<Record_2, O2>): Outlet<O2>;
    map<V2>(func: MapFieldValuesFunction<Value, Value, V2>): MapOutlet<Value, V2, Map_2<Value, V2>>;
    watch(func: WatchValueFunction<Record_2>): this;
    watch(func: WatchFieldsFunction<Value, Value>): this;
}

/** @public */
export declare const RecordOutlet: {
    is(object: unknown): object is RecordOutlet;
};

/** @public */
export declare class RecordScope extends RecordModel {
    constructor(scope: StreamletScope<Value> | null, state?: Record_2);
    readonly streamletScope: StreamletScope<Value> | null;
    static from(record: Record_2): RecordScope;
    static of(...items: AnyItem[]): RecordScope;
}

/** @public */
export declare abstract class RecordStreamlet<I extends Value = Value, O extends Value = I> extends Record_2 implements Streamlet<I, O> {
    isConstant(): boolean;
    abstract readonly streamletScope: StreamletScope<O> | null;
    abstract setStreamletScope(parent: StreamletScope<O> | null): void;
    abstract readonly streamletContext: StreamletContext | null;
    abstract setStreamletContext(context: StreamletContext | null): void;
    abstract inlet(key: string): Inlet<I> | null;
    abstract bindInput(key: string, input: Outlet<I>): void;
    abstract unbindInput(key: string): void;
    abstract outlet(key: string): Outlet<O> | null;
    abstract disconnectInputs(): void;
    abstract disconnectOutputs(): void;
    abstract decohere(): void;
    abstract recohere(version: number): void;
    compile(): void;
    compileInlet(inlet: Inlet<I>, name: string): void;
}

/**
 * An [[OrderedMap]] that memoizes partial combinations of sub-elements to
 * support efficient, incremental reduction of continuously mutating datasets.
 * @public
 */
export declare interface ReducedMap<K, V, U> extends OrderedMap<K, V> {
    /**
     * Returns the reduction of this `ReducedMap`, combining all contained
     * elements with the given `accumulator` and `combiner` functions,
     * recomputing only what has changed since the last invocation of `reduced`.
     * Stores partial computations to accelerate repeated reduction of
     * continuously mutating datasets.
     */
    reduced(identity: U, accumulator: (result: U, element: V) => U, combiner: (result: U, result2: U) => U): U;
}

/** @public */
export declare class ReduceFieldsCombinator<K, V, I, O> extends ReduceFieldsOperator<K, V, I, O> {
    constructor(identity: O, accumulator: (result: O, element: V) => O, combiner: (result: O, result2: O) => O);
    get(): O;
    readonly identity: O;
    /** @internal */
    readonly accumulator: (result: O, element: V) => O;
    accumulate(result: O, value: V): O;
    /** @internal */
    readonly combiner: (result: O, result2: O) => O;
    combine(result: O, value: O): O;
}

/** @public */
export declare abstract class ReduceFieldsOperator<K, V, I, O> extends AbstractMapInletOutlet<K, V, I, O> {
    constructor();
    /** @internal */
    readonly state: BTree<K, V, O>;
    get(): O | undefined;
    protected onRecohereOutputKey(key: K, effect: KeyEffect, version: number): void;
    abstract readonly identity: O;
    abstract accumulate(result: O, value: V): O;
    abstract combine(result: O, value: O): O;
}

/** @public */
export declare interface RefContext extends DownlinkContext {
    /** @internal */
    openRef(ref: BaseRef): void;
    /** @internal */
    closeRef(ref: BaseRef): void;
    authenticate(hostUri: AnyUri, credentials: AnyValue): void;
    command(hostUri: AnyUri, nodeUri: AnyUri, laneUri: AnyUri, body: AnyValue): void;
}

/** @beta */
export declare abstract class Reifier {
    abstract reify(item: Item): Item;
    static system(): Reifier;
}

/** @public */
export declare class RemLength extends Length {
    constructor(value: number);
    readonly value: number;
    get units(): LengthUnits;
    pxValue(basis?: LengthBasis | number): number;
    remValue(basis?: LengthBasis | number): number;
    rem(basis?: LengthBasis | number): RemLength;
    toCssValue(): CSSUnitValue | null;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static zero(): RemLength;
}

/** @internal */
export declare abstract class RemoteHost extends Host {
    constructor(context: HostContext, hostUri: Uri, options: HostOptions);
    /** @internal */
    readonly context: HostContext;
    readonly hostUri: Uri;
    readonly options: HostOptions;
    get credentials(): Value;
    get unlinkDelay(): number;
    get maxReconnectTimeout(): number;
    get idleTimeout(): number;
    get sendBufferSize(): number;
    abstract get connected(): boolean;
    /** @internal */
    readonly authenticated: boolean;
    readonly session: Value;
    /** @internal */
    readonly sendBuffer: Envelope[];
    /** @internal */
    readonly downlinks: BTree<Uri, BTree<Uri, HostDownlink>>;
    /** @internal */
    readonly downlinkCount: number;
    get idle(): boolean;
    /** @internal */
    readonly uriCache: UriCache;
    resolve(relative: AnyUri): Uri;
    unresolve(absolute: AnyUri): Uri;
    authenticate(credentials: AnyValue): void;
    openDownlink(downlink: HostDownlink): void;
    unlinkDownlink(downlink: HostDownlink): void;
    closeDownlink(downlink: HostDownlink): void;
    command(nodeUri: AnyUri, laneUri: AnyUri, body: AnyValue): void;
    protected onEnvelope(envelope: Envelope): void;
    protected onEventMessage(message: EventMessage): void;
    protected onCommandMessage(message: CommandMessage): void;
    protected onLinkRequest(request: LinkRequest): void;
    protected onLinkedResponse(response: LinkedResponse): void;
    protected onSyncRequest(request: SyncRequest): void;
    protected onSyncedResponse(response: SyncedResponse): void;
    protected onUnlinkRequest(request: UnlinkRequest): void;
    protected onUnlinkedResponse(response: UnlinkedResponse): void;
    protected onAuthRequest(request: AuthRequest): void;
    protected onAuthedResponse(response: AuthedResponse): void;
    protected onDeauthRequest(request: DeauthRequest): void;
    protected onDeauthedResponse(response: DeauthedResponse): void;
    protected onUnknownEnvelope(envelope: Envelope | string): void;
    /** @internal */
    reconnectTimer: number;
    /** @internal */
    reconnectTimeout: number;
    /** @internal */
    idleTimer: number;
    protected onConnect(): void;
    protected onDisconnect(): void;
    protected onError(error?: unknown): void;
    protected reconnect(): void;
    protected clearReconnect(): void;
    protected watchIdle(): void;
    protected clearIdle(): void;
    protected checkIdle(): void;
    abstract open(): void;
    close(): void;
    closeUp(): void;
    abstract push(envelope: Envelope): void;
    static readonly UnlinkDelay: number;
    static readonly MaxReconnectTimeout: number;
    static readonly IdleTimeout: number;
    static readonly SendBufferSize: number;
}

/** @public */
export declare class RotateTransform extends Transform {
    constructor(angle: Angle);
    readonly angle: Angle;
    transform(that: Transform): Transform;
    transform(x: number, y: number): R2Point;
    transformX(x: number, y: number): number;
    transformY(x: number, y: number): number;
    inverse(): Transform;
    toAffine(): AffineTransform;
    toCssTransformComponent(): CSSTransformComponent | null;
    toValue(): Value;
    interpolateTo(that: RotateTransform): Interpolator<RotateTransform>;
    interpolateTo(that: Transform): Interpolator<Transform>;
    interpolateTo(that: unknown): Interpolator<Transform> | null;
    conformsTo(that: Transform): boolean;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    /** @internal */
    readonly stringValue: string | undefined;
    toString(): string;
    toAttributeString(): string;
    static fromCssTransformComponent(component: CSSRotate): RotateTransform;
    static fromAny(value: RotateTransform | string): RotateTransform;
    static fromValue(value: Value): RotateTransform | null;
    static parse(string: string): RotateTransform;
}

/** @internal */
export declare const RotateTransformInterpolator: {
    (f0: RotateTransform, f1: RotateTransform): Interpolator<RotateTransform>;
    /** @internal */
    prototype: Interpolator<RotateTransform>;
};

/** @internal */
export declare class RotateTransformParser extends Parser<RotateTransform> {
    private readonly identOutput;
    private readonly angleParser;
    private readonly step;
    constructor(identOutput?: Output<string>, angleParser?: Parser<Angle>, step?: number);
    feed(input: Input): Parser<RotateTransform>;
    static parse(input: Input, identOutput?: Output<string>, angleParser?: Parser<Angle>, step?: number): Parser<RotateTransform>;
    /** @internal */
    static parseRest(input: Input, identOutput?: Output<string>): Parser<RotateTransform>;
}

/** @public */
export declare interface Scale<X, Y> extends Mapping<X, Y> {
    readonly inverse: Mapping<Y, X>;
    withDomain(domain: Domain<X>): Scale<X, Y>;
    withDomain(x0: X, x1: X): Scale<X, Y>;
    overRange(range: Range_2<Y>): Scale<X, Y>;
    overRange(y0: Y, y1: Y): Scale<X, Y>;
    canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
    toString(): string;
}

/** @public */
export declare const Scale: {
    (): never;
    /** @internal */
    prototype: Scale<any, any>;
};

/** @public */
export declare class ScaleTransform extends Transform {
    constructor(x: number, y: number);
    readonly x: number;
    readonly y: number;
    transform(that: Transform): Transform;
    transform(x: number, y: number): R2Point;
    transformX(x: number, y: number): number;
    transformY(x: number, y: number): number;
    inverse(): Transform;
    toAffine(): AffineTransform;
    toCssTransformComponent(): CSSTransformComponent | null;
    toValue(): Value;
    interpolateTo(that: ScaleTransform): Interpolator<ScaleTransform>;
    interpolateTo(that: Transform): Interpolator<Transform>;
    interpolateTo(that: unknown): Interpolator<Transform> | null;
    conformsTo(that: Transform): boolean;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    /** @internal */
    readonly stringValue: string | undefined;
    toString(): string;
    static fromCssTransformComponent(component: CSSScale): ScaleTransform;
    static fromAny(value: ScaleTransform | string): ScaleTransform;
    static fromValue(value: Value): ScaleTransform | null;
    static parse(string: string): ScaleTransform;
}

/** @internal */
export declare const ScaleTransformInterpolator: {
    (f0: ScaleTransform, f1: ScaleTransform): Interpolator<ScaleTransform>;
    /** @internal */
    prototype: Interpolator<ScaleTransform>;
};

/** @internal */
export declare class ScaleTransformParser extends Parser<ScaleTransform> {
    private readonly identOutput;
    private readonly xParser;
    private readonly yParser;
    private readonly step;
    constructor(identOutput?: Output<string>, xParser?: Parser<number>, yParser?: Parser<number>, step?: number);
    feed(input: Input): Parser<ScaleTransform>;
    static parse(input: Input, identOutput?: Output<string>, xParser?: Parser<number>, yParser?: Parser<number>, step?: number): Parser<ScaleTransform>;
    /** @internal */
    static parseRest(input: Input, identOutput?: Output<string>): Parser<ScaleTransform>;
}

/** @internal */
export declare class SecondFormat extends DateTimeFormat {
    writeDate<T>(output: Output<T>, date: DateTime): Output<T>;
    parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit>;
}

/** @internal */
export declare class SecondInterval extends UnitTimeInterval {
    offset(d: AnyDateTime, k?: number): DateTime;
    next(d: AnyDateTime, k?: number): DateTime;
    floor(d: AnyDateTime): DateTime;
    ceil(d: AnyDateTime): DateTime;
    every(k: number): TimeInterval;
    /** @internal */
    static modulo(k: number, d: DateTime): boolean;
}

/** @internal */
export declare class SecondParser extends Parser<DateTimeInit> {
    private readonly date;
    private readonly second;
    private readonly step;
    constructor(date?: DateTimeInit, second?: number, step?: number);
    feed(input: Input): Parser<DateTimeInit>;
    static parse(input: Input, date?: DateTimeInit, second?: number, step?: number): Parser<DateTimeInit>;
    static term(second: number, date: DateTimeInit): Parser<DateTimeInit>;
    static cont(date: DateTimeInit, second: number, step: number): Parser<DateTimeInit>;
}

/** @public */
export declare abstract class Selector extends Expression {
    /** @internal */
    constructor();
    isConstant(): boolean;
    /**
     * The `Selector` that this `Selector` uses to match sub-selections.
     */
    abstract readonly then: Selector;
    abstract forSelected<T>(interpreter: Interpreter, callback: (interpreter: Interpreter) => T | undefined): T | undefined;
    abstract forSelected<T, S>(interpreter: Interpreter, callback: (this: S, interpreter: Interpreter) => T | undefined, thisArg: S): T | undefined;
    abstract mapSelected(interpreter: Interpreter, transform: (interpreter: Interpreter) => Item): Item;
    abstract mapSelected<S>(interpreter: Interpreter, transform: (this: S, interpreter: Interpreter) => Item, thisArg: S): Item;
    evaluate(interpreter: AnyInterpreter): Item;
    abstract substitute(interpreter: AnyInterpreter): Item;
    abstract andThen(then: Selector): Selector;
    get(key: AnyValue): Selector;
    getAttr(key: AnyText): Selector;
    getItem(index: AnyNum): Selector;
    keys(): Selector;
    values(): Selector;
    children(): Selector;
    descendants(): Selector;
    filter(predicate?: AnyItem): Selector;
    invoke(args: Value): Operator;
    get precedence(): number;
    debug<T>(output: Output<T>): Output<T>;
    abstract debugThen<T>(output: Output<T>): Output<T>;
    abstract clone(): Selector;
    static identity(): Selector;
    static get(key: AnyValue): Selector;
    static getAttr(key: AnyText): Selector;
    static getItem(index: AnyNum): Selector;
    static keys(): Selector;
    static values(): Selector;
    static children(): Selector;
    static descendants(): Selector;
    static literal(item: AnyItem): Selector;
}

/** @public */
export declare class Service<R> implements FastenerContext, Observable {
    constructor();
    /** @override */
    readonly observerType?: Class<ServiceObserver<R>>;
    /** @internal */
    readonly roots: ReadonlyArray<R>;
    /** @override */
    attachRoot(root: R): void;
    protected willAttachRoot(root: R): void;
    protected onAttachRoot(root: R): void;
    protected didAttachRoot(root: R): void;
    /** @override */
    detachRoot(root: R): void;
    protected willDetachRoot(root: R): void;
    protected onDetachRoot(root: R): void;
    protected didDetachRoot(root: R): void;
    get attached(): boolean;
    protected willAttach(): void;
    protected onAttach(): void;
    protected didAttach(): void;
    protected willDetach(): void;
    protected onDetach(): void;
    protected didDetach(): void;
    /** @internal */
    readonly fasteners: {
        [fastenerName: string]: Fastener | undefined;
    } | null;
    /** @override */
    hasFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): boolean;
    /** @override */
    getFastener<F extends Fastener<any>>(fastenerName: string, fastenerBound: Proto<F>): F | null;
    /** @override */
    getFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): Fastener | null;
    /** @override */
    setFastener(fastenerName: string, newFastener: Fastener | null): void;
    /** @internal */
    protected attachFastener(fastenerName: string, fastener: Fastener): void;
    protected willAttachFastener(fastenerName: string, fastener: Fastener): void;
    protected onAttachFastener(fastenerName: string, fastener: Fastener): void;
    protected didAttachFastener(fastenerName: string, fastener: Fastener): void;
    /** @internal */
    protected detachFastener(fastenerName: string, fastener: Fastener): void;
    protected willDetachFastener(fastenerName: string, fastener: Fastener): void;
    protected onDetachFastener(fastenerName: string, fastener: Fastener): void;
    protected didDetachFastener(fastenerName: string, fastener: Fastener): void;
    /** @override */
    getLazyFastener<F extends Fastener<any>>(fastenerName: string, fastenerBound: Proto<F>): F | null;
    /** @override */
    getLazyFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): Fastener | null;
    /** @override */
    getSuperFastener<F extends Fastener<any>>(fastenerName: string, fastenerBound: Proto<F>): F | null;
    /** @override */
    getSuperFastener(fastenerName: string, fastenerBound?: Proto<Fastener> | null): Fastener | null;
    /** @internal */
    protected mountFasteners(): void;
    /** @internal */
    protected unmountFasteners(): void;
    /** @internal */
    readonly decoherent: ReadonlyArray<Fastener> | null;
    /** @override */
    decohereFastener(fastener: Fastener): void;
    recohereFasteners(t?: number): void;
    /** @internal */
    readonly observers: ReadonlyArray<ObserverType<this>>;
    /** @override */
    observe(observer: ObserverType<this>): void;
    protected willObserve(observer: ObserverType<this>): void;
    protected onObserve(observer: ObserverType<this>): void;
    protected didObserve(observer: ObserverType<this>): void;
    /** @override */
    unobserve(observer: ObserverType<this>): void;
    protected willUnobserve(observer: ObserverType<this>): void;
    protected onUnobserve(observer: ObserverType<this>): void;
    protected didUnobserve(observer: ObserverType<this>): void;
    protected forEachObserver<T>(callback: (this: this, observer: ObserverType<this>) => T | void): T | undefined;
    callObservers<O, K extends keyof ObserverMethods<O>>(this: this & {
        readonly observerType?: Class<O>;
    }, key: K, ...args: ObserverParameters<O, K>): void;
}

/** @public */
export declare interface ServiceObserver<R, S extends Service<R> = Service<R>> extends Observer<S> {
    serviceWillAttachRoot?(root: R, service: S): void;
    serviceDidAttachRoot?(root: R, service: S): void;
    serviceWillDetachRoot?(root: R, service: S): void;
    serviceDidDetachRoot?(root: R, service: S): void;
    serviceWillAttach?(service: S): void;
    serviceDidAttach?(service: S): void;
    serviceWillDetach?(service: S): void;
    serviceDidDetach?(service: S): void;
}

/**
 * Level of importance. Used for log levels and diagnostic classifications.
 * @public
 */
export declare class Severity implements HashCode, Compare {
    private constructor();
    /**
     * The integer level of importance of this `Severity`, with higher  levels
     * signifying greater importance. An integer between `0` and `7`, inclusive.
     * One of `TRACE_LEVEL`, `DEBUG_LEVEL`, `INFO_LEVEL`, `NOTE_LEVEL`,
     * `WARNING_LEVEL`, `ERROR_LEVEL`, `ALERT_LEVEL`, `FATAL_LEVEL`.
     */
    readonly level: number;
    /**
     * A descriptive label for this `Severity`.
     */
    readonly label: string;
    /**
     * Returns `true` if this `Severity` has `TRACE_LEVEL` of importance.
     */
    isTrace(): boolean;
    /**
     * Returns `true` if this `Severity` has `DEBUG_LEVEL` of importance.
     */
    isDebug(): boolean;
    /**
     * Returns `true` if this `Severity` has `INFO_LEVEL` of importance.
     */
    isInfo(): boolean;
    /**
     * Returns `true` if this `Severity` has `NOTE_LEVEL` of importance.
     */
    isNote(): boolean;
    /**
     * Returns `true` if this `Severity` has `WARNING_LEVEL` of importance.
     */
    isWarning(): boolean;
    /**
     * Returns `true` if this `Severity` has `ERROR_LEVEL` of importance.
     */
    isError(): boolean;
    /**
     * Returns `true` if this `Severity` has `ALERT_LEVEL` of importance.
     */
    isAlert(): boolean;
    /**
     * Returns `true` if this `Severity` has `FATAL_LEVEL` of importance.
     */
    isFatal(): boolean;
    compareTo(that: unknown): number;
    equals(that: unknown): boolean;
    hashCode(): number;
    toString(): string;
    static readonly TRACE_LEVEL: number;
    static readonly DEBUG_LEVEL: number;
    static readonly INFO_LEVEL: number;
    static readonly NOTE_LEVEL: number;
    static readonly WARNING_LEVEL: number;
    static readonly ERROR_LEVEL: number;
    static readonly ALERT_LEVEL: number;
    static readonly FATAL_LEVEL: number;
    private static _trace?;
    private static _debug?;
    private static _info?;
    private static _note?;
    private static _warning?;
    private static _error?;
    private static _alert?;
    private static _fatal?;
    /**
     * Returns a `Severity` with the given importance `level`, and optional
     * descriptive `label`.
     *
     * @throws `Error` if `level` is not a valid level of importance.
     */
    static create(level: number, label?: string): Severity;
    /**
     * Returns a `Severity` with `TRACE_LEVEL` of importance, and an optional
     * descriptive `label`.
     */
    static trace(label?: string): Severity;
    /**
     * Returns a `Severity` with `DEBUG_LEVEL` of importance, and an optional
     * descriptive `label`.
     */
    static debug(label?: string): Severity;
    /**
     * Returns a `Severity` with `INFO_LEVEL` of importance, and an optional
     * descriptive `label`.
     */
    static info(label?: string): Severity;
    /**
     * Returns a `Severity` with `NOTE_LEVEL` of importance, and an optional
     * descriptive `label`.
     */
    static note(label?: string): Severity;
    /**
     * Returns a `Severity` with `WARNING_LEVEL` of importance, and an optional
     * descriptive `label`.
     */
    static warning(label?: string): Severity;
    /**
     * Returns a `Severity` with `ERROR_LEVEL` of importance, and an optional
     * descriptive `label`.
     */
    static error(label?: string): Severity;
    /**
     * Returns a `Severity` with `ALERT_LEVEL` of importance, and an optional
     * descriptive `label`.
     */
    static alert(label?: string): Severity;
    /**
     * Returns a `Severity` with `FATAL_LEVEL` of importance, and an optional
     * descriptive `label`.
     */
    static fatal(label?: string): Severity;
}

/** @internal */
export declare class ShortMonthFormat extends DateTimeFormat {
    private readonly locale;
    constructor(locale: DateTimeLocale);
    withLocale(locale: DateTimeLocale): DateTimeFormat;
    writeDate<T>(output: Output<T>, date: DateTime): Output<T>;
    parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit>;
}

/** @internal */
export declare class ShortMonthParser extends Parser<DateTimeInit> {
    private readonly locale;
    private readonly date;
    private readonly output;
    constructor(locale: DateTimeLocale, date?: DateTimeInit, output?: Output<string>);
    feed(input: Input): Parser<DateTimeInit>;
    static parse(input: Input, locale: DateTimeLocale, date?: DateTimeInit, output?: Output<string>): Parser<DateTimeInit>;
    static term(locale: DateTimeLocale, value: string, date: DateTimeInit, input: Input): Parser<DateTimeInit>;
    static cont(locale: DateTimeLocale, date: DateTimeInit, output: Output<string>): Parser<DateTimeInit>;
}

/** @internal */
export declare class ShortWeekdayFormat extends DateTimeFormat {
    private readonly locale;
    constructor(locale: DateTimeLocale);
    withLocale(locale: DateTimeLocale): DateTimeFormat;
    writeDate<T>(output: Output<T>, date: DateTime): Output<T>;
    parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit>;
}

/** @internal */
export declare class ShortWeekdayParser extends Parser<DateTimeInit> {
    private readonly locale;
    private readonly date;
    private readonly output;
    constructor(locale: DateTimeLocale, date?: DateTimeInit, output?: Output<string>);
    feed(input: Input): Parser<DateTimeInit>;
    static parse(input: Input, locale: DateTimeLocale, date?: DateTimeInit, output?: Output<string>): Parser<DateTimeInit>;
    static term(locale: DateTimeLocale, value: string, date: DateTimeInit, input: Input): Parser<DateTimeInit>;
    static cont(locale: DateTimeLocale, date: DateTimeInit, output: Output<string>): Parser<DateTimeInit>;
}

/** @public */
export declare abstract class Signal<S extends Signal<S> = Signal<any>> extends Message<S> {
    abstract readonly host: Uri;
    abstract withHost(host: AnyUri): S;
    static fromValue(value: Value): Signal | null;
    static parseRecon(input: string): Signal | null;
}

/** @public */
export declare class SkewTransform extends Transform {
    constructor(x: Angle, y: Angle);
    readonly x: Angle;
    readonly y: Angle;
    transform(that: Transform): Transform;
    transform(x: number, y: number): R2Point;
    transformX(x: number, y: number): number;
    transformY(x: number, y: number): number;
    inverse(): Transform;
    toAffine(): AffineTransform;
    toCssTransformComponent(): CSSTransformComponent | null;
    toValue(): Value;
    interpolateTo(that: SkewTransform): Interpolator<SkewTransform>;
    interpolateTo(that: Transform): Interpolator<Transform>;
    interpolateTo(that: unknown): Interpolator<Transform> | null;
    conformsTo(that: Transform): boolean;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    /** @internal */
    readonly stringValue: string | undefined;
    toString(): string;
    toAttributeString(): string;
    static fromCssTransformComponent(component: CSSSkew): SkewTransform;
    static fromAny(value: SkewTransform | string): SkewTransform;
    static fromValue(value: Value): SkewTransform | null;
    static parse(string: string): SkewTransform;
}

/** @internal */
export declare const SkewTransformInterpolator: {
    (f0: SkewTransform, f1: SkewTransform): Interpolator<SkewTransform>;
    /** @internal */
    prototype: Interpolator<SkewTransform>;
};

/** @internal */
export declare class SkewTransformParser extends Parser<SkewTransform> {
    private readonly identOutput;
    private readonly xParser;
    private readonly yParser;
    private readonly step;
    constructor(identOutput?: Output<string>, xParser?: Parser<Angle>, yParser?: Parser<Angle>, step?: number);
    feed(input: Input): Parser<SkewTransform>;
    static parse(input: Input, identOutput?: Output<string>, xParser?: Parser<Angle>, yParser?: Parser<Angle>, step?: number): Parser<SkewTransform>;
    /** @internal */
    static parseRest(input: Input, identOutput?: Output<string>): Parser<SkewTransform>;
}

/** @public */
export declare class Slot extends Field {
    constructor(key: Value, value: Value, flags?: number);
    readonly key: Value;
    readonly value: Value;
    /** @internal */
    readonly flags: number;
    isConstant(): boolean;
    setValue(newValue: Value): Value;
    updatedValue(value: Value): Slot;
    bitwiseOr(that: AnyItem): Item;
    bitwiseXor(that: AnyItem): Item;
    bitwiseAnd(that: AnyItem): Item;
    plus(that: AnyItem): Item;
    minus(that: AnyItem): Item;
    times(that: AnyItem): Item;
    divide(that: AnyItem): Item;
    modulo(that: AnyItem): Item;
    not(): Item;
    bitwiseNot(): Item;
    negative(): Item;
    positive(): Item;
    inverse(): Item;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    toAny(): AnyField;
    isAliased(): boolean;
    isMutable(): boolean;
    alias(): void;
    branch(): Slot;
    clone(): Slot;
    commit(): this;
    interpolateTo(that: Slot): Interpolator<Slot>;
    interpolateTo(that: Item): Interpolator<Item>;
    interpolateTo(that: unknown): Interpolator<Item> | null;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    keyEquals(key: unknown): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    static of(key: AnyValue, value?: AnyValue): Slot;
}

/** @internal */
export declare interface SlotInterpolator extends Interpolator<Slot> {
    /** @internal */
    readonly keyInterpolator: Interpolator<Value>;
    /** @internal */
    readonly valueInterpolator: Interpolator<Value>;
    readonly 0: Slot;
    readonly 1: Slot;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const SlotInterpolator: {
    (y0: Slot, y1: Slot): SlotInterpolator;
    /** @internal */
    prototype: SlotInterpolator;
};

/**
 * Description of a source range, identified by a closed interval between start
 * and end [[Mark marks]].
 * @public
 */
export declare class Span extends Tag {
    /** @internal */
    constructor(start: Mark, end: Mark);
    readonly start: Mark;
    readonly end: Mark;
    union(that: Tag): Tag;
    shift(mark: Mark): Span;
    equals(that: unknown): boolean;
    hashCode(): number;
    display<T>(output: Output<T>): Output<T>;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    /**
     * Returns a new `Span` representing the closed interval between the given
     * `start` and `end` marks.
     */
    static from(start: Mark, end: Mark): Span;
}

/** @internal */
export declare const StepInterpolator: {
    <Y>(y0: Y, y1: Y): Interpolator<Y>;
    /** @internal */
    prototype: Interpolator<any>;
};

/**
 * Stateful node in a dataflow graph that uses the state of its [[Inlet
 * inlets]] to compute the state of its [[Outlet Outlets]].
 * @public
 */
export declare interface Streamlet<I = unknown, O = I> extends StreamletScope<O> {
    /**
     * The lexically scoped parent of this `Streamlet`, or `null` if this
     * `Streamlet` has no lexical parent.
     */
    readonly streamletScope: StreamletScope<O> | null;
    /**
     * Sets the lexically scoped parent of this `Streamlet`.
     */
    setStreamletScope(scope: StreamletScope<O> | null): void;
    /**
     * The environment in which this `Streamlet` operates.
     */
    readonly streamletContext: StreamletContext | null;
    /**
     * Sets the environment in which this `Streamlet` operates.
     */
    setStreamletContext(context: StreamletContext | null): void;
    /**
     * Returns the `Inlet` to this `Streamlet` identified by the given `key`;
     * returns `null` if this `Streamlet` has no such `Inlet`.
     */
    inlet(key: string): Inlet<I> | null;
    /**
     * Connects the `Inlet` of this `Streamlet`, identified by the given `key` to
     * the `input` from which the `Inlet` should acquire its state. Delegates to
     * [[Inlet.bindInput]] on the identified `Inlet`.
     *
     * @throws `Error` if this `Streamlet` has no `Inlet` with the given `key`.
     */
    bindInput(key: string, input: Outlet<I>): void;
    /**
     * Disconnects the `Inlet` of this `Streamlet`, identified by the given
     * `key`, from its [[Inlet.input input]] `Outlet`, if connected. Delegates
     * to [[Inlet.unbindInput]] on the identified `Inlet`.
     *
     * @throws `Error` if this `Streamlet` has no `Inlet` with the given `key`.
     */
    unbindInput(key: string): void;
    /**
     * Returns the `Outlet` of this `Streamlet` identified by the given `key`;
     * returns `null` if this `Streamlet` has no such `Outlet`.
     */
    outlet(key: string): Outlet<O> | null;
    /**
     * Disconnects all `Inlet`s dominated by this `Streamlet` in the dataflow
     * dependency graph. Used to recursively clean up chains of combinators
     * terminating at this `Streamlet`.
     */
    disconnectInputs(): void;
    /**
     * Disconnects all `Inlets`s dominated by this `Streamlet` in the dataflow
     * graph. Used to recursively clean up chains of combinators originating
     * from this `Streamlet`.
     */
    disconnectOutputs(): void;
    /**
     * Marks this `Streamlet`—and all of its outlets—as having decoherent state.
     * Decohering a `Streamlet` will recursively decohere all streamlets that
     * transitively depend on the state of this `Streamlet`. Decohering a
     * `Streamlet` does not cause its state to be recomputed. A subsequent
     * [[recohere]] call will eventually make the state of the `Streamlet`
     * coherent again.
     */
    decohere(): void;
    /**
     * Updates the state of this `Streamlet` to make it consistent with the
     * target `version`. The `Streamlet` only needs to update if its current
     * `version` differs from the target `version`. To update its state, the
     * `Streamlet` first invokes [[Inlet.recohereOutput]] on each of its inlets,
     * to ensure that its input states are coherent. It then recomputes its own
     * state in an implementation defined manner. Finally, it invokes
     * [[Outlet.recohereInput]] on its outlets, causing all transitively
     * dependent streamlets to make their own states coherent again.
     */
    recohere(version: number): void;
}

/** @public */
export declare const Streamlet: {
    is<I, O>(object: unknown): object is Streamlet<I, O>;
};

/**
 * Environment in which a `Streamlet` executes.
 * @public
 */
export declare interface StreamletContext {
    log(message?: unknown, ...optionalParams: unknown[]): void;
}

/** @public */
export declare class StreamletException extends Error {
    constructor(message?: string);
}

/**
 * An `Inlet` that decoheres a parameterized `Streamlet` whenever the `Inlet`
 * decoheres, and that recoheres the parameterized `Streamlet` whenever the
 * `Inlet` recoheres.
 * @public
 */
export declare class StreamletInlet<I> extends AbstractInlet<I> {
    constructor(streamlet: Streamlet<I, unknown>);
    readonly streamlet: Streamlet<I, unknown>;
    protected willDecohereOutput(): void;
    protected didDecohereOutput(): void;
    protected willRecohereOutput(version: number): void;
    protected didRecohereOutput(version: number): void;
}

/**
 * An `Inoutlet` that decoheres a parameterized `Streamlet` whenever the
 * `Inoutlet` decoheres, that recoheres the parameterized `Streamlet`
 * whenever the `Inoutlet` recoheres, and which gets its state from the
 * parameterized `Streamlet`.
 * @public
 */
export declare class StreamletInoutlet<I, O> extends AbstractInoutlet<I, O> {
    constructor(streamlet: Streamlet<I, O>);
    readonly streamlet: Streamlet<I, O>;
    get(): O | undefined;
    protected willDecohere(): void;
    protected didDecohere(): void;
    protected willRecohere(version: number): void;
    protected didRecohere(version: number): void;
}

/**
 * An `Outlet` that decoheres a parameterized `Streamlet` whenever the
 * `Outlet` decoheres, and which gets its state from the parameterized
 * `Streamlet`.
 * @public
 */
export declare class StreamletOutlet<O> extends AbstractOutlet<O> {
    constructor(streamlet: Streamlet<unknown, O>);
    readonly streamlet: Streamlet<unknown, O>;
    get(): O | undefined;
    protected willDecohereInput(): void;
    protected didDecohereInput(): void;
    protected willRecohereInput(version: number): void;
    protected didRecohereInput(version: number): void;
}

/** @internal */
export declare interface StreamletPrototype {
    inlets?: {
        [name: string]: InletDescriptor | InoutletDescriptor | undefined;
    };
    outlets?: {
        [name: string]: OutletDescriptor | InoutletDescriptor | undefined;
    };
    inoutlets?: {
        [name: string]: InoutletDescriptor | undefined;
    };
}

/** @public */
export declare interface StreamletScope<O> {
    /**
     * The lexically scoped parent of this `StreamletScope`, or `null` if this
     * `StreamletScope` has no lexical parent.
     */
    readonly streamletScope: StreamletScope<O> | null;
    /**
     * The environment in which this `StreamletScope` operates.
     */
    readonly streamletContext: StreamletContext | null;
    /**
     * Returns an `Outlet` that updates when the specified `key` updates.
     */
    outlet(key: string): Outlet<O> | null;
}

/** @public */
export declare const StreamletScope: {
    is<O>(object: unknown): object is StreamletScope<O>;
};

/** @public */
export declare class STree<V = unknown, I = unknown> extends STreeContext<V, I> {
    /** @internal */
    root: STreePage<V, I>;
    constructor();
    /** @internal */
    constructor(root: STreePage<V, I>);
    get length(): number;
    isEmpty(): boolean;
    get(index: number, id?: I): V | undefined;
    getEntry(index: number, id?: I): [I, V] | undefined;
    set(index: number, newValue: V, id?: I): this;
    insert(index: number, newValue: V, id?: I): this;
    remove(index: number, id?: I): this;
    push(...newValues: V[]): number;
    pop(): V | undefined;
    unshift(...newValues: V[]): number;
    shift(): V | undefined;
    move(fromIndex: number, toIndex: number, id?: I): this;
    splice(start: number, deleteCount?: number, ...newValues: V[]): V[];
    drop(lower: number): this;
    take(upper: number): this;
    clear(): void;
    forEach<T>(callback: (value: V, index: number, id: I) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, value: V, index: number, id: I) => T | void, thisArg: S): T | undefined;
    keys(): Cursor<I>;
    values(): Cursor<V>;
    entries(): Cursor<[I, V]>;
    reverseKeys(): Cursor<I>;
    reverseValues(): Cursor<V>;
    reverseEntries(): Cursor<[I, V]>;
    clone(): STree<V, I>;
    /** @internal */
    protected copy(root: STreePage<V, I>): STree<V, I>;
    lookup(id: I, start?: number): number;
}

/** @public */
export declare abstract class STreeContext<V, I> {
    pageSplitSize: number;
    identify(value: V): I;
    compare(x: I, y: I): number;
    /** @internal */
    pageShouldSplit(page: STreePage<V, I>): boolean;
    /** @internal */
    pageShouldMerge(page: STreePage<V, I>): boolean;
}

/** @internal */
export declare class STreeLeaf<V, I> extends STreePage<V, I> {
    constructor(slots: ReadonlyArray<[I, V]>);
    /** @internal */
    readonly slots: ReadonlyArray<[I, V]>;
    get arity(): number;
    get size(): number;
    isEmpty(): boolean;
    get(index: number): V | undefined;
    getEntry(index: number): [I, V] | undefined;
    updated(index: number, newValue: V, tree: STreeContext<V, I>): STreeLeaf<V, I>;
    /** @internal */
    updatedItem(index: number, newValue: V): STreeLeaf<V, I>;
    inserted(index: number, newValue: V, id: I | undefined, tree: STreeContext<V, I>): STreeLeaf<V, I>;
    /** @internal */
    insertedItem(index: number, newValue: V, id: I | undefined, tree: STreeContext<V, I>): STreeLeaf<V, I>;
    removed(index: number, tree: STreeContext<V, I>): STreeLeaf<V, I>;
    /** @internal */
    removedSlot(index: number): STreeLeaf<V, I>;
    drop(lower: number, tree: STreeContext<V, I>): STreeLeaf<V, I>;
    take(upper: number, tree: STreeContext<V, I>): STreeLeaf<V, I>;
    balanced(tree: STreeContext<V, I>): STreePage<V, I>;
    split(index: number): STreeNode<V, I>;
    splitLeft(index: number): STreeLeaf<V, I>;
    splitRight(index: number): STreeLeaf<V, I>;
    forEach<T, S>(callback: (this: S, value: V, index: number, id: I) => T | void, thisArg: S, offset: number): T | undefined;
    entries(): Cursor<[I, V]>;
    reverseEntries(): Cursor<[I, V]>;
}

/** @internal */
export declare class STreeNode<V, I> extends STreePage<V, I> {
    constructor(pages: ReadonlyArray<STreePage<V, I>>, knots: ReadonlyArray<number>, size: number);
    /** @internal */
    readonly pages: ReadonlyArray<STreePage<V, I>>;
    /** @internal */
    readonly knots: ReadonlyArray<number>;
    get arity(): number;
    readonly size: number;
    isEmpty(): boolean;
    get(index: number): V | undefined;
    getEntry(index: number): [I, V] | undefined;
    updated(index: number, newValue: V, tree: STreeContext<V, I>): STreeNode<V, I>;
    /** @internal */
    updatedPage(x: number, newPage: STreePage<V, I>, oldPage: STreePage<V, I>): STreeNode<V, I>;
    /** @internal */
    updatedPageSplit(x: number, newPage: STreePage<V, I>, oldPage: STreePage<V, I>): STreeNode<V, I>;
    /** @internal */
    updatedPageMerge(x: number, newPage: STreeNode<V, I>, oldPage: STreePage<V, I>): STreeNode<V, I>;
    inserted(index: number, newValue: V, id: I | undefined, tree: STreeContext<V, I>): STreeNode<V, I>;
    removed(index: number, tree: STreeContext<V, I>): STreePage<V, I>;
    /** @internal */
    replacedPage(x: number, newPage: STreePage<V, I>, oldPage: STreePage<V, I>, tree: STreeContext<V, I>): STreePage<V, I>;
    /** @internal */
    removedPage(x: number, newPage: STreePage<V, I>, oldPage: STreePage<V, I>): STreeNode<V, I>;
    drop(lower: number, tree: STreeContext<V, I>): STreePage<V, I>;
    take(upper: number, tree: STreeContext<V, I>): STreePage<V, I>;
    balanced(tree: STreeContext<V, I>): STreeNode<V, I>;
    split(x: number): STreeNode<V, I>;
    splitLeft(x: number): STreeNode<V, I>;
    splitRight(x: number): STreeNode<V, I>;
    forEach<T, S>(callback: (this: S, value: V, index: number, id: I) => T | void, thisArg: S, offset: number): T | undefined;
    entries(): Cursor<[I, V]>;
    reverseEntries(): Cursor<[I, V]>;
    /** @internal */
    lookup(index: number): number;
    static create<V, I>(pages: ReadonlyArray<STreePage<V, I>>): STreeNode<V, I>;
}

/** @internal */
export declare class STreeNodeCursor<V, I> extends NodeCursor<[I, V], STreePage<V, I>> {
    constructor(pages: ReadonlyArray<STreePage<V, I>>, index?: number, childIndex?: number, childCursor?: Cursor<[I, V]> | null);
    protected pageSize(page: STreePage<V, I>): number;
    protected pageCursor(page: STreePage<V, I>): Cursor<[I, V]>;
    protected reversePageCursor(page: STreePage<V, I>): Cursor<[I, V]>;
}

/** @internal */
export declare abstract class STreePage<V = unknown, I = unknown> {
    abstract readonly arity: number;
    abstract readonly size: number;
    abstract isEmpty(): boolean;
    abstract get(index: number): V | undefined;
    abstract getEntry(index: number): [I, V] | undefined;
    abstract updated(index: number, newValue: V, tree: STreeContext<V, I>): STreePage<V, I>;
    abstract inserted(index: number, newValue: V, id: I | undefined, tree: STreeContext<V, I>): STreePage<V, I>;
    abstract removed(index: number, tree: STreeContext<V, I>): STreePage<V, I>;
    abstract drop(lower: number, tree: STreeContext<V, I>): STreePage<V, I>;
    abstract take(upper: number, tree: STreeContext<V, I>): STreePage<V, I>;
    abstract balanced(tree: STreeContext<V, I>): STreePage<V, I>;
    abstract split(index: number): STreePage<V, I>;
    abstract splitLeft(index: number): STreePage<V, I>;
    abstract splitRight(index: number): STreePage<V, I>;
    abstract forEach<T, S>(callback: (this: S, value: V, index: number, id: I) => T | void, thisArg: S, offset: number): T | undefined;
    keys(): Cursor<I>;
    values(): Cursor<V>;
    abstract entries(): Cursor<[I, V]>;
    reverseKeys(): Cursor<I>;
    reverseValues(): Cursor<V>;
    abstract reverseEntries(): Cursor<[I, V]>;
    static empty<V, I>(): STreeLeaf<V, I>;
}

/** @internal */
export declare const StringAnimator: AnimatorFactory<Animator<any, string | null | undefined, string | null | undefined>>;

/** @internal */
export declare class StringForm extends Form<string> {
    constructor(unit?: string);
    readonly unit: string | undefined;
    withUnit(unit: string | undefined): Form<string>;
    mold(object: string, item?: Item): Item;
    cast(item: Item, object?: string): string | undefined;
}

/** @internal */
export declare class StringInput extends Input {
    constructor(string: string, id: string | undefined, offset: number, line: number, column: number, settings: InputSettings, index: number, part: boolean);
    /** @internal */
    readonly string: string;
    /** @internal */
    readonly index: number;
    /** @internal */
    readonly part: boolean;
    isCont(): boolean;
    isEmpty(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): Input;
    head(): number;
    step(): Input;
    seek(mark?: Mark): Input;
    readonly id: string | undefined;
    withId(id: string | undefined): Input;
    get mark(): Mark;
    withMark(mark: Mark): Input;
    readonly offset: number;
    readonly line: number;
    readonly column: number;
    readonly settings: InputSettings;
    withSettings(settings: AnyInputSettings): Input;
    clone(): Input;
    static create(string: string): Input;
}

/** @internal */
export declare class StringOutput extends Output<string> {
    constructor(string: string, settings: OutputSettings);
    /** @internal */
    readonly string: string;
    isCont(): boolean;
    isFull(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): Output<string>;
    write(token: number | string): Output<string>;
    writeln(string?: string): Output<string>;
    readonly settings: OutputSettings;
    withSettings(settings: AnyOutputSettings): Output<string>;
    bind(): string;
    clone(): Output<string>;
    toString(): string;
}

/** @internal */
export declare const StringProperty: PropertyFactory<Property<any, string | null | undefined, string | null | undefined>>;

/**
 * Utilities for comparing and hashing strings.
 * @public
 */
export declare const Strings: {
    /**
     * Returns the relative order of `x` with respect to `y`. Returns `-1` if
     * the string `x` lexicographically orders before the string `y`; returns `1`
     * if the string `x` lexicographically orders after the string `y`; and
     * returns `0` if `x` and `y` are equal strings. If either `x` or `y` is
     * `null` or `undefined`, then strings order before `null`, and `null` orders
     * before `undefined`.
     */
    compare(x: string | null | undefined, y: string | null | undefined): number;
    /**
     * Returns a hash code for a string.
     */
    hash(x: string | null | undefined): number;
    codePointAt(string: string, index: number): number | undefined;
    offsetByCodePoints(string: string, index: number, count: number): number;
};

/** @internal */
export declare class StringWriter extends Writer<unknown, unknown> {
    /** @internal */
    readonly value: unknown;
    /** @internal */
    readonly input: string;
    /** @internal */
    readonly index: number;
    constructor(value: unknown, input: string, index?: number);
    feed(input: unknown): Writer<unknown, unknown>;
    pull(output: Output): Writer<unknown, unknown>;
    static write(output: Output, value: unknown, input: string, index?: number): Writer<unknown, unknown>;
}

/** @public */
export declare class SyncedResponse extends LaneAddressed<SyncedResponse> {
    static readonly tag: string;
}

/** @public */
export declare class SyncRequest extends LinkAddressed<SyncRequest> {
    static readonly tag: string;
}

/**
 * Description of a source location. Tags are used to annotate input sources,
 * particularly for [[Diagnostic diagnostic]] purposes. A [[Mark]] tag
 * annotates a source position. A [[Span]] tag annotate a source range.
 *
 * @see [[Diagnostic]]
 * @public
 */
export declare abstract class Tag implements HashCode, Display, Debug {
    /**
     * The first source position covered by this `Tag`.
     */
    abstract readonly start: Mark;
    /**
     * The last source position covered by this `Tag`.
     */
    abstract readonly end: Mark;
    /**
     * Returns a `Tag` that includes all source locations covered by
     * both this tag, and `that` tag.
     */
    abstract union(that: Tag): Tag;
    /**
     * Returns the position of this `Tag` relative to the given `mark`.
     */
    abstract shift(mark: Mark): Tag;
    abstract display<T>(output: Output<T>): Output<T>;
    abstract debug<T>(output: Output<T>): Output<T>;
    abstract equals(that: unknown): boolean;
    abstract hashCode(): number;
}

/** @internal */
export declare class TagForm<T, U = never> extends Form<T, U> {
    constructor(form: Form<T, U>, tag: string);
    /** @internal */
    readonly form: Form<T, U>;
    readonly tag: string;
    withTag(tag: string | undefined): Form<T, U>;
    readonly unit: T | undefined;
    withUnit(unit: T | undefined): Form<T, U>;
    mold(object: T | U, item?: Item): Item;
    cast(item: Item, object?: T): T | undefined;
}

/** @public */
declare class Text_2 extends Value {
    private constructor();
    isConstant(): boolean;
    readonly value: string;
    get size(): number;
    stringValue(): string;
    stringValue<T>(orElse: T): string;
    numberValue(): number | undefined;
    numberValue<T>(orElse: T): number | T;
    booleanValue(): boolean | undefined;
    booleanValue<T>(orElse: T): boolean | T;
    toAny(): AnyText;
    valueOf(): string;
    plus(that: AnyValue): Value;
    plus(that: AnyItem): Item;
    branch(): Text_2;
    clone(): Text_2;
    commit(): this;
    interpolateTo(that: Text_2): Interpolator<Text_2>;
    interpolateTo(that: Item): Interpolator<Item>;
    interpolateTo(that: unknown): Interpolator<Item> | null;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown): boolean;
    equals(that: unknown): boolean;
    /** @internal */
    readonly hashValue: number | undefined;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    toString(): string;
    static empty(): Text_2;
    static from(value: string): Text_2;
    static fromAny(value: AnyText): Text_2;
    static output(settings?: OutputSettings): Output<Text_2>;
    /** @internal */
    static get cache(): HashGenCacheSet<Text_2>;
}
export { Text_2 as Text }

/** @internal */
export declare class TextOutput extends Output<Text_2> {
    constructor(string: string, settings: OutputSettings);
    /** @internal */
    readonly string: string;
    isCont(): boolean;
    isFull(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): Output<Text_2>;
    write(token: number | string): Output<Text_2>;
    readonly settings: OutputSettings;
    withSettings(settings: AnyOutputSettings): Output<Text_2>;
    bind(): Text_2;
    clone(): Output<Text_2>;
    toString(): string;
}

/** @public */
export declare interface TimeDomain extends Domain<DateTime>, Interpolate<TimeDomain> {
    readonly 0: DateTime;
    readonly 1: DateTime;
    readonly inverse: TimeRange;
    contains(t: AnyDateTime): boolean;
    interpolateTo(that: TimeDomain): Interpolator<TimeDomain>;
    interpolateTo(that: unknown): Interpolator<TimeDomain> | null;
    canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
    toString(): string;
}

/** @public */
export declare const TimeDomain: {
    (x0: DateTime, x1: DateTime): TimeDomain;
    /** @internal */
    prototype: TimeDomain;
};

/** @internal */
export declare const TimeDomainInterpolator: {
    (x0: TimeDomain, x1: TimeDomain): Interpolator<TimeDomain>;
    /** @internal */
    prototype: Interpolator<TimeDomain>;
};

/** @public */
export declare abstract class TimeInterval {
    abstract offset(d: AnyDateTime, k?: number): DateTime;
    next(d: AnyDateTime, k?: number): DateTime;
    abstract floor(d: AnyDateTime): DateTime;
    ceil(d: AnyDateTime): DateTime;
    round(t: AnyDateTime): DateTime;
    range(t0: AnyDateTime, t1: AnyDateTime, step?: number): DateTime[];
    filter(predicate: (d: DateTime) => boolean): TimeInterval;
    static get year(): UnitTimeInterval;
    static get month(): UnitTimeInterval;
    static get week(): TimeInterval;
    static get day(): UnitTimeInterval;
    static get hour(): UnitTimeInterval;
    static get minute(): UnitTimeInterval;
    static get second(): UnitTimeInterval;
    static get millisecond(): UnitTimeInterval;
    static years(d0: AnyDateTime, d1: AnyDateTime, step?: number): DateTime[];
    static months(d0: AnyDateTime, d1: AnyDateTime, step?: number): DateTime[];
    static weeks(d0: AnyDateTime, d1: AnyDateTime, step?: number): DateTime[];
    static days(d0: AnyDateTime, d1: AnyDateTime, step?: number): DateTime[];
    static hours(d0: AnyDateTime, d1: AnyDateTime, step?: number): DateTime[];
    static minutes(d0: AnyDateTime, d1: AnyDateTime, step?: number): DateTime[];
    static seconds(d0: AnyDateTime, d1: AnyDateTime, step?: number): DateTime[];
    static milliseconds(d0: AnyDateTime, d1: AnyDateTime, step?: number): DateTime[];
    /** @internal */
    static readonly MillisPerSecond: number;
    /** @internal */
    static readonly MillisPerMinute: number;
    /** @internal */
    static readonly MillisPerHour: number;
}

/** @public */
export declare interface Timer<O = unknown> extends Fastener<O> {
    /** @override */
    get fastenerType(): Proto<Timer<any>>;
    /** @protected @override */
    onInherit(superFastener: Fastener): void;
    readonly delay: number;
    /** @internal @protected */
    initDelay(delay: number): void;
    setDelay(delay: number): void;
    readonly deadline: number | undefined;
    get elapsed(): number | undefined;
    get remaining(): number | undefined;
    /** @internal @protected */
    fire(): void;
    get scheduled(): boolean;
    schedule(delay?: number): void;
    throttle(delay?: number): void;
    debounce(delay?: number): void;
    /** @protected */
    willSchedule(delay: number): void;
    /** @protected */
    onSchedule(delay: number): void;
    /** @protected */
    didSchedule(delay: number): void;
    cancel(): void;
    /** @protected */
    willCancel(): void;
    /** @protected */
    onCancel(): void;
    /** @protected */
    didCancel(): void;
    /** @internal @protected */
    expire(): void;
    /** @protected */
    willExpire(): void;
    /** @protected */
    onExpire(): void;
    /** @protected */
    didExpire(): void;
    /** @internal */
    readonly timeout: unknown | undefined;
    /** @internal @protected */
    setTimeout(callback: () => void, delay: number): unknown;
    /** @internal @protected */
    clearTimeout(timeoutId: unknown): void;
    /** @override @protected */
    onUnmount(): void;
    /** @internal @override */
    get lazy(): boolean;
    /** @internal @override */
    get static(): string | boolean;
}

/** @public */
export declare const Timer: TimerFactory<Timer<any>>;

/** @public */
export declare interface TimeRange extends Range_2<DateTime>, Interpolate<TimeRange> {
    readonly 0: DateTime;
    readonly 1: DateTime;
    readonly inverse: TimeDomain;
    interpolateTo(that: TimeRange): Interpolator<TimeRange>;
    interpolateTo(that: unknown): Interpolator<TimeRange> | null;
    canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
    toString(): string;
}

/** @public */
export declare const TimeRange: {
    (y0: DateTime, y1: DateTime): TimeRange;
    /** @internal */
    prototype: TimeRange;
};

/** @internal */
export declare const TimeRangeInterpolator: {
    (y0: TimeRange, y1: TimeRange): Interpolator<TimeRange>;
    /** @internal */
    prototype: Interpolator<TimeRange>;
};

/** @public */
export declare interface TimerClass<F extends Timer<any> = Timer<any>> extends FastenerClass<F> {
}

/** @public */
export declare type TimerDescriptor<O = unknown, I = {}> = ThisType<Timer<O> & I> & TimerInit & Partial<I>;

/** @public */
export declare interface TimerFactory<F extends Timer<any> = Timer<any>> extends TimerClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): TimerFactory<F> & I;
    define<O>(className: string, descriptor: TimerDescriptor<O>): TimerFactory<Timer<any>>;
    define<O, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & TimerDescriptor<O, I>): TimerFactory<Timer<any> & I>;
    <O>(descriptor: TimerDescriptor<O>): PropertyDecorator;
    <O, I = {}>(descriptor: {
        implements: unknown;
    } & TimerDescriptor<O, I>): PropertyDecorator;
}

/** @public */
export declare interface TimerInit extends FastenerInit {
    extends?: {
        prototype: Timer<any>;
    } | string | boolean | null;
    delay?: number;
    fire?(): void;
    willSchedule?(delay: number): void;
    didSchedule?(delay: number): void;
    willCancel?(): void;
    didCancel?(): void;
    willExpire?(): void;
    didExpire?(): void;
    setTimeout?(callback: () => void, delay: number): unknown;
    clearTimeout?(timeout: unknown): void;
}

/** @public */
export declare interface TimeScale extends ContinuousScale<DateTime, number>, Interpolate<TimeScale> {
    readonly domain: TimeDomain;
    readonly range: LinearRange;
    readonly inverse: Mapping<number, DateTime>;
    withDomain(domain: TimeDomain): TimeScale;
    withDomain(x0: AnyDateTime, x1: AnyDateTime): TimeScale;
    overRange(range: LinearRange): TimeScale;
    overRange(y0: number, y1: number): TimeScale;
    clampDomain(xMin: DateTime | undefined, xMax: DateTime | undefined, zMin: number | undefined, zMax: number | undefined, epsilon?: number): TimeScale;
    solveDomain(x1: DateTime, y1: number, x2?: DateTime, y2?: number, reflect?: boolean, epsilon?: number): TimeScale;
    interpolateTo(that: TimeScale): Interpolator<TimeScale>;
    interpolateTo(that: unknown): Interpolator<TimeScale> | null;
    canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
    toString(): string;
}

/** @public */
export declare const TimeScale: {
    (domain: TimeDomain, range: LinearRange): TimeScale;
    /** @internal */
    prototype: TimeScale;
};

/** @internal */
export declare const TimeScaleInterpolator: {
    (s0: TimeScale, s1: TimeScale): Interpolator<TimeScale>;
    /** @internal */
    prototype: Interpolator<TimeScale>;
};

/** @public */
export declare class TimesOperator extends BinaryOperator {
    constructor(operand1: Item, operand2: Item);
    get operator(): string;
    get precedence(): number;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    clone(): TimesOperator;
}

/** @internal */
export declare class TimesOutlet extends BinaryOutlet {
    protected evaluate(argument1: Value, argument2: Value): Item;
}

/** @public */
export declare class TimeZone implements HashCode, Debug {
    /** @internal */
    private constructor();
    readonly name: string | undefined;
    readonly offset: number;
    isUTC(): boolean;
    isLocal(): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static get utc(): TimeZone;
    static get local(): TimeZone;
    static create(name: string | undefined, offset: number): TimeZone;
    static forName(name: string): TimeZone | null;
    static forOffset(offset: number): TimeZone;
    static fromAny(value: AnyTimeZone): TimeZone;
    static fromValue(value: Value): TimeZone | null;
    /** @internal */
    static isAny(value: unknown): value is AnyTimeZone;
    static form(): Form<TimeZone, AnyTimeZone>;
}

/** @internal */
export declare class TimeZoneForm extends Form<TimeZone, AnyTimeZone> {
    constructor(unit: TimeZone | undefined);
    readonly unit: TimeZone | undefined;
    withUnit(unit: TimeZone | undefined): Form<TimeZone, AnyTimeZone>;
    mold(zone: AnyTimeZone): Item;
    cast(item: Item): TimeZone | undefined;
}

/** @public */
export declare interface Timing extends Domain<number> {
    readonly 0: number;
    readonly 1: number;
    readonly duration: number;
    readonly easing: Easing;
    contains(t: number): boolean;
    withDomain(t0: number, t1: number): Timing;
    withDuration(dt: number): Timing;
    overRange<Y>(range: Interpolator<Y>): Tweening<Y>;
    overRange<Y>(y0: Y, y1: Y): Tweening<Y>;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
    toString(): string;
}

/** @public */
export declare const Timing: {
    (easing: Easing, t0: number, t1: number): Timing;
    /** @internal */
    prototype: Timing;
    fromInit(init: TimingInit): Timing;
    fromAny(value: AnyTiming): Timing;
    fromAny(value: AnyTiming | boolean | null | undefined): boolean | Timing;
};

/** @public */
export declare interface TimingInit {
    easing?: AnyEasing;
    t0?: number;
    t1?: number;
    dt?: number;
}

/** @public */
export declare interface ToAny<T> {
    toAny(): T;
}

/** @public */
export declare const ToAny: {
    /**
     * Returns `true` if `object` conforms to the [[ToAny]] interface.
     */
    is<T>(object: unknown): object is ToAny<T>;
};

/** @public */
export declare abstract class Transform implements R2Operator, Interpolate<Transform>, HashCode, Equivalent, Debug {
    abstract transform(that: Transform): Transform;
    abstract transform(x: number, y: number): R2Point;
    abstract transformX(x: number, y: number): number;
    abstract transformY(x: number, y: number): number;
    abstract inverse(): Transform;
    translate(x: AnyLength, y: AnyLength): Transform;
    translateX(x: AnyLength): Transform;
    translateY(y: AnyLength): Transform;
    scale(x: number, y: number): Transform;
    scaleX(x: number): Transform;
    scaleY(y: number): Transform;
    rotate(a: AnyAngle): Transform;
    skew(x: AnyAngle, y: AnyAngle): Transform;
    skewX(x: AnyAngle): Transform;
    skewY(y: AnyAngle): Transform;
    abstract toAffine(): AffineTransform;
    toMatrix(): DOMMatrix;
    toCssTransformComponent(): CSSTransformComponent | null;
    toCssValue(): CSSStyleValue | null;
    abstract toValue(): Value;
    interpolateTo(that: Transform): Interpolator<Transform>;
    interpolateTo(that: unknown): Interpolator<Transform> | null;
    abstract conformsTo(that: Transform): boolean;
    abstract equivalentTo(that: unknown, epsilon?: number): boolean;
    abstract equals(that: unknown): boolean;
    abstract hashCode(): number;
    abstract debug<T>(output: Output<T>): Output<T>;
    abstract toString(): string;
    toAttributeString(): string;
    static identity(): Transform;
    static translate(x: AnyLength, y: AnyLength): TranslateTransform;
    static translateX(x: AnyLength): TranslateTransform;
    static translateY(y: AnyLength): TranslateTransform;
    static scale(x: number, y: number): ScaleTransform;
    static scaleX(x: number): ScaleTransform;
    static scaleY(y: number): ScaleTransform;
    static rotate(a: AnyAngle): RotateTransform;
    static skew(x: AnyAngle, y: AnyAngle): SkewTransform;
    static skewX(x: AnyAngle): SkewTransform;
    static skewY(y: AnyAngle): SkewTransform;
    static affine(x0?: number, y0?: number, x1?: number, y1?: number, tx?: number, ty?: number): AffineTransform;
    static list(...transforms: AnyTransform[]): TransformList;
    static fromCssValue(value: CSSStyleValue): Transform;
    /** @internal */
    static fromCssTransform(value: CSSTransformValue): Transform;
    static fromCssTransformComponent(component: CSSTransformComponent): Transform;
    static fromAny(value: AnyTransform): Transform;
    static fromValue(value: Value): Transform | null;
    static parse(string: string): Transform;
    static form(): Form<Transform, AnyTransform>;
    /** @internal */
    static isAny(value: unknown): value is AnyTransform;
}

/** @internal */
export declare class TransformForm extends Form<Transform, AnyTransform> {
    constructor(unit: Transform | undefined);
    readonly unit: Transform | undefined;
    withUnit(unit: Transform | undefined): Form<Transform, AnyTransform>;
    mold(transform: AnyTransform): Item;
    cast(item: Item): Transform | undefined;
}

/** @public */
export declare class TransformList extends Transform {
    constructor(transforms: ReadonlyArray<Transform>);
    readonly transforms: ReadonlyArray<Transform>;
    transform(that: Transform): Transform;
    transform(x: number, y: number): R2Point;
    transformX(x: number, y: number): number;
    transformY(x: number, y: number): number;
    inverse(): Transform;
    toAffine(): AffineTransform;
    toCssTransformComponent(): CSSTransformComponent | null;
    toCssValue(): CSSStyleValue | null;
    toValue(): Value;
    interpolateTo(that: TransformList): Interpolator<TransformList>;
    interpolateTo(that: Transform): Interpolator<Transform>;
    interpolateTo(that: unknown): Interpolator<Transform> | null;
    conformsTo(that: Transform): boolean;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    /** @internal */
    readonly stringValue: string | undefined;
    toString(): string;
    toAttributeString(): string;
    static fromAny(value: TransformList | string): TransformList;
    static fromValue(value: Value): TransformList | null;
    static parse(string: string): TransformList;
}

/** @internal */
export declare interface TransformListInterpolator extends Interpolator<TransformList> {
    /** @internal */
    readonly interpolators: ReadonlyArray<Interpolator<Transform>>;
    readonly 0: TransformList;
    readonly 1: TransformList;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const TransformListInterpolator: {
    (f0: TransformList, f1: TransformList): TransformListInterpolator;
    /** @internal */
    prototype: TransformListInterpolator;
};

/** @internal */
export declare class TransformListParser extends Parser<Transform> {
    private readonly transform;
    private readonly transformParser;
    constructor(transform?: Transform, transformParser?: Parser<Transform>);
    feed(input: Input): Parser<Transform>;
    static parse(input: Input, transform?: Transform, transformParser?: Parser<Transform>): Parser<Transform>;
}

/** @internal */
export declare class TransformParser extends Parser<Transform> {
    private readonly identOutput;
    constructor(identOutput?: Output<string>);
    feed(input: Input): Parser<Transform>;
    static parse(input: Input, identOutput?: Output<string>): Parser<Transform>;
}

/** @public */
export declare class TranslateTransform extends Transform {
    constructor(x: Length, y: Length);
    readonly x: Length;
    readonly y: Length;
    transform(that: Transform): Transform;
    transform(x: number, y: number): R2Point;
    transformX(x: number, y: number): number;
    transformY(x: number, y: number): number;
    inverse(): Transform;
    toAffine(): AffineTransform;
    toCssTransformComponent(): CSSTransformComponent | null;
    toValue(): Value;
    interpolateTo(that: TranslateTransform): Interpolator<TranslateTransform>;
    interpolateTo(that: Transform): Interpolator<Transform>;
    interpolateTo(that: unknown): Interpolator<Transform> | null;
    conformsTo(that: Transform): boolean;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    /** @internal */
    readonly stringValue: string | undefined;
    toString(): string;
    toAttributeString(): string;
    static fromCssTransformComponent(component: CSSTranslate): TranslateTransform;
    static fromAny(value: TranslateTransform | string): TranslateTransform;
    static fromValue(value: Value): TranslateTransform | null;
    static parse(string: string): TranslateTransform;
}

/** @internal */
export declare const TranslateTransformInterpolator: {
    (f0: TranslateTransform, f1: TranslateTransform): Interpolator<TranslateTransform>;
    /** @internal */
    prototype: Interpolator<TranslateTransform>;
};

/** @internal */
export declare class TranslateTransformParser extends Parser<TranslateTransform> {
    private readonly identOutput;
    private readonly xParser;
    private readonly yParser;
    private readonly zParser;
    private readonly step;
    constructor(identOutput?: Output<string>, xParser?: Parser<Length>, yParser?: Parser<Length>, zParser?: Parser<Length>, step?: number);
    feed(input: Input): Parser<TranslateTransform>;
    static parse(input: Input, identOutput?: Output<string>, xParser?: Parser<Length>, yParser?: Parser<Length>, zParser?: Parser<Length>, step?: number): Parser<TranslateTransform>;
    /** @internal */
    static parseRest(input: Input, identOutput?: Output<string>): Parser<TranslateTransform>;
}

/** @public */
export declare class TurnAngle extends Angle {
    constructor(value: number);
    readonly value: number;
    get units(): AngleUnits;
    degValue(): number;
    gradValue(): number;
    radValue(): number;
    turnValue(): number;
    turn(): TurnAngle;
    toCssValue(): CSSUnitValue | null;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static zero(): TurnAngle;
}

/** @public */
export declare interface Tweening<Y> extends Mapping<number, Y> {
    readonly domain: Timing;
    readonly range: Interpolator<Y>;
    withDomain(t0: number, t1: number): Tweening<Y>;
    canEqual(that: unknown): boolean;
    equals(that: unknown): boolean;
    toString(): string;
}

/** @public */
export declare const Tweening: {
    <Y>(domain: Timing, range: Interpolator<Y>): Tweening<Y>;
    /** @internal */
    prototype: Tweening<any>;
};

/** @public */
export declare abstract class UnaryOperator extends Operator {
    constructor(operand: Item);
    readonly operand: Item;
    abstract readonly operator: string;
    isConstant(): boolean;
    interpolateTo(that: UnaryOperator): Interpolator<UnaryOperator>;
    interpolateTo(that: Item): Interpolator<Item>;
    interpolateTo(that: unknown): Interpolator<Item> | null;
}

/** @internal */
export declare interface UnaryOperatorInterpolator extends Interpolator<UnaryOperator> {
    /** @internal */
    readonly operator: string;
    /** @internal */
    readonly operandInterpolator: Interpolator<Item>;
    readonly 0: UnaryOperator;
    readonly 1: UnaryOperator;
    equals(that: unknown): boolean;
}

/** @internal */
export declare const UnaryOperatorInterpolator: {
    (y0: UnaryOperator, y1: UnaryOperator): UnaryOperatorInterpolator;
    /** @internal */
    prototype: UnaryOperatorInterpolator;
};

/** @internal */
export declare abstract class UnaryOutlet extends AbstractOutlet<Value> {
    constructor();
    readonly operandInlet: Inlet<Value>;
    get(): Value;
    protected abstract evaluate(argument: Value): Item;
}

/**
 * Unicode code point [[Input]]/[[Output]]/[[Writer]] factory.
 *
 * The `Unicode.stringInput(...)` function returns an `Input` that reads the
 * Unicode code points of a `string`.
 *
 * The `Unicode.stringOutput(...)` function returns an `Output` that writes
 * Unicode code points to an internal buffer, and [[Output.bind binds]] a
 * `string` containing all written code points.
 * @public
 */
export declare const Unicode: {
    stringInput(string: string): Input;
    /**
     * Returns a new `Output` that appends Unicode code points to the given
     * `string`, using the given output `settings`. The returned `Output`
     * accepts an unbounded number of code points, remaining permanently in the
     * _cont_ state, and [[Output.bind binds]] a `string` containing the given
     * `string`, and all appended code points.
     */
    stringOutput(string?: string | undefined, settings?: AnyOutputSettings | undefined): Output<string>;
    /**
     * Returns a new `Output` that appends Unicode code points to the given
     * `string`, using the given output `settings`. The returned `Output`
     * accepts an unbounded number of code points, remaining permanently in the
     * _cont_ state, and [[Output.bind binds]] a `string` containing the given
     * `string`, and all appended code points.
     */
    stringOutput(settings?: AnyOutputSettings | undefined): Output<string>;
    stringWriter<I>(): Writer<I, unknown>;
    stringWriter<I_1, O>(input: O): Writer<I_1, O>;
    writeString<I_2>(output: Output, input: unknown): Writer<I_2, unknown>;
    /** @internal */
    isAlpha(c: number): boolean;
    /** @internal */
    isDigit(c: number): boolean;
    /** @internal */
    isSpace(c: number): boolean;
    /** @internal */
    isNewline(c: number): boolean;
    /** @internal */
    isWhitespace(c: number): boolean;
};

/** @internal */
export declare class UnitForm<T, U = never> extends Form<T, U> {
    constructor(form: Form<T, U>, unit: T | undefined);
    /** @internal */
    readonly form: Form<T, U>;
    readonly tag: string | undefined;
    withTag(tag: string | undefined): Form<T, U>;
    readonly unit: T | undefined;
    withUnit(unit: T | undefined): Form<T, U>;
    mold(object: T | U, item?: Item): Item;
    cast(item: Item, object?: T): T | undefined;
}

/** @public */
export declare class UnitlessLength extends Length {
    constructor(value: number);
    readonly value: number;
    get units(): LengthUnits;
    pxValue(basis?: LengthBasis | number): number;
    toCssValue(): CSSUnitValue | null;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    static zero(): UnitlessLength;
}

/** @public */
export declare abstract class UnitTimeInterval extends TimeInterval {
    abstract every(k: number): TimeInterval;
}

/** @public */
export declare class UnlinkedResponse extends LaneAddressed<UnlinkedResponse> {
    static readonly tag: string;
}

/** @public */
export declare class UnlinkRequest extends LaneAddressed<UnlinkRequest> {
    static readonly tag: string;
}

/** @public */
export declare class Uri implements HashCode, Compare, Debug, Display {
    /** @internal */
    constructor(scheme: UriScheme, authority: UriAuthority, path: UriPath, query: UriQuery, fragment: UriFragment);
    isDefined(): boolean;
    isEmpty(): boolean;
    readonly scheme: UriScheme;
    withScheme(scheme: AnyUriScheme): Uri;
    get schemePart(): string;
    withSchemePart(schemePart: string): Uri;
    get schemeName(): string;
    withSchemeName(schemeName: string): Uri;
    readonly authority: UriAuthority;
    withAuthority(authority: AnyUriAuthority): Uri;
    get authorityPart(): string;
    withAuthorityPart(authorityPart: string): Uri;
    get user(): UriUser;
    withUser(user: AnyUriUser): Uri;
    get userPart(): string;
    withUserPart(userPart: string): Uri;
    get username(): string | undefined;
    withUsername(username: string | undefined, password?: string): Uri;
    get password(): string | undefined;
    withPassword(password: string | undefined): Uri;
    get host(): UriHost;
    withHost(host: AnyUriHost): Uri;
    get hostPart(): string;
    withHostPart(hostPart: string): Uri;
    get hostAddress(): string;
    get hostName(): string | undefined;
    withHostName(hostName: string): Uri;
    get hostIPv4(): string | undefined;
    withHostIPv4(hostIPv4: string): Uri;
    get hostIPv6(): string | undefined;
    withHostIPv6(hostIPv6: string): Uri;
    get port(): UriPort;
    withPort(port: AnyUriPort): Uri;
    get portPart(): string;
    withPortPart(portPart: string): Uri;
    get portNumber(): number;
    withPortNumber(portNumber: number): Uri;
    readonly path: UriPath;
    withPath(...components: AnyUriPath[]): Uri;
    get pathPart(): string;
    withPathPart(pathPart: string): Uri;
    get pathName(): string;
    withPathName(pathName: string): Uri;
    parentPath(): UriPath;
    basePath(): UriPath;
    parent(): Uri;
    base(): Uri;
    appendedPath(...components: AnyUriPath[]): Uri;
    appendedSlash(): Uri;
    appendedSegment(segment: string): Uri;
    prependedPath(...components: AnyUriPath[]): Uri;
    prependedSlash(): Uri;
    prependedSegment(segment: string): Uri;
    readonly query: UriQuery;
    withQuery(query: AnyUriQuery): Uri;
    get queryPart(): string;
    withQueryPart(query: string): Uri;
    updatedQuery(key: string, value: string): Uri;
    removedQuery(key: string): Uri;
    appendedQuery(key: string | undefined, value: string): Uri;
    appendedQuery(params: AnyUriQuery): Uri;
    prependedQuery(key: string | undefined, value: string): Uri;
    prependedQuery(params: AnyUriQuery): Uri;
    readonly fragment: UriFragment;
    withFragment(fragment: AnyUriFragment): Uri;
    get fragmentPart(): string;
    withFragmentPart(fragmentPart: string): Uri;
    get fragmentIdentifier(): string | undefined;
    withFragmentIdentifier(fragmentIdentifier: string | undefined): Uri;
    endpoint(): Uri;
    resolve(relative: AnyUri): Uri;
    /** @internal */
    merge(relative: UriPath): UriPath;
    unresolve(absolute: AnyUri): Uri;
    protected copy(scheme: UriScheme, authority: UriAuthority, path: UriPath, query: UriQuery, fragment: UriFragment): Uri;
    toAny(): {
        scheme?: string;
        username?: string;
        password?: string;
        host?: string;
        port?: number;
        path: string[];
        query?: {
            [key: string]: string;
        };
        fragment?: string;
    };
    compareTo(that: Uri): number;
    equals(that: unknown): boolean;
    /** @internal */
    readonly hashValue: number | undefined;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    /** @internal */
    readonly stringValue: string | undefined;
    display<T>(output: Output<T>): Output<T>;
    toString(): string;
    static empty(): Uri;
    static create(scheme?: UriScheme, authority?: UriAuthority, path?: UriPath, query?: UriQuery, fragment?: UriFragment): Uri;
    static fromInit(init: UriInit): Uri;
    static fromAny(value: AnyUri | null | undefined): Uri;
    static scheme(scheme: AnyUriScheme): Uri;
    static schemePart(schemePart: string): Uri;
    static schemeName(name: string): Uri;
    static authority(authority: AnyUriAuthority): Uri;
    static authorityPart(authorityPart: string): Uri;
    static user(user: AnyUriUser): Uri;
    static userPart(userPart: string): Uri;
    static username(username: string, password?: string): Uri;
    static password(password: string): Uri;
    static host(host: AnyUriHost): Uri;
    static hostPart(hostPart: string): Uri;
    static hostName(hostName: string): Uri;
    static hostIPv4(hostIPv4: string): Uri;
    static hostIPv6(hostIPv6: string): Uri;
    static port(port: AnyUriPort): Uri;
    static portPart(portPart: string): Uri;
    static portNumber(portNumber: number): Uri;
    static path(...components: AnyUriPath[]): Uri;
    static pathPart(pathPart: string): Uri;
    static query(query: AnyUriQuery): Uri;
    static queryPart(queryPart: string): Uri;
    static fragment(fragment: AnyUriFragment): Uri;
    static fragmentPart(fragmentPart: string): Uri;
    static fragmentIdentifier(fragmentIdentifier: string | undefined): Uri;
    static get standardParser(): UriParser;
    static parse(string: string): Uri;
    static pathBuilder(): UriPathBuilder;
    static queryBuilder(): UriQueryBuilder;
    static form(): Form<Uri, AnyUri>;
    /** @internal */
    static isUnreservedChar(c: number): boolean;
    /** @internal */
    static isSubDelimChar(c: number): boolean;
    /** @internal */
    static isSchemeChar(c: number): boolean;
    /** @internal */
    static isUserInfoChar(c: number): boolean;
    /** @internal */
    static isUserChar(c: number): boolean;
    /** @internal */
    static isHostChar(c: number): boolean;
    /** @internal */
    static isPathChar(c: number): boolean;
    /** @internal */
    static isQueryChar(c: number): boolean;
    /** @internal */
    static isParamChar(c: number): boolean;
    /** @internal */
    static isFragmentChar(c: number): boolean;
    /** @internal */
    static isAlpha(c: number): boolean;
    /** @internal */
    static toLowerCase(c: number): number;
    /** @internal */
    static writeScheme<T>(output: Output<T>, scheme: string): Output<T>;
    /** @internal */
    static writeUserInfo<T>(output: Output<T>, userInfo: string): Output<T>;
    /** @internal */
    static writeUser<T>(output: Output<T>, user: string): Output<T>;
    /** @internal */
    static writeHost<T>(output: Output<T>, address: string): Output<T>;
    /** @internal */
    static writeHostLiteral<T>(output: Output<T>, address: string): Output<T>;
    /** @internal */
    static writePathSegment<T>(output: Output<T>, segment: string): Output<T>;
    /** @internal */
    static writeQuery<T>(output: Output<T>, query: string): Output<T>;
    /** @internal */
    static writeParam<T>(output: Output<T>, param: string): Output<T>;
    /** @internal */
    static writeFragment<T>(output: Output<T>, fragment: string): Output<T>;
    /** @internal */
    static writeEncoded<T>(output: Output<T>, c: number): Output<T>;
    /** @internal */
    static writePctEncoded<T>(output: Output<T>, c: number): Output<T>;
}

/** @internal */
export declare class UriAbsoluteParser extends Parser<Uri> {
    private readonly uri;
    private readonly schemeParser;
    private readonly authorityParser;
    private readonly pathParser;
    private readonly queryParser;
    private readonly fragmentParser;
    private readonly step;
    constructor(uri: UriParser, schemeParser?: Parser<UriScheme>, authorityParser?: Parser<UriAuthority>, pathParser?: Parser<UriPath>, queryParser?: Parser<UriQuery>, fragmentParser?: Parser<UriFragment>, step?: number);
    feed(input: Input): Parser<Uri>;
    static parse(input: Input, uri: UriParser, schemeParser?: Parser<UriScheme>, authorityParser?: Parser<UriAuthority>, pathParser?: Parser<UriPath>, queryParser?: Parser<UriQuery>, fragmentParser?: Parser<UriFragment>, step?: number): Parser<Uri>;
}

/** @public */
export declare class UriAuthority implements HashCode, Compare, Debug, Display {
    /** @internal */
    constructor(user: UriUser, host: UriHost, port: UriPort);
    isDefined(): boolean;
    readonly user: UriUser;
    withUser(user: AnyUriUser): UriAuthority;
    get userPart(): string;
    withUserPart(userPart: string): UriAuthority;
    get username(): string | undefined;
    withUsername(username: string | undefined, password?: string): UriAuthority;
    get password(): string | undefined;
    withPassword(password: string | undefined): UriAuthority;
    readonly host: UriHost;
    withHost(host: AnyUriHost): UriAuthority;
    get hostPart(): string;
    withHostPart(hostPart: string): UriAuthority;
    get hostAddress(): string;
    get hostName(): string | undefined;
    withHostName(hostName: string): UriAuthority;
    get hostIPv4(): string | undefined;
    withHostIPv4(hostIPv4: string): UriAuthority;
    get hostIPv6(): string | undefined;
    withHostIPv6(hostIPv5: string): UriAuthority;
    readonly port: UriPort;
    withPort(port: AnyUriPort): UriAuthority;
    get portPart(): string;
    withPortPart(portPart: string): UriAuthority;
    get portNumber(): number;
    withPortNumber(portNumber: number): UriAuthority;
    protected copy(user: UriUser, host: UriHost, port: UriPort): UriAuthority;
    toAny(authority?: {
        username?: string;
        password?: string;
        host?: string;
        port?: number;
    }): {
        username?: string;
        password?: string;
        host?: string;
        port?: number;
    } | undefined;
    compareTo(that: unknown): number;
    equals(that: unknown): boolean;
    /** @internal */
    readonly hashValue: number | undefined;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    /** @internal */
    readonly stringValue: string | undefined;
    toString(): string;
    static undefined(): UriAuthority;
    static create(user?: UriUser, host?: UriHost, port?: UriPort): UriAuthority;
    static fromInit(init: UriAuthorityInit): UriAuthority;
    static fromAny(value: AnyUriAuthority | null | undefined): UriAuthority;
    static user(user: AnyUriUser): UriAuthority;
    static userPart(userPart: string): UriAuthority;
    static username(username: string, password?: string | undefined): UriAuthority;
    static password(password: string): UriAuthority;
    static host(host: AnyUriHost): UriAuthority;
    static hostPart(hostPart: string): UriAuthority;
    static hostName(hostName: string): UriAuthority;
    static hostIPv4(hostIPv4: string): UriAuthority;
    static hostIPv6(hostIPv6: string): UriAuthority;
    static port(port: AnyUriPort): UriAuthority;
    static portPart(portPart: string): UriAuthority;
    static portNumber(portNumber: number): UriAuthority;
    static parse(authorityPart: string): UriAuthority;
}

/** @public */
export declare interface UriAuthorityInit extends UriUserInit {
    /** @internal */
    hashValue?: never;
    user?: AnyUriUser;
    host?: AnyUriHost;
    port?: AnyUriPort;
}

/** @internal */
export declare class UriAuthorityParser extends Parser<UriAuthority> {
    private readonly uri;
    private readonly userParser;
    private readonly hostParser;
    private readonly portParser;
    private readonly step;
    constructor(uri: UriParser, userParser?: Parser<UriUser>, hostParser?: Parser<UriHost>, portParser?: Parser<UriPort>, step?: number);
    feed(input: Input): Parser<UriAuthority>;
    static parse(input: Input, uri: UriParser, userParser?: Parser<UriUser>, hostParser?: Parser<UriHost>, portParser?: Parser<UriPort>, step?: number): Parser<UriAuthority>;
}

/** @public */
export declare class UriCache {
    constructor(base: Uri, size?: number);
    readonly base: Uri;
    /** @internal */
    readonly resolveCache: HashGenCacheMap<Uri, Uri>;
    /** @internal */
    readonly unresolveCache: HashGenCacheMap<Uri, Uri>;
    resolve(relative: AnyUri): Uri;
    unresolve(absolute: AnyUri): Uri;
}

/** @public */
export declare class UriException extends Error {
    constructor(message?: Diagnostic | string);
    readonly diagnostic: Diagnostic | null;
    toString(): string;
}

/** @internal */
export declare class UriForm extends Form<Uri, AnyUri> {
    constructor(unit: Uri | undefined);
    readonly unit: Uri | undefined;
    withUnit(unit: Uri | undefined): Form<Uri, AnyUri>;
    mold(object: AnyUri, item?: Item): Item;
    cast(item: Item, object?: Uri): Uri | undefined;
}

/** @public */
export declare class UriFragment implements HashCode, Compare, Debug, Display {
    /** @internal */
    constructor(identifier: string | undefined);
    isDefined(): boolean;
    readonly identifier: string | undefined;
    toAny(): string | undefined;
    compareTo(that: UriFragment): number;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    /** @internal */
    readonly stringValue: string | undefined;
    toString(): string;
    static undefined(): UriFragment;
    static create(identifier: string | undefined): UriFragment;
    static fromAny(value: AnyUriFragment | null | undefined): UriFragment;
    static parse(fragmentPart: string): UriFragment;
    /** @internal */
    static get cache(): HashGenCacheMap<string, UriFragment>;
}

/** @internal */
export declare class UriFragmentParser extends Parser<UriFragment> {
    private readonly uri;
    private readonly output;
    private readonly c1;
    private readonly step;
    constructor(uri: UriParser, output?: Output<string>, c1?: number, step?: number);
    feed(input: Input): Parser<UriFragment>;
    static parse(input: Input, uri: UriParser, output?: Output<string>, c1?: number, step?: number): Parser<UriFragment>;
}

/** @public */
export declare abstract class UriHost implements HashCode, Compare, Debug, Display {
    protected constructor();
    isDefined(): boolean;
    abstract readonly address: string;
    get name(): string | undefined;
    get ipv4(): string | undefined;
    get ipv6(): string | undefined;
    toAny(): string;
    compareTo(that: unknown): number;
    equals(that: unknown): boolean;
    hashCode(): number;
    abstract debug<T>(output: Output<T>): Output<T>;
    abstract display<T>(output: Output<T>): Output<T>;
    abstract toString(): string;
    static undefined(): UriHost;
    static hostname(name: string): UriHost;
    static ipv4(ipv4: string): UriHost;
    static ipv6(ipv6: string): UriHost;
    static fromAny(value: AnyUriHost | null | undefined): UriHost;
    static parse(hostPart: string): UriHost;
    /** @internal */
    static get cache(): HashGenCacheMap<string, UriHost>;
}

/** @internal */
export declare class UriHostAddressParser extends Parser<UriHost> {
    private readonly uri;
    private readonly output;
    private readonly c1;
    private readonly x;
    private readonly step;
    constructor(uri: UriParser, output?: Output<string>, c1?: number, x?: number, step?: number);
    feed(input: Input): Parser<UriHost>;
    static parse(input: Input, uri: UriParser, output?: Output<string>, c1?: number, x?: number, step?: number): Parser<UriHost>;
}

/** @internal */
export declare class UriHostIPv4 extends UriHost {
    /** @internal */
    constructor(address: string);
    readonly address: string;
    get ipv4(): string;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    toString(): string;
}

/** @internal */
export declare class UriHostIPv6 extends UriHost {
    /** @internal */
    constructor(address: string);
    readonly address: string;
    get ipv6(): string;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    toString(): string;
}

/** @internal */
export declare class UriHostLiteralParser extends Parser<UriHost> {
    private readonly uri;
    private readonly output;
    private readonly step;
    constructor(uri: UriParser, output?: Output<string>, step?: number);
    feed(input: Input): Parser<UriHost>;
    static parse(input: Input, uri: UriParser, output?: Output<string>, step?: number): Parser<UriHost>;
}

/** @internal */
export declare class UriHostName extends UriHost {
    /** @internal */
    constructor(address: string);
    readonly address: string;
    get name(): string;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    toString(): string;
}

/** @internal */
export declare class UriHostParser extends Parser<UriHost> {
    private readonly uri;
    constructor(uri: UriParser);
    feed(input: Input): Parser<UriHost>;
    static parse(input: Input, uri: UriParser): Parser<UriHost>;
}

/** @internal */
export declare class UriHostUndefined extends UriHost {
    /** @internal */
    constructor();
    isDefined(): boolean;
    get address(): string;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    toString(): string;
}

/** @public */
export declare interface UriInit extends UriAuthorityInit {
    scheme?: AnyUriScheme;
    authority?: AnyUriAuthority;
    path?: AnyUriPath;
    query?: AnyUriQuery;
    fragment?: AnyUriFragment;
}

/** @public */
export declare class UriParser {
    absolute(scheme?: UriScheme, authority?: UriAuthority, path?: UriPath, query?: UriQuery, fragment?: UriFragment): Uri;
    scheme(name: string): UriScheme;
    authority(user?: UriUser, host?: UriHost, port?: UriPort): UriAuthority;
    user(username: string | undefined, password?: string | undefined): UriUser;
    hostName(address: string): UriHost;
    hostIPv4(address: string): UriHost;
    hostIPv6(address: string): UriHost;
    port(number: number): UriPort;
    pathEmpty(): UriPath;
    pathBuilder(): UriPathBuilder;
    queryBuilder(): UriQueryBuilder;
    fragment(identifier: string | undefined): UriFragment;
    absoluteParser(): Parser<Uri>;
    parseAbsolute(input: Input): Parser<Uri>;
    parseAbsoluteString(string: string): Uri;
    schemeParser(): Parser<UriScheme>;
    parseScheme(input: Input): Parser<UriScheme>;
    parseSchemeString(string: string): UriScheme;
    authorityParser(): Parser<UriAuthority>;
    parseAuthority(input: Input): Parser<UriAuthority>;
    parseAuthorityString(string: string): UriAuthority;
    userParser(): Parser<UriUser>;
    parseUser(input: Input): Parser<UriUser>;
    parseUserString(string: string): UriUser;
    hostParser(): Parser<UriHost>;
    parseHost(input: Input): Parser<UriHost>;
    parseHostString(string: string): UriHost;
    hostAddressParser(): Parser<UriHost>;
    parseHostAddress(input: Input): Parser<UriHost>;
    hostLiteralParser(): Parser<UriHost>;
    parseHostLiteral(input: Input): Parser<UriHost>;
    portParser(): Parser<UriPort>;
    parsePort(input: Input): Parser<UriPort>;
    parsePortString(string: string): UriPort;
    pathParser(builder?: UriPathBuilder): Parser<UriPath>;
    parsePath(input: Input, builder?: UriPathBuilder): Parser<UriPath>;
    parsePathString(string: string): UriPath;
    queryParser(builder?: UriQueryBuilder): Parser<UriQuery>;
    parseQuery(input: Input, builder?: UriQueryBuilder): Parser<UriQuery>;
    parseQueryString(string: string): UriQuery;
    fragmentParser(): Parser<UriFragment>;
    parseFragment(input: Input): Parser<UriFragment>;
    parseFragmentString(string: string): UriFragment;
}

/** @public */
export declare abstract class UriPath implements HashCode, Compare, Debug, Display {
    /** @internal */
    protected constructor();
    abstract isDefined(): boolean;
    abstract isAbsolute(): boolean;
    abstract isRelative(): boolean;
    abstract isEmpty(): boolean;
    get length(): number;
    get(index: number): string | undefined;
    abstract head(): string;
    abstract tail(): UriPath;
    /** @internal */
    abstract setTail(tail: UriPath): void;
    /** @internal */
    abstract dealias(): UriPath;
    abstract parent(): UriPath;
    abstract base(): UriPath;
    get name(): string;
    withName(name: string): UriPath;
    foot(): UriPath;
    isSubpathOf(b: AnyUriPath): boolean;
    appended(...components: AnyUriPath[]): UriPath;
    appendedSlash(): UriPath;
    appendedSegment(segment: string): UriPath;
    prepended(...components: AnyUriPath[]): UriPath;
    prependedSlash(): UriPath;
    prependedSegment(segment: string): UriPath;
    resolve(that: UriPath): UriPath;
    removeDotSegments(): UriPath;
    merge(that: UriPath): UriPath;
    unmerge(relative: UriPath, root?: UriPath): UriPath;
    toAny(): string[];
    compareTo(that: unknown): number;
    equals(that: unknown): boolean;
    hashCode(): number;
    abstract debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    abstract toString(): string;
    static empty(): UriPath;
    static slash(): UriPath;
    static segment(segment: string, tail?: UriPath): UriPath;
    static of(...components: AnyUriPath[]): UriPath;
    static fromAny(value: AnyUriPath | null | undefined): UriPath;
    static parse(pathPart: string): UriPath;
    static builder(): UriPathBuilder;
    static pathForm(): Form<UriPath, AnyUriPath>;
    /** @internal */
    static get segmentCache(): HashGenCacheSet<string>;
    /** @internal */
    static cacheSegment(segment: string): string;
}

/** @public */
export declare class UriPathBuilder implements Builder<string, UriPath> {
    /** @internal */
    first: UriPath;
    /** @internal */
    last: UriPath | null;
    /** @internal */
    size: number;
    /** @internal */
    aliased: number;
    constructor();
    isEmpty(): boolean;
    push(...components: AnyUriPath[]): void;
    bind(): UriPath;
    addSlash(): void;
    addSegment(segment: string): void;
    addPath(path: UriPath): void;
    pop(): UriPath;
    /** @internal */
    dealias(n: number): UriPath;
}

/** @internal */
export declare class UriPathEmpty extends UriPath {
    /** @internal */
    constructor();
    isDefined(): boolean;
    isAbsolute(): boolean;
    isRelative(): boolean;
    isEmpty(): boolean;
    head(): string;
    tail(): UriPath;
    /** @internal */
    setTail(tail: UriPath): void;
    /** @internal */
    dealias(): UriPath;
    parent(): UriPath;
    base(): UriPath;
    appended(...components: AnyUriPath[]): UriPath;
    appendedSlash(): UriPath;
    appendedSegment(segment: string): UriPath;
    prepended(...components: AnyUriPath[]): UriPath;
    prependedSlash(): UriPath;
    prependedSegment(segment: string): UriPath;
    merge(that: UriPath): UriPath;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    toString(): string;
}

/** @internal */
export declare class UriPathForm extends Form<UriPath, AnyUriPath> {
    constructor(unit: UriPath | undefined);
    readonly unit: UriPath | undefined;
    withUnit(unit: UriPath | undefined): Form<UriPath, AnyUriPath>;
    mold(object: AnyUriPath, item?: Item): Item;
    cast(item: Item, object?: UriPath): UriPath | undefined;
}

/** @internal */
export declare class UriPathParser extends Parser<UriPath> {
    private readonly uri;
    private readonly builder;
    private readonly output;
    private readonly c1;
    private readonly step;
    constructor(uri: UriParser, builder?: UriPathBuilder, output?: Output<string>, c1?: number, step?: number);
    feed(input: Input): Parser<UriPath>;
    static parse(input: Input, uri: UriParser, builder?: UriPathBuilder, output?: Output<string>, c1?: number, step?: number): Parser<UriPath>;
}

/** @internal */
export declare class UriPathSegment extends UriPath {
    /** @internal */
    constructor(head: string, tail: UriPath);
    /** @internal */
    readonly segment: string;
    /** @internal */
    readonly rest: UriPath;
    isDefined(): boolean;
    isAbsolute(): boolean;
    isRelative(): boolean;
    isEmpty(): boolean;
    head(): string;
    tail(): UriPath;
    /** @internal */
    setTail(tail: UriPath): void;
    /** @internal */
    dealias(): UriPath;
    parent(): UriPath;
    base(): UriPath;
    prependedSegment(segment: string): UriPath;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    /** @internal */
    readonly stringValue: string | undefined;
    toString(): string;
}

/** @internal */
export declare class UriPathSlash extends UriPath {
    /** @internal */
    constructor(tail: UriPath);
    /** @internal */
    readonly rest: UriPath;
    isDefined(): boolean;
    isAbsolute(): boolean;
    isRelative(): boolean;
    isEmpty(): boolean;
    head(): string;
    tail(): UriPath;
    /** @internal */
    setTail(tail: UriPath): void;
    /** @internal */
    dealias(): UriPath;
    parent(): UriPath;
    base(): UriPath;
    prependedSegment(segment: string): UriPath;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    /** @internal */
    readonly stringValue: string | undefined;
    toString(): string;
}

/** @public */
export declare class UriPort implements HashCode, Compare, Debug, Display {
    /** @internal */
    constructor(portNumber: number);
    isDefined(): boolean;
    readonly number: number;
    valueOf(): number;
    toAny(): number;
    compareTo(that: unknown): number;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    toString(): string;
    static undefined(): UriPort;
    static create(number: number): UriPort;
    static fromAny(value: AnyUriPort | null | undefined): UriPort;
    static parse(portPart: string): UriPort;
    /** @internal */
    static get cache(): HashGenCacheMap<number, UriPort>;
}

/** @internal */
export declare class UriPortParser extends Parser<UriPort> {
    private readonly uri;
    private readonly number;
    constructor(uri: UriParser, number?: number);
    feed(input: Input): Parser<UriPort>;
    static parse(input: Input, uri: UriParser, number?: number): Parser<UriPort>;
}

/** @public */
export declare abstract class UriQuery implements HashCode, Compare, Debug, Display {
    abstract isDefined(): boolean;
    abstract isEmpty(): boolean;
    get length(): number;
    abstract head(): [string | undefined, string];
    abstract readonly key: string | undefined;
    abstract readonly value: string;
    abstract tail(): UriQuery;
    /** @internal */
    abstract setTail(tail: UriQuery): void;
    /** @internal */
    abstract dealias(): UriQuery;
    has(key: string): boolean;
    get(key: string): string | undefined;
    updated(key: string, value: string): UriQuery;
    removed(key: string): UriQuery;
    appended(key: string | undefined, value: string): UriQuery;
    appended(params: AnyUriQuery): UriQuery;
    prepended(key: string | undefined, value: string): UriQuery;
    prepended(params: AnyUriQuery): UriQuery;
    toAny(params?: {
        [key: string]: string;
    }): {
        [key: string]: string;
    } | undefined;
    compareTo(that: UriQuery): number;
    equals(that: unknown): boolean;
    hashCode(): number;
    abstract debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    abstract toString(): string;
    static undefined(): UriQuery;
    static param(value: string, tail?: UriQuery): UriQuery;
    static param(key: string | undefined, value: string, tail?: UriQuery): UriQuery;
    static fromAny(value: AnyUriQuery | null | undefined): UriQuery;
    static parse(queryPart: string): UriQuery;
    static builder(): UriQueryBuilder;
    /** @internal */
    static get keyCache(): HashGenCacheSet<string>;
    /** @internal */
    static cacheKey(key: string): string;
}

/** @public */
export declare class UriQueryBuilder implements PairBuilder<string | undefined, string, UriQuery> {
    /** @internal */
    first: UriQuery;
    /** @internal */
    last: UriQuery | null;
    /** @internal */
    size: number;
    /** @internal */
    aliased: number;
    constructor();
    isEmpty(): boolean;
    add(key: string | undefined, value: string): void;
    add(params: AnyUriQuery): void;
    bind(): UriQuery;
    addParam(value: string): void;
    addParam(key: string | undefined, value: string): void;
    addQuery(query: UriQuery): void;
    /** @internal */
    dealias(n: number): UriQuery;
}

/** @internal */
export declare class UriQueryParam extends UriQuery {
    constructor(key: string | undefined, value: string, tail: UriQuery);
    readonly key: string | undefined;
    readonly value: string;
    /** @internal */
    readonly rest: UriQuery;
    isDefined(): boolean;
    isEmpty(): boolean;
    head(): [string | undefined, string];
    tail(): UriQuery;
    /** @internal */
    setTail(tail: UriQuery): void;
    /** @internal */
    dealias(): UriQuery;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    /** @internal */
    readonly stringValue: string | undefined;
    toString(): string;
}

/** @internal */
export declare class UriQueryParser extends Parser<UriQuery> {
    private readonly uri;
    private readonly builder;
    private readonly keyOutput;
    private readonly valueOutput;
    private readonly c1;
    private readonly step;
    constructor(uri: UriParser, builder?: UriQueryBuilder, keyOutput?: Output<string>, valueOutput?: Output<string>, c1?: number, step?: number);
    feed(input: Input): Parser<UriQuery>;
    static parse(input: Input, uri: UriParser, builder?: UriQueryBuilder, keyOutput?: Output<string>, valueOutput?: Output<string>, c1?: number, step?: number): Parser<UriQuery>;
}

/** @internal */
export declare class UriQueryUndefined extends UriQuery {
    isDefined(): boolean;
    isEmpty(): boolean;
    head(): [string | undefined, string];
    get key(): string | undefined;
    get value(): string;
    tail(): UriQuery;
    /** @internal */
    setTail(tail: UriQuery): void;
    /** @internal */
    dealias(): UriQuery;
    updated(key: string, value: string): UriQuery;
    removed(key: string): UriQuery;
    appended(key: string | undefined, value: string): UriQuery;
    appended(params: AnyUriQuery): UriQuery;
    prepended(key: string | undefined, value: string): UriQuery;
    prepended(params: AnyUriQuery): UriQuery;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    toString(): string;
}

/** @public */
export declare class UriScheme implements HashCode, Compare, Debug, Display {
    /** @internal */
    constructor(name: string);
    isDefined(): boolean;
    readonly name: string;
    toAny(): string | undefined;
    compareTo(that: unknown): number;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    toString(): string;
    static undefined(): UriScheme;
    static create(schemeName: string): UriScheme;
    static fromAny(value: AnyUriScheme | null | undefined): UriScheme;
    static parse(schemePart: string): UriScheme;
    /** @internal */
    static get cache(): HashGenCacheMap<string, UriScheme>;
}

/** @internal */
export declare class UriSchemeParser extends Parser<UriScheme> {
    private readonly uri;
    private readonly output;
    private readonly step;
    constructor(uri: UriParser, output?: Output<string>, step?: number);
    feed(input: Input): Parser<UriScheme>;
    static parse(input: Input, uri: UriParser, output?: Output<string>, step?: number): Parser<UriScheme>;
}

/** @public */
export declare class UriUser implements HashCode, Debug, Display {
    /** @internal */
    constructor(username: string | undefined, password: string | undefined);
    isDefined(): boolean;
    readonly username: string | undefined;
    withUsername(username: string | undefined): UriUser;
    readonly password: string | undefined;
    withPassword(password: string | undefined): UriUser;
    protected copy(username: string | undefined, password: string | undefined): UriUser;
    toAny(user?: {
        username?: string;
        password?: string;
    }): {
        username?: string;
        password?: string;
    } | undefined;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    display<T>(output: Output<T>): Output<T>;
    toString(): string;
    static undefined(): UriUser;
    static create(username: string | undefined, password?: string | undefined): UriUser;
    static fromInit(init: UriUserInit): UriUser;
    static fromAny(value: AnyUriUser | null | undefined): UriUser;
    static parse(userPart: string): UriUser;
}

/** @public */
export declare interface UriUserInit {
    username?: string;
    password?: string;
}

/** @internal */
export declare class UriUserParser extends Parser<UriUser> {
    private readonly uri;
    private readonly usernameOutput;
    private readonly passwordOutput;
    private readonly c1;
    private readonly step;
    constructor(uri: UriParser, usernameOutput?: Output<string>, passwordOutput?: Output<string>, c1?: number, step?: number);
    feed(input: Input): Parser<UriUser>;
    static parse(input: Input, uri: UriParser, usernameOutput?: Output<string>, passwordOutput?: Output<string>, c1?: number, step?: number): Parser<UriUser>;
}

/**
 * UTF-8 [[Input]]/[[Output]] factory.
 * @public
 */
export declare const Utf8: {
    /**
     * Returns the number of bytes in the UTF-8 encoding of the Unicode code
     * point `c`, handling invalid code unit sequences according to the
     * `errorMode` policy. Returns the size of the
     * [[UtfErrorMode.replacementChar]] for surrogates and invalid code points,
     * if [[UtfErrorMode.isReplacement]] is `true`; otherwise returns `0` for
     * surrogates and invalid code points. Uses the two byte modified UTF-8
     * encoding of the NUL character (`U+0000`), if [[UtfErrorMode.isNonZero]]
     * is `true`.
     */
    sizeOf(c: number | undefined, errorMode?: UtfErrorMode | undefined): number;
    /**
     * Returns the number of bytes in the UTF-8 encoding of the Unicode code
     * point `c`, handling invalid code unit sequences according to the
     * `errorMode` policy. Returns the size of the
     * [[UtfErrorMode.replacementChar]] for surrogates and invalid code points,
     * if [[UtfErrorMode.isReplacement]] is `true`; otherwise returns `0` for
     * surrogates and invalid code points. Uses the two byte modified UTF-8
     * encoding of the NUL character (`U+0000`), if [[UtfErrorMode.isNonZero]]
     * is `true`.
     */
    sizeOf(c: number | undefined): number;
    /**
     * Returns the number of bytes in the UTF-8 encoding of the Unicode code
     * point `c`, handling invalid code unit sequences according to the
     * `errorMode` policy. Returns the size of the
     * [[UtfErrorMode.replacementChar]] for surrogates and invalid code points,
     * if [[UtfErrorMode.isReplacement]] is `true`; otherwise returns `0` for
     * surrogates and invalid code points. Uses the two byte modified UTF-8
     * encoding of the NUL character (`U+0000`), if [[UtfErrorMode.isNonZero]]
     * is `true`.
     */
    sizeOf(string: string, errorMode?: UtfErrorMode | undefined): number;
    /**
     * Returns the number of bytes in the UTF-8 encoding of the Unicode code
     * point `c`, handling invalid code unit sequences according to the
     * `errorMode` policy. Returns the size of the
     * [[UtfErrorMode.replacementChar]] for surrogates and invalid code points,
     * if [[UtfErrorMode.isReplacement]] is `true`; otherwise returns `0` for
     * surrogates and invalid code points. Uses the two byte modified UTF-8
     * encoding of the NUL character (`U+0000`), if [[UtfErrorMode.isNonZero]]
     * is `true`.
     */
    sizeOf(string: string): number;
    /**
     * Returns a new `Output` that accepts UTF-8 code unit sequences, and writes
     * writes decoded Unicode code points to the composed `output`, handling
     * invalid code unit sequences according to the `errorMode` policy.
     */
    decodedOutput<T>(output: Output<T>, errorMode?: UtfErrorMode | undefined): Output<T>;
    /**
     * Returns a new `Output` that accepts Unicode code points, and writes
     * encoded UTF-8 code unit sequences to the composed `output`, handling
     * invalid code unit sequences according to the `errorMode` policy.
     */
    encodedOutput<T_1>(output: Output<T_1>, errorMode?: UtfErrorMode | undefined): Output<T_1>;
    /**
     * Returns a new `Output` that accepts UTF-8 code unit sequences, and writes
     * decoded Unicode code points to a growable `string`, handling invalid code
     * unit sequences according to the [[UtfErrorMode.fatal]] policy. The
     * returned `Output` accepts an unbounded number of UTF-8 code units,
     * remaining permanently in the _cont_ state, and [[Output.bind binds]] a
     * `string` containing all decoded code points.
     */
    decodedString(): Output<string>;
};

/** @internal */
export declare class Utf8DecodedOutput<T> extends Output<T> {
    /** @internal */
    readonly output: Output<T>;
    /** @internal */
    readonly errorMode: UtfErrorMode;
    /** @internal */
    c1: number;
    /** @internal */
    c2: number;
    /** @internal */
    c3: number;
    /** @internal */
    have: number;
    constructor(output: Output<T>, errorMode: UtfErrorMode, c1: number, c2: number, c3: number, have: number);
    isCont(): boolean;
    isFull(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): Output<T>;
    write(token: number | string): Output<T>;
    private static invalid;
    get settings(): OutputSettings;
    withSettings(settings: AnyOutputSettings): Output<T>;
    bind(): T;
    trap(): Error;
    clone(): Output<T>;
    static create<T>(output: Output<T>, errorMode?: UtfErrorMode): Output<T>;
}

/** @internal */
export declare class Utf8EncodedOutput<T> extends Output<T> {
    /** @internal */
    readonly output: Output<T>;
    /** @internal */
    readonly errorMode: UtfErrorMode;
    /** @internal */
    c2: number;
    /** @internal */
    c3: number;
    /** @internal */
    c4: number;
    /** @internal */
    index: number;
    constructor(output: Output<T>, errorMode: UtfErrorMode, c2: number, c3: number, c4: number, index: number);
    isCont(): boolean;
    isFull(): boolean;
    isDone(): boolean;
    isError(): boolean;
    isPart(): boolean;
    asPart(part: boolean): Output<T>;
    write(token: number | string): Output<T>;
    flush(): Output<T>;
    get settings(): OutputSettings;
    withSettings(settings: AnyOutputSettings): Output<T>;
    bind(): T;
    clone(): Output<T>;
    static create<T>(output: Output<T>, errorMode?: UtfErrorMode): Output<T>;
}

/**
 * Unicode transformation format error handling mode.
 * @public
 */
export declare abstract class UtfErrorMode implements HashCode, Debug {
    /**
     * Returns `true` if a Unicode decoding should abort with an error when an
     * invalid code unit sequence is encountered.
     */
    isFatal(): boolean;
    /**
     * Returns `true` if a Unicode decoding should substitute invalid code unit
     * sequences with a replacement character.
     */
    isReplacement(): boolean;
    /**
     * The Unicode code point of the replacement character used to substitute
     * for invalid code unit sequences.
     */
    abstract readonly replacementChar: number;
    /**
     * Returns `true` if Unicode decoding should abort with an error when a
     * `NUL` byte is encountered.
     */
    abstract isNonZero(): boolean;
    /**
     * Returns a `UtfErrorMode` that, if `isNonZero` is `true`, aborts when
     * Unicode decoding encounters a `NUL` byte.
     */
    abstract asNonZero(isNonZero: boolean): UtfErrorMode;
    abstract equals(that: unknown): boolean;
    abstract hashCode(): number;
    abstract debug<T>(output: Output<T>): Output<T>;
    toString(): string;
    /**
     * Returns a `UtfErrorMode` that aborts Unicode decoding with an error when
     * invalid code unit sequences are encountered.
     */
    static fatal(): UtfErrorMode;
    /**
     * Returns a `UtfErrorMode` that aborts Unicode decoding with an error when
     * invalid code unit sequences, and `NUL` bytes, are encountered.
     */
    static fatalNonZero(): UtfErrorMode;
    /**
     * Returns a `UtfErrorMode` that substitutes invalid code unit sequences
     * with the replacement character (`U+FFFD`).
     */
    static replacement(): UtfErrorMode;
    /**
     * Returns a `UtfErrorMode` that substitutes invalid code unit sequences
     * with the replacement character (`U+FFFD`), and aborts decoding with an
     * error when `NUL` bytes are encountered.
     */
    static replacementNonZero(): UtfErrorMode;
}

/** @internal */
export declare class UtfErrorModeFatal extends UtfErrorMode {
    constructor(nonZero: boolean);
    isFatal(): boolean;
    get replacementChar(): number;
    /** @internal */
    readonly nonZero: boolean;
    isNonZero(): boolean;
    asNonZero(nonZero: boolean): UtfErrorMode;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
}

/** @internal */
export declare class UtfErrorModeReplacement extends UtfErrorMode {
    constructor(replacementChar: number, nonZero: boolean);
    isReplacement(): boolean;
    readonly replacementChar: number;
    /** @internal */
    readonly nonZero: boolean;
    isNonZero(): boolean;
    asNonZero(nonZero: boolean): UtfErrorMode;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
}

/** @public */
export declare abstract class Value extends Item {
    /** @internal */
    constructor();
    /**
     * Returns `true` if this `Value` is not [[Absent]].
     */
    isDefined(): boolean;
    /**
     * Returns `true` if this `Value` is neither [[Extant]] nor [[Absent]].
     */
    isDistinct(): boolean;
    /**
     * Returns `true` if this `Value` is not one of: an empty `Record`, `False`,
     * `Extant`, or `Absent`.
     */
    isDefinite(): boolean;
    /**
     * Always returns [[Absent]] because a `Value` can't be a `Field`, so it
     * can't have a key component.
     */
    get key(): Value;
    /**
     * Always returns `this` because every `Value` is its own value component.
     */
    toValue(): Value;
    /**
     * Returns the `key` string of the first member of this `Value`, if this
     * `Value` is a [[Record]], and its first member is an [[Attr]]; otherwise
     * returns `undefined` if this `Value` is not a `Record`, or if this `Value`
     * is a `Record` whose first member is not an `Attr`.
     *
     * Used to concisely get the name of the discriminating attribute of a
     * structure. The `tag` can be used to discern the nominal type of a
     * polymorphic structure, similar to an XML element tag.
     */
    get tag(): string | undefined;
    /**
     * Returns the [[Value.flattened flattened]] members of this `Value` after
     * all attributes have been removed, if this `Value` is a [[Record]];
     * otherwise returns `this` if this `Value` is not a `Record`.
     *
     * Used to concisely get the scalar value of an attributed structure. An
     * attributed structure is a `Record` with one or more attributes that modify
     * one or more other members.
     */
    get target(): Value;
    /**
     * Returns the sole member of this `Value`, if this `Value` is a [[Record]]
     * with exactly one member, and its member is a `Value`; returns [[Extant]]
     * if this `Value` is an empty `Record`; otherwise returns `this` if this
     * `Value` is a `Record` with more than one member, or if this `Value` is a
     * not a `Record`.
     *
     * Used to convert a unary `Record` into its member `Value`. Facilitates
     * writing code that treats a unary `Record` equivalently to a bare `Value`.
     */
    flattened(): Value;
    /**
     * Returns `this` if this `Value` is a [[Record]]; returns a `Record`
     * containing just this `Value`, if this `Value` is [[Value.isDistinct
     * distinct]]; otherwise returns an empty `Record` if this `Value` is
     * [[Extant]] or [[Absent]]. Facilitates writing code that treats a bare
     * `Value` equivalently to a unary `Record`.
     */
    unflattened(): Record_2;
    /**
     * Returns the value of the first member of this `Value`, if this `Value` is
     * a `Record`, and its first member is an [[Attr]] whose `key` string is
     * equal to `tag`; otherwise returns [[Absent]] if this `Value` is not a
     * `Record`, or if this `Value` is a `Record` whose first member is not an
     * `Attr`, or if this `Value` is a `Record` whose first member is an `Attr`
     * whose `key` does not equal the `tag`.
     *
     * Used to conditionally get the value of the head `Attr` of a structure, if
     * and only if the key string of the head `Attr` is equal to the `tag`. Can
     * be used to check if a structure might conform to a nominal type named
     * `tag`, while simultaneously getting the value of the `tag` attribute.
     */
    header(tag: string): Value;
    /**
     * Returns the [[Value.unflattened unflattened]] [[Value.header header]] of
     * this `Value`, if this `Value` is a [[Record]], and its first member is an
     * [[Attr]] whose `key` string is equal to `tag`; otherwise returns
     * `undefined`.
     *
     * The `headers` of the `tag` attribute of a structure are like the
     * attributes of an XML element tag; through unlike an XML element, `tag`
     * attribute headers are not limited to string keys and values.
     */
    headers(tag: string): Record_2 | undefined;
    /**
     * Returns the first member of this `Value`, if this `Value` is a non-empty
     * [[Record]]; otherwise returns [[Absent]].
     */
    head(): Item;
    /**
     * Returns a view of all but the first member of this `Value`, if this
     * `Value` is a non-empty [[Record]]; otherwise returns an empty `Record`
     * if this `Value` is not a `Record`, of if this `Value` is itself an
     * empty `Record`.
     */
    tail(): Record_2;
    /**
     * Returns the [[Record.flattened flattened]] [[Value.tail tail]] of this
     * `Value`. Used to recursively deconstruct a structure, terminating with
     * its last `Value`, rather than a unary `Record` containing its last value,
     * if the structure ends with a `Value` member.
     */
    body(): Value;
    /**
     * Returns the number of members contained in this `Value`, if this `Value`
     * is a [[Record]]; otherwise returns `0` if this `Value` is not a `Record`.
     */
    get length(): number;
    /**
     * Returns `true` if this `Value` is a [[Record]] that has a [[Field]] member
     * with a key that is equal to the given `key`; otherwise returns `false` if
     * this `Value` is not a `Record`, or if this `Value` is a `Record`, but has
     * no `Field` member with a key equal to the given `key`.
     */
    has(key: AnyValue): boolean;
    /**
     * Returns the value of the last [[Field]] member of this `Value` whose key
     * is equal to the given `key`; returns [[Absent]] if this `Value` is not a
     * [[Record]], or if this `Value` is a `Record`, but has no `Field` member
     * with a key equal to the given `key`.
     */
    get(key: AnyValue): Value;
    /**
     * Returns the value of the last [[Attr]] member of this `Value` whose key
     * is equal to the given `key`; returns [[Absent]] if this `Value` is not a
     * [[Record]], or if this `Value` is a `Record`, but has no `Attr` member
     * with a key equal to the given `key`.
     */
    getAttr(key: AnyText): Value;
    /**
     * Returns the value of the last [[Slot]] member of this `Value` whose key
     * is equal to the given `key`; returns [[Absent]] if this `Value` is not a
     * [[Record]], or if this `Value` is a `Record`, but has no `Slot` member
     * with a key equal to the given `key`.
     */
    getSlot(key: AnyValue): Value;
    /**
     * Returns the last [[Field]] member of this `Value` whose key is equal to
     * the given `key`; returns `undefined` if this `Value` is not a [[Record]],
     * or if this `Value` is a `Record`, but has no `Field` member with a `key`
     * equal to the given `key`.
     */
    getField(key: AnyValue): Field | undefined;
    /**
     * Returns the member of this `Value` at the given `index`, if this `Value`
     * is a [[Record]], and the `index` is greater than or equal to zero, and
     * less than the [[Record.length length]] of the `Record`; otherwise returns
     * [[Absent]] if this `Value` is not a `Record`, or if this `Value` is a
     * `Record`, but the `index` is out of bounds.
     */
    getItem(index: AnyNum): Item;
    deleted(key: AnyValue): Value;
    conditional(thenTerm: AnyValue, elseTerm: AnyValue): Value;
    conditional(thenTerm: AnyItem, elseTerm: AnyItem): Item;
    or(that: AnyValue): Value;
    or(that: AnyItem): Item;
    and(that: AnyValue): Value;
    and(that: AnyItem): Item;
    bitwiseOr(that: AnyValue): Value;
    bitwiseOr(that: AnyItem): Item;
    bitwiseXor(that: AnyValue): Value;
    bitwiseXor(that: AnyItem): Item;
    bitwiseAnd(that: AnyValue): Value;
    bitwiseAnd(that: AnyItem): Item;
    lt(that: AnyValue): Value;
    lt(that: AnyItem): Item;
    le(that: AnyValue): Value;
    le(that: AnyItem): Item;
    eq(that: AnyValue): Value;
    eq(that: AnyItem): Item;
    ne(that: AnyValue): Value;
    ne(that: AnyItem): Item;
    ge(that: AnyValue): Value;
    ge(that: AnyItem): Item;
    gt(that: AnyValue): Value;
    gt(that: AnyItem): Item;
    plus(that: AnyValue): Value;
    plus(that: AnyItem): Item;
    minus(that: AnyValue): Value;
    minus(that: AnyItem): Item;
    times(that: AnyValue): Value;
    times(that: AnyItem): Item;
    divide(that: AnyValue): Value;
    divide(that: AnyItem): Item;
    modulo(that: AnyValue): Value;
    modulo(that: AnyItem): Item;
    not(): Value;
    bitwiseNot(): Value;
    negative(): Value;
    positive(): Value;
    inverse(): Value;
    lambda(template: Value): Value;
    /**
     * Converts this `Value` into a `string` value, if possible; otherwise returns
     * `undefined` if this `Value` can't be converted into a `string` value.
     */
    stringValue(): string | undefined;
    /**
     * Converts this `Value` into a `string` value, if possible; otherwise returns
     * `orElse` if this `Value` can't be converted into a `string` value.
     */
    stringValue<T>(orElse: T): string | T;
    /**
     * Converts this `Value` into a `number` value, if possible; otherwise returns
     * `undefined` if this `Value` can't be converted into a `number` value.
     */
    numberValue(): number | undefined;
    /**
     * Converts this `Value` into a `number` value, if possible; otherwise returns
     * `orElse` if this `Value` can't be converted into a `number` value.
     */
    numberValue<T>(orElse: T): number | T;
    /**
     * Converts this `Value` into a `boolean` value, if possible; otherwise
     * returns `undefined` if this `Value` can't be converted into a `boolean`
     * value.
     */
    booleanValue(): boolean | undefined;
    /**
     * Converts this `Value` into a `boolean` value, if possible; otherwise
     * returns `orElse` if this `Value` can't be converted into a `boolean` value.
     */
    booleanValue<T>(orElse: T): boolean | T;
    abstract toAny(): AnyValue;
    isAliased(): boolean;
    isMutable(): boolean;
    alias(): void;
    branch(): Value;
    clone(): Value;
    commit(): this;
    interpolateTo(that: Value): Interpolator<Value>;
    interpolateTo(that: Item): Interpolator<Item>;
    interpolateTo(that: unknown): Interpolator<Item> | null;
    keyEquals(key: unknown): boolean;
    static builder(): Builder<Item, Value>;
    static empty(): Value;
    static extant(): Value;
    static absent(): Value;
    static fromAny(value: AnyValue): Value;
}

/** @internal */
export declare class ValueBuilder implements Builder<Item, Value> {
    /** @internal */
    record: Record_2 | null;
    /** @internal */
    value: Value | null;
    constructor();
    push(...items: Item[]): void;
    /** @internal */
    pushField(item: Field): void;
    /** @internal */
    pushValue(item: Value): void;
    bind(): Value;
}

/** @internal */
export declare class ValueCursor<V> extends Cursor<V> {
    constructor(cursor: Cursor<Value>, form: Form<V, unknown>);
    /** @internal */
    readonly cursor: Cursor<Value>;
    /** @internal */
    readonly form: Form<V, unknown>;
    isEmpty(): boolean;
    head(): V;
    step(): void;
    skip(count: number): void;
    hasNext(): boolean;
    nextIndex(): number;
    next(): {
        value?: V;
        done: boolean;
    };
    hasPrevious(): boolean;
    previousIndex(): number;
    previous(): {
        value?: V;
        done: boolean;
    };
    delete(): void;
}

/** @public */
export declare class ValueDownlink<V, VU = never> extends Downlink implements Inlet<V>, Outlet<V> {
    /** @internal */
    constructor(context: DownlinkContext, owner: DownlinkOwner | null, init?: ValueDownlinkInit<V, VU>, hostUri?: Uri, nodeUri?: Uri, laneUri?: Uri, prio?: number, rate?: number, body?: Value, flags?: number, observers?: ReadonlyArray<ValueDownlinkObserver<V, VU>> | ValueDownlinkObserver<V, VU>, valueForm?: Form<V, VU>, state0?: Value);
    /** @internal */
    readonly model: ValueDownlinkModel | null;
    /** @internal */
    observers: ReadonlyArray<ValueDownlinkObserver<V, VU>>;
    /** @internal */
    readonly ownValueForm: Form<V, VU>;
    /** @internal */
    readonly state0: Value;
    get type(): DownlinkType;
    /** @internal */
    protected copy<V, VU>(context: DownlinkContext, owner: DownlinkOwner | null, hostUri: Uri, nodeUri: Uri, laneUri: Uri, prio: number, rate: number, body: Value, flags: number, observers: ReadonlyArray<ValueDownlinkObserver<V, VU>>, valueForm?: Form<V, VU>, state0?: Value): ValueDownlink<V, VU>;
    valueForm(): Form<V, VU>;
    valueForm<V2, V2U = never>(valueForm: Form<V2, V2U>): ValueDownlink<V2, V2U>;
    get(): V;
    set(newObject: V | VU): void;
    setState(state: Value): void;
    observe(observer: ValueDownlinkObserver<V, VU>): this;
    willSet(willSet: ValueDownlinkWillSet<V, VU>): this;
    didSet(didSet: VaueDownlinkDidSet<V, VU>): this;
    /** @internal */
    valueWillSet(newValue: Value): Value;
    /** @internal */
    valueDidSet(newValue: Value, oldValue: Value): void;
    initialState(): Value;
    initialState(state0: Value): ValueDownlink<V, VU>;
    /** @internal */
    protected didAliasModel(): void;
    open(): this;
    readonly input: Outlet<V> | null;
    /** @internal */
    readonly outputs: ReadonlyArray<Inlet<V>>;
    /** @internal */
    readonly version: number;
    bindInput(newInput: Outlet<V> | null): void;
    unbindInput(): void;
    disconnectInputs(): void;
    outputIterator(): Cursor<Inlet<V>>;
    bindOutput(output: Inlet<V>): void;
    unbindOutput(output: Inlet<V>): void;
    unbindOutputs(): void;
    disconnectOutputs(): void;
    decohereOutput(): void;
    decohereInput(): void;
    decohere(): void;
    recohereOutput(version: number): void;
    recohereInput(version: number): void;
    recohere(version: number): void;
    protected willDecohere(): void;
    protected onDecohere(): void;
    protected didDecohere(): void;
    protected willRecohere(version: number): void;
    protected onRecohere(version: number): void;
    protected didRecohere(version: number): void;
}

/** @public */
export declare interface ValueDownlink<V, VU> {
    hostUri(): Uri;
    hostUri(hostUri: AnyUri): ValueDownlink<V, VU>;
    nodeUri(): Uri;
    nodeUri(nodeUri: AnyUri): ValueDownlink<V, VU>;
    laneUri(): Uri;
    laneUri(laneUri: AnyUri): ValueDownlink<V, VU>;
    prio(): number;
    prio(prio: number): ValueDownlink<V, VU>;
    rate(): number;
    rate(rate: number): ValueDownlink<V, VU>;
    body(): Value;
    body(body: AnyValue): ValueDownlink<V, VU>;
    keepLinked(): boolean;
    keepLinked(keepLinked: boolean): ValueDownlink<V, VU>;
    keepSynced(): boolean;
    keepSynced(keepSynced: boolean): ValueDownlink<V, VU>;
}

/** @public */
export declare interface ValueDownlink<V, VU> extends OutletCombinators<V> {
}

/** @beta */
export declare interface ValueDownlinkFastener<O = unknown, V = unknown, VU = V> extends DownlinkFastener<O> {
    (): V | undefined;
    (value: V | VU): O;
    /** @internal */
    readonly ownValueForm: Form<V, VU> | null;
    valueForm(): Form<V, VU> | null;
    valueForm(valueForm: Form<V, VU> | null): this;
    get(): V | undefined;
    set(value: V | VU): void;
    /** @override */
    readonly downlink: ValueDownlink<V, VU> | null;
    /** @internal @override */
    createDownlink(warp: WarpRef): ValueDownlink<V, VU>;
    /** @internal @override */
    bindDownlink(downlink: ValueDownlink<V, VU>): ValueDownlink<V, VU>;
    /** @internal */
    initDownlink?(downlink: ValueDownlink<V, VU>): ValueDownlink<V, VU>;
}

/** @beta */
export declare const ValueDownlinkFastener: ValueDownlinkFastenerFactory<ValueDownlinkFastener<any, any, any>>;

/** @beta */
export declare interface ValueDownlinkFastenerClass<F extends ValueDownlinkFastener<any, any> = ValueDownlinkFastener<any, any>> extends DownlinkFastenerClass<F> {
}

/** @beta */
export declare type ValueDownlinkFastenerDescriptor<O = unknown, V = unknown, VU = V, I = {}> = ThisType<ValueDownlinkFastener<O, V, VU> & I> & ValueDownlinkFastenerInit<V, VU> & Partial<I>;

/** @beta */
export declare interface ValueDownlinkFastenerFactory<F extends ValueDownlinkFastener<any, any> = ValueDownlinkFastener<any, any>> extends ValueDownlinkFastenerClass<F> {
    extend<I = {}>(className: string, classMembers?: Partial<I> | null): ValueDownlinkFastenerFactory<F> & I;
    define<O, V extends Value = Value, VU extends AnyValue = AnyValue>(className: string, descriptor: ValueDownlinkFastenerDescriptor<O, V, VU>): ValueDownlinkFastenerFactory<ValueDownlinkFastener<any, V, VU>>;
    define<O, V, VU = V>(className: string, descriptor: {
        valueForm: Form<V, VU>;
    } & ValueDownlinkFastenerDescriptor<O, V, VU>): ValueDownlinkFastenerFactory<ValueDownlinkFastener<any, V, VU>>;
    define<O, V extends Value = Value, VU extends AnyValue = AnyValue, I = {}>(className: string, descriptor: {
        implements: unknown;
    } & ValueDownlinkFastenerDescriptor<O, V, VU, I>): ValueDownlinkFastenerFactory<ValueDownlinkFastener<any, V, VU> & I>;
    define<O, V, VU = V, I = {}>(className: string, descriptor: {
        implements: unknown;
        valueForm: Form<V, VU>;
    } & ValueDownlinkFastenerDescriptor<O, V, VU, I>): ValueDownlinkFastenerFactory<ValueDownlinkFastener<any, V, VU> & I>;
    <O, V extends Value = Value, VU extends AnyValue = AnyValue>(descriptor: ValueDownlinkFastenerDescriptor<O, V, VU>): PropertyDecorator;
    <O, V, VU = V>(descriptor: {
        valueForm: Form<V, VU>;
    } & ValueDownlinkFastenerDescriptor<O, V, VU>): PropertyDecorator;
    <O, V extends Value = Value, VU extends AnyValue = AnyValue, I = {}>(descriptor: {
        implements: unknown;
    } & ValueDownlinkFastenerDescriptor<O, V, VU, I>): PropertyDecorator;
    <O, V, VU = V, I = {}>(descriptor: {
        implements: unknown;
        valueForm: Form<V, VU>;
    } & ValueDownlinkFastenerDescriptor<O, V, VU, I>): PropertyDecorator;
}

/** @beta */
export declare interface ValueDownlinkFastenerInit<V = unknown, VU = V> extends DownlinkFastenerInit, ValueDownlinkObserver<V, VU> {
    extends?: {
        prototype: ValueDownlinkFastener<any, any>;
    } | string | boolean | null;
    valueForm?: Form<V, VU>;
    initDownlink?(downlink: ValueDownlink<V, VU>): ValueDownlink<V, VU>;
}

/** @internal */
export declare type ValueDownlinkFastenerInitType<F extends ValueDownlinkFastener<any, any>> = F extends ValueDownlinkFastener<any, infer V, infer VU> ? V | VU : never;

/** @internal */
export declare type ValueDownlinkFastenerType<F extends ValueDownlinkFastener<any, any>> = F extends ValueDownlinkFastener<any, infer V, any> ? V : never;

/** @public */
export declare interface ValueDownlinkInit<V, VU = never> extends ValueDownlinkObserver<V, VU>, DownlinkInit {
    valueForm?: Form<V, VU>;
}

/** @internal */
export declare class ValueDownlinkModel extends DownlinkModel {
    constructor(context: DownlinkContext, hostUri: Uri, nodeUri: Uri, laneUri: Uri, prio?: number, rate?: number, body?: Value, state?: Value);
    readonly views: ReadonlyArray<ValueDownlink<unknown>>;
    /** @internal */
    readonly state: Value;
    get type(): DownlinkType;
    get(): Value;
    set(newValue: Value): void;
    setState(state: Value): void;
    onEventMessage(message: EventMessage, host: Host): void;
    protected onSetEvent(newValue: Value): void;
    protected valueWillSet(newValue: Value): Value;
    protected valueDidSet(newValue: Value, oldValue: Value): void;
}

/** @public */
export declare interface ValueDownlinkObserver<V, VU = never> extends DownlinkObserver {
    willSet?: ValueDownlinkWillSet<V, VU>;
    didSet?: VaueDownlinkDidSet<V, VU>;
}

/** @public */
export declare class ValueDownlinkRecord extends DownlinkRecord implements ValueDownlinkObserver<Value, AnyValue> {
    constructor(downlink: ValueDownlink<Value, AnyValue>);
    readonly downlink: ValueDownlink<Value, AnyValue>;
    isEmpty(): boolean;
    isArray(): boolean;
    isObject(): boolean;
    get length(): number;
    has(key: AnyValue): boolean;
    get(): Record_2;
    get(key: AnyValue): Value;
    getAttr(key: AnyText): Value;
    getSlot(key: AnyValue): Value;
    getField(key: AnyValue): Field | undefined;
    getItem(index: AnyNum): Item;
    set(key: AnyValue, newValue: AnyValue): this;
    setAttr(key: AnyText, newValue: AnyValue): this;
    setSlot(key: AnyValue, newValue: AnyValue): this;
    setItem(index: number, newItem: AnyItem): this;
    push(...newItems: AnyItem[]): number;
    splice(start: number, deleteCount?: number, ...newItems: AnyItem[]): Item[];
    delete(key: AnyValue): Item;
    clear(): void;
    forEach<T>(callback: (item: Item, index: number) => T | void): T | undefined;
    forEach<T, S>(callback: (this: S, item: Item, index: number) => T | void, thisArg: S): T | undefined;
    keyIterator(): Cursor<Value>;
    didSet(newValue: Value, oldValue: Value): void;
}

/** @public */
export declare type ValueDownlinkWillSet<V, VU = never> = (newValue: V, downlink: ValueDownlink<V, VU>) => V | void;

/** @internal */
export declare class ValueEntryCursor<K, V> extends Cursor<[K, V]> {
    constructor(cursor: Cursor<[Value, Value]>, keyForm: Form<K, unknown>, valueForm: Form<V, unknown>);
    /** @internal */
    readonly cursor: Cursor<[Value, Value]>;
    /** @internal */
    readonly keyForm: Form<K, unknown>;
    /** @internal */
    readonly valueForm: Form<V, unknown>;
    isEmpty(): boolean;
    head(): [K, V];
    step(): void;
    skip(count: number): void;
    hasNext(): boolean;
    nextIndex(): number;
    next(): {
        value?: [K, V];
        done: boolean;
    };
    hasPrevious(): boolean;
    previousIndex(): number;
    previous(): {
        value?: [K, V];
        done: boolean;
    };
    delete(): void;
}

/** @internal */
export declare class ValueForm extends Form<Value, AnyValue> {
    constructor(unit?: Value);
    readonly unit: Value | undefined;
    withUnit(unit: Value | undefined): Form<Value>;
    mold(object: AnyValue, item?: Item): Item;
    cast(item: Item, object?: Value): Value | undefined;
}

/** @public */
export declare class ValueInput<O> extends AbstractOutlet<O> {
    constructor(state?: O);
    /** @internal */
    readonly state: O | undefined;
    get(): O | undefined;
    set(newState: O | undefined): O | undefined;
}

/** @public */
export declare class ValueOutput<I> extends AbstractInlet<I> {
    constructor(state?: I);
    /** @internal */
    readonly state: I | undefined;
    get(): I | undefined;
    protected onRecohereOutput(version: number): void;
}

/**
 * Utilities for comparing and hashing structural values. A structural value
 * is typed by object structure, rather than by name.
 * @public
 */
export declare const Values: {
    /**
     * Returns `true` if `x` and `y` are structurally equal, otherwise returns `false`.
     */
    equal(x: unknown, y: unknown): boolean;
    /**
     * Returns a hash code for a structural value.
     */
    hash(x: unknown): number;
    /**
     * Returns `true` if `x` and `y` are structurally equivalent, otherwise returns `false`.
     */
    equivalent(x: unknown, y: unknown, epsilon?: number | undefined): boolean;
    /**
     * Returns `-1` if `x` orders before `y`; returns `1` if `x` orders after `y`;
     * returns `0` if `x` and `y` are equivalent; and returns `NaN` if `x` is not
     * comparable to `y`.
     */
    compare(x: unknown, y: unknown): number;
};

/** @internal */
export declare class ValuesCursor<K, V> extends Cursor<V> {
    constructor(cursor: Cursor<[K, V]>);
    /** @internal */
    readonly cursor: Cursor<[K, V]>;
    isEmpty(): boolean;
    head(): V;
    step(): void;
    skip(count: number): void;
    hasNext(): boolean;
    nextIndex(): number;
    next(): {
        value?: V;
        done: boolean;
    };
    hasPrevious(): boolean;
    previousIndex(): number;
    previous(): {
        value?: V;
        done: boolean;
    };
    delete(): void;
}

/** @public */
export declare class ValuesSelector extends Selector {
    constructor(then: Selector);
    readonly then: Selector;
    forSelected<T>(interpreter: Interpreter, callback: (interpreter: Interpreter) => T | undefined): T | undefined;
    forSelected<T, S>(interpreter: Interpreter, callback: (this: S, interpreter: Interpreter) => T | undefined, thisArg: S): T | undefined;
    mapSelected(interpreter: Interpreter, transform: (interpreter: Interpreter) => Item): Item;
    mapSelected<S>(interpreter: Interpreter, transform: (this: S, interpreter: Interpreter) => Item, thisArg: S): Item;
    substitute(interpreter: AnyInterpreter): Item;
    andThen(then: Selector): Selector;
    get typeOrder(): number;
    compareTo(that: unknown): number;
    equivalentTo(that: unknown, epsilon?: number): boolean;
    equals(that: unknown): boolean;
    hashCode(): number;
    debugThen<T>(output: Output<T>): Output<T>;
    clone(): Selector;
}

/** @public */
export declare type VaueDownlinkDidSet<V, VU = never> = (newValue: V, oldValue: V, downlink: ValueDownlink<V, VU>) => void;

/** @public */
export declare class WarpClient implements HostContext, RefContext, WarpRef {
    constructor(options?: WarpClientOptions);
    /** @internal */
    readonly options: WarpClientOptions;
    /** @internal */
    readonly hosts: BTree<Uri, Host>;
    /** @internal */
    readonly downlinks: BTree<Uri, BTree<Uri, BTree<Uri, DownlinkModel>>>;
    /** @internal */
    readonly downlinkCount: number;
    /** @internal */
    readonly refs: BaseRef[];
    readonly online: boolean;
    setOnline(online: boolean): void;
    /** @internal */
    readonly observers: ReadonlyArray<WarpObserver>;
    keepOnline(): boolean;
    keepOnline(keepOnline: boolean): this;
    protected watchOnline(keepOnline: boolean): void;
    protected onOnline(event: Event): void;
    protected onOffline(event: Event): void;
    /** @internal */
    getHost(hostUri: AnyUri): Host | undefined;
    /** @internal */
    openHost(hostUri: AnyUri): Host;
    /** @internal */
    closeHost(host: Host): void;
    /** @internal */
    getDownlink(hostUri: Uri, nodeUri: Uri, laneUri: Uri): DownlinkModel | undefined;
    /** @internal */
    openDownlink(downlink: DownlinkModel): void;
    /** @internal */
    unlinkDownlink(downlink: DownlinkModel): void;
    /** @internal */
    closeDownlink(downlink: DownlinkModel): void;
    downlink(init?: EventDownlinkInit): EventDownlink;
    downlinkList(init?: ListDownlinkInit<Value, AnyValue>): ListDownlink<Value, AnyValue>;
    downlinkList<V extends VU, VU = never>(init?: ListDownlinkInit<V, VU>): ListDownlink<V, VU>;
    downlinkMap(init?: MapDownlinkInit<Value, Value, AnyValue, AnyValue>): MapDownlink<Value, Value, AnyValue, AnyValue>;
    downlinkMap<K extends KU, V extends VU, KU = never, VU = never>(init?: MapDownlinkInit<K, V, KU, VU>): MapDownlink<K, V, KU, VU>;
    downlinkValue(init?: ValueDownlinkInit<Value, AnyValue>): ValueDownlink<Value, AnyValue>;
    downlinkValue<V extends VU, VU = never>(init?: ValueDownlinkInit<V, VU>): ValueDownlink<V, VU>;
    /** @internal */
    openRef(ref: BaseRef): void;
    /** @internal */
    closeRef(ref: BaseRef): void;
    hostRef(hostUri: AnyUri): HostRef;
    nodeRef(hostUri: AnyUri, nodeUri: AnyUri): NodeRef;
    nodeRef(nodeUri: AnyUri): NodeRef;
    laneRef(hostUri: AnyUri, nodeUri: AnyUri, laneUri: AnyUri): LaneRef;
    laneRef(nodeUri: AnyUri, laneUri: AnyUri): LaneRef;
    authenticate(hostUri: AnyUri, credentials: AnyValue): void;
    command(hostUri: AnyUri, nodeUri: AnyUri, laneUri: AnyUri, body: AnyValue): void;
    command(nodeUri: AnyUri, laneUri: AnyUri, body: AnyValue): void;
    close(): void;
    observe(observer: WarpObserver): this;
    unobserve(observer: unknown): this;
    didConnect(didConnect: WarpDidConnect): this;
    didAuthenticate(didAuthenticate: WarpDidAuthenticate): this;
    didDeauthenticate(didDeauthenticate: WarpDidDeauthenticate): this;
    didDisconnect(didDisconnect: WarpDidDisconnect): this;
    didFail(didFail: WarpDidFail): this;
    /** @internal */
    hostDidConnect(host: Host): void;
    /** @internal */
    hostDidAuthenticate(body: Value, host: Host): void;
    /** @internal */
    hostDidDeauthenticate(body: Value, host: Host): void;
    /** @internal */
    hostDidDisconnect(host: Host): void;
    /** @internal */
    hostDidFail(error: unknown, host: Host): void;
}

/** @public */
export declare interface WarpClientOptions extends HostOptions {
    keepOnline?: boolean;
}

/** @public */
export declare type WarpDidAuthenticate = (body: Value, host: Host, warp: WarpRef) => void;

/** @public */
export declare type WarpDidConnect = (host: Host, warp: WarpRef) => void;

/** @public */
export declare type WarpDidDeauthenticate = (body: Value, host: Host, warp: WarpRef) => void;

/** @public */
export declare type WarpDidDisconnect = (host: Host, warp: WarpRef) => void;

/** @public */
export declare type WarpDidFail = (error: unknown, host: Host, warp: WarpRef) => void;

/** @public */
export declare interface WarpObserver {
    didConnect?: WarpDidConnect;
    didAuthenticate?: WarpDidAuthenticate;
    didDeauthenticate?: WarpDidDeauthenticate;
    didDisconnect?: WarpDidDisconnect;
    didFail?: WarpDidFail;
}

/** @public */
export declare interface WarpProvider<O, S extends WarpService<O> | null | undefined = WarpService<O>> extends Provider<O, S> {
    get client(): WarpClient;
    createService(): S;
}

/** @public */
export declare const WarpProvider: ProviderClass<WarpProvider<any, any>>;

/** @public */
export declare interface WarpRef {
    downlink(init?: EventDownlinkInit): EventDownlink;
    downlinkList(init?: ListDownlinkInit<Value, AnyValue>): ListDownlink<Value, AnyValue>;
    downlinkList<V extends VU, VU = never>(init?: ListDownlinkInit<V, VU>): ListDownlink<V, VU>;
    downlinkMap(init?: MapDownlinkInit<Value, Value, AnyValue, AnyValue>): MapDownlink<Value, Value, AnyValue, AnyValue>;
    downlinkMap<K extends KU, V extends VU, KU = never, VU = never>(init?: MapDownlinkInit<K, V, KU, VU>): MapDownlink<K, V, KU, VU>;
    downlinkValue(init?: ValueDownlinkInit<Value, AnyValue>): ValueDownlink<Value, AnyValue>;
    downlinkValue<V extends VU, VU = never>(init?: ValueDownlinkInit<V, VU>): ValueDownlink<V, VU>;
    hostRef(hostUri: AnyUri): HostRef;
    nodeRef(hostUri: AnyUri, nodeUri: AnyUri): NodeRef;
    nodeRef(nodeUri: AnyUri): NodeRef;
    laneRef(hostUri: AnyUri, nodeUri: AnyUri, laneUri: AnyUri): LaneRef;
    laneRef(nodeUri: AnyUri, laneUri: AnyUri): LaneRef;
    observe(observer: WarpObserver): this;
    unobserve(observer: unknown): this;
    didConnect(didConnect: WarpDidConnect): this;
    didAuthenticate(didAuthenticate: WarpDidAuthenticate): this;
    didDeauthenticate(didDeauthenticate: WarpDidDeauthenticate): this;
    didDisconnect(didDisconnect: WarpDidDisconnect): this;
    didFail(didFail: WarpDidFail): this;
}

/** @public */
export declare class WarpService<O> extends Service<O> {
    constructor(client: WarpClient);
    readonly observerType?: Class<WarpServiceObserver<O>>;
    readonly client: WarpClient;
    static global<O>(): WarpService<O>;
}

/** @public */
export declare interface WarpServiceObserver<O, S extends WarpService<O> = WarpService<O>> extends ServiceObserver<O, S> {
}

/** @internal */
export declare class WarpWorkerHost extends RemoteHost {
    constructor(context: HostContext, hostUri: Uri, options: HostOptions, worker: Worker);
    /** @internal */
    readonly worker: Worker;
    /** @internal */
    readonly port: MessagePort | null;
    readonly connected: boolean;
    open(): void;
    close(): void;
    push(envelope: Envelope): void;
    protected onWorkerReceive(event: MessageEvent<AnyValue>): void;
    protected onPortReceive(event: MessageEvent<AnyValue>): void;
    protected onMessage(message: Message, event: MessageEvent): void;
    protected onSignal(signal: Signal, event: MessageEvent): void;
    protected onOpenedSignal(response: OpenedSignal, event: MessageEvent): void;
    protected onClosedSignal(response: ClosedSignal): void;
    protected onConnectedSignal(response: ConnectedSignal): void;
    protected onDisconnectedSignal(response: DisconnectedSignal): void;
    protected onErrorSignal(response: ErrorSignal): void;
    protected onUnexpectedSignal(signal: Signal): void;
    protected onUnknownMessage(message: Message | Value): void;
    protected closeDown(): void;
    static create(context: HostContext, hostUri: Uri, options: HostOptions): WarpWorkerHost | null;
    /** @internal */
    static webworker: string | undefined;
    /** @internal */
    static webworkerUrl: string | undefined;
}

/** @public */
export declare class WatchFieldsCombinator<K, V, O> extends WatchFieldsOperator<K, V, O> {
    constructor(func: WatchFieldsFunction<K, V>);
    /** @internal */
    readonly func: WatchFieldsFunction<K, V>;
    evaluate(key: K, value: V | undefined): void;
}

/** @public */
export declare type WatchFieldsFunction<K, V> = (key: K, value: V) => void;

/** @public */
export declare abstract class WatchFieldsOperator<K, V, O> extends AbstractMapInlet<K, V, O> {
    protected onRecohereOutputKey(key: K, effect: KeyEffect, version: number): void;
    abstract evaluate(key: K, value: V | undefined): void;
}

/** @public */
export declare class WatchValueCombinator<I> extends WatchValueOperator<I> {
    constructor(func: WatchValueFunction<I>);
    /** @internal */
    readonly func: WatchValueFunction<I>;
    evaluate(value: I | undefined): void;
}

/** @public */
export declare type WatchValueFunction<I> = (value: I) => void;

/** @public */
export declare abstract class WatchValueOperator<I> extends AbstractInlet<I> {
    onRecohereOutput(version: number): void;
    abstract evaluate(value: I | undefined): void;
}

/** @internal */
export declare class WebSocketHost extends RemoteHost {
    constructor(context: HostContext, hostUri: Uri, options: HostOptions);
    /** @internal */
    readonly socket: WebSocket | null;
    get connected(): boolean;
    open(): void;
    close(): void;
    push(envelope: Envelope): void;
    protected onWebSocketOpen(): void;
    protected onWebSocketMessage(message: MessageEvent<unknown>): void;
    protected onWebSocketClose(): void;
    protected onWebSocketError(): void;
    /** @internal */
    static WebSocket: typeof WebSocket | null;
}

/** @internal */
export declare class WeekdayFormat extends DateTimeFormat {
    private readonly locale;
    constructor(locale: DateTimeLocale);
    withLocale(locale: DateTimeLocale): DateTimeFormat;
    writeDate<T>(output: Output<T>, date: DateTime): Output<T>;
    parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit>;
}

/** @internal */
export declare class WeekdayParser extends Parser<DateTimeInit> {
    private readonly locale;
    private readonly date;
    private readonly output;
    constructor(locale: DateTimeLocale, date?: DateTimeInit, output?: Output<string>);
    feed(input: Input): Parser<DateTimeInit>;
    static parse(input: Input, locale: DateTimeLocale, date?: DateTimeInit, output?: Output<string>): Parser<DateTimeInit>;
    static term(locale: DateTimeLocale, value: string, date: DateTimeInit, input: Input): Parser<DateTimeInit>;
    static cont(locale: DateTimeLocale, date: DateTimeInit, output: Output<string>): Parser<DateTimeInit>;
}

/** @internal */
export declare class WeekInterval extends TimeInterval {
    readonly day: number;
    constructor(day?: number);
    offset(t: AnyDateTime, k?: number): DateTime;
    next(t: AnyDateTime, k?: number): DateTime;
    floor(t: AnyDateTime): DateTime;
    ceil(t: AnyDateTime): DateTime;
}

/** @public */
export declare abstract class WorkerAddressed<S extends WorkerAddressed<S> = WorkerAddressed<any>> extends Signal {
    constructor(host: Uri, body: Value);
    readonly host: Uri;
    withHost(host: AnyUri): S;
    readonly body: Value;
    withBody(body: AnyValue): S;
    protected copy(host: Uri, body: Value): S;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug<T>(output: Output<T>): Output<T>;
    toValue(): Value;
    static fromValue<S extends WorkerAddressedConstructor<InstanceType<S>>>(this: S, value: Value): InstanceType<S> | null;
    static create<S extends WorkerAddressedConstructor<InstanceType<S>>>(this: S, host: AnyUri, body?: AnyValue): InstanceType<S>;
}

/** @public */
export declare interface WorkerAddressedConstructor<S extends WorkerAddressed<S> = WorkerAddressed<any>> {
    new (host: Uri, body: Value): S;
    readonly tag: string;
}

/**
 * Continuation of how to write subsequent [[Output]] tokens to a stream.
 * `Writer` enables efficient, interruptible writing of network protocols and
 * data formats, without intermediate buffering.
 *
 * ### Output tokens
 * A `Writer` writes tokens to an `Output` writer. Output tokens are modeled
 * as primitive numbers, commonly representing Unicode code points, or raw
 * octets. Each `Writer` implementation specifies the semantic type of output
 * tokens it produces.
 *
 * ### Writer states
 * A `Writer` is always in one of three states: _cont_​inue, _done_, or _error_.
 * The _cont_ state indicates that [[pull]] is ready to produce `Output`; the
 * _done_ state indicates that writing terminated successfully, and that
 * [[bind]] will return the written result; the _error_ state indicates that
 * writing terminated in failure, and that [[trap]] will return the write error.
 * `Writer` subclasses default to the _cont_ state.
 *
 * ### Feeding input
 * The [[feed]] method returns a `Writer` that represents the continuation
 * of how to write the given input object to subsequent `Output` writers.
 * `feed` can be used to specify an initial object to write, or to change
 * the object to be written.
 *
 * ### Pulling output
 * The [[pull]] method incrementally writes as much `Output` as it can, before
 * returning another `Writer` that represents the continuation of how to write
 * additional `Output`. The `Output` passed to `pull` is only guaranteed to be
 * valid for the duration of the method call; references to the provided
 * `Output` instance must not be stored.
 *
 * ### Writer results
 * A `Writer` produces a written result of type `O`, obtained via the [[bind]]
 * method. `bind` is only guaranteed to return a result when in the _done_
 * state; though `bind` may optionally make available partial results in other
 * states. A failed `Writer` provides a write error via the [[trap]] method.
 * `trap` is only guaranteed to return an error when in the _error_ state.
 *
 * ### Continuations
 * A `Writer` instance represents a continuation of how to write remaining
 * `Output`. Rather than writing a complete output in one go, a `Writer` takes
 * an `Output` chunk and returns another `Writer` instance that knows how to
 * write subsequent `Output` chunks. This enables non-blocking, incremental
 * writing that can be interrupted whenever an `Output` writer runs out of
 * space. A `Writer` terminates by returning a continuation in either the
 * _done_ state, or the _error_ state. [[Writer.done]] returns a `Writer` in
 * the _done_ state. [[Writer.error]] returns a `Writer` in the _error_ state.
 *
 * ### Forking
 * The [[fork]] method passes an out-of-band condition to a `Writer`, yielding
 * a `Writer` continuation whose behavior may be altered by the given condition.
 * For example, a console `Writer` might support a `fork` condition that changes
 * the color and style of printed text. The types of conditions accepted by
 * `fork`, and their intended semantics, are implementation defined.
 *
 * @public
 */
export declare abstract class Writer<I = unknown, O = unknown> {
    /**
     * Returns `true` when [[pull]] is able to produce `Output`, i.e. this
     * `Writer` is in the _cont_ state.
     */
    isCont(): boolean;
    /**
     * Returns `true` when writing has terminated successfully, and [[bind]] will
     * return the written result, i.e. this `Writer` is in the _done_ state.
     */
    isDone(): boolean;
    /**
     * Returns `true` when writing has terminated in failure, and [[trap]] will
     * return the write error, i.e. this `Writer` is in the _error_ state.
     */
    isError(): boolean;
    /**
     * Returns a `Writer` that represents the continuation of how to write the
     * given `input` object.
     *
     * @throws `WriterException` if this `Writer` does not know how to write the
     *         given `input` object.
     */
    feed(input: I): Writer<I, O>;
    /**
     * Incrementally writes as much `output` as possible, and returns another
     * `Writer` that represents the continuation of how to write additional
     * `Output`. If `output` enters the _done_ state, `pull` _must_ return a
     * terminated `Writer`, i.e. a `Writer` in the _done_ state, or in the
     * _error_ state. The given `output` is only guaranteed to be valid for the
     * duration of the method call; references to `output` must not be stored.
     */
    abstract pull(output: Output): Writer<I, O>;
    /**
     * Returns a `Writer` continuation whose behavior may be altered by the given
     * out-of-band `condition`.
     */
    fork(condition: unknown): Writer<I, O>;
    /**
     * Returns the written result. Only guaranteed to return a result when in
     * the _done_ state.
     *
     * @throws `Error` if this `Writer` is not in the _done_ state.
     */
    bind(): O;
    /**
     * Returns the write error. Only guaranteed to return an error when in the
     * _error_ state.
     *
     * @throws `Error` if this `Writer` is not in the _error_ state.
     */
    trap(): Error;
    /**
     * Casts a done `Writer` to a different input type. A `Writer` in the _done_
     * state can have any input type.
     *
     * @throws `WriterException` if this `Writer` is not in the _done_ state.
     */
    asDone<I2>(): Writer<I2, O>;
    /**
     * Casts an errored `Writer` to different input and output types. A `Writer`
     * in the _error_ state can have any input type, and any output type.
     *
     * @throws `WriterException` if this `Writer` is not in the _error_ state.
     */
    asError<I2, O2>(): Writer<I2, O2>;
    /**
     * Returns a `Writer` that continues writing `that` `Writer`, after it
     * finishes writing this `Writer`.
     */
    andThen<O2>(that: Writer<unknown, O2>): Writer<never, O2>;
    /**
     * Returns a `Writer` in the _done_ state that never binds a value.
     */
    static end<I>(): Writer<I, never>;
    /**
     * Returns a `Writer` in the _done_ state that binds the given written `value`.
     */
    static done<I, O>(value: O): Writer<I, O>;
    /**
     * Returns a `Writer` in the _error_ state that traps the given write `error`.
     */
    static error<I, O>(error: Error): Writer<I, O>;
}

/** @internal */
export declare class WriterDone<O> extends Writer<unknown, O> {
    /** @internal */
    readonly value: O;
    constructor(value: O);
    isCont(): boolean;
    isDone(): boolean;
    pull(output: Output): Writer<unknown, O>;
    bind(): O;
    asDone<I2>(): Writer<I2, O>;
    andThen<O2>(that: Writer<unknown, O2>): Writer<unknown, O2>;
}

/** @internal */
export declare class WriterEnd extends Writer<unknown, never> {
    constructor();
    isCont(): boolean;
    isDone(): boolean;
    pull(output: Output): Writer<unknown, never>;
    bind(): never;
    asDone<I2>(): Writer<I2, never>;
    andThen<O2>(that: Writer<unknown, O2>): Writer<unknown, O2>;
}

/** @internal */
export declare class WriterError extends Writer<never, never> {
    /** @internal */
    readonly error: Error;
    constructor(error: Error);
    isCont(): boolean;
    isError(): boolean;
    pull(output: Output): Writer<never, never>;
    bind(): never;
    trap(): Error;
    asError<I2, O2>(): Writer<I2, O2>;
    andThen<O2>(that: Writer<never, O2>): Writer<never, O2>;
}

/**
 * Thrown when a [[Writer]] attempts to write invalid syntax.
 * @public
 */
export declare class WriterException extends Error {
    constructor(message?: string);
}

/** @internal */
export declare class WriterSequence<O> extends Writer<never, O> {
    /** @internal */
    readonly head: Writer<unknown, unknown>;
    /** @internal */
    readonly tail: Writer<unknown, O>;
    constructor(head: Writer<unknown, unknown>, tail: Writer<unknown, O>);
    pull(output: Output): Writer<never, O>;
}

/** @internal */
export declare class YearFormat extends DateTimeFormat {
    writeDate<T>(output: Output<T>, date: DateTime): Output<T>;
    parseDateTime(input: Input, date: DateTimeInit): Parser<DateTimeInit>;
}

/** @internal */
export declare class YearInterval extends UnitTimeInterval {
    offset(t: AnyDateTime, k?: number): DateTime;
    next(t: AnyDateTime, k?: number): DateTime;
    floor(t: AnyDateTime): DateTime;
    ceil(t: AnyDateTime): DateTime;
    every(k: number): TimeInterval;
}

/** @internal */
export declare class YearParser extends Parser<DateTimeInit> {
    private readonly date;
    private readonly year;
    private readonly step;
    constructor(date?: DateTimeInit, year?: number, step?: number);
    feed(input: Input): Parser<DateTimeInit>;
    static parse(input: Input, date?: DateTimeInit, year?: number, step?: number): Parser<DateTimeInit>;
    static term(year: number, date: DateTimeInit): Parser<DateTimeInit>;
    static cont(date: DateTimeInit, year: number, step: number): Parser<DateTimeInit>;
}

/** @internal */
export declare class YearsInterval extends TimeInterval {
    private readonly stride;
    constructor(stride: number);
    offset(t: AnyDateTime, k?: number): DateTime;
    next(t: AnyDateTime, k?: number): DateTime;
    floor(t: AnyDateTime): DateTime;
    ceil(t: AnyDateTime): DateTime;
}

export { }
