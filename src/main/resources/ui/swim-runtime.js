// @swim/runtime v4.0.0-dev.20210927.1 (c) 2015-2021 Swim.inc
(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("os"), require("ws")) : typeof define === "function" && define.amd ? define([ "exports", "os", "ws" ], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, 
  factory(global.swim = global.swim || {}, global.os, global.ws));
})(this, (function(exports, os, ws) {
  "use strict";
  function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  const Random = function() {
    const Random = {};
    if (typeof window !== "undefined" && window.crypto !== void 0) {
      Random.fillBytes = function(array) {
        window.crypto.getRandomValues(array);
      };
    } else if (typeof window !== "undefined" && window.msCrypto !== void 0) {
      Random.fillBytes = function(array) {
        window.msCrypto.getRandomValues(array);
      };
    } else {
      Random.fillBytes = function(array) {
        if (array instanceof Int8Array) {
          for (let i = 0; i < array.length; i += 1) {
            array[i] = 128 - Math.round(Math.random() * 256);
          }
        } else if (array instanceof Uint8Array) {
          for (let i = 0; i < array.length; i += 1) {
            array[i] = Math.round(Math.random() * 256);
          }
        } else if (array instanceof Int16Array) {
          for (let i = 0; i < array.length; i += 1) {
            array[i] = 32768 - Math.round(Math.random() * 65536);
          }
        } else if (array instanceof Uint16Array) {
          for (let i = 0; i < array.length; i += 1) {
            array[i] = Math.round(Math.random() * 65536);
          }
        } else if (array instanceof Int32Array) {
          for (let i = 0; i < array.length; i += 1) {
            array[i] = 2147483648 - Math.round(Math.random() * 4294967296);
          }
        } else if (array instanceof Uint32Array) {
          for (let i = 0; i < array.length; i += 1) {
            array[i] = Math.round(Math.random() * 4294967296);
          }
        } else {
          throw new TypeError("" + array);
        }
      };
    }
    return Random;
  }();
  const ByteOrder = function() {
    const ByteOrder = {};
    Object.defineProperty(ByteOrder, "BigEndian", {
      value: "BE",
      enumerable: true
    });
    Object.defineProperty(ByteOrder, "LittleEndian", {
      value: "LE",
      enumerable: true
    });
    Object.defineProperty(ByteOrder, "NativeOrder", {
      get() {
        let nativeEndian;
        const bom = new ArrayBuffer(2);
        new Uint16Array(bom)[0] = 65279;
        const b = new Uint8Array(bom);
        if (b[0] === 254 && b[1] === 255) {
          nativeEndian = ByteOrder.BigEndian;
        } else if (b[0] === 255 && b[1] === 254) {
          nativeEndian = ByteOrder.LittleEndian;
        } else {
          throw new Error;
        }
        Object.defineProperty(ByteOrder, "NativeOrder", {
          value: nativeEndian,
          enumerable: true
        });
        return nativeEndian;
      },
      configurable: true,
      enumerable: true
    });
    return ByteOrder;
  }();
  const Murmur3 = function() {
    const Murmur3 = {};
    Murmur3.mix = function(code, value) {
      value = (value & 65535) * 3432918353 + (((value >>> 16) * 3432918353 & 65535) << 16) & 4294967295;
      value = Murmur3.rotl(value, 15);
      value = (value & 65535) * 461845907 + (((value >>> 16) * 461845907 & 65535) << 16) & 4294967295;
      code ^= value;
      code = Murmur3.rotl(code, 13);
      code = (code & 65535) * 5 + (((code >>> 16) * 5 & 65535) << 16) & 4294967295;
      code = (code & 65535) + 27492 + (((code >>> 16) + 58964 & 65535) << 16);
      return code;
    };
    Murmur3.mixUint8Array = function(code, array) {
      if (ByteOrder.NativeOrder === ByteOrder.BigEndian) {
        return Murmur3.mixUint8ArrayBE(code, array);
      } else if (ByteOrder.NativeOrder === ByteOrder.LittleEndian) {
        return Murmur3.mixUInt8ArrayLE(code, array);
      } else {
        throw new Error;
      }
    };
    Murmur3.mixUint8ArrayBE = function(code, array) {
      let offset = 0;
      const limit = array.length;
      while (offset + 3 < limit) {
        const word = (array[offset] & 255) << 24 | (array[offset + 1] & 255) << 16 | (array[offset + 2] & 255) << 8 | array[offset + 3] & 255;
        code = Murmur3.mix(code, word);
        offset += 4;
      }
      if (offset < limit) {
        let word = (array[offset] & 255) << 24;
        if (offset + 1 < limit) {
          word |= (array[offset + 1] & 255) << 16;
          if (offset + 2 < limit) {
            word |= (array[offset + 2] & 255) << 8;
          }
        }
        word = (word & 65535) * 3432918353 + (((word >>> 16) * 3432918353 & 65535) << 16) & 4294967295;
        word = Murmur3.rotl(word, 15);
        word = (word & 65535) * 461845907 + (((word >>> 16) * 461845907 & 65535) << 16) & 4294967295;
        code ^= word;
      }
      return code ^ limit;
    };
    Murmur3.mixUInt8ArrayLE = function(code, array) {
      let offset = 0;
      const limit = array.length;
      while (offset + 3 < limit) {
        const word = array[offset] & 255 | (array[offset + 1] & 255) << 8 | (array[offset + 2] & 255) << 16 | (array[offset + 3] & 255) << 24;
        code = Murmur3.mix(code, word);
        offset += 4;
      }
      if (offset < limit) {
        let word = array[offset] & 255;
        if (offset + 1 < limit) {
          word |= (array[offset + 1] & 255) << 8;
          if (offset + 2 < limit) {
            word |= (array[offset + 2] & 255) << 16;
          }
        }
        word = (word & 65535) * 3432918353 + (((word >>> 16) * 3432918353 & 65535) << 16) & 4294967295;
        word = Murmur3.rotl(word, 15);
        word = (word & 65535) * 461845907 + (((word >>> 16) * 461845907 & 65535) << 16) & 4294967295;
        code ^= word;
      }
      return code ^ limit;
    };
    Murmur3.mixString = function(code, string) {
      if (ByteOrder.NativeOrder === ByteOrder.BigEndian) {
        return Murmur3.mixStringBE(code, string);
      } else if (ByteOrder.NativeOrder === ByteOrder.LittleEndian) {
        return Murmur3.mixStringLE(code, string);
      } else {
        throw new Error;
      }
    };
    Murmur3.mixStringBE = function(code, string) {
      let word = 0;
      let k = 32;
      let i = 0;
      const n = string.length;
      let utf8Length = 0;
      while (i < n) {
        let c = string.codePointAt(i);
        if (c === void 0) {
          c = string.charCodeAt(i);
        }
        if (c >= 0 && c <= 127) {
          k -= 8;
          word |= c << k;
          if (k === 0) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 32;
          }
          utf8Length += 1;
        } else if (c >= 128 && c <= 2047) {
          k -= 8;
          word |= (192 | c >>> 6) << k;
          if (k === 0) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 32;
          }
          k -= 8;
          word |= (128 | c & 63) << k;
          if (k === 0) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 32;
          }
          utf8Length += 2;
        } else if (c >= 2048 && c <= 65535 || c >= 57344 && c <= 65535) {
          k -= 8;
          word |= (224 | c >>> 12) << k;
          if (k === 0) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 32;
          }
          k -= 8;
          word |= (128 | c >>> 6 & 63) << k;
          if (k === 0) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 32;
          }
          k -= 8;
          word |= (128 | c & 63) << k;
          if (k === 0) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 32;
          }
          utf8Length += 3;
        } else if (c >= 65536 && c <= 1114111) {
          k -= 8;
          word |= (240 | c >>> 18) << k;
          if (k === 0) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 32;
          }
          k -= 8;
          word |= (128 | c >>> 12 & 63) << k;
          if (k === 0) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 32;
          }
          k -= 8;
          word |= (128 | c >>> 6 & 63) << k;
          if (k === 0) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 32;
          }
          k -= 8;
          word |= (128 | c & 63) << k;
          if (k === 0) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 32;
          }
          utf8Length += 4;
        } else {
          k -= 8;
          word |= 239 << k;
          if (k === 0) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 32;
          }
          k -= 8;
          word |= 191 << k;
          if (k === 0) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 32;
          }
          k -= 8;
          word |= 189 << k;
          if (k === 0) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 32;
          }
          utf8Length += 3;
        }
        i = Strings.offsetByCodePoints(string, i, 1);
      }
      if (k !== 32) {
        word = (word & 65535) * 3432918353 + (((word >>> 16) * 3432918353 & 65535) << 16) & 4294967295;
        word = Murmur3.rotl(word, 15);
        word = (word & 65535) * 461845907 + (((word >>> 16) * 461845907 & 65535) << 16) & 4294967295;
        code ^= word;
      }
      return code ^ utf8Length;
    };
    Murmur3.mixStringLE = function(code, string) {
      let word = 0;
      let k = 0;
      let i = 0;
      const n = string.length;
      let utf8Length = 0;
      while (i < n) {
        let c = string.codePointAt(i);
        if (c === void 0) {
          c = string.charCodeAt(i);
        }
        if (c >= 0 && c <= 127) {
          word |= c << k;
          k += 8;
          if (k === 32) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 0;
          }
          utf8Length += 1;
        } else if (c >= 128 && c <= 2047) {
          word |= (192 | c >>> 6) << k;
          k += 8;
          if (k === 32) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 0;
          }
          word |= (128 | c & 63) << k;
          k += 8;
          if (k === 32) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 0;
          }
          utf8Length += 2;
        } else if (c >= 2048 && c <= 65535 || c >= 57344 && c <= 65535) {
          word |= (224 | c >>> 12) << k;
          k += 8;
          if (k === 32) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 0;
          }
          word |= (128 | c >>> 6 & 63) << k;
          k += 8;
          if (k === 32) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 0;
          }
          word |= (128 | c & 63) << k;
          k += 8;
          if (k === 32) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 0;
          }
          utf8Length += 3;
        } else if (c >= 65536 && c <= 1114111) {
          word |= (240 | c >>> 18) << k;
          k += 8;
          if (k === 32) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 0;
          }
          word |= (128 | c >>> 12 & 63) << k;
          k += 8;
          if (k === 32) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 0;
          }
          word |= (128 | c >>> 6 & 63) << k;
          k += 8;
          if (k === 32) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 0;
          }
          word |= (128 | c & 63) << k;
          k += 8;
          if (k === 32) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 0;
          }
          utf8Length += 4;
        } else {
          word |= 239 << k;
          k += 8;
          if (k === 32) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 0;
          }
          word |= 191 << k;
          k += 8;
          if (k === 32) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 0;
          }
          word |= 189 << k;
          k += 8;
          if (k === 32) {
            code = Murmur3.mix(code, word);
            word = 0;
            k = 0;
          }
          utf8Length += 3;
        }
        i = Strings.offsetByCodePoints(string, i, 1);
      }
      if (k !== 32) {
        word = (word & 65535) * 3432918353 + (((word >>> 16) * 3432918353 & 65535) << 16) & 4294967295;
        word = Murmur3.rotl(word, 15);
        word = (word & 65535) * 461845907 + (((word >>> 16) * 461845907 & 65535) << 16) & 4294967295;
        code ^= word;
      }
      return code ^ utf8Length;
    };
    Murmur3.mash = function(code) {
      code ^= code >>> 16;
      code = (code & 65535) * 2246822507 + (((code >>> 16) * 2246822507 & 65535) << 16) & 4294967295;
      code ^= code >>> 13;
      code = (code & 65535) * 3266489909 + (((code >>> 16) * 3266489909 & 65535) << 16) & 4294967295;
      code ^= code >>> 16;
      return code >>> 0;
    };
    Murmur3.rotl = function(value, distance) {
      return value << distance | value >>> 32 - distance;
    };
    return Murmur3;
  }();
  const Lazy = function(target, propertyKey, descriptor) {
    const writable = descriptor.writable;
    const enumerable = descriptor.enumerable;
    const configurable = descriptor.configurable;
    if (descriptor.get !== void 0) {
      const get = descriptor.get;
      descriptor.get = function() {
        const value = get.call(this);
        Object.defineProperty(target, propertyKey, {
          value: value,
          writable: writable,
          enumerable: enumerable,
          configurable: configurable
        });
        return value;
      };
    } else if (descriptor.value !== void 0) {
      const method = descriptor.value;
      descriptor.value = function() {
        const value = method.call(this);
        Object.defineProperty(target, propertyKey, {
          value: function() {
            return value;
          },
          writable: writable,
          enumerable: enumerable,
          configurable: configurable
        });
        return value;
      };
    } else {
      throw new Error("invalid lazy property descriptor");
    }
  };
  const Identity = function() {
    const Identity = {};
    Identity.compare = function(x, y) {
      if (typeof x === "object" && x !== null) {
        if (typeof y === "object" && y !== null) {
          const xh = Identity.hash(x);
          const yh = Identity.hash(y);
          return xh < yh ? -1 : xh > yh ? 1 : 0;
        } else {
          return -1;
        }
      } else if (x === null) {
        return y === void 0 ? -1 : y === null ? 0 : 1;
      } else if (x === void 0) {
        return y === void 0 ? 0 : 1;
      } else {
        return NaN;
      }
    };
    let nextId = 1;
    Identity.hash = function(x) {
      if (typeof x === "object" && x !== null) {
        let hashCode = x._hashCode;
        if (hashCode === void 0) {
          hashCode = ~~nextId;
          nextId += 1;
          Object.defineProperty(x, "_hashCode", {
            value: hashCode,
            configurable: true
          });
        }
        return hashCode;
      } else if (x === null) {
        return 1;
      } else if (x === void 0) {
        return 0;
      } else {
        throw new TypeError("" + x);
      }
    };
    return Identity;
  }();
  const Booleans = function() {
    const Booleans = {};
    Booleans.compare = function(x, y) {
      if (typeof x === "boolean") {
        return typeof y === "boolean" ? x && !y ? -1 : !x && y ? 1 : 0 : -1;
      } else if (x === null) {
        return y === void 0 ? -1 : y === null ? 0 : 1;
      } else if (x === void 0) {
        return y === void 0 ? 0 : 1;
      } else {
        return NaN;
      }
    };
    Booleans.hash = function(x) {
      if (x === true) {
        return 3;
      } else if (x === false) {
        return 2;
      } else if (x === null) {
        return 1;
      } else if (x === void 0) {
        return 0;
      } else {
        throw new TypeError("" + x);
      }
    };
    return Booleans;
  }();
  const Equivalent = function() {
    const Equivalent = function(x, y, epsilon) {
      if (x === y) {
        return true;
      } else if (x !== void 0 && x !== null && typeof x.equivalentTo === "function") {
        return x.equivalentTo(y, epsilon);
      }
      return false;
    };
    Equivalent.is = function(object) {
      return object !== void 0 && object !== null && typeof object.equivalentTo === "function";
    };
    Equivalent.Epsilon = 1e-8;
    return Equivalent;
  }();
  const Numbers = function() {
    const Numbers = {};
    Numbers.equal = function(x, y) {
      return x === y || typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
    };
    Numbers.equivalent = function(x, y, epsilon) {
      return x === y || typeof x === "number" && typeof y === "number" && (isNaN(x) && isNaN(y) || Math.abs(y - x) < (epsilon !== void 0 ? epsilon : Equivalent.Epsilon));
    };
    Numbers.compare = function(x, y) {
      if (typeof x === "number") {
        return typeof y === "number" ? x < y ? -1 : x > y ? 1 : isNaN(y) ? isNaN(x) ? 0 : -1 : isNaN(x) ? 1 : 0 : -1;
      } else if (x === null) {
        return y === void 0 ? -1 : y === null ? 0 : 1;
      } else if (x === void 0) {
        return y === void 0 ? 0 : 1;
      } else {
        return NaN;
      }
    };
    const hashArrayBuffer = new ArrayBuffer(8);
    const hashFloat64Array = new Float64Array(hashArrayBuffer);
    const hashInt32Array = new Int32Array(hashArrayBuffer);
    Numbers.hash = function(x) {
      if (typeof x === "number") {
        if (x === ~~x) {
          return ~~x;
        } else {
          hashFloat64Array[0] = x;
          return hashInt32Array[0] ^ hashInt32Array[1];
        }
      } else if (x === null) {
        return 1;
      } else if (x === void 0) {
        return 0;
      } else {
        throw new TypeError("" + x);
      }
    };
    return Numbers;
  }();
  const Strings = function() {
    const Strings = {};
    Strings.compare = function(x, y) {
      if (typeof x === "string") {
        return typeof y === "string" ? x < y ? -1 : x > y ? 1 : 0 : -1;
      } else if (x === null) {
        return y === void 0 ? -1 : y === null ? 0 : 1;
      } else if (x === void 0) {
        return y === void 0 ? 0 : 1;
      } else {
        return NaN;
      }
    };
    Strings.hash = function(x) {
      if (typeof x === "string") {
        return Murmur3.mash(Murmur3.mixString(0, x));
      } else if (x === null) {
        return 1;
      } else if (x === void 0) {
        return 0;
      } else {
        throw new TypeError("" + x);
      }
    };
    Strings.codePointAt = function(string, index) {
      const length = string.length;
      index = index ? Number(index) : 0;
      if (index !== index) {
        index = 0;
      }
      if (index >= 0 && index < length) {
        const c1 = string.charCodeAt(index);
        if (c1 <= 55295 || c1 >= 57344) {
          return c1;
        } else if (c1 <= 56319 && index + 1 < length) {
          const c2 = string.charCodeAt(index + 1);
          if (c2 >= 56320 && c2 <= 57343) {
            return ((c1 & 1023) << 10 + c2 & 1023) + 65536;
          }
        }
      }
      return void 0;
    };
    Strings.offsetByCodePoints = function(string, index, count) {
      if (count > 0) {
        const length = string.length;
        while (count > 0 && index < length) {
          const c1 = string.charCodeAt(index);
          if (c1 <= 55295 || c1 >= 57344) {
            index += 1;
          } else if (c1 <= 56319 && index + 1 < length) {
            const c2 = string.charCodeAt(index + 1);
            if (c2 >= 56320 && c2 <= 57343) {
              index += 2;
            } else {
              index += 1;
            }
          } else {
            index += 1;
          }
          count -= 1;
        }
      } else if (count < 0) {
        while (count < 0 && index > 0) {
          const c2 = string.charCodeAt(index - 1);
          if (c2 <= 55295 || c2 >= 57344) {
            index -= 1;
          } else if (c2 >= 56320 && c2 <= 57343 && index - 1 > 0) {
            const c1 = string.charCodeAt(index - 2);
            if (c1 >= 55296 && c1 <= 57343) {
              index -= 2;
            } else {
              index -= 1;
            }
          } else {
            index -= 1;
          }
          count -= 1;
        }
      }
      return index;
    };
    return Strings;
  }();
  const Identifiers = function() {
    const Identifiers = {};
    Identifiers.isStartChar = function(c) {
      return c >= 65 && c <= 90 || c === 95 || c >= 97 && c <= 122 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 767 || c >= 880 && c <= 893 || c >= 895 && c <= 8191 || c >= 8204 && c <= 8205 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
    };
    Identifiers.isPartChar = function(c) {
      return c === 45 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c === 95 || c >= 97 && c <= 122 || c === 183 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 893 || c >= 895 && c <= 8191 || c >= 8204 && c <= 8205 || c >= 8255 && c <= 8256 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
    };
    Identifiers.isValid = function(identifier) {
      const n = identifier.length;
      if (n !== 0) {
        let c = identifier.codePointAt(0);
        if (c !== void 0 && Identifiers.isStartChar(c)) {
          let i = Strings.offsetByCodePoints(identifier, 0, 1);
          while (i < n && (c = identifier.codePointAt(0), c !== void 0 && Identifiers.isPartChar(c))) {
            i = Strings.offsetByCodePoints(identifier, i, 1);
          }
          return i === n && !Identifiers.isReserved(identifier);
        }
      }
      return false;
    };
    Identifiers.isReserved = function(identifier) {
      switch (identifier) {
       case "await":
       case "break":
       case "case":
       case "catch":
       case "class":
       case "const":
       case "continue":
       case "debugger":
       case "default":
       case "delete":
       case "do":
       case "else":
       case "enum":
       case "export":
       case "extends":
       case "false":
       case "finally":
       case "for":
       case "function":
       case "if":
       case "import":
       case "in":
       case "instanceof":
       case "new":
       case "null":
       case "return":
       case "super":
       case "switch":
       case "this":
       case "throw":
       case "true":
       case "try":
       case "typeof":
       case "var":
       case "void":
       case "while":
       case "with":
       case "yield":
        return true;

       default:
        return false;
      }
    };
    return Identifiers;
  }();
  const Functions = function() {
    const Functions = {};
    Functions.compare = function(x, y) {
      if (typeof x === "function") {
        if (typeof y === "function") {
          const xh = Functions.hash(x);
          const yh = Functions.hash(y);
          return xh < yh ? -1 : xh > yh ? 1 : 0;
        } else {
          return -1;
        }
      } else if (x === null) {
        return y === void 0 ? -1 : y === null ? 0 : 1;
      } else if (x === void 0) {
        return y === void 0 ? 0 : 1;
      } else {
        return NaN;
      }
    };
    let nextId = -1;
    Functions.hash = function(x) {
      if (typeof x === "function") {
        let hashCode = x._hashCode;
        if (hashCode === void 0) {
          hashCode = ~~nextId;
          nextId -= 1;
          Object.defineProperty(x, "_hashCode", {
            value: hashCode,
            configurable: true
          });
        }
        return hashCode;
      } else if (x === null) {
        return 1;
      } else if (x === void 0) {
        return 0;
      } else {
        throw new TypeError("" + x);
      }
    };
    return Functions;
  }();
  const Constructors = function() {
    const Constructors = {};
    Constructors.compare = function(x, y) {
      if (typeof x === "function") {
        if (typeof y === "function") {
          const xh = Constructors.hash(x);
          const yh = Constructors.hash(y);
          return xh < yh ? -1 : xh > yh ? 1 : 0;
        } else {
          return -1;
        }
      } else if (x === null) {
        return y === void 0 ? -1 : y === null ? 0 : 1;
      } else if (x === void 0) {
        return y === void 0 ? 0 : 1;
      } else {
        return NaN;
      }
    };
    Constructors.hash = function(x) {
      if (typeof x === "function") {
        let hashCode = x._hashCode;
        if (hashCode === void 0) {
          hashCode = Murmur3.mash(Murmur3.mixString(0, x.name));
          Object.defineProperty(x, "_hashCode", {
            value: hashCode,
            configurable: true
          });
        }
        return hashCode;
      } else if (x === null) {
        return 1;
      } else if (x === void 0) {
        return 0;
      } else {
        throw new TypeError("" + x);
      }
    };
    return Constructors;
  }();
  const Equals = function() {
    const Equals = function(x, y) {
      if (x === y) {
        return true;
      } else if (x !== void 0 && x !== null && typeof x.equals === "function") {
        return x.equals(y);
      }
      return false;
    };
    Equals.is = function(object) {
      return object !== void 0 && object !== null && typeof object.equals === "function";
    };
    return Equals;
  }();
  const HashCode = function() {
    const HashCode = function(x) {
      if (x === void 0) {
        return 0;
      } else if (x === null) {
        return 1;
      } else {
        return x.hashCode();
      }
    };
    HashCode.is = function(object) {
      return object !== void 0 && object !== null && typeof object.hashCode === "function";
    };
    return HashCode;
  }();
  const Compare = function() {
    const Compare = function(x, y) {
      if (x === void 0) {
        if (y === void 0) {
          return 0;
        } else {
          return 1;
        }
      } else if (x === null) {
        if (y === void 0) {
          return -1;
        } else if (y === null) {
          return 0;
        } else {
          return 1;
        }
      } else if (typeof x.compareTo === "function") {
        if (y === void 0 || y === null) {
          return -1;
        } else {
          return x.compareTo(y);
        }
      } else {
        return NaN;
      }
    };
    Compare.is = function(object) {
      return object !== void 0 && object !== null && typeof object.compareTo === "function";
    };
    return Compare;
  }();
  const Objects = function() {
    const Objects = {};
    Objects.equal = function(x, y) {
      if (x === y) {
        return true;
      } else if (typeof x === "object" && x !== null && typeof y === "object" && y !== null) {
        const xKeys = Object.keys(x);
        const yKeys = Object.keys(y);
        const n = xKeys.length;
        if (n !== yKeys.length) {
          return false;
        }
        for (let i = 0; i < n; i += 1) {
          const key = xKeys[i];
          if (key !== yKeys[i] || !Values.equal(x[key], y[key])) {
            return false;
          }
        }
        return true;
      }
      return false;
    };
    Objects.equivalent = function(x, y, epsilon) {
      if (x === y) {
        return true;
      } else if (typeof x === "object" && x !== null && typeof y === "object" && y !== null) {
        const xKeys = Object.keys(x);
        const yKeys = Object.keys(y);
        const n = xKeys.length;
        if (n !== yKeys.length) {
          return false;
        }
        for (let i = 0; i < n; i += 1) {
          const key = xKeys[i];
          if (key !== yKeys[i] || !Values.equivalent(x[key], y[key], epsilon)) {
            return false;
          }
        }
        return true;
      }
      return false;
    };
    Objects.compare = function(x, y) {
      if (typeof x === "object" && x !== null) {
        if (typeof y === "object" && y !== null) {
          if (x !== y) {
            const xKeys = Object.keys(x);
            const yKeys = Object.keys(y);
            const p = xKeys.length;
            const q = yKeys.length;
            const n = Math.min(p, q);
            let order = 0;
            for (let i = 0; i < n && order === 0; i += 1) {
              const xKey = xKeys[i];
              const yKey = yKeys[i];
              order = Strings.compare(xKey, yKey);
              if (order === 0) {
                order = Values.compare(x[xKey], y[yKey]);
              }
            }
            return order !== 0 ? order : p > q ? 1 : p < q ? -1 : 0;
          } else {
            return 0;
          }
        } else {
          return -1;
        }
      } else if (x === null) {
        return y === void 0 ? -1 : y === null ? 0 : 1;
      } else if (x === void 0) {
        return y === void 0 ? 0 : 1;
      } else {
        return NaN;
      }
    };
    Objects.hash = function(x) {
      if (typeof x === "object" && x !== null) {
        let hashValue = 0;
        const keys = Object.keys(x);
        for (let i = 0, n = keys.length; i < n; i += 1) {
          const key = keys[i];
          hashValue = Murmur3.mix(Murmur3.mix(hashValue, Strings.hash(key)), Values.hash(x[key]));
        }
        return Murmur3.mash(hashValue);
      } else if (x === null) {
        return 1;
      } else if (x === void 0) {
        return 0;
      } else {
        throw new TypeError("" + x);
      }
    };
    return Objects;
  }();
  const Values = function() {
    const Values = {};
    Values.equal = function(x, y) {
      if (x instanceof Date) {
        x = x.getTime();
      }
      if (y instanceof Date) {
        y = y.getTime();
      }
      if (x === y) {
        return true;
      } else if (typeof x === "number") {
        if (typeof y === "number") {
          return isNaN(x) && isNaN(y);
        }
      } else if (Equals.is(x)) {
        return x.equals(y);
      } else if (Array.isArray(x)) {
        if (Array.isArray(y)) {
          return Arrays.equal(x, y);
        }
      } else if (typeof x === "object" && x !== null) {
        if (typeof y === "object" && y !== null) {
          return Objects.equal(x, y);
        }
      }
      return false;
    };
    Values.hash = function(x) {
      if (x === void 0) {
        return 0;
      } else if (x === null) {
        return 1;
      } else if (x === false) {
        return 2;
      } else if (x === true) {
        return 3;
      } else if (typeof x === "number") {
        return Numbers.hash(x);
      } else if (typeof x === "string") {
        return Strings.hash(x);
      } else if (HashCode.is(x)) {
        return x.hashCode();
      } else if (typeof x === "function") {
        return Functions.hash(x);
      } else if (Array.isArray(x)) {
        return Arrays.hash(x);
      } else if (typeof x === "object") {
        return Objects.hash(x);
      } else {
        throw new TypeError("" + x);
      }
    };
    Values.equivalent = function(x, y, epsilon = Equivalent.Epsilon) {
      if (x instanceof Date) {
        x = x.getTime();
      }
      if (y instanceof Date) {
        y = y.getTime();
      }
      if (x === y) {
        return true;
      } else if (typeof x === "number") {
        if (typeof y === "number") {
          return isNaN(x) && isNaN(y) || Math.abs(y - x) < epsilon;
        }
      } else if (Equivalent.is(x)) {
        return x.equivalentTo(y, epsilon);
      } else if (Array.isArray(x)) {
        if (Array.isArray(y)) {
          return Arrays.equivalent(x, y, epsilon);
        }
      } else if (typeof x === "object" && x !== null) {
        if (typeof y === "object" && y !== null) {
          return Objects.equivalent(x, y, epsilon);
        }
      }
      return false;
    };
    Values.compare = function(x, y) {
      if (x instanceof Date) {
        x = x.getTime();
      }
      if (y instanceof Date) {
        y = y.getTime();
      }
      if (x === void 0) {
        if (y === void 0) {
          return 0;
        } else {
          return 1;
        }
      } else if (x === null) {
        if (y === void 0) {
          return -1;
        } else if (y === null) {
          return 0;
        } else {
          return 1;
        }
      } else if (typeof x === "boolean") {
        if (y === void 0 || y === null) {
          return -1;
        } else if (typeof y === "boolean") {
          return x && !y ? -1 : !x && y ? 1 : 0;
        } else {
          return 1;
        }
      } else if (typeof x === "number") {
        if (y === void 0 || y === null || typeof y === "boolean") {
          return -1;
        } else if (typeof y === "number") {
          return x < y ? -1 : x > y ? 1 : isNaN(y) ? isNaN(x) ? 0 : -1 : isNaN(x) ? 1 : 0;
        } else {
          return 1;
        }
      } else if (typeof x === "string") {
        if (y === void 0 || y === null || typeof y === "boolean" || typeof y === "number") {
          return -1;
        } else if (typeof y === "string") {
          return x < y ? -1 : x > y ? 1 : 0;
        } else {
          return 1;
        }
      } else if (Compare.is(x)) {
        return x.compareTo(y);
      } else if (typeof x === "function") {
        if (y === void 0 || y === null || typeof y === "boolean" || typeof y === "number" || typeof y === "string") {
          return -1;
        } else if (typeof y === "function") {
          return Functions.compare(x, y);
        } else {
          return 1;
        }
      } else if (Array.isArray(x)) {
        if (y === void 0 || y === null || typeof y === "boolean" || typeof y === "number" || typeof y === "string" || typeof y === "function") {
          return -1;
        } else if (Array.isArray(y)) {
          return Arrays.compare(x, y);
        } else {
          return 1;
        }
      } else if (typeof x === "object") {
        if (y === void 0 || y === null || typeof y === "boolean" || typeof y === "number" || typeof y === "string" || typeof y === "function" || Array.isArray(y)) {
          return -1;
        } else if (typeof y === "object") {
          return Objects.compare(x, y);
        } else {
          return 1;
        }
      } else {
        return NaN;
      }
    };
    return Values;
  }();
  const Arrays = function() {
    const Arrays = {};
    Object.defineProperty(Arrays, "empty", {
      value: Object.freeze([]),
      enumerable: true,
      configurable: true
    });
    Arrays.inserted = function(newElement, oldArray) {
      const n = oldArray !== void 0 && oldArray !== null ? oldArray.length : 0;
      const newArray = new Array(n + 1);
      for (let i = 0; i < n; i += 1) {
        const element = oldArray[i];
        if (element !== newElement) {
          newArray[i] = element;
        } else {
          return oldArray;
        }
      }
      newArray[n] = newElement;
      return newArray;
    };
    Arrays.removed = function(oldElement, oldArray) {
      const n = oldArray !== void 0 && oldArray !== null ? oldArray.length : 0;
      if (n === 0) {
        return oldArray !== void 0 && oldArray !== null ? oldArray : Arrays.empty;
      } else if (n === 1) {
        return oldArray[0] !== oldElement ? oldArray : Arrays.empty;
      } else {
        const newArray = new Array(n - 1);
        let i = 0;
        while (i < n) {
          const element = oldArray[i];
          if (element !== oldElement) {
            newArray[i] = element;
            i += 1;
          } else {
            i += 1;
            while (i < n) {
              newArray[i - 1] = oldArray[i];
              i += 1;
            }
            return newArray;
          }
        }
        return oldArray;
      }
    };
    Arrays.equal = function(x, y) {
      if (x === y) {
        return true;
      } else if (typeof x === "object" && x !== null && typeof y === "object" && y !== null) {
        const n = x.length;
        if (n !== y.length) {
          return false;
        }
        for (let i = 0; i < n; i += 1) {
          if (!Values.equal(x[i], y[i])) {
            return false;
          }
        }
        return true;
      }
      return false;
    };
    Arrays.equivalent = function(x, y, epsilon) {
      if (x === y) {
        return true;
      } else if (typeof x === "object" && x !== null && typeof y === "object" && y !== null) {
        const n = x.length;
        if (n !== y.length) {
          return false;
        }
        for (let i = 0; i < n; i += 1) {
          if (!Values.equivalent(x[i], y[i], epsilon)) {
            return false;
          }
        }
        return true;
      }
      return false;
    };
    Arrays.compare = function(x, y) {
      if (typeof x === "object" && x !== null) {
        if (typeof y === "object" && y !== null) {
          if (x !== y) {
            const p = x.length;
            const q = y.length;
            let order = 0;
            for (let i = 0, n = Math.min(p, q); i < n && order === 0; i += 1) {
              order = Values.compare(x[i], y[i]);
            }
            return order !== 0 ? order : p > q ? 1 : p < q ? -1 : 0;
          } else {
            return 0;
          }
        } else {
          return -1;
        }
      } else if (x === null) {
        return y === void 0 ? -1 : y === null ? 0 : 1;
      } else if (x === void 0) {
        return y === void 0 ? 0 : 1;
      } else {
        return NaN;
      }
    };
    Arrays.hash = function(x) {
      if (typeof x === "object" && x !== null) {
        let hashValue = 0;
        for (let i = 0, n = x.length; i < n; i += 1) {
          hashValue = Murmur3.mix(hashValue, Values.hash(x[i]));
        }
        return Murmur3.mash(hashValue);
      } else if (x === null) {
        return 1;
      } else if (x === void 0) {
        return 0;
      } else {
        throw new TypeError("" + x);
      }
    };
    return Arrays;
  }();
  const FromAny = function() {
    const FromAny = {};
    FromAny.is = function(object) {
      return object !== void 0 && object !== null && typeof object.fromAny === "function";
    };
    return FromAny;
  }();
  const ToAny = function() {
    const ToAny = {};
    ToAny.is = function(object) {
      return object !== void 0 && object !== null && typeof object.toAny === "function";
    };
    return ToAny;
  }();
  const Mapping = function(_super) {
    const Mapping = function(domain, range) {
      const mapping = function(x) {
        return mapping.range(mapping.domain(x));
      };
      Object.setPrototypeOf(mapping, Mapping.prototype);
      mapping.domain = domain;
      mapping.range = range;
      return mapping;
    };
    Mapping.prototype = Object.create(_super.prototype);
    Mapping.prototype.constructor = Mapping;
    Mapping.prototype.equivalentTo = function(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof Mapping) {
        return this.domain.equivalentTo(that.domain, epsilon) && this.range.equivalentTo(that.range, epsilon);
      }
      return false;
    };
    Mapping.prototype.canEqual = function(that) {
      return that instanceof Mapping;
    };
    Mapping.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Mapping) {
        return that.canEqual(this) && this.domain.equals(that.domain) && this.range.equals(that.range);
      }
      return false;
    };
    Mapping.prototype.toString = function() {
      return "Mapping(" + this.domain + ", " + this.range + ")";
    };
    return Mapping;
  }(Function);
  const Domain = function(_super) {
    const Domain = function(x0, x1) {
      const domain = function(x) {
        return Values.equal(x, domain[1]) ? 1 : 0;
      };
      Object.setPrototypeOf(domain, Domain.prototype);
      domain[0] = x0;
      domain[1] = x1;
      return domain;
    };
    Domain.prototype = Object.create(_super.prototype);
    Domain.prototype.constructor = Domain;
    Object.defineProperty(Domain.prototype, "domain", {
      get() {
        return this;
      },
      configurable: true
    });
    Object.defineProperty(Domain.prototype, "range", {
      get() {
        return Range.unit;
      },
      configurable: true
    });
    Domain.prototype.contains = function(x) {
      return Values.compare(this[0], x) <= 0 && Values.compare(x, this[1]) <= 0;
    };
    Domain.prototype.equivalentTo = function(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof Domain) {
        return Values.equivalent(this[0], that[0], epsilon) && Values.equivalent(this[1], that[1], epsilon);
      }
      return false;
    };
    Domain.prototype.canEqual = function(that) {
      return that instanceof Domain;
    };
    Domain.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Domain) {
        return that.canEqual(this) && Values.equal(this[0], that[0]) && Values.equal(this[1], that[1]);
      }
      return false;
    };
    Domain.prototype.toString = function() {
      return "Domain(" + this[0] + ", " + this[1] + ")";
    };
    Object.defineProperty(Domain, "unit", {
      get() {
        const value = LinearDomain(0, 1);
        Object.defineProperty(Domain, "unit", {
          value: value,
          enumerable: true,
          configurable: true
        });
        return value;
      },
      enumerable: true,
      configurable: true
    });
    return Domain;
  }(Mapping);
  const Range = function(_super) {
    const Range = function(y0, y1) {
      const range = function(u) {
        return u < 1 ? range[0] : range[1];
      };
      Object.setPrototypeOf(range, Range.prototype);
      range[0] = y0;
      range[1] = y1;
      return range;
    };
    Range.prototype = Object.create(_super.prototype);
    Range.prototype.constructor = Range;
    Object.defineProperty(Range.prototype, "domain", {
      get() {
        return Domain.unit;
      },
      configurable: true
    });
    Object.defineProperty(Range.prototype, "range", {
      get() {
        return this;
      },
      configurable: true
    });
    Range.prototype.equivalentTo = function(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof Range) {
        return Values.equivalent(this[0], that[0], epsilon) && Values.equivalent(this[1], that[1], epsilon);
      }
      return false;
    };
    Range.prototype.canEqual = function(that) {
      return that instanceof Range;
    };
    Range.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Range) {
        return that.canEqual(this) && Values.equal(this[0], that[0]) && Values.equal(this[1], that[1]);
      }
      return false;
    };
    Range.prototype.toString = function() {
      return "Range(" + this[0] + ", " + this[1] + ")";
    };
    Object.defineProperty(Range, "unit", {
      get() {
        const value = LinearRange(0, 1);
        Object.defineProperty(Range, "unit", {
          value: value,
          enumerable: true,
          configurable: true
        });
        return value;
      },
      enumerable: true,
      configurable: true
    });
    return Range;
  }(Mapping);
  const Interpolate = function() {
    const Interpolate = function(x, y) {
      if (x !== void 0 && x !== null && typeof x.interpolateTo === "function") {
        return x.interpolateTo(y);
      } else {
        return null;
      }
    };
    Interpolate.is = function(object) {
      return object !== void 0 && object !== null && typeof object.interpolateTo === "function";
    };
    return Interpolate;
  }();
  const Interpolator = function(_super) {
    const Interpolator = function(y0, y1) {
      let interpolator;
      if (y0 === y1) {
        interpolator = IdentityInterpolator(y0);
      } else if (typeof y0 === "number" && typeof y1 === "number") {
        interpolator = NumberInterpolator(y0, y1);
      } else if (Array.isArray(y0) && Array.isArray(y1)) {
        interpolator = ArrayInterpolator(y0, y1);
      } else {
        interpolator = Interpolate(y0, y1);
        if (interpolator === null) {
          interpolator = StepInterpolator(y0, y1);
        }
      }
      return interpolator;
    };
    Interpolator.prototype = Object.create(_super.prototype);
    Interpolator.prototype.constructor = Interpolator;
    Interpolator.prototype.map = function(transform) {
      return InterpolatorMap(this, transform);
    };
    Interpolator.prototype.interpolateTo = function(that) {
      if (that instanceof Interpolator) {
        return InterpolatorInterpolator(this, that);
      }
      return null;
    };
    Interpolator.prototype.canEqual = function(that) {
      return that instanceof this.constructor;
    };
    Interpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Interpolator) {
        return that.canEqual(this) && Values.equal(this[0], that[0]) && Values.equal(this[1], that[1]);
      }
      return false;
    };
    Interpolator.prototype.toString = function() {
      return "Interpolator(" + this[0] + ", " + this[1] + ")";
    };
    return Interpolator;
  }(Range);
  const InterpolatorMap = function(_super) {
    const InterpolatorMap = function(interpolator, transform) {
      const map = function(u) {
        return map.transform(map.interpolator(u));
      };
      Object.setPrototypeOf(map, InterpolatorMap.prototype);
      map.interpolator = interpolator;
      map.transform = transform;
      return map;
    };
    InterpolatorMap.prototype = Object.create(_super.prototype);
    InterpolatorMap.prototype.constructor = InterpolatorMap;
    Object.defineProperty(InterpolatorMap.prototype, 0, {
      get() {
        return this.transform(this.interpolator[0]);
      },
      configurable: true
    });
    Object.defineProperty(InterpolatorMap.prototype, 1, {
      get() {
        return this.transform(this.interpolator[1]);
      },
      configurable: true
    });
    InterpolatorMap.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof InterpolatorMap) {
        return this.interpolator.equals(that.interpolator) && this.transform === that.transform;
      }
      return false;
    };
    return InterpolatorMap;
  }(Interpolator);
  const IdentityInterpolator = function(_super) {
    const IdentityInterpolator = function(value) {
      const interpolator = function(u) {
        return interpolator.value;
      };
      Object.setPrototypeOf(interpolator, IdentityInterpolator.prototype);
      interpolator.value = value;
      return interpolator;
    };
    IdentityInterpolator.prototype = Object.create(_super.prototype);
    IdentityInterpolator.prototype.constructor = IdentityInterpolator;
    Object.defineProperty(IdentityInterpolator.prototype, 0, {
      get() {
        return this.value;
      },
      configurable: true
    });
    Object.defineProperty(IdentityInterpolator.prototype, 1, {
      get() {
        return this.value;
      },
      configurable: true
    });
    IdentityInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof IdentityInterpolator) {
        return this.value === that.value;
      }
      return false;
    };
    return IdentityInterpolator;
  }(Interpolator);
  const StepInterpolator = function(_super) {
    const StepInterpolator = function(y0, y1) {
      const interpolator = function(u) {
        return u < 1 ? interpolator[0] : interpolator[1];
      };
      Object.setPrototypeOf(interpolator, StepInterpolator.prototype);
      interpolator[0] = y0;
      interpolator[1] = y1;
      return interpolator;
    };
    StepInterpolator.prototype = Object.create(_super.prototype);
    StepInterpolator.prototype.constructor = StepInterpolator;
    return StepInterpolator;
  }(Interpolator);
  const NumberInterpolator = function(_super) {
    const NumberInterpolator = function(y0, y1) {
      const interpolator = function(u) {
        const y0 = interpolator[0];
        const y1 = interpolator[1];
        return y0 + u * (y1 - y0);
      };
      Object.setPrototypeOf(interpolator, NumberInterpolator.prototype);
      interpolator[0] = y0;
      interpolator[1] = y1;
      return interpolator;
    };
    NumberInterpolator.prototype = Object.create(_super.prototype);
    NumberInterpolator.prototype.constructor = NumberInterpolator;
    return NumberInterpolator;
  }(Interpolator);
  const ArrayInterpolator = function(_super) {
    const ArrayInterpolator = function(y0, y1) {
      const interpolator = function(u) {
        const interpolators = interpolator.interpolators;
        const interpolatorCount = interpolators.length;
        const array = new Array(interpolatorCount);
        for (let i = 0; i < interpolatorCount; i += 1) {
          array[i] = interpolators[i](u);
        }
        return array;
      };
      Object.setPrototypeOf(interpolator, ArrayInterpolator.prototype);
      const interpolatorCount = Math.min(y0.length, y1.length);
      const interpolators = new Array(interpolatorCount);
      for (let i = 0; i < interpolatorCount; i += 1) {
        interpolators[i] = Interpolator(y0[i], y1[i]);
      }
      interpolator.interpolators = interpolators;
      return interpolator;
    };
    ArrayInterpolator.prototype = Object.create(_super.prototype);
    ArrayInterpolator.prototype.constructor = ArrayInterpolator;
    Object.defineProperty(ArrayInterpolator.prototype, 0, {
      get() {
        const interpolators = this.interpolators;
        const interpolatorCount = interpolators.length;
        const array = new Array(interpolatorCount);
        for (let i = 0; i < interpolatorCount; i += 1) {
          array[i] = interpolators[i][0];
        }
        return array;
      },
      configurable: true
    });
    Object.defineProperty(ArrayInterpolator.prototype, 1, {
      get() {
        const interpolators = this.interpolators;
        const interpolatorCount = interpolators.length;
        const array = new Array(interpolatorCount);
        for (let i = 0; i < interpolatorCount; i += 1) {
          array[i] = interpolators[i][1];
        }
        return array;
      },
      configurable: true
    });
    ArrayInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof ArrayInterpolator) {
        const n = this.interpolators.length;
        if (n === that.interpolators.length) {
          for (let i = 0; i < n; i += 1) {
            if (!this.interpolators[i].equals(that.interpolators[i])) {
              return false;
            }
          }
          return true;
        }
      }
      return false;
    };
    return ArrayInterpolator;
  }(Interpolator);
  const InterpolatorInterpolator = function(_super) {
    const InterpolatorInterpolator = function(y0, y1) {
      const interpolator = function(u) {
        if (u === 0) {
          return interpolator[0];
        } else if (u === 1) {
          return interpolator[1];
        } else {
          return Interpolator(interpolator[0](u), interpolator[1](u));
        }
      };
      Object.setPrototypeOf(interpolator, InterpolatorInterpolator.prototype);
      interpolator[0] = y0;
      interpolator[1] = y1;
      return interpolator;
    };
    InterpolatorInterpolator.prototype = Object.create(_super.prototype);
    InterpolatorInterpolator.prototype.constructor = InterpolatorInterpolator;
    return InterpolatorInterpolator;
  }(Interpolator);
  const Timing = function(_super) {
    const Timing = function(easing, t0, t1) {
      const timing = function(t) {
        const t0 = timing[0];
        const t1 = timing[1];
        return timing.easing(Math.min(Math.max(0, (t - t0) / (t1 - t0)), 1));
      };
      Object.setPrototypeOf(timing, Timing.prototype);
      timing.easing = easing;
      timing[0] = t0;
      timing[1] = t1;
      return timing;
    };
    Timing.prototype = Object.create(_super.prototype);
    Timing.prototype.constructor = Timing;
    Object.defineProperty(Timing.prototype, "duration", {
      get() {
        return this[1] - this[0];
      },
      configurable: true
    });
    Timing.prototype.contains = function(t) {
      return this[0] <= t && t <= this[1];
    };
    Timing.prototype.withDomain = function(t0, t1) {
      return Timing(this.easing, t0, t1);
    };
    Timing.prototype.withDuration = function(dt) {
      const t0 = this[0];
      return Timing(this.easing, t0, t0 + dt);
    };
    Timing.prototype.overRange = function(y0, y1) {
      let range;
      if (arguments.length === 1) {
        range = y0;
      } else {
        range = Interpolator(y0, y1);
      }
      return Tweening(this, range);
    };
    Timing.prototype.equivalentTo = function(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof Timing) {
        return this.easing.equivalentTo(that.easing, epsilon) && Values.equivalent(this[0], that[0], epsilon) && Values.equivalent(this[1], that[1], epsilon);
      }
      return false;
    };
    Timing.prototype.canEqual = function(that) {
      return that instanceof Timing;
    };
    Timing.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Timing) {
        return that.canEqual(this) && this.easing.equals(that.easing) && Values.equal(this[0], that[0]) && Values.equal(this[1], that[1]);
      }
      return false;
    };
    Timing.prototype.toString = function() {
      return "Timing(" + this.easing + ", " + this[0] + ", " + this[1] + ")";
    };
    Timing.fromInit = function(init) {
      let easing = init.easing;
      if (easing === void 0) {
        easing = Easing.linear;
      } else if (typeof easing === "string") {
        easing = Easing(easing);
      }
      let t0 = init.t0;
      if (t0 === void 0) {
        t0 = 0;
      }
      let t1 = init.t1;
      if (t1 === void 0) {
        const dt = init.dt;
        if (dt !== void 0) {
          t1 = t0 + dt;
        } else {
          t1 = t0;
        }
      }
      return Timing(easing, t0, t1);
    };
    Timing.fromAny = function(value) {
      if (value === void 0 || value === null) {
        return false;
      } else if (value instanceof Timing || typeof value === "boolean") {
        return value;
      } else if (typeof value === "object") {
        return Timing.fromInit(value);
      }
      throw new TypeError("" + value);
    };
    return Timing;
  }(Domain);
  const Easing = function(_super) {
    const Easing = function(type) {
      switch (type) {
       case "linear":
        return Easing.linear;

       case "quad-in":
        return Easing.quadIn;

       case "quad-out":
        return Easing.quadOut;

       case "quad-in-out":
        return Easing.quadInOut;

       case "cubic-in":
        return Easing.cubicIn;

       case "cubic-out":
        return Easing.cubicOut;

       case "cubic-in-out":
        return Easing.cubicInOut;

       case "quart-in":
        return Easing.quartIn;

       case "quart-out":
        return Easing.quartOut;

       case "quart-in-out":
        return Easing.quartInOut;

       case "expo-in":
        return Easing.expoIn;

       case "expo-out":
        return Easing.expoOut;

       case "expo-in-out":
        return Easing.expoInOut;

       case "circ-in":
        return Easing.circIn;

       case "circ-out":
        return Easing.circOut;

       case "circ-in-out":
        return Easing.circInOut;

       case "back-in":
        return Easing.backIn;

       case "back-out":
        return Easing.backOut;

       case "back-in-out":
        return Easing.backInOut;

       case "elastic-in":
        return Easing.elasticIn;

       case "elastic-out":
        return Easing.elasticOut;

       case "elastic-in-out":
        return Easing.elasticInOut;

       case "bounce-in":
        return Easing.bounceIn;

       case "bounce-out":
        return Easing.bounceOut;

       case "bounce-in-out":
        return Easing.bounceInOut;

       default:
        throw new Error("unknown easing: " + type);
      }
    };
    Easing.prototype = Object.create(_super.prototype);
    Easing.prototype.constructor = Easing;
    Object.defineProperty(Easing.prototype, 0, {
      value: 0
    });
    Object.defineProperty(Easing.prototype, 1, {
      value: 1
    });
    Object.defineProperty(Easing.prototype, "easing", {
      get() {
        return this;
      }
    });
    Easing.prototype.equivalentTo = function(that, epsilon) {
      return this === that;
    };
    Easing.prototype.canEqual = function(that) {
      return that instanceof Easing;
    };
    Easing.prototype.equals = function(that) {
      return this === that;
    };
    Easing.prototype.toString = function() {
      return 'Easing("' + this.type + '")';
    };
    Easing.fromAny = function(value) {
      if (value instanceof Easing) {
        return value;
      } else if (typeof value === "string") {
        return Easing(value);
      }
      throw new TypeError("" + value);
    };
    Easing.linear = function(u) {
      return u;
    };
    Object.setPrototypeOf(Easing.linear, Easing.prototype);
    Easing.linear.type = "linear";
    Easing.quadIn = function(u) {
      return u * u;
    };
    Object.setPrototypeOf(Easing.quadIn, Easing.prototype);
    Easing.quadIn.type = "quad-in";
    Easing.quadOut = function(u) {
      return u * (2 - u);
    };
    Object.setPrototypeOf(Easing.quadOut, Easing.prototype);
    Easing.quadOut.type = "quad-out";
    Easing.quadInOut = function(u) {
      u *= 2;
      if (u <= 1) {
        u = u * u;
      } else {
        u -= 1;
        u = u * (2 - u);
        u += 1;
      }
      u /= 2;
      return u;
    };
    Object.setPrototypeOf(Easing.quadInOut, Easing.prototype);
    Easing.quadInOut.type = "quad-in-out";
    Easing.cubicIn = function(u) {
      return u * u * u;
    };
    Object.setPrototypeOf(Easing.cubicIn, Easing.prototype);
    Easing.cubicIn.type = "cubic-in";
    Easing.cubicOut = function(u) {
      u -= 1;
      u = u * u * u;
      u += 1;
      return u;
    };
    Object.setPrototypeOf(Easing.cubicOut, Easing.prototype);
    Easing.cubicOut.type = "cubic-out";
    Easing.cubicInOut = function(u) {
      u *= 2;
      if (u <= 1) {
        u = u * u * u;
      } else {
        u -= 2;
        u = u * u * u;
        u += 2;
      }
      u /= 2;
      return u;
    };
    Object.setPrototypeOf(Easing.cubicInOut, Easing.prototype);
    Easing.cubicInOut.type = "cubic-in-out";
    Easing.quartIn = function(u) {
      return u * u * u * u;
    };
    Object.setPrototypeOf(Easing.quartIn, Easing.prototype);
    Easing.quartIn.type = "quart-in";
    Easing.quartOut = function(u) {
      u -= 1;
      return 1 - u * u * u * u;
    };
    Object.setPrototypeOf(Easing.quartOut, Easing.prototype);
    Easing.quartOut.type = "quart-out";
    Easing.quartInOut = function(u) {
      const v = u - 1;
      return u < .5 ? 8 * u * u * u * u : 1 - 8 * v * v * v * v;
    };
    Object.setPrototypeOf(Easing.quartInOut, Easing.prototype);
    Easing.quartInOut.type = "quart-in-out";
    Easing.expoIn = function(u) {
      if (u === 0) {
        return 0;
      }
      return Math.pow(2, 10 * (u - 1));
    };
    Object.setPrototypeOf(Easing.expoIn, Easing.prototype);
    Easing.expoIn.type = "expo-in";
    Easing.expoOut = function(u) {
      if (u === 1) {
        return 1;
      }
      return -Math.pow(2, -10 * u) + 1;
    };
    Object.setPrototypeOf(Easing.expoOut, Easing.prototype);
    Easing.expoOut.type = "expo-out";
    Easing.expoInOut = function(u) {
      if (u === 1 || u === 0) {
        return u;
      }
      u *= 2;
      if (u < 1) {
        return .5 * Math.pow(2, 10 * (u - 1));
      }
      return .5 * (-Math.pow(2, -10 * (u - 1)) + 2);
    };
    Object.setPrototypeOf(Easing.expoInOut, Easing.prototype);
    Easing.expoInOut.type = "expo-in-out";
    Easing.circIn = function(u) {
      return -1 * (Math.sqrt(1 - u / 1 * u) - 1);
    };
    Object.setPrototypeOf(Easing.circIn, Easing.prototype);
    Easing.circIn.type = "circ-in";
    Easing.circOut = function(u) {
      u -= 1;
      return Math.sqrt(1 - u * u);
    };
    Object.setPrototypeOf(Easing.circOut, Easing.prototype);
    Easing.circOut.type = "circ-out";
    Easing.circInOut = function(u) {
      u *= 2;
      if (u < 1) {
        return -.5 * (Math.sqrt(1 - u * u) - 1);
      }
      const st = u - 2;
      return .5 * (Math.sqrt(1 - st * st) + 1);
    };
    Object.setPrototypeOf(Easing.circInOut, Easing.prototype);
    Easing.circInOut.type = "circ-in-out";
    Easing.backIn = function(u) {
      const m = 1.70158;
      return u * u * ((m + 1) * u - m);
    };
    Object.setPrototypeOf(Easing.backIn, Easing.prototype);
    Easing.backIn.type = "back-in";
    Easing.backOut = function(u) {
      const m = 1.70158;
      const st = u / 1 - 1;
      return st * st * ((m + 1) * m + m) + 1;
    };
    Object.setPrototypeOf(Easing.backOut, Easing.prototype);
    Easing.backOut.type = "back-out";
    Easing.backInOut = function(u) {
      const m = 1.70158;
      const s = m * 1.525;
      if ((u *= 2) < 1) {
        return .5 * u * u * ((s + 1) * u - s);
      }
      const st = u - 2;
      return .5 * (st * st * ((s + 1) * st + s) + 2);
    };
    Object.setPrototypeOf(Easing.backInOut, Easing.prototype);
    Easing.backInOut.type = "back-in-out";
    Easing.elasticIn = function(u) {
      if (u === 0 || u === 1) {
        return u;
      }
      const m = .7;
      const st = u / 1 - 1;
      const s = (1 - m) / 2 * Math.PI * Math.asin(1);
      return -(Math.pow(2, 10 * st) * Math.sin((st - s) * 2 * Math.PI / (1 - m)));
    };
    Object.setPrototypeOf(Easing.elasticIn, Easing.prototype);
    Easing.elasticIn.type = "elastic-in";
    Easing.elasticOut = function(u) {
      if (u === 0 || u === 1) {
        return u;
      }
      const m = .7;
      const s = (1 - m) / (2 * Math.PI) * Math.asin(1);
      u *= 2;
      return Math.pow(2, -10 * u) * Math.sin((u - s) * 2 * Math.PI / (1 - m)) + 1;
    };
    Object.setPrototypeOf(Easing.elasticOut, Easing.prototype);
    Easing.elasticOut.type = "elastic-out";
    Easing.elasticInOut = function(u) {
      if (u === 0 || u === 1) {
        return u;
      }
      const m = .65;
      const s = (1 - m) / (2 * Math.PI) * Math.asin(1);
      const st = u * 2;
      const st1 = st - 1;
      if (st < 1) {
        return -.5 * (Math.pow(2, 10 * st1) * Math.sin((st1 - s) * 2 * Math.PI / (1 - m)));
      }
      return Math.pow(2, -10 * st1) * Math.sin((st1 - s) * 2 * Math.PI / (1 - m)) * .5 + 1;
    };
    Object.setPrototypeOf(Easing.elasticInOut, Easing.prototype);
    Easing.elasticInOut.type = "elastic-in-out";
    Easing.bounceIn = function(u) {
      const p = 7.5625;
      if ((u = 1 - u) < 1 / 2.75) {
        return 1 - p * u * u;
      } else if (u < 2 / 2.75) {
        return 1 - (p * (u -= 1.5 / 2.75) * u + .75);
      } else if (u < 2.5 / 2.75) {
        return 1 - (p * (u -= 2.25 / 2.75) * u + .9375);
      }
      return 1 - (p * (u -= 2.625 / 2.75) * u + .984375);
    };
    Object.setPrototypeOf(Easing.bounceIn, Easing.prototype);
    Easing.bounceIn.type = "bounce-in";
    Easing.bounceOut = function(u) {
      const p = 7.5625;
      if (u < 1 / 2.75) {
        return p * u * u;
      } else if (u < 2 / 2.75) {
        return p * (u -= 1.5 / 2.75) * u + .75;
      } else if (u < 2.5 / 2.75) {
        return p * (u -= 2.25 / 2.75) * u + .9375;
      }
      return p * (u -= 2.625 / 2.75) * u + .984375;
    };
    Object.setPrototypeOf(Easing.bounceOut, Easing.prototype);
    Easing.bounceOut.type = "bounce-out";
    Easing.bounceInOut = function(u) {
      const invert = u < .5;
      u = invert ? 1 - u * 2 : u * 2 - 1;
      const p = 7.5625;
      if (u < 1 / 2.75) {
        u = p * u * u;
      } else if (u < 2 / 2.75) {
        u = p * (u -= 1.5 / 2.75) * u + .75;
      } else if (u < 2.5 / 2.75) {
        u = p * (u -= 2.25 / 2.75) * u + .9375;
      } else {
        u = p * (u -= 2.625 / 2.75) * u + .984375;
      }
      return invert ? (1 - u) * .5 : u * .5 + .5;
    };
    Object.setPrototypeOf(Easing.bounceInOut, Easing.prototype);
    Easing.bounceInOut.type = "bounce-in-out";
    return Easing;
  }(Timing);
  const Tweening = function(_super) {
    const Tweening = function(domain, range) {
      const tweening = function(u) {
        return tweening.range(tweening.domain(u));
      };
      Object.setPrototypeOf(tweening, Tweening.prototype);
      tweening.domain = domain;
      tweening.range = range;
      return tweening;
    };
    Tweening.prototype = Object.create(_super.prototype);
    Tweening.prototype.constructor = Tweening;
    Tweening.prototype.withDomain = function(t0, t1) {
      return this.domain.withDomain(t0, t1).overRange(this.range);
    };
    Tweening.prototype.canEqual = function(that) {
      return that instanceof Tweening;
    };
    Tweening.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Tweening) {
        return this.domain.equals(that.domain) && this.range.equals(that.range);
      }
      return false;
    };
    Tweening.prototype.toString = function() {
      return "Tweening(" + this.domain + ", " + this.range + ")";
    };
    return Tweening;
  }(Mapping);
  const LinearDomain = function(_super) {
    const LinearDomain = function(x0, x1) {
      const domain = function(x) {
        const x0 = domain[0];
        const x1 = domain[1];
        const dx = x1 - x0;
        return dx !== 0 ? (x - x0) / dx : 0;
      };
      Object.setPrototypeOf(domain, LinearDomain.prototype);
      domain[0] = x0;
      domain[1] = x1;
      return domain;
    };
    LinearDomain.prototype = Object.create(_super.prototype);
    LinearDomain.prototype.constructor = LinearDomain;
    Object.defineProperty(LinearDomain.prototype, "inverse", {
      get() {
        return LinearRange(this[0], this[1]);
      },
      configurable: true
    });
    LinearDomain.prototype.contains = function(x) {
      return this[0] <= x && x <= this[1];
    };
    LinearDomain.prototype.interpolateTo = function(that) {
      if (that instanceof LinearDomain) {
        return LinearDomainInterpolator(this, that);
      }
      return null;
    };
    LinearDomain.prototype.canEqual = function(that) {
      return that instanceof LinearDomain;
    };
    LinearDomain.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof LinearDomain) {
        return that.canEqual(this) && this[0] === that[0] && this[1] === that[1];
      }
      return false;
    };
    LinearDomain.prototype.toString = function() {
      return "LinearDomain(" + this[0] + ", " + this[1] + ")";
    };
    return LinearDomain;
  }(Domain);
  const LinearDomainInterpolator = function(_super) {
    const LinearDomainInterpolator = function(x0, x1) {
      const interpolator = function(u) {
        const x0 = interpolator[0];
        const x00 = x0[0];
        const x01 = x0[1];
        const x1 = interpolator[1];
        const x10 = x1[0];
        const x11 = x1[1];
        return LinearDomain(x00 + u * (x10 - x00), x01 + u * (x11 - x01));
      };
      Object.setPrototypeOf(interpolator, LinearDomainInterpolator.prototype);
      interpolator[0] = x0;
      interpolator[1] = x1;
      return interpolator;
    };
    LinearDomainInterpolator.prototype = Object.create(_super.prototype);
    LinearDomainInterpolator.prototype.constructor = LinearDomainInterpolator;
    return LinearDomainInterpolator;
  }(Interpolator);
  const LinearRange = function(_super) {
    const LinearRange = function(y0, y1) {
      const range = function(u) {
        const y0 = range[0];
        const y1 = range[1];
        return y0 + u * (y1 - y0);
      };
      Object.setPrototypeOf(range, LinearRange.prototype);
      range[0] = y0;
      range[1] = y1;
      return range;
    };
    LinearRange.prototype = Object.create(_super.prototype);
    LinearRange.prototype.constructor = LinearRange;
    Object.defineProperty(LinearRange.prototype, "inverse", {
      get() {
        return LinearDomain(this[0], this[1]);
      },
      configurable: true
    });
    LinearRange.prototype.interpolateTo = function(that) {
      if (that instanceof LinearRange) {
        return LinearRangeInterpolator(this, that);
      }
      return null;
    };
    LinearRange.prototype.canEqual = function(that) {
      return that instanceof LinearRange;
    };
    LinearRange.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof LinearRange) {
        return that.canEqual(this) && this[0] === that[0] && this[1] === that[1];
      }
      return false;
    };
    LinearRange.prototype.toString = function() {
      return "LinearRange(" + this[0] + ", " + this[1] + ")";
    };
    return LinearRange;
  }(Range);
  const LinearRangeInterpolator = function(_super) {
    const LinearRangeInterpolator = function(y0, y1) {
      const interpolator = function(u) {
        const y0 = interpolator[0];
        const y00 = y0[0];
        const y01 = y0[1];
        const y1 = interpolator[1];
        const y10 = y1[0];
        const y11 = y1[1];
        return LinearRange(y00 + u * (y10 - y00), y01 + u * (y11 - y01));
      };
      Object.setPrototypeOf(interpolator, LinearRangeInterpolator.prototype);
      interpolator[0] = y0;
      interpolator[1] = y1;
      return interpolator;
    };
    LinearRangeInterpolator.prototype = Object.create(_super.prototype);
    LinearRangeInterpolator.prototype.constructor = LinearRangeInterpolator;
    return LinearRangeInterpolator;
  }(Interpolator);
  const Scale = function(_super) {
    const Scale = function() {
      throw new Error;
    };
    Scale.prototype = Object.create(_super.prototype);
    Scale.prototype.constructor = Scale;
    Scale.prototype.canEqual = function(that) {
      return that instanceof Scale;
    };
    Scale.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Scale) {
        return this.domain.equals(that.domain) && this.range.equals(that.range);
      }
      return false;
    };
    Scale.prototype.toString = function() {
      return "Scale(" + this.domain + ", " + this.range + ")";
    };
    return Scale;
  }(Mapping);
  const ContinuousScale = function(_super) {
    const ContinuousScale = function() {
      throw new Error;
    };
    ContinuousScale.prototype = Object.create(_super.prototype);
    ContinuousScale.prototype.constructor = ContinuousScale;
    ContinuousScale.prototype.canEqual = function(that) {
      return that instanceof ContinuousScale;
    };
    ContinuousScale.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof ContinuousScale) {
        return this.domain.equals(that.domain) && this.range.equals(that.range);
      }
      return false;
    };
    ContinuousScale.prototype.toString = function() {
      return "ContinuousScale(" + this.domain + ", " + this.range + ")";
    };
    return ContinuousScale;
  }(Scale);
  const LinearScale = function(_super) {
    const LinearScale = function(domain, range) {
      const scale = function(x) {
        return scale.range(scale.domain(x));
      };
      Object.setPrototypeOf(scale, LinearScale.prototype);
      scale.domain = domain;
      scale.range = range;
      return scale;
    };
    LinearScale.prototype = Object.create(_super.prototype);
    LinearScale.prototype.constructor = LinearScale;
    Object.defineProperty(LinearScale.prototype, "inverse", {
      get() {
        return LinearScale(this.range.inverse, this.domain.inverse);
      },
      configurable: true
    });
    LinearScale.prototype.withDomain = function(x0, x1) {
      let domain;
      if (arguments.length === 1) {
        domain = x0;
      } else {
        domain = LinearDomain(x0, x1);
      }
      return LinearScale(domain, this.range);
    };
    LinearScale.prototype.overRange = function(y0, y1) {
      let range;
      if (arguments.length === 1) {
        range = y0;
      } else {
        range = LinearRange(y0, y1);
      }
      return LinearScale(this.domain, range);
    };
    LinearScale.prototype.clampDomain = function(xMin, xMax, zMin, zMax, epsilon) {
      if (epsilon === void 0) {
        epsilon = Equivalent.Epsilon;
      }
      let x0 = this.domain[0];
      let x1 = this.domain[1];
      if (xMin !== void 0 && xMax !== void 0 && Math.abs(x1 - x0) > xMax - xMin) {
        if (x0 < x1) {
          x0 = xMin;
          x1 = xMax;
        } else {
          x1 = xMin;
          x0 = xMax;
        }
      } else {
        if (xMin !== void 0) {
          if (x0 < x1 && x0 < xMin) {
            x1 += xMin - x0;
            x0 = xMin;
          } else if (x1 < x0 && x1 < xMin) {
            x0 += xMin - x1;
            x1 = xMin;
          }
        }
        if (xMax !== void 0) {
          if (x0 < x1 && x1 > xMax) {
            x0 -= x1 - xMax;
            x1 = xMax;
          } else if (x1 < x0 && x0 > xMax) {
            x1 -= x0 - xMax;
            x0 = xMax;
          }
        }
      }
      const y0 = this(x0);
      const y1 = this(x1);
      const dy = y0 < y1 ? y1 - y0 : y0 - y1;
      const z = Math.abs(dy / (x1 - x0));
      if (zMin !== void 0 && z < 1 / zMin) {
        const dz = dy * zMin;
        const xSum = x0 + x1;
        x0 = (xSum - dz) / 2;
        x1 = (xSum + dz) / 2;
      } else if (zMax !== void 0 && z > 1 / zMax) {
        const dz = dy * zMax;
        const xSum = x0 + x1;
        x0 = (xSum - dz) / 2;
        x1 = (xSum + dz) / 2;
      }
      if (Math.abs(x0 - this.domain[0]) < epsilon && Math.abs(x1 - this.domain[1]) < epsilon) {
        return this;
      } else {
        return LinearScale(LinearDomain(x0, x1), this.range);
      }
    };
    LinearScale.prototype.solveDomain = function(x1, y1, x2, y2, reflect, epsilon) {
      if (epsilon === void 0) {
        epsilon = Equivalent.Epsilon;
      }
      const dx = this.domain[1] - this.domain[0];
      const y0 = this.range[0];
      const y3 = this.range[1];
      let m;
      if (x2 === void 0 || y2 === void 0 || Math.abs(x2 - x1) < epsilon || Math.abs(y2 - y1) < epsilon) {
        m = (y3 - y0) / (dx !== 0 ? dx : epsilon);
      } else {
        m = (y2 - y1) / (x2 - x1);
        if ((reflect === void 0 || !reflect) && m < 0 !== (y3 - y0) / dx < 0) {
          m = -m;
        }
      }
      const b = y1 - m * x1;
      const x0 = (y0 - b) / m;
      const x3 = (y3 - b) / m;
      if (Math.abs(x0 - this.domain[0]) < epsilon && Math.abs(x3 - this.domain[1]) < epsilon) {
        return this;
      } else {
        return LinearScale(LinearDomain(x0, x3), this.range);
      }
    };
    LinearScale.prototype.interpolateTo = function(that) {
      if (that instanceof LinearScale) {
        return LinearScaleInterpolator(this, that);
      }
      return null;
    };
    LinearScale.prototype.canEqual = function(that) {
      return that instanceof LinearScale;
    };
    LinearScale.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof LinearScale) {
        return this.domain.equals(that.domain) && this.range.equals(that.range);
      }
      return false;
    };
    LinearScale.prototype.toString = function() {
      return "LinearScale(" + this.domain + ", " + this.range + ")";
    };
    return LinearScale;
  }(ContinuousScale);
  const LinearScaleInterpolator = function(_super) {
    const LinearScaleInterpolator = function(s0, s1) {
      const interpolator = function(u) {
        const s0 = interpolator[0];
        const s1 = interpolator[1];
        const x0 = s0.domain;
        const x00 = x0[0];
        const x01 = x0[1];
        const x1 = s1.domain;
        const x10 = x1[0];
        const x11 = x1[1];
        const domain = LinearDomain(x00 + u * (x10 - x00), x01 + u * (x11 - x01));
        const y0 = s0.range;
        const y00 = y0[0];
        const y01 = y0[1];
        const y1 = s1.range;
        const y10 = y1[0];
        const y11 = y1[1];
        const range = LinearRange(y00 + u * (y10 - y00), y01 + u * (y11 - y01));
        return LinearScale(domain, range);
      };
      Object.setPrototypeOf(interpolator, LinearScaleInterpolator.prototype);
      interpolator[0] = s0;
      interpolator[1] = s1;
      return interpolator;
    };
    LinearScaleInterpolator.prototype = Object.create(_super.prototype);
    LinearScaleInterpolator.prototype.constructor = LinearScaleInterpolator;
    return LinearScaleInterpolator;
  }(Interpolator);
  const Creatable = function() {
    const Creatable = {};
    Creatable.is = function(object) {
      if (typeof object === "object" && object !== null || typeof object === "function") {
        const creatable = object;
        return "create" in creatable;
      }
      return false;
    };
    return Creatable;
  }();
  const Initable = function() {
    const Initable = {};
    Initable.is = function(object) {
      if (typeof object === "object" && object !== null || typeof object === "function") {
        const init = object;
        return "init" in init;
      }
      return false;
    };
    return Initable;
  }();
  const Observable = function() {
    const Observable = {};
    Observable.is = function(object) {
      if (typeof object === "object" && object !== null || typeof object === "function") {
        const observable = object;
        return "observe" in observable;
      }
      return false;
    };
    return Observable;
  }();
  const Consumable = function() {
    const Consumable = {};
    Consumable.is = function(object) {
      if (typeof object === "object" && object !== null || typeof object === "function") {
        const consumable = object;
        return "consume" in consumable;
      }
      return false;
    };
    return Consumable;
  }();
  class Cursor {
    set(newValue) {
      throw new Error("immutable");
    }
    delete() {
      throw new Error("immutable");
    }
    static empty() {
      return new CursorEmpty;
    }
    static unary(value) {
      return new CursorUnary(value);
    }
    static array(array, index, limit) {
      if (index === void 0) {
        index = 0;
      }
      if (limit === void 0) {
        limit = array.length;
      }
      return new CursorArray(array, index, limit);
    }
  }
  __decorate([ Lazy ], Cursor, "empty", null);
  class CursorEmpty extends Cursor {
    isEmpty() {
      return true;
    }
    head() {
      throw new Error("empty");
    }
    step() {
      throw new Error("empty");
    }
    skip(count) {}
    hasNext() {
      return false;
    }
    nextIndex() {
      return 0;
    }
    next() {
      return {
        done: true
      };
    }
    hasPrevious() {
      return false;
    }
    previousIndex() {
      return -1;
    }
    previous() {
      return {
        done: true
      };
    }
  }
  class CursorUnary extends Cursor {
    constructor(value) {
      super();
      this.value = value;
      this.index = 0;
    }
    isEmpty() {
      return this.index !== 0;
    }
    head() {
      if (this.index === 0) {
        return this.value;
      } else {
        throw new Error("empty");
      }
    }
    step() {
      if (this.index === 0) {
        this.index = 1;
      } else {
        throw new Error("empty");
      }
    }
    skip(count) {
      this.index = Math.min(Math.max(0, this.index + count), 1);
    }
    hasNext() {
      return this.index === 0;
    }
    nextIndex() {
      return this.index;
    }
    next() {
      if (this.index === 0) {
        this.index = 1;
        return {
          value: this.value,
          done: true
        };
      } else {
        return {
          done: true
        };
      }
    }
    hasPrevious() {
      return this.index === 1;
    }
    previousIndex() {
      return this.index - 1;
    }
    previous() {
      if (this.index === 1) {
        this.index = 0;
        return {
          value: this.value,
          done: true
        };
      } else {
        return {
          done: true
        };
      }
    }
  }
  class CursorArray extends Cursor {
    constructor(array, index, limit) {
      super();
      this.array = array;
      this.index = index;
      this.limit = limit;
    }
    isEmpty() {
      return this.index >= this.limit;
    }
    head() {
      if (this.index < this.limit) {
        return this.array[this.index];
      } else {
        throw new Error("empty");
      }
    }
    step() {
      const index = this.index;
      if (index < this.limit) {
        this.index += 1;
      } else {
        throw new Error("empty");
      }
    }
    skip(count) {
      this.index = Math.min(this.index + count, this.limit);
    }
    hasNext() {
      return this.index < this.limit;
    }
    nextIndex() {
      return this.index;
    }
    next() {
      const index = this.index;
      if (index < this.limit) {
        this.index += 1;
        return {
          value: this.array[index],
          done: this.index === this.limit
        };
      } else {
        this.index = this.limit;
        return {
          done: true
        };
      }
    }
    hasPrevious() {
      return this.index > 0;
    }
    previousIndex() {
      return this.index - 1;
    }
    previous() {
      const index = this.index - 1;
      if (index >= 0) {
        this.index = index;
        return {
          value: this.array[index],
          done: index === 0
        };
      } else {
        this.index = 0;
        return {
          done: true
        };
      }
    }
  }
  class HashGenCacheMap {
    constructor(size) {
      this.buckets = new Array(size);
      this.gen4Hits = 0;
      this.gen3Hits = 0;
      this.gen2Hits = 0;
      this.gen1Hits = 0;
      this.misses = 0;
    }
    get(key) {
      if (this.buckets.length === 0) {
        return void 0;
      }
      const index = Math.abs(Values.hash(key)) % this.buckets.length;
      const bucket = this.buckets[index];
      if (bucket === void 0) {
        return void 0;
      }
      const gen4Key = bucket.gen4Key;
      if (gen4Key !== void 0 && Values.equal(key, gen4Key)) {
        const gen4Val = bucket.gen4Val;
        if (gen4Val !== void 0) {
          this.gen4Hits += 1;
          bucket.gen4Weight++;
          return gen4Val;
        } else {
          bucket.gen4Key = void 0;
        }
      }
      const gen3Key = bucket.gen3Key;
      if (gen3Key !== void 0 && Values.equal(key, gen3Key)) {
        const gen3Val = bucket.gen3Val;
        if (gen3Val !== void 0) {
          this.gen3Hits += 1;
          if (bucket.gen3Weight++ > bucket.gen4Weight) {
            this.buckets[index] = new HashGenCacheMapBucket(bucket.gen3Key, bucket.gen3Val, bucket.gen3Weight, bucket.gen4Key, bucket.gen4Val, bucket.gen4Weight, bucket.gen2Key, bucket.gen2Val, bucket.gen2Weight, bucket.gen1Key, bucket.gen1Val, bucket.gen1Weight);
          }
          return gen3Val;
        } else {
          bucket.gen3Key = void 0;
        }
      }
      const gen2Key = bucket.gen2Key;
      if (gen2Key !== void 0 && Values.equal(key, gen2Key)) {
        const gen2Val = bucket.gen2Val;
        if (gen2Val !== void 0) {
          this.gen2Hits += 1;
          if (bucket.gen2Weight++ > bucket.gen3Weight) {
            this.buckets[index] = new HashGenCacheMapBucket(bucket.gen4Key, bucket.gen4Val, bucket.gen4Weight, bucket.gen2Key, bucket.gen2Val, bucket.gen2Weight, bucket.gen3Key, bucket.gen3Val, bucket.gen3Weight, bucket.gen1Key, bucket.gen1Val, bucket.gen1Weight);
          }
          return gen2Val;
        } else {
          bucket.gen2Key = void 0;
        }
      }
      const gen1Key = bucket.gen1Key;
      if (gen1Key !== void 0 && Values.equal(key, gen1Key)) {
        const gen1Val = bucket.gen1Val;
        if (gen1Val !== void 0) {
          this.gen1Hits += 1;
          if (bucket.gen1Weight++ > bucket.gen2Weight) {
            this.buckets[index] = new HashGenCacheMapBucket(bucket.gen4Key, bucket.gen4Val, bucket.gen4Weight, bucket.gen3Key, bucket.gen3Val, bucket.gen3Weight, bucket.gen1Key, bucket.gen1Val, bucket.gen1Weight, bucket.gen2Key, bucket.gen2Val, bucket.gen2Weight);
          }
          return gen1Val;
        } else {
          bucket.gen1Key = void 0;
        }
      }
      this.misses += 1;
      return void 0;
    }
    put(key, value) {
      if (this.buckets.length === 0) {
        return value;
      }
      const index = Math.abs(Values.hash(key)) % this.buckets.length;
      const bucket = this.buckets[index] || new HashGenCacheMapBucket;
      let gen4Key = bucket.gen4Key;
      if (gen4Key !== void 0 && Values.equal(key, gen4Key)) {
        const gen4Val = bucket.gen4Val;
        if (gen4Val !== void 0) {
          this.gen4Hits += 1;
          bucket.gen4Weight++;
          return gen4Val;
        } else {
          bucket.gen4Key = void 0;
          gen4Key = void 0;
        }
      }
      let gen3Key = bucket.gen3Key;
      if (gen3Key !== void 0 && Values.equal(key, gen3Key)) {
        const gen3Val = bucket.gen3Val;
        if (gen3Val !== void 0) {
          this.gen3Hits += 1;
          if (bucket.gen3Weight++ > bucket.gen4Weight) {
            this.buckets[index] = new HashGenCacheMapBucket(bucket.gen3Key, bucket.gen3Val, bucket.gen3Weight, bucket.gen4Key, bucket.gen4Val, bucket.gen4Weight, bucket.gen2Key, bucket.gen2Val, bucket.gen2Weight, bucket.gen1Key, bucket.gen1Val, bucket.gen1Weight);
          }
          return gen3Val;
        } else {
          bucket.gen3Key = void 0;
          gen3Key = void 0;
        }
      }
      let gen2Key = bucket.gen2Key;
      if (gen2Key !== void 0 && Values.equal(key, gen2Key)) {
        const gen2Val = bucket.gen2Val;
        if (gen2Val !== void 0) {
          this.gen2Hits += 1;
          if (bucket.gen2Weight++ > bucket.gen3Weight) {
            this.buckets[index] = new HashGenCacheMapBucket(bucket.gen4Key, bucket.gen4Val, bucket.gen4Weight, bucket.gen2Key, bucket.gen2Val, bucket.gen2Weight, bucket.gen3Key, bucket.gen3Val, bucket.gen3Weight, bucket.gen1Key, bucket.gen1Val, bucket.gen1Weight);
          }
          return gen2Val;
        } else {
          bucket.gen2Key = void 0;
          gen2Key = void 0;
        }
      }
      let gen1Key = bucket.gen1Key;
      if (gen1Key !== void 0 && Values.equal(key, gen1Key)) {
        const gen1Val = bucket.gen1Val;
        if (gen1Val !== void 0) {
          this.gen1Hits += 1;
          if (bucket.gen1Weight++ > bucket.gen2Weight) {
            this.buckets[index] = new HashGenCacheMapBucket(bucket.gen4Key, bucket.gen4Val, bucket.gen4Weight, bucket.gen3Key, bucket.gen3Val, bucket.gen3Weight, bucket.gen1Key, bucket.gen1Val, bucket.gen1Weight, bucket.gen2Key, bucket.gen2Val, bucket.gen2Weight);
          }
          return gen1Val;
        } else {
          bucket.gen1Key = void 0;
          gen1Key = void 0;
        }
      }
      this.misses += 1;
      if (gen4Key === void 0) {
        this.buckets[index] = new HashGenCacheMapBucket(bucket.gen3Key, bucket.gen3Val, bucket.gen3Weight, bucket.gen2Key, bucket.gen2Val, bucket.gen2Weight, bucket.gen1Key, bucket.gen1Val, bucket.gen1Weight, key, value, 1);
      } else if (gen3Key === void 0) {
        this.buckets[index] = new HashGenCacheMapBucket(bucket.gen4Key, bucket.gen4Val, bucket.gen4Weight, bucket.gen2Key, bucket.gen2Val, bucket.gen2Weight, bucket.gen1Key, bucket.gen1Val, bucket.gen1Weight, key, value, 1);
      } else if (gen2Key === void 0) {
        this.buckets[index] = new HashGenCacheMapBucket(bucket.gen4Key, bucket.gen4Val, bucket.gen4Weight, bucket.gen3Key, bucket.gen3Val, bucket.gen3Weight, bucket.gen1Key, bucket.gen1Val, bucket.gen1Weight, key, value, 1);
      } else if (gen1Key === void 0) {
        this.buckets[index] = new HashGenCacheMapBucket(bucket.gen4Key, bucket.gen4Val, bucket.gen4Weight, bucket.gen3Key, bucket.gen3Val, bucket.gen3Weight, bucket.gen2Key, bucket.gen2Val, bucket.gen2Weight, key, value, 1);
      } else {
        this.buckets[index] = new HashGenCacheMapBucket(bucket.gen4Key, bucket.gen4Val, bucket.gen4Weight - 1, bucket.gen3Key, bucket.gen3Val, bucket.gen3Weight - 1, bucket.gen1Key, bucket.gen1Val, bucket.gen1Weight, key, value, 1);
      }
      return value;
    }
    remove(key) {
      if (this.buckets.length === 0) {
        return void 0;
      }
      const index = Math.abs(Values.hash(key)) % this.buckets.length;
      const bucket = this.buckets[index];
      if (bucket === void 0) {
        return void 0;
      }
      const gen4Key = bucket.gen4Key;
      if (gen4Key !== void 0 && Values.equal(key, gen4Key)) {
        const gen4Val = bucket.gen4Val;
        this.buckets[index] = new HashGenCacheMapBucket(bucket.gen3Key, bucket.gen3Val, bucket.gen3Weight, bucket.gen2Key, bucket.gen2Val, bucket.gen2Weight, bucket.gen1Key, bucket.gen1Val, bucket.gen1Weight, void 0, void 0, 0);
        return gen4Val;
      }
      const gen3Key = bucket.gen3Key;
      if (gen3Key !== void 0 && Values.equal(key, gen3Key)) {
        const gen3Val = bucket.gen3Val;
        this.buckets[index] = new HashGenCacheMapBucket(bucket.gen4Key, bucket.gen4Val, bucket.gen4Weight, bucket.gen2Key, bucket.gen2Val, bucket.gen2Weight, bucket.gen1Key, bucket.gen1Val, bucket.gen1Weight, void 0, void 0, 0);
        return gen3Val;
      }
      const gen2Key = bucket.gen2Key;
      if (gen2Key !== void 0 && Values.equal(key, gen2Key)) {
        const gen2Val = bucket.gen2Val;
        this.buckets[index] = new HashGenCacheMapBucket(bucket.gen4Key, bucket.gen4Val, bucket.gen4Weight, bucket.gen3Key, bucket.gen3Val, bucket.gen3Weight, bucket.gen1Key, bucket.gen1Val, bucket.gen1Weight, void 0, void 0, 0);
        return gen2Val;
      }
      const gen1Key = bucket.gen1Key;
      if (gen1Key !== void 0 && Values.equal(key, gen1Key)) {
        const gen1Val = bucket.gen1Val;
        this.buckets[index] = new HashGenCacheMapBucket(bucket.gen4Key, bucket.gen4Val, bucket.gen4Weight, bucket.gen3Key, bucket.gen3Val, bucket.gen3Weight, bucket.gen2Key, bucket.gen2Val, bucket.gen2Weight, void 0, void 0, 0);
        return gen1Val;
      }
      return void 0;
    }
    clear() {
      for (let i = 0; i < this.buckets.length; i += 1) {
        this.buckets[i] = void 0;
      }
    }
    hits() {
      return this.gen4Hits + this.gen3Hits + this.gen2Hits + this.gen1Hits;
    }
    hitRatio() {
      const hits = this.hits();
      return hits / (hits + this.misses);
    }
  }
  class HashGenCacheMapBucket {
    constructor(gen4Key, gen4Val, gen4Weight = 0, gen3Key, gen3Val, gen3Weight = 0, gen2Key, gen2Val, gen2Weight = 0, gen1Key, gen1Val, gen1Weight = 0) {
      this.gen4Key = gen4Key;
      this.gen4Val = gen4Val;
      this.gen4Weight = gen4Weight;
      this.gen3Key = gen3Key;
      this.gen3Val = gen3Val;
      this.gen3Weight = gen3Weight;
      this.gen2Key = gen2Key;
      this.gen2Val = gen2Val;
      this.gen2Weight = gen2Weight;
      this.gen1Key = gen1Key;
      this.gen1Val = gen1Val;
      this.gen1Weight = gen1Weight;
    }
  }
  class HashGenCacheSet {
    constructor(size) {
      this.buckets = new Array(size);
      this.gen4Hits = 0;
      this.gen3Hits = 0;
      this.gen2Hits = 0;
      this.gen1Hits = 0;
      this.misses = 0;
    }
    put(value) {
      if (this.buckets.length === 0) {
        return value;
      }
      const index = Math.abs(Values.hash(value)) % this.buckets.length;
      const bucket = this.buckets[index] || new HashGenCacheSetBucket;
      const gen4Val = bucket.gen4Val;
      if (gen4Val !== void 0 && Values.equal(value, gen4Val)) {
        this.gen4Hits += 1;
        bucket.gen4Weight++;
        return gen4Val;
      }
      const gen3Val = bucket.gen3Val;
      if (gen3Val !== void 0 && Values.equal(value, gen3Val)) {
        this.gen3Hits += 1;
        if (bucket.gen3Weight++ > bucket.gen4Weight) {
          this.buckets[index] = new HashGenCacheSetBucket(bucket.gen3Val, bucket.gen3Weight, bucket.gen4Val, bucket.gen4Weight, bucket.gen2Val, bucket.gen2Weight, bucket.gen1Val, bucket.gen1Weight);
        }
        return gen3Val;
      }
      const gen2Val = bucket.gen2Val;
      if (gen2Val !== void 0 && Values.equal(value, gen2Val)) {
        this.gen2Hits += 1;
        if (bucket.gen2Weight++ > bucket.gen3Weight) {
          this.buckets[index] = new HashGenCacheSetBucket(bucket.gen4Val, bucket.gen4Weight, bucket.gen2Val, bucket.gen2Weight, bucket.gen3Val, bucket.gen3Weight, bucket.gen1Val, bucket.gen1Weight);
        }
        return gen2Val;
      }
      const gen1Val = bucket.gen1Val;
      if (gen1Val !== void 0 && Values.equal(value, gen1Val)) {
        this.gen1Hits += 1;
        if (bucket.gen1Weight++ > bucket.gen2Weight) {
          this.buckets[index] = new HashGenCacheSetBucket(bucket.gen4Val, bucket.gen4Weight, bucket.gen3Val, bucket.gen3Weight, bucket.gen1Val, bucket.gen1Weight, bucket.gen2Val, bucket.gen2Weight);
        }
        return gen1Val;
      }
      this.misses += 1;
      if (gen4Val === void 0) {
        this.buckets[index] = new HashGenCacheSetBucket(bucket.gen3Val, bucket.gen3Weight, bucket.gen2Val, bucket.gen2Weight, bucket.gen1Val, bucket.gen1Weight, value, 1);
      } else if (gen3Val === void 0) {
        this.buckets[index] = new HashGenCacheSetBucket(bucket.gen4Val, bucket.gen4Weight, bucket.gen2Val, bucket.gen2Weight, bucket.gen1Val, bucket.gen1Weight, value, 1);
      } else if (gen2Val === void 0) {
        this.buckets[index] = new HashGenCacheSetBucket(bucket.gen4Val, bucket.gen4Weight, bucket.gen3Val, bucket.gen3Weight, bucket.gen1Val, bucket.gen1Weight, value, 1);
      } else if (gen1Val === void 0) {
        this.buckets[index] = new HashGenCacheSetBucket(bucket.gen4Val, bucket.gen4Weight, bucket.gen3Val, bucket.gen3Weight, bucket.gen2Val, bucket.gen2Weight, value, 1);
      } else {
        this.buckets[index] = new HashGenCacheSetBucket(bucket.gen4Val, bucket.gen4Weight - 1, bucket.gen3Val, bucket.gen3Weight - 1, bucket.gen1Val, bucket.gen1Weight, value, 1);
      }
      return value;
    }
    remove(value) {
      if (this.buckets.length === 0) {
        return false;
      }
      const index = Math.abs(Values.hash(value)) % this.buckets.length;
      const bucket = this.buckets[index];
      if (bucket === void 0) {
        return false;
      }
      const gen4Val = bucket.gen4Val;
      if (gen4Val !== void 0 && Values.equal(value, gen4Val)) {
        this.buckets[index] = new HashGenCacheSetBucket(bucket.gen3Val, bucket.gen3Weight, bucket.gen2Val, bucket.gen2Weight, bucket.gen1Val, bucket.gen1Weight, void 0, 0);
        return true;
      }
      const gen3Val = bucket.gen3Val;
      if (gen3Val !== void 0 && Values.equal(value, gen3Val)) {
        this.buckets[index] = new HashGenCacheSetBucket(bucket.gen4Val, bucket.gen4Weight, bucket.gen2Val, bucket.gen2Weight, bucket.gen1Val, bucket.gen1Weight, void 0, 0);
        return true;
      }
      const gen2Val = bucket.gen2Val;
      if (gen2Val !== void 0 && Values.equal(value, gen2Val)) {
        this.buckets[index] = new HashGenCacheSetBucket(bucket.gen4Val, bucket.gen4Weight, bucket.gen3Val, bucket.gen3Weight, bucket.gen1Val, bucket.gen1Weight, void 0, 0);
        return true;
      }
      const gen1Val = bucket.gen1Val;
      if (gen1Val !== void 0 && Values.equal(value, gen1Val)) {
        this.buckets[index] = new HashGenCacheSetBucket(bucket.gen4Val, bucket.gen4Weight, bucket.gen3Val, bucket.gen3Weight, bucket.gen2Val, bucket.gen2Weight, void 0, 0);
        return true;
      }
      return false;
    }
    clear() {
      for (let i = 0; i < this.buckets.length; i += 1) {
        this.buckets[i] = void 0;
      }
    }
    get hits() {
      return this.gen4Hits + this.gen3Hits + this.gen2Hits + this.gen1Hits;
    }
    get hitRatio() {
      const hits = this.hits;
      return hits / (hits + this.misses);
    }
  }
  class HashGenCacheSetBucket {
    constructor(gen4Val, gen4Weight = 0, gen3Val, gen3Weight = 0, gen2Val, gen2Weight = 0, gen1Val, gen1Weight = 0) {
      this.gen4Val = gen4Val;
      this.gen4Weight = gen4Weight;
      this.gen3Val = gen3Val;
      this.gen3Weight = gen3Weight;
      this.gen2Val = gen2Val;
      this.gen2Weight = gen2Weight;
      this.gen1Val = gen1Val;
      this.gen1Weight = gen1Weight;
    }
  }
  class AssertException extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, AssertException.prototype);
    }
  }
  const assert = function() {
    const assert = function(condition, message) {
      if (!condition) {
        throw new AssertException(message);
      }
    };
    assert.ok = function(condition, message) {
      if (!condition) {
        throw new AssertException(message);
      }
    };
    assert.notOk = function(condition, message) {
      if (condition) {
        throw new AssertException(message);
      }
    };
    assert.equal = function(lhs, rhs, message) {
      if (!Values.equal(lhs, rhs)) {
        throw new AssertException(message);
      }
    };
    assert.notEqual = function(lhs, rhs, message) {
      if (Values.equal(lhs, rhs)) {
        throw new AssertException(message);
      }
    };
    assert.identical = function(lhs, rhs, message) {
      if (lhs !== rhs) {
        throw new AssertException(message);
      }
    };
    assert.notIdentical = function(lhs, rhs, message) {
      if (lhs === rhs) {
        throw new AssertException(message);
      }
    };
    assert.instanceOf = function(object, constructor, message) {
      if (!(object instanceof constructor)) {
        throw new AssertException(message);
      }
    };
    assert.notInstanceOf = function(object, constructor, message) {
      if (object instanceof constructor) {
        throw new AssertException(message);
      }
    };
    assert.compareLessThan = function(lhs, rhs, message) {
      if (!(Values.compare(lhs, rhs) < 0)) {
        throw new AssertException(message);
      }
    };
    assert.compareNotLessThan = function(lhs, rhs, message) {
      if (Values.compare(lhs, rhs) < 0) {
        throw new AssertException(message);
      }
    };
    assert.compareLessThanOrEqual = function(lhs, rhs, message) {
      if (!(Values.compare(lhs, rhs) <= 0)) {
        throw new AssertException(message);
      }
    };
    assert.compareNotLessThanOrEqual = function(lhs, rhs, message) {
      if (Values.compare(lhs, rhs) <= 0) {
        throw new AssertException(message);
      }
    };
    assert.compareEqual = function(lhs, rhs, message) {
      if (!(Values.compare(lhs, rhs) === 0)) {
        throw new AssertException(message);
      }
    };
    assert.compareNotEqual = function(lhs, rhs, message) {
      if (Values.compare(lhs, rhs) === 0) {
        throw new AssertException(message);
      }
    };
    assert.compareGreaterThanOrEqual = function(lhs, rhs, message) {
      if (!(Values.compare(lhs, rhs) >= 0)) {
        throw new AssertException(message);
      }
    };
    assert.compareNotGreaterThanOrEqual = function(lhs, rhs, message) {
      if (Values.compare(lhs, rhs) >= 0) {
        throw new AssertException(message);
      }
    };
    assert.compareGreaterThan = function(lhs, rhs, message) {
      if (!(Values.compare(lhs, rhs) > 0)) {
        throw new AssertException(message);
      }
    };
    assert.compareNotGreaterThan = function(lhs, rhs, message) {
      if (Values.compare(lhs, rhs) > 0) {
        throw new AssertException(message);
      }
    };
    return assert;
  }();
  class Severity {
    constructor(level, label) {
      this.level = level;
      this.label = label;
    }
    isTrace() {
      return this.level === Severity.TRACE_LEVEL;
    }
    isDebug() {
      return this.level === Severity.DEBUG_LEVEL;
    }
    isInfo() {
      return this.level === Severity.INFO_LEVEL;
    }
    isNote() {
      return this.level === Severity.NOTE_LEVEL;
    }
    isWarning() {
      return this.level === Severity.WARNING_LEVEL;
    }
    isError() {
      return this.level === Severity.ERROR_LEVEL;
    }
    isAlert() {
      return this.level === Severity.ALERT_LEVEL;
    }
    isFatal() {
      return this.level === Severity.FATAL_LEVEL;
    }
    compareTo(that) {
      if (this === that) {
        return 0;
      } else if (that instanceof Severity) {
        if (this.level < that.level) {
          return -1;
        } else if (this.level > that.level) {
          return 1;
        } else {
          return this.label.localeCompare(that.label);
        }
      }
      return NaN;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Severity) {
        return this.level === that.level && this.label === that.label;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(Severity), Numbers.hash(this.level)), Strings.hash(this.label)));
    }
    toString() {
      return this.label;
    }
    static create(level, label) {
      switch (level) {
       case Severity.TRACE_LEVEL:
        return Severity.trace(label);

       case Severity.DEBUG_LEVEL:
        return Severity.debug(label);

       case Severity.INFO_LEVEL:
        return Severity.info(label);

       case Severity.NOTE_LEVEL:
        return Severity.note(label);

       case Severity.WARNING_LEVEL:
        return Severity.warning(label);

       case Severity.ERROR_LEVEL:
        return Severity.error(label);

       case Severity.ALERT_LEVEL:
        return Severity.alert(label);

       case Severity.FATAL_LEVEL:
        return Severity.fatal(label);

       default:
        throw new Error("" + level);
      }
    }
    static trace(label = "trace") {
      if (label === "trace") {
        if (Severity._trace === void 0) {
          Severity._trace = new Severity(Severity.TRACE_LEVEL, label);
        }
        return Severity._trace;
      } else {
        return new Severity(Severity.TRACE_LEVEL, label);
      }
    }
    static debug(label = "debug") {
      if (label === "debug") {
        if (Severity._debug === void 0) {
          Severity._debug = new Severity(Severity.DEBUG_LEVEL, label);
        }
        return Severity._debug;
      } else {
        return new Severity(Severity.DEBUG_LEVEL, label);
      }
    }
    static info(label = "info") {
      if (label === "info") {
        if (Severity._info === void 0) {
          Severity._info = new Severity(Severity.INFO_LEVEL, label);
        }
        return Severity._info;
      } else {
        return new Severity(Severity.INFO_LEVEL, label);
      }
    }
    static note(label = "note") {
      if (label === "note") {
        if (Severity._note === void 0) {
          Severity._note = new Severity(Severity.NOTE_LEVEL, label);
        }
        return Severity._note;
      } else {
        return new Severity(Severity.NOTE_LEVEL, label);
      }
    }
    static warning(label = "warning") {
      if (label === "warning") {
        if (Severity._warning === void 0) {
          Severity._warning = new Severity(Severity.WARNING_LEVEL, label);
        }
        return Severity._warning;
      } else {
        return new Severity(Severity.WARNING_LEVEL, label);
      }
    }
    static error(label = "error") {
      if (label === "error") {
        if (Severity._error === void 0) {
          Severity._error = new Severity(Severity.ERROR_LEVEL, label);
        }
        return Severity._error;
      } else {
        return new Severity(Severity.ERROR_LEVEL, label);
      }
    }
    static alert(label = "alert") {
      if (label === "alert") {
        if (Severity._alert === void 0) {
          Severity._alert = new Severity(Severity.ALERT_LEVEL, label);
        }
        return Severity._alert;
      } else {
        return new Severity(Severity.ALERT_LEVEL, label);
      }
    }
    static fatal(label = "fatal") {
      if (label === "fatal") {
        if (Severity._fatal === void 0) {
          Severity._fatal = new Severity(Severity.FATAL_LEVEL, label);
        }
        return Severity._fatal;
      } else {
        return new Severity(Severity.FATAL_LEVEL, label);
      }
    }
  }
  Severity.TRACE_LEVEL = 0;
  Severity.DEBUG_LEVEL = 1;
  Severity.INFO_LEVEL = 2;
  Severity.NOTE_LEVEL = 3;
  Severity.WARNING_LEVEL = 4;
  Severity.ERROR_LEVEL = 5;
  Severity.ALERT_LEVEL = 6;
  Severity.FATAL_LEVEL = 7;
  class Tag {}
  class Mark extends Tag {
    constructor(offset, line, column, note) {
      super();
      this.offset = offset;
      this.line = line;
      this.column = column;
      this.note = note;
    }
    withNote(note) {
      if (this.note !== note) {
        return Mark.at(this.offset, this.line, this.column, note);
      } else {
        return this;
      }
    }
    min(that) {
      return this.offset <= that.offset ? this : that;
    }
    max(that) {
      return this.offset >= that.offset ? this : that;
    }
    get start() {
      return this;
    }
    get end() {
      return this;
    }
    union(that) {
      if (that instanceof Mark) {
        if (this.offset === that.offset && this.line === that.line && this.column === that.column) {
          return this;
        } else {
          return Span.from(this, that);
        }
      } else if (that instanceof Span) {
        const start = this.min(that.start);
        const end = this.max(that.end);
        if (start === that.start && end === that.end) {
          return that;
        } else {
          return Span.from(start, end);
        }
      }
      throw new Error(that.toString());
    }
    shift(mark) {
      const offset = this.offset + (this.offset - mark.offset);
      const line = this.line + (this.line - mark.line);
      let column = this.column;
      if (line === 1) {
        column += this.column - mark.column;
      }
      if (offset === this.offset && line === this.line && column === this.column) {
        return this;
      } else {
        return Mark.at(offset, line, column, this.note);
      }
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Mark) {
        return this.offset === that.offset && this.line === that.line && this.column === that.column && this.note === that.note;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(Constructors.hash(Mark), Numbers.hash(this.offset)), Numbers.hash(this.line)), Numbers.hash(this.column)), Strings.hash(this.note)));
    }
    display(output) {
      output = Format.displayNumber(output, this.line);
      output = output.write(58);
      output = Format.displayNumber(output, this.column);
      if (this.note !== void 0) {
        output = output.write(58).write(32).write(this.note);
      }
      return output;
    }
    debug(output) {
      output = output.write("Mark").write(".").write("at").write("(");
      output = Format.debugNumber(output, this.offset);
      output = output.write(", ");
      output = Format.debugNumber(output, this.line);
      output = output.write(", ");
      output = Format.debugNumber(output, this.column);
      if (this.note !== void 0) {
        output = output.write(", ");
        output = Format.debugString(output, this.note);
      }
      output = output.write(")");
      return output;
    }
    toString() {
      return Format.display(this);
    }
    static get zero() {
      return new Mark(0, 1, 1, void 0);
    }
    static at(offset, line, column, note) {
      return new Mark(offset, line, column, note);
    }
  }
  __decorate([ Lazy ], Mark, "zero", null);
  class Span extends Tag {
    constructor(start, end) {
      super();
      this.start = start;
      this.end = end;
    }
    union(that) {
      if (that instanceof Mark) {
        const start = this.start.min(that);
        const end = this.end.max(that);
        if (start === this.start && end === this.end) {
          return this;
        } else {
          return Span.from(start, end);
        }
      } else if (that instanceof Span) {
        const start = this.start.min(that.start);
        const end = this.end.max(that.end);
        if (start === this.start && end === this.end) {
          return this;
        } else {
          return Span.from(start, end);
        }
      }
      throw new Error(that.toString());
    }
    shift(mark) {
      const start = this.start.shift(mark);
      const end = this.end.shift(mark);
      if (start === this.start && end === this.end) {
        return this;
      } else {
        return Span.from(start, end);
      }
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Span) {
        return this.start.equals(that.start) && this.end.equals(that.end);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(Span), this.start.hashCode()), this.end.hashCode()));
    }
    display(output) {
      if (this.start.note !== void 0) {
        output = output.write(this.start.note).write(58).write(32);
      }
      output = Format.displayNumber(output, this.start.line);
      output = output.write(58);
      output = Format.displayNumber(output, this.start.column);
      output = output.write(45);
      output = Format.displayNumber(output, this.end.line);
      output = output.write(58);
      output = Format.displayNumber(output, this.end.column);
      if (this.end.note !== void 0) {
        output = output.write(58).write(32).write(this.end.note);
      }
      return output;
    }
    debug(output) {
      output = output.write("Span").write(".").write("from").write("(");
      output = this.start.debug(output);
      output = output.write(", ");
      output = this.end.debug(output);
      output = output.write(")");
      return output;
    }
    toString() {
      return Format.display(this);
    }
    static from(start, end) {
      if (start.offset > end.offset) {
        const tmp = start;
        start = end;
        end = tmp;
      }
      return new Span(start, end);
    }
  }
  const OutputStyle = function() {
    const OutputStyle = {};
    OutputStyle.reset = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(48).write(109);
      }
      return output;
    };
    OutputStyle.bold = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(49).write(109);
      }
      return output;
    };
    OutputStyle.faint = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(50).write(109);
      }
      return output;
    };
    OutputStyle.black = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(48).write(59).write(51).write(48).write(109);
      }
      return output;
    };
    OutputStyle.red = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(48).write(59).write(51).write(49).write(109);
      }
      return output;
    };
    OutputStyle.green = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(48).write(59).write(51).write(50).write(109);
      }
      return output;
    };
    OutputStyle.yellow = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(48).write(59).write(51).write(51).write(109);
      }
      return output;
    };
    OutputStyle.blue = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(48).write(59).write(51).write(52).write(109);
      }
      return output;
    };
    OutputStyle.magenta = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(48).write(59).write(51).write(53).write(109);
      }
      return output;
    };
    OutputStyle.cyan = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(48).write(59).write(51).write(54).write(109);
      }
      return output;
    };
    OutputStyle.gray = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(48).write(59).write(51).write(55).write(109);
      }
      return output;
    };
    OutputStyle.blackBold = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(49).write(59).write(51).write(48).write(109);
      }
      return output;
    };
    OutputStyle.redBold = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(49).write(59).write(51).write(49).write(109);
      }
      return output;
    };
    OutputStyle.greenBold = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(49).write(59).write(51).write(50).write(109);
      }
      return output;
    };
    OutputStyle.yellowBold = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(49).write(59).write(51).write(51).write(109);
      }
      return output;
    };
    OutputStyle.blueBold = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(49).write(59).write(51).write(52).write(109);
      }
      return output;
    };
    OutputStyle.magentaBold = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(49).write(59).write(51).write(53).write(109);
      }
      return output;
    };
    OutputStyle.cyanBold = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(49).write(59).write(51).write(54).write(109);
      }
      return output;
    };
    OutputStyle.grayBold = function(output) {
      if (output.settings.isStyled()) {
        output = output.write(27).write(91).write(49).write(59).write(51).write(55).write(109);
      }
      return output;
    };
    return OutputStyle;
  }();
  class OutputSettings {
    constructor(lineSeparator, pretty, styled, precision) {
      Object.defineProperty(this, "lineSeparator", {
        value: lineSeparator,
        enumerable: true
      });
      Object.defineProperty(this, "pretty", {
        value: pretty,
        enumerable: true
      });
      Object.defineProperty(this, "styled", {
        value: styled,
        enumerable: true
      });
      Object.defineProperty(this, "precision", {
        value: precision,
        enumerable: true
      });
    }
    withLineSeparator(lineSeparator) {
      return this.copy(lineSeparator, this.pretty, this.styled, this.precision);
    }
    isPretty() {
      return this.pretty;
    }
    asPretty(pretty) {
      return this.copy(this.lineSeparator, pretty, this.styled, this.precision);
    }
    isStyled() {
      return this.styled;
    }
    asStyled(styled) {
      return this.copy(this.lineSeparator, this.pretty, styled, this.precision);
    }
    withPrecision(precision) {
      return this.copy(this.lineSeparator, this.pretty, this.styled, precision);
    }
    copy(lineSeparator, pretty, styled, precision) {
      return OutputSettings.create(lineSeparator, pretty, styled, precision);
    }
    canEqual(that) {
      return that instanceof OutputSettings;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof OutputSettings) {
        return that.canEqual(this) && this.lineSeparator === that.lineSeparator && this.pretty === that.pretty && this.styled === that.styled && this.precision === that.precision;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(Constructors.hash(OutputSettings), Strings.hash(this.lineSeparator)), Booleans.hash(this.pretty)), Booleans.hash(this.styled)), Numbers.hash(this.precision)));
    }
    debug(output) {
      output = output.write("OutputSettings").write(46);
      if (!this.pretty && !this.styled) {
        output = output.write("standard");
      } else if (this.pretty && !this.styled) {
        output = output.write("pretty");
      } else if (!this.pretty && this.styled) {
        output = output.write("styled");
      } else {
        output = output.write("prettyStyled");
      }
      output = output.write(40).write(41);
      if (this.lineSeparator !== Format.lineSeparator) {
        output = output.write(46).write("lineSeparator").write(40).display(this.lineSeparator).write(41);
      }
      if (this.precision !== -1) {
        output = output.write(46).write("precision").write(40).display(this.precision).write(41);
      }
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static standard() {
      return new OutputSettings(Format.lineSeparator, false, false, -1);
    }
    static pretty() {
      return new OutputSettings(Format.lineSeparator, true, false, -1);
    }
    static styled() {
      return new OutputSettings(Format.lineSeparator, false, true, -1);
    }
    static prettyStyled() {
      return new OutputSettings(Format.lineSeparator, true, true, -1);
    }
    static create(lineSeparator, pretty, styled, precision) {
      if (typeof lineSeparator !== "string") {
        lineSeparator = Format.lineSeparator;
      }
      if (typeof pretty !== "boolean") {
        pretty = false;
      }
      if (typeof styled !== "boolean") {
        styled = false;
      }
      if (typeof precision !== "number") {
        precision = -1;
      }
      if (lineSeparator === Format.lineSeparator && precision === -1) {
        if (!pretty && !styled) {
          return OutputSettings.standard();
        } else if (pretty && !styled) {
          return OutputSettings.pretty();
        } else if (!pretty && styled) {
          return OutputSettings.styled();
        } else {
          return OutputSettings.prettyStyled();
        }
      }
      return new OutputSettings(lineSeparator, pretty, styled, precision);
    }
    static fromInit(init) {
      return OutputSettings.create(init.lineSeparator, init.isPretty, init.isStyled, init.precision);
    }
    static fromAny(value) {
      if (value instanceof OutputSettings) {
        return value;
      } else if (typeof value === "object" && value !== null) {
        return OutputSettings.fromInit(value);
      }
      return OutputSettings.standard();
    }
  }
  __decorate([ Lazy ], OutputSettings, "standard", null);
  __decorate([ Lazy ], OutputSettings, "pretty", null);
  __decorate([ Lazy ], OutputSettings, "styled", null);
  __decorate([ Lazy ], OutputSettings, "prettyStyled", null);
  class InputException extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, InputException.prototype);
    }
  }
  class InputSettings {
    constructor(stripped) {
      Object.defineProperty(this, "stripped", {
        value: stripped,
        enumerable: true
      });
    }
    isStripped() {
      return this.stripped;
    }
    asStripped(stripped) {
      return this.copy(stripped);
    }
    copy(stripped) {
      return InputSettings.create(stripped);
    }
    canEqual(that) {
      return that instanceof InputSettings;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof InputSettings) {
        return that.canEqual(this) && this.stripped === that.stripped;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(InputSettings), Booleans.hash(this.stripped)));
    }
    debug(output) {
      output = output.write("InputSettings").write(46);
      if (!this.stripped) {
        output = output.write("standard");
      } else {
        output = output.write("stripped");
      }
      output = output.write(40).write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static standard() {
      return new InputSettings(false);
    }
    static stripped() {
      return new InputSettings(true);
    }
    static create(isStripped) {
      if (isStripped) {
        return InputSettings.stripped();
      }
      return InputSettings.standard();
    }
    static fromAny(settings) {
      if (settings instanceof InputSettings) {
        return settings;
      } else if (typeof settings === "object" && settings !== null) {
        return InputSettings.create(settings.isStripped);
      } else {
        return InputSettings.standard();
      }
    }
  }
  __decorate([ Lazy ], InputSettings, "standard", null);
  __decorate([ Lazy ], InputSettings, "stripped", null);
  class Input {
    trap() {
      throw new InputException;
    }
    static empty() {
      return new InputEmpty(void 0, Mark.zero, InputSettings.standard());
    }
    static done() {
      return new InputDone(void 0, Mark.zero, InputSettings.standard());
    }
    static error(error) {
      return new InputError(error, void 0, Mark.zero, InputSettings.standard());
    }
  }
  __decorate([ Lazy ], Input, "empty", null);
  __decorate([ Lazy ], Input, "done", null);
  class InputError extends Input {
    constructor(error, id, mark, settings) {
      super();
      Object.defineProperty(this, "error", {
        value: error,
        enumerable: true
      });
      Object.defineProperty(this, "id", {
        value: id,
        enumerable: true
      });
      Object.defineProperty(this, "mark", {
        value: mark,
        enumerable: true
      });
      Object.defineProperty(this, "settings", {
        value: settings,
        enumerable: true
      });
    }
    isCont() {
      return false;
    }
    isEmpty() {
      return false;
    }
    isDone() {
      return false;
    }
    isError() {
      return true;
    }
    isPart() {
      return false;
    }
    asPart(part) {
      return this;
    }
    head() {
      throw new InputException;
    }
    step() {
      const error = new InputException("error step");
      return new InputError(error, this.id, this.mark, this.settings);
    }
    trap() {
      return this.error;
    }
    seek(mark) {
      const error = new InputException("error seek");
      return new InputError(error, this.id, this.mark, this.settings);
    }
    withId(id) {
      return new InputError(this.error, id, this.mark, this.settings);
    }
    withMark(mark) {
      return new InputError(this.error, this.id, mark, this.settings);
    }
    get offset() {
      return this.mark.offset;
    }
    get line() {
      return this.mark.line;
    }
    get column() {
      return this.mark.column;
    }
    withSettings(settings) {
      settings = InputSettings.fromAny(settings);
      return new InputError(this.error, this.id, this.mark, settings);
    }
    clone() {
      return this;
    }
  }
  class StringInput extends Input {
    constructor(string, id, offset, line, column, settings, index, part) {
      super();
      this.string = string;
      this.index = index;
      this.part = part;
      this.id = id;
      this.offset = offset;
      this.line = line;
      this.column = column;
      this.settings = settings;
    }
    isCont() {
      return this.index < this.string.length;
    }
    isEmpty() {
      return this.part && this.index >= this.string.length;
    }
    isDone() {
      return !this.part && this.index >= this.string.length;
    }
    isError() {
      return false;
    }
    isPart() {
      return this.part;
    }
    asPart(part) {
      this.part = part;
      return this;
    }
    head() {
      const string = this.string;
      const index = this.index;
      if (index < string.length) {
        const c = string.codePointAt(index);
        if (c !== void 0) {
          return c;
        } else {
          return string.charCodeAt(index);
        }
      }
      throw new InputException;
    }
    step() {
      const string = this.string;
      const index = this.index;
      if (index < string.length) {
        const c = string.codePointAt(index);
        this.index = Strings.offsetByCodePoints(string, index, 1);
        this.offset += this.index - index;
        if (c === 10) {
          this.line += 1;
          this.column = 1;
        } else {
          this.column += 1;
        }
        return this;
      } else {
        const error = new InputException("invalid step");
        return new InputError(error, this.id, this.mark, this.settings);
      }
    }
    seek(mark) {
      if (mark !== void 0) {
        const index = this.index + (mark.offset - this.offset);
        if (0 <= index && index <= this.string.length) {
          this.index = index;
          this.offset = mark.offset;
          this.line = mark.line;
          this.column = mark.column;
          return this;
        } else {
          const error = new InputException("invalid seek to " + mark);
          return new InputError(error, this.id, this.mark, this.settings);
        }
      } else {
        this.index = 0;
        this.offset = 0;
        this.line = 1;
        this.column = 1;
        return this;
      }
    }
    withId(id) {
      this.id = id;
      return this;
    }
    get mark() {
      return Mark.at(this.offset, this.line, this.column);
    }
    withMark(mark) {
      this.offset = mark.offset;
      this.line = mark.line;
      this.column = mark.column;
      return this;
    }
    withSettings(settings) {
      settings = InputSettings.fromAny(settings);
      this.settings = settings;
      return this;
    }
    clone() {
      return new StringInput(this.string, this.id, this.offset, this.line, this.column, this.settings, this.index, this.part);
    }
    static create(string) {
      return new StringInput(string, void 0, 0, 1, 1, InputSettings.standard(), 0, false);
    }
  }
  class OutputException extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, OutputException.prototype);
    }
  }
  class Output {
    writeln(string) {
      if (typeof string === "string") {
        this.write(string);
      }
      return this.write(this.settings.lineSeparator);
    }
    display(object) {
      return Format.displayAny(this, object);
    }
    debug(object) {
      return Format.debugAny(this, object);
    }
    flush() {
      return this;
    }
    push(...tokens) {
      const n = tokens.length;
      for (let i = 0; i < n; i += 1) {
        this.write(tokens[i]);
      }
    }
    trap() {
      throw new OutputException;
    }
    clone() {
      throw new Error;
    }
    static full() {
      return new OutputFull(OutputSettings.standard());
    }
    static done() {
      return new OutputDone(OutputSettings.standard());
    }
    static error(error) {
      return new OutputError(error, OutputSettings.standard());
    }
  }
  __decorate([ Lazy ], Output, "full", null);
  __decorate([ Lazy ], Output, "done", null);
  class StringOutput extends Output {
    constructor(string, settings) {
      super();
      this.string = string;
      this.settings = settings;
    }
    isCont() {
      return true;
    }
    isFull() {
      return false;
    }
    isDone() {
      return false;
    }
    isError() {
      return false;
    }
    isPart() {
      return false;
    }
    asPart(part) {
      return this;
    }
    write(token) {
      if (typeof token === "number") {
        if (token >= 0 && token <= 55295 || token >= 57344 && token <= 65535) {
          token = String.fromCharCode(token);
        } else if (token >= 65536 && token <= 1114111) {
          const u = token - 65536;
          token = String.fromCharCode(55296 | u >>> 10, 56320 | u & 1023);
        } else {
          token = "";
        }
      }
      this.string += token;
      return this;
    }
    writeln(string) {
      if (string !== void 0) {
        this.string = this.string.concat(string);
      }
      this.string = this.string.concat(this.settings.lineSeparator);
      return this;
    }
    withSettings(settings) {
      settings = OutputSettings.fromAny(settings);
      this.settings = settings;
      return this;
    }
    bind() {
      return this.string;
    }
    clone() {
      return new StringOutput(this.string, this.settings);
    }
    toString() {
      return this.string;
    }
  }
  class WriterException extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, WriterException.prototype);
    }
  }
  class Writer {
    isCont() {
      return true;
    }
    isDone() {
      return false;
    }
    isError() {
      return false;
    }
    feed(input) {
      throw new WriterException;
    }
    fork(condition) {
      return this;
    }
    bind() {
      throw new WriterException;
    }
    trap() {
      throw new WriterException;
    }
    asDone() {
      throw new WriterException;
    }
    asError() {
      throw new WriterException;
    }
    andThen(that) {
      return new WriterSequence(this, that);
    }
    static end() {
      return new WriterEnd;
    }
    static done(value) {
      return new WriterDone(value);
    }
    static error(error) {
      return new WriterError(error);
    }
  }
  __decorate([ Lazy ], Writer, "end", null);
  class StringWriter$1 extends Writer {
    constructor(value, input, index = 0) {
      super();
      this.value = value;
      this.input = input;
      this.index = index;
    }
    feed(input) {
      return new StringWriter$1(input, "" + input);
    }
    pull(output) {
      return StringWriter$1.write(output, this.value, this.input, this.index);
    }
    static write(output, value, input, index = 0) {
      const length = input.length;
      while (index < length && output.isCont()) {
        let c = input.codePointAt(index);
        if (c === void 0) {
          c = input.charCodeAt(index);
        }
        output = output.write(c);
        index = Strings.offsetByCodePoints(input, index, 1);
      }
      if (index === length) {
        return Writer.done(value);
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new StringWriter$1(value, input, index);
    }
  }
  const Unicode = function() {
    const Unicode = {};
    Unicode.stringInput = function(string) {
      return StringInput.create(string);
    };
    Unicode.stringOutput = function(string, settings) {
      if (settings === void 0 && typeof string !== "string") {
        settings = string;
        string = "";
      } else if (typeof string !== "string") {
        string = "";
      }
      settings = OutputSettings.fromAny(settings);
      return new StringOutput(string, settings);
    };
    Unicode.stringWriter = function(input) {
      if (input === void 0) {
        return new StringWriter$1(void 0, "");
      } else {
        return new StringWriter$1(input, "" + input);
      }
    };
    Unicode.writeString = function(output, input) {
      return StringWriter$1.write(output, void 0, "" + input);
    };
    Unicode.isAlpha = function(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    };
    Unicode.isDigit = function(c) {
      return c >= 48 && c <= 57;
    };
    Unicode.isSpace = function(c) {
      return c === 32 || c === 9;
    };
    Unicode.isNewline = function(c) {
      return c === 10 || c === 13;
    };
    Unicode.isWhitespace = function(c) {
      return Unicode.isSpace(c) || Unicode.isNewline(c);
    };
    return Unicode;
  }();
  const Format = function() {
    const Format = {};
    Object.defineProperty(Format, "lineSeparator", {
      value: typeof os !== "undefined" && typeof os.EOL === "string" ? os.EOL : "\n",
      enumerable: true,
      configurable: true
    });
    Format.display = function(object, settings) {
      if (object === void 0) {
        return "undefined";
      } else if (object === null) {
        return "null";
      } else if (typeof object === "number") {
        return "" + object;
      } else if (typeof object === "string") {
        return object;
      } else if (typeof object.display === "function") {
        let output = Unicode.stringOutput(settings);
        output = object.display(output);
        return output.bind();
      } else {
        return "" + object;
      }
    };
    Format.debug = function(object, settings) {
      if (object === void 0) {
        return "undefined";
      } else if (object === null) {
        return "null";
      } else if (typeof object === "number") {
        return "" + object;
      } else if (typeof object === "string") {
        let output = Unicode.stringOutput(settings);
        output = Format.debugString(output, object);
        return output.bind();
      } else if (typeof object.debug === "function") {
        let output = Unicode.stringOutput(settings);
        output = object.debug(output);
        return output.bind();
      } else {
        return "" + object;
      }
    };
    Format.displayAny = function(output, object) {
      if (object === void 0) {
        output = output.write("undefined");
      } else if (object === null) {
        output = output.write("null");
      } else if (typeof object === "number") {
        output = Format.displayNumber(output, object);
      } else if (typeof object === "string") {
        output = output.write(object);
      } else if (typeof object.display === "function") {
        output = object.display(output);
      } else {
        output = output.write("" + object);
      }
      return output;
    };
    Format.debugAny = function(output, object) {
      if (object === void 0) {
        output = output.write("undefined");
      } else if (object === null) {
        output = output.write("null");
      } else if (typeof object === "number") {
        output = Format.debugNumber(output, object);
      } else if (typeof object === "string") {
        output = Format.debugString(output, object);
      } else if (typeof object.debug === "function") {
        output = object.debug(output);
      } else {
        output = output.write("" + object);
      }
      return output;
    };
    Format.displayNumber = function(output, value) {
      if (isFinite(value) && Math.floor(value) === value && Math.abs(value) < 2147483648) {
        if (value < 0) {
          output = output.write(45);
        }
        if (value > -10 && value < 10) {
          output = output.write(48 + Math.abs(value));
        } else {
          const digits = new Array(19);
          let x = value;
          let i = 18;
          while (x !== 0) {
            digits[i] = Math.abs(x % 10 | 0);
            x = x / 10 | 0;
            i -= 1;
          }
          i += 1;
          while (i < 19) {
            output = output.write(48 + digits[i]);
            i += 1;
          }
        }
      } else {
        output = output.write(Format.decimal(value, output.settings.precision));
      }
      return output;
    };
    Format.debugNumber = function(output, value) {
      return Format.displayNumber(output, value);
    };
    Format.debugChar = function(output, value) {
      output = output.write(39);
      switch (value) {
       case 8:
        output.write(92).write(98);
        break;

       case 9:
        output.write(92).write(116);
        break;

       case 10:
        output.write(92).write(110);
        break;

       case 12:
        output.write(92).write(102);
        break;

       case 13:
        output.write(92).write(114);
        break;

       case 34:
        output.write(92).write(34);
        break;

       case 39:
        output.write(92).write(39);
        break;

       case 92:
        output.write(92).write(92);
        break;

       default:
        if (value >= 0 && value <= 31 || value >= 127 && value <= 159) {
          output = output.write(92).write(117).write(Format.encodeHex(value >>> 12 & 15)).write(Format.encodeHex(value >>> 8 & 15)).write(Format.encodeHex(value >>> 4 & 15)).write(Format.encodeHex(value & 15));
        } else {
          output = output.write(value);
        }
      }
      output = output.write(39);
      return output;
    };
    Format.debugString = function(output, string) {
      output = output.write(34);
      let input = Unicode.stringInput(string);
      while (input.isCont()) {
        const c = input.head();
        switch (c) {
         case 8:
          output.write(92).write(98);
          break;

         case 9:
          output.write(92).write(116);
          break;

         case 10:
          output.write(92).write(110);
          break;

         case 12:
          output.write(92).write(102);
          break;

         case 13:
          output.write(92).write(114);
          break;

         case 34:
          output.write(92).write(34);
          break;

         case 92:
          output.write(92).write(92);
          break;

         default:
          if (c >= 0 && c <= 31 || c >= 127 && c <= 159) {
            output = output.write(92).write(117).write(Format.encodeHex(c >>> 12 & 15)).write(Format.encodeHex(c >>> 8 & 15)).write(Format.encodeHex(c >>> 4 & 15)).write(Format.encodeHex(c & 15));
          } else {
            output = output.write(c);
          }
        }
        input = input.step();
      }
      output = output.write(34);
      return output;
    };
    Format.encodeHex = function(x) {
      if (x < 10) {
        return 48 + x;
      } else {
        return 65 + (x - 10);
      }
    };
    Format.prefix = function() {
      const prefixes = [ "y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", " Z", "Y" ];
      return function(value, precision = 1) {
        if (isFinite(value)) {
          const exponential = Math.abs(value).toExponential();
          const exponentIndex = exponential.indexOf("e");
          const exponent = exponentIndex >= 0 ? +exponential.slice(exponentIndex + 1) : NaN;
          const power = Math.min(Math.max(-8, Math.floor(exponent / 3)), 8) * 3;
          const scaled = Math.pow(10, -power) * value;
          let s = Format.trimTrailingZeros(Math.abs(scaled).toFixed(precision));
          if (scaled < 0 && +s !== 0) {
            s = "-" + s;
          }
          s += prefixes[8 + power / 3];
          return s;
        } else {
          return "" + value;
        }
      };
    }();
    Format.decimal = function(value, precision = -1) {
      if (precision >= 0) {
        let s = Format.trimTrailingZeros(Math.abs(value).toFixed(precision));
        if (value < 0 && +s !== 0) {
          s = "-" + s;
        }
        return s;
      } else {
        return "" + value;
      }
    };
    Format.trimTrailingZeros = function(s) {
      let i0 = -1;
      let i1;
      for (let i = 1, n = s.length; i < n; i += 1) {
        const c = s.charCodeAt(i);
        if (c === 46) {
          i0 = i;
          i1 = i;
        } else if (c === 48) {
          if (i0 === 0) {
            i0 = i;
          }
          i1 = i;
        } else if (c >= 49 && c <= 57) {
          if (i0 > 0) {
            i0 = 0;
          }
        } else if (i0 > 0) {
          break;
        }
      }
      if (i0 > 0) {
        s = s.slice(0, i0) + s.slice(i1 + 1);
      }
      return s;
    };
    Format.duration = function(millis, separator = " ") {
      if (isFinite(millis)) {
        const SECOND = 1e3;
        const MINUTE = 60 * SECOND;
        const HOUR = 60 * MINUTE;
        const DAY = 24 * HOUR;
        const WEEK = 7 * DAY;
        let weeks;
        if (millis > WEEK) {
          weeks = Math.floor(millis / WEEK);
          millis %= WEEK;
        }
        let days;
        if (millis > DAY) {
          days = Math.floor(millis / DAY);
          millis %= DAY;
        }
        let hours;
        if (millis > HOUR) {
          hours = Math.floor(millis / HOUR);
          millis %= HOUR;
        }
        let minutes;
        if (millis > MINUTE) {
          minutes = Math.floor(millis / MINUTE);
          millis %= MINUTE;
        }
        let seconds;
        if (millis > SECOND) {
          seconds = Math.floor(millis / SECOND);
          millis %= SECOND;
        }
        let s = "";
        if (weeks !== void 0) {
          s += weeks + "w";
        }
        if (days !== void 0) {
          s += (s.length !== 0 ? separator : "") + days + "d";
        }
        if (hours !== void 0) {
          s += (s.length !== 0 ? separator : "") + hours + "h";
        }
        if (minutes !== void 0) {
          s += (s.length !== 0 ? separator : "") + minutes + "m";
        }
        if (seconds !== void 0 || millis === 0) {
          s += (s.length !== 0 ? separator : "") + (seconds !== void 0 ? seconds : 0) + "s";
        }
        if (millis !== 0 && s.length === 0) {
          s += millis + "ms";
        }
        return s;
      } else {
        return "" + millis;
      }
    };
    return Format;
  }();
  const Base10 = function() {
    const Base10 = {};
    Base10.isDigit = function(c) {
      return c >= 48 && c <= 57;
    };
    Base10.decodeDigit = function(c) {
      if (c >= 48 && c <= 57) {
        return c - 48;
      } else {
        let message = Unicode.stringOutput();
        message = message.write("Invalid base-10 digit: ");
        message = Format.debugChar(message, c);
        throw new Error(message.bind());
      }
    };
    Base10.encodeDigit = function(b) {
      if (b >= 0 && b <= 9) {
        return 48 + b;
      } else {
        throw new Error("" + b);
      }
    };
    Base10.countDigits = function(value) {
      let size = 0;
      do {
        size += 1;
        value = value / 10 | 0;
      } while (value !== 0);
      return size;
    };
    Base10.integerParser = function() {
      return new Base10NumberParser(void 0, void 0, 0);
    };
    Base10.parseInteger = function(input) {
      return Base10NumberParser.parse(input, void 0, void 0, 0);
    };
    Base10.decimalParser = function() {
      return new Base10NumberParser(void 0, void 0, 1);
    };
    Base10.parseDecimal = function(input) {
      return Base10NumberParser.parse(input, void 0, void 0, 1);
    };
    Base10.numberParser = function() {
      return new Base10NumberParser;
    };
    Base10.parseNumber = function(input) {
      return Base10NumberParser.parse(input);
    };
    Base10.integerWriter = function(input) {
      if (input === void 0) {
        return new Base10IntegerWriter(void 0, 0);
      } else {
        return new Base10IntegerWriter(void 0, input);
      }
    };
    Base10.writeInteger = function(output, input) {
      return Base10IntegerWriter.write(output, void 0, input);
    };
    return Base10;
  }();
  class Diagnostic {
    constructor(input, tag, severity, message, note, cause) {
      this.input = input;
      this.tag = tag;
      this.severity = severity;
      this.message = message;
      this.note = note;
      this.cause = cause;
    }
    lineDigits() {
      let digits = Base10.countDigits(this.tag.end.line);
      if (this.cause !== null) {
        digits = Math.max(digits, this.cause.lineDigits());
      }
      return digits;
    }
    display(output) {
      const input = this.input.clone();
      const start = this.tag.start;
      const end = this.tag.end;
      const severity = this.severity;
      const message = this.message;
      const note = this.note;
      const cause = this.cause;
      const contextLines = 2;
      const lineDigits = this.lineDigits();
      output = Diagnostic.display(output, input, start, end, severity, message, note, cause, contextLines, lineDigits);
      return output;
    }
    static display(output, input, start, end, severity, message, note, cause, contextLines, lineDigits) {
      do {
        if (message !== void 0) {
          output = Diagnostic.displayMessage(output, severity, message);
          output = output.writeln();
        }
        output = Diagnostic.displayAnchor(output, input, start, lineDigits);
        output = output.writeln();
        const cont = Diagnostic.displayContext(output, input, start, end, severity, note, cause, contextLines, lineDigits);
        const next = cont[0];
        output = cont[1];
        if (next !== null) {
          output = output.writeln();
          input = next.input.clone();
          start = next.tag.start;
          end = next.tag.end;
          severity = next.severity;
          message = next.message;
          note = next.note;
          cause = next.cause;
        } else {
          break;
        }
      } while (true);
      return output;
    }
    static displayMessage(output, severity, message) {
      output = Diagnostic.formatSeverity(output, severity);
      output = output.write(severity.label);
      output = OutputStyle.reset(output);
      output = OutputStyle.bold(output);
      output = output.write(58);
      if (message !== void 0) {
        output = output.write(32).write(message);
      }
      output = OutputStyle.reset(output);
      return output;
    }
    static displayAnchor(output, input, start, lineDigits) {
      output = Diagnostic.displayLineLeadArrow(output, lineDigits);
      output = output.write(32);
      const id = input.id;
      if (id !== void 0) {
        output = Format.displayAny(output, id);
      }
      output = output.write(58);
      output = Format.displayNumber(output, start.line);
      output = output.write(58);
      output = Format.displayNumber(output, start.column);
      output = output.writeln();
      output = Diagnostic.displayLineLead(output, lineDigits);
      return output;
    }
    static displayContext(output, input, start, end, severity, note, cause, contextLines, lineDigits) {
      let next = cause;
      const sameCause = cause !== null && cause.message === void 0 && Values.equal(input.id, cause.input.id);
      const causeOrder = sameCause ? start.offset <= cause.tag.start.offset ? -1 : 1 : 0;
      if (causeOrder === 1) {
        const cont = Diagnostic.displayContext(output, cause.input.clone(), cause.tag.start, cause.tag.end, cause.severity, cause.note, cause.cause, contextLines, lineDigits);
        next = cont[0];
        output = cont[1];
        output = output.writeln();
        output = Diagnostic.displayLineLeadEllipsis(output, lineDigits);
        output = output.writeln();
      }
      output = Diagnostic.displayLines(output, input, start, end, severity, contextLines, lineDigits);
      if (note !== void 0) {
        output = Diagnostic.displayNote(output, note, lineDigits);
      }
      if (causeOrder === -1) {
        output = output.writeln();
        output = Diagnostic.displayLineLeadEllipsis(output, lineDigits);
        output = output.writeln();
        const cont = Diagnostic.displayContext(output, cause.input.clone(), cause.tag.start, cause.tag.end, cause.severity, cause.note, cause.cause, contextLines, lineDigits);
        next = cont[0];
        output = cont[1];
      }
      return [ next, output ];
    }
    static displayLines(output, input, start, end, severity, contextLines, lineDigits) {
      const startLine = start.line;
      const endLine = end.line;
      let line = input.line;
      while (line < startLine) {
        Diagnostic.consumeLineText(input, line);
        line += 1;
      }
      if (endLine - startLine > 2 * contextLines + 2) {
        while (line <= startLine + contextLines) {
          output = Diagnostic.displayLine(output, input, start, end, severity, line, lineDigits);
          line += 1;
        }
        output = Diagnostic.displayLineLeadEllipsis(output, lineDigits);
        output = output.write(32);
        output = Diagnostic.formatSeverity(output, severity);
        output = output.write(124);
        output = OutputStyle.reset(output);
        output = output.writeln();
        while (line < endLine - contextLines) {
          Diagnostic.consumeLineText(input, line);
          line += 1;
        }
      }
      while (line <= endLine) {
        output = Diagnostic.displayLine(output, input, start, end, severity, line, lineDigits);
        line += 1;
      }
      return output;
    }
    static displayNote(output, note, lineDigits) {
      output = output.writeln();
      output = Diagnostic.displayLineLead(output, lineDigits);
      output = output.writeln();
      output = Diagnostic.displayLineComment(output, "note", note, lineDigits);
      return output;
    }
    static displayLine(output, input, start, end, severity, line, lineDigits) {
      if (start.line === line && end.line === line) {
        output = Diagnostic.displaySingleLine(output, input, start, end, severity, line, lineDigits);
      } else if (start.line === line) {
        output = Diagnostic.displayStartLine(output, input, start, severity, line, lineDigits);
      } else if (end.line === line) {
        output = Diagnostic.displayEndLine(output, input, end, severity, line, lineDigits);
      } else {
        output = Diagnostic.displayMidLine(output, input, severity, line, lineDigits);
      }
      return output;
    }
    static displaySingleLine(output, input, start, end, severity, line, lineDigits) {
      output = Diagnostic.displayLineLeadNumber(output, line, lineDigits);
      output = output.write(32);
      for (let i = 1; i < input.column; i += 1) {
        output = output.write(32);
      }
      output = Diagnostic.displayLineText(output, input, line);
      output = Diagnostic.displayLineLead(output, lineDigits);
      output = output.write(32);
      let i = 1;
      while (i < start.column) {
        output = output.write(32);
        i += 1;
      }
      output = Diagnostic.formatSeverity(output, severity);
      while (i <= end.column) {
        output = output.write(94);
        i += 1;
      }
      if (end.note !== void 0) {
        output = output.write(32).write(end.note);
      }
      output = OutputStyle.reset(output);
      return output;
    }
    static displayStartLine(output, input, start, severity, line, lineDigits) {
      output = Diagnostic.displayLineLeadNumber(output, line, lineDigits);
      output = output.write(32).write(32).write(32);
      for (let i = 1; i < input.column; i += 1) {
        output = output.write(32);
      }
      output = Diagnostic.displayLineText(output, input, line);
      output = Diagnostic.displayLineLead(output, lineDigits);
      output = output.write(32).write(32);
      output = Diagnostic.formatSeverity(output, severity);
      output = output.write(95);
      let i = 1;
      while (i < start.column) {
        output = output.write(95);
        i += 1;
      }
      output = output.write(94);
      if (start.note !== void 0) {
        output = output.write(32).write(start.note);
      }
      output = OutputStyle.reset(output);
      output = output.writeln();
      return output;
    }
    static displayEndLine(output, input, end, severity, line, lineDigits) {
      output = Diagnostic.displayLineLeadNumber(output, line, lineDigits);
      output = output.write(32);
      output = Diagnostic.formatSeverity(output, severity);
      output = output.write(124);
      output = OutputStyle.reset(output);
      output = output.write(32);
      output = Diagnostic.displayLineText(output, input, line);
      output = Diagnostic.displayLineLead(output, lineDigits);
      output = output.write(32);
      output = Diagnostic.formatSeverity(output, severity);
      output = output.write(124).write(95);
      let i = 1;
      while (i < end.column) {
        output = output.write(95);
        i += 1;
      }
      output = output.write(94);
      if (end.note !== void 0) {
        output = output.write(32).write(end.note);
      }
      output = OutputStyle.reset(output);
      return output;
    }
    static displayMidLine(output, input, severity, line, lineDigits) {
      output = Diagnostic.displayLineLeadNumber(output, line, lineDigits);
      output = output.write(32);
      output = Diagnostic.formatSeverity(output, severity);
      output = output.write(124);
      output = OutputStyle.reset(output);
      output = output.write(32);
      output = Diagnostic.displayLineText(output, input, line);
      return output;
    }
    static displayLineComment(output, label, comment, lineDigits) {
      output = Diagnostic.displayLineLeadComment(output, lineDigits);
      output = output.write(32);
      output = OutputStyle.bold(output);
      output = output.write(label).write(58);
      output = OutputStyle.reset(output);
      if (comment !== void 0) {
        output = output.write(32).write(comment);
      }
      return output;
    }
    static displayLineLead(output, lineDigits) {
      output = OutputStyle.blueBold(output);
      const padding = 1 + lineDigits;
      for (let i = 0; i < padding; i += 1) {
        output = output.write(32);
      }
      output = output.write(124);
      output = OutputStyle.reset(output);
      return output;
    }
    static displayLineLeadComment(output, lineDigits) {
      output = OutputStyle.blueBold(output);
      const padding = 1 + lineDigits;
      for (let i = 0; i < padding; i += 1) {
        output = output.write(32);
      }
      output = output.write(61);
      output = OutputStyle.reset(output);
      return output;
    }
    static displayLineLeadArrow(output, lineDigits) {
      for (let i = 0; i < lineDigits; i += 1) {
        output = output.write(32);
      }
      output = OutputStyle.blueBold(output);
      output = output.write(45).write(45).write(62);
      output = OutputStyle.reset(output);
      return output;
    }
    static displayLineLeadEllipsis(output, lineDigits) {
      output = OutputStyle.blueBold(output);
      for (let i = 0; i < lineDigits; i += 1) {
        output = output.write(46);
      }
      output = OutputStyle.reset(output);
      output = output.write(32).write(32);
      return output;
    }
    static displayLineLeadNumber(output, line, lineDigits) {
      const padding = lineDigits - Base10.countDigits(line);
      for (let i = 0; i < padding; i += 1) {
        output = output.write(32);
      }
      output = OutputStyle.blueBold(output);
      output = Format.displayNumber(output, line);
      output = output.write(32).write(124);
      output = OutputStyle.reset(output);
      return output;
    }
    static displayLineText(output, input, line) {
      while (input.isCont() && input.line === line) {
        output = output.write(input.head());
        input = input.step();
      }
      if (input.line === line) {
        output = output.writeln();
      }
      return output;
    }
    static consumeLineText(input, line) {
      while (input.isCont() && input.line === line) {
        input = input.step();
      }
    }
    static formatSeverity(output, severity) {
      switch (severity.level) {
       case Severity.FATAL_LEVEL:
       case Severity.ALERT_LEVEL:
       case Severity.ERROR_LEVEL:
        output = OutputStyle.redBold(output);
        break;

       case Severity.WARNING_LEVEL:
        output = OutputStyle.yellowBold(output);
        break;

       case Severity.NOTE_LEVEL:
        output = OutputStyle.greenBold(output);
        break;

       case Severity.INFO_LEVEL:
        output = OutputStyle.cyanBold(output);
        break;

       case Severity.DEBUG_LEVEL:
       case Severity.TRACE_LEVEL:
       default:
        output = OutputStyle.magentaBold(output);
      }
      return output;
    }
    toString(settings) {
      return Format.display(this, settings);
    }
    static create(input, tag, severity, message, note, cause) {
      if (arguments.length === 3) {
        cause = null;
        note = void 0;
        message = void 0;
      } else if (arguments.length === 4) {
        if (message === null || message instanceof Diagnostic) {
          cause = message;
          message = void 0;
        } else {
          cause = null;
        }
      } else if (arguments.length === 5) {
        if (note === null || note instanceof Diagnostic) {
          cause = note;
          note = void 0;
        } else {
          cause = null;
        }
      } else {
        if (cause === void 0) {
          cause = null;
        }
      }
      return new Diagnostic(input.clone(), tag, severity, message, note, cause);
    }
    static message(message, input, severity, note, cause) {
      if (arguments.length === 2) {
        cause = null;
        note = void 0;
        severity = Severity.error();
      } else if (arguments.length === 3) {
        if (severity === null || severity instanceof Diagnostic) {
          cause = severity;
          severity = Severity.error();
        } else if (typeof severity === "string") {
          cause = null;
          note = severity;
          severity = Severity.error();
        } else {
          cause = null;
        }
      } else if (arguments.length === 4) {
        if (typeof severity === "string") {
          cause = note;
          note = severity;
          severity = Severity.error();
        } else if (note === null || note instanceof Diagnostic) {
          cause = note;
          note = void 0;
        } else {
          cause = null;
        }
      } else {
        if (cause === void 0) {
          cause = null;
        }
      }
      const mark = input.mark;
      const source = input.clone();
      source.seek();
      return new Diagnostic(source, mark, severity, message, note, cause);
    }
    static unexpected(input, severity, note, cause) {
      if (arguments.length === 1) {
        cause = null;
        severity = Severity.error();
      } else if (arguments.length === 2) {
        if (severity === null || severity instanceof Diagnostic) {
          cause = severity;
          severity = Severity.error();
        } else if (typeof severity === "string") {
          cause = null;
          note = severity;
          severity = Severity.error();
        } else {
          cause = null;
        }
      } else if (arguments.length === 3) {
        if (typeof severity === "string") {
          cause = note;
          note = severity;
          severity = Severity.error();
        } else if (note === null || note instanceof Diagnostic) {
          cause = note;
          note = void 0;
        } else {
          cause = null;
        }
      } else {
        if (cause === void 0) {
          cause = null;
        }
      }
      let message;
      if (input.isCont()) {
        let output = Unicode.stringOutput().write("unexpected").write(32);
        output = Format.debugChar(output, input.head());
        message = output.bind();
      } else {
        message = "unexpected end of input";
      }
      const mark = input.mark;
      const source = input.clone();
      source.seek();
      return new Diagnostic(source, mark, severity, message, note, cause);
    }
    static expected(expected, input, severity, note, cause) {
      if (arguments.length === 2) {
        cause = null;
        severity = Severity.error();
      } else if (arguments.length === 3) {
        if (severity === null || severity instanceof Diagnostic) {
          cause = severity;
          severity = Severity.error();
        } else if (typeof severity === "string") {
          cause = null;
          note = severity;
          severity = Severity.error();
        } else {
          cause = null;
        }
      } else if (arguments.length === 4) {
        if (typeof severity === "string") {
          cause = note;
          note = severity;
          severity = Severity.error();
        } else if (note === null || note instanceof Diagnostic) {
          cause = note;
          note = void 0;
        } else {
          cause = null;
        }
      } else {
        if (cause === void 0) {
          cause = null;
        }
      }
      let output = Unicode.stringOutput().write("expected").write(32);
      if (typeof expected === "number") {
        output = Format.debugChar(output, expected);
      } else {
        output = output.write(expected);
      }
      output = output.write(44).write(32).write("but found").write(32);
      if (input.isCont()) {
        output = Format.debugChar(output, input.head());
      } else {
        output = output.write("end of input");
      }
      const message = output.bind();
      const mark = input.mark;
      const source = input.clone();
      source.seek();
      return new Diagnostic(source, mark, severity, message, note, cause);
    }
  }
  class InputEmpty extends Input {
    constructor(id, mark, settings) {
      super();
      Object.defineProperty(this, "id", {
        value: id,
        enumerable: true
      });
      Object.defineProperty(this, "mark", {
        value: mark,
        enumerable: true
      });
      Object.defineProperty(this, "settings", {
        value: settings,
        enumerable: true
      });
    }
    isCont() {
      return false;
    }
    isEmpty() {
      return true;
    }
    isDone() {
      return false;
    }
    isError() {
      return false;
    }
    isPart() {
      return true;
    }
    asPart(part) {
      return part ? this : new InputDone(this.id, this.mark, this.settings);
    }
    head() {
      throw new InputException;
    }
    step() {
      const error = new InputException("empty step");
      return new InputError(error, this.id, this.mark, this.settings);
    }
    seek(mark) {
      const error = new InputException("empty seek");
      return new InputError(error, this.id, this.mark, this.settings);
    }
    withId(id) {
      return new InputEmpty(id, this.mark, this.settings);
    }
    withMark(mark) {
      return new InputEmpty(this.id, mark, this.settings);
    }
    get offset() {
      return this.mark.offset;
    }
    get line() {
      return this.mark.line;
    }
    get column() {
      return this.mark.column;
    }
    withSettings(settings) {
      settings = InputSettings.fromAny(settings);
      return new InputEmpty(this.id, this.mark, settings);
    }
    clone() {
      return this;
    }
  }
  class InputDone extends Input {
    constructor(id, mark, settings) {
      super();
      Object.defineProperty(this, "id", {
        value: id,
        enumerable: true
      });
      Object.defineProperty(this, "mark", {
        value: mark,
        enumerable: true
      });
      Object.defineProperty(this, "settings", {
        value: settings,
        enumerable: true
      });
    }
    isCont() {
      return false;
    }
    isEmpty() {
      return false;
    }
    isDone() {
      return true;
    }
    isError() {
      return false;
    }
    isPart() {
      return false;
    }
    asPart(part) {
      return part ? new InputEmpty(this.id, this.mark, this.settings) : this;
    }
    head() {
      throw new InputException;
    }
    step() {
      const error = new InputException("done step");
      return new InputError(error, this.id, this.mark, this.settings);
    }
    seek(mark) {
      const error = new InputException("empty seek");
      return new InputError(error, this.id, this.mark, this.settings);
    }
    withId(id) {
      return new InputDone(id, this.mark, this.settings);
    }
    withMark(mark) {
      return new InputDone(this.id, mark, this.settings);
    }
    get offset() {
      return this.mark.offset;
    }
    get line() {
      return this.mark.line;
    }
    get column() {
      return this.mark.column;
    }
    withSettings(settings) {
      settings = InputSettings.fromAny(settings);
      return new InputDone(this.id, this.mark, settings);
    }
    clone() {
      return this;
    }
  }
  class InputBuffer extends Input {
    static empty() {
      return new InputBufferEmpty(void 0, Mark.zero, InputSettings.standard());
    }
    static done() {
      return new InputBufferDone(void 0, Mark.zero, InputSettings.standard());
    }
    static error(error) {
      return new InputBufferError(error, void 0, Mark.zero, InputSettings.standard());
    }
  }
  __decorate([ Lazy ], InputBuffer, "empty", null);
  __decorate([ Lazy ], InputBuffer, "done", null);
  class InputBufferEmpty extends InputBuffer {
    constructor(id, mark, settings) {
      super();
      Object.defineProperty(this, "id", {
        value: id,
        enumerable: true
      });
      Object.defineProperty(this, "mark", {
        value: mark,
        enumerable: true
      });
      Object.defineProperty(this, "settings", {
        value: settings,
        enumerable: true
      });
    }
    isCont() {
      return false;
    }
    isEmpty() {
      return true;
    }
    isDone() {
      return false;
    }
    isError() {
      return false;
    }
    isPart() {
      return true;
    }
    asPart(part) {
      return part ? this : new InputBufferDone(this.id, this.mark, this.settings);
    }
    get index() {
      return 0;
    }
    withIndex(index) {
      if (index === 0) {
        return this;
      } else {
        const error = new InputException("invalid index");
        return new InputBufferError(error, this.id, this.mark, this.settings);
      }
    }
    get limit() {
      return 0;
    }
    withLimit(limit) {
      if (limit === 0) {
        return this;
      } else {
        const error = new InputException("invalid limit");
        return new InputBufferError(error, this.id, this.mark, this.settings);
      }
    }
    get capacity() {
      return 0;
    }
    get remaining() {
      return 0;
    }
    has(index) {
      return false;
    }
    get(index) {
      throw new InputException;
    }
    set(index, token) {
      throw new InputException;
    }
    head() {
      throw new InputException;
    }
    step(offset) {
      const error = new InputException("empty step");
      return new InputBufferError(error, this.id, this.mark, this.settings);
    }
    seek(mark) {
      const error = new InputException("empty seek");
      return new InputBufferError(error, this.id, this.mark, this.settings);
    }
    withId(id) {
      return new InputBufferEmpty(id, this.mark, this.settings);
    }
    withMark(mark) {
      return new InputBufferEmpty(this.id, mark, this.settings);
    }
    get offset() {
      return this.mark.offset;
    }
    get line() {
      return this.mark.line;
    }
    get column() {
      return this.mark.column;
    }
    withSettings(settings) {
      settings = InputSettings.fromAny(settings);
      return new InputBufferEmpty(this.id, this.mark, settings);
    }
    clone() {
      return this;
    }
  }
  class InputBufferDone extends InputBuffer {
    constructor(id, mark, settings) {
      super();
      Object.defineProperty(this, "id", {
        value: id,
        enumerable: true
      });
      Object.defineProperty(this, "mark", {
        value: mark,
        enumerable: true
      });
      Object.defineProperty(this, "settings", {
        value: settings,
        enumerable: true
      });
    }
    isCont() {
      return false;
    }
    isEmpty() {
      return false;
    }
    isDone() {
      return true;
    }
    isError() {
      return false;
    }
    isPart() {
      return false;
    }
    asPart(part) {
      return part ? new InputBufferEmpty(this.id, this.mark, this.settings) : this;
    }
    get index() {
      return 0;
    }
    withIndex(index) {
      if (index === 0) {
        return this;
      } else {
        const error = new InputException("invalid index");
        return new InputBufferError(error, this.id, this.mark, this.settings);
      }
    }
    get limit() {
      return 0;
    }
    withLimit(limit) {
      if (limit === 0) {
        return this;
      } else {
        const error = new InputException("invalid limit");
        return new InputBufferError(error, this.id, this.mark, this.settings);
      }
    }
    get capacity() {
      return 0;
    }
    get remaining() {
      return 0;
    }
    has(index) {
      return false;
    }
    get(index) {
      throw new InputException;
    }
    set(index, token) {
      throw new InputException;
    }
    head() {
      throw new InputException;
    }
    step(offset) {
      const error = new InputException("done step");
      return new InputBufferError(error, this.id, this.mark, this.settings);
    }
    seek(mark) {
      const error = new InputException("done seek");
      return new InputBufferError(error, this.id, this.mark, this.settings);
    }
    withId(id) {
      return new InputBufferDone(id, this.mark, this.settings);
    }
    withMark(mark) {
      return new InputBufferDone(this.id, mark, this.settings);
    }
    get offset() {
      return this.mark.offset;
    }
    get line() {
      return this.mark.line;
    }
    get column() {
      return this.mark.column;
    }
    withSettings(settings) {
      settings = InputSettings.fromAny(settings);
      return new InputBufferDone(this.id, this.mark, settings);
    }
    clone() {
      return this;
    }
  }
  class InputBufferError extends InputBuffer {
    constructor(error, id, mark, settings) {
      super();
      Object.defineProperty(this, "error", {
        value: error,
        enumerable: true
      });
      Object.defineProperty(this, "id", {
        value: id,
        enumerable: true
      });
      Object.defineProperty(this, "mark", {
        value: mark,
        enumerable: true
      });
      Object.defineProperty(this, "settings", {
        value: settings,
        enumerable: true
      });
    }
    isCont() {
      return false;
    }
    isEmpty() {
      return false;
    }
    isDone() {
      return false;
    }
    isError() {
      return true;
    }
    isPart() {
      return false;
    }
    asPart(part) {
      return this;
    }
    get index() {
      return 0;
    }
    withIndex(index) {
      if (index === 0) {
        return this;
      } else {
        const error = new InputException("invalid index");
        return new InputBufferError(error, this.id, this.mark, this.settings);
      }
    }
    get limit() {
      return 0;
    }
    withLimit(limit) {
      if (limit === 0) {
        return this;
      } else {
        const error = new InputException("invalid limit");
        return new InputBufferError(error, this.id, this.mark, this.settings);
      }
    }
    get capacity() {
      return 0;
    }
    get remaining() {
      return 0;
    }
    has(index) {
      return false;
    }
    get(index) {
      throw new InputException;
    }
    set(index, token) {
      throw new InputException;
    }
    head() {
      throw new InputException;
    }
    step(offset) {
      const error = new InputException("error step");
      return new InputBufferError(error, this.id, this.mark, this.settings);
    }
    trap() {
      return this.error;
    }
    seek(mark) {
      const error = new InputException("error seek");
      return new InputBufferError(error, this.id, this.mark, this.settings);
    }
    withId(id) {
      return new InputBufferError(this.error, id, this.mark, this.settings);
    }
    withMark(mark) {
      return new InputBufferError(this.error, this.id, mark, this.settings);
    }
    get offset() {
      return this.mark.offset;
    }
    get line() {
      return this.mark.line;
    }
    get column() {
      return this.mark.column;
    }
    withSettings(settings) {
      settings = InputSettings.fromAny(settings);
      return new InputBufferError(this.error, this.id, this.mark, settings);
    }
    clone() {
      return this;
    }
  }
  class OutputFull extends Output {
    constructor(settings) {
      super();
      Object.defineProperty(this, "settings", {
        value: settings,
        enumerable: true
      });
    }
    isCont() {
      return false;
    }
    isFull() {
      return true;
    }
    isDone() {
      return false;
    }
    isError() {
      return false;
    }
    isPart() {
      return true;
    }
    asPart(part) {
      return part ? this : new OutputDone(this.settings);
    }
    write(tokenOrString) {
      return new OutputError(new OutputException("full"), this.settings);
    }
    writeln(string) {
      return new OutputError(new OutputException("full"), this.settings);
    }
    bind() {
      throw new OutputException;
    }
    withSettings(settings) {
      settings = OutputSettings.fromAny(settings);
      return new OutputFull(settings);
    }
    clone() {
      return this;
    }
  }
  class OutputDone extends Output {
    constructor(settings) {
      super();
      Object.defineProperty(this, "settings", {
        value: settings,
        enumerable: true
      });
    }
    isCont() {
      return false;
    }
    isFull() {
      return false;
    }
    isDone() {
      return true;
    }
    isError() {
      return false;
    }
    isPart() {
      return false;
    }
    asPart(part) {
      return part ? new OutputFull(this.settings) : this;
    }
    write(tokenOrString) {
      return new OutputError(new OutputException("done"), this.settings);
    }
    writeln(string) {
      return new OutputError(new OutputException("done"), this.settings);
    }
    bind() {
      throw new OutputException;
    }
    withSettings(settings) {
      settings = OutputSettings.fromAny(settings);
      return new OutputDone(settings);
    }
    clone() {
      return this;
    }
  }
  class OutputError extends Output {
    constructor(error, settings) {
      super();
      Object.defineProperty(this, "error", {
        value: error,
        enumerable: true
      });
      Object.defineProperty(this, "settings", {
        value: settings,
        enumerable: true
      });
    }
    isCont() {
      return false;
    }
    isFull() {
      return false;
    }
    isDone() {
      return false;
    }
    isError() {
      return true;
    }
    isPart() {
      return false;
    }
    asPart(part) {
      return this;
    }
    write(tokenOrString) {
      return this;
    }
    writeln(string) {
      return this;
    }
    bind() {
      throw new OutputException;
    }
    trap() {
      return this.error;
    }
    withSettings(settings) {
      settings = OutputSettings.fromAny(settings);
      return new OutputError(this.error, settings);
    }
    clone() {
      return this;
    }
  }
  class OutputBuffer extends Output {
    writeln(string) {
      if (typeof string === "string") {
        this.write(string);
      }
      return this.write(this.settings.lineSeparator);
    }
    flush() {
      return this;
    }
    clone() {
      throw new Error;
    }
    static full() {
      return new OutputBufferFull(OutputSettings.standard());
    }
    static done() {
      return new OutputBufferDone(OutputSettings.standard());
    }
    static error(error) {
      return new OutputBufferError(error, OutputSettings.standard());
    }
  }
  __decorate([ Lazy ], OutputBuffer, "full", null);
  __decorate([ Lazy ], OutputBuffer, "done", null);
  class OutputBufferFull extends OutputBuffer {
    constructor(settings) {
      super();
      Object.defineProperty(this, "settings", {
        value: settings,
        enumerable: true
      });
    }
    isCont() {
      return false;
    }
    isFull() {
      return true;
    }
    isDone() {
      return false;
    }
    isError() {
      return false;
    }
    isPart() {
      return true;
    }
    asPart(part) {
      return part ? this : new OutputBufferDone(this.settings);
    }
    get index() {
      return 0;
    }
    withIndex(index) {
      if (index === 0) {
        return this;
      } else {
        return new OutputBufferError(new OutputException("invalid index"), this.settings);
      }
    }
    get limit() {
      return 0;
    }
    withLimit(limit) {
      if (limit === 0) {
        return this;
      } else {
        return new OutputBufferError(new OutputException("invalid limit"), this.settings);
      }
    }
    get capacity() {
      return 0;
    }
    get remaining() {
      return 0;
    }
    has(index) {
      return false;
    }
    get(index) {
      throw new OutputException;
    }
    set(index, token) {
      throw new OutputException;
    }
    write(tokenOrString) {
      return new OutputBufferError(new OutputException("full"), this.settings);
    }
    writeln(string) {
      return new OutputBufferError(new OutputException("full"), this.settings);
    }
    step(offset = 1) {
      if (offset === 0) {
        return this;
      } else {
        return new OutputBufferError(new OutputException("invalid step"), this.settings);
      }
    }
    bind() {
      throw new OutputException;
    }
    withSettings(settings) {
      settings = OutputSettings.fromAny(settings);
      return new OutputBufferFull(settings);
    }
    clone() {
      return this;
    }
  }
  class OutputBufferDone extends OutputBuffer {
    constructor(settings) {
      super();
      Object.defineProperty(this, "settings", {
        value: settings,
        enumerable: true
      });
    }
    isCont() {
      return false;
    }
    isFull() {
      return false;
    }
    isDone() {
      return true;
    }
    isError() {
      return false;
    }
    isPart() {
      return false;
    }
    asPart(part) {
      return part ? new OutputBufferFull(this.settings) : this;
    }
    get index() {
      return 0;
    }
    withIndex(index) {
      if (index === 0) {
        return this;
      } else {
        return new OutputBufferError(new OutputException("invalid index"), this.settings);
      }
    }
    get limit() {
      return 0;
    }
    withLimit(limit) {
      if (limit === 0) {
        return this;
      } else {
        return new OutputBufferError(new OutputException("invalid limit"), this.settings);
      }
    }
    get capacity() {
      return 0;
    }
    get remaining() {
      return 0;
    }
    has(index) {
      return false;
    }
    get(index) {
      throw new OutputException;
    }
    set(index, token) {
      throw new OutputException;
    }
    write(tokenOrString) {
      return new OutputBufferError(new OutputException("done"), this.settings);
    }
    writeln(string) {
      return new OutputBufferError(new OutputException("done"), this.settings);
    }
    step(offset = 1) {
      if (offset === 0) {
        return this;
      } else {
        return new OutputBufferError(new OutputException("invalid step"), this.settings);
      }
    }
    bind() {
      throw new OutputException;
    }
    withSettings(settings) {
      settings = OutputSettings.fromAny(settings);
      return new OutputBufferDone(settings);
    }
    clone() {
      return this;
    }
  }
  class OutputBufferError extends OutputBuffer {
    constructor(error, settings) {
      super();
      Object.defineProperty(this, "error", {
        value: error,
        enumerable: true
      });
      Object.defineProperty(this, "settings", {
        value: settings,
        enumerable: true
      });
    }
    isCont() {
      return false;
    }
    isFull() {
      return false;
    }
    isDone() {
      return false;
    }
    isError() {
      return true;
    }
    isPart() {
      return false;
    }
    asPart(part) {
      return this;
    }
    get index() {
      return 0;
    }
    withIndex(index) {
      if (index === 0) {
        return this;
      } else {
        return new OutputBufferError(new OutputException("invalid index"), this.settings);
      }
    }
    get limit() {
      return 0;
    }
    withLimit(limit) {
      if (limit === 0) {
        return this;
      } else {
        return new OutputBufferError(new OutputException("invalid limit"), this.settings);
      }
    }
    get capacity() {
      return 0;
    }
    get remaining() {
      return 0;
    }
    has(index) {
      return false;
    }
    get(index) {
      throw new OutputException;
    }
    set(index, token) {
      throw new OutputException;
    }
    write(tokenOrString) {
      return this;
    }
    writeln(string) {
      return this;
    }
    step(offset = 1) {
      if (offset === 0) {
        return this;
      } else {
        return new OutputBufferError(new OutputException("invalid step"), this.settings);
      }
    }
    bind() {
      throw new OutputException;
    }
    trap() {
      return this.error;
    }
    withSettings(settings) {
      settings = OutputSettings.fromAny(settings);
      return new OutputBufferError(this.error, settings);
    }
    clone() {
      return this;
    }
  }
  class ParserException extends Error {
    constructor(message) {
      super(message instanceof Diagnostic ? message.message : message);
      Object.setPrototypeOf(this, ParserException.prototype);
      this.diagnostic = message instanceof Diagnostic ? message : null;
    }
    toString() {
      if (this.diagnostic !== null) {
        return this.diagnostic.toString();
      } else {
        return super.toString();
      }
    }
  }
  class Parser {
    isCont() {
      return true;
    }
    isDone() {
      return false;
    }
    isError() {
      return false;
    }
    fork(condition) {
      return this;
    }
    bind() {
      throw new ParserException;
    }
    trap() {
      throw new ParserException;
    }
    asError() {
      throw new ParserException;
    }
    static done(value) {
      return new ParserDone(value);
    }
    static error(error) {
      if (error instanceof Error) {
        return new ParserError(error);
      } else {
        return new ParserError(new ParserException(error));
      }
    }
  }
  class ParserDone extends Parser {
    constructor(value) {
      super();
      Object.defineProperty(this, "value", {
        value: value,
        enumerable: true
      });
    }
    isCont() {
      return false;
    }
    isDone() {
      return true;
    }
    feed(input) {
      return this;
    }
    bind() {
      return this.value;
    }
  }
  class ParserError extends Parser {
    constructor(error) {
      super();
      Object.defineProperty(this, "error", {
        value: error,
        enumerable: true
      });
    }
    isCont() {
      return false;
    }
    isError() {
      return true;
    }
    feed(input) {
      return this;
    }
    bind() {
      throw this.error;
    }
    trap() {
      return this.error;
    }
    asError() {
      return this;
    }
  }
  class WriterEnd extends Writer {
    constructor() {
      super();
    }
    isCont() {
      return false;
    }
    isDone() {
      return true;
    }
    pull(output) {
      return this;
    }
    bind() {
      throw new WriterException;
    }
    asDone() {
      return this;
    }
    andThen(that) {
      return that;
    }
  }
  class WriterDone extends Writer {
    constructor(value) {
      super();
      Object.defineProperty(this, "value", {
        value: value,
        enumerable: true
      });
    }
    isCont() {
      return false;
    }
    isDone() {
      return true;
    }
    pull(output) {
      return this;
    }
    bind() {
      return this.value;
    }
    asDone() {
      return this;
    }
    andThen(that) {
      return that;
    }
  }
  class WriterError extends Writer {
    constructor(error) {
      super();
      Object.defineProperty(this, "error", {
        value: error,
        enumerable: true
      });
    }
    isCont() {
      return false;
    }
    isError() {
      return true;
    }
    pull(output) {
      return this;
    }
    bind() {
      throw this.error;
    }
    trap() {
      return this.error;
    }
    asError() {
      return this;
    }
    andThen(that) {
      return this;
    }
  }
  class WriterSequence extends Writer {
    constructor(head, tail) {
      super();
      this.head = head;
      this.tail = tail;
    }
    pull(output) {
      let head = this.head;
      if (head.isCont()) {
        head = head.pull(output);
      }
      if (head.isError()) {
        return head.asError();
      } else if (head.isDone()) {
        return this.tail.pull(output);
      } else {
        return new WriterSequence(head, this.tail);
      }
    }
  }
  class ByteOutput extends Output {
    constructor(array, size, settings) {
      super();
      this.array = array;
      this.size = size;
      this.settings = settings;
    }
    isCont() {
      return true;
    }
    isFull() {
      return false;
    }
    isDone() {
      return false;
    }
    isError() {
      return false;
    }
    isPart() {
      return false;
    }
    asPart(part) {
      return this;
    }
    write(b) {
      if (typeof b === "number") {
        const n = this.size;
        const oldArray = this.array;
        let newArray;
        if (oldArray === null || n + 1 > oldArray.length) {
          newArray = new Uint8Array(ByteOutput.expand(n + 1));
          if (oldArray !== null) {
            newArray.set(oldArray, 0);
          }
          this.array = newArray;
        } else {
          newArray = oldArray;
        }
        newArray[n] = b;
        this.size = n + 1;
        return this;
      } else {
        throw new TypeError("" + b);
      }
    }
    writeln(string) {
      throw new TypeError("" + string);
    }
    toUint8Array() {
      const n = this.size;
      const oldArray = this.array;
      if (oldArray !== null && n === oldArray.length) {
        return oldArray;
      } else {
        const newArray = new Uint8Array(n);
        if (oldArray !== null) {
          newArray.set(oldArray.slice(0, n), 0);
        }
        this.array = newArray;
        return newArray;
      }
    }
    cloneArray() {
      const oldArray = this.array;
      if (oldArray !== null) {
        return oldArray.slice(0, this.size);
      } else {
        return null;
      }
    }
    withSettings(settings) {
      settings = OutputSettings.fromAny(settings);
      this.settings = settings;
      return this;
    }
    static expand(n) {
      n = Math.max(32, n) - 1;
      n |= n >> 1;
      n |= n >> 2;
      n |= n >> 4;
      n |= n >> 8;
      n |= n >> 16;
      return n + 1;
    }
  }
  class ByteOutputUint8Array extends ByteOutput {
    constructor(array, size, settings) {
      super(array, size, settings);
    }
    bind() {
      return this.toUint8Array();
    }
    clone() {
      return new ByteOutputUint8Array(this.cloneArray(), this.size, this.settings);
    }
  }
  class ByteOutputBuffer extends OutputBuffer {
    constructor(array, index, limit, part, settings) {
      super();
      this.array = array;
      this.index = index;
      this.limit = limit;
      this.part = part;
      this.settings = settings;
    }
    isCont() {
      return this.index < this.limit;
    }
    isFull() {
      return this.part && this.index >= this.limit;
    }
    isDone() {
      return !this.part && this.index >= this.limit;
    }
    isError() {
      return false;
    }
    isPart() {
      return this.part;
    }
    asPart(part) {
      this.part = part;
      return this;
    }
    withIndex(index) {
      if (0 <= index && index <= this.limit) {
        this.index = index;
        return this;
      } else {
        return new OutputBufferError(new OutputException("invalid index"), this.settings);
      }
    }
    withLimit(limit) {
      if (0 <= limit && limit <= this.array.length) {
        this.limit = limit;
        return this;
      } else {
        return new OutputBufferError(new OutputException("invalid limit"), this.settings);
      }
    }
    get capacity() {
      return this.array.length;
    }
    get remaining() {
      return this.limit - this.index;
    }
    has(index) {
      return 0 <= index && index < this.limit;
    }
    get(index) {
      if (0 <= index && index < this.limit) {
        return this.array[index];
      } else {
        throw new OutputException;
      }
    }
    set(index, token) {
      if (0 <= index && index < this.limit) {
        this.array[index] = token;
      } else {
        throw new OutputException;
      }
    }
    write(token) {
      if (typeof token === "number") {
        const index = this.index;
        if (index < this.limit) {
          this.array[index] = token;
          this.index += 1;
          return this;
        } else {
          return new OutputBufferError(new OutputException("full"), this.settings);
        }
      } else {
        return new OutputBufferError(new OutputException("binary output"), this.settings);
      }
    }
    writeln(string) {
      return new OutputBufferError(new OutputException("binary output"), this.settings);
    }
    step(offset) {
      const index = this.index + offset;
      if (0 <= index && index <= this.limit) {
        this.index = index;
        return this;
      } else {
        return new OutputBufferError(new OutputException("invalid step"), this.settings);
      }
    }
    bind() {
      return new Uint8Array(this.array.buffer, 0, this.index);
    }
    withSettings(settings) {
      settings = OutputSettings.fromAny(settings);
      this.settings = settings;
      return this;
    }
    clone() {
      return new ByteOutputBuffer(this.array, this.index, this.limit, this.part, this.settings);
    }
    static create(array, offset, length) {
      if (offset === void 0) {
        offset = 0;
      }
      if (length === void 0) {
        length = array.length;
      }
      return new ByteOutputBuffer(array, offset, offset + length, false, OutputSettings.standard());
    }
  }
  const Binary = function() {
    const Binary = {};
    Binary.output = function(initialCapacity, settings) {
      if (settings === void 0 && typeof initialCapacity !== "number") {
        settings = initialCapacity;
        initialCapacity = void 0;
      } else if (typeof initialCapacity !== "number") {
        initialCapacity = void 0;
      }
      let array;
      if (typeof initialCapacity === "number") {
        array = new Uint8Array(initialCapacity);
      } else {
        array = null;
      }
      settings = OutputSettings.fromAny(settings);
      return new ByteOutputUint8Array(array, 0, settings);
    };
    Binary.outputBuffer = function(array, offset, length) {
      return ByteOutputBuffer.create(array, offset, length);
    };
    return Binary;
  }();
  class UtfErrorMode {
    isFatal() {
      return false;
    }
    isReplacement() {
      return false;
    }
    toString() {
      return Format.debug(this);
    }
    static fatal() {
      return new UtfErrorModeFatal(false);
    }
    static fatalNonZero() {
      return new UtfErrorModeFatal(true);
    }
    static replacement() {
      return new UtfErrorModeReplacement(65533, false);
    }
    static replacementNonZero() {
      return new UtfErrorModeReplacement(65533, true);
    }
  }
  __decorate([ Lazy ], UtfErrorMode, "fatal", null);
  __decorate([ Lazy ], UtfErrorMode, "fatalNonZero", null);
  __decorate([ Lazy ], UtfErrorMode, "replacement", null);
  __decorate([ Lazy ], UtfErrorMode, "replacementNonZero", null);
  class UtfErrorModeFatal extends UtfErrorMode {
    constructor(nonZero) {
      super();
      Object.defineProperty(this, "nonZero", {
        value: nonZero,
        enumerable: true
      });
    }
    isFatal() {
      return true;
    }
    get replacementChar() {
      return 65533;
    }
    isNonZero() {
      return this.nonZero;
    }
    asNonZero(nonZero) {
      if (nonZero) {
        return UtfErrorMode.fatalNonZero();
      } else {
        return UtfErrorMode.fatal();
      }
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof UtfErrorModeFatal) {
        return this.nonZero === that.nonZero;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(UtfErrorModeFatal), Booleans.hash(this.nonZero)));
    }
    debug(output) {
      output = output.write("UtfErrorMode").write(46).write(this.nonZero ? "fatalNonZero" : "fatal").write(40).write(41);
      return output;
    }
  }
  class UtfErrorModeReplacement extends UtfErrorMode {
    constructor(replacementChar, nonZero) {
      super();
      Object.defineProperty(this, "replacementChar", {
        value: replacementChar,
        enumerable: true
      });
      Object.defineProperty(this, "nonZero", {
        value: nonZero,
        enumerable: true
      });
    }
    isReplacement() {
      return true;
    }
    isNonZero() {
      return this.nonZero;
    }
    asNonZero(nonZero) {
      if (this.replacementChar === 65533) {
        if (nonZero) {
          return UtfErrorMode.replacementNonZero();
        } else {
          return UtfErrorMode.replacement();
        }
      } else {
        return new UtfErrorModeReplacement(this.replacementChar, nonZero);
      }
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof UtfErrorModeReplacement) {
        return this.replacementChar === that.replacementChar && this.nonZero === that.nonZero;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(UtfErrorModeReplacement), Numbers.hash(this.replacementChar)), Booleans.hash(this.nonZero)));
    }
    debug(output) {
      output = output.write("UtfErrorMode").write(46).write(this.nonZero ? "replacementNonZero" : "replacement").write(40).write(41);
      return output;
    }
  }
  class Base16 {
    constructor(alphabet) {
      Object.defineProperty(this, "alphabet", {
        value: alphabet,
        enumerable: true
      });
    }
    encodeDigit(b) {
      return this.alphabet.charCodeAt(b);
    }
    uint8ArrayWriter(input) {
      if (input === void 0) {
        return new Base16Writer(this, void 0, null);
      } else {
        return new Base16Writer(this, input, input);
      }
    }
    writeUint8Array(output, input) {
      return Base16Writer.write(output, this, void 0, input);
    }
    writeInteger(output, input, width = 0) {
      return Base16IntegerWriter.write(output, this, void 0, input, width);
    }
    writeIntegerLiteral(output, input, width = 0) {
      return Base16IntegerWriter.writeLiteral(output, this, void 0, input, width);
    }
    static get lowercase() {
      return new Base16("0123456789abcdef");
    }
    static get uppercase() {
      return new Base16("0123456789ABCDEF");
    }
    static isDigit(c) {
      return c >= 48 && c <= 57 || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    static decodeDigit(c) {
      if (c >= 48 && c <= 57) {
        return c - 48;
      } else if (c >= 65 && c <= 70) {
        return 10 + (c - 65);
      } else if (c >= 97 && c <= 102) {
        return 10 + (c - 97);
      } else {
        let message = Unicode.stringOutput();
        message = message.write("Invalid base-16 digit: ");
        message = Format.debugChar(message, c);
        throw new Error(message.bind());
      }
    }
    static writeQuantum(output, c1, c2) {
      const x = Base16.decodeDigit(c1);
      const y = Base16.decodeDigit(c2);
      output = output.write(x << 4 | y);
      return output;
    }
    static parser(output) {
      return new Base16Parser(output);
    }
    static parse(input, output) {
      return Base16Parser.parse(input, output);
    }
    static parseUint8Array(input) {
      return Base16Parser.parse(input, Binary.output());
    }
  }
  __decorate([ Lazy ], Base16, "lowercase", null);
  __decorate([ Lazy ], Base16, "uppercase", null);
  class Utf8DecodedOutput extends Output {
    constructor(output, errorMode, c1, c2, c3, have) {
      super();
      this.output = output;
      this.errorMode = errorMode;
      this.c1 = c1;
      this.c2 = c2;
      this.c3 = c3;
      this.have = have;
    }
    isCont() {
      return this.output.isCont();
    }
    isFull() {
      return this.output.isFull();
    }
    isDone() {
      return this.output.isDone();
    }
    isError() {
      return this.output.isError();
    }
    isPart() {
      return this.output.isPart();
    }
    asPart(part) {
      this.output = this.output.asPart(part);
      return this;
    }
    write(token) {
      if (typeof token === "number") {
        let c1 = this.c1;
        let c2 = this.c2;
        let c3 = this.c3;
        let c4 = -1;
        let have = this.have;
        if (token >= 0) {
          switch (have) {
           case 0:
            c1 = token & 255;
            have = 1;
            break;

           case 1:
            c2 = token & 255;
            have = 2;
            break;

           case 2:
            c3 = token & 255;
            have = 3;
            break;

           case 3:
            c4 = token & 255;
            have = 4;
            break;

           default:
            throw new Error("unreachable");
          }
        }
        if (c1 === 0 && this.errorMode.isNonZero()) {
          return Output.error(new OutputException("unexpected NUL byte"));
        } else if (c1 >= 0 && c1 <= 127) {
          this.output = this.output.write(c1);
          this.have = 0;
        } else if (c1 >= 194 && c1 <= 244) {
          if (c1 >= 194 && c1 <= 223 && c2 >= 128 && c2 <= 191) {
            this.output = this.output.write((c1 & 31) << 6 | c2 & 63);
            this.c1 = -1;
            this.have = 0;
          } else if (c1 === 224 && c2 >= 160 && c2 <= 191 || c1 >= 225 && c1 <= 236 && c2 >= 128 && c2 <= 191 || c1 === 237 && c2 >= 128 && c2 <= 159 || c1 >= 238 && c1 <= 239 && c2 >= 128 && c2 <= 191) {
            if (c3 >= 128 && c3 <= 191) {
              this.output = this.output.write((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
              this.c1 = -1;
              this.c2 = -1;
              this.have = 0;
            } else if (c3 >= 0) {
              if (this.errorMode.isFatal()) {
                return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2, c3)));
              }
              this.output = this.output.write(this.errorMode.replacementChar);
              this.c1 = c3;
              this.c2 = -1;
              this.have = 1;
            } else if (token < 0 || this.output.isDone()) {
              return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2)));
            } else {
              this.c2 = c2;
              this.have = 2;
            }
          } else if (c1 === 240 && c2 >= 144 && c2 <= 191 || c1 >= 241 && c1 <= 243 && c2 >= 128 && c2 <= 191 || c1 === 244 && c2 >= 128 && c2 <= 143) {
            if (c3 >= 128 && c3 <= 191) {
              if (c4 >= 128 && c4 <= 191) {
                this.have = 4;
                this.output = this.output.write((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63);
                this.c1 = -1;
                this.c2 = -1;
                this.c3 = -1;
                this.have = 0;
              } else if (c4 >= 0) {
                if (this.errorMode.isFatal()) {
                  return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2, c3, c4)));
                }
                this.output = this.output.write(this.errorMode.replacementChar);
                this.c1 = c4;
                this.c2 = -1;
                this.c3 = -1;
                this.have = 1;
              } else if (token < 0 || this.output.isDone()) {
                return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2, c3)));
              } else {
                this.c3 = c3;
                this.have = 3;
              }
            } else if (c3 >= 0) {
              if (this.errorMode.isFatal()) {
                return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2, c3)));
              }
              this.output = this.output.write(this.errorMode.replacementChar);
              this.c1 = c3;
              this.c2 = -1;
              this.have = 1;
            } else if (token < 0 || this.output.isDone()) {
              return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2)));
            } else {
              this.c2 = c2;
              this.have = 2;
            }
          } else if (c2 >= 0) {
            if (this.errorMode.isFatal()) {
              return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2)));
            }
            this.output = this.output.write(this.errorMode.replacementChar);
            this.c1 = c2;
            this.have = 1;
          } else if (token < 0 || this.output.isDone()) {
            return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1)));
          } else {
            this.c1 = c1;
            this.have = 1;
          }
        } else if (c1 >= 0) {
          if (this.errorMode.isFatal()) {
            return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1)));
          }
          this.output = this.output.write(this.errorMode.replacementChar);
          this.have = 0;
        }
        if (this.output.isError()) {
          return this.output;
        }
        return this;
      } else if (typeof token === "string") {
        this.output = this.output.write(token);
        return this;
      } else {
        throw new TypeError("" + token);
      }
    }
    static invalid(c1, c2, c3, c4) {
      let output = Unicode.stringOutput();
      output = output.write("invalid UTF-8 code unit sequence: ");
      const base16 = Base16.uppercase;
      base16.writeIntegerLiteral(output, c1, 2);
      if (c2 !== void 0) {
        output = output.write(" ");
        base16.writeIntegerLiteral(output, c2, 2);
        if (c3 !== void 0) {
          output = output.write(" ");
          base16.writeIntegerLiteral(output, c3, 2);
          if (c4 !== void 0) {
            output = output.write(" ");
            base16.writeIntegerLiteral(output, c4, 2);
          }
        }
      }
      return output.bind();
    }
    get settings() {
      return this.output.settings;
    }
    withSettings(settings) {
      this.output = this.output.withSettings(settings);
      return this;
    }
    bind() {
      if (this.have === 0) {
        return this.output.bind();
      } else {
        return this.write(-1).bind();
      }
    }
    trap() {
      return this.output.trap();
    }
    clone() {
      return new Utf8DecodedOutput(this.output.clone(), this.errorMode, this.c1, this.c2, this.c3, this.have);
    }
    static create(output, errorMode) {
      if (errorMode === void 0) {
        errorMode = UtfErrorMode.fatal();
      }
      return new Utf8DecodedOutput(output, errorMode, -1, -1, -1, 0);
    }
  }
  class Utf8EncodedOutput extends Output {
    constructor(output, errorMode, c2, c3, c4, index) {
      super();
      this.output = output;
      this.errorMode = errorMode;
      this.c2 = c2;
      this.c3 = c3;
      this.c4 = c4;
      this.index = index;
    }
    isCont() {
      return this.output.isCont();
    }
    isFull() {
      return this.output.isFull();
    }
    isDone() {
      return this.output.isDone();
    }
    isError() {
      return false;
    }
    isPart() {
      return this.output.isPart();
    }
    asPart(part) {
      this.output = this.output.asPart(part);
      return this;
    }
    write(token) {
      if (typeof token === "number") {
        let c1 = 0;
        let c2 = this.c2;
        let c3 = this.c3;
        let c4 = this.c4;
        let output = this.output;
        let index = this.index;
        while (index < 4) {
          if (output.isCont()) {
            switch (index) {
             case 1:
              output = output.write(c2);
              this.c2 = 0;
              break;

             case 2:
              output = output.write(c3);
              this.c3 = 0;
              break;

             case 3:
              output = output.write(c4);
              this.c4 = 0;
              break;

             default:
              throw new Error("unreachable");
            }
            index += 1;
          } else {
            return Output.error(new OutputException("unable to flush buffered code units"));
          }
        }
        if (token >= 0 && token <= 127) {
          c4 = token;
          index = 3;
        } else if (token >= 128 && token <= 2047) {
          c3 = 192 | token >>> 6;
          c4 = 128 | token & 63;
          index = 2;
        } else if (token >= 2048 && token <= 65535 || token >= 57344 && token <= 65535) {
          c2 = 224 | token >>> 12;
          c3 = 128 | token >>> 6 & 63;
          c4 = 128 | token & 63;
          index = 1;
        } else if (token >= 65536 && token <= 1114111) {
          c1 = 240 | token >>> 18;
          c2 = 128 | token >>> 12 & 63;
          c3 = 128 | token >>> 6 & 63;
          c4 = 128 | token & 63;
          index = 0;
        } else {
          if (this.errorMode.isFatal()) {
            return Output.error(new OutputException("invalid code point: " + token));
          } else {
            return this.write(this.errorMode.replacementChar);
          }
        }
        do {
          switch (index) {
           case 0:
            output = output.write(c1);
            break;

           case 1:
            output = output.write(c2);
            this.c2 = 0;
            break;

           case 2:
            output = output.write(c3);
            this.c3 = 0;
            break;

           case 3:
            output = output.write(c4);
            this.c4 = 0;
            break;

           default:
            throw new Error("unreachable");
          }
          this.output = output;
          index += 1;
        } while (index < 4 && output.isCont());
        if (index < 4) {
          if (index < 3) {
            if (index < 2) {
              this.c2 = c2;
            }
            this.c3 = c3;
          }
          this.c4 = c4;
        }
        this.output = output;
        this.index = index;
        return this;
      } else if (typeof token === "string") {
        this.output = this.output.write(token);
        return this;
      } else {
        throw new TypeError("" + token);
      }
    }
    flush() {
      let output = this.output;
      let index = this.index;
      while (index < 4) {
        if (output.isCont()) {
          switch (index) {
           case 1:
            output = output.write(this.c2);
            this.c2 = 0;
            break;

           case 2:
            output = output.write(this.c3);
            this.c3 = 0;
            break;

           case 3:
            output = output.write(this.c4);
            this.c4 = 0;
            break;

           default:
            throw new Error("unreachable");
          }
          index += 1;
        } else {
          return Output.error(new OutputException("unable to flush buffered code units"));
        }
      }
      this.output = output;
      this.index = index;
      return this;
    }
    get settings() {
      return this.output.settings;
    }
    withSettings(settings) {
      this.output = this.output.withSettings(settings);
      return this;
    }
    bind() {
      return this.output.bind();
    }
    clone() {
      return new Utf8EncodedOutput(this.output.clone(), this.errorMode, this.c2, this.c3, this.c4, this.index);
    }
    static create(output, errorMode) {
      if (errorMode === void 0) {
        errorMode = UtfErrorMode.fatal();
      }
      return new Utf8EncodedOutput(output, errorMode, 0, 0, 0, 4);
    }
  }
  const Utf8 = function() {
    const Utf8 = {};
    Utf8.sizeOf = function(u, errorMode) {
      if (typeof u === "number" || u === void 0) {
        if (typeof u === "number") {
          if (u === 0 && errorMode !== void 0 && errorMode.isNonZero()) {
            return 2;
          } else if (u >= 0 && u <= 127) {
            return 1;
          } else if (u >= 128 && u <= 2047) {
            return 2;
          } else if (u >= 2048 && u <= 65535 || u >= 57344 && u <= 65535) {
            return 3;
          } else if (u >= 65536 && u <= 1114111) {
            return 4;
          }
        }
        if (errorMode === void 0) {
          return 3;
        } else if (errorMode.isReplacement()) {
          return Utf8.sizeOf(errorMode.replacementChar);
        } else {
          return 0;
        }
      } else if (typeof u === "string") {
        let size = 0;
        for (let i = 0, n = u.length; i < n; i = Strings.offsetByCodePoints(u, i, 1)) {
          size += Utf8.sizeOf(u.charCodeAt(i), errorMode);
        }
        return size;
      } else {
        throw new TypeError("" + u);
      }
    };
    Utf8.decodedOutput = function(output, errorMode) {
      return Utf8DecodedOutput.create(output, errorMode);
    };
    Utf8.encodedOutput = function(output, errorMode) {
      return Utf8EncodedOutput.create(output, errorMode);
    };
    Utf8.decodedString = function() {
      return Utf8.decodedOutput(Unicode.stringOutput());
    };
    return Utf8;
  }();
  class Base10NumberParser extends Parser {
    constructor(sign = 1, value = 0, mode = 2, step = 1) {
      super();
      this.sign = sign;
      this.value = value;
      this.mode = mode;
      this.step = step;
    }
    feed(input) {
      return Base10NumberParser.parse(input, this.sign, this.value, this.mode, this.step);
    }
    static parse(input, sign = 1, value = 0, mode = 2, step = 1) {
      let c = 0;
      if (step === 1) {
        if (input.isCont()) {
          c = input.head();
          if (c === 45) {
            input = input.step();
            sign = -1;
          } else if (c === 43) {
            input = input.step();
            sign = 1;
          }
          step = 2;
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected("number", input));
        }
      }
      if (step === 2) {
        if (input.isCont()) {
          c = input.head();
          if (c === 48) {
            input = input.step();
            step = 4;
          } else if (c >= 49 && c <= 57) {
            input = input.step();
            value = sign * (c - 48);
            step = 3;
          } else if (mode > 0 && c === 46) {
            let output = Unicode.stringOutput();
            if (sign < 0) {
              output = output.write(45);
            }
            return Base10DecimalParser.parse(input, output, mode);
          } else {
            return Parser.error(Diagnostic.expected("number", input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected("number", input));
        }
      }
      if (step === 3) {
        while (input.isCont()) {
          c = input.head();
          if (c >= 48 && c <= 57) {
            const newValue = 10 * value + sign * (c - 48);
            if (-9007199254740991 <= newValue && newValue <= 9007199254740992) {
              value = newValue;
              input = input.step();
            } else {
              return Parser.error(Diagnostic.message("integer overflow", input));
            }
          } else {
            break;
          }
        }
        if (input.isCont()) {
          step = 4;
        } else if (input.isDone()) {
          return Parser.done(value);
        }
      }
      if (step === 4) {
        if (input.isCont()) {
          c = input.head();
          if (mode > 0 && c === 46 || mode > 1 && (c === 69 || c === 101)) {
            let output = Unicode.stringOutput();
            if (sign < 0 && value === 0) {
              output = output.write(45).write(48);
            } else {
              output = output.write("" + value);
            }
            return Base10DecimalParser.parse(input, output, mode);
          } else {
            return Parser.done(value);
          }
        } else if (input.isDone()) {
          return Parser.done(value);
        }
      }
      return new Base10NumberParser(sign, value, mode, step);
    }
  }
  class Base10DecimalParser extends Parser {
    constructor(output, mode = 2, step = 1) {
      super();
      this.output = output;
      this.mode = mode;
      this.step = step;
    }
    feed(input) {
      return Base10DecimalParser.parse(input, this.output, this.mode, this.step);
    }
    static parse(input, output, mode = 2, step = 1) {
      let c = 0;
      if (step === 1) {
        if (input.isCont()) {
          c = input.head();
          if (c === 46) {
            input = input.step();
            output = output.write(c);
            step = 2;
          } else if (mode > 1 && (c === 69 || c === 101)) {
            input = input.step();
            output = output.write(c);
            step = 5;
          } else {
            return Parser.error(Diagnostic.expected("decimal or exponent", input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected("decimal or exponent", input));
        }
      }
      if (step === 2) {
        if (input.isCont()) {
          c = input.head();
          if (c >= 48 && c <= 57) {
            input = input.step();
            output = output.write(c);
            step = 3;
          } else {
            return Parser.error(Diagnostic.expected("digit", input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected("digit", input));
        }
      }
      if (step === 3) {
        while (input.isCont()) {
          c = input.head();
          if (c >= 48 && c <= 57) {
            input = input.step();
            output = output.write(c);
          } else {
            break;
          }
        }
        if (input.isCont()) {
          if (mode > 1) {
            step = 4;
          } else {
            return Parser.done(+output.bind());
          }
        } else if (input.isDone()) {
          return Parser.done(+output.bind());
        }
      }
      if (step === 4) {
        c = input.head();
        if (c === 69 || c === 101) {
          input = input.step();
          output = output.write(c);
          step = 5;
        } else {
          return Parser.done(+output.bind());
        }
      }
      if (step === 5) {
        if (input.isCont()) {
          c = input.head();
          if (c === 43 || c === 45) {
            input = input.step();
            output = output.write(c);
          }
          step = 6;
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      if (step === 6) {
        if (input.isCont()) {
          c = input.head();
          if (c >= 48 && c <= 57) {
            input = input.step();
            output = output.write(c);
            step = 7;
          } else {
            return Parser.error(Diagnostic.expected("digit", input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected("digit", input));
        }
      }
      if (step === 7) {
        while (input.isCont()) {
          c = input.head();
          if (c >= 48 && c <= 57) {
            input = input.step();
            output = output.write(c);
          } else {
            break;
          }
        }
        if (!input.isEmpty()) {
          return Parser.done(+output.bind());
        }
      }
      return new Base10DecimalParser(output, mode, step);
    }
  }
  class Base10IntegerWriter extends Writer {
    constructor(value, input, index = 0, step = 1) {
      super();
      this.value = value;
      this.input = input;
      this.index = index;
      this.step = step;
    }
    pull(output) {
      return Base10IntegerWriter.write(output, this.value, this.input, this.index, this.step);
    }
    static write(output, value, input, index = 0, step = 1) {
      if (step === 0) {
        return Writer.end();
      }
      if (step === 1) {
        if (input < 0) {
          if (output.isCont()) {
            output = output.write(45);
            step = 2;
          }
        } else {
          step = 2;
        }
      }
      if (step === 2) {
        if (input > -10 && input < 10) {
          if (output.isCont()) {
            output = output.write(Base10.encodeDigit(Math.abs(input | 0)));
            return Writer.done(value);
          }
        } else {
          const digits = new Array(19);
          let x = input;
          let i = 18;
          while (x !== 0) {
            digits[i] = Math.abs(x % 10 | 0);
            x = x / 10 | 0;
            i -= 1;
          }
          i += 1 + index;
          while (i < 19 && output.isCont()) {
            output = output.write(Base10.encodeDigit(digits[i]));
            index += 1;
            i += 1;
          }
          if (i === 19) {
            return Writer.done(value);
          }
        }
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new Base10IntegerWriter(value, input, index, step);
    }
  }
  class Base16Parser extends Parser {
    constructor(output, p = 0, step = 1) {
      super();
      this.output = output;
      this.p = p;
      this.step = step;
    }
    feed(input) {
      return Base16Parser.parse(input, this.output.clone(), this.p, this.step);
    }
    static parse(input, output, p = 0, step = 1) {
      let c = 0;
      while (!input.isEmpty()) {
        if (step === 1) {
          if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
            input = input.step();
            p = c;
            step = 2;
          } else if (!input.isEmpty()) {
            return Parser.done(output.bind());
          }
        }
        if (step === 2) {
          if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
            input = input.step();
            output = Base16.writeQuantum(output, p, c);
            p = 0;
            step = 1;
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected("base16 digit", input));
          }
        }
      }
      return new Base16Parser(output, p, step);
    }
  }
  class Base16Writer extends Writer {
    constructor(base16, value, input, index = 0, step = 1) {
      super();
      this.base16 = base16;
      this.value = value;
      this.input = input;
      this.index = index;
      this.step = step;
    }
    feed(value) {
      if (value instanceof Uint8Array) {
        return new Base16Writer(this.base16, void 0, value);
      } else {
        throw new TypeError("" + value);
      }
    }
    pull(output) {
      if (this.input === null) {
        throw new WriterException;
      }
      return Base16Writer.write(output, this.base16, this.value, this.input, this.index, this.step);
    }
    static write(output, base16, value, input, index = 0, step = 1) {
      while (index < input.length) {
        const x = input[index];
        if (step === 1 && output.isCont()) {
          output = output.write(base16.encodeDigit(x >>> 4));
          step = 2;
        }
        if (step === 2 && output.isCont()) {
          output = output.write(base16.encodeDigit(x & 15));
          index += 1;
          step = 1;
        }
      }
      if (index === input.length) {
        return Writer.done(value);
      } else if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new Base16Writer(base16, value, input, index, step);
    }
  }
  class Base16IntegerWriter extends Writer {
    constructor(base16, value, input, width, index = 0, step = 3) {
      super();
      this.base16 = base16;
      this.value = value;
      this.input = input;
      this.width = width;
      this.index = index;
      this.step = step;
    }
    pull(output) {
      return Base16IntegerWriter.write(output, this.base16, this.value, this.input, this.width, this.index, this.step);
    }
    static write(output, base16, value, input, width, index = 0, step = 3) {
      if (step <= 0) {
        return Writer.end();
      }
      if (step === 1 && output.isCont()) {
        output = output.write(48);
        step = 2;
      }
      if (step === 2 && output.isCont()) {
        output = output.write(120);
        step = 3;
      }
      if (step === 3) {
        if (input >= 0 && input < 16 && width <= 1) {
          if (output.isCont()) {
            output = output.write(base16.encodeDigit(input));
            return Writer.done(value);
          }
        } else {
          let i = 15;
          const digits = new Array(16);
          let x = input;
          while (x !== 0 || i >= 16 - width) {
            digits[i] = x & 15;
            x >>>= 4;
            i -= 1;
          }
          i += 1 + index;
          while (i < 16 && output.isCont()) {
            output = output.write(base16.encodeDigit(digits[i]));
            index += 1;
            i += 1;
          }
          if (i === 16) {
            return Writer.done(value);
          }
        }
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new Base16IntegerWriter(base16, value, input, width, index, step);
    }
    static writeLiteral(output, base16, value, input, width) {
      return Base16IntegerWriter.write(output, base16, value, input, width, 0, 1);
    }
  }
  class Base64 {
    decodeDigit(c) {
      if (c >= 65 && c <= 90) {
        return c - 65;
      } else if (c >= 97 && c <= 122) {
        return c + (26 - 97);
      } else if (c >= 48 && c <= 57) {
        return c + (52 - 48);
      } else if (c === 43 || c === 45) {
        return 62;
      } else if (c === 47 || c === 95) {
        return 63;
      } else {
        let message = Unicode.stringOutput();
        message = message.write("Invalid base-64 digit: ");
        message = Format.debugChar(message, c);
        throw new Error(message.bind());
      }
    }
    encodeDigit(b) {
      return this.alphabet.charCodeAt(b);
    }
    writeQuantum(output, c1, c2, c3, c4) {
      const x = this.decodeDigit(c1);
      const y = this.decodeDigit(c2);
      if (c3 !== 61) {
        const z = this.decodeDigit(c3);
        if (c4 !== 61) {
          const w = this.decodeDigit(c4);
          output = output.write(x << 2 | y >>> 4);
          output = output.write(y << 4 | z >>> 2);
          output = output.write(z << 6 | w);
        } else {
          output = output.write(x << 2 | y >>> 4);
          output = output.write(y << 4 | z >>> 2);
        }
      } else {
        if (c4 !== 61) {
          return Output.error(new Error("Improperly padded base-64"));
        }
        output = output.write(x << 2 | y >>> 4);
      }
      return output;
    }
    parser(output) {
      return new Base64Parser(this, output);
    }
    parse(input, output) {
      return Base64Parser.parse(input, this, output);
    }
    parseUint8Array(input) {
      return Base64Parser.parse(input, this, Binary.output());
    }
    uint8ArrayWriter(input) {
      if (input === void 0) {
        return new Base64Writer(this, void 0, null);
      } else {
        return new Base64Writer(this, input, input);
      }
    }
    writeUint8Array(output, input) {
      return Base64Writer.write(output, this, void 0, input);
    }
    static get standardPadded() {
      return new Base64Standard(true);
    }
    static get standardUnpadded() {
      return new Base64Standard(false);
    }
    static standard(padded = true) {
      if (padded) {
        return Base64.standardPadded;
      } else {
        return Base64.standardUnpadded;
      }
    }
    static get urlPadded() {
      return new Base64Url(true);
    }
    static get urlUnpadded() {
      return new Base64Url(false);
    }
    static url(padded = true) {
      if (padded) {
        return Base64.urlPadded;
      } else {
        return Base64.urlUnpadded;
      }
    }
  }
  __decorate([ Lazy ], Base64, "standardPadded", null);
  __decorate([ Lazy ], Base64, "standardUnpadded", null);
  __decorate([ Lazy ], Base64, "urlPadded", null);
  __decorate([ Lazy ], Base64, "urlUnpadded", null);
  class Base64Standard extends Base64 {
    constructor(padded) {
      super();
      Object.defineProperty(this, "padded", {
        value: padded,
        enumerable: true
      });
    }
    get alphabet() {
      return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    }
    isPadded() {
      return this.padded;
    }
    asPadded(padded) {
      if (padded === this.padded) {
        return this;
      } else {
        return Base64.standard(padded);
      }
    }
    isDigit(c) {
      return c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || c === 43 || c === 47;
    }
  }
  class Base64Url extends Base64 {
    constructor(padded) {
      super();
      Object.defineProperty(this, "padded", {
        value: padded,
        enumerable: true
      });
    }
    get alphabet() {
      return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
    }
    isPadded() {
      return this.padded;
    }
    asPadded(padded) {
      if (padded === this.padded) {
        return this;
      } else {
        return Base64.url(padded);
      }
    }
    isDigit(c) {
      return c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || c === 45 || c === 95;
    }
  }
  class Base64Parser extends Parser {
    constructor(base64, output, p = 0, q = 0, r = 0, step = 1) {
      super();
      this.base64 = base64;
      this.output = output;
      this.p = p;
      this.q = q;
      this.r = r;
      this.step = step;
    }
    feed(input) {
      return Base64Parser.parse(input, this.base64, this.output.clone(), this.p, this.q, this.r, this.step);
    }
    static parse(input, base64, output, p = 0, q = 0, r = 0, step = 1) {
      let c = 0;
      while (!input.isEmpty()) {
        if (step === 1) {
          if (input.isCont() && (c = input.head(), base64.isDigit(c))) {
            input = input.step();
            p = c;
            step = 2;
          } else if (!input.isEmpty()) {
            return Parser.done(output.bind());
          }
        }
        if (step === 2) {
          if (input.isCont() && (c = input.head(), base64.isDigit(c))) {
            input = input.step();
            q = c;
            step = 3;
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected("base64 digit", input));
          }
        }
        if (step === 3) {
          if (input.isCont() && (c = input.head(), base64.isDigit(c) || c === 61)) {
            input = input.step();
            r = c;
            if (c !== 61) {
              step = 4;
            } else {
              step = 5;
            }
          } else if (!input.isEmpty()) {
            if (!base64.isPadded()) {
              output = base64.writeQuantum(output, p, q, 61, 61);
              return Parser.done(output.bind());
            } else {
              return Parser.error(Diagnostic.unexpected(input));
            }
          }
        }
        if (step === 4) {
          if (input.isCont() && (c = input.head(), base64.isDigit(c) || c === 61)) {
            input = input.step();
            output = base64.writeQuantum(output, p, q, r, c);
            r = 0;
            q = 0;
            p = 0;
            if (c !== 61) {
              step = 1;
            } else {
              return Parser.done(output.bind());
            }
          } else if (!input.isEmpty()) {
            if (!base64.isPadded()) {
              output = base64.writeQuantum(output, p, q, r, 61);
              return Parser.done(output.bind());
            } else {
              return Parser.error(Diagnostic.unexpected(input));
            }
          }
        } else if (step === 5) {
          if (input.isCont() && (c = input.head(), c === 61)) {
            input = input.step();
            output = base64.writeQuantum(output, p, q, r, c);
            r = 0;
            q = 0;
            p = 0;
            return Parser.done(output.bind());
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected(61, input));
          }
        }
      }
      return new Base64Parser(base64, output, p, q, r, step);
    }
  }
  class Base64Writer extends Writer {
    constructor(base64, value, input, index = 0, step = 1) {
      super();
      this.base64 = base64;
      this.value = value;
      this.input = input;
      this.index = index;
      this.step = step;
    }
    feed(value) {
      if (value instanceof Uint8Array) {
        return new Base64Writer(this.base64, null, value);
      } else {
        throw new TypeError("" + value);
      }
    }
    pull(output) {
      if (this.input === null) {
        throw new WriterException;
      }
      return Base64Writer.write(output, this.base64, this.value, this.input, this.index, this.step);
    }
    static write(output, base64, value, input, index = 0, step = 1) {
      while (index + 2 < input.length && output.isCont()) {
        const x = input[index];
        const y = input[index + 1];
        const z = input[index + 2];
        if (step === 1 && output.isCont()) {
          output = output.write(base64.encodeDigit(x >>> 2));
          step = 2;
        }
        if (step === 2 && output.isCont()) {
          output = output.write(base64.encodeDigit((x << 4 | y >>> 4) & 63));
          step = 3;
        }
        if (step === 3 && output.isCont()) {
          output = output.write(base64.encodeDigit((y << 2 | z >>> 6) & 63));
          step = 4;
        }
        if (step === 4 && output.isCont()) {
          output = output.write(base64.encodeDigit(z & 63));
          index += 3;
          step = 1;
        }
      }
      if (index + 1 < input.length && output.isCont()) {
        const x = input[index];
        const y = input[index + 1];
        if (step === 1 && output.isCont()) {
          output = output.write(base64.encodeDigit(x >>> 2));
          step = 2;
        }
        if (step === 2 && output.isCont()) {
          output = output.write(base64.encodeDigit((x << 4 | y >>> 4) & 63));
          step = 3;
        }
        if (step === 3 && output.isCont()) {
          output = output.write(base64.encodeDigit(y << 2 & 63));
          step = 4;
        }
        if (step === 4) {
          if (!base64.isPadded()) {
            index += 2;
          } else if (output.isCont()) {
            output = output.write(61);
            index += 2;
          }
        }
      } else if (index < input.length && output.isCont()) {
        const x = input[index];
        if (step === 1 && output.isCont()) {
          output = output.write(base64.encodeDigit(x >>> 2));
          step = 2;
        }
        if (step === 2 && output.isCont()) {
          output = output.write(base64.encodeDigit(x << 4 & 63));
          step = 3;
        }
        if (step === 3) {
          if (!base64.isPadded()) {
            index += 1;
          } else if (output.isCont()) {
            output = output.write(61);
            step = 4;
          }
        }
        if (step === 4 && output.isCont()) {
          output = output.write(61);
          index += 1;
        }
      }
      if (index === input.length) {
        return Writer.done(value);
      } else if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new Base64Writer(base64, value, input, index, step);
    }
  }
  const Affinity = function() {
    const Affinity = {};
    Affinity.Transient = 0;
    Affinity.Inherited = 1;
    Affinity.Intrinsic = 2;
    Affinity.Extrinsic = 3;
    Affinity.Reflexive = 1 << 2;
    Affinity.Shift = 2;
    Affinity.Mask = (1 << Affinity.Shift) - 1;
    return Affinity;
  }();
  const FastenerContext = function() {
    const FastenerContext = {};
    FastenerContext.getLazyFastener = function(fastenerContext, fastenerName, fastenerBound) {
      let fastener = fastenerContext.getFastener(fastenerName);
      if (fastener === null) {
        const contextClass = fastenerContext.constructor;
        const fastenerClass = FastenerContext.getFastenerClass(contextClass, fastenerName, fastenerBound);
        if (fastenerClass !== null) {
          fastener = fastenerClass.create(fastenerContext);
          fastenerContext.setFastener(fastenerName, fastener);
        }
      } else if (fastenerBound !== void 0 && fastenerBound !== null && !(fastener instanceof fastenerBound)) {
        fastener = null;
      }
      return fastener;
    };
    FastenerContext.getFastenerClass = function(contextClass, fastenerName, fastenerBound) {
      do {
        if (Object.prototype.hasOwnProperty.call(contextClass, "fastenerClassMap")) {
          const fastenerClass = contextClass.fastenerClassMap[fastenerName];
          if (fastenerClass !== void 0 && (fastenerBound === void 0 || fastenerBound === null || fastenerClass.prototype instanceof fastenerBound)) {
            return fastenerClass;
          }
        }
        contextClass = Object.getPrototypeOf(contextClass);
      } while (contextClass !== null);
      return null;
    };
    FastenerContext.getSuperFastenerClass = function(contextClass, fastenerName, fastenerBound) {
      const superContextClass = Object.getPrototypeOf(contextClass);
      const fastenerClass = FastenerContext.getFastenerClass(superContextClass, fastenerName, fastenerBound);
      if (fastenerClass === null) {
        throw new Error("No " + fastenerName + " " + (fastenerBound !== void 0 && fastenerBound !== null ? fastenerBound.name : "fastener") + " class in " + superContextClass.constructor.name);
      }
      return fastenerClass;
    };
    FastenerContext.decorate = function(factory, descriptor, target, propertyKey) {
      const contextClass = target.constructor;
      const fastenerName = propertyKey.toString();
      const fastenerExtends = descriptor.extends;
      if (typeof fastenerExtends === "string") {
        Object.defineProperty(descriptor, "extends", {
          value: FastenerContext.getSuperFastenerClass(contextClass, fastenerExtends),
          writable: true,
          enumerable: true,
          configurable: true
        });
      } else if (fastenerExtends === true) {
        Object.defineProperty(descriptor, "extends", {
          value: FastenerContext.getSuperFastenerClass(contextClass, fastenerName),
          writable: true,
          enumerable: true,
          configurable: true
        });
      } else if (fastenerExtends === false) {
        Object.defineProperty(descriptor, "extends", {
          value: null,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
      const fastenerClass = factory.define(fastenerName, descriptor);
      fastenerClass.contextClass = contextClass;
      if (!Object.prototype.hasOwnProperty.call(contextClass, "fastenerClassMap")) {
        contextClass.fastenerClassMap = {};
      }
      contextClass.fastenerClassMap[fastenerName] = fastenerClass;
      if (!fastenerClass.prototype.lazy) {
        if (!Object.prototype.hasOwnProperty.call(contextClass, "fastenerClassInitMap")) {
          contextClass.fastenerClassInitMap = {};
        }
        contextClass.fastenerClassInitMap[fastenerName] = fastenerClass;
      }
      let staticName = fastenerClass.prototype.static;
      if (staticName !== false) {
        if (staticName === true) {
          staticName = fastenerName;
        }
        contextClass[staticName] = fastenerClass;
      }
      Object.defineProperty(target, propertyKey, {
        get: function() {
          let fastener = this.getFastener(fastenerName);
          if (fastener === null) {
            fastener = fastenerClass.create(this);
            this.setFastener(fastenerName, fastener);
          }
          return fastener;
        },
        configurable: true
      });
    };
    FastenerContext.decorator = function(factory, descriptor) {
      return FastenerContext.decorate.bind(FastenerContext, factory, descriptor);
    };
    FastenerContext.init = function(fastenerContext) {
      let contextClass = fastenerContext.constructor;
      do {
        if (Object.prototype.hasOwnProperty.call(contextClass, "fastenerClassInitMap")) {
          const fastenerClassInitMap = contextClass.fastenerClassInitMap;
          for (const fastenerName in fastenerClassInitMap) {
            const fastenerClass = fastenerClassInitMap[fastenerName];
            if (!fastenerContext.hasFastener(fastenerName)) {
              const fastener = fastenerClass.create(fastenerContext);
              fastenerContext.setFastener(fastenerName, fastener);
            }
          }
        }
        contextClass = Object.getPrototypeOf(contextClass);
      } while (contextClass !== null);
    };
    FastenerContext.has = function(object, key) {
      if (typeof object === "object" && object !== null || typeof object === "function") {
        return key in object;
      }
      return false;
    };
    FastenerContext.is = function(object) {
      if (typeof object === "object" && object !== null || typeof object === "function") {
        const fastenerContext = object;
        return "hasFastener" in fastenerContext;
      }
      return false;
    };
    return FastenerContext;
  }();
  const Fastener = function(_super) {
    const Fastener = function(descriptor) {
      return FastenerContext.decorator(Fastener, descriptor);
    };
    Fastener.prototype = Object.create(_super.prototype);
    Fastener.prototype.constructor = Fastener;
    Fastener.prototype.init = function() {};
    Object.defineProperty(Fastener.prototype, "fastenerType", {
      get: function() {
        return Fastener;
      },
      configurable: true
    });
    Object.defineProperty(Fastener.prototype, "name", {
      value: "",
      configurable: true
    });
    Fastener.prototype.setFlags = function(flags) {
      this.flags = flags;
    };
    Object.defineProperty(Fastener.prototype, "affinity", {
      get() {
        return this.flags & Affinity.Mask;
      },
      configurable: true
    });
    Fastener.prototype.hasAffinity = function(affinity) {
      return affinity >= (this.flags & Affinity.Mask);
    };
    Fastener.prototype.initAffinity = function(affinity) {
      this.flags = this.flags & ~Affinity.Mask | affinity & Affinity.Mask;
    };
    Fastener.prototype.minAffinity = function(newAffinity) {
      const oldAffinity = this.flags & Affinity.Mask;
      if (newAffinity === Affinity.Reflexive) {
        newAffinity = oldAffinity;
      } else if ((newAffinity & ~Affinity.Mask) !== 0) {
        throw new Error("invalid affinity: " + newAffinity);
      }
      if (newAffinity > oldAffinity) {
        this.willSetAffinity(newAffinity, oldAffinity);
        this.setFlags(this.flags & ~Affinity.Mask | newAffinity);
        this.onSetAffinity(newAffinity, oldAffinity);
        this.didSetAffinity(newAffinity, oldAffinity);
      }
      return newAffinity >= oldAffinity;
    };
    Fastener.prototype.setAffinity = function(newAffinity) {
      if ((newAffinity & ~Affinity.Mask) !== 0) {
        throw new Error("invalid affinity: " + newAffinity);
      }
      const oldAffinity = this.flags & Affinity.Mask;
      if (newAffinity !== oldAffinity) {
        this.willSetAffinity(newAffinity, oldAffinity);
        this.setFlags(this.flags & ~Affinity.Mask | newAffinity);
        this.onSetAffinity(newAffinity, oldAffinity);
        this.didSetAffinity(newAffinity, oldAffinity);
      }
    };
    Fastener.prototype.willSetAffinity = function(newAffinity, oldAffinity) {};
    Fastener.prototype.onSetAffinity = function(newAffinity, oldAffinity) {
      if (newAffinity > oldAffinity && (this.flags & Fastener.InheritedFlag) !== 0) {
        const superFastener = this.superFastener;
        if (superFastener !== null && Math.min(superFastener.flags & Affinity.Mask, Affinity.Intrinsic) < newAffinity) {
          this.setInherited(false, superFastener);
        }
      } else if (newAffinity < oldAffinity && (this.flags & Fastener.InheritsFlag) !== 0) {
        const superFastener = this.superFastener;
        if (superFastener !== null && Math.min(superFastener.flags & Affinity.Mask, Affinity.Intrinsic) >= newAffinity) {
          this.setInherited(true, superFastener);
        }
      }
    };
    Fastener.prototype.didSetAffinity = function(newAffinity, oldAffinity) {};
    Object.defineProperty(Fastener.prototype, "inherits", {
      get: function() {
        return (this.flags & Fastener.InheritsFlag) !== 0;
      },
      configurable: true
    });
    Fastener.prototype.initInherits = function(inherits) {
      let superName;
      if (typeof inherits === "string") {
        superName = inherits;
        inherits = true;
      }
      if (inherits) {
        if (superName !== void 0) {
          Object.defineProperty(this, "name", {
            value: superName,
            enumerable: true,
            configurable: true
          });
        }
        this.flags = this.flags | Fastener.InheritsFlag;
      } else {
        this.flags = this.flags & ~Fastener.InheritsFlag;
      }
    };
    Fastener.prototype.setInherits = function(inherits) {
      let superName;
      if (typeof inherits === "string") {
        if (inherits !== this.name) {
          superName = inherits;
        }
        inherits = true;
      }
      if (inherits !== ((this.flags & Fastener.InheritsFlag) !== 0) || superName !== void 0) {
        this.unbindSuperFastener();
        this.willSetInherits(inherits, superName);
        if (inherits) {
          if (superName !== void 0) {
            Object.defineProperty(this, "name", {
              value: superName,
              enumerable: true,
              configurable: true
            });
          }
          this.setFlags(this.flags | Fastener.InheritsFlag);
        } else {
          this.setFlags(this.flags & ~Fastener.InheritsFlag);
        }
        this.onSetInherits(inherits, superName);
        this.didSetInherits(inherits, superName);
        this.bindSuperFastener();
      }
    };
    Fastener.prototype.willSetInherits = function(inherits, superName) {};
    Fastener.prototype.onSetInherits = function(inherits, superName) {};
    Fastener.prototype.didSetInherits = function(inherits, superName) {};
    Object.defineProperty(Fastener.prototype, "inherited", {
      get: function() {
        return (this.flags & Fastener.InheritedFlag) !== 0;
      },
      configurable: true
    });
    Fastener.prototype.setInherited = function(inherited, superFastener) {
      if (inherited && (this.flags & Fastener.InheritedFlag) === 0) {
        this.willInherit(superFastener);
        this.setFlags(this.flags | Fastener.InheritedFlag);
        this.onInherit(superFastener);
        this.didInherit(superFastener);
      } else if (!inherited && (this.flags & Fastener.InheritedFlag) !== 0) {
        this.willUninherit(superFastener);
        this.setFlags(this.flags & ~Fastener.InheritedFlag);
        this.onUninherit(superFastener);
        this.didUninherit(superFastener);
      }
    };
    Fastener.prototype.willInherit = function(superFastener) {};
    Fastener.prototype.onInherit = function(superFastener) {};
    Fastener.prototype.didInherit = function(superFastener) {};
    Fastener.prototype.willUninherit = function(superFastener) {};
    Fastener.prototype.onUninherit = function(superFastener) {};
    Fastener.prototype.didUninherit = function(superFastener) {};
    Object.defineProperty(Fastener.prototype, "superName", {
      get: function() {
        return (this.flags & Fastener.InheritsFlag) !== 0 ? this.name : void 0;
      },
      configurable: true
    });
    Object.defineProperty(Fastener.prototype, "superFastener", {
      get: function() {
        return this.getSuperFastener();
      },
      configurable: true
    });
    Fastener.prototype.getSuperFastener = function() {
      const superName = this.superName;
      if (superName !== void 0) {
        const fastenerContext = this.owner;
        if (FastenerContext.is(fastenerContext)) {
          const superFastener = fastenerContext.getSuperFastener(superName, this.fastenerType);
          if (superFastener !== null) {
            return superFastener;
          }
        }
      }
      return null;
    };
    Fastener.prototype.bindSuperFastener = function() {
      const superName = this.superName;
      if (superName !== void 0) {
        const fastenerContext = this.owner;
        if (FastenerContext.is(fastenerContext)) {
          const superFastener = fastenerContext.getSuperFastener(superName, this.fastenerType);
          if (superFastener !== null) {
            this.willBindSuperFastener(superFastener);
            superFastener.attachSubFastener(this);
            this.onBindSuperFastener(superFastener);
            this.didBindSuperFastener(superFastener);
          }
        }
      }
    };
    Fastener.prototype.willBindSuperFastener = function(superFastener) {};
    Fastener.prototype.onBindSuperFastener = function(superFastener) {
      if ((superFastener.flags & Affinity.Mask) >= (this.flags & Affinity.Mask)) {
        this.setInherited(true, superFastener);
      }
    };
    Fastener.prototype.didBindSuperFastener = function(superFastener) {};
    Fastener.prototype.unbindSuperFastener = function() {
      const superFastener = this.superFastener;
      if (superFastener !== null) {
        this.willUnbindSuperFastener(superFastener);
        superFastener.detachSubFastener(this);
        this.onUnbindSuperFastener(superFastener);
        this.didUnbindSuperFastener(superFastener);
      }
    };
    Fastener.prototype.willUnbindSuperFastener = function(superFastener) {};
    Fastener.prototype.onUnbindSuperFastener = function(superFastener) {
      this.setInherited(false, superFastener);
    };
    Fastener.prototype.didUnbindSuperFastener = function(superFastener) {};
    Fastener.prototype.attachSubFastener = function(subFastener) {};
    Fastener.prototype.detachSubFastener = function(subFastener) {};
    Object.defineProperty(Fastener.prototype, "coherent", {
      get: function() {
        return (this.flags & Fastener.DecoherentFlag) === 0;
      },
      configurable: true
    });
    Fastener.prototype.setCoherent = function(coherent) {
      if (coherent) {
        this.setFlags(this.flags & ~Fastener.DecoherentFlag);
      } else {
        this.setFlags(this.flags | Fastener.DecoherentFlag);
      }
    };
    Fastener.prototype.decohere = function() {
      const fastenerContext = this.owner;
      if (FastenerContext.has(fastenerContext, "decohereFastener")) {
        fastenerContext.decohereFastener(this);
      }
    };
    Fastener.prototype.recohere = function(t) {};
    Object.defineProperty(Fastener.prototype, "mounted", {
      get: function() {
        return (this.flags & Fastener.MountedFlag) !== 0;
      },
      configurable: true
    });
    Fastener.prototype.mount = function() {
      if ((this.flags & Fastener.MountedFlag) === 0) {
        this.willMount();
        this.setFlags(this.flags | Fastener.MountedFlag);
        this.onMount();
        this.didMount();
      }
    };
    Fastener.prototype.willMount = function() {};
    Fastener.prototype.onMount = function() {
      this.bindSuperFastener();
    };
    Fastener.prototype.didMount = function() {};
    Fastener.prototype.unmount = function() {
      if ((this.flags & Fastener.MountedFlag) !== 0) {
        this.willUnmount();
        this.setFlags(this.flags & ~Fastener.MountedFlag);
        this.onUnmount();
        this.didUnmount();
      }
    };
    Fastener.prototype.willUnmount = function() {};
    Fastener.prototype.onUnmount = function() {
      this.unbindSuperFastener();
    };
    Fastener.prototype.didUnmount = function() {};
    Fastener.prototype.toString = function() {
      return this.name;
    };
    Object.defineProperty(Fastener.prototype, "lazy", {
      get: function() {
        return true;
      },
      configurable: true
    });
    Object.defineProperty(Fastener.prototype, "static", {
      get: function() {
        return false;
      },
      configurable: true
    });
    Fastener.create = function(owner) {
      const fastener = this.construct(this, null, owner);
      fastener.init();
      return fastener;
    };
    Fastener.construct = function(fastenerClass, fastener, owner) {
      if (fastener === null) {
        fastener = Object.create(fastenerClass.prototype);
      }
      fastener.owner = owner;
      fastener.flags = 0;
      return fastener;
    };
    Fastener.extend = function(className, classMembers) {
      let classIdentifier;
      if (classMembers !== void 0 && classMembers !== null && typeof classMembers.name === "string" && Identifiers.isValid(classMembers.name)) {
        classIdentifier = classMembers.name;
        className = classIdentifier;
      } else if (Identifiers.isValid(className)) {
        classIdentifier = className;
      }
      let fastenerClass;
      if (classIdentifier !== void 0) {
        fastenerClass = new Function("FastenerContext", "return function " + className + "(descriptor) { return FastenerContext.decorator(" + className + ", descriptor); }")(FastenerContext);
      } else {
        fastenerClass = function(descriptor) {
          return FastenerContext.decorator(fastenerClass, descriptor);
        };
        Object.defineProperty(fastenerClass, "name", {
          value: className,
          configurable: true
        });
      }
      const classProperties = {};
      if (classMembers !== void 0 && classMembers !== null) {
        classProperties.name = {
          value: className,
          configurable: true
        };
        const classMemberNames = Object.getOwnPropertyNames(classMembers);
        for (let i = 0; i < classMemberNames.length; i += 1) {
          const classMemberName = classMemberNames[i];
          classProperties[classMemberName] = Object.getOwnPropertyDescriptor(classMembers, classMemberName);
        }
      } else {
        classProperties.name = {
          value: "",
          configurable: true
        };
      }
      Object.setPrototypeOf(fastenerClass, this);
      fastenerClass.prototype = Object.create(this.prototype, classProperties);
      fastenerClass.prototype.constructor = fastenerClass;
      return fastenerClass;
    };
    Fastener.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        return fastener;
      };
      return fastenerClass;
    };
    Fastener.MountedFlag = 1 << Affinity.Shift + 0;
    Fastener.InheritsFlag = 1 << Affinity.Shift + 1;
    Fastener.InheritedFlag = 1 << Affinity.Shift + 2;
    Fastener.DecoherentFlag = 1 << Affinity.Shift + 3;
    Fastener.FlagShift = Affinity.Shift + 4;
    Fastener.FlagMask = (1 << Fastener.FlagShift) - 1;
    return Fastener;
  }(Object);
  const Property = function(_super) {
    const Property = _super.extend("Property");
    Object.defineProperty(Property.prototype, "fastenerType", {
      get: function() {
        return Property;
      },
      configurable: true
    });
    Property.prototype.onInherit = function(superFastener) {
      const superValue = this.transformSuperValue(superFastener.value);
      this.setValue(superValue, Affinity.Reflexive);
    };
    Property.prototype.onBindSuperFastener = function(superFastener) {
      this.superFastener = superFastener;
      _super.prototype.onBindSuperFastener.call(this, superFastener);
    };
    Property.prototype.onUnbindSuperFastener = function(superFastener) {
      _super.prototype.onUnbindSuperFastener.call(this, superFastener);
      this.superFastener = null;
    };
    Property.prototype.attachSubFastener = function(subFastener) {
      let subFasteners = this.subFasteners;
      if (subFasteners === null) {
        subFasteners = [];
        this.subFasteners = subFasteners;
      }
      subFasteners.push(subFastener);
    };
    Property.prototype.detachSubFastener = function(subFastener) {
      const subFasteners = this.subFasteners;
      if (subFasteners !== null) {
        const index = subFasteners.indexOf(subFastener);
        if (index >= 0) {
          subFasteners.splice(index, 1);
        }
      }
    };
    Object.defineProperty(Property.prototype, "superValue", {
      get: function() {
        const superFastener = this.superFastener;
        return superFastener !== null ? superFastener.value : void 0;
      },
      configurable: true
    });
    Property.prototype.getSuperValue = function() {
      const superValue = this.superValue;
      if (superValue === void 0 || superValue === null) {
        let message = superValue + " ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "super value";
        throw new TypeError(message);
      }
      return superValue;
    };
    Property.prototype.getSuperValueOr = function(elseValue) {
      let superValue = this.superValue;
      if (superValue === void 0 || superValue === null) {
        superValue = elseValue;
      }
      return superValue;
    };
    Property.prototype.transformSuperValue = function(superValue) {
      return superValue;
    };
    Property.prototype.getValue = function() {
      const value = this.value;
      if (value === void 0 || value === null) {
        let message = value + " ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "value";
        throw new TypeError(message);
      }
      return value;
    };
    Property.prototype.getValueOr = function(elseValue) {
      let value = this.value;
      if (value === void 0 || value === null) {
        value = elseValue;
      }
      return value;
    };
    Property.prototype.transformValue = function(value) {
      return value;
    };
    Property.prototype.setValue = function(newValue, affinity) {
      if (affinity === void 0) {
        affinity = Affinity.Extrinsic;
      }
      if (this.minAffinity(affinity)) {
        newValue = this.fromAny(newValue);
        newValue = this.transformValue(newValue);
        const oldValue = this.value;
        if (!this.equalValues(newValue, oldValue)) {
          this.willSetValue(newValue, oldValue);
          this.value = newValue;
          this.onSetValue(newValue, oldValue);
          this.didSetValue(newValue, oldValue);
          this.setCoherent(true);
          this.decohereSubFasteners();
        }
      }
    };
    Property.prototype.willSetValue = function(newValue, oldValue) {};
    Property.prototype.onSetValue = function(newValue, oldValue) {
      const updateFlags = this.updateFlags;
      const fastenerContext = this.owner;
      if (updateFlags !== void 0 && FastenerContext.has(fastenerContext, "requireUpdate")) {
        fastenerContext.requireUpdate(updateFlags);
      }
    };
    Property.prototype.didSetValue = function(newValue, oldValue) {};
    Property.prototype.decohereSubFasteners = function() {
      const subFasteners = this.subFasteners;
      for (let i = 0, n = subFasteners !== null ? subFasteners.length : 0; i < n; i += 1) {
        this.decohereSubFastener(subFasteners[i]);
      }
    };
    Property.prototype.decohereSubFastener = function(subFastener) {
      if ((subFastener.flags & Fastener.InheritedFlag) === 0 && Math.min(this.flags & Affinity.Mask, Affinity.Intrinsic) >= (subFastener.flags & Affinity.Mask)) {
        subFastener.setInherited(true, this);
      } else if ((subFastener.flags & Fastener.InheritedFlag) !== 0 && (subFastener.flags & Fastener.DecoherentFlag) === 0) {
        subFastener.setCoherent(false);
        subFastener.decohere();
      }
    };
    Property.prototype.recohere = function(t) {
      if ((this.flags & Fastener.InheritedFlag) !== 0) {
        const superFastener = this.superFastener;
        if (superFastener !== null) {
          const superValue = this.transformSuperValue(superFastener.value);
          this.setValue(superValue, Affinity.Reflexive);
        }
      }
    };
    Property.prototype.definedValue = function(value) {
      return value !== void 0 && value !== null;
    };
    Property.prototype.equalValues = function(newValue, oldValue) {
      return Equals(newValue, oldValue);
    };
    Property.prototype.fromAny = function(value) {
      return value;
    };
    Property.construct = function(propertyClass, property, owner) {
      if (property === null) {
        property = function(value, affinity) {
          if (arguments.length === 0) {
            return property.value;
          } else {
            property.setValue(value, affinity);
            return property.owner;
          }
        };
        delete property.name;
        Object.setPrototypeOf(property, propertyClass.prototype);
      }
      property = _super.construct(propertyClass, property, owner);
      Object.defineProperty(property, "superFastener", {
        value: null,
        writable: true,
        enumerable: true,
        configurable: true
      });
      property.subFasteners = null;
      property.value = void 0;
      return property;
    };
    Property.specialize = function(type) {
      if (type === String) {
        return StringProperty;
      } else if (type === Number) {
        return NumberProperty;
      } else if (type === Boolean) {
        return BooleanProperty;
      }
      return null;
    };
    Property.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const value = descriptor.value;
      const initValue = descriptor.initValue;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.value;
      delete descriptor.initValue;
      if (superClass === void 0 || superClass === null) {
        superClass = this.specialize(descriptor.type);
      }
      if (superClass === null) {
        superClass = this;
        if (descriptor.fromAny === void 0 && FromAny.is(descriptor.type)) {
          descriptor.fromAny = descriptor.type.fromAny;
        }
      }
      const propertyClass = superClass.extend(className, descriptor);
      propertyClass.construct = function(propertyClass, property, owner) {
        property = superClass.construct(propertyClass, property, owner);
        if (affinity !== void 0) {
          property.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          property.initInherits(inherits);
        }
        if (initValue !== void 0) {
          property.value = property.fromAny(initValue());
        } else if (value !== void 0) {
          property.value = property.fromAny(value);
        }
        return property;
      };
      return propertyClass;
    };
    return Property;
  }(Fastener);
  const StringProperty = function(_super) {
    const StringProperty = _super.extend("StringProperty");
    StringProperty.prototype.fromAny = function(value) {
      return value;
    };
    StringProperty.prototype.equalValues = function(newValue, oldValue) {
      return newValue === oldValue;
    };
    return StringProperty;
  }(Property);
  const NumberProperty = function(_super) {
    const NumberProperty = _super.extend("NumberProperty");
    NumberProperty.prototype.fromAny = function(value) {
      if (typeof value === "string") {
        const number = +value;
        if (isFinite(number)) {
          return number;
        } else {
          throw new Error(value);
        }
      } else {
        return value;
      }
    };
    NumberProperty.prototype.equalValues = function(newValue, oldValue) {
      return newValue === oldValue;
    };
    return NumberProperty;
  }(Property);
  const BooleanProperty = function(_super) {
    const BooleanProperty = _super.extend("BooleanProperty");
    BooleanProperty.prototype.fromAny = function(value) {
      return !!value;
    };
    BooleanProperty.prototype.equalValues = function(newValue, oldValue) {
      return newValue === oldValue;
    };
    return BooleanProperty;
  }(Property);
  const Animator = function(_super) {
    const Animator = _super.extend("Animator");
    Animator.prototype.onInherit = function(superFastener) {
      let newValue;
      let newState;
      if (superFastener instanceof Animator) {
        newValue = this.transformSuperValue(superFastener.value);
        newState = this.transformSuperValue(superFastener.state);
      } else {
        newValue = this.transformSuperValue(superFastener.value);
        newState = newValue;
      }
      const oldState = this.state;
      const stateChanged = !this.equalValues(newState, oldState);
      if (stateChanged) {
        this.willSetState(newState, oldState);
        this.state = newState;
        this.timing = null;
        this.interpolator = null;
        this.onSetState(newState, oldState);
      }
      this.setValue(newValue, Affinity.Reflexive);
      if (stateChanged) {
        this.didSetState(newState, oldState);
        if ((this.flags & Animator.TweeningFlag) !== 0) {
          this.didInterrupt(this.value);
        }
      }
      if (superFastener instanceof Animator && (superFastener.flags & Animator.TweeningFlag) !== 0) {
        this.startTweening();
      } else {
        this.stopTweening();
      }
    };
    Animator.prototype.setValue = function(newValue, affinity) {
      if (affinity === void 0) {
        affinity = Affinity.Extrinsic;
      }
      if (this.minAffinity(affinity)) {
        newValue = this.fromAny(newValue);
        newValue = this.transformValue(newValue);
        const oldValue = this.value;
        if (!this.equalValues(newValue, oldValue)) {
          this.willSetValue(newValue, oldValue);
          this.value = newValue;
          this.onSetValue(newValue, oldValue);
          this.didSetValue(newValue, oldValue);
          this.decohereSubFasteners();
        }
      }
    };
    Object.defineProperty(Animator.prototype, "superState", {
      get: function() {
        const superFastener = this.superFastener;
        return superFastener instanceof Animator ? superFastener.state : void 0;
      },
      configurable: true
    });
    Animator.prototype.getSuperState = function() {
      const superState = this.superState;
      if (superState === void 0 || superState === null) {
        let message = superState + " ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "super state";
        throw new TypeError(message);
      }
      return superState;
    };
    Animator.prototype.getSuperStateOr = function(elseState) {
      let superState = this.superState;
      if (superState === void 0 || superState === null) {
        superState = elseState;
      }
      return superState;
    };
    Animator.prototype.getState = function() {
      const state = this.state;
      if (state === void 0 || state === null) {
        let message = state + " ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "state";
        throw new TypeError(message);
      }
      return state;
    };
    Animator.prototype.getStateOr = function(elseState) {
      let state = this.state;
      if (state === void 0 || state === null) {
        state = elseState;
      }
      return state;
    };
    Animator.prototype.transformState = function(state) {
      return state;
    };
    Animator.prototype.setState = function(newState, timing, affinity) {
      if (typeof timing === "number") {
        affinity = timing;
        timing = void 0;
      }
      if (affinity === void 0) {
        affinity = Affinity.Extrinsic;
      }
      if (this.minAffinity(affinity)) {
        newState = this.fromAny(newState);
        newState = this.transformState(newState);
        const oldState = this.state;
        if (!this.equalValues(newState, oldState)) {
          if (timing === void 0 || timing === null || timing === false) {
            timing = false;
          } else if (timing === true) {
            timing = this.timing !== null ? this.timing : false;
          } else {
            timing = Timing.fromAny(timing);
          }
          const animated = timing !== false && this.definedValue(oldState);
          this.willSetState(newState, oldState);
          this.state = newState;
          if (animated) {
            this.timing = timing;
            this.interpolator = Interpolator(this.value, newState);
            if ((this.flags & Animator.TweeningFlag) !== 0) {
              this.setFlags(this.flags | (Animator.DivergedFlag | Animator.InterruptFlag));
            } else {
              this.setFlags(this.flags | Animator.DivergedFlag);
            }
          } else {
            this.timing = null;
            this.interpolator = null;
          }
          this.onSetState(newState, oldState);
          if (!animated) {
            this.setValue(newState, Affinity.Reflexive);
          }
          this.didSetState(newState, oldState);
          if (animated) {
            this.startTweening();
          } else if ((this.flags & Animator.TweeningFlag) !== 0) {
            this.didInterrupt(this.value);
            this.stopTweening();
          }
        }
      }
    };
    Animator.prototype.willSetState = function(newState, oldState) {};
    Animator.prototype.onSetState = function(newState, oldState) {};
    Animator.prototype.didSetState = function(newState, oldState) {};
    Animator.prototype.setInterpolatedValue = function(newValue, newState) {
      const oldState = arguments.length > 1 ? this.state : void 0;
      const stateChanged = arguments.length > 1 && !this.equalValues(newState, oldState);
      if (stateChanged) {
        this.willSetState(newState, oldState);
        this.state = newState;
        this.timing = null;
        this.interpolator = null;
        this.onSetState(newState, oldState);
      }
      this.setValue(newValue, Affinity.Reflexive);
      if (stateChanged) {
        this.didSetState(newState, oldState);
        if ((this.flags & Animator.TweeningFlag) !== 0) {
          this.didInterrupt(this.value);
          this.stopTweening();
        }
      }
    };
    Animator.prototype.decohereSubFastener = function(subFastener) {
      if ((subFastener.flags & Animator.InheritedFlag) === 0 && Math.min(this.flags & Affinity.Mask, Affinity.Intrinsic) >= (subFastener.flags & Affinity.Mask)) {
        subFastener.setInherited(true, this);
      } else if ((subFastener.flags & Animator.InheritedFlag) !== 0) {
        if ((this.flags & Animator.TweeningFlag) !== 0 && subFastener instanceof Animator) {
          subFastener.startTweening();
        }
        if ((subFastener.flags & Animator.DecoherentFlag) === 0) {
          subFastener.setCoherent(false);
          subFastener.decohere();
        }
      }
    };
    Animator.prototype.recohere = function(t) {
      const flags = this.flags;
      if ((flags & Animator.InheritedFlag) !== 0) {
        this.tweenInherited(t);
      } else if ((flags & Animator.TweeningFlag) !== 0) {
        this.tween(t);
      }
    };
    Animator.prototype.tween = function(t) {
      const oldValue = this.value;
      let timing = this.timing;
      if (timing === null) {
        timing = Easing.linear.withDomain(t, t);
        this.timing = timing;
      }
      let interpolator = this.interpolator;
      if (interpolator === null) {
        interpolator = Interpolator(oldValue, this.state);
        this.interpolator = interpolator;
      }
      if ((this.flags & Animator.InterruptFlag) !== 0) {
        this.setFlags(this.flags & ~Animator.InterruptFlag);
        this.didInterrupt(oldValue);
      }
      if ((this.flags & Animator.DivergedFlag) !== 0) {
        this.setFlags(this.flags & ~Animator.DivergedFlag);
        if (!this.equalValues(this.state, oldValue)) {
          timing = timing.withDomain(t, t + timing.duration);
        } else {
          timing = timing.withDomain(t - timing.duration, t);
        }
        this.timing = timing;
        this.willTransition(oldValue);
      }
      const u = timing(t);
      const newValue = interpolator(u);
      this.setValue(newValue, Affinity.Reflexive);
      if (u < 1) {
        this.decohere();
      } else if ((this.flags & Animator.TweeningFlag) !== 0) {
        this.stopTweening();
        this.interpolator = null;
        this.didTransition(this.value);
      } else {
        this.setCoherent(true);
      }
    };
    Animator.prototype.tweenInherited = function(t) {
      const superFastener = this.superFastener;
      if (superFastener !== null) {
        let newValue;
        let newState;
        if (superFastener instanceof Animator) {
          newValue = this.transformSuperValue(superFastener.value);
          newState = this.transformSuperValue(superFastener.state);
        } else {
          newValue = this.transformSuperValue(superFastener.value);
          newState = newValue;
        }
        const oldState = this.state;
        const stateChanged = !this.equalValues(newState, oldState);
        if (stateChanged) {
          this.willSetState(newState, oldState);
          this.state = newState;
          this.timing = null;
          this.interpolator = null;
          this.onSetState(newState, oldState);
        }
        this.setValue(newValue, Affinity.Reflexive);
        if (stateChanged) {
          this.didSetState(newState, oldState);
          if ((this.flags & Animator.TweeningFlag) !== 0) {
            this.didInterrupt(this.value);
          }
        }
        if (superFastener instanceof Animator && (superFastener.flags & Animator.TweeningFlag) !== 0) {
          this.decohere();
        } else if ((this.flags & Animator.TweeningFlag) !== 0) {
          this.stopTweening();
        } else {
          this.setCoherent(true);
        }
      } else {
        this.stopTweening();
      }
    };
    Object.defineProperty(Animator.prototype, "tweening", {
      get: function() {
        return (this.flags & Animator.TweeningFlag) !== 0;
      },
      configurable: true
    });
    Animator.prototype.startTweening = function() {
      if ((this.flags & Animator.TweeningFlag) === 0) {
        this.willStartTweening();
        this.setFlags(this.flags | Animator.TweeningFlag);
        this.onStartTweening();
        this.didStartTweening();
      }
    };
    Animator.prototype.willStartTweening = function() {};
    Animator.prototype.onStartTweening = function() {
      if ((this.flags & Animator.DecoherentFlag) === 0) {
        this.setCoherent(false);
        this.decohere();
      }
      this.decohereSubFasteners();
    };
    Animator.prototype.didStartTweening = function() {};
    Animator.prototype.stopTweening = function() {
      if ((this.flags & Animator.TweeningFlag) !== 0) {
        this.willStopTweening();
        this.setFlags(this.flags & ~Animator.TweeningFlag);
        this.onStopTweening();
        this.didStopTweening();
      }
    };
    Animator.prototype.willStopTweening = function() {};
    Animator.prototype.onStopTweening = function() {
      this.setCoherent(true);
    };
    Animator.prototype.didStopTweening = function() {};
    Animator.prototype.willTransition = function(oldValue) {};
    Animator.prototype.didTransition = function(newValue) {};
    Animator.prototype.didInterrupt = function(value) {};
    Animator.prototype.onUnmount = function() {
      this.stopTweening();
      _super.prototype.onUnmount.call(this);
    };
    Animator.construct = function(animatorClass, animator, owner) {
      if (animator === null) {
        animator = function(state, timing, affinity) {
          if (arguments.length === 0) {
            return animator.value;
          } else {
            if (arguments.length === 2) {
              animator.setState(state, timing);
            } else {
              animator.setState(state, timing, affinity);
            }
            return animator.owner;
          }
        };
        delete animator.name;
        Object.setPrototypeOf(animator, animatorClass.prototype);
      }
      animator = _super.construct(animatorClass, animator, owner);
      animator.state = animator.value;
      animator.timing = null;
      animator.interpolator = null;
      return animator;
    };
    Animator.specialize = function(type) {
      if (type === String) {
        return StringAnimator;
      } else if (type === Number) {
        return NumberAnimator;
      } else if (type === Boolean) {
        return BooleanAnimator;
      }
      return null;
    };
    Animator.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const value = descriptor.value;
      const initValue = descriptor.initValue;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.value;
      delete descriptor.initValue;
      if (superClass === void 0 || superClass === null) {
        superClass = this.specialize(descriptor.type);
      }
      if (superClass === null) {
        superClass = this;
        if (descriptor.fromAny === void 0 && FromAny.is(descriptor.type)) {
          descriptor.fromAny = descriptor.type.fromAny;
        }
      }
      const animatorClass = superClass.extend(className, descriptor);
      animatorClass.construct = function(animatorClass, animator, owner) {
        animator = superClass.construct(animatorClass, animator, owner);
        if (affinity !== void 0) {
          animator.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          animator.initInherits(inherits);
        }
        if (initValue !== void 0) {
          animator.value = animator.fromAny(initValue());
          animator.state = animator.value;
        } else if (value !== void 0) {
          animator.value = animator.fromAny(value);
          animator.state = animator.value;
        }
        return animator;
      };
      return animatorClass;
    };
    Animator.TweeningFlag = 1 << _super.FlagShift + 0;
    Animator.DivergedFlag = 1 << _super.FlagShift + 1;
    Animator.InterruptFlag = 1 << _super.FlagShift + 2;
    Animator.FlagShift = _super.FlagShift + 3;
    Animator.FlagMask = (1 << Animator.FlagShift) - 1;
    return Animator;
  }(Property);
  const StringAnimator = function(_super) {
    const StringAnimator = _super.extend("StringAnimator");
    StringAnimator.prototype.fromAny = function(value) {
      return value;
    };
    StringAnimator.prototype.equalValues = function(newValue, oldValue) {
      return newValue === oldValue;
    };
    return StringAnimator;
  }(Animator);
  const NumberAnimator = function(_super) {
    const NumberAnimator = _super.extend("NumberAnimator");
    NumberAnimator.prototype.fromAny = function(value) {
      if (typeof value === "string") {
        const number = +value;
        if (isFinite(number)) {
          return number;
        } else {
          throw new Error(value);
        }
      } else {
        return value;
      }
    };
    NumberAnimator.prototype.equalValues = function(newValue, oldValue) {
      return newValue === oldValue;
    };
    return NumberAnimator;
  }(Animator);
  const BooleanAnimator = function(_super) {
    const BooleanAnimator = _super.extend("BooleanAnimator");
    BooleanAnimator.prototype.fromAny = function(value) {
      return !!value;
    };
    BooleanAnimator.prototype.equalValues = function(newValue, oldValue) {
      return newValue === oldValue;
    };
    return BooleanAnimator;
  }(Animator);
  class Service {
    constructor() {
      this.roots = Arrays.empty;
      this.fasteners = null;
      this.decoherent = null;
      this.observers = Arrays.empty;
    }
    attachRoot(root) {
      const oldRoots = this.roots;
      const newRoots = Arrays.inserted(root, oldRoots);
      if (oldRoots !== newRoots) {
        const needsAttach = oldRoots.length === 0;
        if (needsAttach) {
          this.willAttach();
        }
        this.willAttachRoot(root);
        this.roots = newRoots;
        if (needsAttach) {
          this.onAttach();
        }
        this.onAttachRoot(root);
        this.didAttachRoot(root);
        if (needsAttach) {
          this.didAttach();
        }
      }
    }
    willAttachRoot(root) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceWillAttachRoot !== void 0) {
          observer.serviceWillAttachRoot(root, this);
        }
      }
    }
    onAttachRoot(root) {}
    didAttachRoot(root) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceDidAttachRoot !== void 0) {
          observer.serviceDidAttachRoot(root, this);
        }
      }
    }
    detachRoot(root) {
      const oldRoots = this.roots;
      const newRoots = Arrays.removed(root, oldRoots);
      if (oldRoots !== newRoots) {
        const needsDetach = oldRoots.length === 1;
        if (needsDetach) {
          this.willDetach();
        }
        this.willDetachRoot(root);
        this.roots = newRoots;
        if (needsDetach) {
          this.onDetach();
        }
        this.onDetachRoot(root);
        this.didDetachRoot(root);
        if (needsDetach) {
          this.didDetach();
        }
      }
    }
    willDetachRoot(root) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceWillDetachRoot !== void 0) {
          observer.serviceWillDetachRoot(root, this);
        }
      }
    }
    onDetachRoot(root) {}
    didDetachRoot(root) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceDidDetachRoot !== void 0) {
          observer.serviceDidDetachRoot(root, this);
        }
      }
    }
    get attached() {
      return this.roots.length !== 0;
    }
    willAttach() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceWillAttach !== void 0) {
          observer.serviceWillAttach(this);
        }
      }
    }
    onAttach() {
      this.mountFasteners();
    }
    didAttach() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceDidAttach !== void 0) {
          observer.serviceDidAttach(this);
        }
      }
    }
    willDetach() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceWillDetach !== void 0) {
          observer.serviceWillDetach(this);
        }
      }
    }
    onDetach() {
      this.unmountFasteners();
    }
    didDetach() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.serviceDidDetach !== void 0) {
          observer.serviceDidDetach(this);
        }
      }
    }
    hasFastener(fastenerName, fastenerBound) {
      const fasteners = this.fasteners;
      if (fasteners !== null) {
        const fastener = fasteners[fastenerName];
        if (fastener !== void 0 && (fastenerBound === void 0 || fastenerBound === null || fastener instanceof fastenerBound)) {
          return true;
        }
      }
      return false;
    }
    getFastener(fastenerName, fastenerBound) {
      const fasteners = this.fasteners;
      if (fasteners !== null) {
        const fastener = fasteners[fastenerName];
        if (fastener !== void 0 && (fastenerBound === void 0 || fastenerBound === null || fastener instanceof fastenerBound)) {
          return fastener;
        }
      }
      return null;
    }
    setFastener(fastenerName, newFastener) {
      var _a;
      const fasteners = this.fasteners;
      const oldFastener = fasteners !== null ? (_a = fasteners[fastenerName]) !== null && _a !== void 0 ? _a : null : null;
      if (oldFastener !== newFastener) {
        if (oldFastener !== null) {
          this.detachFastener(fastenerName, oldFastener);
        }
        if (newFastener !== null) {
          this.attachFastener(fastenerName, newFastener);
        }
      }
    }
    attachFastener(fastenerName, fastener) {
      let fasteners = this.fasteners;
      if (fasteners === null) {
        fasteners = {};
        this.fasteners = fasteners;
      }
      this.willAttachFastener(fastenerName, fastener);
      fasteners[fastenerName] = fastener;
      if (this.attached) {
        fastener.mount();
      }
      this.onAttachFastener(fastenerName, fastener);
      this.didAttachFastener(fastenerName, fastener);
    }
    willAttachFastener(fastenerName, fastener) {}
    onAttachFastener(fastenerName, fastener) {}
    didAttachFastener(fastenerName, fastener) {}
    detachFastener(fastenerName, fastener) {
      const fasteners = this.fasteners;
      this.willDetachFastener(fastenerName, fastener);
      this.onDetachFastener(fastenerName, fastener);
      if (this.attached) {
        fastener.unmount();
      }
      delete fasteners[fastenerName];
      this.didDetachFastener(fastenerName, fastener);
    }
    willDetachFastener(fastenerName, fastener) {}
    onDetachFastener(fastenerName, fastener) {}
    didDetachFastener(fastenerName, fastener) {}
    getLazyFastener(fastenerName, fastenerBound) {
      return FastenerContext.getLazyFastener(this, fastenerName, fastenerBound);
    }
    getSuperFastener(fastenerName, fastenerBound) {
      return null;
    }
    mountFasteners() {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        fastener.mount();
      }
    }
    unmountFasteners() {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        fastener.unmount();
      }
    }
    decohereFastener(fastener) {
      let decoherent = this.decoherent;
      if (decoherent === null) {
        decoherent = [];
        this.decoherent = decoherent;
      }
      decoherent.push(fastener);
    }
    recohereFasteners(t) {
      const decoherent = this.decoherent;
      if (decoherent !== null) {
        const decoherentCount = decoherent.length;
        if (decoherentCount !== 0) {
          if (t === void 0) {
            t = performance.now();
          }
          this.decoherent = null;
          for (let i = 0; i < decoherentCount; i += 1) {
            const fastener = decoherent[i];
            fastener.recohere(t);
          }
        }
      }
    }
    observe(observer) {
      const oldObservers = this.observers;
      const newObservers = Arrays.inserted(observer, oldObservers);
      if (oldObservers !== newObservers) {
        this.willObserve(observer);
        this.observers = newObservers;
        this.onObserve(observer);
        this.didObserve(observer);
      }
    }
    willObserve(observer) {}
    onObserve(observer) {}
    didObserve(observer) {}
    unobserve(observer) {
      const oldObservers = this.observers;
      const newObservers = Arrays.removed(observer, oldObservers);
      if (oldObservers !== newObservers) {
        this.willUnobserve(observer);
        this.observers = newObservers;
        this.onUnobserve(observer);
        this.didUnobserve(observer);
      }
    }
    willUnobserve(observer) {}
    onUnobserve(observer) {}
    didUnobserve(observer) {}
    forEachObserver(callback) {
      let result;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        result = callback.call(this, observer);
        if (result !== void 0) {
          return result;
        }
      }
      return result;
    }
    callObservers(key, ...args) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        const method = observer[key];
        if (typeof method === "function") {
          method.call(observer, ...args);
        }
      }
    }
  }
  const Provider = function(_super) {
    const Provider = _super.extend("Provider");
    Object.defineProperty(Provider.prototype, "fastenerType", {
      get: function() {
        return Provider;
      },
      configurable: true
    });
    Provider.prototype.onInherit = function(superFastener) {
      this.setService(superFastener.service);
    };
    Provider.prototype.onBindSuperFastener = function(superFastener) {
      if ((this.flags & Fastener.InheritsFlag) !== 0 && (this.flags & Affinity.Mask) === Affinity.Inherited) {
        this.initAffinity(Affinity.Transient);
      }
      _super.prototype.onBindSuperFastener.call(this, superFastener);
    };
    Provider.prototype.onUnbindSuperFastener = function(superFastener) {
      _super.prototype.onUnbindSuperFastener.call(this, superFastener);
      if ((this.flags & Fastener.InheritsFlag) !== 0 && (this.flags & Affinity.Mask) === Affinity.Transient) {
        this.initAffinity(Affinity.Inherited);
      }
    };
    Provider.prototype.getService = function() {
      const service = this.service;
      if (service === void 0 || service === null) {
        let message = service + " ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "service";
        throw new TypeError(message);
      }
      return service;
    };
    Provider.prototype.getServiceOr = function(elseService) {
      let service = this.service;
      if (service === void 0 || service === null) {
        service = elseService;
      }
      return service;
    };
    Provider.prototype.setService = function(newService) {
      const oldService = this.service;
      if (oldService !== newService) {
        if (oldService !== void 0 && oldService !== null) {
          this.willDetachService(oldService);
          this.service = void 0;
          this.onDetachService(oldService);
          this.deinitService(oldService);
          this.didDetachService(oldService);
        }
        if (newService !== void 0 && newService !== null) {
          this.willAttachService(newService);
          this.service = newService;
          this.onAttachService(newService);
          this.initService(newService);
          this.didAttachService(newService);
        }
      }
      return oldService;
    };
    Provider.prototype.initService = function(service) {};
    Provider.prototype.willAttachService = function(service) {};
    Provider.prototype.onAttachService = function(service) {
      if (this.observes === true && Observable.is(service)) {
        service.observe(this);
      }
    };
    Provider.prototype.didAttachService = function(service) {};
    Provider.prototype.deinitService = function(service) {};
    Provider.prototype.willDetachService = function(service) {};
    Provider.prototype.onDetachService = function(service) {
      if (this.observes === true && Observable.is(service)) {
        service.unobserve(this);
      }
    };
    Provider.prototype.didDetachService = function(service) {};
    Provider.prototype.createService = function() {
      return this.service;
    };
    Provider.prototype.onMount = function() {
      _super.prototype.onMount.call(this);
      let service = this.service;
      if (service === void 0 || service === null) {
        service = this.createService();
        this.setService(service);
      }
      if ((this.flags & Fastener.InheritedFlag) === 0 && service instanceof Service) {
        service.attachRoot(this.owner);
      }
    };
    Provider.prototype.onUnmount = function() {
      const service = this.service;
      if ((this.flags & Fastener.InheritedFlag) === 0 && service instanceof Service) {
        service.detachRoot(this.owner);
      }
      _super.prototype.onUnmount.call(this);
    };
    Provider.construct = function(providerClass, provider, owner) {
      if (provider === null) {
        provider = function() {
          return provider.service;
        };
        delete provider.name;
        Object.setPrototypeOf(provider, providerClass.prototype);
      }
      provider = _super.construct(providerClass, provider, owner);
      provider.service = void 0;
      provider.initAffinity(Affinity.Inherited);
      provider.initInherits(true);
      return provider;
    };
    Provider.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const service = descriptor.service;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.service;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const providerClass = superClass.extend(className, descriptor);
      providerClass.construct = function(providerClass, provider, owner) {
        provider = superClass.construct(providerClass, provider, owner);
        if (affinity !== void 0) {
          provider.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          provider.initInherits(inherits);
        }
        if (service !== void 0) {
          provider.setService(service);
        }
        return provider;
      };
      return providerClass;
    };
    return Provider;
  }(Fastener);
  const Timer = function(_super) {
    const Timer = _super.extend("Timer");
    Object.defineProperty(Timer.prototype, "fastenerType", {
      get: function() {
        return Timer;
      },
      configurable: true
    });
    Timer.prototype.onInherit = function(superFastener) {
      this.setDelay(superFastener.delay);
    };
    Timer.prototype.initDelay = function(delay) {
      this.delay = Math.max(0, delay);
    };
    Timer.prototype.setDelay = function(delay) {
      this.delay = Math.max(0, delay);
    };
    Object.defineProperty(Timer.prototype, "elapsed", {
      get: function() {
        const deadline = this.deadline;
        if (deadline !== void 0) {
          return Math.max(0, performance.now() - (deadline - this.delay));
        } else {
          return void 0;
        }
      },
      configurable: true
    });
    Object.defineProperty(Timer.prototype, "remaining", {
      get: function() {
        const deadline = this.deadline;
        if (deadline !== void 0) {
          return Math.max(0, deadline - performance.now());
        } else {
          return void 0;
        }
      },
      configurable: true
    });
    Timer.prototype.fire = function() {};
    Object.defineProperty(Timer.prototype, "scheduled", {
      get: function() {
        return this.timeout !== void 0;
      },
      configurable: true
    });
    Timer.prototype.schedule = function(delay) {
      let timeout = this.timeout;
      if (timeout === void 0) {
        if (delay === void 0) {
          delay = this.delay;
        } else {
          this.setDelay(delay);
        }
        this.willSchedule(delay);
        this.deadline = performance.now() + delay;
        timeout = this.setTimeout(this.expire.bind(this), delay);
        this.timeout = timeout;
        this.onSchedule(delay);
        this.didSchedule(delay);
      } else {
        throw new Error("timer already scheduled; call throttle or debounce to reschedule");
      }
    };
    Timer.prototype.throttle = function(delay) {
      let timeout = this.timeout;
      if (timeout === void 0) {
        if (delay === void 0) {
          delay = this.delay;
        } else {
          this.setDelay(delay);
        }
        this.willSchedule(delay);
        this.deadline = performance.now() + delay;
        timeout = this.setTimeout(this.expire.bind(this), delay);
        this.timeout = timeout;
        this.onSchedule(delay);
        this.didSchedule(delay);
      }
    };
    Timer.prototype.debounce = function(delay) {
      let timeout = this.timeout;
      if (timeout !== void 0) {
        this.willCancel();
        this.timeout = void 0;
        this.clearTimeout(timeout);
        this.onCancel();
        this.didCancel();
      }
      if (delay === void 0) {
        delay = this.delay;
      } else {
        this.setDelay(delay);
      }
      this.willSchedule(delay);
      this.deadline = performance.now() + delay;
      timeout = this.setTimeout(this.expire.bind(this), delay);
      this.timeout = timeout;
      this.onSchedule(delay);
      this.didSchedule(delay);
    };
    Timer.prototype.willSchedule = function(delay) {};
    Timer.prototype.onSchedule = function(delay) {};
    Timer.prototype.didSchedule = function(delay) {};
    Timer.prototype.cancel = function() {
      const timeout = this.timeout;
      if (timeout !== void 0) {
        this.willCancel();
        this.timeout = void 0;
        this.deadline = void 0;
        this.clearTimeout(timeout);
        this.onCancel();
        this.didCancel();
      }
    };
    Timer.prototype.willCancel = function() {};
    Timer.prototype.onCancel = function() {};
    Timer.prototype.didCancel = function() {};
    Timer.prototype.expire = function() {
      this.timeout = void 0;
      this.deadline = void 0;
      this.willExpire();
      this.fire();
      this.onExpire();
      this.didExpire();
    };
    Timer.prototype.willExpire = function() {};
    Timer.prototype.onExpire = function() {};
    Timer.prototype.didExpire = function() {};
    Timer.prototype.setTimeout = function(callback, delay) {
      return setTimeout(callback, delay);
    };
    Timer.prototype.clearTimeout = function(timeout) {
      clearTimeout(timeout);
    };
    Timer.prototype.onUnmount = function() {
      _super.prototype.onUnmount.call(this);
      this.cancel();
    };
    Object.defineProperty(Timer.prototype, "lazy", {
      get: function() {
        return false;
      },
      configurable: true
    });
    Object.defineProperty(Timer.prototype, "static", {
      get: function() {
        return true;
      },
      configurable: true
    });
    Timer.construct = function(fastenerClass, fastener, owner) {
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.delay = 0;
      fastener.deadline = 0;
      fastener.timeout = void 0;
      fastener.expire = fastener.expire.bind(fastener);
      return fastener;
    };
    Timer.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const delay = descriptor.delay;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.delay;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        if (delay !== void 0) {
          fastener.initDelay(delay);
        }
        return fastener;
      };
      return fastenerClass;
    };
    return Timer;
  }(Fastener);
  class Component {
    constructor() {
      this.uid = this.constructor.uid();
      this.key = void 0;
      this.flags = 0;
      this.parent = null;
      this.nextSibling = null;
      this.previousSibling = null;
      this.firstChild = null;
      this.lastChild = null;
      this.childMap = null;
      this.fasteners = null;
      this.decoherent = null;
      this.observers = Arrays.empty;
      FastenerContext.init(this);
    }
    get componentType() {
      return Component;
    }
    setKey(key) {
      this.key = key;
    }
    setFlags(flags) {
      this.flags = flags;
    }
    attachParent(parent, nextSibling) {
      this.willAttachParent(parent);
      this.parent = parent;
      let previousSibling;
      if (nextSibling !== null) {
        previousSibling = nextSibling.previousSibling;
        this.setNextSibling(nextSibling);
        nextSibling.setPreviousSibling(this);
      } else {
        previousSibling = parent.lastChild;
        parent.setLastChild(this);
      }
      if (previousSibling !== null) {
        previousSibling.setNextSibling(this);
        this.setPreviousSibling(previousSibling);
      } else {
        parent.setFirstChild(this);
      }
      if (parent.mounted) {
        this.cascadeMount();
      }
      this.onAttachParent(parent);
      this.didAttachParent(parent);
    }
    willAttachParent(parent) {}
    onAttachParent(parent) {}
    didAttachParent(parent) {}
    detachParent(parent) {
      this.willDetachParent(parent);
      if (this.mounted) {
        this.cascadeUnmount();
      }
      this.onDetachParent(parent);
      const nextSibling = this.nextSibling;
      const previousSibling = this.previousSibling;
      if (nextSibling !== null) {
        this.setNextSibling(null);
        nextSibling.setPreviousSibling(previousSibling);
      } else {
        parent.setLastChild(previousSibling);
      }
      if (previousSibling !== null) {
        previousSibling.setNextSibling(nextSibling);
        this.setPreviousSibling(null);
      } else {
        parent.setFirstChild(nextSibling);
      }
      this.parent = null;
      this.didDetachParent(parent);
    }
    willDetachParent(parent) {}
    onDetachParent(parent) {}
    didDetachParent(parent) {}
    setNextSibling(nextSibling) {
      this.nextSibling = nextSibling;
    }
    setPreviousSibling(previousSibling) {
      this.previousSibling = previousSibling;
    }
    setFirstChild(firstChild) {
      this.firstChild = firstChild;
    }
    setLastChild(lastChild) {
      this.lastChild = lastChild;
    }
    forEachChild(callback, thisArg) {
      let result;
      let child = this.firstChild;
      while (child !== null) {
        const next = child.nextSibling;
        const result = callback.call(thisArg, child);
        if (result !== void 0) {
          break;
        }
        child = next !== null && next.parent === this ? next : null;
      }
      return result;
    }
    insertChildMap(child) {
      const key = child.key;
      if (key !== void 0) {
        let childMap = this.childMap;
        if (childMap === null) {
          childMap = {};
          this.childMap = childMap;
        }
        childMap[key] = child;
      }
    }
    removeChildMap(child) {
      const key = child.key;
      if (key !== void 0) {
        const childMap = this.childMap;
        if (childMap !== null) {
          delete childMap[key];
        }
      }
    }
    getChild(key, childBound) {
      const childMap = this.childMap;
      if (childMap !== null) {
        const child = childMap[key];
        if (child !== void 0 && (childBound === void 0 || child instanceof childBound)) {
          return child;
        }
      }
      return null;
    }
    setChild(key, newChild) {
      const oldChild = this.getChild(key);
      let target;
      if (oldChild !== null && newChild !== null && oldChild !== newChild) {
        newChild.remove();
        target = oldChild.nextSibling;
        if ((oldChild.flags & Component.RemovingFlag) === 0) {
          oldChild.setFlags(oldChild.flags | Component.RemovingFlag);
          this.willRemoveChild(oldChild);
          oldChild.detachParent(this);
          this.removeChildMap(oldChild);
          this.onRemoveChild(oldChild);
          this.didRemoveChild(oldChild);
          oldChild.setKey(void 0);
          oldChild.setFlags(oldChild.flags & ~Component.RemovingFlag);
        }
        newChild.setKey(oldChild.key);
        this.willInsertChild(newChild, target);
        this.insertChildMap(newChild);
        newChild.attachParent(this, target);
        this.onInsertChild(newChild, target);
        this.didInsertChild(newChild, target);
        newChild.cascadeInsert();
      } else if (newChild !== oldChild || newChild !== null && newChild.key !== key) {
        if (oldChild !== null) {
          target = oldChild.nextSibling;
          if ((oldChild.flags & Component.RemovingFlag) === 0) {
            oldChild.setFlags(oldChild.flags | Component.RemovingFlag);
            this.willRemoveChild(oldChild);
            oldChild.detachParent(this);
            this.removeChildMap(oldChild);
            this.onRemoveChild(oldChild);
            this.didRemoveChild(oldChild);
            oldChild.setKey(void 0);
            oldChild.setFlags(oldChild.flags & ~Component.RemovingFlag);
          }
        } else {
          target = null;
        }
        if (newChild !== null) {
          newChild.remove();
          newChild.setKey(key);
          this.willInsertChild(newChild, target);
          this.insertChildMap(newChild);
          newChild.attachParent(this, target);
          this.onInsertChild(newChild, target);
          this.didInsertChild(newChild, target);
          newChild.cascadeInsert();
        }
      }
      return oldChild;
    }
    appendChild(child, key) {
      child.remove();
      if (key !== void 0) {
        this.removeChild(key);
      }
      child.setKey(key);
      this.willInsertChild(child, null);
      this.insertChildMap(child);
      child.attachParent(this, null);
      this.onInsertChild(child, null);
      this.didInsertChild(child, null);
      child.cascadeInsert();
      return child;
    }
    prependChild(child, key) {
      child.remove();
      if (key !== void 0) {
        this.removeChild(key);
      }
      const target = this.firstChild;
      child.setKey(key);
      this.willInsertChild(child, target);
      this.insertChildMap(child);
      child.attachParent(this, target);
      this.onInsertChild(child, target);
      this.didInsertChild(child, target);
      child.cascadeInsert();
      return child;
    }
    insertChild(child, target, key) {
      if (target !== null && target.parent !== this) {
        throw new Error("insert target is not a child");
      }
      child.remove();
      if (key !== void 0) {
        this.removeChild(key);
      }
      child.setKey(key);
      this.willInsertChild(child, target);
      this.insertChildMap(child);
      child.attachParent(this, target);
      this.onInsertChild(child, target);
      this.didInsertChild(child, target);
      child.cascadeInsert();
      return child;
    }
    replaceChild(newChild, oldChild) {
      if (oldChild.parent !== this) {
        throw new Error("replacement target is not a child");
      }
      if (newChild !== oldChild) {
        newChild.remove();
        const target = oldChild.nextSibling;
        if ((oldChild.flags & Component.RemovingFlag) === 0) {
          oldChild.setFlags(oldChild.flags | Component.RemovingFlag);
          this.willRemoveChild(oldChild);
          oldChild.detachParent(this);
          this.removeChildMap(oldChild);
          this.onRemoveChild(oldChild);
          this.didRemoveChild(oldChild);
          oldChild.setKey(void 0);
          oldChild.setFlags(oldChild.flags & ~Component.RemovingFlag);
        }
        newChild.setKey(oldChild.key);
        this.willInsertChild(newChild, target);
        this.insertChildMap(newChild);
        newChild.attachParent(this, target);
        this.onInsertChild(newChild, target);
        this.didInsertChild(newChild, target);
        newChild.cascadeInsert();
      }
      return oldChild;
    }
    get insertChildFlags() {
      return this.constructor.InsertChildFlags;
    }
    willInsertChild(child, target) {}
    onInsertChild(child, target) {
      this.requireUpdate(this.insertChildFlags);
      this.bindChildFasteners(child, target);
    }
    didInsertChild(child, target) {}
    cascadeInsert() {}
    removeChild(key) {
      let child;
      if (typeof key === "string") {
        child = this.getChild(key);
        if (child === null) {
          return null;
        }
      } else {
        child = key;
        if (child.parent !== this) {
          throw new Error("not a child");
        }
      }
      if ((child.flags & Component.RemovingFlag) === 0) {
        child.setFlags(child.flags | Component.RemovingFlag);
        this.willRemoveChild(child);
        child.detachParent(this);
        this.removeChildMap(child);
        this.onRemoveChild(child);
        this.didRemoveChild(child);
        child.setKey(void 0);
        child.setFlags(child.flags & ~Component.RemovingFlag);
      }
      return child;
    }
    get removeChildFlags() {
      return this.constructor.RemoveChildFlags;
    }
    willRemoveChild(child) {}
    onRemoveChild(child) {
      this.requireUpdate(this.removeChildFlags);
      this.unbindChildFasteners(child);
    }
    didRemoveChild(child) {}
    removeChildren() {
      let child;
      while (child = this.lastChild, child !== null) {
        if ((child.flags & Component.RemovingFlag) !== 0) {
          throw new Error("inconsistent removeChildren");
        }
        this.willRemoveChild(child);
        child.detachParent(this);
        this.removeChildMap(child);
        this.onRemoveChild(child);
        this.didRemoveChild(child);
        child.setKey(void 0);
        child.setFlags(child.flags & ~Component.RemovingFlag);
      }
    }
    remove() {
      const parent = this.parent;
      if (parent !== null) {
        parent.removeChild(this);
      }
    }
    sortChildren(comparator) {
      let child = this.firstChild;
      if (child !== null) {
        const children = [];
        do {
          children.push(child);
          child = child.nextSibling;
        } while (child !== null);
        children.sort(comparator);
        child = children[0];
        this.setFirstChild(child);
        child.setPreviousSibling(null);
        for (let i = 1; i < children.length; i += 1) {
          const next = children[i];
          child.setNextSibling(next);
          next.setPreviousSibling(child);
          child = next;
        }
        child.setNextSibling(null);
        this.setLastChild(child);
      }
    }
    getSuper(superBound) {
      const parent = this.parent;
      if (parent === null) {
        return null;
      } else if (parent instanceof superBound) {
        return parent;
      } else {
        return parent.getSuper(superBound);
      }
    }
    getBase(baseBound) {
      const parent = this.parent;
      if (parent === null) {
        return null;
      } else {
        const base = parent.getBase(baseBound);
        if (base !== null) {
          return base;
        } else {
          return parent instanceof baseBound ? parent : null;
        }
      }
    }
    get mounted() {
      return (this.flags & Component.MountedFlag) !== 0;
    }
    get mountFlags() {
      return this.constructor.MountFlags;
    }
    mount() {
      if (!this.mounted && this.parent === null) {
        this.cascadeMount();
        this.cascadeInsert();
      }
    }
    cascadeMount() {
      if ((this.flags & Component.MountedFlag) === 0) {
        this.willMount();
        this.setFlags(this.flags | Component.MountedFlag);
        this.onMount();
        this.mountChildren();
        this.didMount();
      } else {
        throw new Error("already mounted");
      }
    }
    willMount() {}
    onMount() {
      this.requireUpdate(this.mountFlags);
      this.mountFasteners();
    }
    didMount() {}
    mountChildren() {
      let child = this.firstChild;
      while (child !== null) {
        const next = child.nextSibling;
        child.cascadeMount();
        if (next !== null && next.parent !== this) {
          throw new Error("inconsistent mount");
        }
        child = next;
      }
    }
    unmount() {
      if (this.mounted && this.parent === null) {
        this.cascadeUnmount();
      }
    }
    cascadeUnmount() {
      if ((this.flags & Component.MountedFlag) !== 0) {
        this.willUnmount();
        this.setFlags(this.flags & ~Component.MountedFlag);
        this.unmountChildren();
        this.onUnmount();
        this.didUnmount();
      } else {
        throw new Error("already unmounted");
      }
    }
    willUnmount() {}
    onUnmount() {
      this.unmountFasteners();
    }
    didUnmount() {}
    unmountChildren() {
      let child = this.lastChild;
      while (child !== null) {
        const prev = child.previousSibling;
        child.cascadeUnmount();
        if (prev !== null && prev.parent !== this) {
          throw new Error("inconsistent unmount");
        }
        child = prev;
      }
    }
    requireUpdate(updateFlags, immediate) {}
    hasFastener(fastenerName, fastenerBound) {
      const fasteners = this.fasteners;
      if (fasteners !== null) {
        const fastener = fasteners[fastenerName];
        if (fastener !== void 0 && (fastenerBound === void 0 || fastenerBound === null || fastener instanceof fastenerBound)) {
          return true;
        }
      }
      return false;
    }
    getFastener(fastenerName, fastenerBound) {
      const fasteners = this.fasteners;
      if (fasteners !== null) {
        const fastener = fasteners[fastenerName];
        if (fastener !== void 0 && (fastenerBound === void 0 || fastenerBound === null || fastener instanceof fastenerBound)) {
          return fastener;
        }
      }
      return null;
    }
    setFastener(fastenerName, newFastener) {
      var _a;
      const fasteners = this.fasteners;
      const oldFastener = fasteners !== null ? (_a = fasteners[fastenerName]) !== null && _a !== void 0 ? _a : null : null;
      if (oldFastener !== newFastener) {
        if (oldFastener !== null) {
          this.detachFastener(fastenerName, oldFastener);
        }
        if (newFastener !== null) {
          this.attachFastener(fastenerName, newFastener);
        }
      }
    }
    attachFastener(fastenerName, fastener) {
      let fasteners = this.fasteners;
      if (fasteners === null) {
        fasteners = {};
        this.fasteners = fasteners;
      }
      this.willAttachFastener(fastenerName, fastener);
      fasteners[fastenerName] = fastener;
      if (this.mounted) {
        fastener.mount();
      }
      this.onAttachFastener(fastenerName, fastener);
      this.didAttachFastener(fastenerName, fastener);
    }
    willAttachFastener(fastenerName, fastener) {}
    onAttachFastener(fastenerName, fastener) {
      this.bindFastener(fastener);
    }
    didAttachFastener(fastenerName, fastener) {}
    detachFastener(fastenerName, fastener) {
      const fasteners = this.fasteners;
      this.willDetachFastener(fastenerName, fastener);
      this.onDetachFastener(fastenerName, fastener);
      if (this.mounted) {
        fastener.unmount();
      }
      delete fasteners[fastenerName];
      this.didDetachFastener(fastenerName, fastener);
    }
    willDetachFastener(fastenerName, fastener) {}
    onDetachFastener(fastenerName, fastener) {}
    didDetachFastener(fastenerName, fastener) {}
    getLazyFastener(fastenerName, fastenerBound) {
      return FastenerContext.getLazyFastener(this, fastenerName, fastenerBound);
    }
    getSuperFastener(fastenerName, fastenerBound) {
      const parent = this.parent;
      if (parent === null) {
        return null;
      } else {
        const parentFastener = parent.getLazyFastener(fastenerName, fastenerBound);
        if (parentFastener !== null) {
          return parentFastener;
        } else {
          return parent.getSuperFastener(fastenerName, fastenerBound);
        }
      }
    }
    mountFasteners() {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        fastener.mount();
      }
    }
    unmountFasteners() {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        fastener.unmount();
      }
    }
    bindFastener(fastener) {
      if (fastener.binds) {
        let child = this.firstChild;
        while (child !== null) {
          const next = child.nextSibling;
          this.bindChildFastener(fastener, child, next);
          child = next !== null && next.parent === this ? next : null;
        }
      }
    }
    bindChildFasteners(child, target) {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        this.bindChildFastener(fastener, child, target);
      }
    }
    bindChildFastener(fastener, child, target) {
      if (fastener instanceof ComponentRelation) {
        fastener.bindComponent(child, target);
      }
    }
    unbindChildFasteners(child) {
      const fasteners = this.fasteners;
      for (const fastenerName in fasteners) {
        const fastener = fasteners[fastenerName];
        this.unbindChildFastener(fastener, child);
      }
    }
    unbindChildFastener(fastener, child) {
      if (fastener instanceof ComponentRelation) {
        fastener.unbindComponent(child);
      }
    }
    decohereFastener(fastener) {
      let decoherent = this.decoherent;
      if (decoherent === null) {
        decoherent = [];
        this.decoherent = decoherent;
      }
      decoherent.push(fastener);
    }
    recohereFasteners(t) {
      const decoherent = this.decoherent;
      if (decoherent !== null) {
        const decoherentCount = decoherent.length;
        if (decoherentCount !== 0) {
          if (t === void 0) {
            t = performance.now();
          }
          this.decoherent = null;
          for (let i = 0; i < decoherentCount; i += 1) {
            const fastener = decoherent[i];
            fastener.recohere(t);
          }
        }
      }
    }
    observe(observer) {
      const oldObservers = this.observers;
      const newObservers = Arrays.inserted(observer, oldObservers);
      if (oldObservers !== newObservers) {
        this.willObserve(observer);
        this.observers = newObservers;
        this.onObserve(observer);
        this.didObserve(observer);
      }
    }
    willObserve(observer) {}
    onObserve(observer) {}
    didObserve(observer) {}
    unobserve(observer) {
      const oldObservers = this.observers;
      const newObservers = Arrays.removed(observer, oldObservers);
      if (oldObservers !== newObservers) {
        this.willUnobserve(observer);
        this.observers = newObservers;
        this.onUnobserve(observer);
        this.didUnobserve(observer);
      }
    }
    willUnobserve(observer) {}
    onUnobserve(observer) {}
    didUnobserve(observer) {}
    forEachObserver(callback) {
      let result;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        result = callback.call(this, observer);
        if (result !== void 0) {
          return result;
        }
      }
      return result;
    }
    callObservers(key, ...args) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        const method = observer[key];
        if (typeof method === "function") {
          method.call(observer, ...args);
        }
      }
    }
    equals(that) {
      return this === that;
    }
    hashCode() {
      return this.uid;
    }
    init(init) {}
    static create() {
      return new this;
    }
    static fromInit(init) {
      let type;
      if ((typeof init === "object" && init !== null || typeof init === "function") && Creatable.is(init.type)) {
        type = init.type;
      } else {
        type = this;
      }
      const component = type.create();
      component.init(init);
      return component;
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return value;
      } else if (value instanceof Component) {
        if (value instanceof this) {
          return value;
        } else {
          throw new TypeError(value + " not an instance of " + this);
        }
      } else if (Creatable.is(value)) {
        return value.create();
      } else {
        return this.fromInit(value);
      }
    }
  }
  Component.uid = function() {
    let nextId = 1;
    return function uid() {
      const id = ~~nextId;
      nextId += 1;
      return id;
    };
  }();
  Component.MountedFlag = 1 << 0;
  Component.RemovingFlag = 1 << 1;
  Component.FlagShift = 2;
  Component.FlagMask = (1 << Component.FlagShift) - 1;
  Component.MountFlags = 0;
  Component.InsertChildFlags = 0;
  Component.RemoveChildFlags = 0;
  const ComponentRelation = function(_super) {
    const ComponentRelation = _super.extend("ComponentRelation");
    Object.defineProperty(ComponentRelation.prototype, "fastenerType", {
      get: function() {
        return ComponentRelation;
      },
      configurable: true
    });
    ComponentRelation.prototype.initComponent = function(component) {};
    ComponentRelation.prototype.willAttachComponent = function(component, target) {};
    ComponentRelation.prototype.onAttachComponent = function(component, target) {
      if (this.observes === true) {
        component.observe(this);
      }
    };
    ComponentRelation.prototype.didAttachComponent = function(component, target) {};
    ComponentRelation.prototype.deinitComponent = function(component) {};
    ComponentRelation.prototype.willDetachComponent = function(component) {};
    ComponentRelation.prototype.onDetachComponent = function(component) {
      if (this.observes === true) {
        component.unobserve(this);
      }
    };
    ComponentRelation.prototype.didDetachComponent = function(component) {};
    Object.defineProperty(ComponentRelation.prototype, "parentComponent", {
      get() {
        const owner = this.owner;
        return owner instanceof Component ? owner : null;
      },
      configurable: true
    });
    ComponentRelation.prototype.insertChild = function(parent, child, target, key) {
      parent.insertChild(child, target, key);
    };
    ComponentRelation.prototype.bindComponent = function(component, target) {};
    ComponentRelation.prototype.unbindComponent = function(component) {};
    ComponentRelation.prototype.detectComponent = function(component) {
      return null;
    };
    ComponentRelation.prototype.createComponent = function() {
      let component;
      const type = this.type;
      if (type !== void 0) {
        component = type.create();
      }
      if (component === void 0 || component === null) {
        let message = "Unable to create ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "component";
        throw new Error(message);
      }
      return component;
    };
    ComponentRelation.prototype.fromAny = function(value) {
      const type = this.type;
      if (type !== void 0) {
        return type.fromAny(value);
      } else {
        return Component.fromAny(value);
      }
    };
    Object.defineProperty(ComponentRelation.prototype, "lazy", {
      get: function() {
        return false;
      },
      configurable: true
    });
    Object.defineProperty(ComponentRelation.prototype, "static", {
      get: function() {
        return true;
      },
      configurable: true
    });
    ComponentRelation.construct = function(fastenerClass, fastener, owner) {
      fastener = _super.construct(fastenerClass, fastener, owner);
      return fastener;
    };
    ComponentRelation.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        return fastener;
      };
      return fastenerClass;
    };
    return ComponentRelation;
  }(Fastener);
  const ComponentRef = function(_super) {
    const ComponentRef = _super.extend("ComponentRef");
    Object.defineProperty(ComponentRef.prototype, "fastenerType", {
      get: function() {
        return ComponentRef;
      },
      configurable: true
    });
    ComponentRef.prototype.onInherit = function(superFastener) {
      this.setComponent(superFastener.component);
    };
    ComponentRef.prototype.getComponent = function() {
      const component = this.component;
      if (component === null) {
        let message = component + " ";
        if (this.name.length !== 0) {
          message += this.name + " ";
        }
        message += "component";
        throw new TypeError(message);
      }
      return component;
    };
    ComponentRef.prototype.setComponent = function(newComponent, target, key) {
      if (newComponent !== null) {
        newComponent = this.fromAny(newComponent);
      }
      let oldComponent = this.component;
      if (oldComponent !== newComponent) {
        if (target === void 0) {
          target = null;
        }
        let parent;
        if (this.binds && (parent = this.parentComponent, parent !== null)) {
          if (oldComponent !== null && oldComponent.parent === parent) {
            if (target === null) {
              target = oldComponent.nextSibling;
            }
            oldComponent.remove();
          }
          if (newComponent !== null) {
            if (key === void 0) {
              key = this.key;
            }
            this.insertChild(parent, newComponent, target, key);
          }
          oldComponent = this.component;
        }
        if (oldComponent !== newComponent) {
          if (oldComponent !== null) {
            this.willDetachComponent(oldComponent);
            this.component = null;
            this.onDetachComponent(oldComponent);
            this.deinitComponent(oldComponent);
            this.didDetachComponent(oldComponent);
          }
          if (newComponent !== null) {
            this.willAttachComponent(newComponent, target);
            this.component = newComponent;
            this.onAttachComponent(newComponent, target);
            this.initComponent(newComponent);
            this.didAttachComponent(newComponent, target);
          }
        }
      }
      return oldComponent;
    };
    ComponentRef.prototype.attachComponent = function(newComponent, target) {
      const oldComponent = this.component;
      if (newComponent !== void 0 && newComponent !== null) {
        newComponent = this.fromAny(newComponent);
      } else if (oldComponent === null) {
        newComponent = this.createComponent();
      } else {
        newComponent = oldComponent;
      }
      if (newComponent !== oldComponent) {
        if (target === void 0) {
          target = null;
        }
        if (oldComponent !== null) {
          this.willDetachComponent(oldComponent);
          this.component = null;
          this.onDetachComponent(oldComponent);
          this.deinitComponent(oldComponent);
          this.didDetachComponent(oldComponent);
        }
        this.willAttachComponent(newComponent, target);
        this.component = newComponent;
        this.onAttachComponent(newComponent, target);
        this.initComponent(newComponent);
        this.didAttachComponent(newComponent, target);
      }
      return newComponent;
    };
    ComponentRef.prototype.detachComponent = function() {
      const oldComponent = this.component;
      if (oldComponent !== null) {
        this.willDetachComponent(oldComponent);
        this.component = null;
        this.onDetachComponent(oldComponent);
        this.deinitComponent(oldComponent);
        this.didDetachComponent(oldComponent);
      }
      return oldComponent;
    };
    ComponentRef.prototype.insertComponent = function(parent, newComponent, target, key) {
      if (newComponent !== void 0 && newComponent !== null) {
        newComponent = this.fromAny(newComponent);
      } else {
        const oldComponent = this.component;
        if (oldComponent === null) {
          newComponent = this.createComponent();
        } else {
          newComponent = oldComponent;
        }
      }
      if (parent === void 0 || parent === null) {
        parent = this.parentComponent;
      }
      if (target === void 0) {
        target = null;
      }
      if (key === void 0) {
        key = this.key;
      }
      if (parent !== null && (newComponent.parent !== parent || newComponent.key !== key)) {
        this.insertChild(parent, newComponent, target, key);
      }
      const oldComponent = this.component;
      if (newComponent !== oldComponent) {
        if (oldComponent !== null) {
          this.willDetachComponent(oldComponent);
          this.component = null;
          this.onDetachComponent(oldComponent);
          this.deinitComponent(oldComponent);
          this.didDetachComponent(oldComponent);
          oldComponent.remove();
        }
        this.willAttachComponent(newComponent, target);
        this.component = newComponent;
        this.onAttachComponent(newComponent, target);
        this.initComponent(newComponent);
        this.didAttachComponent(newComponent, target);
      }
      return newComponent;
    };
    ComponentRef.prototype.removeComponent = function() {
      const component = this.component;
      if (component !== null) {
        component.remove();
      }
      return component;
    };
    ComponentRef.prototype.deleteComponent = function() {
      const component = this.detachComponent();
      if (component !== null) {
        component.remove();
      }
      return component;
    };
    ComponentRef.prototype.bindComponent = function(component, target) {
      if (this.binds && this.component === null) {
        const newComponent = this.detectComponent(component);
        if (newComponent !== null) {
          this.willAttachComponent(newComponent, target);
          this.component = newComponent;
          this.onAttachComponent(newComponent, target);
          this.initComponent(newComponent);
          this.didAttachComponent(newComponent, target);
        }
      }
    };
    ComponentRef.prototype.unbindComponent = function(component) {
      if (this.binds) {
        const oldComponent = this.detectComponent(component);
        if (oldComponent !== null && this.component === oldComponent) {
          this.willDetachComponent(oldComponent);
          this.component = null;
          this.onDetachComponent(oldComponent);
          this.deinitComponent(oldComponent);
          this.didDetachComponent(oldComponent);
        }
      }
    };
    ComponentRef.prototype.detectComponent = function(component) {
      const key = this.key;
      if (key !== void 0 && key === component.key) {
        return component;
      }
      return null;
    };
    ComponentRef.construct = function(fastenerClass, fastener, owner) {
      if (fastener === null) {
        fastener = function(component, target, key) {
          if (component === void 0) {
            return fastener.component;
          } else {
            fastener.setComponent(component, target, key);
            return fastener.owner;
          }
        };
        delete fastener.name;
        Object.setPrototypeOf(fastener, fastenerClass.prototype);
      }
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.key = void 0;
      fastener.component = null;
      return fastener;
    };
    ComponentRef.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      if (descriptor.key === true) {
        Object.defineProperty(descriptor, "key", {
          value: className,
          configurable: true
        });
      } else if (descriptor.key === false) {
        Object.defineProperty(descriptor, "key", {
          value: void 0,
          configurable: true
        });
      }
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        return fastener;
      };
      return fastenerClass;
    };
    return ComponentRef;
  }(ComponentRelation);
  const ComponentSet = function(_super) {
    const ComponentSet = _super.extend("ComponentSet");
    Object.defineProperty(ComponentSet.prototype, "fastenerType", {
      get: function() {
        return ComponentSet;
      },
      configurable: true
    });
    ComponentSet.prototype.hasComponent = function(component) {
      return this.components[component.uid] !== void 0;
    };
    ComponentSet.prototype.addComponent = function(newComponent, target, key) {
      if (newComponent !== void 0 && newComponent !== null) {
        newComponent = this.fromAny(newComponent);
      } else {
        newComponent = this.createComponent();
      }
      if (target === void 0) {
        target = null;
      }
      let parent;
      if (this.binds && (parent = this.parentComponent, parent !== null)) {
        if (key === void 0) {
          key = this.key(newComponent);
        }
        this.insertChild(parent, newComponent, target, key);
      }
      const components = this.components;
      if (components[newComponent.uid] === void 0) {
        this.willAttachComponent(newComponent, target);
        components[newComponent.uid] = newComponent;
        this.componentCount += 1;
        this.onAttachComponent(newComponent, target);
        this.initComponent(newComponent);
        this.didAttachComponent(newComponent, target);
      }
      return newComponent;
    };
    ComponentSet.prototype.attachComponent = function(newComponent, target) {
      if (newComponent !== void 0 && newComponent !== null) {
        newComponent = this.fromAny(newComponent);
      } else {
        newComponent = this.createComponent();
      }
      const components = this.components;
      if (components[newComponent.uid] === void 0) {
        if (target === void 0) {
          target = null;
        }
        this.willAttachComponent(newComponent, target);
        components[newComponent.uid] = newComponent;
        this.componentCount += 1;
        this.onAttachComponent(newComponent, target);
        this.initComponent(newComponent);
        this.didAttachComponent(newComponent, target);
      }
      return newComponent;
    };
    ComponentSet.prototype.detachComponent = function(oldComponent) {
      const components = this.components;
      if (components[oldComponent.uid] !== void 0) {
        this.willDetachComponent(oldComponent);
        this.componentCount -= 1;
        delete components[oldComponent.uid];
        this.onDetachComponent(oldComponent);
        this.deinitComponent(oldComponent);
        this.didDetachComponent(oldComponent);
        return oldComponent;
      }
      return null;
    };
    ComponentSet.prototype.insertComponent = function(parent, newComponent, target, key) {
      if (newComponent !== void 0 && newComponent !== null) {
        newComponent = this.fromAny(newComponent);
      } else {
        newComponent = this.createComponent();
      }
      if (parent === void 0 || parent === null) {
        parent = this.parentComponent;
      }
      if (target === void 0) {
        target = null;
      }
      if (key === void 0) {
        key = this.key(newComponent);
      }
      if (parent !== null && (newComponent.parent !== parent || newComponent.key !== key)) {
        this.insertChild(parent, newComponent, target, key);
      }
      const components = this.components;
      if (components[newComponent.uid] === void 0) {
        this.willAttachComponent(newComponent, target);
        components[newComponent.uid] = newComponent;
        this.componentCount += 1;
        this.onAttachComponent(newComponent, target);
        this.initComponent(newComponent);
        this.didAttachComponent(newComponent, target);
      }
      return newComponent;
    };
    ComponentSet.prototype.removeComponent = function(component) {
      if (this.hasComponent(component)) {
        component.remove();
        return component;
      }
      return null;
    };
    ComponentSet.prototype.deleteComponent = function(component) {
      const oldComponent = this.detachComponent(component);
      if (oldComponent !== null) {
        oldComponent.remove();
      }
      return oldComponent;
    };
    ComponentSet.prototype.bindComponent = function(component, target) {
      if (this.binds) {
        const newComponent = this.detectComponent(component);
        const components = this.components;
        if (newComponent !== null && components[newComponent.uid] === void 0) {
          this.willAttachComponent(newComponent, target);
          components[newComponent.uid] = newComponent;
          this.componentCount += 1;
          this.onAttachComponent(newComponent, target);
          this.initComponent(newComponent);
          this.didAttachComponent(newComponent, target);
        }
      }
    };
    ComponentSet.prototype.unbindComponent = function(component) {
      if (this.binds) {
        const oldComponent = this.detectComponent(component);
        const components = this.components;
        if (oldComponent !== null && components[oldComponent.uid] !== void 0) {
          this.willDetachComponent(oldComponent);
          this.componentCount -= 1;
          delete components[oldComponent.uid];
          this.onDetachComponent(oldComponent);
          this.deinitComponent(oldComponent);
          this.didDetachComponent(oldComponent);
        }
      }
    };
    ComponentSet.prototype.detectComponent = function(component) {
      if (typeof this.type === "function" && component instanceof this.type) {
        return component;
      }
      return null;
    };
    ComponentSet.prototype.key = function(component) {
      return void 0;
    };
    Object.defineProperty(ComponentSet.prototype, "sorted", {
      get() {
        return (this.flags & ComponentSet.SortedFlag) !== 0;
      },
      configurable: true
    });
    ComponentSet.prototype.initInherits = function(sorted) {
      if (sorted) {
        this.flags = this.flags | ComponentSet.SortedFlag;
      } else {
        this.flags = this.flags & ~ComponentSet.SortedFlag;
      }
    };
    ComponentSet.prototype.sort = function(sorted) {
      if (sorted === void 0) {
        sorted = true;
      }
      const flags = this.flags;
      if (sorted && (flags & ComponentSet.SortedFlag) === 0) {
        const parent = this.parentComponent;
        this.willSort(parent);
        this.setFlags(flags | ComponentSet.SortedFlag);
        this.onSort(parent);
        this.didSort(parent);
      } else if (!sorted && (flags & ComponentSet.SortedFlag) !== 0) {
        this.setFlags(flags & ~ComponentSet.SortedFlag);
      }
      return this;
    };
    ComponentSet.prototype.willSort = function(parent) {};
    ComponentSet.prototype.onSort = function(parent) {
      if (parent !== null) {
        this.sortChildren(parent);
      }
    };
    ComponentSet.prototype.didSort = function(parent) {};
    ComponentSet.prototype.sortChildren = function(parent) {
      parent.sortChildren(this.compareChildren.bind(this));
    };
    ComponentSet.prototype.compareChildren = function(a, b) {
      const components = this.components;
      const x = components[a.uid];
      const y = components[b.uid];
      if (x !== void 0 && y !== void 0) {
        return this.compare(x, y);
      } else {
        return x !== void 0 ? 1 : y !== void 0 ? -1 : 0;
      }
    };
    ComponentSet.prototype.compare = function(a, b) {
      return a.uid < b.uid ? -1 : a.uid > b.uid ? 1 : 0;
    };
    ComponentSet.construct = function(fastenerClass, fastener, owner) {
      if (fastener === null) {
        fastener = function(newComponent) {
          fastener.addComponent(newComponent);
          return fastener.owner;
        };
        delete fastener.name;
        Object.setPrototypeOf(fastener, fastenerClass.prototype);
      }
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.components = {};
      fastener.componentCount = 0;
      return fastener;
    };
    ComponentSet.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const sorted = descriptor.sorted;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.sorted;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        if (sorted !== void 0) {
          fastener.initSorted(sorted);
        }
        return fastener;
      };
      return fastenerClass;
    };
    ComponentSet.SortedFlag = 1 << _super.FlagShift + 0;
    ComponentSet.FlagShift = _super.FlagShift + 1;
    ComponentSet.FlagMask = (1 << ComponentSet.FlagShift) - 1;
    return ComponentSet;
  }(ComponentRelation);
  class KeysCursor extends Cursor {
    constructor(cursor) {
      super();
      this.cursor = cursor;
    }
    isEmpty() {
      return this.cursor.isEmpty();
    }
    head() {
      return this.cursor.head()[0];
    }
    step() {
      this.cursor.step();
    }
    skip(count) {
      this.cursor.skip(count);
    }
    hasNext() {
      return this.cursor.hasNext();
    }
    nextIndex() {
      return this.cursor.nextIndex();
    }
    next() {
      const {value: value, done: done} = this.cursor.next();
      return {
        value: value && value[0],
        done: done
      };
    }
    hasPrevious() {
      return this.cursor.hasPrevious();
    }
    previousIndex() {
      return this.cursor.previousIndex();
    }
    previous() {
      const {value: value, done: done} = this.cursor.previous();
      return {
        value: value && value[0],
        done: done
      };
    }
    delete() {
      this.cursor.delete();
    }
  }
  class ValuesCursor extends Cursor {
    constructor(cursor) {
      super();
      this.cursor = cursor;
    }
    isEmpty() {
      return this.cursor.isEmpty();
    }
    head() {
      return this.cursor.head()[1];
    }
    step() {
      this.cursor.step();
    }
    skip(count) {
      this.cursor.skip(count);
    }
    hasNext() {
      return this.cursor.hasNext();
    }
    nextIndex() {
      return this.cursor.nextIndex();
    }
    next() {
      const {value: value, done: done} = this.cursor.next();
      return {
        value: value && value[1],
        done: done
      };
    }
    hasPrevious() {
      return this.cursor.hasPrevious();
    }
    previousIndex() {
      return this.cursor.previousIndex();
    }
    previous() {
      const {value: value, done: done} = this.cursor.previous();
      return {
        value: value && value[1],
        done: done
      };
    }
    delete() {
      this.cursor.delete();
    }
  }
  class NodeCursor extends Cursor {
    constructor(pages, index, childIndex, childCursor) {
      super();
      this.pages = pages;
      this.index = index;
      this.childIndex = childIndex;
      this.childCursor = childCursor;
    }
    isEmpty() {
      do {
        if (this.childCursor !== null) {
          if (!this.childCursor.isEmpty()) {
            return false;
          } else {
            this.childCursor = null;
          }
        } else if (this.childIndex < this.pages.length) {
          this.childCursor = this.pageCursor(this.pages[this.childIndex]);
          this.childIndex += 1;
        } else {
          this.childIndex = this.pages.length;
          return true;
        }
      } while (true);
    }
    head() {
      do {
        if (this.childCursor !== null) {
          if (!this.childCursor.isEmpty()) {
            return this.childCursor.head();
          } else {
            this.childCursor = null;
          }
        } else {
          if (this.childIndex < this.pages.length) {
            this.childCursor = this.pageCursor(this.pages[this.childIndex]);
            this.childIndex += 1;
          } else {
            this.childIndex = this.pages.length;
            throw new Error("empty");
          }
        }
      } while (true);
    }
    step() {
      do {
        if (this.childCursor !== null) {
          if (!this.childCursor.isEmpty()) {
            this.index += 1;
            return;
          } else {
            this.childCursor = null;
          }
        } else {
          if (this.childIndex < this.pages.length) {
            this.childCursor = this.pageCursor(this.pages[this.childIndex]);
            this.childIndex += 1;
          } else {
            this.childIndex = this.pages.length;
            throw new Error("empty");
          }
        }
      } while (true);
    }
    skip(count) {
      while (count > 0) {
        if (this.childCursor !== null) {
          if (this.childCursor.hasNext()) {
            this.index += 1;
            count -= 1;
            this.childCursor.next();
          } else {
            this.childCursor = null;
          }
        } else if (this.childIndex < this.pages.length) {
          const page = this.pages[this.childIndex];
          const pageSize = this.pageSize(page);
          this.childIndex += 1;
          if (pageSize < count) {
            this.childCursor = this.pageCursor(page);
            if (count > 0) {
              this.index += count;
              this.childCursor.skip(count);
              count = 0;
            }
            break;
          } else {
            this.index += pageSize;
            count -= pageSize;
          }
        } else {
          break;
        }
      }
    }
    hasNext() {
      do {
        if (this.childCursor !== null) {
          if (this.childCursor.hasNext()) {
            return true;
          } else {
            this.childCursor = null;
          }
        } else if (this.childIndex < this.pages.length) {
          this.childCursor = this.pageCursor(this.pages[this.childIndex]);
          this.childIndex += 1;
        } else {
          this.childIndex = this.pages.length;
          return false;
        }
      } while (true);
    }
    nextIndex() {
      return this.index;
    }
    next() {
      do {
        if (this.childCursor !== null) {
          if (this.childCursor.hasNext()) {
            this.index += 1;
            return this.childCursor.next();
          } else {
            this.childCursor = null;
          }
        } else {
          if (this.childIndex < this.pages.length) {
            this.childCursor = this.pageCursor(this.pages[this.childIndex]);
            this.childIndex += 1;
          } else {
            this.childIndex = this.pages.length;
            return {
              done: true
            };
          }
        }
      } while (true);
    }
    hasPrevious() {
      do {
        if (this.childCursor !== null) {
          if (this.childCursor.hasPrevious()) {
            return true;
          } else {
            this.childCursor = null;
          }
        } else if (this.childIndex > 0) {
          this.childCursor = this.reversePageCursor(this.pages[this.childIndex - 1]);
          this.childIndex -= 1;
        } else {
          this.childIndex = 0;
          return false;
        }
      } while (true);
    }
    previousIndex() {
      return this.index - 1;
    }
    previous() {
      do {
        if (this.childCursor !== null) {
          if (this.childCursor.hasPrevious()) {
            this.index -= 1;
            return this.childCursor.previous();
          } else {
            this.childCursor = null;
          }
        } else if (this.childIndex > 0) {
          this.childCursor = this.reversePageCursor(this.pages[this.childIndex - 1]);
          this.childIndex -= 1;
        } else {
          this.childIndex = 0;
          return {
            done: true
          };
        }
      } while (true);
    }
    set(newValue) {
      this.childCursor.set(newValue);
    }
    delete() {
      this.childCursor.delete();
    }
  }
  class BTreeContext {
    constructor() {
      this.pageSplitSize = 32;
    }
    compare(x, y) {
      return Values.compare(x, y);
    }
    pageShouldSplit(page) {
      return page.arity > this.pageSplitSize;
    }
    pageShouldMerge(page) {
      return page.arity < this.pageSplitSize >>> 1;
    }
  }
  class BTree extends BTreeContext {
    constructor(root) {
      super();
      if (root === void 0) {
        root = BTreePage.empty();
      }
      this.root = root;
    }
    get size() {
      return this.root.size;
    }
    isEmpty() {
      return this.root.isEmpty();
    }
    has(key) {
      return this.root.has(key, this);
    }
    get(key) {
      return this.root.get(key, this);
    }
    getEntry(index) {
      return this.root.getEntry(index);
    }
    firstKey() {
      const entry = this.root.firstEntry();
      if (entry !== void 0) {
        return entry[0];
      } else {
        return void 0;
      }
    }
    firstValue() {
      const entry = this.root.firstEntry();
      if (entry !== void 0) {
        return entry[1];
      } else {
        return void 0;
      }
    }
    firstEntry() {
      return this.root.firstEntry();
    }
    lastKey() {
      const entry = this.root.lastEntry();
      if (entry !== void 0) {
        return entry[0];
      } else {
        return void 0;
      }
    }
    lastValue() {
      const entry = this.root.lastEntry();
      if (entry !== void 0) {
        return entry[1];
      } else {
        return void 0;
      }
    }
    lastEntry() {
      return this.root.lastEntry();
    }
    nextKey(key) {
      const entry = this.root.nextEntry(key, this);
      if (entry !== void 0) {
        return entry[0];
      } else {
        return void 0;
      }
    }
    nextValue(key) {
      const entry = this.root.nextEntry(key, this);
      if (entry !== void 0) {
        return entry[1];
      } else {
        return void 0;
      }
    }
    nextEntry(key) {
      return this.root.nextEntry(key, this);
    }
    previousKey(key) {
      const entry = this.root.previousEntry(key, this);
      if (entry !== void 0) {
        return entry[0];
      } else {
        return void 0;
      }
    }
    previousValue(key) {
      const entry = this.root.previousEntry(key, this);
      if (entry !== void 0) {
        return entry[1];
      } else {
        return void 0;
      }
    }
    previousEntry(key) {
      return this.root.previousEntry(key, this);
    }
    set(key, newValue) {
      const oldRoot = this.root;
      let newRoot = this.root.updated(key, newValue, this);
      if (oldRoot !== newRoot) {
        if (newRoot.size > oldRoot.size) {
          newRoot = newRoot.balanced(this);
        }
        this.root = newRoot;
      }
      return this;
    }
    delete(key) {
      const oldRoot = this.root;
      const newRoot = this.root.removed(key, this);
      if (oldRoot !== newRoot) {
        this.root = newRoot;
        return true;
      } else {
        return false;
      }
    }
    drop(lower) {
      if (lower > 0 && this.root.size > 0) {
        if (lower < this.root.size) {
          this.root = this.root.drop(lower, this);
        } else {
          this.root = BTreePage.empty();
        }
      }
      return this;
    }
    take(upper) {
      if (upper < this.root.size && this.root.size > 0) {
        if (upper > 0) {
          this.root = this.root.take(upper, this);
        } else {
          this.root = BTreePage.empty();
        }
      }
      return this;
    }
    clear() {
      this.root = BTreePage.empty();
    }
    updated(key, newValue) {
      const oldRoot = this.root;
      let newRoot = oldRoot.updated(key, newValue, this);
      if (oldRoot !== newRoot) {
        if (newRoot.size > oldRoot.size) {
          newRoot = newRoot.balanced(this);
        }
        return this.copy(newRoot);
      } else {
        return this;
      }
    }
    removed(key) {
      const oldRoot = this.root;
      const newRoot = oldRoot.removed(key, this);
      if (oldRoot !== newRoot) {
        return this.copy(newRoot);
      } else {
        return this;
      }
    }
    cleared() {
      if (!this.root.isEmpty()) {
        return this.copy(BTreePage.empty());
      } else {
        return this;
      }
    }
    reduced(identity, accumulator, combiner) {
      const oldRoot = this.root;
      const newRoot = oldRoot.reduced(identity, accumulator, combiner);
      if (oldRoot !== newRoot) {
        this.root = newRoot;
      }
      return newRoot.fold;
    }
    forEach(callback, thisArg) {
      return this.root.forEach(callback, thisArg);
    }
    forEachKey(callback, thisArg) {
      return this.root.forEachKey(callback, thisArg);
    }
    forEachValue(callback, thisArg) {
      return this.root.forEachValue(callback, thisArg);
    }
    keys() {
      return this.root.keys();
    }
    values() {
      return this.root.values();
    }
    entries() {
      return this.root.entries();
    }
    reverseKeys() {
      return this.root.reverseKeys();
    }
    reverseValues() {
      return this.root.reverseValues();
    }
    reverseEntries() {
      return this.root.reverseEntries();
    }
    clone() {
      return this.copy(this.root);
    }
    copy(root) {
      const tree = new BTree(root);
      if (tree.compare !== this.compare) {
        tree.compare = this.compare;
      }
      if (tree.pageSplitSize !== this.pageSplitSize) {
        tree.pageSplitSize = this.pageSplitSize;
      }
      return tree;
    }
  }
  class BTreePage {
    keys() {
      return new KeysCursor(this.entries());
    }
    values() {
      return new ValuesCursor(this.entries());
    }
    reverseKeys() {
      return new KeysCursor(this.reverseEntries());
    }
    reverseValues() {
      return new ValuesCursor(this.reverseEntries());
    }
    static empty() {
      return new BTreeLeaf([], void 0);
    }
  }
  __decorate([ Lazy ], BTreePage, "empty", null);
  class BTreeLeaf extends BTreePage {
    constructor(slots, fold) {
      super();
      this.slots = slots;
      this.fold = fold;
    }
    get arity() {
      return this.slots.length;
    }
    get size() {
      return this.slots.length;
    }
    isEmpty() {
      return this.slots.length === 0;
    }
    minKey() {
      return this.slots[0][0];
    }
    maxKey() {
      return this.slots[this.slots.length - 1][0];
    }
    has(key, tree) {
      return this.lookup(key, tree) >= 0;
    }
    get(key, tree) {
      const x = this.lookup(key, tree);
      if (x >= 0) {
        return this.slots[x][1];
      } else {
        return void 0;
      }
    }
    getEntry(index) {
      return this.slots[index];
    }
    firstEntry() {
      const slots = this.slots;
      if (slots.length !== 0) {
        return slots[0];
      } else {
        return void 0;
      }
    }
    lastEntry() {
      const slots = this.slots;
      if (slots.length !== 0) {
        return slots[slots.length - 1];
      } else {
        return void 0;
      }
    }
    nextEntry(key, tree) {
      let x = this.lookup(key, tree);
      if (x >= 0) {
        x += 1;
      } else {
        x = -(x + 1);
      }
      return this.slots[x];
    }
    previousEntry(key, tree) {
      let x = this.lookup(key, tree);
      if (x >= 0) {
        x -= 1;
      } else {
        x = -(x + 2);
      }
      return this.slots[x];
    }
    updated(key, newValue, tree) {
      let x = this.lookup(key, tree);
      if (x >= 0) {
        return this.updatedSlot(x, key, newValue);
      } else {
        x = -(x + 1);
        return this.insertedSlot(x, key, newValue);
      }
    }
    updatedSlot(x, key, newValue) {
      const oldSlots = this.slots;
      if (newValue !== oldSlots[x][1]) {
        const newSlots = oldSlots.slice(0);
        newSlots[x] = [ key, newValue ];
        return new BTreeLeaf(newSlots, void 0);
      } else {
        return this;
      }
    }
    insertedSlot(x, key, newValue) {
      const oldSlots = this.slots;
      const n = oldSlots.length + 1;
      const newSlots = new Array(n);
      for (let i = 0; i < x; i += 1) {
        newSlots[i] = oldSlots[i];
      }
      newSlots[x] = [ key, newValue ];
      for (let i = x; i < n - 1; i += 1) {
        newSlots[i + 1] = oldSlots[i];
      }
      return new BTreeLeaf(newSlots, void 0);
    }
    removed(key, tree) {
      const x = this.lookup(key, tree);
      if (x >= 0) {
        if (this.slots.length > 1) {
          return this.removedSlot(x);
        } else {
          return BTreePage.empty();
        }
      } else {
        return this;
      }
    }
    removedSlot(x) {
      const oldSlots = this.slots;
      const newSlots = new Array(oldSlots.length - 1);
      for (let i = 0; i < x; i += 1) {
        newSlots[i] = oldSlots[i];
      }
      for (let i = x; i < newSlots.length; i += 1) {
        newSlots[i] = oldSlots[i + 1];
      }
      return new BTreeLeaf(newSlots, void 0);
    }
    drop(lower, tree) {
      if (lower > 0) {
        const oldSlots = this.slots;
        if (lower < oldSlots.length) {
          const size = oldSlots.length - lower;
          const newSlots = new Array(size);
          for (let i = 0; i < size; i += 1) {
            newSlots[i] = oldSlots[i + lower];
          }
          return new BTreeLeaf(newSlots, void 0);
        } else {
          return BTreePage.empty();
        }
      } else {
        return this;
      }
    }
    take(upper, tree) {
      const oldSlots = this.slots;
      if (upper < oldSlots.length) {
        if (upper > 0) {
          const newSlots = new Array(upper);
          for (let i = 0; i < upper; i += 1) {
            newSlots[i] = oldSlots[i];
          }
          return new BTreeLeaf(newSlots, void 0);
        } else {
          return BTreePage.empty();
        }
      } else {
        return this;
      }
    }
    balanced(tree) {
      const n = this.slots.length;
      if (n > 1 && tree.pageShouldSplit(this)) {
        const x = n >>> 1;
        return this.split(x);
      } else {
        return this;
      }
    }
    split(x) {
      const newPages = new Array(2);
      const newLeftPage = this.splitLeft(x);
      const newRightPage = this.splitRight(x);
      newPages[0] = newLeftPage;
      newPages[1] = newRightPage;
      const newKnots = new Array(1);
      newKnots[0] = newRightPage.minKey();
      return new BTreeNode(newPages, newKnots, void 0, this.slots.length);
    }
    splitLeft(x) {
      const oldSlots = this.slots;
      const newSlots = new Array(x);
      for (let i = 0; i < x; i += 1) {
        newSlots[i] = oldSlots[i];
      }
      return new BTreeLeaf(newSlots, void 0);
    }
    splitRight(x) {
      const oldSlots = this.slots;
      const y = oldSlots.length - x;
      const newSlots = new Array(y);
      for (let i = 0; i < y; i += 1) {
        newSlots[i] = oldSlots[i + x];
      }
      return new BTreeLeaf(newSlots, void 0);
    }
    reduced(identity, accumulator, combiner) {
      if (this.fold === void 0) {
        const slots = this.slots;
        let fold = identity;
        for (let i = 0, n = slots.length; i < n; i += 1) {
          fold = accumulator(fold, slots[i][1]);
        }
        return new BTreeLeaf(slots, fold);
      } else {
        return this;
      }
    }
    forEach(callback, thisArg) {
      const slots = this.slots;
      for (let i = 0, n = slots.length; i < n; i += 1) {
        const slot = slots[i];
        const result = callback.call(thisArg, slot[0], slot[1]);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
    forEachKey(callback, thisArg) {
      const slots = this.slots;
      for (let i = 0, n = slots.length; i < n; i += 1) {
        const slot = slots[i];
        const result = callback.call(thisArg, slot[0]);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
    forEachValue(callback, thisArg) {
      const slots = this.slots;
      for (let i = 0, n = slots.length; i < n; i += 1) {
        const slot = slots[i];
        const result = callback.call(thisArg, slot[1]);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
    entries() {
      return Cursor.array(this.slots);
    }
    reverseEntries() {
      return Cursor.array(this.slots, this.slots.length);
    }
    lookup(key, tree) {
      let lo = 0;
      let hi = this.slots.length - 1;
      while (lo <= hi) {
        const mid = lo + hi >>> 1;
        const order = tree.compare(key, this.slots[mid][0]);
        if (order > 0) {
          lo = mid + 1;
        } else if (order < 0) {
          hi = mid - 1;
        } else {
          return mid;
        }
      }
      return -(lo + 1);
    }
  }
  class BTreeNode extends BTreePage {
    constructor(pages, knots, fold, size) {
      super();
      this.pages = pages;
      this.knots = knots;
      this.fold = fold;
      this.size = size;
    }
    get arity() {
      return this.pages.length;
    }
    isEmpty() {
      return this.size === 0;
    }
    minKey() {
      return this.pages[0].minKey();
    }
    maxKey() {
      return this.pages[this.pages.length - 1].maxKey();
    }
    has(key, tree) {
      let xx = this.lookup(key, tree);
      if (xx > 0) {
        xx += 1;
      } else if (xx < 0) {
        xx = -(xx + 1);
      } else {
        return true;
      }
      return this.pages[xx].has(key, tree);
    }
    get(key, tree) {
      let x = this.lookup(key, tree);
      if (x >= 0) {
        x += 1;
      } else {
        x = -(x + 1);
      }
      return this.pages[x].get(key, tree);
    }
    getEntry(x) {
      const pages = this.pages;
      for (let i = 0, n = pages.length; i < n; i += 1) {
        const page = pages[i];
        if (x < page.size) {
          return page.getEntry(x);
        } else {
          x -= page.size;
        }
      }
      return void 0;
    }
    firstEntry() {
      const pages = this.pages;
      if (pages.length !== 0) {
        return pages[0].firstEntry();
      } else {
        return void 0;
      }
    }
    lastEntry() {
      const pages = this.pages;
      if (pages.length !== 0) {
        return pages[pages.length - 1].lastEntry();
      } else {
        return void 0;
      }
    }
    nextEntry(key, tree) {
      let x = this.lookup(key, tree);
      if (x >= 0) {
        x += 1;
      } else {
        x = -(x + 1);
      }
      const pages = this.pages;
      let entry = pages[x].nextEntry(key, tree);
      if (entry === void 0 && x + 1 < pages.length) {
        entry = pages[x + 1].nextEntry(key, tree);
      }
      return entry;
    }
    previousEntry(key, tree) {
      let x = this.lookup(key, tree);
      if (x >= 0) {
        x += 1;
      } else {
        x = -(x + 1);
      }
      const pages = this.pages;
      let entry = pages[x].previousEntry(key, tree);
      if (entry === void 0 && x > 0) {
        entry = pages[x - 1].previousEntry(key, tree);
      }
      return entry;
    }
    updated(key, newValue, tree) {
      let x = this.lookup(key, tree);
      if (x >= 0) {
        x += 1;
      } else {
        x = -(x + 1);
      }
      const oldPage = this.pages[x];
      const newPage = oldPage.updated(key, newValue, tree);
      if (oldPage !== newPage) {
        if (oldPage.size !== newPage.size && tree.pageShouldSplit(newPage)) {
          return this.updatedPageSplit(x, newPage, oldPage);
        } else {
          return this.updatedPage(x, newPage, oldPage);
        }
      } else {
        return this;
      }
    }
    updatedPage(x, newPage, oldPage) {
      const oldPages = this.pages;
      const newPages = oldPages.slice(0);
      newPages[x] = newPage;
      const oldKnots = this.knots;
      let newKnots;
      if (oldKnots.length > 0) {
        newKnots = oldKnots.slice(0);
        if (x > 0) {
          newKnots[x - 1] = newPage.minKey();
        }
      } else {
        newKnots = [];
      }
      const newSize = this.size - oldPage.size + newPage.size;
      return new BTreeNode(newPages, newKnots, void 0, newSize);
    }
    updatedPageSplit(x, newPage, oldPage) {
      const oldPages = this.pages;
      const newPages = new Array(oldPages.length + 1);
      for (let i = 0; i < x; i += 1) {
        newPages[i] = oldPages[i];
      }
      const newLeftPage = newPage.splitLeft(newPage.arity >>> 1);
      const newRightPage = newPage.splitRight(newPage.arity >>> 1);
      newPages[x] = newLeftPage;
      newPages[x + 1] = newRightPage;
      for (let i = x + 1; i < oldPages.length; i += 1) {
        newPages[i + 1] = oldPages[i];
      }
      const oldKnots = this.knots;
      const newKnots = new Array(oldPages.length);
      if (x > 0) {
        for (let i = 0; i < x - 1; i += 1) {
          newKnots[i] = oldKnots[i];
        }
        newKnots[x - 1] = newLeftPage.minKey();
        newKnots[x] = newRightPage.minKey();
        for (let i = x; i < oldKnots.length; i += 1) {
          newKnots[i + 1] = oldKnots[i];
        }
      } else {
        newKnots[0] = newRightPage.minKey();
        for (let i = 0; i < oldKnots.length; i += 1) {
          newKnots[i + 1] = oldKnots[i];
        }
      }
      const newSize = this.size - oldPage.size + newPage.size;
      return new BTreeNode(newPages, newKnots, void 0, newSize);
    }
    updatedPageMerge(x, newPage, oldPage) {
      const oldPages = this.pages;
      const midPages = newPage.pages;
      const newPages = new Array(oldPages.length + midPages.length - 1);
      for (let i = 0; i < x; i += 1) {
        newPages[i] = oldPages[i];
      }
      for (let i = 0; i < midPages.length; i += 1) {
        newPages[i + x] = midPages[i];
      }
      for (let i = x + 1; i < oldPages.length; i += 1) {
        newPages[i + midPages.length - 1] = oldPages[i];
      }
      const oldKnots = this.knots;
      const midKnots = newPage.knots;
      const newKnots = new Array(newPages.length - 1);
      if (x > 0) {
        for (let i = 0; i < x - 1; i += 1) {
          newKnots[i] = oldKnots[i];
        }
        newKnots[x - 1] = midPages[0].minKey();
        for (let i = 0; i < midKnots.length; i += 1) {
          newKnots[i + x] = midKnots[i];
        }
        for (let i = x; i < oldKnots.length; i += 1) {
          newKnots[i + midKnots.length] = oldKnots[i];
        }
      } else {
        for (let i = 0; i < midKnots.length; i += 1) {
          newKnots[i] = midKnots[i];
        }
        newKnots[midKnots.length] = oldPages[1].minKey();
        for (let i = 1; i < oldKnots.length; i += 1) {
          newKnots[i + midKnots.length] = oldKnots[i];
        }
      }
      const newSize = this.size - oldPage.size + newPage.size;
      return new BTreeNode(newPages, newKnots, void 0, newSize);
    }
    removed(key, tree) {
      let x = this.lookup(key, tree);
      if (x >= 0) {
        x += 1;
      } else {
        x = -(x + 1);
      }
      const oldPage = this.pages[x];
      const newPage = oldPage.removed(key, tree);
      if (oldPage !== newPage) {
        return this.replacedPage(x, newPage, oldPage, tree);
      } else {
        return this;
      }
    }
    replacedPage(x, newPage, oldPage, tree) {
      if (!newPage.isEmpty()) {
        if (newPage instanceof BTreeNode && tree.pageShouldMerge(newPage)) {
          return this.updatedPageMerge(x, newPage, oldPage);
        } else {
          return this.updatedPage(x, newPage, oldPage);
        }
      } else if (this.pages.length > 2) {
        return this.removedPage(x, newPage, oldPage);
      } else if (this.pages.length > 1) {
        if (x === 0) {
          return this.pages[1];
        } else {
          return this.pages[0];
        }
      } else {
        return BTreePage.empty();
      }
    }
    removedPage(x, newPage, oldPage) {
      const oldPages = this.pages;
      const newPages = new Array(oldPages.length - 1);
      for (let i = 0; i < x; i += 1) {
        newPages[i] = oldPages[i];
      }
      for (let i = x + 1; i < oldPages.length; i += 1) {
        newPages[i - 1] = oldPages[i];
      }
      const oldKnots = this.knots;
      const newKnots = new Array(oldKnots.length - 1);
      if (x > 0) {
        for (let i = 0; i < x - 1; i += 1) {
          newKnots[i] = oldKnots[i];
        }
        for (let i = x; i < oldKnots.length; i += 1) {
          newKnots[i - 1] = oldKnots[i];
        }
      } else {
        for (let i = 1; i < oldKnots.length; i += 1) {
          newKnots[i - 1] = oldKnots[i];
        }
      }
      const newSize = this.size - oldPage.size;
      return new BTreeNode(newPages, newKnots, void 0, newSize);
    }
    drop(lower, tree) {
      if (lower > 0) {
        let newSize = this.size;
        if (lower < newSize) {
          const oldPages = this.pages;
          let x = 0;
          while (x < oldPages.length) {
            const size = oldPages[x].size;
            if (size <= lower) {
              newSize -= size;
              lower -= size;
              x += 1;
            } else {
              break;
            }
          }
          const newArity = oldPages.length - x;
          if (newArity > 1) {
            let newNode;
            if (x > 0) {
              const newPages = new Array(newArity);
              for (let i = 0; i < newArity; i += 1) {
                newPages[i] = oldPages[i + x];
              }
              const newKnots = new Array(newArity - 1);
              for (let i = 0; i < newKnots.length; i += 1) {
                newKnots[i] = this.knots[i + x];
              }
              newNode = new BTreeNode(newPages, newKnots, void 0, newSize);
            } else {
              newNode = this;
            }
            if (lower > 0) {
              const oldPage = oldPages[x];
              const newPage = oldPage.drop(lower, tree);
              return newNode.replacedPage(0, newPage, oldPage, tree);
            } else {
              return newNode;
            }
          } else {
            return oldPages[x].drop(lower, tree);
          }
        } else {
          return BTreePage.empty();
        }
      } else {
        return this;
      }
    }
    take(upper, tree) {
      if (upper < this.size) {
        if (upper > 0) {
          const oldPages = this.pages;
          let x = 0;
          let newSize = 0;
          while (x < oldPages.length && upper > 0) {
            const size = oldPages[x].size;
            newSize += size;
            x += 1;
            if (size <= upper) {
              upper -= size;
            } else {
              break;
            }
          }
          const newArity = upper === 0 ? x : x + 1;
          if (newArity > 1) {
            let newNode;
            if (x < oldPages.length) {
              const newPages = new Array(newArity);
              for (let i = 0; i < newArity; i += 1) {
                newPages[i] = oldPages[i];
              }
              const newKnots = new Array(newArity - 1);
              for (let i = 0; i < newKnots.length; i += 1) {
                newKnots[i] = this.knots[i];
              }
              newNode = new BTreeNode(newPages, newKnots, void 0, newSize);
            } else {
              newNode = this;
            }
            if (upper > 0) {
              const oldPage = oldPages[x - 1];
              const newPage = oldPage.take(upper, tree);
              return newNode.replacedPage(x - 1, newPage, oldPage, tree);
            } else {
              return newNode;
            }
          } else if (upper > 0) {
            return oldPages[0].take(upper, tree);
          } else {
            return oldPages[0];
          }
        } else {
          return BTreePage.empty();
        }
      } else {
        return this;
      }
    }
    balanced(tree) {
      if (this.pages.length > 1 && tree.pageShouldSplit(this)) {
        const x = this.knots.length >>> 1;
        return this.split(x);
      } else {
        return this;
      }
    }
    split(x) {
      const newPages = new Array(2);
      const newLeftPage = this.splitLeft(x);
      const newRightPage = this.splitRight(x);
      newPages[0] = newLeftPage;
      newPages[1] = newRightPage;
      const newKnots = new Array(1);
      newKnots[0] = newRightPage.minKey();
      return new BTreeNode(newPages, newKnots, void 0, this.size);
    }
    splitLeft(x) {
      const oldPages = this.pages;
      const newPages = new Array(x + 1);
      for (let i = 0; i < x + 1; i += 1) {
        newPages[i] = oldPages[i];
      }
      const oldKnots = this.knots;
      const newKnots = new Array(x);
      for (let i = 0; i < x; i += 1) {
        newKnots[i] = oldKnots[i];
      }
      let newSize = 0;
      for (let i = 0; i <= x; i += 1) {
        newSize += newPages[i].size;
      }
      return new BTreeNode(newPages, newKnots, void 0, newSize);
    }
    splitRight(x) {
      const oldPages = this.pages;
      const newArity = oldPages.length - (x + 1);
      const newPages = new Array(newArity);
      for (let i = 0; i < newArity; i += 1) {
        newPages[i] = oldPages[i + (x + 1)];
      }
      const oldKnots = this.knots;
      const newKnots = new Array(newArity - 1);
      for (let i = 0; i < newKnots.length; i += 1) {
        newKnots[i] = oldKnots[i + (x + 1)];
      }
      let newSize = 0;
      for (let i = 0; i < newArity; i += 1) {
        newSize += newPages[i].size;
      }
      return new BTreeNode(newPages, newKnots, void 0, newSize);
    }
    reduced(identity, accumulator, combiner) {
      if (this.fold === void 0) {
        const oldPages = this.pages;
        const n = oldPages.length;
        const newPages = new Array(n);
        for (let i = 0; i < n; i += 1) {
          newPages[i] = oldPages[i].reduced(identity, accumulator, combiner);
        }
        let fold = newPages[0].fold;
        for (let i = 1; i < n; i += 1) {
          fold = combiner(fold, newPages[i].fold);
        }
        return new BTreeNode(newPages, this.knots, fold, this.size);
      } else {
        return this;
      }
    }
    forEach(callback, thisArg) {
      const pages = this.pages;
      for (let i = 0, n = pages.length; i < n; i += 1) {
        const result = pages[i].forEach(callback, thisArg);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
    forEachKey(callback, thisArg) {
      const pages = this.pages;
      for (let i = 0, n = pages.length; i < n; i += 1) {
        const result = pages[i].forEachKey(callback, thisArg);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
    forEachValue(callback, thisArg) {
      const pages = this.pages;
      for (let i = 0, n = pages.length; i < n; i += 1) {
        const result = pages[i].forEachValue(callback, thisArg);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
    entries() {
      return new BTreeNodeCursor(this.pages);
    }
    reverseEntries() {
      return new BTreeNodeCursor(this.pages, this.size, this.pages.length);
    }
    lookup(key, tree) {
      let lo = 0;
      let hi = this.knots.length - 1;
      while (lo <= hi) {
        const mid = lo + hi >>> 1;
        const order = tree.compare(key, this.knots[mid]);
        if (order > 0) {
          lo = mid + 1;
        } else if (order < 0) {
          hi = mid - 1;
        } else {
          return mid;
        }
      }
      return -(lo + 1);
    }
  }
  class BTreeNodeCursor extends NodeCursor {
    constructor(pages, index = 0, childIndex = 0, childCursor = null) {
      super(pages, index, childIndex, childCursor);
    }
    pageSize(page) {
      return page.size;
    }
    pageCursor(page) {
      return page.entries();
    }
    reversePageCursor(page) {
      return page.reverseEntries();
    }
  }
  class STreeContext {
    constructor() {
      this.pageSplitSize = 32;
    }
    identify(value) {
      const id = new Uint8Array(6);
      Random.fillBytes(id);
      return id;
    }
    compare(x, y) {
      return Values.compare(x, y);
    }
    pageShouldSplit(page) {
      return page.arity > this.pageSplitSize;
    }
    pageShouldMerge(page) {
      return page.arity < this.pageSplitSize >>> 1;
    }
  }
  class STree extends STreeContext {
    constructor(root) {
      super();
      if (root === void 0) {
        root = STreePage.empty();
      }
      this.root = root;
    }
    get length() {
      return this.root.size;
    }
    isEmpty() {
      return this.root.isEmpty();
    }
    get(index, id) {
      if (id !== void 0) {
        index = this.lookup(id, index);
        if (index < 0) {
          return void 0;
        }
      }
      return this.root.get(index);
    }
    getEntry(index, id) {
      if (id !== void 0) {
        index = this.lookup(id, index);
        if (index < 0) {
          return void 0;
        }
      }
      return this.root.getEntry(index);
    }
    set(index, newValue, id) {
      if (id !== void 0) {
        index = this.lookup(id, index);
        if (index < 0) {
          throw new RangeError("" + id);
        }
      }
      const oldRoot = this.root;
      if (index < 0 || index >= oldRoot.size) {
        throw new RangeError("" + index);
      }
      this.root = oldRoot.updated(index, newValue, this);
      return this;
    }
    insert(index, newValue, id) {
      const oldRoot = this.root;
      if (index < 0 || index > oldRoot.size) {
        throw new RangeError("" + index);
      }
      this.root = oldRoot.inserted(index, newValue, id, this).balanced(this);
      return this;
    }
    remove(index, id) {
      if (id !== void 0) {
        index = this.lookup(id, index);
        if (index < 0) {
          throw new RangeError("" + id);
        }
      }
      const oldRoot = this.root;
      if (index < 0 || index > oldRoot.size) {
        throw new RangeError("" + index);
      }
      this.root = oldRoot.removed(index, this);
      return this;
    }
    push(...newValues) {
      let newRoot = this.root;
      for (let i = 0; i < newValues.length; i += 1) {
        newRoot = newRoot.inserted(newRoot.size, newValues[i], void 0, this).balanced(this);
      }
      this.root = newRoot;
      return newRoot.size;
    }
    pop() {
      const oldRoot = this.root;
      const index = oldRoot.size - 1;
      if (index >= 0) {
        const oldValue = oldRoot.get(index);
        this.root = oldRoot.removed(index, this);
        return oldValue;
      } else {
        return void 0;
      }
    }
    unshift(...newValues) {
      let newRoot = this.root;
      for (let i = newValues.length - 1; i >= 0; i -= 1) {
        newRoot = newRoot.inserted(0, newValues[i], void 0, this).balanced(this);
      }
      this.root = newRoot;
      return newRoot.size;
    }
    shift() {
      const oldRoot = this.root;
      if (oldRoot.size > 0) {
        const oldValue = oldRoot.get(0);
        this.root = oldRoot.removed(0, this);
        return oldValue;
      } else {
        return void 0;
      }
    }
    move(fromIndex, toIndex, id) {
      if (id !== void 0) {
        fromIndex = this.lookup(id, fromIndex);
        if (fromIndex < 0) {
          throw new RangeError("" + id);
        }
      }
      const oldRoot = this.root;
      if (fromIndex < 0 || fromIndex >= oldRoot.size) {
        throw new RangeError("" + fromIndex);
      }
      if (toIndex < 0 || toIndex >= oldRoot.size) {
        throw new RangeError("" + toIndex);
      }
      if (fromIndex !== toIndex) {
        const entry = oldRoot.getEntry(fromIndex);
        this.root = oldRoot.removed(fromIndex, this).inserted(toIndex, entry[1], entry[0], this).balanced(this);
      }
      return this;
    }
    splice(start, deleteCount, ...newValues) {
      let newRoot = this.root;
      if (start < 0) {
        start = newRoot.size + start;
      }
      start = Math.min(Math.max(0, start), newRoot.size);
      if (deleteCount === void 0) {
        deleteCount = newRoot.size - start;
      }
      const deleted = [];
      for (let i = start, n = start + deleteCount; i < n; i += 1) {
        deleted.push(newRoot.get(start));
        newRoot = newRoot.removed(start, this);
      }
      for (let i = 0; i < newValues.length; i += 1) {
        newRoot = newRoot.inserted(start + i, newValues[i], void 0, this).balanced(this);
      }
      this.root = newRoot;
      return deleted;
    }
    drop(lower) {
      const oldRoot = this.root;
      if (lower > 0 && oldRoot.size > 0) {
        if (lower < oldRoot.size) {
          this.root = oldRoot.drop(lower, this);
        } else {
          this.root = STreePage.empty();
        }
      }
      return this;
    }
    take(upper) {
      const oldRoot = this.root;
      if (upper < oldRoot.size && oldRoot.size > 0) {
        if (upper > 0) {
          this.root = oldRoot.take(upper, this);
        } else {
          this.root = STreePage.empty();
        }
      }
      return this;
    }
    clear() {
      this.root = STreePage.empty();
    }
    forEach(callback, thisArg) {
      return this.root.forEach(callback, thisArg, 0);
    }
    keys() {
      return this.root.keys();
    }
    values() {
      return this.root.values();
    }
    entries() {
      return this.root.entries();
    }
    reverseKeys() {
      return this.root.reverseKeys();
    }
    reverseValues() {
      return this.root.reverseValues();
    }
    reverseEntries() {
      return this.root.reverseEntries();
    }
    clone() {
      return this.copy(this.root);
    }
    copy(root) {
      const tree = new STree(root);
      if (tree.identify !== this.identify) {
        tree.identify = this.identify;
      }
      if (tree.compare !== this.compare) {
        tree.compare = this.compare;
      }
      if (tree.pageSplitSize !== this.pageSplitSize) {
        tree.pageSplitSize = this.pageSplitSize;
      }
      return tree;
    }
    lookup(id, start = 0) {
      const root = this.root;
      start = Math.min(Math.max(0, start), root.size - 1);
      let index = start;
      do {
        const entry = root.getEntry(index);
        if (entry !== void 0 && this.compare(entry[0], id) === 0) {
          return index;
        }
        index = (index + 1) % root.size;
      } while (isFinite(index) && index !== start);
      return -1;
    }
  }
  class STreePage {
    keys() {
      return new KeysCursor(this.entries());
    }
    values() {
      return new ValuesCursor(this.entries());
    }
    reverseKeys() {
      return new KeysCursor(this.reverseEntries());
    }
    reverseValues() {
      return new ValuesCursor(this.reverseEntries());
    }
    static empty() {
      return new STreeLeaf([]);
    }
  }
  __decorate([ Lazy ], STreePage, "empty", null);
  class STreeLeaf extends STreePage {
    constructor(slots) {
      super();
      this.slots = slots;
    }
    get arity() {
      return this.slots.length;
    }
    get size() {
      return this.slots.length;
    }
    isEmpty() {
      return this.slots.length === 0;
    }
    get(index) {
      const slot = this.slots[index];
      if (slot !== void 0) {
        return slot[1];
      } else {
        return void 0;
      }
    }
    getEntry(index) {
      return this.slots[index];
    }
    updated(index, newValue, tree) {
      if (index < 0 || index >= this.slots.length) {
        throw new RangeError("" + index);
      }
      return this.updatedItem(index, newValue);
    }
    updatedItem(index, newValue) {
      const oldItems = this.slots;
      const oldSlot = oldItems[index];
      if (oldSlot !== void 0 && newValue !== oldSlot[1]) {
        const newValues = oldItems.slice(0);
        newValues[index] = [ oldSlot[0], newValue ];
        return new STreeLeaf(newValues);
      } else {
        return this;
      }
    }
    inserted(index, newValue, id, tree) {
      if (index < 0 || index > this.slots.length) {
        throw new RangeError("" + index);
      }
      return this.insertedItem(index, newValue, id, tree);
    }
    insertedItem(index, newValue, id, tree) {
      if (id === void 0) {
        id = tree.identify(newValue);
      }
      const oldSlots = this.slots;
      const newSlots = new Array(oldSlots.length + 1);
      for (let i = 0; i < index; i += 1) {
        newSlots[i] = oldSlots[i];
      }
      newSlots[index] = [ id, newValue ];
      for (let i = index; i < oldSlots.length; i += 1) {
        newSlots[i + 1] = oldSlots[i];
      }
      return new STreeLeaf(newSlots);
    }
    removed(index, tree) {
      if (index < 0 || index >= this.slots.length) {
        throw new RangeError("" + index);
      }
      if (this.slots.length > 1) {
        return this.removedSlot(index);
      } else {
        return STreePage.empty();
      }
    }
    removedSlot(index) {
      const oldSlots = this.slots;
      const newSlots = new Array(oldSlots.length - 1);
      for (let i = 0; i < index; i += 1) {
        newSlots[i] = oldSlots[i];
      }
      for (let i = index; i < newSlots.length; i += 1) {
        newSlots[i] = oldSlots[i + 1];
      }
      return new STreeLeaf(newSlots);
    }
    drop(lower, tree) {
      const oldSlots = this.slots;
      if (lower > 0 && oldSlots.length > 0) {
        if (lower < oldSlots.length) {
          const size = oldSlots.length - lower;
          const newSlots = new Array(size);
          for (let i = 0; i < size; i += 1) {
            newSlots[i] = oldSlots[i + lower];
          }
          return new STreeLeaf(newSlots);
        } else {
          return STreePage.empty();
        }
      } else {
        return this;
      }
    }
    take(upper, tree) {
      const oldSlots = this.slots;
      if (upper < oldSlots.length && oldSlots.length > 0) {
        if (upper > 0) {
          const newSlots = new Array(upper);
          for (let i = 0; i < upper; i += 1) {
            newSlots[i] = oldSlots[i];
          }
          return new STreeLeaf(newSlots);
        } else {
          return STreePage.empty();
        }
      } else {
        return this;
      }
    }
    balanced(tree) {
      const size = this.slots.length;
      if (size > 1 && tree.pageShouldSplit(this)) {
        return this.split(size >>> 1);
      } else {
        return this;
      }
    }
    split(index) {
      const newPages = new Array(2);
      const newLeftPage = this.splitLeft(index);
      const newRightPage = this.splitRight(index);
      newPages[0] = newLeftPage;
      newPages[1] = newRightPage;
      const newKnots = new Array(1);
      newKnots[0] = index;
      return new STreeNode(newPages, newKnots, this.slots.length);
    }
    splitLeft(index) {
      const oldSlots = this.slots;
      const newSlots = new Array(index);
      for (let i = 0; i < index; i += 1) {
        newSlots[i] = oldSlots[i];
      }
      return new STreeLeaf(newSlots);
    }
    splitRight(index) {
      const oldSlots = this.slots;
      const newSize = oldSlots.length - index;
      const newSlots = new Array(newSize);
      for (let i = 0; i < newSize; i += 1) {
        newSlots[i] = oldSlots[i + index];
      }
      return new STreeLeaf(newSlots);
    }
    forEach(callback, thisArg, offset) {
      for (let i = 0; i < this.slots.length; i += 1) {
        const slot = this.slots[i];
        const result = callback.call(thisArg, slot[1], offset + i, slot[0]);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
    entries() {
      return Cursor.array(this.slots);
    }
    reverseEntries() {
      return Cursor.array(this.slots, this.slots.length);
    }
  }
  class STreeNode extends STreePage {
    constructor(pages, knots, size) {
      super();
      this.pages = pages;
      this.knots = knots;
      this.size = size;
    }
    get arity() {
      return this.pages.length;
    }
    isEmpty() {
      return this.size === 0;
    }
    get(index) {
      let x = this.lookup(index);
      if (x >= 0) {
        x += 1;
      } else {
        x = -(x + 1);
      }
      const i = x === 0 ? index : index - this.knots[x - 1];
      return this.pages[x].get(i);
    }
    getEntry(index) {
      let x = this.lookup(index);
      if (x >= 0) {
        x += 1;
      } else {
        x = -(x + 1);
      }
      const i = x === 0 ? index : index - this.knots[x - 1];
      return this.pages[x].getEntry(i);
    }
    updated(index, newValue, tree) {
      let x = this.lookup(index);
      if (x >= 0) {
        x += 1;
      } else {
        x = -(x + 1);
      }
      const i = x === 0 ? index : index - this.knots[x - 1];
      const oldPage = this.pages[x];
      const newPage = oldPage.updated(i, newValue, tree);
      if (oldPage !== newPage) {
        if (oldPage.size !== newPage.size && tree.pageShouldSplit(newPage)) {
          return this.updatedPageSplit(x, newPage, oldPage);
        } else {
          return this.updatedPage(x, newPage, oldPage);
        }
      } else {
        return this;
      }
    }
    updatedPage(x, newPage, oldPage) {
      const oldPages = this.pages;
      const newPages = oldPages.slice(0);
      newPages[x] = newPage;
      const oldKnots = this.knots;
      let newKnots;
      let newSize;
      if (oldPages.length - 1 > 0) {
        newKnots = oldKnots.slice(0);
        if (x > 0) {
          newSize = oldKnots[x - 1];
        } else {
          newSize = 0;
        }
        for (let i = x; i < newKnots.length; i += 1) {
          newSize += newPages[i].size;
          newKnots[i] = newSize;
        }
        newSize += newPages[newKnots.length].size;
      } else {
        newKnots = [];
        newSize = 0;
      }
      return new STreeNode(newPages, newKnots, newSize);
    }
    updatedPageSplit(x, newPage, oldPage) {
      const oldPages = this.pages;
      const newPages = new Array(oldPages.length + 1);
      for (let i = 0; i < x; i += 1) {
        newPages[i] = oldPages[i];
      }
      const newLeftPage = newPage.splitLeft(newPage.arity >>> 1);
      const newRightPage = newPage.splitRight(newPage.arity >>> 1);
      newPages[x] = newLeftPage;
      newPages[x + 1] = newRightPage;
      for (let i = x + 1; i < oldPages.length; i += 1) {
        newPages[i + 1] = oldPages[i];
      }
      return STreeNode.create(newPages);
    }
    updatedPageMerge(x, newPage, oldPage) {
      const oldPages = this.pages;
      const midPages = newPage.pages;
      const newPages = new Array(oldPages.length + midPages.length - 1);
      for (let i = 0; i < x; i += 1) {
        newPages[i] = oldPages[i];
      }
      for (let i = 0; i < midPages.length; i += 1) {
        newPages[i + x] = midPages[i];
      }
      for (let i = x + 1; i < oldPages.length; i += 1) {
        newPages[i + midPages.length - 1] = oldPages[i];
      }
      return STreeNode.create(newPages);
    }
    inserted(index, newValue, id, tree) {
      let x = this.lookup(index);
      if (x >= 0) {
        x += 1;
      } else {
        x = -(x + 1);
      }
      const subIndex = x === 0 ? index : index - this.knots[x - 1];
      const oldPage = this.pages[x];
      const newPage = oldPage.inserted(subIndex, newValue, id, tree);
      if (oldPage !== newPage) {
        if (tree.pageShouldSplit(newPage)) {
          return this.updatedPageSplit(x, newPage, oldPage);
        } else {
          return this.updatedPage(x, newPage, oldPage);
        }
      } else {
        return this;
      }
    }
    removed(index, tree) {
      let x = this.lookup(index);
      if (x >= 0) {
        x += 1;
      } else {
        x = -(x + 1);
      }
      const subIndex = x === 0 ? index : index - this.knots[x - 1];
      const oldPage = this.pages[x];
      const newPage = oldPage.removed(subIndex, tree);
      if (oldPage !== newPage) {
        return this.replacedPage(x, newPage, oldPage, tree);
      } else {
        return this;
      }
    }
    replacedPage(x, newPage, oldPage, tree) {
      if (!newPage.isEmpty()) {
        if (newPage instanceof STreeNode && tree.pageShouldMerge(newPage)) {
          return this.updatedPageMerge(x, newPage, oldPage);
        } else {
          return this.updatedPage(x, newPage, oldPage);
        }
      } else if (this.pages.length > 2) {
        return this.removedPage(x, newPage, oldPage);
      } else if (this.pages.length > 1) {
        if (x === 0) {
          return this.pages[1];
        } else {
          return this.pages[0];
        }
      } else {
        return STreePage.empty();
      }
    }
    removedPage(x, newPage, oldPage) {
      const oldPages = this.pages;
      const newPages = new Array(oldPages.length - 1);
      for (let i = 0; i < x; i += 1) {
        newPages[i] = oldPages[i];
      }
      for (let i = x + 1; i < oldPages.length; i += 1) {
        newPages[i - 1] = oldPages[i];
      }
      const oldKnots = this.knots;
      const newKnots = new Array(oldKnots.length - 1);
      let newSize;
      if (x > 0) {
        for (let i = 0; i < x; i += 1) {
          newKnots[i] = oldKnots[i];
        }
        newSize = oldKnots[x - 1];
      } else {
        newSize = 0;
      }
      for (let i = x; i < newKnots.length; i += 1) {
        newSize += newPages[i].size;
        newKnots[i] = newSize;
      }
      newSize += newPages[newKnots.length].size;
      return new STreeNode(newPages, newKnots, newSize);
    }
    drop(lower, tree) {
      if (lower > 0) {
        if (lower < this.size) {
          let x = this.lookup(lower);
          if (x >= 0) {
            x += 1;
          } else {
            x = -(x + 1);
          }
          lower = x === 0 ? lower : lower - this.knots[x - 1];
          const oldPages = this.pages;
          const n = oldPages.length - x;
          if (n > 1) {
            let newNode;
            if (x > 0) {
              const newPages = new Array(n);
              for (let i = 0; i < n; i += 1) {
                newPages[i] = oldPages[i + x];
              }
              newNode = STreeNode.create(newPages);
            } else {
              newNode = this;
            }
            if (lower > 0) {
              const oldPage = oldPages[x];
              const newPage = oldPage.drop(lower, tree);
              return newNode.replacedPage(0, newPage, oldPage, tree);
            } else {
              return newNode;
            }
          } else {
            return oldPages[x].drop(lower, tree);
          }
        } else {
          return STreePage.empty();
        }
      } else {
        return this;
      }
    }
    take(upper, tree) {
      if (upper < this.size) {
        if (upper > 0) {
          let x = this.lookup(upper);
          if (x >= 0) {
            x += 1;
          } else {
            x = -(x + 1);
          }
          upper = x === 0 ? upper : upper - this.knots[x - 1];
          const oldPages = this.pages;
          const n = upper === 0 ? x : x + 1;
          if (n > 1) {
            let newNode;
            if (x < oldPages.length) {
              const newPages = new Array(n);
              for (let i = 0; i < n; i += 1) {
                newPages[i] = oldPages[i];
              }
              const newKnots = new Array(n - 1);
              for (let i = 0; i < newKnots.length; i += 1) {
                newKnots[i] = this.knots[i];
              }
              const newSize = newKnots[n - 2] + newPages[n - 1].size;
              newNode = new STreeNode(newPages, newKnots, newSize);
            } else {
              newNode = this;
            }
            if (upper > 0) {
              const oldPage = oldPages[x];
              const newPage = oldPage.take(upper, tree);
              return newNode.replacedPage(x, newPage, oldPage, tree);
            } else {
              return newNode;
            }
          } else if (upper > 0) {
            return oldPages[0].take(upper, tree);
          } else {
            return oldPages[0];
          }
        } else {
          return STreePage.empty();
        }
      } else {
        return this;
      }
    }
    balanced(tree) {
      if (this.pages.length > 1 && tree.pageShouldSplit(this)) {
        const x = this.knots.length >>> 1;
        return this.split(x);
      } else {
        return this;
      }
    }
    split(x) {
      const newPages = new Array(2);
      const newLeftPage = this.splitLeft(x);
      const newRightPage = this.splitRight(x);
      newPages[0] = newLeftPage;
      newPages[1] = newRightPage;
      const newKnots = new Array(1);
      newKnots[0] = newLeftPage.size;
      return new STreeNode(newPages, newKnots, this.size);
    }
    splitLeft(x) {
      const oldPages = this.pages;
      const newPages = new Array(x + 1);
      for (let i = 0; i < x + 1; i += 1) {
        newPages[i] = oldPages[i];
      }
      const oldKnots = this.knots;
      const newKnots = new Array(x);
      for (let i = 0; i < x; i += 1) {
        newKnots[i] = oldKnots[i];
      }
      let newSize = 0;
      for (let i = 0; i <= x; i += 1) {
        newSize += newPages[i].size;
      }
      return new STreeNode(newPages, newKnots, newSize);
    }
    splitRight(x) {
      const oldPages = this.pages;
      const y = oldPages.length - (x + 1);
      const newPages = new Array(y);
      for (let i = 0; i < y; i += 1) {
        newPages[i] = oldPages[i + (x + 1)];
      }
      const newKnots = new Array(y - 1);
      let newSize;
      if (y > 0) {
        newSize = newPages[0].size;
        for (let i = 1; i < y; i += 1) {
          newKnots[i - 1] = newSize;
          newSize += newPages[i].size;
        }
      } else {
        newSize = 0;
      }
      return new STreeNode(newPages, newKnots, newSize);
    }
    forEach(callback, thisArg, offset) {
      for (let i = 0; i < this.pages.length; i += 1) {
        const page = this.pages[i];
        const result = page.forEach(callback, thisArg, offset);
        if (result !== void 0) {
          return result;
        }
        offset += page.size;
      }
      return void 0;
    }
    entries() {
      return new STreeNodeCursor(this.pages);
    }
    reverseEntries() {
      return new STreeNodeCursor(this.pages, this.size, this.pages.length);
    }
    lookup(index) {
      let lo = 0;
      let hi = this.knots.length - 1;
      while (lo <= hi) {
        const mid = lo + hi >>> 1;
        if (index > this.knots[mid]) {
          lo = mid + 1;
        } else if (index < this.knots[mid]) {
          hi = mid - 1;
        } else {
          return mid;
        }
      }
      return -(lo + 1);
    }
    static create(pages) {
      const knots = new Array(pages.length - 1);
      let size = 0;
      for (let i = 0, n = knots.length; i < n; i += 1) {
        size += pages[i].size;
        knots[i] = size;
      }
      size += pages[knots.length].size;
      return new STreeNode(pages, knots, size);
    }
  }
  class STreeNodeCursor extends NodeCursor {
    constructor(pages, index = 0, childIndex = 0, childCursor = null) {
      super(pages, index, childIndex, childCursor);
    }
    pageSize(page) {
      return page.size;
    }
    pageCursor(page) {
      return page.entries();
    }
    reversePageCursor(page) {
      return page.reverseEntries();
    }
  }
  const ConstraintId = function() {
    const ConstraintId = {};
    let nextId = 1;
    ConstraintId.next = function() {
      const id = ~~nextId;
      nextId += 1;
      return id;
    };
    return ConstraintId;
  }();
  class ConstraintMap {
    constructor(index, array) {
      this.index = index !== void 0 ? index : {};
      this.array = array !== void 0 ? array : [];
    }
    get size() {
      return this.array.length;
    }
    isEmpty() {
      return this.array.length === 0;
    }
    has(key) {
      return this.index[key.id] !== void 0;
    }
    get(key) {
      const k = this.index[key.id];
      return k !== void 0 ? this.array[k][1] : void 0;
    }
    getField(key) {
      const k = this.index[key.id];
      return k !== void 0 ? this.array[k] : void 0;
    }
    getEntry(k) {
      return this.array[k];
    }
    set(key, newValue) {
      const k = this.index[key.id];
      if (k !== void 0) {
        const entry = this.array[k];
        const oldValue = entry[1];
        entry[1] = newValue;
        return oldValue;
      } else {
        this.index[key.id] = this.array.length;
        this.array.push([ key, newValue ]);
        return void 0;
      }
    }
    delete(key) {
      const k = this.index[key.id];
      if (k !== void 0) {
        delete this.index[key.id];
        const item = this.array[k];
        const last = this.array.pop();
        if (item !== last) {
          this.array[k] = last;
          this.index[last[0].id] = k;
        }
        return true;
      } else {
        return false;
      }
    }
    remove(key) {
      const k = this.index[key.id];
      if (k !== void 0) {
        delete this.index[key.id];
        const item = this.array[k];
        const last = this.array.pop();
        if (item !== last) {
          this.array[k] = last;
          this.index[last[0].id] = k;
        }
        return item[1];
      } else {
        return void 0;
      }
    }
    clear() {
      this.index = {};
      this.array.length = 0;
    }
    forEach(callback, thisArg) {
      const array = this.array;
      for (let i = 0, n = array.length; i < n; i += 1) {
        const item = array[i];
        const result = callback.call(thisArg, item[0], item[1]);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
    clone() {
      const oldArray = this.array;
      const n = oldArray.length;
      const newIndex = {};
      const newArray = new Array(n);
      for (let i = 0; i < n; i += 1) {
        const [key, value] = oldArray[i];
        newArray[i] = [ key, value ];
        newIndex[key.id] = i;
      }
      return new ConstraintMap(newIndex, newArray);
    }
  }
  const ConstraintSymbol = {};
  class ConstraintSlack {
    constructor() {
      this.id = ConstraintId.next();
    }
    isExternal() {
      return false;
    }
    isDummy() {
      return false;
    }
    isInvalid() {
      return false;
    }
    addConstraintCondition(constraint, solver) {}
    removeConstraintCondition(constraint, solver) {}
    updateConstraintSolution(value) {}
  }
  class ConstraintDummy {
    constructor() {
      this.id = ConstraintId.next();
    }
    isExternal() {
      return false;
    }
    isDummy() {
      return true;
    }
    isInvalid() {
      return false;
    }
    addConstraintCondition(constraint, solver) {}
    removeConstraintCondition(constraint, solver) {}
    updateConstraintSolution(value) {}
  }
  class ConstraintError {
    constructor() {
      this.id = ConstraintId.next();
    }
    isExternal() {
      return false;
    }
    isDummy() {
      return false;
    }
    isInvalid() {
      return false;
    }
    addConstraintCondition(constraint, solver) {}
    removeConstraintCondition(constraint, solver) {}
    updateConstraintSolution(value) {}
  }
  class ConstraintInvalid {
    get id() {
      return -1;
    }
    isExternal() {
      return false;
    }
    isDummy() {
      return false;
    }
    isInvalid() {
      return true;
    }
    addConstraintCondition(constraint, solver) {}
    removeConstraintCondition(constraint, solver) {}
    updateConstraintSolution(value) {}
  }
  ConstraintSymbol.invalid = new ConstraintInvalid;
  const ConstraintExpression = function() {
    const ConstraintExpression = {};
    ConstraintExpression.fromAny = function(value) {
      if (typeof value === "number") {
        return ConstraintExpression.constant(value);
      } else {
        return value;
      }
    };
    ConstraintExpression.sum = function(...expressions) {
      const terms = new ConstraintMap;
      let constant = 0;
      for (let i = 0, n = expressions.length; i < n; i += 1) {
        const expression = expressions[i];
        if (typeof expression === "number") {
          constant += expression;
        } else if (ConstraintTerm.is(expression)) {
          const variable = expression.variable;
          if (variable !== null) {
            const field = terms.getField(variable);
            if (field !== void 0) {
              field[1] += expression.coefficient;
            } else {
              terms.set(variable, expression.coefficient);
            }
          } else {
            constant += expression.constant;
          }
        } else {
          const subterms = expression.terms;
          for (let j = 0, k = subterms.size; j < k; j += 1) {
            const [variable, coefficient] = subterms.getEntry(j);
            const field = terms.getField(variable);
            if (field !== void 0) {
              field[1] += coefficient;
            } else {
              terms.set(variable, coefficient);
            }
          }
          constant += expression.constant;
        }
      }
      return new ConstraintSum(terms, constant);
    };
    ConstraintExpression.product = function(coefficient, variable) {
      return new ConstraintProduct(coefficient, variable);
    };
    ConstraintExpression.constant = function(value) {
      if (value === 0) {
        return ConstraintExpression.zero;
      } else {
        return new ConstraintConstant(value);
      }
    };
    return ConstraintExpression;
  }();
  class ConstraintSum {
    constructor(terms, constant) {
      this.terms = terms;
      this.constant = constant;
    }
    isConstant() {
      return this.terms.isEmpty();
    }
    plus(that) {
      return ConstraintExpression.sum(this, that);
    }
    negative() {
      const oldTerms = this.terms;
      const newTerms = new ConstraintMap;
      for (let i = 0, n = oldTerms.size; i < n; i += 1) {
        const [variable, coefficient] = oldTerms.getEntry(i);
        newTerms.set(variable, -coefficient);
      }
      return new ConstraintSum(newTerms, -this.constant);
    }
    minus(that) {
      if (typeof that === "number") {
        that = ConstraintExpression.constant(that);
      } else {
        that = that.negative();
      }
      return ConstraintExpression.sum(this, that);
    }
    times(scalar) {
      const oldTerms = this.terms;
      const newTerms = new ConstraintMap;
      for (let i = 0, n = oldTerms.size; i < n; i += 1) {
        const [variable, coefficient] = oldTerms.getEntry(i);
        newTerms.set(variable, coefficient * scalar);
      }
      return new ConstraintSum(newTerms, this.constant * scalar);
    }
    divide(scalar) {
      const oldTerms = this.terms;
      const newTerms = new ConstraintMap;
      for (let i = 0, n = oldTerms.size; i < n; i += 1) {
        const [variable, coefficient] = oldTerms.getEntry(i);
        newTerms.set(variable, coefficient / scalar);
      }
      return new ConstraintSum(newTerms, this.constant / scalar);
    }
    debug(output) {
      output = output.write("ConstraintExpression").write(46).write("sum").write(40);
      const n = this.terms.size;
      for (let i = 0; i < n; i += 1) {
        const [variable, coefficient] = this.terms.getEntry(i);
        if (i > 0) {
          output = output.write(", ");
        }
        if (coefficient === 1) {
          output = output.debug(variable);
        } else {
          output = output.debug(ConstraintExpression.product(coefficient, variable));
        }
      }
      if (this.constant !== 0) {
        if (n > 0) {
          output = output.write(", ");
        }
        output = output.debug(this.constant);
      }
      output = output.write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
  }
  const ConstraintTerm = function() {
    const ConstraintTerm = {};
    ConstraintTerm.is = function(value) {
      if (typeof value === "object" && value !== null || typeof value === "function") {
        const term = value;
        return "coefficient" in term && "variable" in term;
      }
      return false;
    };
    return ConstraintTerm;
  }();
  class ConstraintProduct {
    constructor(coefficient, variable) {
      this.coefficient = coefficient;
      this.variable = variable;
    }
    isConstant() {
      return false;
    }
    get terms() {
      const terms = new ConstraintMap;
      terms.set(this.variable, this.coefficient);
      return terms;
    }
    get constant() {
      return 0;
    }
    plus(that) {
      that = ConstraintExpression.fromAny(that);
      if (that instanceof ConstraintProduct && this.variable === that.variable) {
        return ConstraintExpression.product(this.coefficient + that.coefficient, this.variable);
      } else if (this.variable === that) {
        return ConstraintExpression.product(this.coefficient + 1, this.variable);
      } else {
        return ConstraintExpression.sum(this, that);
      }
    }
    negative() {
      return ConstraintExpression.product(-this.coefficient, this.variable);
    }
    minus(that) {
      that = ConstraintExpression.fromAny(that);
      if (that instanceof ConstraintProduct && this.variable === that.variable) {
        return ConstraintExpression.product(this.coefficient - that.coefficient, this.variable);
      } else if (this.variable === that) {
        return ConstraintExpression.product(this.coefficient - 1, this.variable);
      } else {
        return ConstraintExpression.sum(this, that.negative());
      }
    }
    times(scalar) {
      return ConstraintExpression.product(this.coefficient * scalar, this.variable);
    }
    divide(scalar) {
      return ConstraintExpression.product(this.coefficient / scalar, this.variable);
    }
    debug(output) {
      output = output.write("ConstraintExpression").write(46).write("product").write(40).debug(this.coefficient).write(", ").debug(this.variable).write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
  }
  class ConstraintConstant {
    constructor(constant) {
      this.constant = constant;
    }
    isConstant() {
      return true;
    }
    get coefficient() {
      return 0;
    }
    get variable() {
      return null;
    }
    get terms() {
      return new ConstraintMap;
    }
    plus(that) {
      that = ConstraintExpression.fromAny(that);
      if (that instanceof ConstraintConstant) {
        return ConstraintExpression.constant(this.constant + that.constant);
      } else {
        return ConstraintExpression.sum(this, that);
      }
    }
    negative() {
      return ConstraintExpression.constant(-this.constant);
    }
    minus(that) {
      that = ConstraintExpression.fromAny(that);
      if (that instanceof ConstraintConstant) {
        return ConstraintExpression.constant(this.constant - that.constant);
      } else {
        return ConstraintExpression.sum(this, that.negative());
      }
    }
    times(scalar) {
      return ConstraintExpression.constant(this.constant * scalar);
    }
    divide(scalar) {
      return ConstraintExpression.constant(this.constant / scalar);
    }
    debug(output) {
      output = output.write("ConstraintExpression").write(46);
      if (this.constant === 0) {
        output = output.write("zero");
      } else {
        output = output.write("constant").write(40).debug(this.constant).write(41);
      }
      return output;
    }
    toString() {
      return Format.debug(this);
    }
  }
  ConstraintExpression.zero = new ConstraintConstant(0);
  const ConstraintProperty = function(_super) {
    const ConstraintProperty = _super.extend("ConstraintProperty");
    ConstraintProperty.prototype.isExternal = function() {
      return true;
    };
    ConstraintProperty.prototype.isDummy = function() {
      return false;
    };
    ConstraintProperty.prototype.isInvalid = function() {
      return false;
    };
    ConstraintProperty.prototype.isConstant = function() {
      return false;
    };
    ConstraintProperty.prototype.evaluateConstraintVariable = function() {};
    ConstraintProperty.prototype.updateConstraintSolution = function(value) {
      if (this.constrained && this.toNumber(this.value) !== value) {
        this.setValue(value, Affinity.Reflexive);
      }
    };
    ConstraintProperty.prototype.setStrength = function(strength) {
      this.strength = ConstraintStrength.fromAny(strength);
    };
    Object.defineProperty(ConstraintProperty.prototype, "coefficient", {
      get() {
        return 1;
      },
      configurable: true
    });
    Object.defineProperty(ConstraintProperty.prototype, "variable", {
      get() {
        return this;
      },
      configurable: true
    });
    Object.defineProperty(ConstraintProperty.prototype, "terms", {
      get() {
        const terms = new ConstraintMap;
        terms.set(this, 1);
        return terms;
      },
      configurable: true
    });
    Object.defineProperty(ConstraintProperty.prototype, "constant", {
      get() {
        return 0;
      },
      configurable: true
    });
    ConstraintProperty.prototype.plus = function(that) {
      that = ConstraintExpression.fromAny(that);
      if (this === that) {
        return ConstraintExpression.product(2, this);
      } else {
        return ConstraintExpression.sum(this, that);
      }
    };
    ConstraintProperty.prototype.negative = function() {
      return ConstraintExpression.product(-1, this);
    };
    ConstraintProperty.prototype.minus = function(that) {
      that = ConstraintExpression.fromAny(that);
      if (this === that) {
        return ConstraintExpression.zero;
      } else {
        return ConstraintExpression.sum(this, that.negative());
      }
    };
    ConstraintProperty.prototype.times = function(scalar) {
      return ConstraintExpression.product(scalar, this);
    };
    ConstraintProperty.prototype.divide = function(scalar) {
      return ConstraintExpression.product(1 / scalar, this);
    };
    Object.defineProperty(ConstraintProperty.prototype, "constrained", {
      get() {
        return (this.flags & ConstraintProperty.ConstrainedFlag) !== 0;
      },
      configurable: true
    });
    ConstraintProperty.prototype.constrain = function(constrained) {
      if (constrained === void 0) {
        constrained = true;
      }
      const flags = this.flags;
      if (constrained && (flags & ConstraintProperty.ConstrainedFlag) === 0) {
        this.setFlags(flags | ConstraintProperty.ConstrainedFlag);
        if (this.conditionCount !== 0 && this.mounted) {
          this.stopConstraining();
        }
      } else if (!constrained && (flags & ConstraintProperty.ConstrainedFlag) !== 0) {
        this.setFlags(flags & ~ConstraintProperty.ConstrainedFlag);
        if (this.conditionCount !== 0 && this.mounted) {
          this.startConstraining();
          this.updateConstraintVariable();
        }
      }
      return this;
    };
    ConstraintProperty.prototype.addConstraintCondition = function(constraint, solver) {
      this.conditionCount += 1;
      if (!this.constrained && this.conditionCount === 1 && this.mounted) {
        this.startConstraining();
        this.updateConstraintVariable();
      }
    };
    ConstraintProperty.prototype.removeConstraintCondition = function(constraint, solver) {
      this.conditionCount -= 1;
      if (!this.constrained && this.conditionCount === 0 && this.mounted) {
        this.stopConstraining();
      }
    };
    Object.defineProperty(ConstraintProperty.prototype, "constraining", {
      get() {
        return (this.flags & ConstraintProperty.ConstrainingFlag) !== 0;
      },
      configurable: true
    });
    ConstraintProperty.prototype.startConstraining = function() {
      if ((this.flags & ConstraintProperty.ConstrainingFlag) === 0) {
        this.willStartConstraining();
        this.setFlags(this.flags | ConstraintProperty.ConstrainingFlag);
        this.onStartConstraining();
        this.didStartConstraining();
      }
    };
    ConstraintProperty.prototype.willStartConstraining = function() {};
    ConstraintProperty.prototype.onStartConstraining = function() {
      const constraintScope = this.owner;
      if (ConstraintScope.is(constraintScope)) {
        constraintScope.addConstraintVariable(this);
      }
    };
    ConstraintProperty.prototype.didStartConstraining = function() {};
    ConstraintProperty.prototype.stopConstraining = function() {
      if ((this.flags & ConstraintProperty.ConstrainingFlag) !== 0) {
        this.willStopConstraining();
        this.setFlags(this.flags & ~ConstraintProperty.ConstrainingFlag);
        this.onStopConstraining();
        this.didStopConstraining();
      }
    };
    ConstraintProperty.prototype.willStopConstraining = function() {};
    ConstraintProperty.prototype.onStopConstraining = function() {
      const constraintScope = this.owner;
      if (ConstraintScope.is(constraintScope)) {
        constraintScope.removeConstraintVariable(this);
      }
    };
    ConstraintProperty.prototype.didStopConstraining = function() {};
    ConstraintProperty.prototype.updateConstraintVariable = function() {
      const constraintScope = this.owner;
      const value = this.value;
      if (value !== void 0 && ConstraintScope.is(constraintScope)) {
        constraintScope.setConstraintVariable(this, this.toNumber(value));
      }
    };
    ConstraintProperty.prototype.onSetValue = function(newValue, oldValue) {
      _super.prototype.onSetValue.call(this, newValue, oldValue);
      const constraintScope = this.owner;
      if (this.constraining && ConstraintScope.is(constraintScope)) {
        constraintScope.setConstraintVariable(this, newValue !== void 0 && newValue !== null ? this.toNumber(newValue) : 0);
      }
    };
    ConstraintProperty.prototype.onMount = function() {
      _super.prototype.onMount.call(this);
      if (!this.constrained && this.conditionCount !== 0) {
        this.startConstraining();
      }
    };
    ConstraintProperty.prototype.onUnmount = function() {
      if (!this.constrained && this.conditionCount !== 0) {
        this.stopConstraining();
      }
      _super.prototype.onUnmount.call(this);
    };
    ConstraintProperty.prototype.fromAny = function(value) {
      if (typeof value === "string") {
        const number = +value;
        if (isFinite(number)) {
          return number;
        }
      }
      return value;
    };
    ConstraintProperty.prototype.toNumber = function(value) {
      return value !== void 0 && value !== null ? +value : 0;
    };
    ConstraintProperty.construct = function(propertyClass, property, owner) {
      property = _super.construct(propertyClass, property, owner);
      property.id = ConstraintId.next();
      property.strength = ConstraintStrength.Strong;
      property.conditionCount = 0;
      return property;
    };
    ConstraintProperty.specialize = function(type) {
      return null;
    };
    ConstraintProperty.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const strength = descriptor.strength !== void 0 ? ConstraintStrength.fromAny(descriptor.strength) : void 0;
      const constrain = descriptor.constrain;
      const value = descriptor.value;
      const initValue = descriptor.initValue;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.strength;
      delete descriptor.constrain;
      delete descriptor.value;
      delete descriptor.initValue;
      if (superClass === void 0 || superClass === null) {
        superClass = this.specialize(descriptor.type);
      }
      if (superClass === null) {
        superClass = this;
        if (descriptor.fromAny === void 0 && FromAny.is(descriptor.type)) {
          descriptor.fromAny = descriptor.type.fromAny;
        }
      }
      const propertyClass = superClass.extend(className, descriptor);
      propertyClass.construct = function(propertyClass, property, owner) {
        property = superClass.construct(propertyClass, property, owner);
        if (affinity !== void 0) {
          property.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          property.initInherits(inherits);
        }
        if (strength !== void 0) {
          property.strength = strength;
        }
        if (initValue !== void 0) {
          property.value = property.fromAny(initValue());
        } else if (value !== void 0) {
          property.value = property.fromAny(value);
        }
        if (constrain === true) {
          property.constrain();
        }
        return property;
      };
      return propertyClass;
    };
    ConstraintProperty.ConstrainedFlag = 1 << _super.FlagShift + 0;
    ConstraintProperty.ConstrainingFlag = 1 << _super.FlagShift + 1;
    ConstraintProperty.FlagShift = _super.FlagShift + 2;
    ConstraintProperty.FlagMask = (1 << ConstraintProperty.FlagShift) - 1;
    return ConstraintProperty;
  }(Property);
  const ConstraintAnimator = function(_super) {
    const ConstraintAnimator = _super.extend("ConstraintAnimator");
    ConstraintAnimator.prototype.isExternal = function() {
      return true;
    };
    ConstraintAnimator.prototype.isDummy = function() {
      return false;
    };
    ConstraintAnimator.prototype.isInvalid = function() {
      return false;
    };
    ConstraintAnimator.prototype.isConstant = function() {
      return false;
    };
    ConstraintAnimator.prototype.evaluateConstraintVariable = function() {};
    ConstraintAnimator.prototype.updateConstraintSolution = function(state) {
      if (this.constrained && this.toNumber(this.state) !== state) {
        this.setState(state, Affinity.Reflexive);
      }
    };
    ConstraintAnimator.prototype.setStrength = function(strength) {
      this.strength = ConstraintStrength.fromAny(strength);
    };
    Object.defineProperty(ConstraintAnimator.prototype, "coefficient", {
      get() {
        return 1;
      },
      configurable: true
    });
    Object.defineProperty(ConstraintAnimator.prototype, "variable", {
      get() {
        return this;
      },
      configurable: true
    });
    Object.defineProperty(ConstraintAnimator.prototype, "terms", {
      get() {
        const terms = new ConstraintMap;
        terms.set(this, 1);
        return terms;
      },
      configurable: true
    });
    Object.defineProperty(ConstraintAnimator.prototype, "constant", {
      get() {
        return 0;
      },
      configurable: true
    });
    ConstraintAnimator.prototype.plus = function(that) {
      that = ConstraintExpression.fromAny(that);
      if (this === that) {
        return ConstraintExpression.product(2, this);
      } else {
        return ConstraintExpression.sum(this, that);
      }
    };
    ConstraintAnimator.prototype.negative = function() {
      return ConstraintExpression.product(-1, this);
    };
    ConstraintAnimator.prototype.minus = function(that) {
      that = ConstraintExpression.fromAny(that);
      if (this === that) {
        return ConstraintExpression.zero;
      } else {
        return ConstraintExpression.sum(this, that.negative());
      }
    };
    ConstraintAnimator.prototype.times = function(scalar) {
      return ConstraintExpression.product(scalar, this);
    };
    ConstraintAnimator.prototype.divide = function(scalar) {
      return ConstraintExpression.product(1 / scalar, this);
    };
    Object.defineProperty(ConstraintAnimator.prototype, "constrained", {
      get() {
        return (this.flags & ConstraintAnimator.ConstrainedFlag) !== 0;
      },
      configurable: true
    });
    ConstraintAnimator.prototype.constrain = function(constrained) {
      if (constrained === void 0) {
        constrained = true;
      }
      const flags = this.flags;
      if (constrained && (flags & ConstraintAnimator.ConstrainedFlag) === 0) {
        this.setFlags(flags | ConstraintAnimator.ConstrainedFlag);
        if (this.conditionCount !== 0 && this.mounted) {
          this.stopConstraining();
        }
      } else if (!constrained && (flags & ConstraintAnimator.ConstrainedFlag) !== 0) {
        this.setFlags(flags & ~ConstraintAnimator.ConstrainedFlag);
        if (this.conditionCount !== 0 && this.mounted) {
          this.startConstraining();
          this.updateConstraintVariable();
        }
      }
      return this;
    };
    ConstraintAnimator.prototype.addConstraintCondition = function(constraint, solver) {
      this.conditionCount += 1;
      if (!this.constrained && this.conditionCount === 1 && this.mounted) {
        this.startConstraining();
        this.updateConstraintVariable();
      }
    };
    ConstraintAnimator.prototype.removeConstraintCondition = function(constraint, solver) {
      this.conditionCount -= 1;
      if (!this.constrained && this.conditionCount === 0 && this.mounted) {
        this.stopConstraining();
      }
    };
    Object.defineProperty(ConstraintAnimator.prototype, "constraining", {
      get() {
        return (this.flags & ConstraintAnimator.ConstrainingFlag) !== 0;
      },
      configurable: true
    });
    ConstraintAnimator.prototype.startConstraining = function() {
      if ((this.flags & ConstraintAnimator.ConstrainingFlag) === 0) {
        this.willStartConstraining();
        this.setFlags(this.flags | ConstraintAnimator.ConstrainingFlag);
        this.onStartConstraining();
        this.didStartConstraining();
      }
    };
    ConstraintAnimator.prototype.willStartConstraining = function() {};
    ConstraintAnimator.prototype.onStartConstraining = function() {
      const constraintScope = this.owner;
      if (ConstraintScope.is(constraintScope)) {
        constraintScope.addConstraintVariable(this);
      }
    };
    ConstraintAnimator.prototype.didStartConstraining = function() {};
    ConstraintAnimator.prototype.stopConstraining = function() {
      if ((this.flags & ConstraintAnimator.ConstrainingFlag) !== 0) {
        this.willStopConstraining();
        this.setFlags(this.flags & ~ConstraintAnimator.ConstrainingFlag);
        this.onStopConstraining();
        this.didStopConstraining();
      }
    };
    ConstraintAnimator.prototype.willStopConstraining = function() {};
    ConstraintAnimator.prototype.onStopConstraining = function() {
      const constraintScope = this.owner;
      if (ConstraintScope.is(constraintScope)) {
        constraintScope.removeConstraintVariable(this);
      }
    };
    ConstraintAnimator.prototype.didStopConstraining = function() {};
    ConstraintAnimator.prototype.updateConstraintVariable = function() {
      const constraintScope = this.owner;
      const value = this.value;
      if (value !== void 0 && ConstraintScope.is(constraintScope)) {
        constraintScope.setConstraintVariable(this, this.toNumber(value));
      }
    };
    ConstraintAnimator.prototype.onSetValue = function(newValue, oldValue) {
      _super.prototype.onSetValue.call(this, newValue, oldValue);
      const constraintScope = this.owner;
      if (this.constraining && ConstraintScope.is(constraintScope)) {
        constraintScope.setConstraintVariable(this, newValue !== void 0 && newValue !== null ? this.toNumber(newValue) : 0);
      }
    };
    ConstraintAnimator.prototype.onMount = function() {
      _super.prototype.onMount.call(this);
      if (!this.constrained && this.conditionCount !== 0) {
        this.startConstraining();
      }
    };
    ConstraintAnimator.prototype.onUnmount = function() {
      if (!this.constrained && this.conditionCount !== 0) {
        this.stopConstraining();
      }
      _super.prototype.onUnmount.call(this);
    };
    ConstraintAnimator.prototype.fromAny = function(value) {
      if (typeof value === "string") {
        const number = +value;
        if (isFinite(number)) {
          return number;
        }
      }
      return value;
    };
    ConstraintAnimator.prototype.toNumber = function(value) {
      return value !== void 0 && value !== null ? +value : 0;
    };
    ConstraintAnimator.construct = function(animatorClass, animator, owner) {
      animator = _super.construct(animatorClass, animator, owner);
      animator.id = ConstraintId.next();
      animator.strength = ConstraintStrength.Strong;
      animator.conditionCount = 0;
      return animator;
    };
    ConstraintAnimator.specialize = function(type) {
      return null;
    };
    ConstraintAnimator.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const strength = descriptor.strength !== void 0 ? ConstraintStrength.fromAny(descriptor.strength) : void 0;
      const constrain = descriptor.constrain;
      const value = descriptor.value;
      const initValue = descriptor.initValue;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.strength;
      delete descriptor.constrain;
      delete descriptor.value;
      delete descriptor.initValue;
      if (superClass === void 0 || superClass === null) {
        superClass = this.specialize(descriptor.type);
      }
      if (superClass === null) {
        superClass = this;
        if (descriptor.fromAny === void 0 && FromAny.is(descriptor.type)) {
          descriptor.fromAny = descriptor.type.fromAny;
        }
      }
      const animatorClass = superClass.extend(className, descriptor);
      animatorClass.construct = function(animatorClass, animator, owner) {
        animator = superClass.construct(animatorClass, animator, owner);
        if (affinity !== void 0) {
          animator.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          animator.initInherits(inherits);
        }
        if (strength !== void 0) {
          animator.strength = strength;
        }
        if (initValue !== void 0) {
          animator.value = animator.fromAny(initValue());
          animator.state = animator.value;
        } else if (value !== void 0) {
          animator.value = animator.fromAny(value);
          animator.state = animator.value;
        }
        if (constrain === true) {
          animator.constrain();
        }
        return animator;
      };
      return animatorClass;
    };
    ConstraintAnimator.ConstrainedFlag = 1 << _super.FlagShift + 0;
    ConstraintAnimator.ConstrainingFlag = 1 << _super.FlagShift + 1;
    ConstraintAnimator.FlagShift = _super.FlagShift + 2;
    ConstraintAnimator.FlagMask = (1 << ConstraintAnimator.FlagShift) - 1;
    return ConstraintAnimator;
  }(Animator);
  const ConstraintStrength = function() {
    const ConstraintStrength = {};
    ConstraintStrength.Required = 1001001e3;
    ConstraintStrength.Strong = 1e6;
    ConstraintStrength.Medium = 1e3;
    ConstraintStrength.Weak = 1;
    ConstraintStrength.Unbound = -1;
    ConstraintStrength.clip = function(strength) {
      return Math.min(Math.max(0, strength), ConstraintStrength.Required);
    };
    ConstraintStrength.fromAny = function(strength) {
      if (typeof strength === "number") {
        return ConstraintStrength.clip(strength);
      } else if (strength === "required") {
        return ConstraintStrength.Required;
      } else if (strength === "strong") {
        return ConstraintStrength.Strong;
      } else if (strength === "medium") {
        return ConstraintStrength.Medium;
      } else if (strength === "weak") {
        return ConstraintStrength.Weak;
      }
      throw new TypeError("" + strength);
    };
    return ConstraintStrength;
  }();
  class Constraint {
    constructor(scope, expression, relation, strength) {
      this.id = ConstraintId.next();
      this.scope = scope;
      this.expression = expression;
      this.relation = relation;
      this.strength = strength;
    }
    isConstrained() {
      return this.scope.hasConstraint(this);
    }
    constrain(constrained = true) {
      if (constrained) {
        this.scope.addConstraint(this);
      } else {
        this.scope.removeConstraint(this);
      }
      return this;
    }
    debug(output) {
      output = output.debug(this.scope).write(46).write("constraint").write(40).debug(this.expression).write(", ").debug(this.relation).write(", ").debug(void 0).write(", ");
      if (this.strength === ConstraintStrength.Required) {
        output = output.debug("required");
      } else if (this.strength === ConstraintStrength.Strong) {
        output = output.debug("strong");
      } else if (this.strength === ConstraintStrength.Medium) {
        output = output.debug("medium");
      } else if (this.strength === ConstraintStrength.Weak) {
        output = output.debug("weak");
      } else {
        output = output.debug(this.strength);
      }
      output = output.write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
  }
  class ConstraintGroup {
    constructor(scope) {
      this.scope = scope;
      this.constraints = [];
      this.constrained = false;
    }
    constraint(lhs, relation, rhs, strength) {
      lhs = ConstraintExpression.fromAny(lhs);
      if (rhs !== void 0) {
        rhs = ConstraintExpression.fromAny(rhs);
      }
      const expression = rhs !== void 0 ? lhs.minus(rhs) : lhs;
      if (strength === void 0) {
        strength = ConstraintStrength.Required;
      } else {
        strength = ConstraintStrength.fromAny(strength);
      }
      const constraint = new Constraint(this.scope, expression, relation, strength);
      this.addConstraint(constraint);
      return constraint;
    }
    hasConstraint(constraint) {
      const constraints = this.constraints;
      return constraints.indexOf(constraint) >= 0;
    }
    addConstraint(constraint) {
      const constraints = this.constraints;
      if (constraints.indexOf(constraint) < 0) {
        constraints.push(constraint);
        constraint.constrain(this.constrained);
      }
    }
    removeConstraint(constraint) {
      const constraints = this.constraints;
      if (constraints !== void 0) {
        const index = constraints.indexOf(constraint);
        if (index >= 0) {
          constraints.splice(index, 1);
          constraint.constrain(false);
        }
      }
    }
    enableConstraints() {
      const constraints = this.constraints;
      for (let i = 0, n = constraints.length; i < n; i += 1) {
        constraints[i].constrain(true);
      }
    }
    disableConstraints() {
      const constraints = this.constraints;
      for (let i = 0, n = constraints.length; i < n; i += 1) {
        constraints[i].constrain(false);
      }
    }
    isConstrained() {
      return this.constrained;
    }
    constrain(constrained = true) {
      if (constrained && !this.constrained) {
        this.constrained = true;
        this.enableConstraints();
      } else if (!constrained && this.constrained) {
        this.constrained = false;
        this.disableConstraints();
      }
      return this;
    }
  }
  const ConstraintScope = function() {
    const ConstraintScope = {};
    ConstraintScope.is = function(object) {
      if (typeof object === "object" && object !== null || typeof object === "function") {
        const constraintScope = object;
        return "constraint" in constraintScope;
      }
      return false;
    };
    return ConstraintScope;
  }();
  class ConstraintRow {
    constructor(solver, symbol, cells, constant) {
      this.solver = solver;
      this.symbol = symbol;
      this.cells = cells;
      this.constant = constant;
    }
    setSymbol(symbol) {
      this.symbol = symbol;
      this.invalidate();
    }
    setConstant(constant) {
      if (this.constant !== constant) {
        this.constant = constant;
        this.invalidate();
      }
    }
    isConstant() {
      return this.cells.isEmpty();
    }
    isDummy() {
      for (let i = 0, n = this.cells.size; i < n; i += 1) {
        const symbol = this.cells.getEntry(i)[0];
        if (!(symbol instanceof ConstraintDummy)) {
          return false;
        }
      }
      return true;
    }
    clone() {
      return new ConstraintRow(this.solver, this.symbol, this.cells.clone(), this.constant);
    }
    add(value) {
      const sum = this.constant + value;
      this.setConstant(sum);
      return sum;
    }
    insertSymbol(symbol, coefficient = 1) {
      var _a;
      coefficient += (_a = this.cells.get(symbol)) !== null && _a !== void 0 ? _a : 0;
      if (Math.abs(coefficient) < Equivalent.Epsilon) {
        this.cells.remove(symbol);
      } else {
        this.cells.set(symbol, coefficient);
      }
    }
    insertRow(that, coefficient) {
      this.setConstant(this.constant + that.constant * coefficient);
      for (let i = 0, n = that.cells.size; i < n; i += 1) {
        const [symbol, value] = that.cells.getEntry(i);
        this.insertSymbol(symbol, value * coefficient);
      }
    }
    removeSymbol(symbol) {
      this.cells.remove(symbol);
    }
    negate() {
      this.setConstant(-this.constant);
      for (let i = 0, n = this.cells.size; i < n; i += 1) {
        const entry = this.cells.getEntry(i);
        entry[1] = -entry[1];
      }
    }
    solveFor(symbol) {
      const value = this.cells.remove(symbol);
      if (value !== void 0) {
        const coefficient = -1 / value;
        this.setConstant(this.constant * coefficient);
        for (let i = 0, n = this.cells.size; i < n; i += 1) {
          const entry = this.cells.getEntry(i);
          entry[1] *= coefficient;
        }
      }
    }
    solveForEx(lhs, rhs) {
      this.insertSymbol(lhs, -1);
      this.solveFor(rhs);
    }
    coefficientFor(symbol) {
      const value = this.cells.get(symbol);
      return value !== void 0 ? value : 0;
    }
    substitute(symbol, row) {
      const value = this.cells.remove(symbol);
      if (value !== void 0) {
        this.insertRow(row, value);
      }
    }
    invalidate() {
      const symbol = this.symbol;
      if (symbol !== null) {
        this.solver.invalidate(symbol, this);
      }
    }
  }
  class ConstraintSolver {
    constructor() {
      this.constraints = new ConstraintMap;
      this.constraintVariables = new ConstraintMap;
      this.rows = new ConstraintMap;
      this.infeasible = [];
      this.objective = new ConstraintRow(this, null, new ConstraintMap, 0);
      this.artificial = null;
      this.invalidated = new ConstraintMap;
    }
    constraint(lhs, relation, rhs, strength) {
      lhs = ConstraintExpression.fromAny(lhs);
      if (rhs !== void 0) {
        rhs = ConstraintExpression.fromAny(rhs);
      }
      const expression = rhs !== void 0 ? lhs.minus(rhs) : lhs;
      if (strength === void 0) {
        strength = ConstraintStrength.Required;
      } else {
        strength = ConstraintStrength.fromAny(strength);
      }
      const constraint = new Constraint(this, expression, relation, strength);
      this.addConstraint(constraint);
      return constraint;
    }
    hasConstraint(constraint) {
      return this.constraints.has(constraint);
    }
    addConstraint(constraint) {
      if (this.constraints.has(constraint)) {
        return;
      }
      const terms = constraint.expression.terms;
      for (let i = 0, n = terms.size; i < n; i += 1) {
        const variable = terms.getEntry(i)[0];
        variable.addConstraintCondition(constraint, this);
      }
      const {row: row, tag: tag} = this.createRow(constraint);
      this.addConstraintRow(constraint, row, tag);
    }
    addConstraintRow(constraint, row, tag) {
      this.willAddConstraint(constraint);
      let subject = this.chooseSubject(row, tag);
      if (subject.isInvalid() && row.isDummy()) {
        if (Math.abs(row.constant) < Equivalent.Epsilon) {
          subject = tag.marker;
        } else {
          throw new Error("unsatisfiable constraint");
        }
      }
      if (subject.isInvalid()) {
        if (!this.addWithArtificialVariable(row)) {
          throw new Error("unsatisfiable constraint");
        }
      } else {
        row.setSymbol(subject);
        row.solveFor(subject);
        this.substitute(subject, row);
        this.rows.set(subject, row);
      }
      this.constraints.set(constraint, tag);
      this.optimize(this.objective);
      this.didAddConstraint(constraint);
      this.updateSolution();
    }
    willAddConstraint(constraint) {}
    didAddConstraint(constraint) {}
    removeConstraint(constraint) {
      const tag = this.constraints.get(constraint);
      if (tag === void 0) {
        return;
      }
      this.removeConstraintRow(constraint);
      const terms = constraint.expression.terms;
      for (let i = 0, n = terms.size; i < n; i += 1) {
        const variable = terms.getEntry(i)[0];
        variable.removeConstraintCondition(constraint, this);
      }
    }
    removeConstraintRow(constraint) {
      const tag = this.constraints.get(constraint);
      if (tag === void 0) {
        return;
      }
      this.willRemoveConstraint(constraint);
      this.constraints.remove(constraint);
      this.removeConstraintEffects(constraint, tag);
      const marker = tag.marker;
      if (this.rows.remove(marker) === void 0) {
        const leaving = this.getMarkerLeavingSymbol(marker);
        if (leaving.isInvalid()) {
          throw new Error("failed to find leaving row");
        }
        const row = this.rows.remove(leaving);
        row.solveForEx(leaving, marker);
        this.substitute(marker, row);
      }
      this.optimize(this.objective);
      this.didRemoveConstraint(constraint);
      this.updateSolution();
    }
    willRemoveConstraint(constraint) {}
    didRemoveConstraint(constraint) {}
    constraintVariable(name, value, strength) {
      if (value === void 0) {
        value = 0;
      }
      if (strength !== void 0) {
        strength = ConstraintStrength.fromAny(strength);
      } else {
        strength = ConstraintStrength.Strong;
      }
      const property = ConstraintProperty.create(this);
      Object.defineProperty(property, "name", {
        value: name,
        configurable: true
      });
      if (value !== void 0) {
        property.setValue(value);
      }
      property.setStrength(strength);
      property.mount();
      return property;
    }
    hasConstraintVariable(variable) {
      return this.constraintVariables.has(variable);
    }
    addConstraintVariable(variable) {
      if (this.constraintVariables.has(variable)) {
        return;
      }
      const strength = ConstraintStrength.clip(variable.strength);
      if (strength === ConstraintStrength.Required) {
        throw new Error("invalid variable strength");
      }
      this.willAddConstraintVariable(variable);
      const constraint = new Constraint(this, variable, "eq", strength);
      const {row: row, tag: tag} = this.createRow(constraint);
      this.constraintVariables.set(variable, {
        constraint: constraint,
        tag: tag,
        state: 0
      });
      this.addConstraintRow(constraint, row, tag);
      this.didAddConstraintVariable(variable);
    }
    willAddConstraintVariable(variable) {}
    didAddConstraintVariable(variable) {}
    removeConstraintVariable(variable) {
      const binding = this.constraintVariables.get(variable);
      if (binding === void 0) {
        return;
      }
      this.willRemoveConstraintVariable(variable);
      this.constraintVariables.remove(variable);
      this.removeConstraintRow(binding.constraint);
      this.didRemoveConstraintVariable(variable);
    }
    willRemoveConstraintVariable(variable) {}
    didRemoveConstraintVariable(variable) {}
    setConstraintVariable(variable, newState) {
      const binding = this.constraintVariables.get(variable);
      if (binding === void 0) {
        throw new Error("unbound variable");
      }
      const oldState = binding.state;
      if (oldState !== newState) {
        binding.state = newState;
        const delta = newState - oldState;
        this.willSetConstraintVariable(variable, newState, oldState);
        const marker = binding.tag.marker;
        let row = this.rows.get(marker);
        if (row !== void 0) {
          if (row.add(-delta) < 0) {
            this.infeasible.push(marker);
          }
          this.dualOptimize();
          return;
        }
        const other = binding.tag.other;
        row = this.rows.get(other);
        if (row !== void 0) {
          if (row.add(delta) < 0) {
            this.infeasible.push(other);
          }
          this.dualOptimize();
          return;
        }
        for (let i = 0, n = this.rows.size; i < n; i += 1) {
          const [symbol, row] = this.rows.getEntry(i);
          const coefficient = row.coefficientFor(marker);
          if (coefficient !== 0 && row.add(delta * coefficient) < 0 && !symbol.isExternal()) {
            this.infeasible.push(symbol);
          }
        }
        this.dualOptimize();
        this.didSetConstraintVariable(variable, newState, oldState);
        this.updateSolution();
      }
    }
    willSetConstraintVariable(variable, newState, oldState) {}
    didSetConstraintVariable(variable, newState, oldState) {}
    invalidate(symbol, row = null) {
      if (symbol.isExternal()) {
        this.invalidated.set(symbol, row);
      }
    }
    updateSolution() {
      const invalidated = this.invalidated;
      if (!invalidated.isEmpty()) {
        this.invalidated = new ConstraintMap;
        for (let i = 0, n = invalidated.size; i < n; i += 1) {
          const symbol = invalidated.getEntry(i)[0];
          const row = this.rows.get(symbol);
          if (row !== void 0) {
            symbol.updateConstraintSolution(row.constant);
          }
        }
      }
    }
    createRow(constraint) {
      const expression = constraint.expression;
      const row = new ConstraintRow(this, null, new ConstraintMap, expression.constant);
      const terms = expression.terms;
      for (let i = 0, n = terms.size; i < n; i += 1) {
        const [variable, coefficient] = terms.getEntry(i);
        if (Math.abs(coefficient) >= Equivalent.Epsilon) {
          const basic = this.rows.get(variable);
          if (basic !== void 0) {
            row.insertRow(basic, coefficient);
          } else {
            row.insertSymbol(variable, coefficient);
          }
        }
      }
      const objective = this.objective;
      const relation = constraint.relation;
      const strength = constraint.strength;
      const tag = {
        marker: ConstraintSymbol.invalid,
        other: ConstraintSymbol.invalid
      };
      if (relation === "le" || relation === "ge") {
        const coefficient = relation === "le" ? 1 : -1;
        const slack = new ConstraintSlack;
        tag.marker = slack;
        row.insertSymbol(slack, coefficient);
        if (strength < ConstraintStrength.Required) {
          const error = new ConstraintError;
          tag.other = error;
          row.insertSymbol(error, -coefficient);
          objective.insertSymbol(error, strength);
        }
      } else {
        if (strength < ConstraintStrength.Required) {
          const eplus = new ConstraintError;
          const eminus = new ConstraintError;
          tag.marker = eplus;
          tag.other = eminus;
          row.insertSymbol(eplus, -1);
          row.insertSymbol(eminus, 1);
          objective.insertSymbol(eplus, strength);
          objective.insertSymbol(eminus, strength);
        } else {
          const dummy = new ConstraintDummy;
          tag.marker = dummy;
          row.insertSymbol(dummy);
        }
      }
      if (row.constant < 0) {
        row.negate();
      }
      return {
        row: row,
        tag: tag
      };
    }
    chooseSubject(row, tag) {
      for (let i = 0, n = row.cells.size; i < n; i += 1) {
        const symbol = row.cells.getEntry(i)[0];
        if (symbol.isExternal()) {
          return symbol;
        }
      }
      if (tag.marker instanceof ConstraintSlack || tag.marker instanceof ConstraintError) {
        if (row.coefficientFor(tag.marker) < 0) {
          return tag.marker;
        }
      }
      if (tag.other instanceof ConstraintSlack || tag.other instanceof ConstraintError) {
        if (row.coefficientFor(tag.other) < 0) {
          return tag.other;
        }
      }
      return ConstraintSymbol.invalid;
    }
    addWithArtificialVariable(row) {
      const artificial = new ConstraintSlack;
      this.rows.set(artificial, row.clone());
      this.artificial = row.clone();
      this.optimize(this.artificial);
      const success = Math.abs(this.artificial.constant) < Equivalent.Epsilon;
      this.artificial = null;
      const basic = this.rows.remove(artificial);
      if (basic !== void 0) {
        if (basic.isConstant()) {
          return success;
        }
        const entering = this.anyPivotableSymbol(basic);
        if (entering.isInvalid()) {
          return false;
        }
        basic.setSymbol(entering);
        basic.solveForEx(artificial, entering);
        this.substitute(entering, basic);
        this.rows.set(entering, basic);
      }
      for (let i = 0, n = this.rows.size; i < n; i += 1) {
        this.rows.getEntry(i)[1].removeSymbol(artificial);
      }
      this.objective.removeSymbol(artificial);
      return success;
    }
    substitute(symbol, row) {
      for (let i = 0, n = this.rows.size; i < n; i += 1) {
        const [key, value] = this.rows.getEntry(i);
        value.substitute(symbol, row);
        if (value.constant < 0 && !key.isExternal()) {
          this.infeasible.push(key);
        }
      }
      this.objective.substitute(symbol, row);
      if (this.artificial !== null) {
        this.artificial.substitute(symbol, row);
      }
    }
    optimize(objective) {
      do {
        const entering = this.getEnteringSymbol(objective);
        if (entering.isInvalid()) {
          return;
        }
        const leaving = this.getLeavingSymbol(entering);
        if (leaving.isInvalid()) {
          throw new Error("objective is unbounded");
        }
        const row = this.rows.remove(leaving);
        row.setSymbol(entering);
        row.solveForEx(leaving, entering);
        this.substitute(entering, row);
        this.rows.set(entering, row);
      } while (true);
    }
    dualOptimize() {
      let leaving;
      while (leaving = this.infeasible.pop(), leaving !== void 0) {
        const row = this.rows.get(leaving);
        if (row !== void 0 && row.constant < 0) {
          const entering = this.getDualEnteringSymbol(row);
          if (entering.isInvalid()) {
            throw new Error("dual optimize failed");
          }
          this.rows.remove(leaving);
          row.setSymbol(entering);
          row.solveForEx(leaving, entering);
          this.substitute(entering, row);
          this.rows.set(entering, row);
        }
      }
    }
    getEnteringSymbol(objective) {
      for (let i = 0, n = objective.cells.size; i < n; i += 1) {
        const [symbol, value] = objective.cells.getEntry(i);
        if (value < 0 && !symbol.isDummy()) {
          return symbol;
        }
      }
      return ConstraintSymbol.invalid;
    }
    getDualEnteringSymbol(row) {
      let ratio = Number.MAX_VALUE;
      let entering = ConstraintSymbol.invalid;
      for (let i = 0, n = row.cells.size; i < n; i += 1) {
        const [symbol, value] = row.cells.getEntry(i);
        if (value > 0 && !symbol.isDummy()) {
          const coefficient = this.objective.coefficientFor(symbol);
          const coratio = coefficient / value;
          if (coratio < ratio) {
            ratio = coratio;
            entering = symbol;
          }
        }
      }
      return entering;
    }
    getLeavingSymbol(entering) {
      let ratio = Number.MAX_VALUE;
      let found = ConstraintSymbol.invalid;
      for (let i = 0, n = this.rows.size; i < n; i += 1) {
        const [symbol, row] = this.rows.getEntry(i);
        if (!symbol.isExternal()) {
          const coefficient = row.coefficientFor(entering);
          if (coefficient < 0) {
            const coratio = -row.constant / coefficient;
            if (coratio < ratio) {
              ratio = coratio;
              found = symbol;
            }
          }
        }
      }
      return found;
    }
    getMarkerLeavingSymbol(marker) {
      let r1 = Number.MAX_VALUE;
      let r2 = Number.MAX_VALUE;
      let first = ConstraintSymbol.invalid;
      let second = ConstraintSymbol.invalid;
      let third = ConstraintSymbol.invalid;
      for (let i = 0, n = this.rows.size; i < n; i += 1) {
        const [symbol, row] = this.rows.getEntry(i);
        const coefficient = row.coefficientFor(marker);
        if (coefficient === 0) {
          continue;
        }
        if (symbol.isExternal()) {
          third = symbol;
        } else if (coefficient < 0) {
          const ratio = -row.constant / coefficient;
          if (ratio < r1) {
            r1 = ratio;
            first = symbol;
          }
        } else {
          const ratio = row.constant / coefficient;
          if (ratio < r2) {
            r2 = ratio;
            second = symbol;
          }
        }
      }
      if (!first.isInvalid()) {
        return first;
      } else if (!second.isInvalid()) {
        return second;
      } else {
        return third;
      }
    }
    removeConstraintEffects(constraint, tag) {
      if (tag.marker instanceof ConstraintError) {
        this.removeMarkerEffects(tag.marker, constraint.strength);
      }
      if (tag.other instanceof ConstraintError) {
        this.removeMarkerEffects(tag.other, constraint.strength);
      }
    }
    removeMarkerEffects(marker, strength) {
      const row = this.rows.get(marker);
      if (row !== void 0) {
        this.objective.insertRow(row, -strength);
      } else {
        this.objective.insertSymbol(marker, -strength);
      }
    }
    anyPivotableSymbol(row) {
      for (let i = 0, n = row.cells.size; i < n; i += 1) {
        const symbol = row.cells.getEntry(i)[0];
        if (symbol instanceof ConstraintSlack || symbol instanceof ConstraintError) {
          return symbol;
        }
      }
      return ConstraintSymbol.invalid;
    }
  }
  class Item {
    constructor() {}
    updated(key, value) {
      const record = Record.create(2);
      record.push(this);
      record.set(key, value);
      return record;
    }
    updatedAttr(key, value) {
      const record = Record.create(2);
      record.push(this);
      record.setAttr(key, value);
      return record;
    }
    updatedSlot(key, value) {
      const record = Record.create(2);
      record.push(this);
      record.setSlot(key, value);
      return record;
    }
    appended(...items) {
      const record = Record.create(1 + arguments.length);
      record.push(this);
      record.push(...items);
      return record;
    }
    prepended(...items) {
      const record = Record.create(arguments.length + 1);
      record.push(...items);
      record.push(this);
      return record;
    }
    concat(...items) {
      const record = Record.create();
      record.push(this);
      for (let i = 0, n = items.length; i < n; i += 1) {
        Item.fromAny(items[i]).forEach((function(item) {
          record.push(item);
        }));
      }
      return record;
    }
    lt(that) {
      that = Item.fromAny(that);
      return this.compareTo(that) < 0 ? Bool.from(true) : Item.absent();
    }
    le(that) {
      that = Item.fromAny(that);
      return this.compareTo(that) <= 0 ? Bool.from(true) : Item.absent();
    }
    eq(that) {
      that = Item.fromAny(that);
      return this.equals(that) ? Bool.from(true) : Item.absent();
    }
    ne(that) {
      that = Item.fromAny(that);
      return !this.equals(that) ? Bool.from(true) : Item.absent();
    }
    ge(that) {
      that = Item.fromAny(that);
      return this.compareTo(that) >= 0 ? Bool.from(true) : Item.absent();
    }
    gt(that) {
      that = Item.fromAny(that);
      return this.compareTo(that) > 0 ? Bool.from(true) : Item.absent();
    }
    invoke(args) {
      return Item.absent();
    }
    filter(predicate) {
      const selector = Selector.literal(this);
      if (arguments.length === 0) {
        return selector.filter();
      } else {
        return selector.filter(predicate);
      }
    }
    max(that) {
      return this.compareTo(that) >= 0 ? this : that;
    }
    min(that) {
      return this.compareTo(that) <= 0 ? this : that;
    }
    evaluate(interpreter) {
      return this;
    }
    substitute(interpreter) {
      return this;
    }
    cast(form, orElse) {
      let object = form.cast(this);
      if (object === void 0) {
        object = orElse;
      }
      return object;
    }
    coerce(form, orElse) {
      let object = form.cast(this);
      if (object === void 0) {
        object = form.unit;
      }
      if (object === void 0) {
        object = orElse;
      }
      return object;
    }
    get precedence() {
      return 11;
    }
    forEach(callback, thisArg) {
      return callback.call(thisArg, this, 0);
    }
    iterator() {
      return Cursor.unary(this);
    }
    interpolateTo(that) {
      if (that instanceof Item) {
        return ItemInterpolator(this, that);
      } else {
        return null;
      }
    }
    display(output) {
      return this.debug(output);
    }
    toString() {
      return Format.debug(this);
    }
    static empty() {
      return Record.empty();
    }
    static extant() {
      return Extant.extant();
    }
    static absent() {
      return Absent.absent();
    }
    static fromAny(item) {
      if (item instanceof Item) {
        return item;
      } else {
        return Value.fromAny(item);
      }
    }
    static globalScope() {
      return Record.create(1).slot("math", MathModule.scope).commit();
    }
  }
  __decorate([ Lazy ], Item, "globalScope", null);
  const ItemInterpolator = function(_super) {
    const ItemInterpolator = function(y0, y1) {
      const interpolator = function(u) {
        return u < 1 ? interpolator[0] : interpolator[1];
      };
      Object.setPrototypeOf(interpolator, ItemInterpolator.prototype);
      interpolator[0] = y0.commit();
      interpolator[1] = y1.commit();
      return interpolator;
    };
    ItemInterpolator.prototype = Object.create(_super.prototype);
    ItemInterpolator.prototype.constructor = ItemInterpolator;
    return ItemInterpolator;
  }(Interpolator);
  class Field extends Item {
    constructor() {
      super();
    }
    isDefined() {
      return true;
    }
    isDistinct() {
      return true;
    }
    isDefinite() {
      return true;
    }
    toValue() {
      return this.value;
    }
    get tag() {
      return void 0;
    }
    get target() {
      return this.value;
    }
    flattened() {
      return Value.absent();
    }
    unflattened() {
      return Record.of(this);
    }
    header(tag) {
      return Value.absent();
    }
    headers(tag) {
      return void 0;
    }
    head() {
      return Item.absent();
    }
    tail() {
      return Record.empty();
    }
    body() {
      return Value.absent();
    }
    get length() {
      return 0;
    }
    has(key) {
      return false;
    }
    get(key) {
      return Value.absent();
    }
    getAttr(key) {
      return Value.absent();
    }
    getSlot(key) {
      return Value.absent();
    }
    getField(key) {
      return void 0;
    }
    getItem(index) {
      return Item.absent();
    }
    deleted(key) {
      return this;
    }
    conditional(thenTerm, elseTerm) {
      thenTerm = Item.fromAny(thenTerm);
      return thenTerm;
    }
    or(that) {
      return this;
    }
    and(that) {
      that = Item.fromAny(that);
      return that;
    }
    lambda(template) {
      return Value.absent();
    }
    stringValue(orElse) {
      return this.value.stringValue(orElse);
    }
    numberValue(orElse) {
      return this.value.numberValue(orElse);
    }
    booleanValue(orElse) {
      return this.value.booleanValue(orElse);
    }
    interpolateTo(that) {
      if (that instanceof Field) {
        return FieldInterpolator(this, that);
      } else {
        return super.interpolateTo(that);
      }
    }
    static of(key, value) {
      let name;
      if (typeof key === "string") {
        name = key;
      } else if (key instanceof Text) {
        name = key.value;
      }
      if (name !== void 0 && name.charCodeAt(0) === 64) {
        name = name.slice(1);
        if (arguments.length === 1) {
          return Attr.of(name);
        } else {
          return Attr.of(name, value);
        }
      } else {
        if (arguments.length === 1) {
          return Slot.of(key);
        } else {
          return Slot.of(key, value);
        }
      }
    }
    static fromAny(field) {
      if (field instanceof Field) {
        return field;
      } else if (typeof field === "object" && field !== null) {
        if (field.$key !== void 0) {
          return Field.of(field.$key, field.$value);
        } else {
          for (const key in field) {
            return Field.of(key, field[key]);
          }
        }
      }
      throw new TypeError("" + field);
    }
  }
  Field.ImmutableFlag = 1 << 0;
  class Slot extends Field {
    constructor(key, value, flags) {
      super();
      this.key = key.commit();
      this.value = value;
      this.flags = flags !== void 0 ? flags : 0;
    }
    isConstant() {
      return this.key.isConstant() && this.value.isConstant();
    }
    setValue(newValue) {
      if ((this.flags & Field.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      }
      const oldValue = this.value;
      this.value = newValue;
      return oldValue;
    }
    updatedValue(value) {
      return new Slot(this.key, value);
    }
    bitwiseOr(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new BitwiseOrOperator(this, that);
      }
      let newValue;
      if (that instanceof Slot && this.key.equals(that.key)) {
        newValue = this.value.bitwiseOr(that.value);
      } else if (that instanceof Value) {
        newValue = this.value.bitwiseOr(that);
      } else {
        newValue = Value.absent();
      }
      if (newValue.isDefined()) {
        return new Slot(this.key, newValue);
      }
      return Item.absent();
    }
    bitwiseXor(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new BitwiseXorOperator(this, that);
      }
      let newValue;
      if (that instanceof Slot && this.key.equals(that.key)) {
        newValue = this.value.bitwiseXor(that.value);
      } else if (that instanceof Value) {
        newValue = this.value.bitwiseXor(that);
      } else {
        newValue = Value.absent();
      }
      if (newValue.isDefined()) {
        return new Slot(this.key, newValue);
      }
      return Item.absent();
    }
    bitwiseAnd(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new BitwiseAndOperator(this, that);
      }
      let newValue;
      if (that instanceof Slot && this.key.equals(that.key)) {
        newValue = this.value.bitwiseAnd(that.value);
      } else if (that instanceof Value) {
        newValue = this.value.bitwiseAnd(that);
      } else {
        newValue = Value.absent();
      }
      if (newValue.isDefined()) {
        return new Slot(this.key, newValue);
      }
      return Item.absent();
    }
    plus(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new PlusOperator(this, that);
      }
      let newValue;
      if (that instanceof Slot && this.key.equals(that.key)) {
        newValue = this.value.plus(that.value);
      } else if (that instanceof Value) {
        newValue = this.value.plus(that);
      } else {
        newValue = Value.absent();
      }
      if (newValue.isDefined()) {
        return new Slot(this.key, newValue);
      }
      return Item.absent();
    }
    minus(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new MinusOperator(this, that);
      }
      let newValue;
      if (that instanceof Slot && this.key.equals(that.key)) {
        newValue = this.value.minus(that.value);
      } else if (that instanceof Value) {
        newValue = this.value.minus(that);
      } else {
        newValue = Value.absent();
      }
      if (newValue.isDefined()) {
        return new Slot(this.key, newValue);
      }
      return Item.absent();
    }
    times(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new TimesOperator(this, that);
      }
      let newValue;
      if (that instanceof Slot && this.key.equals(that.key)) {
        newValue = this.value.times(that.value);
      } else if (that instanceof Value) {
        newValue = this.value.times(that);
      } else {
        newValue = Value.absent();
      }
      if (newValue.isDefined()) {
        return new Slot(this.key, newValue);
      }
      return Item.absent();
    }
    divide(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new DivideOperator(this, that);
      }
      let newValue;
      if (that instanceof Slot && this.key.equals(that.key)) {
        newValue = this.value.divide(that.value);
      } else if (that instanceof Value) {
        newValue = this.value.divide(that);
      } else {
        newValue = Value.absent();
      }
      if (newValue.isDefined()) {
        return new Slot(this.key, newValue);
      }
      return Item.absent();
    }
    modulo(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new ModuloOperator(this, that);
      }
      let newValue;
      if (that instanceof Slot && this.key.equals(that.key)) {
        newValue = this.value.modulo(that.value);
      } else if (that instanceof Value) {
        newValue = this.value.modulo(that);
      } else {
        newValue = Value.absent();
      }
      if (newValue.isDefined()) {
        return new Slot(this.key, newValue);
      }
      return Item.absent();
    }
    not() {
      const newValue = this.value.not();
      if (newValue.isDefined()) {
        return new Slot(this.key, newValue);
      }
      return Item.absent();
    }
    bitwiseNot() {
      const newValue = this.value.bitwiseNot();
      if (newValue.isDefined()) {
        return new Slot(this.key, newValue);
      }
      return Item.absent();
    }
    negative() {
      const newValue = this.value.negative();
      if (newValue.isDefined()) {
        return new Slot(this.key, newValue);
      }
      return Item.absent();
    }
    positive() {
      const newValue = this.value.positive();
      if (newValue.isDefined()) {
        return new Slot(this.key, newValue);
      }
      return Item.absent();
    }
    inverse() {
      const newValue = this.value.inverse();
      if (newValue.isDefined()) {
        return new Slot(this.key, newValue);
      }
      return Item.absent();
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const key = this.key.evaluate(interpreter).toValue();
      const value = this.value.evaluate(interpreter).toValue();
      if (key === this.key && value === this.value) {
        return this;
      } else if (key.isDefined() && value.isDefined()) {
        return new Slot(key, value);
      }
      return Item.absent();
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const key = this.key.substitute(interpreter).toValue();
      const value = this.value.substitute(interpreter).toValue();
      if (key === this.key && value === this.value) {
        return this;
      } else if (key.isDefined() && value.isDefined()) {
        return new Slot(key, value);
      }
      return Item.absent();
    }
    toAny() {
      const field = {};
      if (this.key instanceof Text) {
        field[this.key.value] = this.value.toAny();
      } else {
        field.$key = this.key.toAny();
        field.$value = this.value.toAny();
      }
      return field;
    }
    isAliased() {
      return false;
    }
    isMutable() {
      return (this.flags & Field.ImmutableFlag) === 0;
    }
    alias() {
      this.flags |= Field.ImmutableFlag;
    }
    branch() {
      if ((this.flags & Field.ImmutableFlag) !== 0) {
        return new Slot(this.key, this.value, this.flags & ~Field.ImmutableFlag);
      } else {
        return this;
      }
    }
    clone() {
      return new Slot(this.key.clone(), this.value.clone());
    }
    commit() {
      this.flags |= Field.ImmutableFlag;
      this.value.commit();
      return this;
    }
    interpolateTo(that) {
      if (that instanceof Slot) {
        return SlotInterpolator(this, that);
      } else {
        return super.interpolateTo(that);
      }
    }
    get typeOrder() {
      return 2;
    }
    compareTo(that) {
      if (that instanceof Slot) {
        let order = this.key.compareTo(that.key);
        if (order === 0) {
          order = this.value.compareTo(that.value);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof Slot) {
        return this.key.equals(that.key) && this.value.equivalentTo(that.value, epsilon);
      }
      return false;
    }
    keyEquals(key) {
      if (typeof key === "string" && this.key instanceof Text) {
        return this.key.value === key;
      } else if (key instanceof Field) {
        return this.key.equals(key.key);
      } else {
        return this.key.equals(key);
      }
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Slot) {
        return this.key.equals(that.key) && this.value.equals(that.value);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(Slot), this.key.hashCode()), this.value.hashCode()));
    }
    debug(output) {
      output = output.write("Slot").write(46).write("of").write(40).display(this.key);
      if (!(this.value instanceof Extant)) {
        output = output.write(44).write(32).display(this.value);
      }
      output = output.write(41);
      return output;
    }
    static of(key, value) {
      key = Value.fromAny(key);
      if (arguments.length === 1) {
        value = Value.extant();
      } else {
        value = Value.fromAny(value);
      }
      return new Slot(key, value);
    }
  }
  const FieldInterpolator = function(_super) {
    const FieldInterpolator = function(y0, y1) {
      const interpolator = function(u) {
        const key = interpolator.keyInterpolator(u);
        const value = interpolator.valueInterpolator(u);
        return Slot.of(key, value);
      };
      Object.setPrototypeOf(interpolator, FieldInterpolator.prototype);
      interpolator.keyInterpolator = y0.key.interpolateTo(y1.key);
      interpolator.valueInterpolator = y0.value.interpolateTo(y1.value);
      return interpolator;
    };
    FieldInterpolator.prototype = Object.create(_super.prototype);
    FieldInterpolator.prototype.constructor = FieldInterpolator;
    Object.defineProperty(FieldInterpolator.prototype, 0, {
      get() {
        return Slot.of(this.keyInterpolator[0], this.valueInterpolator[0]);
      },
      configurable: true
    });
    Object.defineProperty(FieldInterpolator.prototype, 1, {
      get() {
        return Slot.of(this.keyInterpolator[1], this.valueInterpolator[1]);
      },
      configurable: true
    });
    FieldInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof FieldInterpolator) {
        return this.keyInterpolator.equals(that.keyInterpolator) && this.valueInterpolator.equals(that.valueInterpolator);
      }
      return false;
    };
    return FieldInterpolator;
  }(Interpolator);
  class Attr extends Field {
    constructor(key, value, flags) {
      super();
      this.key = key;
      this.value = value;
      this.flags = flags !== void 0 ? flags : 0;
    }
    isConstant() {
      return this.key.isConstant() && this.value.isConstant();
    }
    get name() {
      return this.key.value;
    }
    setValue(newValue) {
      if ((this.flags & Field.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      }
      const oldValue = this.value;
      this.value = newValue;
      return oldValue;
    }
    updatedValue(value) {
      return new Attr(this.key, value);
    }
    bitwiseOr(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new BitwiseOrOperator(this, that);
      }
      let newValue;
      if (that instanceof Attr && this.key.equals(that.key)) {
        newValue = this.value.bitwiseOr(that.value);
      } else if (that instanceof Value) {
        newValue = this.value.bitwiseOr(that);
      } else {
        newValue = Value.absent();
      }
      if (newValue.isDefined()) {
        return new Attr(this.key, newValue);
      }
      return Item.absent();
    }
    bitwiseXor(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new BitwiseXorOperator(this, that);
      }
      let newValue;
      if (that instanceof Attr && this.key.equals(that.key)) {
        newValue = this.value.bitwiseXor(that.value);
      } else if (that instanceof Value) {
        newValue = this.value.bitwiseXor(that);
      } else {
        newValue = Value.absent();
      }
      if (newValue.isDefined()) {
        return new Attr(this.key, newValue);
      }
      return Item.absent();
    }
    bitwiseAnd(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new BitwiseAndOperator(this, that);
      }
      let newValue;
      if (that instanceof Attr && this.key.equals(that.key)) {
        newValue = this.value.bitwiseAnd(that.value);
      } else if (that instanceof Value) {
        newValue = this.value.bitwiseAnd(that);
      } else {
        newValue = Value.absent();
      }
      if (newValue.isDefined()) {
        return new Attr(this.key, newValue);
      }
      return Item.absent();
    }
    plus(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new PlusOperator(this, that);
      }
      let newValue;
      if (that instanceof Attr && this.key.equals(that.key)) {
        newValue = this.value.plus(that.value);
      } else if (that instanceof Value) {
        newValue = this.value.plus(that);
      } else {
        newValue = Value.absent();
      }
      if (newValue.isDefined()) {
        return new Attr(this.key, newValue);
      }
      return Item.absent();
    }
    minus(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new MinusOperator(this, that);
      }
      let newValue;
      if (that instanceof Attr && this.key.equals(that.key)) {
        newValue = this.value.minus(that.value);
      } else if (that instanceof Value) {
        newValue = this.value.minus(that);
      } else {
        newValue = Value.absent();
      }
      if (newValue.isDefined()) {
        return new Attr(this.key, newValue);
      }
      return Item.absent();
    }
    times(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new TimesOperator(this, that);
      }
      let newValue;
      if (that instanceof Attr && this.key.equals(that.key)) {
        newValue = this.value.times(that.value);
      } else if (that instanceof Value) {
        newValue = this.value.times(that);
      } else {
        newValue = Value.absent();
      }
      if (newValue.isDefined()) {
        return new Attr(this.key, newValue);
      }
      return Item.absent();
    }
    divide(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new DivideOperator(this, that);
      }
      let newValue;
      if (that instanceof Attr && this.key.equals(that.key)) {
        newValue = this.value.divide(that.value);
      } else if (that instanceof Value) {
        newValue = this.value.divide(that);
      } else {
        newValue = Value.absent();
      }
      if (newValue.isDefined()) {
        return new Attr(this.key, newValue);
      }
      return Item.absent();
    }
    modulo(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new ModuloOperator(this, that);
      }
      let newValue;
      if (that instanceof Attr && this.key.equals(that.key)) {
        newValue = this.value.modulo(that.value);
      } else if (that instanceof Value) {
        newValue = this.value.modulo(that);
      } else {
        newValue = Value.absent();
      }
      if (newValue.isDefined()) {
        return new Attr(this.key, newValue);
      }
      return Item.absent();
    }
    not() {
      const newValue = this.value.not();
      if (newValue.isDefined()) {
        return new Attr(this.key, newValue);
      }
      return Item.absent();
    }
    bitwiseNot() {
      const newValue = this.value.bitwiseNot();
      if (newValue.isDefined()) {
        return new Attr(this.key, newValue);
      }
      return Item.absent();
    }
    negative() {
      const newValue = this.value.negative();
      if (newValue.isDefined()) {
        return new Attr(this.key, newValue);
      }
      return Item.absent();
    }
    positive() {
      const newValue = this.value.positive();
      if (newValue.isDefined()) {
        return new Attr(this.key, newValue);
      }
      return Item.absent();
    }
    inverse() {
      const newValue = this.value.inverse();
      if (newValue.isDefined()) {
        return new Attr(this.key, newValue);
      }
      return Item.absent();
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const key = this.key.evaluate(interpreter).toValue();
      const value = this.value.evaluate(interpreter).toValue();
      if (key === this.key && value === this.value) {
        return this;
      } else if (key.isDefined() && value.isDefined()) {
        if (key instanceof Text) {
          return new Attr(key, value);
        } else {
          return new Slot(key, value);
        }
      }
      return Item.absent();
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const key = this.key.substitute(interpreter).toValue();
      const value = this.value.substitute(interpreter).toValue();
      if (key === this.key && value === this.value) {
        return this;
      } else if (key.isDefined() && value.isDefined()) {
        if (key instanceof Text) {
          return new Attr(key, value);
        } else {
          return new Slot(key, value);
        }
      }
      return Item.absent();
    }
    toAny() {
      const field = {};
      field["@" + this.key.value] = this.value.toAny();
      return field;
    }
    isAliased() {
      return false;
    }
    isMutable() {
      return (this.flags & Field.ImmutableFlag) === 0;
    }
    alias() {
      this.flags |= Field.ImmutableFlag;
    }
    branch() {
      if ((this.flags & Field.ImmutableFlag) !== 0) {
        return new Attr(this.key, this.value, this.flags & ~Field.ImmutableFlag);
      } else {
        return this;
      }
    }
    clone() {
      return new Attr(this.key.clone(), this.value.clone());
    }
    commit() {
      this.flags |= Field.ImmutableFlag;
      this.value.commit();
      return this;
    }
    interpolateTo(that) {
      if (that instanceof Attr) {
        return AttrInterpolator(this, that);
      } else {
        return super.interpolateTo(that);
      }
    }
    get typeOrder() {
      return 1;
    }
    compareTo(that) {
      if (that instanceof Attr) {
        let order = this.key.compareTo(that.key);
        if (order === 0) {
          order = this.value.compareTo(that.value);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof Attr) {
        return this.key.equals(that.key) && this.value.equivalentTo(that.value, epsilon);
      }
      return false;
    }
    keyEquals(key) {
      if (typeof key === "string") {
        return this.key.value === key;
      } else if (key instanceof Field) {
        return this.key.equals(key.key);
      } else {
        return this.key.equals(key);
      }
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Attr) {
        return this.key.equals(that.key) && this.value.equals(that.value);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(Attr), this.key.hashCode()), this.value.hashCode()));
    }
    debug(output) {
      output = output.write("Attr").write(46).write("of").write(40).display(this.key);
      if (!(this.value instanceof Extant)) {
        output = output.write(44).write(32).display(this.value);
      }
      output = output.write(41);
      return output;
    }
    static of(key, value) {
      key = Text.fromAny(key);
      if (arguments.length === 1) {
        value = Value.extant();
      } else {
        value = Value.fromAny(value);
      }
      return new Attr(key, value);
    }
  }
  const AttrInterpolator = function(_super) {
    const AttrInterpolator = function(y0, y1) {
      const interpolator = function(u) {
        const key = interpolator.keyInterpolator(u);
        const value = interpolator.valueInterpolator(u);
        return Attr.of(key, value);
      };
      Object.setPrototypeOf(interpolator, AttrInterpolator.prototype);
      interpolator.keyInterpolator = y0.key.interpolateTo(y1.key);
      interpolator.valueInterpolator = y0.value.interpolateTo(y1.value);
      return interpolator;
    };
    AttrInterpolator.prototype = Object.create(_super.prototype);
    AttrInterpolator.prototype.constructor = AttrInterpolator;
    Object.defineProperty(AttrInterpolator.prototype, 0, {
      get() {
        return Attr.of(this.keyInterpolator[0], this.valueInterpolator[0]);
      },
      configurable: true
    });
    Object.defineProperty(AttrInterpolator.prototype, 1, {
      get() {
        return Attr.of(this.keyInterpolator[1], this.valueInterpolator[1]);
      },
      configurable: true
    });
    AttrInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof AttrInterpolator) {
        return this.keyInterpolator.equals(that.keyInterpolator) && this.valueInterpolator.equals(that.valueInterpolator);
      }
      return false;
    };
    return AttrInterpolator;
  }(Interpolator);
  const SlotInterpolator = function(_super) {
    const SlotInterpolator = function(y0, y1) {
      const interpolator = function(u) {
        const key = interpolator.keyInterpolator(u);
        const value = interpolator.valueInterpolator(u);
        return Slot.of(key, value);
      };
      Object.setPrototypeOf(interpolator, SlotInterpolator.prototype);
      interpolator.keyInterpolator = y0.key.interpolateTo(y1.key);
      interpolator.valueInterpolator = y0.value.interpolateTo(y1.value);
      return interpolator;
    };
    SlotInterpolator.prototype = Object.create(_super.prototype);
    SlotInterpolator.prototype.constructor = SlotInterpolator;
    Object.defineProperty(SlotInterpolator.prototype, 0, {
      get() {
        return Slot.of(this.keyInterpolator[0], this.valueInterpolator[0]);
      },
      configurable: true
    });
    Object.defineProperty(SlotInterpolator.prototype, 1, {
      get() {
        return Slot.of(this.keyInterpolator[1], this.valueInterpolator[1]);
      },
      configurable: true
    });
    SlotInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof SlotInterpolator) {
        return this.keyInterpolator.equals(that.keyInterpolator) && this.valueInterpolator.equals(that.valueInterpolator);
      }
      return false;
    };
    return SlotInterpolator;
  }(Interpolator);
  class Value extends Item {
    constructor() {
      super();
    }
    isDefined() {
      return true;
    }
    isDistinct() {
      return true;
    }
    isDefinite() {
      return true;
    }
    get key() {
      return Value.absent();
    }
    toValue() {
      return this;
    }
    get tag() {
      return void 0;
    }
    get target() {
      return this;
    }
    flattened() {
      return this;
    }
    unflattened() {
      return Record.of(this);
    }
    header(tag) {
      return Value.absent();
    }
    headers(tag) {
      return void 0;
    }
    head() {
      return Item.absent();
    }
    tail() {
      return Record.empty();
    }
    body() {
      return Value.extant();
    }
    get length() {
      return 0;
    }
    has(key) {
      return false;
    }
    get(key) {
      return Value.absent();
    }
    getAttr(key) {
      return Value.absent();
    }
    getSlot(key) {
      return Value.absent();
    }
    getField(key) {
      return void 0;
    }
    getItem(index) {
      return Item.absent();
    }
    deleted(key) {
      return this;
    }
    conditional(thenTerm, elseTerm) {
      thenTerm = Item.fromAny(thenTerm);
      return thenTerm;
    }
    or(that) {
      return this;
    }
    and(that) {
      that = Item.fromAny(that);
      return that;
    }
    bitwiseOr(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new BitwiseOrOperator(this, that);
      } else if (that instanceof Attr) {
        const newValue = this.bitwiseOr(that.value);
        if (newValue.isDefined()) {
          return new Attr(that.key, newValue);
        }
      } else if (that instanceof Slot) {
        const newValue = this.bitwiseOr(that.value);
        if (newValue.isDefined()) {
          return new Slot(that.key, newValue);
        }
      }
      return Item.absent();
    }
    bitwiseXor(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new BitwiseXorOperator(this, that);
      } else if (that instanceof Attr) {
        const newValue = this.bitwiseXor(that.value);
        if (newValue.isDefined()) {
          return new Attr(that.key, newValue);
        }
      } else if (that instanceof Slot) {
        const newValue = this.bitwiseXor(that.value);
        if (newValue.isDefined()) {
          return new Slot(that.key, newValue);
        }
      }
      return Item.absent();
    }
    bitwiseAnd(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new BitwiseAndOperator(this, that);
      } else if (that instanceof Attr) {
        const newValue = this.bitwiseAnd(that.value);
        if (newValue.isDefined()) {
          return new Attr(that.key, newValue);
        }
      } else if (that instanceof Slot) {
        const newValue = this.bitwiseAnd(that.value);
        if (newValue.isDefined()) {
          return new Slot(that.key, newValue);
        }
      }
      return Item.absent();
    }
    lt(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new LtOperator(this, that);
      }
      return super.lt(that);
    }
    le(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new LeOperator(this, that);
      }
      return super.le(that);
    }
    eq(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new EqOperator(this, that);
      }
      return super.eq(that);
    }
    ne(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new NeOperator(this, that);
      }
      return super.ne(that);
    }
    ge(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new GeOperator(this, that);
      }
      return super.ge(that);
    }
    gt(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new GtOperator(this, that);
      }
      return super.gt(that);
    }
    plus(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new PlusOperator(this, that);
      } else if (that instanceof Attr) {
        const newValue = this.plus(that.value);
        if (newValue.isDefined()) {
          return new Attr(that.key, newValue);
        }
      } else if (that instanceof Slot) {
        const newValue = this.plus(that.value);
        if (newValue.isDefined()) {
          return new Slot(that.key, newValue);
        }
      }
      return Item.absent();
    }
    minus(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new MinusOperator(this, that);
      } else if (that instanceof Attr) {
        const newValue = this.minus(that.value);
        if (newValue.isDefined()) {
          return new Attr(that.key, newValue);
        }
      } else if (that instanceof Slot) {
        const newValue = this.minus(that.value);
        if (newValue.isDefined()) {
          return new Slot(that.key, newValue);
        }
      }
      return Item.absent();
    }
    times(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new TimesOperator(this, that);
      } else if (that instanceof Attr) {
        const newValue = this.times(that.value);
        if (newValue.isDefined()) {
          return new Attr(that.key, newValue);
        }
      } else if (that instanceof Slot) {
        const newValue = this.times(that.value);
        if (newValue.isDefined()) {
          return new Slot(that.key, newValue);
        }
      }
      return Item.absent();
    }
    divide(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new DivideOperator(this, that);
      } else if (that instanceof Attr) {
        const newValue = this.divide(that.value);
        if (newValue.isDefined()) {
          return new Attr(that.key, newValue);
        }
      } else if (that instanceof Slot) {
        const newValue = this.divide(that.value);
        if (newValue.isDefined()) {
          return new Slot(that.key, newValue);
        }
      }
      return Item.absent();
    }
    modulo(that) {
      that = Item.fromAny(that);
      if (that instanceof Expression) {
        return new ModuloOperator(this, that);
      } else if (that instanceof Attr) {
        const newValue = this.modulo(that.value);
        if (newValue.isDefined()) {
          return new Attr(that.key, newValue);
        }
      } else if (that instanceof Slot) {
        const newValue = this.modulo(that.value);
        if (newValue.isDefined()) {
          return new Slot(that.key, newValue);
        }
      }
      return Item.absent();
    }
    not() {
      return Value.absent();
    }
    bitwiseNot() {
      return Value.absent();
    }
    negative() {
      return Value.absent();
    }
    positive() {
      return Value.absent();
    }
    inverse() {
      return Value.absent();
    }
    lambda(template) {
      return new LambdaFunc(this, template);
    }
    stringValue(orElse) {
      return orElse;
    }
    numberValue(orElse) {
      return orElse;
    }
    booleanValue(orElse) {
      return orElse;
    }
    isAliased() {
      return false;
    }
    isMutable() {
      return false;
    }
    alias() {}
    branch() {
      return this;
    }
    clone() {
      return this;
    }
    commit() {
      return this;
    }
    interpolateTo(that) {
      return super.interpolateTo(that);
    }
    keyEquals(key) {
      return false;
    }
    static builder() {
      return new ValueBuilder;
    }
    static empty() {
      return Record.empty();
    }
    static extant() {
      return Extant.extant();
    }
    static absent() {
      return Absent.absent();
    }
    static fromAny(value) {
      if (value instanceof Value) {
        return value;
      } else if (value === void 0) {
        return Absent.absent();
      } else if (value === null) {
        return Extant.extant();
      } else if (typeof value === "boolean") {
        return Bool.from(value);
      } else if (typeof value === "number") {
        return Num.from(value);
      } else if (typeof value === "string") {
        return Text.from(value);
      } else if (value instanceof Uint8Array) {
        return Data.wrap(value);
      } else if (Array.isArray(value)) {
        return Record.fromArray(value);
      } else if (typeof value === "object") {
        return Record.fromObject(value);
      } else {
        throw new TypeError("" + value);
      }
    }
  }
  class Record extends Value {
    constructor() {
      super();
    }
    isDefinite() {
      return !this.isEmpty();
    }
    isArray() {
      return this.fieldCount === 0;
    }
    isObject() {
      return this.valueCount === 0;
    }
    get valueCount() {
      let count = 0;
      this.forEach((function(member) {
        if (member instanceof Value) {
          count += 1;
        }
      }), this);
      return count;
    }
    isConstant() {
      return this.forEach((function(member) {
        return member.isConstant() ? void 0 : false;
      }), this) === void 0;
    }
    get tag() {
      const item = this.head();
      if (item instanceof Attr) {
        return item.key.value;
      }
      return void 0;
    }
    get target() {
      let value;
      let record;
      let modified = false;
      this.forEach((function(item) {
        if (item instanceof Attr) {
          modified = true;
        } else if (value === void 0 && item instanceof Value) {
          value = item;
        } else {
          if (record === void 0) {
            record = Record.create();
            if (value !== void 0) {
              record.push(value);
            }
          }
          record.push(item);
        }
      }), this);
      if (value === void 0) {
        return Value.extant();
      } else if (record === void 0) {
        return value;
      } else if (modified) {
        return record;
      } else {
        return this;
      }
    }
    flattened() {
      if (this.isEmpty()) {
        return Value.extant();
      } else {
        const items = this.iterator();
        const head = items.head();
        items.step();
        if (items.isEmpty() && head instanceof Value) {
          return head;
        } else {
          return this.branch();
        }
      }
    }
    unflattened() {
      return this;
    }
    header(tag) {
      const head = this.head();
      if (head instanceof Attr && head.key.value === tag) {
        return head.value;
      } else {
        return Value.absent();
      }
    }
    headers(tag) {
      const head = this.head();
      if (head instanceof Attr && head.key.value === tag) {
        const header = head.value;
        if (header instanceof Record) {
          return header;
        } else {
          return Record.of(header);
        }
      }
      return void 0;
    }
    head() {
      return this.forEach((function(item) {
        return item;
      }), this) || Item.absent();
    }
    tail() {
      const tail = Record.create();
      this.forEach((function(item, index) {
        if (index > 0) {
          tail.push(item);
        }
      }), this);
      return tail;
    }
    body() {
      const tail = this.tail();
      if (!tail.isEmpty()) {
        return tail.flattened();
      } else {
        return Value.absent();
      }
    }
    has(key) {
      key = Value.fromAny(key);
      return this.forEach((function(item) {
        return item instanceof Field && item.key.equals(key) ? true : void 0;
      }), this) || false;
    }
    indexOf(item, index = 0) {
      item = Item.fromAny(item);
      if (index < 0) {
        index = Math.max(0, this.length + index);
      }
      const i = this.forEach((function(member, i) {
        return i >= index && item.equals(member) ? i : void 0;
      }), this);
      return i !== void 0 ? i : -1;
    }
    lastIndexOf(item, index) {
      item = Item.fromAny(item);
      const n = this.length;
      if (index === void 0) {
        index = n - 1;
      } else if (index < 0) {
        index = n + index;
      }
      index = Math.min(index, n - 1);
      while (index >= 0) {
        if (item.equals(this.getItem(index))) {
          return index;
        }
        index -= 1;
      }
      return -1;
    }
    get(key) {
      key = Value.fromAny(key);
      return this.forEach((function(item) {
        return item instanceof Field && item.key.equals(key) ? item.value : void 0;
      }), this) || Value.absent();
    }
    getAttr(key) {
      key = Text.fromAny(key);
      return this.forEach((function(item) {
        return item instanceof Attr && item.key.equals(key) ? item.value : void 0;
      }), this) || Value.absent();
    }
    getSlot(key) {
      key = Value.fromAny(key);
      return this.forEach((function(item) {
        return item instanceof Slot && item.key.equals(key) ? item.value : void 0;
      }), this) || Value.absent();
    }
    getField(key) {
      key = Value.fromAny(key);
      return this.forEach((function(item) {
        return item instanceof Field && item.key.equals(key) ? item : void 0;
      }), this);
    }
    set(key, newValue) {
      key = Value.fromAny(key);
      newValue = Value.fromAny(newValue);
      const items = this.iterator();
      while (!items.isEmpty()) {
        const item = items.head();
        if (item instanceof Field && item.key.equals(key)) {
          if (item.isMutable()) {
            item.setValue(newValue);
          } else {
            items.set(item.updatedValue(newValue));
          }
          return this;
        }
        items.step();
      }
      this.push(new Slot(key, newValue));
      return this;
    }
    setAttr(key, newValue) {
      key = Text.fromAny(key);
      newValue = Value.fromAny(newValue);
      const items = this.iterator();
      while (!items.isEmpty()) {
        const item = items.head();
        if (item instanceof Field && item.key.equals(key)) {
          if (item instanceof Attr && item.isMutable()) {
            item.setValue(newValue);
          } else {
            items.set(new Attr(key, newValue));
          }
          return this;
        }
        items.step();
      }
      this.push(new Attr(key, newValue));
      return this;
    }
    setSlot(key, newValue) {
      key = Value.fromAny(key);
      newValue = Value.fromAny(newValue);
      const items = this.iterator();
      while (!items.isEmpty()) {
        const item = items.head();
        if (item instanceof Field && item.key.equals(key)) {
          if (item instanceof Slot && item.isMutable()) {
            item.setValue(newValue);
          } else {
            items.set(new Slot(key, newValue));
          }
          return this;
        }
        items.step();
      }
      this.push(new Slot(key, newValue));
      return this;
    }
    updated(key, value) {
      key = Value.fromAny(key);
      value = Value.fromAny(value);
      const record = this.isMutable() ? this : this.branch();
      const items = record.iterator();
      while (!items.isEmpty()) {
        const item = items.head();
        if (item.key.equals(key)) {
          if (item instanceof Field && item.isMutable()) {
            item.setValue(value);
          } else {
            items.set(new Slot(key, value));
          }
          return record;
        }
        items.step();
      }
      record.push(new Slot(key, value));
      return record;
    }
    updatedAttr(key, value) {
      key = Text.fromAny(key);
      value = Value.fromAny(value);
      const record = this.isMutable() ? this : this.branch();
      const items = record.iterator();
      while (!items.isEmpty()) {
        const item = items.head();
        if (item.key.equals(key)) {
          if (item instanceof Attr && item.isMutable()) {
            item.setValue(value);
          } else {
            items.set(new Attr(key, value));
          }
          return record;
        }
        items.step();
      }
      record.push(new Attr(key, value));
      return record;
    }
    updatedSlot(key, value) {
      key = Value.fromAny(key);
      value = Value.fromAny(value);
      const record = this.isMutable() ? this : this.branch();
      const items = record.iterator();
      while (!items.isEmpty()) {
        const item = items.head();
        if (item.key.equals(key)) {
          if (item instanceof Slot && item.isMutable()) {
            item.setValue(value);
          } else {
            items.set(new Slot(key, value));
          }
          return record;
        }
        items.step();
      }
      record.push(new Slot(key, value));
      return record;
    }
    appended(...items) {
      const record = this.isMutable() ? this : this.branch();
      record.push(...items);
      return record;
    }
    prepended(...items) {
      const record = this.isMutable() ? this : this.branch();
      record.splice(0, 0, ...items);
      return record;
    }
    deleted(key) {
      const record = this.isMutable() ? this : this.branch();
      record.delete(key);
      return record;
    }
    concat(...items) {
      const record = this.isMutable() ? this : this.branch();
      for (let i = 0, n = items.length; i < n; i += 1) {
        Item.fromAny(items[i]).forEach((function(item) {
          record.push(item);
        }));
      }
      return record;
    }
    slice(lower, upper) {
      return this.subRecord(lower, upper).branch();
    }
    attr(key, value) {
      let field;
      if (arguments.length === 1) {
        field = Attr.of(key);
      } else {
        field = Attr.of(key, value);
      }
      this.push(field);
      return this;
    }
    slot(key, value) {
      let field;
      if (arguments.length === 1) {
        field = Slot.of(key);
      } else {
        field = Slot.of(key, value);
      }
      this.push(field);
      return this;
    }
    item(item) {
      this.push(item);
      return this;
    }
    items(...items) {
      this.push(this, ...items);
      return this;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const scope = Record.create();
      interpreter.pushScope(scope);
      let changed = false;
      this.forEach((function(oldItem) {
        const newItem = oldItem.evaluate(interpreter);
        if (newItem.isDefined()) {
          scope.push(newItem);
        }
        if (oldItem !== newItem) {
          changed = true;
        }
      }), this);
      interpreter.popScope();
      return changed ? scope : this;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const scope = Record.create();
      interpreter.pushScope(scope);
      let changed = false;
      this.forEach((function(oldItem) {
        const newItem = oldItem.substitute(interpreter);
        if (newItem.isDefined()) {
          scope.push(newItem);
        }
        if (oldItem !== newItem) {
          changed = true;
        }
      }), this);
      interpreter.popScope();
      return changed ? scope : this;
    }
    stringValue(orElse) {
      let recordString = "";
      const defined = this.forEach((function(item) {
        if (item instanceof Value) {
          const itemString = item.stringValue();
          if (itemString !== void 0) {
            recordString += itemString;
            return;
          }
        }
        return null;
      }), this) === void 0;
      return defined ? recordString : void 0;
    }
    toAny() {
      if (!this.isEmpty() && this.isArray()) {
        return this.toArray();
      } else {
        return this.toObject();
      }
    }
    toArray() {
      const array = new Array(this.length);
      this.forEach((function(item, index) {
        if (item instanceof Value) {
          array[index] = item.toAny();
        } else if (item instanceof Field) {
          array[index] = {
            $key: item.key.toAny(),
            $value: item.value.toAny()
          };
        }
      }), this);
      return array;
    }
    toObject() {
      const object = {};
      this.forEach((function(item, index) {
        if (item instanceof Attr) {
          object["@" + item.key.value] = item.value.toAny();
        } else if (item instanceof Slot) {
          if (item.key instanceof Text) {
            object[item.key.value] = item.value.toAny();
          } else {
            object["$" + index] = {
              $key: item.key.toAny(),
              $value: item.value.toAny()
            };
          }
        } else if (item instanceof Value) {
          object["$" + index] = item.toAny();
        }
      }), this);
      return object;
    }
    isAliased() {
      return false;
    }
    isMutable() {
      return true;
    }
    alias() {}
    branch() {
      const branch = Record.create();
      this.forEach((function(item) {
        branch.push(item);
      }), this);
      return branch;
    }
    clone() {
      const clone = Record.create();
      this.forEach((function(item) {
        clone.push(item.clone());
      }), this);
      return clone;
    }
    commit() {
      return this;
    }
    bind() {
      return this;
    }
    subRecord(lower, upper) {
      const n = this.length;
      if (lower === void 0) {
        lower = 0;
      } else if (lower < 0) {
        lower = n + lower;
      }
      lower = Math.min(Math.max(0, lower), n);
      if (upper === void 0) {
        upper = n;
      } else if (upper < 0) {
        upper = n + upper;
      }
      const record = Record.create();
      this.forEach((function(item, index) {
        if (index < lower) {
          return;
        } else if (index < upper) {
          record.push(item);
          return;
        } else {
          return null;
        }
      }), this);
      return record;
    }
    iterator() {
      return new RecordCursor(this);
    }
    interpolateTo(that) {
      if (that instanceof Record) {
        return RecordInterpolator(this, that);
      } else {
        return super.interpolateTo(that);
      }
    }
    get typeOrder() {
      return 3;
    }
    compareTo(that) {
      if (that instanceof Record) {
        const xs = this.iterator();
        const ys = that.iterator();
        let order = 0;
        do {
          if (!xs.isEmpty() && !ys.isEmpty()) {
            order = xs.head().compareTo(ys.head());
            xs.step();
            ys.step();
          } else {
            break;
          }
        } while (order === 0);
        if (order !== 0) {
          return order;
        } else if (xs.isEmpty() && !ys.isEmpty()) {
          return -1;
        } else if (!xs.isEmpty() && ys.isEmpty()) {
          return 1;
        } else {
          return 0;
        }
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof Record) {
        const xs = this.iterator();
        const ys = that.iterator();
        while (!xs.isEmpty() && !ys.isEmpty()) {
          if (!xs.head().equivalentTo(ys.head(), epsilon)) {
            return false;
          }
          xs.step();
          ys.step();
        }
        return xs.isEmpty() && ys.isEmpty();
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Record) {
        const xs = this.iterator();
        const ys = that.iterator();
        while (!xs.isEmpty() && !ys.isEmpty()) {
          if (!xs.head().equals(ys.head())) {
            return false;
          }
          xs.step();
          ys.step();
        }
        return xs.isEmpty() && ys.isEmpty();
      }
      return false;
    }
    hashCode() {
      let hashValue = Constructors.hash(Record);
      this.forEach((function(item) {
        hashValue = Murmur3.mix(hashValue, item.hashCode());
      }), this);
      return hashValue;
    }
    debug(output) {
      output = output.write("Record").write(46);
      if (this.isEmpty()) {
        output = output.write("empty").write(40).write(41);
      } else {
        output = output.write("of").write(40);
        this.forEach((function(item, index) {
          if (index !== 0) {
            output = output.write(44).write(32);
          }
          output = output.display(item);
        }), this);
        output = output.write(41);
      }
      return output;
    }
    static empty() {
      return RecordMap.empty();
    }
    static create(initialCapacity) {
      return RecordMap.create(initialCapacity);
    }
    static of(...items) {
      return RecordMap.of(...items);
    }
    static fromAny(value) {
      if (value instanceof Record) {
        return value;
      } else if (Array.isArray(value)) {
        return Record.fromArray(value);
      } else if (typeof value === "object" && value !== null) {
        return Record.fromObject(value);
      } else {
        throw new TypeError("" + value);
      }
    }
    static fromArray(array) {
      const n = array.length || 0;
      const record = Record.create(n);
      for (let i = 0; i < n; i += 1) {
        record.push(Item.fromAny(array[i]));
      }
      return record;
    }
    static fromObject(object) {
      const record = Record.create();
      for (const key in object) {
        const value = object[key];
        if (key.charCodeAt(0) === 36) {
          if (!value || typeof value !== "object" || !Object.prototype.hasOwnProperty.call(value, "$key")) {
            record.push(Value.fromAny(value));
          } else {
            record.push(Field.of(value.$key, value.$value));
          }
        } else {
          record.push(Field.of(key, value));
        }
      }
      return record;
    }
    static expand(n) {
      n = Math.max(8, n) - 1;
      n |= n >> 1;
      n |= n >> 2;
      n |= n >> 4;
      n |= n >> 8;
      n |= n >> 16;
      return n + 1;
    }
  }
  Record.AliasedFlag = 1;
  Record.ImmutableFlag = 2;
  Object.defineProperty(Record.prototype, "fieldCount", {
    get() {
      let count = 0;
      this.forEach((function(member) {
        if (member instanceof Field) {
          count += 1;
        }
      }), this);
      return count;
    },
    configurable: true
  });
  class ValueBuilder {
    constructor() {
      this.record = null;
      this.value = null;
    }
    push(...items) {
      for (let i = 0, n = items.length; i < n; i += 1) {
        const item = items[i];
        if (item instanceof Field) {
          return this.pushField(item);
        } else if (item instanceof Value) {
          return this.pushValue(item);
        } else {
          throw new TypeError("" + item);
        }
      }
    }
    pushField(item) {
      if (this.record === null) {
        this.record = Record.create();
        if (this.value !== null) {
          this.record.push(this.value);
          this.value = null;
        }
      }
      this.record.push(item);
    }
    pushValue(item) {
      if (this.record !== null) {
        this.record.push(item);
      } else if (this.value === null) {
        this.value = item;
      } else {
        this.record = Record.create();
        this.record.push(this.value);
        this.value = null;
        this.record.push(item);
      }
    }
    bind() {
      if (this.record !== null) {
        return this.record;
      } else if (this.value !== null) {
        return this.value;
      } else {
        return Value.absent();
      }
    }
  }
  const RecordInterpolator = function(_super) {
    const RecordInterpolator = function(y0, y1) {
      const interpolator = function(u) {
        const interpolators = interpolator.interpolators;
        const interpolatorCount = interpolators.length;
        const record = Record.create(interpolatorCount);
        for (let i = 0; i < interpolatorCount; i += 1) {
          record.push(interpolators[i](u));
        }
        return record;
      };
      Object.setPrototypeOf(interpolator, RecordInterpolator.prototype);
      const interpolatorCount = Math.min(y0.length, y1.length);
      const interpolators = new Array(interpolatorCount);
      for (let i = 0; i < interpolatorCount; i += 1) {
        interpolators[i] = y0.getItem(i).interpolateTo(y1.getItem(i));
      }
      interpolator.interpolators = interpolators;
      return interpolator;
    };
    RecordInterpolator.prototype = Object.create(_super.prototype);
    RecordInterpolator.prototype.constructor = RecordInterpolator;
    Object.defineProperty(RecordInterpolator.prototype, 0, {
      get() {
        const interpolators = this.interpolators;
        const interpolatorCount = interpolators.length;
        const record = Record.create(interpolatorCount);
        for (let i = 0; i < interpolatorCount; i += 1) {
          record.push(interpolators[i][0]);
        }
        return record;
      },
      configurable: true
    });
    Object.defineProperty(RecordInterpolator.prototype, 1, {
      get() {
        const interpolators = this.interpolators;
        const interpolatorCount = interpolators.length;
        const record = Record.create(interpolatorCount);
        for (let i = 0; i < interpolatorCount; i += 1) {
          record.push(interpolators[i][1]);
        }
        return record;
      },
      configurable: true
    });
    RecordInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof RecordInterpolator) {
        const n = this.interpolators.length;
        if (n === that.interpolators.length) {
          for (let i = 0; i < n; i += 1) {
            if (!this.interpolators[i].equals(that.interpolators[i])) {
              return false;
            }
          }
          return true;
        }
      }
      return false;
    };
    return RecordInterpolator;
  }(Interpolator);
  class RecordCursor extends Cursor {
    constructor(record, lower, upper, index) {
      super();
      if (lower === void 0) {
        lower = 0;
      }
      if (upper === void 0) {
        upper = record.length;
      }
      if (index === void 0) {
        index = lower;
      }
      this.record = record;
      this.lower = lower;
      this.upper = upper;
      this.index = index;
      this.direction = 0;
    }
    isEmpty() {
      return this.index >= this.upper;
    }
    head() {
      this.direction = 0;
      if (this.index < this.upper) {
        return this.record.getItem(this.index);
      } else {
        throw new Error("empty");
      }
    }
    step() {
      this.direction = 0;
      const index = this.index;
      if (index < this.upper) {
        this.index = index + 1;
      } else {
        throw new Error("empty");
      }
    }
    skip(count) {
      this.index = Math.min(Math.max(this.lower, this.index + count, this.upper));
    }
    hasNext() {
      return this.index < this.upper;
    }
    nextIndex() {
      return this.index - this.lower;
    }
    next() {
      this.direction = 1;
      const index = this.index;
      if (index < this.upper) {
        this.index = index + 1;
        return {
          value: this.record.getItem(index),
          done: this.index === this.upper
        };
      } else {
        this.index = this.upper;
        return {
          done: true
        };
      }
    }
    hasPrevious() {
      return this.index > this.lower;
    }
    previousIndex() {
      return this.index - this.lower - 1;
    }
    previous() {
      this.direction = -1;
      const index = this.index - 1;
      if (index >= this.lower) {
        this.index = index;
        return {
          value: this.record.getItem(index),
          done: index === this.lower
        };
      } else {
        this.index = 0;
        return {
          done: true
        };
      }
    }
    set(newItem) {
      if (this.direction > 0) {
        this.record.setItem(this.index - 1, newItem);
      } else {
        this.record.setItem(this.index, newItem);
      }
    }
    delete() {
      let index = this.index;
      if (this.direction > 0) {
        index -= 1;
        this.index = index;
      }
      this.record.splice(index, 1);
      this.direction = 0;
    }
  }
  class RecordMap extends Record {
    constructor(array, table, length, fieldCount, flags) {
      super();
      this.array = array;
      this.table = table;
      Object.defineProperty(this, "length", {
        value: length,
        writable: true,
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(this, "fieldCount", {
        value: fieldCount,
        writable: true,
        enumerable: true,
        configurable: true
      });
      this.flags = flags;
    }
    isEmpty() {
      return this.length === 0;
    }
    get valueCount() {
      return this.length - this.fieldCount;
    }
    isConstant() {
      const array = this.array;
      for (let i = 0, n = this.length; i < n; i += 1) {
        if (!array[i].isConstant()) {
          return false;
        }
      }
      return true;
    }
    get tag() {
      if (this.fieldCount > 0) {
        const head = this.array[0];
        if (head instanceof Attr) {
          return head.key.value;
        }
      }
      return void 0;
    }
    get target() {
      let value;
      let record;
      let modified = false;
      const array = this.array;
      for (let i = 0, n = this.length; i < n; i += 1) {
        const item = array[i];
        if (item instanceof Attr) {
          modified = true;
        } else if (value === void 0 && item instanceof Value) {
          value = item;
        } else {
          if (record === void 0) {
            record = Record.create();
            if (value !== void 0) {
              record.push(value);
            }
          }
          record.push(item);
        }
      }
      if (value === void 0) {
        return Value.extant();
      } else if (record === void 0) {
        return value;
      } else if (modified) {
        return record;
      } else {
        return this;
      }
    }
    head() {
      if (this.length > 0) {
        return this.array[0];
      }
      return Item.absent();
    }
    tail() {
      const n = this.length;
      if (n > 0) {
        return new RecordMapView(this, 1, n);
      } else {
        return Record.empty();
      }
    }
    body() {
      const n = this.length;
      if (n > 2) {
        return new RecordMapView(this, 1, n).branch();
      } else if (n === 2) {
        const item = this.array[1];
        if (item instanceof Value) {
          return item;
        } else {
          return Record.of(item);
        }
      }
      return Value.absent();
    }
    has(key) {
      if (this.fieldCount !== 0) {
        key = Value.fromAny(key);
        const table = this.hashTable();
        const n = table.length;
        const x = Math.abs(key.hashCode() % n);
        let i = x;
        do {
          const field = table[i];
          if (field !== void 0) {
            if (field.key.equals(key)) {
              return true;
            }
          } else {
            break;
          }
          i = (i + 1) % n;
        } while (i !== x);
      }
      return false;
    }
    indexOf(item, index = 0) {
      item = Item.fromAny(item);
      const array = this.array;
      const n = this.length;
      if (index < 0) {
        index = Math.max(0, n + index);
      }
      while (index < n) {
        if (item.equals(array[index])) {
          return index;
        }
        index += 1;
      }
      return -1;
    }
    lastIndexOf(item, index) {
      item = Item.fromAny(item);
      const array = this.array;
      const n = this.length;
      if (index === void 0) {
        index = n - 1;
      } else if (index < 0) {
        index = n + index;
      }
      index = Math.min(index, n - 1);
      while (index >= 0) {
        if (item.equals(array[index])) {
          return index;
        }
        index -= 1;
      }
      return -1;
    }
    get(key) {
      if (this.fieldCount > 0) {
        key = Value.fromAny(key);
        const table = this.hashTable();
        const n = table.length;
        const x = Math.abs(key.hashCode() % n);
        let i = x;
        do {
          const field = table[i];
          if (field !== void 0) {
            if (field.key.equals(key)) {
              return field.value;
            }
          } else {
            break;
          }
          i = (i + 1) % n;
        } while (i !== x);
      }
      return Value.absent();
    }
    getAttr(key) {
      if (this.fieldCount > 0) {
        key = Text.fromAny(key);
        const table = this.hashTable();
        const n = table.length;
        const x = Math.abs(key.hashCode() % n);
        let i = x;
        do {
          const field = table[i];
          if (field !== void 0) {
            if (field instanceof Attr && field.key.equals(key)) {
              return field.value;
            }
          } else {
            break;
          }
          i = (i + 1) % n;
        } while (i !== x);
      }
      return Value.absent();
    }
    getSlot(key) {
      if (this.fieldCount > 0) {
        key = Value.fromAny(key);
        const table = this.hashTable();
        const n = table.length;
        const x = Math.abs(key.hashCode() % n);
        let i = x;
        do {
          const field = table[i];
          if (field !== void 0) {
            if (field instanceof Slot && field.key.equals(key)) {
              return field.value;
            }
          } else {
            break;
          }
          i = (i + 1) % n;
        } while (i !== x);
      }
      return Value.absent();
    }
    getField(key) {
      if (this.fieldCount > 0) {
        key = Value.fromAny(key);
        const table = this.hashTable();
        const n = table.length;
        const x = Math.abs(key.hashCode() % n);
        let i = x;
        do {
          const field = table[i];
          if (field !== void 0) {
            if (field.key.equals(key)) {
              return field;
            }
          } else {
            break;
          }
          i = (i + 1) % n;
        } while (i !== x);
      }
      return void 0;
    }
    getItem(index) {
      if (index instanceof Num) {
        index = index.value;
      }
      const n = this.length;
      if (index < 0) {
        index = n + index;
      }
      if (index >= 0 && index < n) {
        return this.array[index];
      } else {
        return Item.absent();
      }
    }
    set(key, newValue) {
      if ((this.flags & Record.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      }
      key = Value.fromAny(key);
      newValue = Value.fromAny(newValue);
      if ((this.flags & Record.AliasedFlag) !== 0) {
        if (this.fieldCount > 0) {
          this.setAliased(key, newValue);
        } else {
          this.pushAliased(new Slot(key, newValue));
        }
      } else {
        if (this.fieldCount > 0) {
          if (this.table !== null) {
            this.setMutable(key, newValue);
          } else {
            this.updateMutable(key, newValue);
          }
        } else {
          this.pushMutable(new Slot(key, newValue));
        }
      }
      return this;
    }
    setAliased(key, newValue) {
      const n = this.length;
      const oldArray = this.array;
      const newArray = new Array(Record.expand(n + 1));
      for (let i = 0; i < n; i += 1) {
        const item = oldArray[i];
        if (item instanceof Field && item.key.equals(key)) {
          newArray[i] = item.updatedValue(newValue);
          i += 1;
          while (i < n) {
            newArray[i] = oldArray[i];
            i += 1;
          }
          this.array = newArray;
          this.table = null;
          this.flags &= ~Record.AliasedFlag;
          return;
        }
        newArray[i] = item;
      }
      newArray[n] = new Slot(key, newValue);
      this.array = newArray;
      this.table = null;
      this.length = n + 1;
      this.fieldCount += 1;
      this.flags &= ~Record.AliasedFlag;
    }
    setMutable(key, newValue) {
      const table = this.table;
      const n = table.length;
      const x = Math.abs(key.hashCode() % n);
      let i = x;
      do {
        const field = table[i];
        if (field !== void 0) {
          if (field.key.equals(key)) {
            if (field.isMutable()) {
              field.setValue(newValue);
              return;
            } else {
              this.updateMutable(key, newValue);
              return;
            }
          }
        } else {
          break;
        }
        i = (i + 1) % n;
      } while (i !== x);
      const field = new Slot(key, newValue);
      this.pushMutable(field);
      RecordMap.put(table, field);
    }
    updateMutable(key, newValue) {
      const array = this.array;
      for (let i = 0, n = this.length; i < n; i += 1) {
        const item = array[i];
        if (item instanceof Field && item.key.equals(key)) {
          array[i] = item.updatedValue(newValue);
          this.table = null;
          return;
        }
      }
      const field = new Slot(key, newValue);
      this.pushMutable(field);
      RecordMap.put(this.table, field);
    }
    setAttr(key, newValue) {
      if ((this.flags & Record.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      }
      key = Text.fromAny(key);
      newValue = Value.fromAny(newValue);
      if ((this.flags & Record.AliasedFlag) !== 0) {
        if (this.fieldCount > 0) {
          this.setAttrAliased(key, newValue);
        } else {
          this.pushAliased(new Attr(key, newValue));
        }
      } else {
        if (this.fieldCount > 0) {
          if (this.table !== null) {
            this.setAttrMutable(key, newValue);
          } else {
            this.updateAttrMutable(key, newValue);
          }
        } else {
          this.pushMutable(new Attr(key, newValue));
        }
      }
      return this;
    }
    setAttrAliased(key, newValue) {
      const n = this.length;
      const oldArray = this.array;
      const newArray = new Array(Record.expand(n + 1));
      for (let i = 0; i < n; i += 1) {
        const item = oldArray[i];
        if (item instanceof Field && item.key.equals(key)) {
          newArray[i] = new Attr(key, newValue);
          i += 1;
          while (i < n) {
            newArray[i] = oldArray[i];
            i += 1;
          }
          this.array = newArray;
          this.table = null;
          this.flags &= ~Record.AliasedFlag;
          return;
        }
        newArray[i] = item;
      }
      newArray[n] = new Attr(key, newValue);
      this.array = newArray;
      this.table = null;
      this.length = n + 1;
      this.fieldCount += 1;
      this.flags &= ~Record.AliasedFlag;
    }
    setAttrMutable(key, newValue) {
      const table = this.table;
      const n = table.length;
      const x = Math.abs(key.hashCode() % n);
      let i = x;
      do {
        const field = table[i];
        if (field !== void 0) {
          if (field.key.equals(key)) {
            if (field instanceof Attr && field.isMutable()) {
              field.setValue(newValue);
            } else {
              this.updateAttrMutable(key, newValue);
            }
            return;
          }
        } else {
          break;
        }
        i = (i + 1) % n;
      } while (i !== x);
      const field = new Attr(key, newValue);
      this.push(field);
      RecordMap.put(table, field);
    }
    updateAttrMutable(key, newValue) {
      const array = this.array;
      for (let i = 0, n = this.length; i < n; i += 1) {
        const item = array[i];
        if (item instanceof Field && item.key.equals(key)) {
          array[i] = new Attr(key, newValue);
          this.table = null;
          return;
        }
      }
      const field = new Attr(key, newValue);
      this.push(field);
      RecordMap.put(this.table, field);
    }
    setSlot(key, newValue) {
      if ((this.flags & Record.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      }
      key = Value.fromAny(key);
      newValue = Value.fromAny(newValue);
      if ((this.flags & Record.AliasedFlag) !== 0) {
        if (this.fieldCount > 0) {
          this.setSlotAliased(key, newValue);
        } else {
          this.pushAliased(new Slot(key, newValue));
        }
      } else {
        if (this.fieldCount > 0) {
          if (this.table !== null) {
            this.setSlotMutable(key, newValue);
          } else {
            this.updateSlotMutable(key, newValue);
          }
        } else {
          this.pushMutable(new Slot(key, newValue));
        }
      }
      return this;
    }
    setSlotAliased(key, newValue) {
      const n = this.length;
      const oldArray = this.array;
      const newArray = new Array(Record.expand(n + 1));
      for (let i = 0; i < n; i += 1) {
        const item = oldArray[i];
        if (item instanceof Field && item.key.equals(key)) {
          newArray[i] = new Slot(key, newValue);
          i += 1;
          while (i < n) {
            newArray[i] = oldArray[i];
            i += 1;
          }
          this.array = newArray;
          this.table = null;
          this.flags &= ~Record.AliasedFlag;
          return;
        }
        newArray[i] = item;
      }
      newArray[n] = new Slot(key, newValue);
      this.array = newArray;
      this.table = null;
      this.length = n + 1;
      this.fieldCount += 1;
      this.flags &= ~Record.AliasedFlag;
    }
    setSlotMutable(key, newValue) {
      const table = this.table;
      const n = table.length;
      const x = Math.abs(key.hashCode() % n);
      let i = x;
      do {
        const field = table[i];
        if (field !== void 0) {
          if (field.key.equals(key)) {
            if (field instanceof Slot && field.isMutable()) {
              field.setValue(newValue);
            } else {
              this.updateSlotMutable(key, newValue);
            }
            return;
          }
        } else {
          break;
        }
        i = (i + 1) % n;
      } while (i !== x);
      const field = new Slot(key, newValue);
      this.push(field);
      RecordMap.put(table, field);
    }
    updateSlotMutable(key, newValue) {
      const array = this.array;
      for (let i = 0, n = this.length; i < n; i += 1) {
        const item = array[i];
        if (item instanceof Field && item.key.equals(key)) {
          array[i] = new Slot(key, newValue);
          this.table = null;
          return;
        }
      }
      const field = new Slot(key, newValue);
      this.push(field);
      RecordMap.put(this.table, field);
    }
    setItem(index, newItem) {
      if ((this.flags & Record.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      }
      newItem = Item.fromAny(newItem);
      const n = this.length;
      if (index < 0) {
        index = n + index;
      }
      if (index < 0 || index > n) {
        throw new RangeError("" + index);
      }
      if ((this.flags & Record.AliasedFlag) !== 0) {
        this.setItemAliased(index, newItem);
      } else {
        this.setItemMutable(index, newItem);
      }
      return this;
    }
    setItemAliased(index, newItem) {
      const n = this.length;
      const oldArray = this.array;
      const newArray = new Array(Record.expand(n));
      for (let i = 0; i < n; i += 1) {
        newArray[i] = oldArray[i];
      }
      const oldItem = oldArray[index];
      newArray[index] = newItem;
      this.array = newArray;
      this.table = null;
      if (newItem instanceof Field) {
        if (!(oldItem instanceof Field)) {
          this.fieldCount += 1;
        }
      } else if (oldItem instanceof Field) {
        this.fieldCount -= 1;
      }
      this.flags &= ~Record.AliasedFlag;
    }
    setItemMutable(index, newItem) {
      const array = this.array;
      const oldItem = array[index];
      array[index] = newItem;
      if (newItem instanceof Field) {
        this.table = null;
        if (!(oldItem instanceof Field)) {
          this.fieldCount += 1;
        }
      } else if (oldItem instanceof Field) {
        this.table = null;
        this.fieldCount -= 1;
      }
    }
    updated(key, newValue) {
      key = Value.fromAny(key);
      newValue = Value.fromAny(newValue);
      const record = (this.flags & Record.ImmutableFlag) === 0 ? this : this.branch();
      if ((record.flags & Record.AliasedFlag) !== 0) {
        if (record.fieldCount > 0) {
          record.setAliased(key, newValue);
        } else {
          record.pushAliased(new Slot(key, newValue));
        }
      } else {
        if (record.fieldCount > 0) {
          if (record.table !== null) {
            record.setMutable(key, newValue);
          } else {
            record.updateMutable(key, newValue);
          }
        } else {
          record.pushMutable(new Slot(key, newValue));
        }
      }
      return record;
    }
    updatedAttr(key, newValue) {
      key = Text.fromAny(key);
      newValue = Value.fromAny(newValue);
      const record = (this.flags & Record.ImmutableFlag) === 0 ? this : this.branch();
      if ((record.flags & Record.AliasedFlag) !== 0) {
        if (record.fieldCount > 0) {
          record.setAttrAliased(key, newValue);
        } else {
          record.pushAliased(new Attr(key, newValue));
        }
      } else {
        if (record.fieldCount > 0) {
          if (record.table !== null) {
            record.setAttrMutable(key, newValue);
          } else {
            record.updateAttrMutable(key, newValue);
          }
        } else {
          record.pushMutable(new Attr(key, newValue));
        }
      }
      return record;
    }
    updatedSlot(key, newValue) {
      key = Value.fromAny(key);
      newValue = Value.fromAny(newValue);
      const record = (this.flags & Record.ImmutableFlag) === 0 ? this : this.branch();
      if ((record.flags & Record.AliasedFlag) !== 0) {
        if (record.fieldCount > 0) {
          record.setSlotAliased(key, newValue);
        } else {
          record.pushAliased(new Slot(key, newValue));
        }
      } else {
        if (record.fieldCount > 0) {
          if (record.table !== null) {
            record.setSlotMutable(key, newValue);
          } else {
            record.updateSlotMutable(key, newValue);
          }
        } else {
          record.pushMutable(new Slot(key, newValue));
        }
      }
      return record;
    }
    push(...newItems) {
      if ((this.flags & Record.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      }
      if ((this.flags & Record.AliasedFlag) !== 0) {
        this.pushAliased(...newItems);
      } else {
        this.pushMutable(...newItems);
      }
      return this.length;
    }
    pushAliased(...newItems) {
      const k = newItems.length;
      let m = this.length;
      let n = this.fieldCount;
      const oldArray = this.array;
      const newArray = new Array(Record.expand(m + k));
      if (oldArray !== null) {
        for (let i = 0; i < m; i += 1) {
          newArray[i] = oldArray[i];
        }
      }
      for (let i = 0; i < k; i += 1) {
        const newItem = Item.fromAny(newItems[i]);
        newArray[m] = newItem;
        m += 1;
        if (newItem instanceof Field) {
          n += 1;
        }
      }
      this.array = newArray;
      this.table = null;
      this.length = m;
      this.fieldCount = n;
      this.flags &= ~Record.AliasedFlag;
    }
    pushMutable(...newItems) {
      const k = newItems.length;
      let m = this.length;
      let n = this.fieldCount;
      const oldArray = this.array;
      let newArray;
      if (oldArray === null || m + k > oldArray.length) {
        newArray = new Array(Record.expand(m + k));
        if (oldArray !== null) {
          for (let i = 0; i < m; i += 1) {
            newArray[i] = oldArray[i];
          }
        }
      } else {
        newArray = oldArray;
      }
      for (let i = 0; i < k; i += 1) {
        const newItem = Item.fromAny(newItems[i]);
        newArray[m] = newItem;
        m += 1;
        if (newItem instanceof Field) {
          n += 1;
          this.table = null;
        }
      }
      this.array = newArray;
      this.length = m;
      this.fieldCount = n;
    }
    splice(start, deleteCount = 0, ...newItems) {
      if ((this.flags & Record.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      }
      const n = this.length;
      if (start < 0) {
        start = n + start;
      }
      start = Math.min(Math.max(0, start), n);
      deleteCount = Math.min(Math.max(0, deleteCount), n - start);
      if ((this.flags & Record.AliasedFlag) !== 0) {
        return this.spliceAliased(start, deleteCount, ...newItems);
      } else {
        return this.spliceMutable(start, deleteCount, ...newItems);
      }
    }
    spliceAliased(start, deleteCount, ...newItems) {
      const k = newItems.length;
      let m = this.length;
      let n = this.fieldCount;
      const oldArray = this.array;
      const newArray = new Array(Record.expand(m - deleteCount + k));
      for (let i = 0; i < start; i += 1) {
        newArray[i] = oldArray[i];
      }
      const oldItems = [];
      for (let i = start; i < start + deleteCount; i += 1) {
        const oldItem = oldArray[i];
        oldItems.push(oldItem);
        m -= 1;
        if (oldItem instanceof Field) {
          n -= 1;
        }
      }
      for (let i = start; i < m; i += 1) {
        newArray[i + k] = oldArray[i + deleteCount];
      }
      for (let i = 0; i < k; i += 1) {
        const newItem = Item.fromAny(newItems[i]);
        newArray[i + start] = newItem;
        m += 1;
        if (newItem instanceof Field) {
          n += 1;
        }
      }
      this.array = newArray;
      this.table = null;
      this.length = m;
      this.fieldCount = n;
      this.flags &= ~Record.AliasedFlag;
      return oldItems;
    }
    spliceMutable(start, deleteCount, ...newItems) {
      const k = newItems.length;
      let m = this.length;
      let n = this.fieldCount;
      const oldArray = this.array;
      let newArray;
      if (oldArray === null || m - deleteCount + k > oldArray.length) {
        newArray = new Array(Record.expand(m - deleteCount + k));
        if (oldArray !== null) {
          for (let i = 0; i < start; i += 1) {
            newArray[i] = oldArray[i];
          }
        }
      } else {
        newArray = oldArray;
      }
      const oldItems = [];
      for (let i = start; i < start + deleteCount; i += 1) {
        const oldItem = oldArray[i];
        oldItems.push(oldItem);
        m -= 1;
        if (oldItem instanceof Field) {
          n -= 1;
        }
      }
      if (k > deleteCount) {
        for (let i = m - 1; i >= start; i -= 1) {
          newArray[i + k] = oldArray[i + deleteCount];
        }
      } else {
        for (let i = start; i < m; i += 1) {
          newArray[i + k] = oldArray[i + deleteCount];
        }
      }
      for (let i = 0; i < k; i += 1) {
        const newItem = Item.fromAny(newItems[i]);
        newArray[i + start] = newItem;
        m += 1;
        if (newItem instanceof Field) {
          n += 1;
        }
      }
      this.array = newArray;
      this.length = m;
      this.fieldCount = n;
      return oldItems;
    }
    delete(key) {
      if ((this.flags & Record.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      }
      key = Value.fromAny(key);
      if ((this.flags & Record.AliasedFlag) !== 0) {
        return this.deleteAliased(key);
      } else {
        return this.deleteMutable(key);
      }
    }
    deleteAliased(key) {
      const n = this.length;
      const oldArray = this.array;
      const newArray = new Array(Record.expand(n));
      for (let i = 0; i < n; i += 1) {
        const item = oldArray[i];
        if (item instanceof Field && item.key.equals(key)) {
          for (let j = i + 1; j < n; j += 1, i += 1) {
            newArray[i] = oldArray[j];
          }
          this.array = newArray;
          this.table = null;
          this.length = n - 1;
          this.fieldCount -= 1;
          this.flags &= ~Record.AliasedFlag;
          return item;
        }
        newArray[i] = item;
      }
      return Item.absent();
    }
    deleteMutable(key) {
      const n = this.length;
      const array = this.array;
      for (let i = 0; i < n; i += 1) {
        const item = array[i];
        if (item instanceof Field && item.key.equals(key)) {
          for (let j = i + 1; j < n; j += 1, i += 1) {
            array[i] = array[j];
          }
          array[n - 1] = void 0;
          this.table = null;
          this.length = n - 1;
          this.fieldCount -= 1;
          return item;
        }
      }
      return Item.absent();
    }
    clear() {
      if ((this.flags & Record.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      }
      this.array = null;
      this.table = null;
      this.length = 0;
      this.fieldCount = 0;
      this.flags = 0;
    }
    isAliased() {
      return (this.flags & Record.AliasedFlag) !== 0;
    }
    isMutable() {
      return (this.flags & Record.ImmutableFlag) === 0;
    }
    alias() {
      this.flags |= Record.AliasedFlag;
    }
    branch() {
      if ((this.flags & (Record.AliasedFlag | Record.ImmutableFlag)) === 0) {
        const array = this.array;
        for (let i = 0, n = this.length; i < n; i += 1) {
          array[i].alias();
        }
      }
      this.flags |= Record.AliasedFlag;
      return new RecordMap(this.array, this.table, this.length, this.fieldCount, Record.AliasedFlag);
    }
    clone() {
      const itemCount = this.length;
      const oldArray = this.array;
      const newArray = new Array(itemCount);
      for (let i = 0; i < itemCount; i += 1) {
        newArray[i] = oldArray[i].clone();
      }
      return new RecordMap(newArray, null, itemCount, this.fieldCount, 0);
    }
    commit() {
      if ((this.flags & Record.ImmutableFlag) === 0) {
        this.flags |= Record.ImmutableFlag;
        const array = this.array;
        for (let i = 0, n = this.length; i < n; i += 1) {
          array[i].commit();
        }
      }
      return this;
    }
    hashTable() {
      const n = this.fieldCount;
      let table = this.table;
      if (n !== 0 && table === null) {
        table = new Array(Record.expand(Math.max(n, n * 10 / 7)));
        const array = this.array;
        for (let i = 0, m = this.length; i < m; i += 1) {
          const item = array[i];
          if (item instanceof Field) {
            RecordMap.put(table, item);
          }
        }
        this.table = table;
      }
      return table;
    }
    static put(table, field) {
      if (table !== null) {
        const n = table.length;
        const x = Math.abs(field.key.hashCode() % n);
        let i = x;
        do {
          const item = table[i];
          if (item !== void 0) {
            if (field.key.equals(item.key)) {
              table[i] = field;
              return;
            }
          } else {
            table[i] = field;
            return;
          }
          i = (i + 1) % n;
        } while (i !== x);
        throw new Error;
      }
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const array = this.array;
      const n = this.length;
      const scope = Record.create(n);
      interpreter.pushScope(scope);
      let changed = false;
      for (let i = 0; i < n; i += 1) {
        const oldItem = array[i];
        const newItem = oldItem.evaluate(interpreter);
        if (newItem.isDefined()) {
          scope.push(newItem);
        }
        if (oldItem !== newItem) {
          changed = true;
        }
      }
      interpreter.popScope();
      return changed ? scope : this;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const array = this.array;
      const n = this.length;
      const scope = Record.create(n);
      interpreter.pushScope(scope);
      let changed = false;
      for (let i = 0; i < n; i += 1) {
        const oldItem = array[i];
        const newItem = oldItem.substitute(interpreter);
        if (newItem.isDefined()) {
          scope.push(newItem);
        }
        if (oldItem !== newItem) {
          changed = true;
        }
      }
      interpreter.popScope();
      return changed ? scope : this;
    }
    subRecord(lower, upper) {
      const n = this.length;
      if (lower === void 0) {
        lower = 0;
      } else if (lower < 0) {
        lower = n + lower;
      }
      if (upper === void 0) {
        upper = n;
      } else if (upper < 0) {
        upper = n + upper;
      }
      if (lower < 0 || upper > n || lower > upper) {
        throw new RangeError(lower + ", " + upper);
      }
      return new RecordMapView(this, lower, upper);
    }
    forEach(callback, thisArg) {
      const array = this.array;
      for (let i = 0, n = this.length; i < n; i += 1) {
        const result = callback.call(thisArg, array[i], i);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
    static empty() {
      return new RecordMap(null, null, 0, 0, Record.AliasedFlag | Record.ImmutableFlag);
    }
    static create(initialCapacity) {
      if (initialCapacity === void 0) {
        return new RecordMap(null, null, 0, 0, Record.AliasedFlag);
      } else {
        return new RecordMap(new Array(initialCapacity), null, 0, 0, 0);
      }
    }
    static of(...items) {
      const n = items.length;
      if (n === 0) {
        return new RecordMap(null, null, 0, 0, Record.AliasedFlag);
      } else {
        const array = new Array(n);
        let itemCount = 0;
        let fieldCount = 0;
        for (let i = 0; i < n; i += 1) {
          const item = Item.fromAny(items[i]);
          array[i] = item;
          itemCount += 1;
          if (item instanceof Field) {
            fieldCount += 1;
          }
        }
        return new RecordMap(array, null, itemCount, fieldCount, 0);
      }
    }
  }
  __decorate([ Lazy ], RecordMap, "empty", null);
  class RecordMapView extends Record {
    constructor(record, lower, upper) {
      super();
      this.record = record;
      this.lower = lower;
      this.upper = upper;
    }
    isEmpty() {
      return this.lower === this.upper;
    }
    isArray() {
      const array = this.record.array;
      for (let i = this.lower, n = this.upper; i < n; i += 1) {
        if (array[i] instanceof Field) {
          return false;
        }
      }
      return true;
    }
    isObject() {
      const array = this.record.array;
      for (let i = this.lower, n = this.upper; i < n; i += 1) {
        if (array[i] instanceof Value) {
          return false;
        }
      }
      return true;
    }
    get length() {
      return this.upper - this.lower;
    }
    get valueCount() {
      let k = 0;
      const array = this.record.array;
      for (let i = this.lower, n = this.upper; i < n; i += 1) {
        if (array[i] instanceof Value) {
          k += 1;
        }
      }
      return k;
    }
    isConstant() {
      const array = this.record.array;
      for (let i = this.lower, n = this.upper; i < n; i += 1) {
        if (!array[i].isConstant()) {
          return false;
        }
      }
      return true;
    }
    get tag() {
      if (this.length > 0) {
        const item = this.record.array[this.lower];
        if (item instanceof Attr) {
          return item.key.value;
        }
      }
      return void 0;
    }
    get target() {
      let value;
      let record;
      let modified = false;
      const array = this.record.array;
      for (let i = this.lower, n = this.upper; i < n; i += 1) {
        const item = array[i];
        if (item instanceof Attr) {
          modified = true;
        } else if (value === void 0 && item instanceof Value) {
          value = item;
        } else {
          if (record === void 0) {
            record = Record.create();
            if (value !== void 0) {
              record.push(value);
            }
          }
          record.push(item);
        }
      }
      if (value === void 0) {
        return Value.extant();
      } else if (record === void 0) {
        return value;
      } else if (modified) {
        return record;
      } else {
        return this;
      }
    }
    head() {
      if (this.length > 0) {
        return this.record.array[this.lower];
      } else {
        return Item.absent();
      }
    }
    tail() {
      if (this.length > 0) {
        return new RecordMapView(this.record, this.lower + 1, this.upper);
      } else {
        return Record.empty();
      }
    }
    body() {
      const n = this.length;
      if (n > 2) {
        return new RecordMapView(this.record, this.lower + 1, this.upper).branch();
      } else if (n === 2) {
        const item = this.record.array[this.lower + 1];
        if (item instanceof Value) {
          return item;
        } else {
          return Record.of(item);
        }
      } else {
        return Value.absent();
      }
    }
    indexOf(item, index = 0) {
      item = Item.fromAny(item);
      const array = this.record.array;
      const n = this.length;
      if (index < 0) {
        index = Math.max(0, n + index);
      }
      index = this.lower + index;
      while (index < this.upper) {
        if (item.equals(array[index])) {
          return index - this.lower;
        }
        index += 1;
      }
      return -1;
    }
    lastIndexOf(item, index) {
      item = Item.fromAny(item);
      const array = this.record.array;
      const n = this.length;
      if (index === void 0) {
        index = n - 1;
      } else if (index < 0) {
        index = n + index;
      }
      index = this.lower + Math.min(index, n - 1);
      while (index >= this.lower) {
        if (item.equals(array[index])) {
          return index - this.lower;
        }
        index -= 1;
      }
      return -1;
    }
    getItem(index) {
      if (index instanceof Num) {
        index = index.value;
      }
      const n = this.length;
      if (index < 0) {
        index = n + index;
      }
      if (index >= 0 && index < n) {
        return this.record.array[this.lower + index];
      } else {
        return Item.absent();
      }
    }
    setItem(index, newItem) {
      if ((this.record.flags & Record.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      }
      newItem = Item.fromAny(newItem);
      const n = this.length;
      if (index < 0) {
        index = n + index;
      }
      if (index < 0 || index > n) {
        throw new RangeError("" + index);
      }
      if ((this.record.flags & Record.AliasedFlag) !== 0) {
        this.setItemAliased(index, newItem);
      } else {
        this.setItemMutable(index, newItem);
      }
      return this;
    }
    setItemAliased(index, newItem) {
      const record = this.record;
      const n = record.length;
      const oldArray = record.array;
      const newArray = new Array(Record.expand(n));
      for (let i = 0; i < n; i += 1) {
        newArray[i] = oldArray[i];
      }
      const oldItem = oldArray !== null ? oldArray[this.lower + index] : null;
      newArray[this.lower + index] = newItem;
      record.array = newArray;
      record.table = null;
      if (newItem instanceof Field) {
        if (!(oldItem instanceof Field)) {
          record.fieldCount += 1;
        }
      } else if (oldItem instanceof Field) {
        record.fieldCount -= 1;
      }
      record.flags &= ~Record.AliasedFlag;
    }
    setItemMutable(index, newItem) {
      const record = this.record;
      const array = record.array;
      const oldItem = array[this.lower + index];
      array[this.lower + index] = newItem;
      if (newItem instanceof Field) {
        record.table = null;
        if (!(oldItem instanceof Field)) {
          record.fieldCount += 1;
        }
      } else if (oldItem instanceof Field) {
        record.table = null;
        record.fieldCount -= 1;
      }
    }
    push(...newItems) {
      if ((this.record.flags & Record.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      }
      if ((this.record.flags & Record.AliasedFlag) !== 0) {
        this.pushAliased(...newItems);
      } else {
        this.pushMutable(...newItems);
      }
      return this.length;
    }
    pushAliased(...newItems) {
      const record = this.record;
      const k = newItems.length;
      let m = record.length;
      let n = record.fieldCount;
      const oldArray = record.array;
      const newArray = new Array(Record.expand(m + k));
      if (oldArray !== null) {
        for (let i = 0; i < this.upper; i += 1) {
          newArray[i] = oldArray[i];
        }
        for (let i = this.upper; i < m; i += 1) {
          newArray[i + k] = oldArray[i];
        }
      }
      for (let i = 0; i < k; i += 1) {
        const newItem = Item.fromAny(newItems[i]);
        newArray[i + this.upper] = newItem;
        m += 1;
        if (newItem instanceof Field) {
          n += 1;
        }
      }
      record.array = newArray;
      record.table = null;
      record.length = m;
      record.fieldCount = n;
      record.flags &= ~Record.AliasedFlag;
      this.upper += k;
    }
    pushMutable(...newItems) {
      const record = this.record;
      const k = newItems.length;
      let m = record.length;
      let n = record.fieldCount;
      const oldArray = record.array;
      let newArray;
      if (oldArray === null || m + k > oldArray.length) {
        newArray = new Array(Record.expand(m + k));
        if (oldArray !== null) {
          for (let i = 0; i < this.upper; i += 1) {
            newArray[i] = oldArray[i];
          }
        }
      } else {
        newArray = oldArray;
      }
      for (let i = m - 1; i >= this.upper; i -= 1) {
        newArray[i + k] = oldArray[i];
      }
      for (let i = 0; i < k; i += 1) {
        const newItem = Item.fromAny(newItems[i]);
        newArray[i + this.upper] = newItem;
        m += 1;
        if (newItem instanceof Field) {
          n += 1;
          record.table = null;
        }
      }
      record.array = newArray;
      record.length = m;
      record.fieldCount = n;
      this.upper += k;
    }
    splice(start, deleteCount = 0, ...newItems) {
      if ((this.record.flags & Record.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      }
      const n = this.length;
      if (start < 0) {
        start = n + start;
      }
      start = Math.min(Math.max(0, start), n);
      deleteCount = Math.min(Math.max(0, deleteCount), n - start);
      let deleted;
      if ((this.record.flags & Record.AliasedFlag) !== 0) {
        deleted = this.record.spliceAliased(this.lower + start, deleteCount, ...newItems);
      } else {
        deleted = this.record.spliceMutable(this.lower + start, deleteCount, ...newItems);
      }
      this.upper += newItems.length - deleted.length;
      return deleted;
    }
    delete(key) {
      if ((this.record.flags & Record.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      }
      key = Value.fromAny(key);
      if ((this.record.flags & Record.AliasedFlag) !== 0) {
        return this.deleteAliased(key);
      } else {
        return this.deleteMutable(key);
      }
    }
    deleteAliased(key) {
      const record = this.record;
      const n = record.length;
      const oldArray = record.array;
      const newArray = new Array(Record.expand(n));
      for (let i = this.lower; i < this.upper; i += 1) {
        const item = oldArray[i];
        if (item instanceof Field && item.key.equals(key)) {
          for (let j = i + 1; j < n; j += 1, i += 1) {
            newArray[i] = oldArray[j];
          }
          record.array = newArray;
          record.table = null;
          record.length = n - 1;
          record.fieldCount -= 1;
          record.flags &= ~Record.AliasedFlag;
          this.upper -= 1;
          return item;
        }
        newArray[i] = item;
      }
      return Item.absent();
    }
    deleteMutable(key) {
      const record = this.record;
      const n = record.length;
      const array = record.array;
      for (let i = this.lower; i < this.upper; i += 1) {
        const item = array[i];
        if (item instanceof Field && item.key.equals(key)) {
          for (let j = i + 1; j < n; j += 1, i += 1) {
            array[i] = array[j];
          }
          array[n - 1] = void 0;
          record.table = null;
          record.length = n - 1;
          record.fieldCount -= 1;
          this.upper -= 1;
          return item;
        }
      }
      return Item.absent();
    }
    clear() {
      if ((this.record.flags & Record.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      }
      if ((this.record.flags & Record.AliasedFlag) !== 0) {
        this.clearAliased();
      } else {
        this.clearMutable();
      }
    }
    clearAliased() {
      const record = this.record;
      const m = record.length;
      let n = record.fieldCount;
      const l = m - this.length;
      const oldArray = record.array;
      const newArray = new Array(Record.expand(l));
      let i = 0;
      while (i < this.lower) {
        newArray[i] = oldArray[i];
        i += 1;
      }
      while (i < this.upper) {
        if (oldArray[i] instanceof Field) {
          n -= 1;
        }
        i += 1;
      }
      i = this.lower;
      let j = this.upper;
      while (j < m) {
        newArray[i] = oldArray[j];
        i += 1;
        j += 1;
      }
      record.array = newArray;
      record.table = null;
      record.length = l;
      record.fieldCount = n;
      record.flags &= ~Record.AliasedFlag;
      this.upper = this.lower;
    }
    clearMutable() {
      const record = this.record;
      const m = record.length;
      let n = record.fieldCount;
      const array = record.array;
      let i = this.lower;
      while (i < this.upper) {
        if (array[i] instanceof Field) {
          n -= 1;
        }
        i += 1;
      }
      i = this.lower;
      let j = this.upper;
      while (j < m) {
        const item = array[j];
        if (item instanceof Field) {
          record.table = null;
        }
        array[i] = item;
        i += 1;
        j += 1;
      }
      record.length = i;
      record.fieldCount = n;
      while (i < m) {
        array[i] = void 0;
        i += 1;
      }
      this.upper = this.lower;
    }
    isAliased() {
      return (this.record.flags & Record.AliasedFlag) !== 0;
    }
    isMutable() {
      return (this.record.flags & Record.ImmutableFlag) === 0;
    }
    alias() {
      this.record.flags |= Record.AliasedFlag;
    }
    branch() {
      const m = this.length;
      let n = 0;
      const oldArray = this.record.array;
      const newArray = new Array(Record.expand(m));
      let i = this.lower;
      let j = 0;
      while (j < m) {
        const item = oldArray[i];
        newArray[j] = item;
        if (item instanceof Field) {
          n += 1;
        }
        i += 1;
        j += 1;
      }
      return new RecordMap(newArray, null, m, n, 0);
    }
    clone() {
      const m = this.length;
      let n = 0;
      const oldArray = this.record.array;
      const newArray = new Array(Record.expand(m));
      let i = this.lower;
      let j = 0;
      while (j < m) {
        const item = oldArray[i];
        newArray[j] = item.clone();
        if (item instanceof Field) {
          n += 1;
        }
        i += 1;
        j += 1;
      }
      return new RecordMap(newArray, null, m, n, 0);
    }
    commit() {
      this.record.commit();
      return this;
    }
    subRecord(lower, upper) {
      const n = this.length;
      if (lower === void 0) {
        lower = 0;
      } else if (lower < 0) {
        lower = n + lower;
      }
      if (upper === void 0) {
        upper = n;
      } else if (upper < 0) {
        upper = n + upper;
      }
      if (lower < 0 || upper > n || lower > upper) {
        throw new RangeError(lower + ", " + upper);
      }
      return new RecordMapView(this.record, this.lower + lower, this.upper + upper);
    }
    forEach(callback, thisArg) {
      const array = this.record.array;
      for (let i = this.lower, n = this.upper; i < n; i += 1) {
        const result = callback.call(thisArg, array[i], i);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
  }
  Object.defineProperty(RecordMapView.prototype, "fieldCount", {
    get() {
      const array = this.record.array;
      let k = 0;
      for (let i = this.lower, n = this.upper; i < n; i += 1) {
        if (array[i] instanceof Field) {
          k += 1;
        }
      }
      return k;
    },
    configurable: true
  });
  class Data extends Value {
    constructor(array, size, flags) {
      super();
      this.array = array;
      this.size = size;
      this.flags = flags;
    }
    isConstant() {
      return true;
    }
    getByte(index) {
      if (index < 0 || index >= this.size) {
        throw new RangeError("" + index);
      }
      return this.array[index];
    }
    setByte(index, value) {
      const flags = this.flags;
      if ((flags & Data.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      } else if (index < 0 || index >= this.size) {
        throw new RangeError("" + index);
      }
      if ((flags & Data.AliasedFlag) !== 0) {
        return this.setByteAliased(index, value);
      } else {
        return this.setByteMutable(index, value);
      }
    }
    setByteAliased(index, value) {
      const n = this.size;
      const oldArray = this.array;
      const newArray = new Uint8Array(Data.expand(n));
      newArray.set(oldArray, 0);
      newArray[index] = value;
      this.array = newArray;
      this.flags &= ~Data.AliasedFlag;
      return this;
    }
    setByteMutable(index, value) {
      this.array[index] = value;
      return this;
    }
    addByte(value) {
      const flags = this.flags;
      if ((flags & Data.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      }
      if ((flags & Data.AliasedFlag) !== 0) {
        return this.addByteAliased(value);
      } else {
        return this.addByteMutable(value);
      }
    }
    addByteAliased(value) {
      const n = this.size;
      const oldArray = this.array;
      const newArray = new Uint8Array(Data.expand(n + 1));
      if (oldArray !== null) {
        newArray.set(oldArray, 0);
      }
      newArray[n] = value;
      this.array = newArray;
      this.size = n + 1;
      this.flags &= ~Data.AliasedFlag;
      return this;
    }
    addByteMutable(value) {
      const n = this.size;
      const oldArray = this.array;
      let newArray;
      if (oldArray === null || n + 1 > oldArray.length) {
        newArray = new Uint8Array(Data.expand(n + 1));
        if (oldArray !== null) {
          newArray.set(oldArray, 0);
        }
        this.array = newArray;
      } else {
        newArray = oldArray;
      }
      newArray[n] = value;
      this.size = n + 1;
      return this;
    }
    addData(data) {
      let array = data.array;
      if (array !== null) {
        const size = data.size;
        if (array.length > size) {
          array = array.slice(0, size);
        }
        return this.addUint8Array(array);
      } else {
        return this;
      }
    }
    addUint8Array(array) {
      const flags = this.flags;
      if ((flags & Data.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      }
      if ((flags & Data.AliasedFlag) !== 0) {
        return this.addUint8ArrayAliased(array);
      } else {
        return this.addUint8ArrayMutable(array);
      }
    }
    addUint8ArrayAliased(array) {
      const size = array.length;
      if (size === 0) {
        return this;
      }
      const n = this.size;
      const oldArray = this.array;
      const newArray = new Uint8Array(Data.expand(n + size));
      if (oldArray !== null) {
        newArray.set(oldArray, 0);
      }
      newArray.set(array, n);
      this.array = newArray;
      this.size = n + size;
      this.flags &= ~Data.AliasedFlag;
      return this;
    }
    addUint8ArrayMutable(array) {
      const size = array.length;
      if (size === 0) {
        return this;
      }
      const n = this.size;
      const oldArray = this.array;
      let newArray;
      if (oldArray === null || n + size > oldArray.length) {
        newArray = new Uint8Array(Data.expand(n + size));
        if (oldArray !== null) {
          newArray.set(oldArray, 0);
        }
        this.array = newArray;
      } else {
        newArray = oldArray;
      }
      newArray.set(array, n);
      this.size = n + size;
      return this;
    }
    clear() {
      if ((this.flags & Data.ImmutableFlag) !== 0) {
        throw new Error("immutable");
      }
      this.array = null;
      this.size = 0;
      this.flags = Data.AliasedFlag;
    }
    toUint8Array() {
      const oldArray = this.array;
      const flags = this.flags;
      if ((flags & Data.ImmutableFlag) !== 0) {
        return oldArray !== null ? oldArray.slice(0) : new Uint8Array(0);
      } else if ((flags & Data.AliasedFlag) !== 0 || this.size !== oldArray.length) {
        const newArray = oldArray !== null ? oldArray.slice(0) : new Uint8Array(0);
        this.array = newArray;
        this.flags &= ~Data.AliasedFlag;
        return newArray;
      } else {
        return oldArray;
      }
    }
    asUint8Array() {
      let array;
      if (this.array !== null && this.size > 0) {
        array = this.array;
        if (array.length !== this.size) {
          array = new Uint8Array(array.buffer, array.byteOffset, this.size);
        }
      } else {
        array = void 0;
      }
      return array;
    }
    toAny() {
      return this.toUint8Array();
    }
    isAliased() {
      return (this.flags & Data.AliasedFlag) !== 0;
    }
    isMutable() {
      return (this.flags & Data.ImmutableFlag) === 0;
    }
    branch() {
      this.flags |= Data.AliasedFlag;
      return new Data(this.array, this.size, Data.AliasedFlag);
    }
    clone() {
      return this.branch();
    }
    commit() {
      this.flags |= Data.ImmutableFlag;
      return this;
    }
    writeBase16(output, base16 = Base16.uppercase) {
      let array = this.array;
      const size = this.size;
      if (array !== null && size !== 0) {
        if (array.length !== size) {
          array = array.slice(0, size);
        }
        return base16.writeUint8Array(output, array);
      } else {
        return Writer.end();
      }
    }
    toBase16(base16 = Base16.uppercase) {
      const output = Unicode.stringOutput();
      this.writeBase16(output, base16).bind();
      return output.bind();
    }
    writeBase64(output, base64 = Base64.standard()) {
      let array = this.array;
      const size = this.size;
      if (array !== null && size !== 0) {
        if (array.length !== size) {
          array = array.slice(0, size);
        }
        return base64.writeUint8Array(output, array);
      } else {
        return Writer.end();
      }
    }
    toBase64(base64 = Base64.standard()) {
      const output = Unicode.stringOutput();
      this.writeBase64(output, base64);
      return output.bind();
    }
    interpolateTo(that) {
      return super.interpolateTo(that);
    }
    get typeOrder() {
      return 4;
    }
    compareTo(that) {
      if (that instanceof Data) {
        const xs = this.array;
        const ys = that.array;
        const xn = this.size;
        const yn = that.size;
        let order = 0;
        let i = 0;
        do {
          if (i < xn && i < yn) {
            order = xs[i] - ys[i];
            i += 1;
          } else {
            break;
          }
        } while (order === 0);
        if (order > 0) {
          return 1;
        } else if (order < 0) {
          return -1;
        } else if (xn > yn) {
          return 1;
        } else if (xn < yn) {
          return -1;
        } else {
          return 0;
        }
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that) {
      return this.equals(that);
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Data) {
        const xs = this.array;
        const ys = that.array;
        const xn = this.size;
        if (xn !== that.size) {
          return false;
        }
        for (let i = 0; i < xn; i += 1) {
          if (xs[i] !== ys[i]) {
            return false;
          }
        }
        return true;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mixUint8Array(Constructors.hash(Data), this.array !== null ? this.array : new Uint8Array(0)));
    }
    debug(output) {
      output = output.write("Data").write(46);
      if (this.size === 0) {
        output = output.write("empty").write(40).write(41);
      } else {
        output = output.write("base16").write(40).write(34);
        const writer = this.writeBase16(output);
        if (!writer.isDone()) {
          return Output.error(writer.trap());
        }
        output = output.write(34).write(41);
      }
      return output;
    }
    static empty() {
      return new Data(null, 0, Data.AliasedFlag | Data.ImmutableFlag);
    }
    static create(initialCapacity) {
      if (initialCapacity === void 0) {
        return new Data(null, 0, Data.AliasedFlag);
      } else {
        return new Data(new Uint8Array(initialCapacity), 0, 0);
      }
    }
    static wrap(value) {
      return new Data(value, value.length, Data.AliasedFlag);
    }
    static fromBase16(input) {
      if (typeof input === "string") {
        input = Unicode.stringInput(input);
      }
      return Base16.parse(input, Data.output()).bind();
    }
    static fromBase64(input, base64 = Base64.standard()) {
      if (typeof input === "string") {
        input = Unicode.stringInput(input);
      }
      return base64.parse(input, Data.output()).bind();
    }
    static fromAny(value) {
      if (value instanceof Data) {
        return value;
      } else if (value instanceof Uint8Array) {
        return Data.wrap(value);
      } else {
        throw new TypeError("" + value);
      }
    }
    static random(size) {
      const array = new Uint8Array(size);
      Random.fillBytes(array);
      return Data.wrap(array);
    }
    static output(data) {
      if (!(data instanceof Data)) {
        data = Data.create(data);
      }
      return new DataOutput(data, OutputSettings.standard());
    }
    static expand(n) {
      n = Math.max(32, n) - 1;
      n |= n >> 1;
      n |= n >> 2;
      n |= n >> 4;
      n |= n >> 8;
      n |= n >> 16;
      return n + 1;
    }
  }
  Data.AliasedFlag = 1 << 0;
  Data.ImmutableFlag = 1 << 1;
  __decorate([ Lazy ], Data, "empty", null);
  class DataOutput extends Output {
    constructor(data, settings) {
      super();
      this.data = data;
      this.settings = settings;
    }
    isCont() {
      return true;
    }
    isFull() {
      return false;
    }
    isDone() {
      return false;
    }
    isError() {
      return false;
    }
    isPart() {
      return false;
    }
    asPart(part) {
      return this;
    }
    write(b) {
      if (typeof b === "number") {
        this.data.addByte(b);
        return this;
      } else {
        throw new TypeError("" + b);
      }
    }
    writeln(string) {
      throw new TypeError("" + string);
    }
    withSettings(settings) {
      settings = OutputSettings.fromAny(settings);
      this.settings = settings;
      return this;
    }
    bind() {
      return this.data;
    }
    clone() {
      return new DataOutput(this.data.branch(), this.settings);
    }
  }
  class Text extends Value {
    constructor(value) {
      super();
      this.value = value;
      this.hashValue = void 0;
    }
    isConstant() {
      return true;
    }
    get size() {
      return this.value.length;
    }
    stringValue(orElse) {
      return this.value;
    }
    numberValue(orElse) {
      try {
        return Num.parse(this.value).numberValue();
      } catch (error) {
        return orElse;
      }
    }
    booleanValue(orElse) {
      if (this.value === "true") {
        return true;
      } else if (this.value === "false") {
        return false;
      } else {
        return orElse;
      }
    }
    toAny() {
      return this.value;
    }
    valueOf() {
      return this.value;
    }
    plus(that) {
      that = Item.fromAny(that);
      if (that instanceof Text) {
        return Text.from(this.value + that.value);
      }
      return super.plus(that);
    }
    branch() {
      return this;
    }
    clone() {
      return this;
    }
    commit() {
      return this;
    }
    interpolateTo(that) {
      return super.interpolateTo(that);
    }
    get typeOrder() {
      return 5;
    }
    compareTo(that) {
      if (that instanceof Text) {
        return this.value.localeCompare(that.value);
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that) {
      return this.equals(that);
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Text) {
        return this.value === that.value;
      }
      return false;
    }
    hashCode() {
      let hashValue = this.hashValue;
      if (hashValue === void 0) {
        hashValue = Strings.hash(this.value);
        this.hashValue = hashValue;
      }
      return hashValue;
    }
    debug(output) {
      output = output.write("Text").write(46);
      if (this.value.length === 0) {
        output = output.write("empty").write(40).write(41);
      } else {
        output = output.write("from").write(40).debug(this.value).write(41);
      }
      return output;
    }
    display(output) {
      return Format.debugAny(output, this.value);
    }
    toString() {
      return this.value;
    }
    static empty() {
      return new Text("");
    }
    static from(value) {
      const n = value.length;
      if (n === 0) {
        return Text.empty();
      } else {
        let text = new Text(value);
        if (n <= 64) {
          text = Text.cache.put(text);
        }
        return text;
      }
    }
    static fromAny(value) {
      if (value instanceof Text) {
        return value;
      } else if (typeof value === "string") {
        return Text.from(value);
      } else {
        throw new TypeError("" + value);
      }
    }
    static output(settings) {
      if (settings === void 0) {
        settings = OutputSettings.standard();
      }
      return new TextOutput("", settings);
    }
    static get cache() {
      const cacheSize = 128;
      return new HashGenCacheSet(cacheSize);
    }
  }
  __decorate([ Lazy ], Text, "empty", null);
  __decorate([ Lazy ], Text, "cache", null);
  class TextOutput extends Output {
    constructor(string, settings) {
      super();
      this.string = string;
      this.settings = settings;
    }
    isCont() {
      return true;
    }
    isFull() {
      return false;
    }
    isDone() {
      return false;
    }
    isError() {
      return false;
    }
    isPart() {
      return false;
    }
    asPart(part) {
      return this;
    }
    write(token) {
      if (typeof token === "number") {
        if (token >= 0 && token <= 55295 || token >= 57344 && token <= 65535) {
          token = String.fromCharCode(token);
        } else if (token >= 65536 && token <= 1114111) {
          const u = token - 65536;
          token = String.fromCharCode(55296 | u >>> 10, 56320 | u & 1023);
        } else {
          token = "";
        }
      }
      this.string += token;
      return this;
    }
    withSettings(settings) {
      settings = OutputSettings.fromAny(settings);
      this.settings = settings;
      return this;
    }
    bind() {
      return Text.from(this.string);
    }
    clone() {
      return new TextOutput(this.string, this.settings);
    }
    toString() {
      return this.string;
    }
  }
  class Num extends Value {
    constructor(value, flags) {
      super();
      this.value = value;
      this.flags = flags !== void 0 ? flags : 0;
    }
    isConstant() {
      return true;
    }
    isNaN() {
      return isNaN(this.value);
    }
    isInfinite() {
      return !isNaN(this.value) && !isFinite(this.value);
    }
    isUint32() {
      return (this.flags & Num.Uint32Flag) !== 0;
    }
    isUint64() {
      return (this.flags & Num.Uint64Flag) !== 0;
    }
    stringValue(orElse) {
      return "" + this.value;
    }
    numberValue(orElse) {
      return this.value;
    }
    booleanValue(orElse) {
      return !!this.value;
    }
    toAny() {
      return this.value;
    }
    valueOf() {
      return this.value;
    }
    bitwiseOr(that) {
      that = Item.fromAny(that);
      if (that instanceof Num) {
        return Num.from((this.value | that.value) >>> 0);
      }
      return super.bitwiseOr(that);
    }
    bitwiseXor(that) {
      that = Item.fromAny(that);
      if (that instanceof Num) {
        return Num.from((this.value ^ that.value) >>> 0);
      }
      return super.bitwiseXor(that);
    }
    bitwiseAnd(that) {
      that = Item.fromAny(that);
      if (that instanceof Num) {
        return Num.from((this.value & that.value) >>> 0);
      }
      return super.bitwiseAnd(that);
    }
    plus(that) {
      that = Item.fromAny(that);
      if (that instanceof Num) {
        return Num.from(this.value + that.value);
      }
      return super.plus(that);
    }
    minus(that) {
      that = Item.fromAny(that);
      if (that instanceof Num) {
        return Num.from(this.value - that.value);
      }
      return super.minus(that);
    }
    times(that) {
      that = Item.fromAny(that);
      if (that instanceof Num) {
        return Num.from(this.value * that.value);
      }
      return super.times(that);
    }
    divide(that) {
      that = Item.fromAny(that);
      if (that instanceof Num) {
        return Num.from(this.value / that.value);
      }
      return super.divide(that);
    }
    modulo(that) {
      that = Item.fromAny(that);
      if (that instanceof Num) {
        return Num.from(this.value % that.value);
      }
      return super.modulo(that);
    }
    bitwiseNot() {
      return Num.from(~this.value >>> 0);
    }
    negative() {
      return Num.from(-this.value);
    }
    positive() {
      return this;
    }
    inverse() {
      return Num.from(1 / this.value);
    }
    abs() {
      return Num.from(Math.abs(this.value));
    }
    ceil() {
      return Num.from(Math.ceil(this.value));
    }
    floor() {
      return Num.from(Math.floor(this.value));
    }
    round() {
      return Num.from(Math.round(this.value));
    }
    sqrt() {
      return Num.from(Math.sqrt(this.value));
    }
    pow(that) {
      that = Num.fromAny(that);
      return Num.from(Math.pow(this.value, that.value));
    }
    max(that) {
      return this.compareTo(that) >= 0 ? this : that;
    }
    min(that) {
      return this.compareTo(that) <= 0 ? this : that;
    }
    interpolateTo(that) {
      if (that instanceof Num) {
        return NumInterpolator(this, that);
      } else {
        return super.interpolateTo(that);
      }
    }
    get typeOrder() {
      return 6;
    }
    compareTo(that) {
      if (that instanceof Num) {
        const x = this.value;
        const y = that.value;
        return x < y ? -1 : x > y ? 1 : isNaN(y) ? isNaN(x) ? 0 : -1 : isNaN(x) ? 1 : 0;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof Num) {
        const x = this.value;
        const y = that.value;
        return x === y || isNaN(x) && isNaN(y) || Math.abs(y - x) < (epsilon !== void 0 ? epsilon : Equivalent.Epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Num) {
        const x = this.value;
        const y = that.value;
        return x === y || isNaN(x) && isNaN(y);
      }
      return false;
    }
    hashCode() {
      return Numbers.hash(this.value);
    }
    debug(output) {
      output = output.write("Num").write(46).write("from").write(40).display(this).write(41);
      return output;
    }
    display(output) {
      return Format.displayNumber(output, this.value);
    }
    static get zero() {
      return new Num(0);
    }
    static get negativeZero() {
      return new Num(-0);
    }
    static get one() {
      return new Num(1);
    }
    static get negativeOne() {
      return new Num(-1);
    }
    static get nan() {
      return new Num(NaN);
    }
    static uint32(value) {
      return new Num(value, Num.Uint32Flag);
    }
    static uint64(value) {
      return new Num(value, Num.Uint64Flag);
    }
    static from(value) {
      if (value === 0) {
        if (1 / value === -Infinity) {
          return Num.negativeZero;
        } else {
          return Num.zero;
        }
      } else if (value === 1) {
        return Num.one;
      } else if (value === -1) {
        return Num.negativeOne;
      } else if (isNaN(value)) {
        return Num.nan;
      } else {
        return Num.cache.put(new Num(value));
      }
    }
    static fromAny(value) {
      if (value instanceof Num) {
        return value;
      } else if (typeof value === "number") {
        return Num.from(value);
      } else {
        throw new TypeError("" + value);
      }
    }
    static parse(value) {
      if (value === "NaN") {
        return Num.nan;
      } else {
        const num = +value;
        if (isFinite(num)) {
          return Num.from(num);
        }
      }
      throw new Error(value);
    }
    static get cache() {
      const cacheSize = 128;
      return new HashGenCacheSet(cacheSize);
    }
  }
  Num.Uint32Flag = 1;
  Num.Uint64Flag = 2;
  Num.TypeMask = 3;
  __decorate([ Lazy ], Num, "zero", null);
  __decorate([ Lazy ], Num, "negativeZero", null);
  __decorate([ Lazy ], Num, "one", null);
  __decorate([ Lazy ], Num, "negativeOne", null);
  __decorate([ Lazy ], Num, "nan", null);
  __decorate([ Lazy ], Num, "cache", null);
  const NumInterpolator = function(_super) {
    const NumInterpolator = function(y0, y1) {
      const interpolator = function(u) {
        const y0 = interpolator[0].value;
        const y1 = interpolator[1].value;
        return Num.from(y0 + u * (y1 - y0));
      };
      Object.setPrototypeOf(interpolator, NumInterpolator.prototype);
      interpolator[0] = y0;
      interpolator[1] = y1;
      return interpolator;
    };
    NumInterpolator.prototype = Object.create(_super.prototype);
    NumInterpolator.prototype.constructor = NumInterpolator;
    return NumInterpolator;
  }(Interpolator);
  class Bool extends Value {
    constructor(value) {
      super();
      Object.defineProperty(this, "value", {
        value: value,
        enumerable: true
      });
      Object.defineProperty(this, "hashValue", {
        value: Strings.hash(value ? "true" : "false")
      });
    }
    isDefinite() {
      return this.value;
    }
    isConstant() {
      return true;
    }
    stringValue(orElse) {
      return this.value ? "true" : "false";
    }
    booleanValue(orElse) {
      return this.value;
    }
    toAny() {
      return this.value;
    }
    valueOf() {
      return this.value;
    }
    conditional(thenTerm, elseTerm) {
      return this.value ? Item.fromAny(thenTerm) : Item.fromAny(elseTerm);
    }
    or(that) {
      return this.value ? this : Item.fromAny(that);
    }
    and(that) {
      return this.value ? Item.fromAny(that) : this;
    }
    not() {
      return Bool.from(!this.value);
    }
    get typeOrder() {
      return 7;
    }
    compareTo(that) {
      if (that instanceof Bool) {
        if (this.value && !that.value) {
          return -1;
        } else if (!this.value && that.value) {
          return 1;
        } else {
          return 0;
        }
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that) {
      return this.equals(that);
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Bool) {
        return this.value === that.value;
      }
      return false;
    }
    hashCode() {
      return this.hashValue;
    }
    debug(output) {
      output = output.write("Bool").write(46).write("from").write(40).write(this.value ? "true" : "false").write(41);
      return output;
    }
    display(output) {
      output = output.write(this.value ? "true" : "false");
      return output;
    }
    static get true() {
      return new Bool(true);
    }
    static get false() {
      return new Bool(false);
    }
    static from(value) {
      return value ? Bool.true : Bool.false;
    }
    static fromAny(value) {
      if (value instanceof Bool) {
        return value;
      } else if (typeof value === "boolean") {
        return Bool.from(value);
      } else {
        throw new TypeError("" + value);
      }
    }
  }
  __decorate([ Lazy ], Bool, "true", null);
  __decorate([ Lazy ], Bool, "false", null);
  class Extant extends Value {
    constructor() {
      super();
    }
    isDefined() {
      return true;
    }
    isDistinct() {
      return false;
    }
    isDefinite() {
      return false;
    }
    isConstant() {
      return true;
    }
    unflattened() {
      return Record.empty();
    }
    not() {
      return Value.absent();
    }
    stringValue(orElse) {
      return "";
    }
    booleanValue(orElse) {
      return true;
    }
    toAny() {
      return null;
    }
    interpolateTo(that) {
      return super.interpolateTo(that);
    }
    get typeOrder() {
      return 98;
    }
    compareTo(that) {
      if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that) {
      return this === that;
    }
    equals(that) {
      return this === that;
    }
    hashCode() {
      return Constructors.hash(Extant);
    }
    debug(output) {
      output = output.write("Value").write(46).write("extant").write(40).write(41);
      return output;
    }
    display(output) {
      output = output.write("null");
      return output;
    }
    static extant() {
      return new Extant;
    }
    static fromAny(value) {
      if (value instanceof Extant) {
        return value;
      } else if (value === null) {
        return Extant.extant();
      } else {
        throw new TypeError("" + value);
      }
    }
  }
  __decorate([ Lazy ], Extant, "extant", null);
  class Absent extends Value {
    constructor() {
      super();
    }
    isDefined() {
      return false;
    }
    isDistinct() {
      return false;
    }
    isDefinite() {
      return false;
    }
    isConstant() {
      return true;
    }
    unflattened() {
      return Record.empty();
    }
    updated(key, value) {
      return Record.of(Slot.of(key, value));
    }
    updatedAttr(key, value) {
      return Record.of(Attr.of(key, value));
    }
    updatedSlot(key, value) {
      return Record.of(Slot.of(key, value));
    }
    appended(...items) {
      return Record.of(items);
    }
    prepended(...items) {
      return Record.of(items);
    }
    concat(...items) {
      const record = Record.create();
      for (let i = 0, n = items.length; i < n; i += 1) {
        Item.fromAny(items[i]).forEach((function(item) {
          record.push(item);
        }));
      }
      return record;
    }
    conditional(thenTerm, elseTerm) {
      return Item.fromAny(elseTerm);
    }
    or(that) {
      return Item.fromAny(that);
    }
    and(that) {
      return this;
    }
    not() {
      return Value.extant();
    }
    booleanValue(orElse) {
      return false;
    }
    toAny() {
      return void 0;
    }
    forEach(callback, thisArg) {
      return void 0;
    }
    iterator() {
      return Cursor.empty();
    }
    interpolateTo(that) {
      return super.interpolateTo(that);
    }
    get typeOrder() {
      return 99;
    }
    compareTo(that) {
      if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that) {
      return this === that;
    }
    equals(that) {
      return this === that;
    }
    hashCode() {
      return Constructors.hash(Absent);
    }
    debug(output) {
      output = output.write("Value").write(46).write("absent").write(40).write(41);
      return output;
    }
    display(output) {
      output = output.write("undefined");
      return output;
    }
    static absent() {
      return new Absent;
    }
    static fromAny(value) {
      if (value instanceof Absent) {
        return value;
      } else if (value === void 0) {
        return Absent.absent();
      } else {
        throw new TypeError("" + value);
      }
    }
  }
  __decorate([ Lazy ], Absent, "absent", null);
  class Expression extends Value {
    constructor() {
      super();
    }
    conditional(thenTerm, elseTerm) {
      thenTerm = Item.fromAny(thenTerm);
      elseTerm = Item.fromAny(elseTerm);
      return new ConditionalOperator(this, thenTerm, elseTerm);
    }
    or(that) {
      that = Item.fromAny(that);
      return new OrOperator(this, that);
    }
    and(that) {
      that = Item.fromAny(that);
      return new AndOperator(this, that);
    }
    bitwiseOr(that) {
      that = Item.fromAny(that);
      return new BitwiseOrOperator(this, that);
    }
    bitwiseXor(that) {
      that = Item.fromAny(that);
      return new BitwiseXorOperator(this, that);
    }
    bitwiseAnd(that) {
      that = Item.fromAny(that);
      return new BitwiseAndOperator(this, that);
    }
    lt(that) {
      that = Item.fromAny(that);
      return new LtOperator(this, that);
    }
    le(that) {
      that = Item.fromAny(that);
      return new LeOperator(this, that);
    }
    eq(that) {
      that = Item.fromAny(that);
      return new EqOperator(this, that);
    }
    ne(that) {
      that = Item.fromAny(that);
      return new NeOperator(this, that);
    }
    ge(that) {
      that = Item.fromAny(that);
      return new GeOperator(this, that);
    }
    gt(that) {
      that = Item.fromAny(that);
      return new GtOperator(this, that);
    }
    plus(that) {
      that = Item.fromAny(that);
      return new PlusOperator(this, that);
    }
    minus(that) {
      that = Item.fromAny(that);
      return new MinusOperator(this, that);
    }
    times(that) {
      that = Item.fromAny(that);
      return new TimesOperator(this, that);
    }
    divide(that) {
      that = Item.fromAny(that);
      return new DivideOperator(this, that);
    }
    modulo(that) {
      that = Item.fromAny(that);
      return new ModuloOperator(this, that);
    }
    not() {
      return new NotOperator(this);
    }
    bitwiseNot() {
      return new BitwiseNotOperator(this);
    }
    negative() {
      return new NegativeOperator(this);
    }
    positive() {
      return new PositiveOperator(this);
    }
    inverse() {
      return new DivideOperator(Num.one, this);
    }
    toAny() {
      return this;
    }
  }
  class Operator extends Expression {
    constructor() {
      super();
    }
    static binary(operand1, operator, operand2) {
      switch (operator) {
       case "||":
        return new OrOperator(operand1, operand2);

       case "&&":
        return new AndOperator(operand1, operand2);

       case "|":
        return new BitwiseOrOperator(operand1, operand2);

       case "^":
        return new BitwiseXorOperator(operand1, operand2);

       case "&":
        return new BitwiseAndOperator(operand1, operand2);

       case "<":
        return new LtOperator(operand1, operand2);

       case "<=":
        return new LeOperator(operand1, operand2);

       case "==":
        return new EqOperator(operand1, operand2);

       case "!=":
        return new NeOperator(operand1, operand2);

       case ">=":
        return new GeOperator(operand1, operand2);

       case ">":
        return new GtOperator(operand1, operand2);

       case "+":
        return new PlusOperator(operand1, operand2);

       case "-":
        return new MinusOperator(operand1, operand2);

       case "*":
        return new TimesOperator(operand1, operand2);

       case "/":
        return new DivideOperator(operand1, operand2);

       case "%":
        return new ModuloOperator(operand1, operand2);

       default:
        throw new Error(operator);
      }
    }
    static unary(operator, operand) {
      switch (operator) {
       case "!":
        return new NotOperator(operand);

       case "~":
        return new BitwiseNotOperator(operand);

       case "-":
        return new NegativeOperator(operand);

       case "+":
        return new PositiveOperator(operand);

       default:
        throw new Error(operator);
      }
    }
  }
  class BinaryOperator extends Operator {
    constructor(operand1, operand2) {
      super();
      this.operand1 = operand1;
      this.operand2 = operand2;
    }
    isConstant() {
      return this.operand1.isConstant() && this.operand2.isConstant();
    }
    interpolateTo(that) {
      if (that instanceof BinaryOperator && this.operator === that.operator) {
        return BinaryOperatorInterpolator(this, that);
      } else {
        return super.interpolateTo(that);
      }
    }
  }
  const BinaryOperatorInterpolator = function(_super) {
    const BinaryOperatorInterpolator = function(y0, y1) {
      const operator = y0.operator;
      if (operator !== y1.operator) {
        throw new Error;
      }
      const interpolator = function(u) {
        const operand1 = interpolator.operand1Interpolator(u);
        const operand2 = interpolator.operand2Interpolator(u);
        return Operator.binary(operand1, interpolator.operator, operand2);
      };
      Object.setPrototypeOf(interpolator, BinaryOperatorInterpolator.prototype);
      interpolator.operand1Interpolator = y0.operand1.interpolateTo(y1.operand1);
      interpolator.operator = operator;
      interpolator.operand2Interpolator = y0.operand2.interpolateTo(y1.operand2);
      return interpolator;
    };
    BinaryOperatorInterpolator.prototype = Object.create(_super.prototype);
    BinaryOperatorInterpolator.prototype.constructor = BinaryOperatorInterpolator;
    Object.defineProperty(BinaryOperatorInterpolator.prototype, 0, {
      get() {
        const operand1 = this.operand1Interpolator[0];
        const operand2 = this.operand2Interpolator[0];
        return Operator.binary(operand1, this.operator, operand2);
      },
      configurable: true
    });
    Object.defineProperty(BinaryOperatorInterpolator.prototype, 1, {
      get() {
        const operand1 = this.operand1Interpolator[1];
        const operand2 = this.operand2Interpolator[1];
        return Operator.binary(operand1, this.operator, operand2);
      },
      configurable: true
    });
    BinaryOperatorInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof BinaryOperatorInterpolator) {
        return this.operator === that.operator && this.operand1Interpolator.equals(that.operand1Interpolator) && this.operand2Interpolator.equals(that.operand2Interpolator);
      }
      return false;
    };
    return BinaryOperatorInterpolator;
  }(Interpolator);
  class UnaryOperator extends Operator {
    constructor(operand) {
      super();
      this.operand = operand;
    }
    isConstant() {
      return this.operand.isConstant();
    }
    interpolateTo(that) {
      if (that instanceof UnaryOperator && this.operator === that.operator) {
        return UnaryOperatorInterpolator(this, that);
      } else {
        return super.interpolateTo(that);
      }
    }
  }
  const UnaryOperatorInterpolator = function(_super) {
    const UnaryOperatorInterpolator = function(y0, y1) {
      const operator = y0.operator;
      if (operator !== y1.operator) {
        throw new Error;
      }
      const interpolator = function(u) {
        const operand = interpolator.operandInterpolator(u);
        return Operator.unary(interpolator.operator, operand);
      };
      Object.setPrototypeOf(interpolator, UnaryOperatorInterpolator.prototype);
      interpolator.operator = operator;
      interpolator.operandInterpolator = y0.operand.interpolateTo(y1.operand);
      return interpolator;
    };
    UnaryOperatorInterpolator.prototype = Object.create(_super.prototype);
    UnaryOperatorInterpolator.prototype.constructor = UnaryOperatorInterpolator;
    Object.defineProperty(UnaryOperatorInterpolator.prototype, 0, {
      get() {
        const operand = this.operandInterpolator[0];
        return Operator.unary(this.operator, operand);
      },
      configurable: true
    });
    Object.defineProperty(UnaryOperatorInterpolator.prototype, 1, {
      get() {
        const operand = this.operandInterpolator[1];
        return Operator.unary(this.operator, operand);
      },
      configurable: true
    });
    UnaryOperatorInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof UnaryOperatorInterpolator) {
        return this.operator === that.operator && this.operandInterpolator.equals(that.operandInterpolator);
      }
      return false;
    };
    return UnaryOperatorInterpolator;
  }(Interpolator);
  class ConditionalOperator extends Operator {
    constructor(ifTerm, thenTerm, elseTerm) {
      super();
      this.ifTerm = ifTerm.commit();
      this.thenTerm = thenTerm.commit();
      this.elseTerm = elseTerm.commit();
    }
    isConstant() {
      return this.ifTerm.isConstant() && this.thenTerm.isConstant() && this.elseTerm.isConstant();
    }
    get precedence() {
      return 2;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      interpreter.willOperate(this);
      let result;
      const ifTerm = this.ifTerm.evaluate(interpreter);
      if (ifTerm.isDefinite()) {
        const theTerm = this.thenTerm.evaluate(interpreter);
        result = theTerm;
      } else {
        const elseTerm = this.elseTerm.evaluate(interpreter);
        result = elseTerm;
      }
      interpreter.didOperate(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const ifTerm = this.ifTerm.substitute(interpreter);
      const thenTerm = this.thenTerm.substitute(interpreter);
      const elseTerm = this.elseTerm.substitute(interpreter);
      return new ConditionalOperator(ifTerm, thenTerm, elseTerm);
    }
    interpolateTo(that) {
      if (that instanceof ConditionalOperator) {
        return ConditionalOperatorInterpolator(this, that);
      } else {
        return super.interpolateTo(that);
      }
    }
    get typeOrder() {
      return 20;
    }
    compareTo(that) {
      if (that instanceof ConditionalOperator) {
        let order = this.ifTerm.compareTo(that.ifTerm);
        if (order === 0) {
          order = this.thenTerm.compareTo(that.thenTerm);
          if (order === 0) {
            order = this.elseTerm.compareTo(that.elseTerm);
          }
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof ConditionalOperator) {
        return this.ifTerm.equivalentTo(that.ifTerm, epsilon) && this.thenTerm.equivalentTo(that.thenTerm, epsilon) && this.elseTerm.equivalentTo(that.elseTerm, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof ConditionalOperator) {
        return this.ifTerm.equals(that.ifTerm) && this.thenTerm.equals(that.thenTerm) && this.elseTerm.equals(that.elseTerm);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Constructors.hash(ConditionalOperator), this.ifTerm.hashCode()), this.thenTerm.hashCode()), this.elseTerm.hashCode()));
    }
    debug(output) {
      output = output.debug(this.ifTerm).write(46).write("conditional").write(40).debug(this.thenTerm).write(44).write(32).debug(this.elseTerm).write(41);
      return output;
    }
    clone() {
      return new ConditionalOperator(this.ifTerm.clone(), this.thenTerm.clone(), this.elseTerm.clone());
    }
  }
  const ConditionalOperatorInterpolator = function(_super) {
    const ConditionalOperatorInterpolator = function(y0, y1) {
      const interpolator = function(u) {
        const ifTerm = interpolator.ifTermInterpolator(u);
        const thenTerm = interpolator.thenTermInterpolator(u);
        const elseTerm = interpolator.elseTermInterpolator(u);
        return new ConditionalOperator(ifTerm, thenTerm, elseTerm);
      };
      Object.setPrototypeOf(interpolator, ConditionalOperatorInterpolator.prototype);
      interpolator.ifTermInterpolator = y0.ifTerm.interpolateTo(y1.ifTerm);
      interpolator.thenTermInterpolator = y0.thenTerm.interpolateTo(y1.thenTerm);
      interpolator.elseTermInterpolator = y0.elseTerm.interpolateTo(y1.elseTerm);
      return interpolator;
    };
    ConditionalOperatorInterpolator.prototype = Object.create(_super.prototype);
    ConditionalOperatorInterpolator.prototype.constructor = ConditionalOperatorInterpolator;
    Object.defineProperty(ConditionalOperatorInterpolator.prototype, 0, {
      get() {
        const ifTerm = this.ifTermInterpolator[0];
        const thenTerm = this.thenTermInterpolator[0];
        const elseTerm = this.elseTermInterpolator[0];
        return new ConditionalOperator(ifTerm, thenTerm, elseTerm);
      },
      configurable: true
    });
    Object.defineProperty(ConditionalOperatorInterpolator.prototype, 1, {
      get() {
        const ifTerm = this.ifTermInterpolator[1];
        const thenTerm = this.thenTermInterpolator[1];
        const elseTerm = this.elseTermInterpolator[1];
        return new ConditionalOperator(ifTerm, thenTerm, elseTerm);
      },
      configurable: true
    });
    ConditionalOperatorInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof ConditionalOperatorInterpolator) {
        return this.ifTermInterpolator.equals(that.ifTermInterpolator) && this.thenTermInterpolator.equals(that.thenTermInterpolator) && this.elseTermInterpolator.equals(that.elseTermInterpolator);
      }
      return false;
    };
    return ConditionalOperatorInterpolator;
  }(Interpolator);
  class InterpreterException extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, InterpreterException.prototype);
    }
  }
  class InterpreterSettings {
    constructor(maxScopeDepth) {
      Object.defineProperty(this, "maxScopeDepth", {
        value: maxScopeDepth,
        enumerable: true
      });
    }
    withMaxScopeDepth(maxScopeDepth) {
      return this.copy(maxScopeDepth);
    }
    copy(maxScopeDepth) {
      return new InterpreterSettings(maxScopeDepth);
    }
    canEqual(that) {
      return that instanceof InterpreterSettings;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof InterpreterSettings) {
        return that.canEqual(this) && this.maxScopeDepth === that.maxScopeDepth;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(InterpreterSettings), Numbers.hash(this.maxScopeDepth)));
    }
    debug(output) {
      output = output.write("new").write(32).write("InterpreterSettings").write(40).debug(this.maxScopeDepth).write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static standard() {
      const maxScopeDepth = 1024;
      return new InterpreterSettings(maxScopeDepth);
    }
  }
  __decorate([ Lazy ], InterpreterSettings, "standard", null);
  class Interpreter {
    constructor(settings, scopeStack, scopeDepth) {
      this.settings = settings !== void 0 ? settings : InterpreterSettings.standard();
      this.scopeStack = scopeStack !== void 0 ? scopeStack : null;
      this.scopeDepth = scopeDepth !== void 0 ? scopeDepth : 0;
    }
    withSettings(settings) {
      this.settings = settings;
      return this;
    }
    peekScope() {
      const scopeDepth = this.scopeDepth;
      if (scopeDepth <= 0) {
        throw new InterpreterException("scope stack empty");
      }
      return this.scopeStack[scopeDepth - 1];
    }
    getScope(index) {
      if (index < 0 || index >= this.scopeDepth) {
        throw new RangeError("" + index);
      }
      return this.scopeStack[index];
    }
    pushScope(scope) {
      const scopeDepth = this.scopeDepth;
      if (scopeDepth >= this.settings.maxScopeDepth) {
        throw new InterpreterException("scope stack overflow");
      }
      const oldScopeStack = this.scopeStack;
      let newScopeStack;
      if (oldScopeStack === null || scopeDepth + 1 > oldScopeStack.length) {
        newScopeStack = new Array(Interpreter.expand(scopeDepth + 1));
        if (oldScopeStack !== null) {
          for (let i = 0; i < scopeDepth; i += 1) {
            newScopeStack[i] = oldScopeStack[i];
          }
        }
        this.scopeStack = newScopeStack;
      } else {
        newScopeStack = oldScopeStack;
      }
      newScopeStack[scopeDepth] = scope;
      this.scopeDepth += 1;
    }
    popScope() {
      const scopeDepth = this.scopeDepth;
      if (scopeDepth <= 0) {
        throw new InterpreterException("scope stack empty");
      }
      const scopeStack = this.scopeStack;
      const scope = scopeStack[scopeDepth - 1];
      scopeStack[scopeDepth - 1] = void 0;
      this.scopeDepth -= 1;
      return scope;
    }
    swapScope(newScope) {
      const scopeDepth = this.scopeDepth;
      if (scopeDepth <= 0) {
        throw new InterpreterException("scope stack empty");
      }
      const scopeStack = this.scopeStack;
      const oldScope = scopeStack[scopeDepth - 1];
      scopeStack[scopeDepth - 1] = newScope;
      return oldScope;
    }
    willOperate(operator) {}
    didOperate(operator, result) {}
    willSelect(selector) {}
    didSelect(selector, result) {}
    willTransform(selector) {}
    didTransform(selector, result) {}
    static of(...objects) {
      const n = objects.length;
      const scopes = new Array(Interpreter.expand(n));
      for (let i = 0; i < n; i += 1) {
        const scope = Item.fromAny(objects[i]);
        scopes[i] = scope;
      }
      return new Interpreter(InterpreterSettings.standard(), scopes, n);
    }
    static fromAny(interpreter, globalScope = Item.globalScope()) {
      if (!(interpreter instanceof Interpreter)) {
        const scope = interpreter;
        interpreter = new Interpreter;
        if (globalScope !== void 0) {
          interpreter.pushScope(globalScope);
        }
        if (scope !== void 0) {
          interpreter.pushScope(Item.fromAny(scope));
        }
      }
      return interpreter;
    }
    static expand(n) {
      n = Math.max(32, n) - 1;
      n |= n >> 1;
      n |= n >> 2;
      n |= n >> 4;
      n |= n >> 8;
      n |= n >> 16;
      return n + 1;
    }
  }
  class OrOperator extends BinaryOperator {
    constructor(operand1, operand2) {
      super(operand1, operand2);
    }
    get operator() {
      return "||";
    }
    get precedence() {
      return 3;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      interpreter.willOperate(this);
      let result;
      const argument1 = this.operand1.evaluate(interpreter);
      if (argument1.isDefinite()) {
        result = argument1;
      } else {
        const argument2 = this.operand2.evaluate(interpreter);
        result = argument2;
      }
      interpreter.didOperate(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument1 = this.operand1.substitute(interpreter);
      const argument2 = this.operand2.substitute(interpreter);
      return argument1.or(argument2);
    }
    get typeOrder() {
      return 21;
    }
    compareTo(that) {
      if (that instanceof OrOperator) {
        let order = this.operand1.compareTo(that.operand1);
        if (order === 0) {
          order = this.operand2.compareTo(that.operand2);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof OrOperator) {
        return this.operand1.equivalentTo(that.operand1, epsilon) && this.operand2.equivalentTo(that.operand2, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof OrOperator) {
        return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(OrOperator), this.operand1.hashCode()), this.operand2.hashCode()));
    }
    debug(output) {
      output = output.debug(this.operand1).write(46).write("or").write(40).debug(this.operand2).write(41);
      return output;
    }
    clone() {
      return new OrOperator(this.operand1.clone(), this.operand2.clone());
    }
  }
  class AndOperator extends BinaryOperator {
    constructor(operand1, operand2) {
      super(operand1, operand2);
    }
    get operator() {
      return "&&";
    }
    get precedence() {
      return 4;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      interpreter.willOperate(this);
      let result;
      const argument1 = this.operand1.evaluate(interpreter);
      if (argument1.isDefinite()) {
        const argument2 = this.operand2.evaluate(interpreter);
        result = argument2;
      } else {
        result = argument1;
      }
      interpreter.didOperate(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument1 = this.operand1.substitute(interpreter);
      const argument2 = this.operand2.substitute(interpreter);
      return argument1.and(argument2);
    }
    get typeOrder() {
      return 22;
    }
    compareTo(that) {
      if (that instanceof AndOperator) {
        let order = this.operand1.compareTo(that.operand1);
        if (order === 0) {
          order = this.operand2.compareTo(that.operand2);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof AndOperator) {
        return this.operand1.equivalentTo(that.operand1, epsilon) && this.operand2.equivalentTo(that.operand2, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof AndOperator) {
        return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(AndOperator), this.operand1.hashCode()), this.operand2.hashCode()));
    }
    debug(output) {
      output = output.debug(this.operand1).write(46).write("and").write(40).debug(this.operand2).write(41);
      return output;
    }
    clone() {
      return new AndOperator(this.operand1.clone(), this.operand2.clone());
    }
  }
  class BitwiseOrOperator extends BinaryOperator {
    constructor(operand1, operand2) {
      super(operand1, operand2);
    }
    get operator() {
      return "|";
    }
    get precedence() {
      return 5;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      interpreter.willOperate(this);
      const argument1 = this.operand1.evaluate(interpreter);
      const argument2 = this.operand2.evaluate(interpreter);
      const result = argument1.bitwiseOr(argument2);
      interpreter.didOperate(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument1 = this.operand1.substitute(interpreter);
      const argument2 = this.operand2.substitute(interpreter);
      return argument1.bitwiseOr(argument2);
    }
    get typeOrder() {
      return 23;
    }
    compareTo(that) {
      if (that instanceof BitwiseOrOperator) {
        let order = this.operand1.compareTo(that.operand1);
        if (order === 0) {
          order = this.operand2.compareTo(that.operand2);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof BitwiseOrOperator) {
        return this.operand1.equivalentTo(that.operand1, epsilon) && this.operand2.equivalentTo(that.operand2, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof BitwiseOrOperator) {
        return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(BitwiseOrOperator), this.operand1.hashCode()), this.operand2.hashCode()));
    }
    debug(output) {
      output = output.debug(this.operand1).write(46).write("bitwiseOr").write(40).debug(this.operand2).write(41);
      return output;
    }
    clone() {
      return new BitwiseOrOperator(this.operand1.clone(), this.operand2.clone());
    }
  }
  class BitwiseXorOperator extends BinaryOperator {
    constructor(operand1, operand2) {
      super(operand1, operand2);
    }
    get operator() {
      return "^";
    }
    get precedence() {
      return 6;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      interpreter.willOperate(this);
      const argument1 = this.operand1.evaluate(interpreter);
      const argument2 = this.operand2.evaluate(interpreter);
      const result = argument1.bitwiseXor(argument2);
      interpreter.didOperate(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument1 = this.operand1.substitute(interpreter);
      const argument2 = this.operand2.substitute(interpreter);
      return argument1.bitwiseXor(argument2);
    }
    get typeOrder() {
      return 24;
    }
    compareTo(that) {
      if (that instanceof BitwiseXorOperator) {
        let order = this.operand1.compareTo(that.operand1);
        if (order === 0) {
          order = this.operand2.compareTo(that.operand2);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof BitwiseXorOperator) {
        return this.operand1.equivalentTo(that.operand1, epsilon) && this.operand2.equivalentTo(that.operand2, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof BitwiseXorOperator) {
        return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(BitwiseXorOperator), this.operand1.hashCode()), this.operand2.hashCode()));
    }
    debug(output) {
      output = output.debug(this.operand1).write(46).write("bitwiseXor").write(40).debug(this.operand2).write(41);
      return output;
    }
    clone() {
      return new BitwiseXorOperator(this.operand1.clone(), this.operand2.clone());
    }
  }
  class BitwiseAndOperator extends BinaryOperator {
    constructor(operand1, operand2) {
      super(operand1, operand2);
    }
    get operator() {
      return "&";
    }
    get precedence() {
      return 7;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      interpreter.willOperate(this);
      const argument1 = this.operand1.evaluate(interpreter);
      const argument2 = this.operand2.evaluate(interpreter);
      const result = argument1.bitwiseAnd(argument2);
      interpreter.didOperate(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument1 = this.operand1.substitute(interpreter);
      const argument2 = this.operand2.substitute(interpreter);
      return argument1.bitwiseAnd(argument2);
    }
    get typeOrder() {
      return 25;
    }
    compareTo(that) {
      if (that instanceof BitwiseAndOperator) {
        let order = this.operand1.compareTo(that.operand1);
        if (order === 0) {
          order = this.operand2.compareTo(that.operand2);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof BitwiseAndOperator) {
        return this.operand1.equivalentTo(that.operand1, epsilon) && this.operand2.equivalentTo(that.operand2, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof BitwiseAndOperator) {
        return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(BitwiseAndOperator), this.operand1.hashCode()), this.operand2.hashCode()));
    }
    debug(output) {
      output = output.debug(this.operand1).write(46).write("bitwiseAnd").write(40).debug(this.operand2).write(41);
      return output;
    }
    clone() {
      return new BitwiseAndOperator(this.operand1.clone(), this.operand2.clone());
    }
  }
  class LtOperator extends BinaryOperator {
    constructor(operand1, operand2) {
      super(operand1, operand2);
    }
    get operator() {
      return "<";
    }
    get precedence() {
      return 0;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      interpreter.willOperate(this);
      const argument1 = this.operand1.evaluate(interpreter);
      const argument2 = this.operand2.evaluate(interpreter);
      const result = argument1.lt(argument2);
      interpreter.didOperate(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument1 = this.operand1.substitute(interpreter);
      const argument2 = this.operand2.substitute(interpreter);
      return argument1.lt(argument2);
    }
    get typeOrder() {
      return 26;
    }
    compareTo(that) {
      if (that instanceof LtOperator) {
        let order = this.operand1.compareTo(that.operand1);
        if (order === 0) {
          order = this.operand2.compareTo(that.operand2);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof LtOperator) {
        return this.operand1.equivalentTo(that.operand1, epsilon) && this.operand2.equivalentTo(that.operand2, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof LtOperator) {
        return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(LtOperator), this.operand1.hashCode()), this.operand2.hashCode()));
    }
    debug(output) {
      return output.debug(this.operand1).write(46).write("lt").write(40).debug(this.operand2).write(41);
    }
    clone() {
      return new LtOperator(this.operand1.clone(), this.operand2.clone());
    }
  }
  class LeOperator extends BinaryOperator {
    constructor(operand1, operand2) {
      super(operand1, operand2);
    }
    get operator() {
      return "<=";
    }
    get precedence() {
      return 0;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      interpreter.willOperate(this);
      const argument1 = this.operand1.evaluate(interpreter);
      const argument2 = this.operand2.evaluate(interpreter);
      const result = argument1.le(argument2);
      interpreter.didOperate(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument1 = this.operand1.substitute(interpreter);
      const argument2 = this.operand2.substitute(interpreter);
      return argument1.le(argument2);
    }
    get typeOrder() {
      return 27;
    }
    compareTo(that) {
      if (that instanceof LeOperator) {
        let order = this.operand1.compareTo(that.operand1);
        if (order === 0) {
          order = this.operand2.compareTo(that.operand2);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof LeOperator) {
        return this.operand1.equivalentTo(that.operand1, epsilon) && this.operand2.equivalentTo(that.operand2, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof LeOperator) {
        return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(LeOperator), this.operand1.hashCode()), this.operand2.hashCode()));
    }
    debug(output) {
      return output.debug(this.operand1).write(46).write("le").write(40).debug(this.operand2).write(41);
    }
    clone() {
      return new LeOperator(this.operand1.clone(), this.operand2.clone());
    }
  }
  class EqOperator extends BinaryOperator {
    constructor(operand1, operand2) {
      super(operand1, operand2);
    }
    get operator() {
      return "==";
    }
    get precedence() {
      return 0;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      interpreter.willOperate(this);
      const argument1 = this.operand1.evaluate(interpreter);
      const argument2 = this.operand2.evaluate(interpreter);
      const result = argument1.eq(argument2);
      interpreter.didOperate(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument1 = this.operand1.substitute(interpreter);
      const argument2 = this.operand2.substitute(interpreter);
      return argument1.eq(argument2);
    }
    get typeOrder() {
      return 28;
    }
    compareTo(that) {
      if (that instanceof EqOperator) {
        let order = this.operand1.compareTo(that.operand1);
        if (order === 0) {
          order = this.operand2.compareTo(that.operand2);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof EqOperator) {
        return this.operand1.equivalentTo(that.operand1, epsilon) && this.operand2.equivalentTo(that.operand2, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof EqOperator) {
        return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(EqOperator), this.operand1.hashCode()), this.operand2.hashCode()));
    }
    debug(output) {
      output = output.debug(this.operand1).write(46).write("eq").write(40).debug(this.operand2).write(41);
      return output;
    }
    clone() {
      return new EqOperator(this.operand1.clone(), this.operand2.clone());
    }
  }
  class NeOperator extends BinaryOperator {
    constructor(operand1, operand2) {
      super(operand1, operand2);
    }
    get operator() {
      return "!=";
    }
    get precedence() {
      return 0;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      interpreter.willOperate(this);
      const argument1 = this.operand1.evaluate(interpreter);
      const argument2 = this.operand2.evaluate(interpreter);
      const result = argument1.ne(argument2);
      interpreter.didOperate(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument1 = this.operand1.substitute(interpreter);
      const argument2 = this.operand2.substitute(interpreter);
      return argument1.ne(argument2);
    }
    get typeOrder() {
      return 29;
    }
    compareTo(that) {
      if (that instanceof NeOperator) {
        let order = this.operand1.compareTo(that.operand1);
        if (order === 0) {
          order = this.operand2.compareTo(that.operand2);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof NeOperator) {
        return this.operand1.equivalentTo(that.operand1, epsilon) && this.operand2.equivalentTo(that.operand2, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof NeOperator) {
        return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(NeOperator), this.operand1.hashCode()), this.operand2.hashCode()));
    }
    debug(output) {
      output = output.debug(this.operand1).write(46).write("ne").write(40).debug(this.operand2).write(41);
      return output;
    }
    clone() {
      return new NeOperator(this.operand1.clone(), this.operand2.clone());
    }
  }
  class GeOperator extends BinaryOperator {
    constructor(operand1, operand2) {
      super(operand1, operand2);
    }
    get operator() {
      return ">=";
    }
    get precedence() {
      return 0;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      interpreter.willOperate(this);
      const argument1 = this.operand1.evaluate(interpreter);
      const argument2 = this.operand2.evaluate(interpreter);
      const result = argument1.ge(argument2);
      interpreter.didOperate(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument1 = this.operand1.substitute(interpreter);
      const argument2 = this.operand2.substitute(interpreter);
      return argument1.ge(argument2);
    }
    get typeOrder() {
      return 30;
    }
    compareTo(that) {
      if (that instanceof GeOperator) {
        let order = this.operand1.compareTo(that.operand1);
        if (order === 0) {
          order = this.operand2.compareTo(that.operand2);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof GeOperator) {
        return this.operand1.equivalentTo(that.operand1, epsilon) && this.operand2.equivalentTo(that.operand2, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof GeOperator) {
        return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(GeOperator), this.operand1.hashCode()), this.operand2.hashCode()));
    }
    debug(output) {
      output = output.debug(this.operand1).write(46).write("ge").write(40).debug(this.operand2).write(41);
      return output;
    }
    clone() {
      return new GeOperator(this.operand1.clone(), this.operand2.clone());
    }
  }
  class GtOperator extends BinaryOperator {
    constructor(operand1, operand2) {
      super(operand1, operand2);
    }
    get operator() {
      return ">";
    }
    get precedence() {
      return 0;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      interpreter.willOperate(this);
      const argument1 = this.operand1.evaluate(interpreter);
      const argument2 = this.operand2.evaluate(interpreter);
      const result = argument1.gt(argument2);
      interpreter.didOperate(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument1 = this.operand1.substitute(interpreter);
      const argument2 = this.operand2.substitute(interpreter);
      return argument1.gt(argument2);
    }
    get typeOrder() {
      return 31;
    }
    compareTo(that) {
      if (that instanceof GtOperator) {
        let order = this.operand1.compareTo(that.operand1);
        if (order === 0) {
          order = this.operand2.compareTo(that.operand2);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof GtOperator) {
        return this.operand1.equivalentTo(that.operand1, epsilon) && this.operand2.equivalentTo(that.operand2, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof GtOperator) {
        return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(GtOperator), this.operand1.hashCode()), this.operand2.hashCode()));
    }
    debug(output) {
      output = output.debug(this.operand1).write(46).write("gt").write(40).debug(this.operand2).write(41);
      return output;
    }
    clone() {
      return new GtOperator(this.operand1.clone(), this.operand2.clone());
    }
  }
  class PlusOperator extends BinaryOperator {
    constructor(operand1, operand2) {
      super(operand1, operand2);
    }
    get operator() {
      return "+";
    }
    get precedence() {
      return 8;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      interpreter.willOperate(this);
      const argument1 = this.operand1.evaluate(interpreter);
      const argument2 = this.operand2.evaluate(interpreter);
      const result = argument1.plus(argument2);
      interpreter.didOperate(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument1 = this.operand1.substitute(interpreter);
      const argument2 = this.operand2.substitute(interpreter);
      return argument1.plus(argument2);
    }
    get typeOrder() {
      return 32;
    }
    compareTo(that) {
      if (that instanceof PlusOperator) {
        let order = this.operand1.compareTo(that.operand1);
        if (order === 0) {
          order = this.operand2.compareTo(that.operand2);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof PlusOperator) {
        return this.operand1.equivalentTo(that.operand1, epsilon) && this.operand2.equivalentTo(that.operand2, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof PlusOperator) {
        return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(PlusOperator), this.operand1.hashCode()), this.operand2.hashCode()));
    }
    debug(output) {
      output = output.debug(this.operand1).write(46).write("plus").write(40).debug(this.operand2).write(41);
      return output;
    }
    clone() {
      return new PlusOperator(this.operand1.clone(), this.operand2.clone());
    }
  }
  class MinusOperator extends BinaryOperator {
    constructor(operand1, operand2) {
      super(operand1, operand2);
    }
    get operator() {
      return "-";
    }
    get precedence() {
      return 8;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      interpreter.willOperate(this);
      const argument1 = this.operand1.evaluate(interpreter);
      const argument2 = this.operand2.evaluate(interpreter);
      const result = argument1.minus(argument2);
      interpreter.didOperate(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument1 = this.operand1.substitute(interpreter);
      const argument2 = this.operand2.substitute(interpreter);
      return argument1.minus(argument2);
    }
    get typeOrder() {
      return 33;
    }
    compareTo(that) {
      if (that instanceof MinusOperator) {
        let order = this.operand1.compareTo(that.operand1);
        if (order === 0) {
          order = this.operand2.compareTo(that.operand2);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof MinusOperator) {
        return this.operand1.equivalentTo(that.operand1, epsilon) && this.operand2.equivalentTo(that.operand2, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof MinusOperator) {
        return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(MinusOperator), this.operand1.hashCode()), this.operand2.hashCode()));
    }
    debug(output) {
      output = output.debug(this.operand1).write(46).write("minus").write(40).debug(this.operand2).write(41);
      return output;
    }
    clone() {
      return new MinusOperator(this.operand1.clone(), this.operand2.clone());
    }
  }
  class TimesOperator extends BinaryOperator {
    constructor(operand1, operand2) {
      super(operand1, operand2);
    }
    get operator() {
      return "*";
    }
    get precedence() {
      return 9;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      interpreter.willOperate(this);
      const argument1 = this.operand1.evaluate(interpreter);
      const argument2 = this.operand2.evaluate(interpreter);
      const result = argument1.times(argument2);
      interpreter.didOperate(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument1 = this.operand1.substitute(interpreter);
      const argument2 = this.operand2.substitute(interpreter);
      return argument1.times(argument2);
    }
    get typeOrder() {
      return 34;
    }
    compareTo(that) {
      if (that instanceof TimesOperator) {
        let order = this.operand1.compareTo(that.operand1);
        if (order === 0) {
          order = this.operand2.compareTo(that.operand2);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof TimesOperator) {
        return this.operand1.equivalentTo(that.operand1, epsilon) && this.operand2.equivalentTo(that.operand2, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof TimesOperator) {
        return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(TimesOperator), this.operand1.hashCode()), this.operand2.hashCode()));
    }
    debug(output) {
      output = output.debug(this.operand1).write(46).write("times").write(40).debug(this.operand2).write(41);
      return output;
    }
    clone() {
      return new TimesOperator(this.operand1.clone(), this.operand2.clone());
    }
  }
  class DivideOperator extends BinaryOperator {
    constructor(operand1, operand2) {
      super(operand1, operand2);
    }
    get operator() {
      return "/";
    }
    get precedence() {
      return 9;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      interpreter.willOperate(this);
      const argument1 = this.operand1.evaluate(interpreter);
      const argument2 = this.operand2.evaluate(interpreter);
      const result = argument1.divide(argument2);
      interpreter.didOperate(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument1 = this.operand1.substitute(interpreter);
      const argument2 = this.operand2.substitute(interpreter);
      return argument1.divide(argument2);
    }
    get typeOrder() {
      return 35;
    }
    compareTo(that) {
      if (that instanceof DivideOperator) {
        let order = this.operand1.compareTo(that.operand1);
        if (order === 0) {
          order = this.operand2.compareTo(that.operand2);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof DivideOperator) {
        return this.operand1.equivalentTo(that.operand1, epsilon) && this.operand2.equivalentTo(that.operand2, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof DivideOperator) {
        return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(DivideOperator), this.operand1.hashCode()), this.operand2.hashCode()));
    }
    debug(output) {
      output = output.debug(this.operand1).write(46).write("divide").write(40).debug(this.operand2).write(41);
      return output;
    }
    clone() {
      return new DivideOperator(this.operand1.clone(), this.operand2.clone());
    }
  }
  class ModuloOperator extends BinaryOperator {
    constructor(operand1, operand2) {
      super(operand1, operand2);
    }
    get operator() {
      return "%";
    }
    get precedence() {
      return 9;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      interpreter.willOperate(this);
      const argument1 = this.operand1.evaluate(interpreter);
      const argument2 = this.operand2.evaluate(interpreter);
      const result = argument1.modulo(argument2);
      interpreter.didOperate(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument1 = this.operand1.substitute(interpreter);
      const argument2 = this.operand2.substitute(interpreter);
      return argument1.modulo(argument2);
    }
    get typeOrder() {
      return 36;
    }
    compareTo(that) {
      if (that instanceof ModuloOperator) {
        let order = this.operand1.compareTo(that.operand1);
        if (order === 0) {
          order = this.operand2.compareTo(that.operand2);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof ModuloOperator) {
        return this.operand1.equivalentTo(that.operand1, epsilon) && this.operand2.equivalentTo(that.operand2, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof ModuloOperator) {
        return this.operand1.equals(that.operand1) && this.operand2.equals(that.operand2);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(ModuloOperator), this.operand1.hashCode()), this.operand2.hashCode()));
    }
    debug(output) {
      output = output.debug(this.operand1).write(46).write("modulo").write(40).debug(this.operand2).write(41);
      return output;
    }
    clone() {
      return new ModuloOperator(this.operand1.clone(), this.operand2.clone());
    }
  }
  class NotOperator extends UnaryOperator {
    constructor(operand) {
      super(operand);
    }
    get operator() {
      return "!";
    }
    get precedence() {
      return 10;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument = this.operand.evaluate(interpreter);
      return argument.not();
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument = this.operand.substitute(interpreter);
      return argument.not();
    }
    get typeOrder() {
      return 37;
    }
    compareTo(that) {
      return Numbers.compare(this.typeOrder, that.typeOrder);
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof NotOperator) {
        return this.operand.equivalentTo(that.operand, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof NotOperator) {
        return this.operand.equals(that.operand);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(NotOperator), this.operand.hashCode()));
    }
    debug(output) {
      output = output.debug(this.operand).write(46).write("not").write(40).write(41);
      return output;
    }
    clone() {
      return new NotOperator(this.operand.clone());
    }
  }
  class BitwiseNotOperator extends UnaryOperator {
    constructor(operand) {
      super(operand);
    }
    get operator() {
      return "~";
    }
    get precedence() {
      return 10;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument = this.operand.evaluate(interpreter);
      return argument.bitwiseNot();
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument = this.operand.substitute(interpreter);
      return argument.bitwiseNot();
    }
    get typeOrder() {
      return 38;
    }
    compareTo(that) {
      if (that instanceof BitwiseNotOperator) {
        return this.operand.compareTo(that.operand);
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof BitwiseNotOperator) {
        return this.operand.equivalentTo(that.operand, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof BitwiseNotOperator) {
        return this.operand.equals(that.operand);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(BitwiseNotOperator), this.operand.hashCode()));
    }
    debug(output) {
      output = output.debug(this.operand).write(46).write("bitwiseNot").write(40).write(41);
      return output;
    }
    clone() {
      return new BitwiseNotOperator(this.operand.clone());
    }
  }
  class NegativeOperator extends UnaryOperator {
    constructor(operand) {
      super(operand);
    }
    get operator() {
      return "-";
    }
    get precedence() {
      return 10;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument = this.operand.evaluate(interpreter);
      return argument.negative();
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument = this.operand.substitute(interpreter);
      return argument.negative();
    }
    get typeOrder() {
      return 39;
    }
    compareTo(that) {
      if (that instanceof NegativeOperator) {
        return this.operand.compareTo(that.operand);
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof NegativeOperator) {
        return this.operand.equivalentTo(that.operand, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof NegativeOperator) {
        return this.operand.equals(that.operand);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(NegativeOperator), this.operand.hashCode()));
    }
    debug(output) {
      output = output.debug(this.operand).write(46).write("negative").write(40).write(41);
      return output;
    }
    clone() {
      return new NegativeOperator(this.operand.clone());
    }
  }
  class PositiveOperator extends UnaryOperator {
    constructor(operand) {
      super(operand);
    }
    get operator() {
      return "+";
    }
    get precedence() {
      return 10;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument = this.operand.evaluate(interpreter);
      return argument.positive();
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const argument = this.operand.substitute(interpreter);
      return argument.positive();
    }
    get typeOrder() {
      return 40;
    }
    compareTo(that) {
      if (that instanceof PositiveOperator) {
        return this.operand.compareTo(that.operand);
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof PositiveOperator) {
        return this.operand.equivalentTo(that.operand, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof PositiveOperator) {
        return this.operand.equals(that.operand);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(PositiveOperator), this.operand.hashCode()));
    }
    debug(output) {
      output = output.debug(this.operand).write(46).write("positive").write(40).write(41);
      return output;
    }
    clone() {
      return new PositiveOperator(this.operand.clone());
    }
  }
  class InvokeOperator extends Operator {
    constructor(func, args) {
      super();
      this.func = func;
      this.args = args.commit();
      this.state = void 0;
    }
    setState(state) {
      this.state = state;
    }
    isConstant() {
      return this.func.isConstant() && this.args.isConstant();
    }
    get precedence() {
      return 11;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const func = this.func.evaluate(interpreter);
      if (func instanceof Func) {
        return func.invoke(this.args, interpreter, this);
      }
      return Item.absent();
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const func = this.func.evaluate(interpreter);
      if (func instanceof Func) {
        const result = func.expand(this.args, interpreter, this);
        if (result !== void 0) {
          return result;
        }
      }
      const args = this.args.substitute(interpreter).toValue();
      return new InvokeOperator(this.func, args);
    }
    interpolateTo(that) {
      if (that instanceof InvokeOperator) {
        return InvokeOperatorInterpolator(this, that);
      } else {
        return super.interpolateTo(that);
      }
    }
    get typeOrder() {
      return 41;
    }
    compareTo(that) {
      if (that instanceof InvokeOperator) {
        let order = this.func.compareTo(that.func);
        if (order === 0) {
          order = this.args.compareTo(that.args);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof InvokeOperator) {
        return this.func.equals(that.func) && this.args.equivalentTo(that.args, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof InvokeOperator) {
        return this.func.equals(that.func) && this.args.equals(that.args);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(InvokeOperator), this.func.hashCode()), this.args.hashCode()));
    }
    debug(output) {
      output = output.debug(this.func).write(46).write("invoke").write(40).debug(this.args).write(41);
      return output;
    }
    clone() {
      return new InvokeOperator(this.func.clone(), this.args.clone());
    }
  }
  const InvokeOperatorInterpolator = function(_super) {
    const InvokeOperatorInterpolator = function(y0, y1) {
      const interpolator = function(u) {
        const func = interpolator.funcInterpolator(u);
        const args = interpolator.argsInterpolator(u);
        return new InvokeOperator(func, args);
      };
      Object.setPrototypeOf(interpolator, InvokeOperatorInterpolator.prototype);
      interpolator.funcInterpolator = y0.func.interpolateTo(y1.func);
      interpolator.argsInterpolator = y0.args.interpolateTo(y1.args);
      return interpolator;
    };
    InvokeOperatorInterpolator.prototype = Object.create(_super.prototype);
    InvokeOperatorInterpolator.prototype.constructor = InvokeOperatorInterpolator;
    Object.defineProperty(InvokeOperatorInterpolator.prototype, 0, {
      get() {
        const func = this.funcInterpolator[0];
        const args = this.argsInterpolator[0];
        return new InvokeOperator(func, args);
      },
      configurable: true
    });
    Object.defineProperty(InvokeOperatorInterpolator.prototype, 1, {
      get() {
        const func = this.funcInterpolator[1];
        const args = this.argsInterpolator[1];
        return new InvokeOperator(func, args);
      },
      configurable: true
    });
    InvokeOperatorInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof InvokeOperatorInterpolator) {
        return this.funcInterpolator.equals(that.funcInterpolator) && this.argsInterpolator.equals(that.argsInterpolator);
      }
      return false;
    };
    return InvokeOperatorInterpolator;
  }(Interpolator);
  class Selector extends Expression {
    constructor() {
      super();
    }
    isConstant() {
      return false;
    }
    evaluate(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const selected = Record.create();
      this.forSelected(interpreter, (function(interpreter) {
        const scope = interpreter.peekScope();
        if (scope !== void 0) {
          selected.push(scope);
        }
      }), this);
      return selected.isEmpty() ? Item.absent() : selected.flattened();
    }
    get(key) {
      key = Value.fromAny(key);
      return this.andThen(new GetSelector(key, Selector.identity()));
    }
    getAttr(key) {
      key = Text.fromAny(key);
      return this.andThen(new GetAttrSelector(key, Selector.identity()));
    }
    getItem(index) {
      index = Num.fromAny(index);
      return this.andThen(new GetItemSelector(index, Selector.identity()));
    }
    keys() {
      return this.andThen(Selector.keys());
    }
    values() {
      return this.andThen(Selector.values());
    }
    children() {
      return this.andThen(Selector.children());
    }
    descendants() {
      return this.andThen(Selector.descendants());
    }
    filter(predicate) {
      if (arguments.length === 0) {
        return new FilterSelector(this, Selector.identity());
      } else {
        predicate = Item.fromAny(predicate);
        return this.andThen(predicate.filter());
      }
    }
    invoke(args) {
      return new InvokeOperator(this, args);
    }
    get precedence() {
      return 11;
    }
    debug(output) {
      output = output.write("Selector").write(46).write("identity").write(40).write(41);
      output = this.debugThen(output);
      return output;
    }
    static identity() {
      return new IdentitySelector;
    }
    static get(key) {
      key = Value.fromAny(key);
      return new GetSelector(key, Selector.identity());
    }
    static getAttr(key) {
      key = Text.fromAny(key);
      return new GetAttrSelector(key, Selector.identity());
    }
    static getItem(index) {
      index = Num.fromAny(index);
      return new GetItemSelector(index, Selector.identity());
    }
    static keys() {
      return new KeysSelector(Selector.identity());
    }
    static values() {
      return new ValuesSelector(Selector.identity());
    }
    static children() {
      return new ChildrenSelector(Selector.identity());
    }
    static descendants() {
      return new DescendantsSelector(Selector.identity());
    }
    static literal(item) {
      item = Item.fromAny(item);
      if (!(item instanceof Selector)) {
        item = new LiteralSelector(item, Selector.identity());
      }
      return item;
    }
  }
  __decorate([ Lazy ], Selector, "identity", null);
  __decorate([ Lazy ], Selector, "keys", null);
  __decorate([ Lazy ], Selector, "values", null);
  __decorate([ Lazy ], Selector, "children", null);
  __decorate([ Lazy ], Selector, "descendants", null);
  class IdentitySelector extends Selector {
    get then() {
      return this;
    }
    forSelected(interpreter, callback, thisArg) {
      let selected;
      interpreter.willSelect(this);
      if (interpreter.scopeDepth !== 0) {
        const oldScope = interpreter.popScope();
        const newScope = oldScope.evaluate(interpreter);
        interpreter.pushScope(newScope);
        selected = callback.call(thisArg, interpreter);
        interpreter.swapScope(oldScope);
      }
      interpreter.didSelect(this, selected);
      return selected;
    }
    mapSelected(interpreter, transform, thisArg) {
      return transform.call(thisArg, interpreter);
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      return interpreter.peekScope().substitute(interpreter);
    }
    get(key) {
      key = Value.fromAny(key);
      return new GetSelector(key, this);
    }
    getAttr(key) {
      key = Text.fromAny(key);
      return new GetAttrSelector(key, this);
    }
    getItem(index) {
      index = Num.fromAny(index);
      return new GetItemSelector(index, this);
    }
    andThen(then) {
      return then;
    }
    keys() {
      return Selector.keys();
    }
    values() {
      return Selector.values();
    }
    children() {
      return Selector.children();
    }
    descendants() {
      return Selector.descendants();
    }
    filter(predicate) {
      if (arguments.length === 0) {
        return new FilterSelector(this, this);
      } else {
        predicate = Item.fromAny(predicate);
        return predicate.filter();
      }
    }
    get typeOrder() {
      return 10;
    }
    compareTo(that) {
      if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that) {
      return this === that;
    }
    equals(that) {
      return this === that;
    }
    hashCode() {
      return Constructors.hash(IdentitySelector);
    }
    debugThen(output) {
      return output;
    }
    clone() {
      return this;
    }
  }
  class GetSelector extends Selector {
    constructor(key, then) {
      super();
      this.item = key.commit();
      this.then = then;
    }
    forSelected(interpreter, callback, thisArg) {
      interpreter.willSelect(this);
      const key = this.item.evaluate(interpreter).toValue();
      const selected = GetSelector.forSelected(key, this.then, interpreter, callback, thisArg);
      interpreter.didSelect(this, selected);
      return selected;
    }
    static forSelected(key, then, interpreter, callback, thisArg) {
      let selected;
      if (interpreter.scopeDepth !== 0) {
        const scope = interpreter.popScope().toValue();
        let field;
        if (scope instanceof Record) {
          field = scope.getField(key);
          if (field !== void 0) {
            interpreter.pushScope(field.toValue());
            selected = then.forSelected(interpreter, callback, thisArg);
            interpreter.popScope();
          }
        }
        if (field === void 0 && selected === void 0) {
          GetSelector.forSelected(key, then, interpreter, callback, thisArg);
        }
        interpreter.pushScope(scope);
      }
      return selected;
    }
    mapSelected(interpreter, transform, thisArg) {
      let result;
      interpreter.willTransform(this);
      const key = this.item.evaluate(interpreter).toValue();
      if (interpreter.scopeDepth !== 0) {
        const scope = interpreter.popScope().toValue();
        if (scope instanceof Record) {
          const oldField = scope.getField(key);
          if (oldField !== void 0) {
            interpreter.pushScope(oldField.toValue());
            const newItem = this.then.mapSelected(interpreter, transform, thisArg);
            interpreter.popScope();
            if (newItem instanceof Field) {
              if (key.equals(newItem.key)) {
                scope.set(key, newItem.toValue());
              } else {
                scope.delete(key);
                scope.push(newItem);
              }
            } else if (newItem.isDefined()) {
              scope.set(key, newItem.toValue());
            } else {
              scope.delete(key);
            }
          }
        }
        interpreter.pushScope(scope);
        result = scope;
      } else {
        result = Item.absent();
      }
      interpreter.didTransform(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const key = this.item.evaluate(interpreter).toValue();
      const value = GetSelector.substitute(key, this.then, interpreter);
      if (value !== void 0) {
        return value;
      }
      let then = this.then.substitute(interpreter);
      if (!(then instanceof Selector)) {
        then = this.then;
      }
      return new GetSelector(this.item, then);
    }
    static substitute(key, then, interpreter) {
      let selected;
      if (interpreter.scopeDepth !== 0) {
        const scope = interpreter.popScope().toValue();
        let field;
        if (scope instanceof Record) {
          field = scope.getField(key);
          if (field !== void 0) {
            selected = field.toValue().substitute(interpreter);
          }
        }
        if (field === void 0 && selected === void 0) {
          GetSelector.substitute(key, then, interpreter);
        }
        interpreter.pushScope(scope);
      }
      return selected;
    }
    andThen(then) {
      return new GetSelector(this.item, this.then.andThen(then));
    }
    get typeOrder() {
      return 12;
    }
    compareTo(that) {
      if (that instanceof GetSelector) {
        let order = this.item.compareTo(that.item);
        if (order === 0) {
          order = this.then.compareTo(that.then);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof GetSelector) {
        return this.item.equals(that.item) && this.then.equivalentTo(that.then, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof GetSelector) {
        return this.item.equals(that.item) && this.then.equals(that.then);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(GetSelector), this.item.hashCode()), this.then.hashCode()));
    }
    debugThen(output) {
      output = output.write(46).write("get").write(40).debug(this.item).write(41);
      output = this.then.debugThen(output);
      return output;
    }
    clone() {
      return new GetSelector(this.item.clone(), this.then.clone());
    }
  }
  class GetAttrSelector extends Selector {
    constructor(key, then) {
      super();
      this.item = key;
      this.then = then;
    }
    forSelected(interpreter, callback, thisArg) {
      interpreter.willSelect(this);
      const key = this.item;
      const selected = GetAttrSelector.forSelected(key, this.then, interpreter, callback);
      interpreter.didSelect(this, selected);
      return selected;
    }
    static forSelected(key, then, interpreter, callback, thisArg) {
      let selected;
      if (interpreter.scopeDepth !== 0) {
        const scope = interpreter.popScope().toValue();
        let field;
        if (scope instanceof Record) {
          field = scope.getField(key);
          if (field instanceof Attr) {
            interpreter.pushScope(field.toValue());
            selected = then.forSelected(interpreter, callback, thisArg);
            interpreter.popScope();
          }
        }
        if (field === void 0 && selected === void 0) {
          GetAttrSelector.forSelected(key, then, interpreter, callback, thisArg);
        }
        interpreter.pushScope(scope);
      }
      return selected;
    }
    mapSelected(interpreter, transform, thisArg) {
      let result;
      interpreter.willTransform(this);
      const key = this.item;
      if (interpreter.scopeDepth !== 0) {
        const scope = interpreter.popScope().toValue();
        if (scope instanceof Record) {
          const oldField = scope.getField(key);
          if (oldField instanceof Attr) {
            interpreter.pushScope(oldField.toValue());
            const newItem = this.then.mapSelected(interpreter, transform, thisArg);
            interpreter.popScope();
            if (newItem instanceof Field) {
              if (key.equals(newItem.key)) {
                scope.setAttr(key, newItem.toValue());
              } else {
                scope.delete(key);
                scope.push(newItem);
              }
            } else if (newItem.isDefined()) {
              scope.setAttr(key, newItem.toValue());
            } else {
              scope.delete(key);
            }
          }
        }
        interpreter.pushScope(scope);
        result = scope;
      } else {
        result = Item.absent();
      }
      interpreter.didTransform(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const key = this.item;
      const value = GetAttrSelector.substitute(key, this.then, interpreter);
      if (value !== void 0) {
        return value;
      }
      let then = this.then.substitute(interpreter);
      if (!(then instanceof Selector)) {
        then = this.then;
      }
      return new GetAttrSelector(this.item, then);
    }
    static substitute(key, then, interpreter) {
      let selected;
      if (interpreter.scopeDepth !== 0) {
        const scope = interpreter.popScope().toValue();
        let field;
        if (scope instanceof Record) {
          field = scope.getField(key);
          if (field instanceof Attr) {
            selected = field.toValue().substitute(interpreter);
          }
        }
        if (field === void 0 && selected === void 0) {
          GetAttrSelector.substitute(key, then, interpreter);
        }
        interpreter.pushScope(scope);
      }
      return selected;
    }
    andThen(then) {
      return new GetAttrSelector(this.item, this.then.andThen(then));
    }
    get typeOrder() {
      return 13;
    }
    compareTo(that) {
      if (that instanceof GetAttrSelector) {
        let order = this.item.compareTo(that.item);
        if (order === 0) {
          order = this.then.compareTo(that.then);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof GetAttrSelector) {
        return this.item.equals(that.item) && this.then.equivalentTo(that.then, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof GetAttrSelector) {
        return this.item.equals(that.item) && this.then.equals(that.then);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(GetAttrSelector), this.item.hashCode()), this.then.hashCode()));
    }
    debugThen(output) {
      output = output.write(46).write("getAttr").write(40).debug(this.item).write(41);
      output = this.then.debugThen(output);
      return output;
    }
    clone() {
      return new GetAttrSelector(this.item.clone(), this.then.clone());
    }
  }
  class GetItemSelector extends Selector {
    constructor(index, then) {
      super();
      this.item = index;
      this.then = then;
    }
    forSelected(interpreter, callback, thisArg) {
      let selected;
      interpreter.willSelect(this);
      const index = this.item.numberValue();
      if (interpreter.scopeDepth !== 0) {
        const scope = interpreter.popScope().toValue();
        if (scope instanceof Record && index < scope.length) {
          const item = scope.getItem(index);
          interpreter.pushScope(item);
          selected = this.then.forSelected(interpreter, callback, thisArg);
          interpreter.popScope();
        }
        interpreter.pushScope(scope);
      }
      interpreter.didSelect(this, selected);
      return selected;
    }
    mapSelected(interpreter, transform, thisArg) {
      let result;
      interpreter.willTransform(this);
      if (interpreter.scopeDepth !== 0) {
        const scope = interpreter.popScope().toValue();
        const index = this.item.numberValue();
        if (scope instanceof Record && index < scope.length) {
          const oldItem = scope.getItem(index);
          interpreter.pushScope(oldItem);
          const newItem = this.then.mapSelected(interpreter, transform, thisArg);
          interpreter.popScope();
          if (newItem.isDefined()) {
            scope.setItem(index, newItem);
          } else {
            scope.splice(index, 1);
          }
        }
        interpreter.pushScope(scope);
        result = scope;
      } else {
        result = Item.absent();
      }
      interpreter.didTransform(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const index = this.item.numberValue();
      if (interpreter.scopeDepth !== 0) {
        const scope = interpreter.popScope().toValue();
        let selected;
        if (scope instanceof Record && index < scope.length) {
          const item = scope.getItem(index);
          selected = item.substitute(interpreter);
        }
        interpreter.pushScope(scope);
        if (selected !== void 0) {
          return selected;
        }
      }
      let then = this.then.substitute(interpreter);
      if (!(then instanceof Selector)) {
        then = this.then;
      }
      return new GetItemSelector(this.item, then);
    }
    andThen(then) {
      return new GetItemSelector(this.item, this.then.andThen(then));
    }
    get typeOrder() {
      return 14;
    }
    compareTo(that) {
      if (that instanceof GetItemSelector) {
        let order = this.item.compareTo(that.item);
        if (order === 0) {
          order = this.then.compareTo(that.then);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof GetItemSelector) {
        return this.item.equals(that.item) && this.then.equivalentTo(that.then, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof GetItemSelector) {
        return this.item.equals(that.item) && this.then.equals(that.then);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(GetItemSelector), this.item.hashCode()), this.then.hashCode()));
    }
    debugThen(output) {
      output = output.write(46).write("getItem").write(40).debug(this.item).write(41);
      output = this.then.debugThen(output);
      return output;
    }
    clone() {
      return new GetItemSelector(this.item, this.then.clone());
    }
  }
  class KeysSelector extends Selector {
    constructor(then) {
      super();
      this.then = then;
    }
    forSelected(interpreter, callback, thisArg) {
      let selected;
      interpreter.willSelect(this);
      if (interpreter.scopeDepth !== 0) {
        const scope = interpreter.popScope();
        if (scope instanceof Record) {
          const children = scope.iterator();
          while (selected === void 0 && children.hasNext()) {
            const child = children.next().value;
            if (child instanceof Field) {
              interpreter.pushScope(child.key);
              selected = this.then.forSelected(interpreter, callback, thisArg);
              interpreter.popScope();
            }
          }
        } else if (scope instanceof Field) {
          interpreter.pushScope(scope.key);
          selected = this.then.forSelected(interpreter, callback, thisArg);
          interpreter.popScope();
        }
        interpreter.pushScope(scope);
      }
      interpreter.didSelect(this, selected);
      return selected;
    }
    mapSelected(interpreter, transform, thisArg) {
      let result;
      interpreter.willTransform(this);
      if (interpreter.scopeDepth !== 0) {
        let scope = interpreter.popScope();
        if (scope instanceof Record) {
          const children = scope.iterator();
          while (children.hasNext()) {
            const child = children.next().value;
            if (child instanceof Field) {
              const oldKey = child.key;
              interpreter.pushScope(oldKey);
              const newKey = this.then.mapSelected(interpreter, transform, thisArg).toValue();
              interpreter.popScope();
              if (newKey.isDefined()) {
                if (oldKey !== newKey) {
                  if (scope instanceof Attr && newKey instanceof Text) {
                    children.set(Attr.of(newKey, scope.toValue()));
                  } else {
                    children.set(Slot.of(newKey, scope.toValue()));
                  }
                }
              } else {
                children.delete();
              }
            }
          }
        } else if (scope instanceof Field) {
          const oldKey = scope.key;
          interpreter.pushScope(oldKey);
          const newKey = this.then.mapSelected(interpreter, transform, thisArg).toValue();
          interpreter.popScope();
          if (newKey.isDefined()) {
            if (oldKey !== newKey) {
              if (scope instanceof Attr && newKey instanceof Text) {
                scope = Attr.of(newKey, scope.toValue());
              } else {
                scope = Slot.of(newKey, scope.toValue());
              }
            }
          } else {
            scope = Item.absent();
          }
        }
        interpreter.pushScope(scope);
        result = scope;
      } else {
        result = Item.absent();
      }
      interpreter.didTransform(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      let then = this.then.substitute(interpreter);
      if (!(then instanceof Selector)) {
        then = this.then;
      }
      return new KeysSelector(then);
    }
    andThen(then) {
      return new KeysSelector(this.then.andThen(then));
    }
    get typeOrder() {
      return 15;
    }
    compareTo(that) {
      if (that instanceof KeysSelector) {
        return this.then.compareTo(that.then);
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof KeysSelector) {
        return this.then.equivalentTo(that.then, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof KeysSelector) {
        return this.then.equals(that.then);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(KeysSelector), this.then.hashCode()));
    }
    debugThen(output) {
      output = output.write(46).write("keys").write(40).write(41);
      output = this.then.debugThen(output);
      return output;
    }
    clone() {
      return new KeysSelector(this.then.clone());
    }
  }
  class ValuesSelector extends Selector {
    constructor(then) {
      super();
      this.then = then;
    }
    forSelected(interpreter, callback, thisArg) {
      let selected;
      interpreter.willSelect(this);
      if (interpreter.scopeDepth !== 0) {
        const scope = interpreter.popScope();
        if (scope instanceof Record) {
          const children = scope.iterator();
          while (selected === void 0 && children.hasNext()) {
            const child = children.next().value;
            interpreter.pushScope(child.toValue());
            selected = this.then.forSelected(interpreter, callback, thisArg);
            interpreter.popScope();
          }
        } else {
          interpreter.pushScope(scope.toValue());
          selected = this.then.forSelected(interpreter, callback, thisArg);
          interpreter.popScope();
        }
        interpreter.pushScope(scope);
      }
      interpreter.didSelect(this, selected);
      return selected;
    }
    mapSelected(interpreter, transform, thisArg) {
      let result;
      interpreter.willTransform(this);
      if (interpreter.scopeDepth !== 0) {
        let scope = interpreter.popScope();
        if (scope instanceof Record) {
          const children = scope.iterator();
          while (children.hasNext()) {
            const child = children.next().value;
            if (child instanceof Field) {
              const oldValue = child.toValue();
              interpreter.pushScope(oldValue);
              const newItem = this.then.mapSelected(interpreter, transform, thisArg);
              interpreter.popScope();
              if (newItem.isDefined()) {
                if (newItem instanceof Field) {
                  children.set(newItem);
                } else if (newItem !== oldValue) {
                  children.set(child.updatedValue(newItem.toValue()));
                }
              } else {
                children.delete();
              }
            } else {
              interpreter.pushScope(child.toValue());
              const newItem = this.then.mapSelected(interpreter, transform, thisArg);
              interpreter.popScope();
              if (newItem.isDefined()) {
                if (child !== newItem) {
                  children.set(newItem);
                }
              } else {
                children.delete();
              }
            }
          }
        } else if (scope instanceof Field) {
          const oldValue = scope.toValue();
          interpreter.pushScope(oldValue);
          const newItem = this.then.mapSelected(interpreter, transform, thisArg);
          interpreter.popScope();
          if (newItem.isDefined()) {
            if (newItem instanceof Field) {
              scope = newItem;
            } else if (newItem !== oldValue) {
              scope = scope.updatedValue(newItem.toValue());
            }
          } else {
            scope = Item.absent();
          }
        } else {
          interpreter.pushScope(scope);
          scope = this.then.mapSelected(interpreter, transform, thisArg);
          interpreter.popScope();
        }
        interpreter.pushScope(scope);
        result = scope;
      } else {
        result = Item.absent();
      }
      interpreter.didTransform(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      let then = this.then.substitute(interpreter);
      if (!(then instanceof Selector)) {
        then = this.then;
      }
      return new ValuesSelector(then);
    }
    andThen(then) {
      return new ValuesSelector(this.then.andThen(then));
    }
    get typeOrder() {
      return 16;
    }
    compareTo(that) {
      if (that instanceof ValuesSelector) {
        return this.then.compareTo(that.then);
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof ValuesSelector) {
        return this.then.equivalentTo(that.then, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof ValuesSelector) {
        return this.then.equals(that.then);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(ValuesSelector), this.then.hashCode()));
    }
    debugThen(output) {
      output = output.write(46).write("values").write(40).write(41);
      output = this.then.debugThen(output);
      return output;
    }
    clone() {
      return new ValuesSelector(this.then.clone());
    }
  }
  class ChildrenSelector extends Selector {
    constructor(then) {
      super();
      this.then = then;
    }
    forSelected(interpreter, callback, thisArg) {
      let selected;
      interpreter.willSelect(this);
      if (interpreter.scopeDepth !== 0) {
        const scope = interpreter.popScope().toValue();
        if (scope instanceof Record) {
          const children = scope.iterator();
          while (selected === void 0 && children.hasNext()) {
            const child = children.next().value;
            interpreter.pushScope(child);
            selected = this.then.forSelected(interpreter, callback, thisArg);
            interpreter.popScope();
          }
        }
        interpreter.pushScope(scope);
      }
      interpreter.didSelect(this, selected);
      return selected;
    }
    mapSelected(interpreter, transform, thisArg) {
      let result;
      interpreter.willTransform(this);
      if (interpreter.scopeDepth !== 0) {
        const scope = interpreter.popScope().toValue();
        if (scope instanceof Record) {
          const children = scope.iterator();
          while (children.hasNext()) {
            const oldChild = children.next().value;
            interpreter.pushScope(oldChild);
            const newChild = this.then.mapSelected(interpreter, transform);
            interpreter.popScope();
            if (newChild.isDefined()) {
              if (newChild !== oldChild) {
                children.set(newChild);
              }
            } else {
              children.delete();
            }
          }
        }
        interpreter.pushScope(scope);
        result = scope;
      } else {
        result = Item.absent();
      }
      interpreter.didTransform(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      let then = this.then.substitute(interpreter);
      if (!(then instanceof Selector)) {
        then = this.then;
      }
      return new ChildrenSelector(then);
    }
    andThen(then) {
      return new ChildrenSelector(this.then.andThen(then));
    }
    get typeOrder() {
      return 17;
    }
    compareTo(that) {
      if (that instanceof ChildrenSelector) {
        return this.then.compareTo(that.then);
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof ChildrenSelector) {
        return this.then.equivalentTo(that.then, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof ChildrenSelector) {
        return this.then.equals(that.then);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(ChildrenSelector), this.then.hashCode()));
    }
    debugThen(output) {
      output = output.write(46).write("children").write(40).write(41);
      output = this.then.debugThen(output);
      return output;
    }
    clone() {
      return new ChildrenSelector(this.then.clone());
    }
  }
  class DescendantsSelector extends Selector {
    constructor(then) {
      super();
      this.then = then;
    }
    forSelected(interpreter, callback, thisArg) {
      let selected;
      interpreter.willSelect(this);
      if (interpreter.scopeDepth !== 0) {
        const scope = interpreter.popScope().toValue();
        if (scope instanceof Record) {
          const children = scope.iterator();
          while (selected === void 0 && children.hasNext()) {
            const child = children.next().value;
            interpreter.pushScope(child);
            selected = this.then.forSelected(interpreter, callback, thisArg);
            if (selected === void 0) {
              this.forSelected(interpreter, callback, thisArg);
            }
            interpreter.popScope();
          }
        }
        interpreter.pushScope(scope);
      }
      interpreter.didSelect(this, selected);
      return selected;
    }
    mapSelected(interpreter, transform, thisArg) {
      let result;
      interpreter.willTransform(this);
      if (interpreter.scopeDepth !== 0) {
        const scope = interpreter.popScope().toValue();
        if (scope instanceof Record) {
          const children = scope.iterator();
          while (children.hasNext()) {
            const oldChild = children.next().value;
            interpreter.pushScope(oldChild);
            let newChild = this.then.mapSelected(interpreter, transform, thisArg);
            if (newChild.isDefined()) {
              newChild = this.mapSelected(interpreter, transform, thisArg);
            }
            interpreter.popScope();
            if (newChild.isDefined()) {
              if (newChild !== oldChild) {
                children.set(newChild);
              }
            } else {
              children.delete();
            }
          }
        }
        interpreter.pushScope(scope);
        result = scope;
      } else {
        result = Item.absent();
      }
      interpreter.didTransform(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      let then = this.then.substitute(interpreter);
      if (!(then instanceof Selector)) {
        then = this.then;
      }
      return new DescendantsSelector(then);
    }
    andThen(then) {
      return new DescendantsSelector(this.then.andThen(then));
    }
    get typeOrder() {
      return 18;
    }
    compareTo(that) {
      if (that instanceof DescendantsSelector) {
        return this.then.compareTo(that.then);
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof DescendantsSelector) {
        return this.then.equivalentTo(that.then, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof DescendantsSelector) {
        return this.then.equals(that.then);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(DescendantsSelector), this.then.hashCode()));
    }
    debugThen(output) {
      output = output.write(46).write("descendants").write(40).write(41);
      output = this.then.debugThen(output);
      return output;
    }
    clone() {
      return new DescendantsSelector(this.then.clone());
    }
  }
  class FilterSelector extends Selector {
    constructor(predicate, then) {
      super();
      this.predicate = predicate;
      this.then = then;
    }
    forSelected(interpreter, callback, thisArg) {
      let selected;
      interpreter.willSelect(this);
      if (interpreter.scopeDepth !== 0) {
        if (this.filterSelected(interpreter)) {
          selected = this.then.forSelected(interpreter, callback, thisArg);
        }
      }
      interpreter.didSelect(this, selected);
      return selected;
    }
    mapSelected(interpreter, transform, thisArg) {
      let result;
      interpreter.willTransform(this);
      if (interpreter.scopeDepth !== 0) {
        if (this.filterSelected(interpreter)) {
          result = this.then.mapSelected(interpreter, transform, thisArg);
        } else {
          result = interpreter.peekScope().toValue();
        }
      } else {
        result = Item.absent();
      }
      interpreter.didTransform(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      let predicate = this.predicate.substitute(interpreter);
      if (!(predicate instanceof Selector)) {
        predicate = this.predicate;
      }
      let then = this.then.substitute(interpreter);
      if (!(then instanceof Selector)) {
        then = this.then;
      }
      return new FilterSelector(predicate, then);
    }
    filterSelected(interpreter) {
      return this.predicate.forSelected(interpreter, this.selected, this) !== void 0;
    }
    selected(interpreter) {
      return null;
    }
    andThen(then) {
      return new FilterSelector(this.predicate, this.then.andThen(then));
    }
    filter(predicate) {
      if (arguments.length === 0) {
        return this;
      } else {
        predicate = Item.fromAny(predicate);
        return this.andThen(predicate.filter());
      }
    }
    get typeOrder() {
      return 19;
    }
    compareTo(that) {
      if (that instanceof FilterSelector) {
        let order = this.predicate.compareTo(that.predicate);
        if (order === 0) {
          order = this.then.compareTo(that.then);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof FilterSelector) {
        return this.predicate.equivalentTo(that.predicate, epsilon) && this.then.equivalentTo(that.then, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof FilterSelector) {
        return this.predicate.equals(that.predicate) && this.then.equals(that.then);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(FilterSelector), this.predicate.hashCode()), this.then.hashCode()));
    }
    debugThen(output) {
      output = output.write(46).write("filter").write(40).debug(this.predicate).write(41);
      output = this.then.debugThen(output);
      return output;
    }
    clone() {
      return new FilterSelector(this.predicate.clone(), this.then.clone());
    }
  }
  class LiteralSelector extends Selector {
    constructor(item, then) {
      super();
      this.item = item.commit();
      this.then = then;
    }
    forSelected(interpreter, callback, thisArg) {
      let selected;
      interpreter.willSelect(this);
      if (interpreter.scopeDepth !== 0) {
        const literal = this.item.evaluate(interpreter);
        if (literal.isDefined()) {
          interpreter.pushScope(literal);
          selected = this.then.forSelected(interpreter, callback, thisArg);
          interpreter.popScope();
        }
      }
      interpreter.didSelect(this, selected);
      return selected;
    }
    mapSelected(interpreter, transform, thisArg) {
      let result;
      interpreter.willTransform(this);
      if (interpreter.scopeDepth !== 0) {
        let literal = this.item.evaluate(interpreter);
        if (literal.isDefined()) {
          interpreter.pushScope(literal);
          literal = this.then.mapSelected(interpreter, transform, thisArg);
          interpreter.popScope();
        }
        result = literal;
      } else {
        result = Item.absent();
      }
      interpreter.didTransform(this, result);
      return result;
    }
    substitute(interpreter) {
      interpreter = Interpreter.fromAny(interpreter);
      const item = this.item.substitute(interpreter);
      let then = this.then.substitute(interpreter);
      if (!(then instanceof Selector)) {
        then = this.then;
      }
      return new LiteralSelector(item, then);
    }
    andThen(then) {
      return new LiteralSelector(this.item, this.then.andThen(then));
    }
    get precedence() {
      return this.item.precedence;
    }
    get typeOrder() {
      return 11;
    }
    compareTo(that) {
      if (that instanceof LiteralSelector) {
        let order = this.item.compareTo(that.item);
        if (order === 0) {
          order = this.then.compareTo(that.then);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof LiteralSelector) {
        return this.item.equivalentTo(that.item, epsilon) && this.then.equivalentTo(that.then, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof LiteralSelector) {
        return this.item.equals(that.item) && this.then.equals(that.then);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(LiteralSelector), this.item.hashCode()), this.then.hashCode()));
    }
    debug(output) {
      output = output.write("Selector").write(46).write("literal").write(40).debug(this.item).write(41);
      output = this.then.debugThen(output);
      return output;
    }
    debugThen(output) {
      return output;
    }
    clone() {
      return new LiteralSelector(this.item.clone(), this.then.clone());
    }
  }
  class Func extends Expression {
    constructor() {
      super();
    }
    isConstant() {
      return false;
    }
    expand(args, interpreter, operator) {
      return void 0;
    }
  }
  class LambdaFunc extends Func {
    constructor(bindings, template) {
      super();
      this.bindings = bindings;
      this.template = template;
    }
    get precedence() {
      return 1;
    }
    invoke(args, interpreter, operator) {
      interpreter = Interpreter.fromAny(interpreter);
      const bindings = this.bindings;
      const arity = Math.max(1, bindings.length);
      const params = Record.create(arity);
      let i = 0;
      let j = 0;
      while (i < arity) {
        const binding = bindings instanceof Record ? bindings.getItem(i) : i === 0 ? bindings : Item.absent();
        const arg = args instanceof Record ? args.getItem(j).toValue() : j === 0 ? args : Value.absent();
        if (binding instanceof Text && arg.isDistinct()) {
          params.push(Slot.of(binding, arg));
          j += 1;
        } else if (binding instanceof Slot) {
          if (arg.isDistinct()) {
            params.push(binding.updatedValue(arg));
          } else {
            params.push(binding);
          }
          j += 1;
        }
        i += 1;
      }
      interpreter.pushScope(params);
      const result = this.template.evaluate(interpreter);
      interpreter.popScope();
      return result;
    }
    get typeOrder() {
      return 50;
    }
    compareTo(that) {
      if (that instanceof LambdaFunc) {
        let order = this.bindings.compareTo(that.bindings);
        if (order === 0) {
          order = this.template.compareTo(that.template);
        }
        return order;
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof LambdaFunc) {
        return this.bindings.equivalentTo(that.bindings, epsilon) && this.template.equivalentTo(that.template, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof LambdaFunc) {
        return this.bindings.equals(that.bindings) && this.template.equals(that.template);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(LambdaFunc), this.bindings.hashCode()), this.template.hashCode()));
    }
    debug(output) {
      output = output.debug(this.bindings).write(46).write("lambda").write(40).debug(this.template).write(41);
      return output;
    }
  }
  class BridgeFunc extends Func {
    get typeOrder() {
      return 51;
    }
    compareTo(that) {
      if (that instanceof BridgeFunc) {
        return Constructors.compare(this.constructor, that.constructor);
      } else if (that instanceof Item) {
        return Numbers.compare(this.typeOrder, that.typeOrder);
      }
      return NaN;
    }
    equivalentTo(that) {
      return this === that;
    }
    equals(that) {
      return this === that;
    }
    hashCode() {
      return Constructors.hash(this.constructor);
    }
    debug(output) {
      output = output.write(this.constructor.name);
      return output;
    }
  }
  const MathModule = function() {
    const MathModule = {};
    Object.defineProperty(MathModule, "max", {
      get() {
        const func = new MaxFunc;
        Object.defineProperty(MathModule, "max", {
          value: func,
          enumerable: true,
          configurable: true
        });
        return func;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MathModule, "min", {
      get() {
        const func = new MinFunc;
        Object.defineProperty(MathModule, "min", {
          value: func,
          enumerable: true,
          configurable: true
        });
        return func;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MathModule, "abs", {
      get() {
        const func = new AbsFunc;
        Object.defineProperty(MathModule, "abs", {
          value: func,
          enumerable: true,
          configurable: true
        });
        return func;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MathModule, "ceil", {
      get() {
        const func = new CeilFunc;
        Object.defineProperty(MathModule, "ceil", {
          value: func,
          enumerable: true,
          configurable: true
        });
        return func;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MathModule, "floor", {
      get() {
        const func = new FloorFunc;
        Object.defineProperty(MathModule, "floor", {
          value: func,
          enumerable: true,
          configurable: true
        });
        return func;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MathModule, "round", {
      get() {
        const func = new RoundFunc;
        Object.defineProperty(MathModule, "round", {
          value: func,
          enumerable: true,
          configurable: true
        });
        return func;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MathModule, "sqrt", {
      get() {
        const func = new SqrtFunc;
        Object.defineProperty(MathModule, "sqrt", {
          value: func,
          enumerable: true,
          configurable: true
        });
        return func;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MathModule, "pow", {
      get() {
        const func = new PowFunc;
        Object.defineProperty(MathModule, "pow", {
          value: func,
          enumerable: true,
          configurable: true
        });
        return func;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MathModule, "rate", {
      get() {
        const func = new RateFunc;
        Object.defineProperty(MathModule, "rate", {
          value: func,
          enumerable: true,
          configurable: true
        });
        return func;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MathModule, "random", {
      get() {
        const func = new RandomFunc;
        Object.defineProperty(MathModule, "random", {
          value: func,
          enumerable: true,
          configurable: true
        });
        return func;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MathModule, "scope", {
      get() {
        const scope = Record.create(10).slot("max", MathModule.max).slot("min", MathModule.min).slot("abs", MathModule.abs).slot("ceil", MathModule.ceil).slot("floor", MathModule.floor).slot("round", MathModule.round).slot("pow", MathModule.pow).slot("sqrt", MathModule.sqrt).slot("rate", MathModule.rate).slot("random", MathModule.random).commit();
        Object.defineProperty(MathModule, "scope", {
          value: scope,
          configurable: true,
          enumerable: true
        });
        return scope;
      },
      enumerable: true,
      configurable: true
    });
    class MaxFunc extends BridgeFunc {
      invoke(args, interpreter, operator) {
        interpreter = Interpreter.fromAny(interpreter);
        let x;
        let y;
        if (args.length >= 2) {
          x = args.getItem(0).evaluate(interpreter);
          y = args.getItem(1).evaluate(interpreter);
        } else {
          x = args.evaluate(interpreter);
        }
        if (y !== void 0) {
          return x.max(y);
        } else if (operator !== void 0) {
          y = operator.state;
          const max = y !== void 0 ? x.max(y) : x;
          operator.setState(max);
          return max;
        }
        return Item.absent();
      }
      expand(args, interpreter, operator) {
        if (args.length === 1) {
          args = args.evaluate(interpreter).toValue();
          return this.invoke(args, interpreter, operator);
        }
        return void 0;
      }
    }
    class MinFunc extends BridgeFunc {
      invoke(args, interpreter, operator) {
        interpreter = Interpreter.fromAny(interpreter);
        let x;
        let y;
        if (args.length >= 2) {
          x = args.getItem(0).evaluate(interpreter);
          y = args.getItem(1).evaluate(interpreter);
        } else {
          x = args.evaluate(interpreter);
        }
        if (y !== void 0) {
          return x.min(y);
        } else if (operator !== void 0) {
          y = operator.state;
          const min = y !== void 0 ? x.min(y) : x;
          operator.setState(min);
          return min;
        }
        return Item.absent();
      }
      expand(args, interpreter, operator) {
        if (args.length === 1) {
          args = args.evaluate(interpreter).toValue();
          return this.invoke(args, interpreter, operator);
        }
        return void 0;
      }
    }
    class AbsFunc extends BridgeFunc {
      invoke(args, interpreter, operator) {
        args = args.evaluate(interpreter).toValue();
        if (args instanceof Num) {
          return args.abs();
        }
        return Item.absent();
      }
    }
    class CeilFunc extends BridgeFunc {
      invoke(args, interpreter, operator) {
        args = args.evaluate(interpreter).toValue();
        if (args instanceof Num) {
          return args.ceil();
        }
        return Item.absent();
      }
    }
    class FloorFunc extends BridgeFunc {
      invoke(args, interpreter, operator) {
        args = args.evaluate(interpreter).toValue();
        if (args instanceof Num) {
          return args.floor();
        }
        return Item.absent();
      }
    }
    class RoundFunc extends BridgeFunc {
      invoke(args, interpreter, operator) {
        args = args.evaluate(interpreter).toValue();
        if (args instanceof Num) {
          return args.round();
        }
        return Item.absent();
      }
    }
    class SqrtFunc extends BridgeFunc {
      invoke(args, interpreter, operator) {
        args = args.evaluate(interpreter).toValue();
        if (args instanceof Num) {
          return args.sqrt();
        }
        return Item.absent();
      }
    }
    class PowFunc extends BridgeFunc {
      invoke(args, interpreter, operator) {
        interpreter = Interpreter.fromAny(interpreter);
        const x = args.getItem(0).evaluate(interpreter);
        const y = args.getItem(1).evaluate(interpreter);
        if (x instanceof Num && y instanceof Num) {
          return x.pow(y);
        }
        return Item.absent();
      }
    }
    class RateFunc extends BridgeFunc {
      invoke(args, interpreter, operator) {
        interpreter = Interpreter.fromAny(interpreter);
        let value;
        let period;
        if (args.length >= 2) {
          value = args.getItem(0).evaluate(interpreter).numberValue(NaN);
          period = args.getItem(1).evaluate(interpreter).numberValue(1e3);
        } else {
          value = args.evaluate(interpreter).numberValue(NaN);
          period = 1e3;
        }
        if (isFinite(value) && operator !== void 0) {
          let state = operator.state;
          if (state === void 0) {
            state = {
              v0: value,
              t0: Date.now(),
              dv: 0,
              dt: 0
            };
            operator.setState(state);
          } else {
            const t1 = Date.now();
            const dt = t1 - state.t0;
            if (dt > period && t1 > state.t0 || dt > 2 * period) {
              const dv = value - state.v0;
              state.v0 = value;
              state.t0 = t1;
              state.dv = dv;
              state.dt = dt;
            }
            operator.setState(state);
            if (state.dt !== 0) {
              const rate = period * state.dv / state.dt;
              return Num.from(rate);
            }
          }
        }
        return Item.absent();
      }
      expand(args, interpreter, operator) {
        args = args.evaluate(interpreter).toValue();
        return this.invoke(args, interpreter, operator);
      }
    }
    class RandomFunc extends BridgeFunc {
      invoke(args, interpreter, operator) {
        args = args.evaluate(interpreter).toValue();
        const lower = args.length >= 1 ? args.getItem(0).numberValue(0) : 0;
        const upper = args.length >= 2 ? args.getItem(1).numberValue(lower + 1) : lower + 1;
        const value = lower + Math.random() * (upper - lower);
        return Num.from(value);
      }
    }
    return MathModule;
  }();
  class FormException extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, FormException.prototype);
    }
  }
  class Form {
    withTag(tag) {
      if (tag !== void 0 && tag !== this.tag) {
        return new TagForm(this, tag);
      } else {
        return this;
      }
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new UnitForm(this, unit);
      } else {
        return this;
      }
    }
    static forString() {
      return new StringForm("");
    }
    static forNumber() {
      return new NumberForm(0);
    }
    static forBoolean() {
      return new BooleanForm(false);
    }
    static forAny() {
      return new AnyForm(void 0);
    }
    static forItem() {
      return new ItemForm(Item.absent());
    }
    static forValue() {
      return new ValueForm(Value.absent());
    }
  }
  __decorate([ Lazy ], Form, "forString", null);
  __decorate([ Lazy ], Form, "forNumber", null);
  __decorate([ Lazy ], Form, "forBoolean", null);
  __decorate([ Lazy ], Form, "forAny", null);
  __decorate([ Lazy ], Form, "forItem", null);
  __decorate([ Lazy ], Form, "forValue", null);
  Object.defineProperty(Form.prototype, "tag", {
    get() {
      return void 0;
    },
    configurable: true
  });
  Object.defineProperty(Form.prototype, "unit", {
    get() {
      return void 0;
    },
    configurable: true
  });
  class TagForm extends Form {
    constructor(form, tag) {
      super();
      this.form = form;
      this.tag = tag;
    }
    withTag(tag) {
      if (tag !== void 0 && tag !== this.tag) {
        return new TagForm(this.form, tag);
      } else if (tag === void 0) {
        return this.form;
      } else {
        return this;
      }
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new TagForm(this.form.withUnit(unit), this.tag);
      } else {
        return this;
      }
    }
    mold(object, item) {
      item = this.form.mold(object, item);
      if (!item.header(this.tag).isDefined()) {
        item = item.prepended(Attr.of(this.tag));
      }
      return item;
    }
    cast(item, object) {
      if (item.header(this.tag).isDefined()) {
        return this.form.cast(item, object);
      } else if (item.keyEquals(this.tag)) {
        return this.form.cast(item.toValue(), object);
      }
      return void 0;
    }
  }
  Object.defineProperty(TagForm.prototype, "unit", {
    get() {
      return this.form.unit;
    },
    configurable: true
  });
  class UnitForm extends Form {
    constructor(form, unit) {
      super();
      this.form = form;
      Object.defineProperty(this, "unit", {
        value: unit,
        enumerable: true
      });
    }
    withTag(tag) {
      if (tag !== this.tag) {
        return new UnitForm(this.form.withTag(tag), this.unit);
      } else {
        return this;
      }
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new UnitForm(this.form, unit);
      } else if (unit === this.form.unit) {
        return this.form;
      } else {
        return this;
      }
    }
    mold(object, item) {
      if (arguments.length === 1) {
        return this.form.mold(object);
      } else {
        return this.form.mold(object, item);
      }
    }
    cast(item, object) {
      if (arguments.length === 1) {
        return this.form.cast(item);
      } else {
        return this.form.cast(item, object);
      }
    }
  }
  Object.defineProperty(UnitForm.prototype, "tag", {
    get() {
      return this.form.tag;
    },
    configurable: true
  });
  class StringForm extends Form {
    constructor(unit) {
      super();
      Object.defineProperty(this, "unit", {
        value: unit,
        enumerable: true
      });
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new StringForm(unit);
      } else {
        return this;
      }
    }
    mold(object, item) {
      if (item === void 0) {
        return Text.from(object);
      } else {
        return item.concat(Text.from(object));
      }
    }
    cast(item, object) {
      const value = item.target;
      try {
        return value.stringValue();
      } catch (error) {
        return void 0;
      }
    }
  }
  class NumberForm extends Form {
    constructor(unit) {
      super();
      Object.defineProperty(this, "unit", {
        value: unit,
        enumerable: true
      });
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new NumberForm(unit);
      } else {
        return this;
      }
    }
    mold(object, item) {
      if (item === void 0) {
        return Num.from(object);
      } else {
        return item.concat(Num.from(object));
      }
    }
    cast(item, object) {
      const value = item.target;
      try {
        return value.numberValue();
      } catch (error) {
        return void 0;
      }
    }
  }
  class BooleanForm extends Form {
    constructor(unit) {
      super();
      Object.defineProperty(this, "unit", {
        value: unit,
        enumerable: true
      });
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new BooleanForm(unit);
      } else {
        return this;
      }
    }
    mold(object, item) {
      if (item === void 0) {
        return Bool.from(object);
      } else {
        return item.concat(Bool.from(object));
      }
    }
    cast(item, object) {
      const value = item.target;
      try {
        return value.booleanValue();
      } catch (error) {
        return void 0;
      }
    }
  }
  class AnyForm extends Form {
    constructor(unit) {
      super();
      Object.defineProperty(this, "unit", {
        value: unit,
        enumerable: true
      });
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new AnyForm(unit);
      } else {
        return this;
      }
    }
    mold(object, item) {
      object = Item.fromAny(object);
      if (item !== void 0) {
        object = item.concat(object);
      }
      return object;
    }
    cast(item, object) {
      return item.toAny();
    }
  }
  class ItemForm extends Form {
    constructor(unit) {
      super();
      Object.defineProperty(this, "unit", {
        value: unit !== void 0 ? unit.commit() : void 0,
        enumerable: true
      });
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new ItemForm(unit);
      } else {
        return this;
      }
    }
    mold(object, item) {
      object = Item.fromAny(object);
      if (item !== void 0) {
        object = item.concat(object);
      }
      return object;
    }
    cast(item, object) {
      return item;
    }
  }
  class ValueForm extends Form {
    constructor(unit) {
      super();
      Object.defineProperty(this, "unit", {
        value: unit !== void 0 ? unit.commit() : void 0,
        enumerable: true
      });
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new ValueForm(unit);
      } else {
        return this;
      }
    }
    mold(object, item) {
      object = Value.fromAny(object);
      if (item !== void 0) {
        object = item.concat(object);
      }
      return object;
    }
    cast(item, object) {
      return item.toValue();
    }
  }
  class ValueCursor extends Cursor {
    constructor(cursor, form) {
      super();
      this.cursor = cursor;
      this.form = form;
    }
    isEmpty() {
      return this.cursor.isEmpty();
    }
    head() {
      const value = this.cursor.head();
      return value.coerce(this.form);
    }
    step() {
      this.cursor.step();
    }
    skip(count) {
      this.cursor.skip(count);
    }
    hasNext() {
      return this.cursor.hasNext();
    }
    nextIndex() {
      return this.cursor.nextIndex();
    }
    next() {
      const {value: value, done: done} = this.cursor.next();
      if (value !== void 0) {
        return {
          value: value.coerce(this.form),
          done: done
        };
      } else {
        return {
          done: done
        };
      }
    }
    hasPrevious() {
      return this.cursor.hasPrevious();
    }
    previousIndex() {
      return this.cursor.previousIndex();
    }
    previous() {
      const {value: value, done: done} = this.cursor.previous();
      if (value !== void 0) {
        return {
          value: value.coerce(this.form),
          done: done
        };
      } else {
        return {
          done: done
        };
      }
    }
    delete() {
      this.cursor.delete();
    }
  }
  class ValueEntryCursor extends Cursor {
    constructor(cursor, keyForm, valueForm) {
      super();
      this.cursor = cursor;
      this.keyForm = keyForm;
      this.valueForm = valueForm;
    }
    isEmpty() {
      return this.cursor.isEmpty();
    }
    head() {
      const pair = this.cursor.head();
      return [ pair[0].coerce(this.keyForm), pair[1].coerce(this.valueForm) ];
    }
    step() {
      this.cursor.step();
    }
    skip(count) {
      this.cursor.skip(count);
    }
    hasNext() {
      return this.cursor.hasNext();
    }
    nextIndex() {
      return this.cursor.nextIndex();
    }
    next() {
      const {value: value, done: done} = this.cursor.next();
      if (value !== void 0) {
        return {
          value: [ value[0].coerce(this.keyForm), value[1].coerce(this.valueForm) ],
          done: done
        };
      } else {
        return {
          done: done
        };
      }
    }
    hasPrevious() {
      return this.cursor.hasPrevious();
    }
    previousIndex() {
      return this.cursor.previousIndex();
    }
    previous() {
      const {value: value, done: done} = this.cursor.previous();
      if (value !== void 0) {
        return {
          value: [ value[0].coerce(this.keyForm), value[1].coerce(this.valueForm) ],
          done: done
        };
      } else {
        return {
          done: done
        };
      }
    }
    delete() {
      this.cursor.delete();
    }
  }
  const Inlet = function() {
    const Inlet = {};
    Inlet.is = function(object) {
      if (typeof object === "object" && object !== null || typeof object === "function") {
        const inlet = object;
        return "input" in inlet && typeof inlet.bindInput === "function" && typeof inlet.unbindInput === "function";
      }
      return false;
    };
    return Inlet;
  }();
  const Outlet = function() {
    const Outlet = {};
    Outlet.is = function(object) {
      if (typeof object === "object" && object !== null) {
        const outlet = object;
        return typeof outlet.outputIterator === "function" && typeof outlet.bindOutput === "function" && typeof outlet.unbindOutput === "function";
      }
      return false;
    };
    return Outlet;
  }();
  const OutletCombinators = function() {
    const OutletCombinators = {};
    OutletCombinators.define = function(prototype) {
      if (!Object.prototype.hasOwnProperty.call(prototype, "memoize")) {
        prototype.memoize = OutletCombinators.memoize;
      }
      if (!Object.prototype.hasOwnProperty.call(prototype, "map")) {
        prototype.map = OutletCombinators.map;
      }
      if (!Object.prototype.hasOwnProperty.call(prototype, "watch")) {
        prototype.watch = OutletCombinators.watch;
      }
    };
    OutletCombinators.memoize = function() {
      const combinator = new MemoizeValueCombinator;
      combinator.bindInput(this);
      return combinator;
    };
    OutletCombinators.map = function(func) {
      const combinator = new MapValueCombinator(func);
      combinator.bindInput(this);
      return combinator;
    };
    OutletCombinators.watch = function(func) {
      const combinator = new WatchValueCombinator(func);
      combinator.bindInput(this);
      return this;
    };
    return OutletCombinators;
  }();
  exports.KeyEffect = void 0;
  (function(KeyEffect) {
    KeyEffect[KeyEffect["Update"] = 0] = "Update";
    KeyEffect[KeyEffect["Remove"] = 1] = "Remove";
  })(exports.KeyEffect || (exports.KeyEffect = {}));
  const MapInlet = function() {
    const MapInlet = {};
    MapInlet.is = function(object) {
      if (typeof object === "object" && object !== null) {
        const inlet = object;
        return Inlet.is(inlet) && typeof inlet.decohereOutputKey === "function" && typeof inlet.recohereOutputKey === "function";
      }
      return false;
    };
    return MapInlet;
  }();
  const MapOutlet = function() {
    const MapOutlet = {};
    MapOutlet.is = function(object) {
      if (typeof object === "object" && object !== null) {
        const outlet = object;
        return Outlet.is(outlet) && typeof outlet.keyIterator === "function" && typeof outlet.outlet === "function";
      }
      return false;
    };
    return MapOutlet;
  }();
  const MapOutletCombinators = function() {
    const MapOutletCombinators = {};
    MapOutletCombinators.define = function(prototype) {
      if (!Object.prototype.hasOwnProperty.call(prototype, "memoize")) {
        prototype.memoize = MapOutletCombinators.memoize;
      }
      if (!Object.prototype.hasOwnProperty.call(prototype, "filterr")) {
        prototype.filter = MapOutletCombinators.filter;
      }
      if (!Object.prototype.hasOwnProperty.call(prototype, "map")) {
        prototype.map = MapOutletCombinators.map;
      }
      if (!Object.prototype.hasOwnProperty.call(prototype, "reduce")) {
        prototype.reduce = MapOutletCombinators.reduce;
      }
      if (!Object.prototype.hasOwnProperty.call(prototype, "watch")) {
        prototype.watch = MapOutletCombinators.watch;
      }
    };
    MapOutletCombinators.memoize = function() {
      const combinator = new MemoizeMapCombinator;
      combinator.bindInput(this);
      return combinator;
    };
    MapOutletCombinators.filter = function(func) {
      const combinator = new FilterFieldsCombinator(func);
      combinator.bindInput(this);
      return combinator;
    };
    MapOutletCombinators.map = function(func) {
      if (func.length === 1) {
        const combinator = new MapValueCombinator(func);
        combinator.bindInput(this);
        return combinator;
      } else {
        const combinator = new MapFieldValuesCombinator(func);
        combinator.bindInput(this);
        return combinator;
      }
    };
    MapOutletCombinators.reduce = function(identity, accumulator, combiner) {
      const combinator = new ReduceFieldsCombinator(identity, accumulator, combiner);
      combinator.bindInput(this);
      return combinator;
    };
    MapOutletCombinators.watch = function(func) {
      if (func.length === 1) {
        const combinator = new WatchValueCombinator(func);
        combinator.bindInput(this);
        return this;
      } else {
        const combinator = new WatchFieldsCombinator(func);
        combinator.bindInput(this);
        return this;
      }
    };
    return MapOutletCombinators;
  }();
  class StreamletException extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, StreamletException.prototype);
    }
  }
  const StreamletScope = function() {
    const StreamletScope = {};
    StreamletScope.is = function(object) {
      if (typeof object === "object" && object !== null || typeof object === "function") {
        const scope = object;
        return "streamletScope" in scope && "streamletContext" in scope && typeof scope.outlet === "function";
      }
      return false;
    };
    return StreamletScope;
  }();
  const Streamlet = function() {
    const Streamlet = {};
    Streamlet.is = function(object) {
      if (typeof object === "object" && object !== null || typeof object === "function") {
        const streamlet = object;
        return "streamletScope" in streamlet && typeof streamlet.setStreamletScope === "function" && "streamletContext" in streamlet && typeof streamlet.setStreamletContext === "function";
      }
      return false;
    };
    return Streamlet;
  }();
  class AbstractInlet {
    constructor() {
      this.input = null;
      this.version = -1;
    }
    bindInput(newInput) {
      const oldInput = this.input;
      if (oldInput !== newInput) {
        if (oldInput !== null) {
          oldInput.unbindOutput(this);
        }
        this.input = newInput;
        if (newInput !== null) {
          newInput.bindOutput(this);
        }
      }
    }
    unbindInput() {
      const oldInput = this.input;
      if (oldInput !== null) {
        oldInput.unbindOutput(this);
        this.input = null;
      }
    }
    disconnectInputs() {
      const oldInput = this.input;
      if (oldInput !== null) {
        oldInput.unbindOutput(this);
        this.input = null;
        oldInput.disconnectInputs();
      }
    }
    disconnectOutputs() {}
    decohereOutput() {
      if (this.version >= 0) {
        this.willDecohereOutput();
        this.version = -1;
        this.onDecohereOutput();
        this.didDecohereOutput();
      }
    }
    recohereOutput(version) {
      if (this.version < 0) {
        this.willRecohereOutput(version);
        this.version = version;
        if (this.input !== null) {
          this.input.recohereInput(version);
        }
        this.onRecohereOutput(version);
        this.didRecohereOutput(version);
      }
    }
    willDecohereOutput() {}
    onDecohereOutput() {}
    didDecohereOutput() {}
    willRecohereOutput(version) {}
    onRecohereOutput(version) {}
    didRecohereOutput(version) {}
  }
  class AbstractOutlet {
    constructor() {
      this.outputs = Arrays.empty;
      this.version = -1;
    }
    outputIterator() {
      return Cursor.array(this.outputs);
    }
    bindOutput(output) {
      this.outputs = Arrays.inserted(output, this.outputs);
    }
    unbindOutput(output) {
      this.outputs = Arrays.removed(output, this.outputs);
    }
    unbindOutputs() {
      const oldOutputs = this.outputs;
      this.outputs = Arrays.empty;
      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {
        const output = oldOutputs[i];
        output.unbindInput();
      }
    }
    disconnectOutputs() {
      const oldOutputs = this.outputs;
      this.outputs = Arrays.empty;
      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {
        const output = oldOutputs[i];
        output.unbindInput();
        output.disconnectOutputs();
      }
    }
    disconnectInputs() {}
    decohereInput() {
      if (this.version >= 0) {
        this.willDecohereInput();
        this.version = -1;
        this.onDecohereInput();
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          outputs[i].decohereOutput();
        }
        this.didDecohereInput();
      }
    }
    recohereInput(version) {
      if (this.version < 0) {
        this.willRecohereInput(version);
        this.version = version;
        this.onRecohereInput(version);
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          outputs[i].recohereOutput(version);
        }
        this.didRecohereInput(version);
      }
    }
    willDecohereInput() {}
    onDecohereInput() {}
    didDecohereInput() {}
    willRecohereInput(version) {}
    onRecohereInput(version) {}
    didRecohereInput(version) {}
  }
  OutletCombinators.define(AbstractOutlet.prototype);
  class AbstractInoutlet {
    constructor() {
      this.input = null;
      this.outputs = Arrays.empty;
      this.version = -1;
    }
    bindInput(newInput) {
      const oldInput = this.input;
      if (oldInput !== newInput) {
        if (oldInput !== null) {
          oldInput.unbindOutput(this);
        }
        this.input = newInput;
        if (newInput !== null) {
          newInput.bindOutput(this);
        }
      }
    }
    unbindInput() {
      const oldInput = this.input;
      if (oldInput !== null) {
        oldInput.unbindOutput(this);
        this.input = null;
      }
    }
    disconnectInputs() {
      const oldInput = this.input;
      if (oldInput !== null) {
        oldInput.unbindOutput(this);
        this.input = null;
        oldInput.disconnectInputs();
      }
    }
    outputIterator() {
      return Cursor.array(this.outputs);
    }
    bindOutput(output) {
      this.outputs = Arrays.inserted(output, this.outputs);
    }
    unbindOutput(output) {
      this.outputs = Arrays.removed(output, this.outputs);
    }
    unbindOutputs() {
      const oldOutputs = this.outputs;
      this.outputs = Arrays.empty;
      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {
        const output = oldOutputs[i];
        output.unbindInput();
      }
    }
    disconnectOutputs() {
      const oldOutputs = this.outputs;
      this.outputs = Arrays.empty;
      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {
        const output = oldOutputs[i];
        output.unbindInput();
        output.disconnectOutputs();
      }
    }
    decohereOutput() {
      this.decohere();
    }
    decohereInput() {
      this.decohere();
    }
    decohere() {
      if (this.version >= 0) {
        this.willDecohere();
        this.version = -1;
        this.onDecohere();
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          outputs[i].decohereOutput();
        }
        this.didDecohere();
      }
    }
    recohereOutput(version) {
      this.recohere(version);
    }
    recohereInput(version) {
      this.recohere(version);
    }
    recohere(version) {
      if (this.version < 0) {
        this.willRecohere(version);
        this.version = version;
        if (this.input !== null) {
          this.input.recohereInput(version);
        }
        this.onRecohere(version);
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          outputs[i].recohereOutput(version);
        }
        this.didRecohere(version);
      }
    }
    willDecohere() {}
    onDecohere() {}
    didDecohere() {}
    willRecohere(version) {}
    onRecohere(version) {}
    didRecohere(version) {}
  }
  OutletCombinators.define(AbstractInoutlet.prototype);
  class KeyOutlet extends AbstractOutlet {
    constructor(input, key) {
      super();
      this.input = input;
      this.key = key;
    }
    get() {
      return this.input.get(this.key);
    }
  }
  class AbstractMapInlet {
    constructor() {
      this.input = null;
      this.effects = new BTree;
      this.version = -1;
    }
    bindInput(newInput) {
      if (!MapOutlet.is(newInput)) {
        throw new TypeError("" + newInput);
      }
      const oldInput = this.input;
      if (oldInput !== newInput) {
        if (oldInput !== null) {
          oldInput.unbindOutput(this);
        }
        this.input = newInput;
        if (newInput !== null) {
          newInput.bindOutput(this);
        }
      }
    }
    unbindInput() {
      const oldInput = this.input;
      if (oldInput !== null) {
        oldInput.unbindOutput(this);
        this.input = null;
      }
    }
    disconnectInputs() {
      const oldInput = this.input;
      if (oldInput !== null) {
        oldInput.unbindOutput(this);
        this.input = null;
        oldInput.disconnectInputs();
      }
    }
    disconnectOutputs() {}
    decohereOutputKey(key, effect) {
      const oldEffects = this.effects;
      if (oldEffects.get(key) !== effect) {
        this.willDecohereOutputKey(key, effect);
        this.effects = oldEffects.updated(key, effect);
        this.version = -1;
        this.onDecohereOutputKey(key, effect);
        this.didDecohereOutputKey(key, effect);
      }
    }
    decohereOutput() {
      if (this.version >= 0) {
        this.willDecohereOutput();
        this.version = -1;
        this.onDecohereOutput();
        this.didDecohereOutput();
      }
    }
    recohereOutputKey(key, version) {
      if (this.version < 0) {
        const oldEffects = this.effects;
        const effect = oldEffects.get(key);
        if (effect !== void 0) {
          this.willRecohereOutputKey(key, effect, version);
          this.effects = oldEffects.removed(key);
          if (this.input !== null) {
            this.input.recohereInputKey(key, version);
          }
          this.onRecohereOutputKey(key, effect, version);
          this.didRecohereOutputKey(key, effect, version);
        }
      }
    }
    recohereOutput(version) {
      if (this.version < 0) {
        this.willRecohereOutput(version);
        this.effects.forEach((function(key) {
          this.recohereOutputKey(key, version);
        }), this);
        this.version = version;
        this.onRecohereOutput(version);
        this.didRecohereOutput(version);
      }
    }
    willDecohereOutputKey(key, effect) {}
    onDecohereOutputKey(key, effect) {}
    didDecohereOutputKey(key, effect) {}
    willDecohereOutput() {}
    onDecohereOutput() {}
    didDecohereOutput() {}
    willRecohereOutputKey(key, effect, version) {}
    onRecohereOutputKey(key, effect, version) {}
    didRecohereOutputKey(key, effect, version) {}
    willRecohereOutput(version) {}
    onRecohereOutput(version) {}
    didRecohereOutput(version) {}
  }
  class AbstractMapOutlet {
    constructor() {
      this.effects = new BTree;
      this.outlets = new BTree;
      this.outputs = Arrays.empty;
      this.version = -1;
    }
    outlet(key) {
      const oldOutlets = this.outlets;
      let outlet = oldOutlets.get(key);
      if (outlet === void 0) {
        outlet = new KeyOutlet(this, key);
        this.outlets = oldOutlets.updated(key, outlet);
      }
      return outlet;
    }
    outputIterator() {
      return Cursor.array(this.outputs);
    }
    bindOutput(output) {
      this.outputs = Arrays.inserted(output, this.outputs);
    }
    unbindOutput(output) {
      this.outputs = Arrays.removed(output, this.outputs);
    }
    unbindOutputs() {
      const oldOutlets = this.outlets;
      if (oldOutlets.isEmpty()) {
        this.outlets = new BTree;
        oldOutlets.forEach((function(key, keyOutlet) {
          keyOutlet.unbindOutputs();
        }), this);
      }
      const oldOutputs = this.outputs;
      this.outputs = Arrays.empty;
      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {
        const output = oldOutputs[i];
        output.unbindInput();
      }
    }
    disconnectOutputs() {
      const oldOutlets = this.outlets;
      if (oldOutlets.isEmpty()) {
        this.outlets = new BTree;
        oldOutlets.forEach((function(key, keyOutlet) {
          keyOutlet.disconnectOutputs();
        }), this);
      }
      const oldOutputs = this.outputs;
      this.outputs = Arrays.empty;
      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {
        const output = oldOutputs[i];
        output.unbindInput();
        output.disconnectOutputs();
      }
    }
    disconnectInputs() {}
    decohereInputKey(key, effect) {
      const oldEffects = this.effects;
      if (oldEffects.get(key) !== effect) {
        this.willDecohereInputKey(key, effect);
        this.effects = oldEffects.updated(key, effect);
        this.version = -1;
        this.onDecohereInputKey(key, effect);
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          const output = outputs[i];
          if (MapInlet.is(output)) {
            output.decohereOutputKey(key, effect);
          } else {
            output.decohereOutput();
          }
        }
        const outlet = this.outlets.get(key);
        if (outlet !== void 0) {
          outlet.decohereInput();
        }
        this.didDecohereInputKey(key, effect);
      }
    }
    decohereInput() {
      if (this.version >= 0) {
        this.willDecohereInput();
        this.version = -1;
        this.onDecohereInput();
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          const output = outputs[i];
          output.decohereOutput();
        }
        this.outlets.forEach((function(key, outlet) {
          outlet.decohereInput();
        }), this);
        this.didDecohereInput();
      }
    }
    recohereInputKey(key, version) {
      if (this.version < 0) {
        const oldEffects = this.effects;
        const effect = oldEffects.get(key);
        if (effect !== void 0) {
          this.willRecohereInputKey(key, effect, version);
          this.effects = oldEffects.removed(key);
          this.onRecohereInputKey(key, effect, version);
          const outputs = this.outputs;
          for (let i = 0, n = outputs.length; i < n; i += 1) {
            const output = outputs[i];
            if (MapInlet.is(output)) {
              output.recohereOutputKey(key, version);
            }
          }
          const outlet = this.outlets.get(key);
          if (outlet !== void 0) {
            outlet.recohereInput(version);
          }
          this.didRecohereInputKey(key, effect, version);
        }
      }
    }
    recohereInput(version) {
      if (this.version < 0) {
        this.willRecohereInput(version);
        this.effects.forEach((function(key) {
          this.recohereInputKey(key, version);
        }), this);
        this.version = version;
        this.onRecohereInput(version);
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          const output = outputs[i];
          output.recohereOutput(version);
        }
        this.didRecohereInput(version);
      }
    }
    willDecohereInputKey(key, effect) {}
    onDecohereInputKey(key, effect) {}
    didDecohereInputKey(key, effect) {}
    willDecohereInput() {}
    onDecohereInput() {}
    didDecohereInput() {}
    willRecohereInputKey(key, effect, version) {}
    onRecohereInputKey(key, effect, version) {}
    didRecohereInputKey(key, effect, version) {}
    willRecohereInput(version) {}
    onRecohereInput(version) {}
    didRecohereInput(version) {}
  }
  MapOutletCombinators.define(AbstractMapOutlet.prototype);
  class AbstractMapInoutlet {
    constructor() {
      this.input = null;
      this.effects = new BTree;
      this.outlets = new BTree;
      this.outputs = Arrays.empty;
      this.version = -1;
    }
    bindInput(newInput) {
      if (!MapOutlet.is(newInput)) {
        throw new TypeError("" + newInput);
      }
      const oldInput = this.input;
      if (oldInput !== newInput) {
        if (oldInput !== null) {
          oldInput.unbindOutput(this);
        }
        this.input = newInput;
        if (newInput !== null) {
          newInput.bindOutput(this);
        }
      }
    }
    unbindInput() {
      const oldInput = this.input;
      if (oldInput !== null) {
        oldInput.unbindOutput(this);
        this.input = null;
      }
    }
    disconnectInputs() {
      const oldInput = this.input;
      if (oldInput !== null) {
        oldInput.unbindOutput(this);
        this.input = null;
        oldInput.disconnectInputs();
      }
    }
    outlet(key) {
      const oldOutlets = this.outlets;
      let outlet = oldOutlets.get(key);
      if (outlet === void 0) {
        outlet = new KeyOutlet(this, key);
        this.outlets = oldOutlets.updated(key, outlet);
      }
      return outlet;
    }
    outputIterator() {
      return Cursor.array(this.outputs);
    }
    bindOutput(output) {
      this.outputs = Arrays.inserted(output, this.outputs);
    }
    unbindOutput(output) {
      this.outputs = Arrays.removed(output, this.outputs);
    }
    unbindOutputs() {
      const oldOutlets = this.outlets;
      if (oldOutlets.isEmpty()) {
        this.outlets = new BTree;
        oldOutlets.forEach((function(key, keyOutlet) {
          keyOutlet.unbindOutputs();
        }), this);
      }
      const oldOutputs = this.outputs;
      this.outputs = Arrays.empty;
      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {
        const output = oldOutputs[i];
        output.unbindInput();
      }
    }
    disconnectOutputs() {
      const oldOutlets = this.outlets;
      if (oldOutlets.isEmpty()) {
        this.outlets = new BTree;
        oldOutlets.forEach((function(key, keyOutlet) {
          keyOutlet.disconnectOutputs();
        }), this);
      }
      const oldOutputs = this.outputs;
      this.outputs = Arrays.empty;
      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {
        const output = oldOutputs[i];
        output.unbindInput();
        output.disconnectOutputs();
      }
    }
    decohereOutputKey(key, effect) {
      this.decohereKey(key, effect);
    }
    decohereInputKey(key, effect) {
      this.decohereKey(key, effect);
    }
    decohereKey(key, effect) {
      const oldEffects = this.effects;
      if (oldEffects.get(key) !== effect) {
        this.willDecohereKey(key, effect);
        this.effects = oldEffects.updated(key, effect);
        this.version = -1;
        this.onDecohereKey(key, effect);
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          const output = outputs[i];
          if (MapInlet.is(output)) {
            output.decohereOutputKey(key, effect);
          } else {
            output.decohereOutput();
          }
        }
        const outlet = this.outlets.get(key);
        if (outlet !== void 0) {
          outlet.decohereInput();
        }
        this.didDecohereKey(key, effect);
      }
    }
    decohereOutput() {
      this.decohere();
    }
    decohereInput() {
      this.decohere();
    }
    decohere() {
      if (this.version >= 0) {
        this.willDecohere();
        this.version = -1;
        this.onDecohere();
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          const output = outputs[i];
          output.decohereOutput();
        }
        this.outlets.forEach((function(key, outlet) {
          outlet.decohereInput();
        }), this);
        this.didDecohere();
      }
    }
    recohereOutputKey(key, version) {
      this.recohereKey(key, version);
    }
    recohereInputKey(key, version) {
      this.recohereKey(key, version);
    }
    recohereKey(key, version) {
      if (this.version < 0) {
        const oldEffects = this.effects;
        const effect = oldEffects.get(key);
        if (effect !== void 0) {
          this.willRecohereKey(key, effect, version);
          this.effects = oldEffects.removed(key);
          if (this.input !== null) {
            this.input.recohereInputKey(key, version);
          }
          this.onRecohereKey(key, effect, version);
          const outputs = this.outputs;
          for (let i = 0, n = outputs.length; i < n; i += 1) {
            const output = outputs[i];
            if (MapInlet.is(output)) {
              output.recohereOutputKey(key, version);
            }
          }
          const outlet = this.outlets.get(key);
          if (outlet !== void 0) {
            outlet.recohereInput(version);
          }
          this.didRecohereKey(key, effect, version);
        }
      }
    }
    recohereOutput(version) {
      this.recohere(version);
    }
    recohereInput(version) {
      this.recohere(version);
    }
    recohere(version) {
      if (this.version < 0) {
        this.willRecohere(version);
        this.effects.forEach((function(key) {
          this.recohereKey(key, version);
        }), this);
        this.version = version;
        this.onRecohere(version);
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          const output = outputs[i];
          output.recohereOutput(version);
        }
        this.didRecohere(version);
      }
    }
    willDecohereKey(key, effect) {}
    onDecohereKey(key, effect) {}
    didDecohereKey(key, effect) {}
    willDecohere() {}
    onDecohere() {}
    didDecohere() {}
    willRecohereKey(key, effect, version) {}
    onRecohereKey(key, effect, version) {}
    didRecohereKey(key, effect, version) {}
    willRecohere(version) {}
    onRecohere(version) {}
    didRecohere(version) {}
  }
  MapOutletCombinators.define(AbstractMapInoutlet.prototype);
  class AbstractMapInletOutlet {
    constructor() {
      this.input = null;
      this.effects = new BTree;
      this.outputs = Arrays.empty;
      this.version = -1;
    }
    bindInput(newInput) {
      if (!MapOutlet.is(newInput)) {
        throw new TypeError("" + newInput);
      }
      const oldInput = this.input;
      if (oldInput !== newInput) {
        if (oldInput !== null) {
          oldInput.unbindOutput(this);
        }
        this.input = newInput;
        if (newInput !== null) {
          newInput.bindOutput(this);
        }
      }
    }
    unbindInput() {
      const oldInput = this.input;
      if (oldInput !== null) {
        oldInput.unbindOutput(this);
        this.input = null;
      }
    }
    disconnectInputs() {
      const oldInput = this.input;
      if (oldInput !== null) {
        oldInput.unbindOutput(this);
        this.input = null;
        oldInput.disconnectInputs();
      }
    }
    outputIterator() {
      return Cursor.array(this.outputs);
    }
    bindOutput(output) {
      this.outputs = Arrays.inserted(output, this.outputs);
    }
    unbindOutput(output) {
      this.outputs = Arrays.removed(output, this.outputs);
    }
    unbindOutputs() {
      const oldOutputs = this.outputs;
      this.outputs = Arrays.empty;
      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {
        const output = oldOutputs[i];
        output.unbindInput();
      }
    }
    disconnectOutputs() {
      const oldOutputs = this.outputs;
      this.outputs = Arrays.empty;
      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {
        const output = oldOutputs[i];
        output.unbindInput();
        output.disconnectOutputs();
      }
    }
    decohereOutputKey(key, effect) {
      const oldEffects = this.effects;
      if (oldEffects.get(key) !== effect) {
        this.willDecohereOutputKey(key, effect);
        this.effects = oldEffects.updated(key, effect);
        this.version = -1;
        this.onDecohereOutputKey(key, effect);
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          const output = outputs[i];
          output.decohereOutput();
        }
        this.didDecohereOutputKey(key, effect);
      }
    }
    decohereOutput() {
      this.decohere();
    }
    decohereInput() {
      this.decohere();
    }
    decohere() {
      if (this.version >= 0) {
        this.willDecohere();
        this.version = -1;
        this.onDecohere();
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          const output = outputs[i];
          output.decohereOutput();
        }
        this.didDecohere();
      }
    }
    recohereOutputKey(key, version) {
      if (this.version < 0) {
        const oldEffects = this.effects;
        const effect = oldEffects.get(key);
        if (effect !== void 0) {
          this.willRecohereOutputKey(key, effect, version);
          this.effects = oldEffects.removed(key);
          if (this.input !== null) {
            this.input.recohereInputKey(key, version);
          }
          this.onRecohereOutputKey(key, effect, version);
          this.didRecohereOutputKey(key, effect, version);
        }
      }
    }
    recohereOutput(version) {
      this.recohere(version);
    }
    recohereInput(version) {
      this.recohere(version);
    }
    recohere(version) {
      if (this.version < 0) {
        this.willRecohere(version);
        this.effects.forEach((function(key) {
          this.recohereOutputKey(key, version);
        }), this);
        this.version = version;
        this.onRecohere(version);
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          const output = outputs[i];
          output.recohereOutput(version);
        }
        this.didRecohere(version);
      }
    }
    willDecohereOutputKey(key, effect) {}
    onDecohereOutputKey(key, effect) {}
    didDecohereOutputKey(key, effect) {}
    willDecohere() {}
    onDecohere() {}
    didDecohere() {}
    willRecohereOutputKey(key, effect, version) {}
    onRecohereOutputKey(key, effect, version) {}
    didRecohereOutputKey(key, effect, version) {}
    willRecohere(version) {}
    onRecohere(version) {}
    didRecohere(version) {}
  }
  OutletCombinators.define(AbstractMapInletOutlet.prototype);
  class AbstractMapInletMapOutlet {
    constructor() {
      this.input = null;
      this.outputEffects = new BTree;
      this.inputEffects = new BTree;
      this.outlets = new BTree;
      this.outputs = Arrays.empty;
      this.version = -1;
    }
    bindInput(newInput) {
      if (!MapOutlet.is(newInput)) {
        throw new TypeError("" + newInput);
      }
      const oldInput = this.input;
      if (oldInput !== newInput) {
        if (oldInput !== null) {
          oldInput.unbindOutput(this);
        }
        this.input = newInput;
        if (newInput !== null) {
          newInput.bindOutput(this);
        }
      }
    }
    unbindInput() {
      const oldInput = this.input;
      if (oldInput !== null) {
        oldInput.unbindOutput(this);
        this.input = null;
      }
    }
    disconnectInputs() {
      const oldInput = this.input;
      if (oldInput !== null) {
        oldInput.unbindOutput(this);
        this.input = null;
        oldInput.disconnectInputs();
      }
    }
    outlet(key) {
      const oldOutlets = this.outlets;
      let outlet = oldOutlets.get(key);
      if (outlet === void 0) {
        outlet = new KeyOutlet(this, key);
        this.outlets = oldOutlets.updated(key, outlet);
      }
      return outlet;
    }
    outputIterator() {
      return Cursor.array(this.outputs);
    }
    bindOutput(output) {
      this.outputs = Arrays.inserted(output, this.outputs);
    }
    unbindOutput(output) {
      this.outputs = Arrays.removed(output, this.outputs);
    }
    unbindOutputs() {
      const oldOutlets = this.outlets;
      if (oldOutlets.isEmpty()) {
        this.outlets = new BTree;
        oldOutlets.forEach((function(key, keyOutlet) {
          keyOutlet.unbindOutputs();
        }), this);
      }
      const oldOutputs = this.outputs;
      this.outputs = Arrays.empty;
      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {
        const output = oldOutputs[i];
        output.unbindInput();
      }
    }
    disconnectOutputs() {
      const oldOutlets = this.outlets;
      if (oldOutlets.isEmpty()) {
        this.outlets = new BTree;
        oldOutlets.forEach((function(key, keyOutlet) {
          keyOutlet.disconnectOutputs();
        }), this);
      }
      const oldOutputs = this.outputs;
      this.outputs = Arrays.empty;
      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {
        const output = oldOutputs[i];
        output.unbindInput();
        output.disconnectOutputs();
      }
    }
    decohereOutputKey(key, effect) {
      const oldOutputEffects = this.outputEffects;
      if (oldOutputEffects.get(key) !== effect) {
        this.willDecohereOutputKey(key, effect);
        this.outputEffects = oldOutputEffects.updated(key, effect);
        this.version = -1;
        this.onDecohereOutputKey(key, effect);
        this.didDecohereOutputKey(key, effect);
      }
    }
    decohereInputKey(key, effect) {
      const oldInputEffects = this.inputEffects;
      if (oldInputEffects.get(key) !== effect) {
        this.willDecohereInputKey(key, effect);
        this.inputEffects = oldInputEffects.updated(key, effect);
        this.version = -1;
        this.onDecohereInputKey(key, effect);
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          const output = outputs[i];
          if (MapInlet.is(output)) {
            output.decohereOutputKey(key, effect);
          } else {
            output.decohereOutput();
          }
        }
        const outlet = this.outlets.get(key);
        if (outlet !== void 0) {
          outlet.decohereInput();
        }
        this.didDecohereInputKey(key, effect);
      }
    }
    decohereOutput() {
      this.decohere();
    }
    decohereInput() {
      this.decohere();
    }
    decohere() {
      if (this.version >= 0) {
        this.willDecohere();
        this.version = -1;
        this.onDecohere();
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          const output = outputs[i];
          output.decohereOutput();
        }
        this.outlets.forEach((function(key, outlet) {
          outlet.decohereInput();
        }), this);
        this.didDecohere();
      }
    }
    recohereOutputKey(key, version) {
      if (this.version < 0) {
        const oldOutputEffects = this.outputEffects;
        const effect = oldOutputEffects.get(key);
        if (effect !== void 0) {
          this.willRecohereOutputKey(key, effect, version);
          this.outputEffects = oldOutputEffects.removed(key);
          if (this.input !== null) {
            this.input.recohereInputKey(key, version);
          }
          this.onRecohereOutputKey(key, effect, version);
          this.didRecohereOutputKey(key, effect, version);
        }
      }
    }
    recohereInputKey(key, version) {
      if (this.version < 0) {
        const oldInputEffects = this.inputEffects;
        const oldEffect = oldInputEffects.get(key);
        if (oldEffect !== void 0) {
          const newEffect = this.willRecohereInputKey(key, oldEffect, version);
          if (oldEffect !== newEffect) {
            this.decohereInputKey(key, newEffect);
          }
          this.inputEffects = oldInputEffects.removed(key);
          this.onRecohereInputKey(key, newEffect, version);
          const outputs = this.outputs;
          for (let i = 0, n = outputs.length; i < n; i += 1) {
            const output = outputs[i];
            if (MapInlet.is(output)) {
              output.recohereOutputKey(key, version);
            }
          }
          const outlet = this.outlets.get(key);
          if (outlet !== void 0) {
            outlet.recohereInput(version);
          }
          this.didRecohereInputKey(key, newEffect, version);
        }
      }
    }
    recohereOutput(version) {
      this.recohere(version);
    }
    recohereInput(version) {
      this.recohere(version);
    }
    recohere(version) {
      if (this.version < 0) {
        this.willRecohere(version);
        this.outputEffects.forEach((function(key) {
          this.recohereOutputKey(key, version);
        }), this);
        this.inputEffects.forEach((function(key) {
          this.recohereInputKey(key, version);
        }), this);
        this.version = version;
        this.onRecohere(version);
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          const output = outputs[i];
          output.recohereOutput(version);
        }
        this.didRecohere(version);
      }
    }
    willDecohereOutputKey(key, effect) {}
    onDecohereOutputKey(key, effect) {}
    didDecohereOutputKey(key, effect) {}
    willDecohereInputKey(key, effect) {}
    onDecohereInputKey(key, effect) {}
    didDecohereInputKey(key, effect) {}
    willDecohere() {}
    onDecohere() {}
    didDecohere() {}
    willRecohereOutputKey(key, effect, version) {}
    onRecohereOutputKey(key, effect, version) {}
    didRecohereOutputKey(key, effect, version) {}
    willRecohereInputKey(key, effect, version) {
      return effect;
    }
    onRecohereInputKey(key, effect, version) {}
    didRecohereInputKey(key, effect, version) {}
    willRecohere(version) {}
    onRecohere(version) {}
    didRecohere(version) {}
  }
  MapOutletCombinators.define(AbstractMapInletMapOutlet.prototype);
  class OutletInlet extends AbstractInlet {
    constructor(outlet) {
      super();
      this.outlet = outlet;
    }
    onDecohereOutput() {
      this.outlet.decohereInput();
    }
    onRecohereOutput(version) {
      this.outlet.recohereInput(version);
    }
  }
  class OutletMapInlet extends AbstractMapInlet {
    constructor(outlet) {
      super();
      this.outlet = outlet;
    }
    onDecohereOutputKey(key, effect) {
      this.outlet.decohereInput();
    }
    onDecohereOutput() {
      this.outlet.decohereInput();
    }
    onRecohereOutputKey(key, effect, version) {
      this.outlet.recohereInput(version);
    }
    onRecohereOutput(version) {
      this.outlet.recohereInput(version);
    }
  }
  class ValueInput extends AbstractOutlet {
    constructor(state) {
      super();
      this.state = state;
    }
    get() {
      return this.state;
    }
    set(newState) {
      const oldState = this.state;
      if (oldState !== newState) {
        this.state = newState;
        this.decohereInput();
      }
      return oldState;
    }
  }
  class ValueOutput extends AbstractInlet {
    constructor(state) {
      super();
      this.state = state;
    }
    get() {
      return this.state;
    }
    onRecohereOutput(version) {
      const input = this.input;
      if (input !== null) {
        this.state = input.get();
      }
    }
  }
  class MapInput extends AbstractMapOutlet {
    constructor(state) {
      super();
      if (state === void 0) {
        state = new BTree;
      }
      this.state = state;
      let effects = this.effects;
      state.forEach((function(key) {
        effects = effects.updated(key, 0);
      }), this);
      this.effects = effects;
    }
    has(key) {
      return this.state.has(key);
    }
    get(key) {
      if (key === void 0) {
        return this.state;
      } else {
        return this.state.get(key);
      }
    }
    set(key, newValue) {
      const oldState = this.state;
      const oldValue = oldState.get(key);
      if (oldValue !== newValue) {
        this.state = oldState.updated(key, newValue);
        this.decohereInputKey(key, 0);
      }
      return oldValue;
    }
    delete(key) {
      const oldState = this.state;
      const newState = oldState.removed(key);
      if (oldState !== newState) {
        this.state = newState;
        this.decohereInputKey(key, 1);
      }
      return this;
    }
    keyIterator() {
      return this.state.keys();
    }
  }
  class MapOutput extends AbstractMapInlet {
    constructor() {
      super();
      this.state = new BTree;
    }
    get() {
      return this.state;
    }
    onRecohereOutputKey(key, effect, version) {
      if (effect === 0) {
        const input = this.input;
        if (input !== null) {
          const value = input.get(key);
          if (value !== void 0) {
            this.state = this.state.updated(key, value);
          } else {
            this.state = this.state.removed(key);
          }
        }
      } else if (effect === 1) {
        this.state = this.state.removed(key);
      }
    }
  }
  class MemoizeValueCombinator extends AbstractInoutlet {
    constructor() {
      super();
      this.state = void 0;
    }
    get() {
      return this.state;
    }
    onRecohere(version) {
      const input = this.input;
      if (input !== null) {
        this.state = input.get();
      }
    }
    memoize() {
      return this;
    }
  }
  class MemoizeMapCombinator extends AbstractMapInoutlet {
    constructor() {
      super();
      this.state = void 0;
      this.cache = new BTree;
    }
    has(key) {
      return this.cache.has(key);
    }
    get(key) {
      if (key === void 0) {
        let state = this.state;
        const input = this.input;
        if (state === void 0 && input !== null) {
          state = input.get();
          this.state = state;
        }
        return state;
      } else {
        return this.cache.get(key);
      }
    }
    keyIterator() {
      return this.cache.keys();
    }
    onRecohereKey(key, effect, version) {
      if (effect === 0) {
        const input = this.input;
        if (input !== null) {
          const value = input.get(key);
          if (value !== void 0) {
            this.cache = this.cache.updated(key, value);
          } else {
            this.cache = this.cache.removed(key);
          }
        }
      } else if (effect === 1) {
        this.cache = this.cache.removed(key);
      }
    }
    onRecohere(version) {
      this.state = void 0;
    }
    memoize() {
      return this;
    }
  }
  class FilterFieldsOperator extends AbstractMapInletMapOutlet {
    has(key) {
      const input = this.input;
      if (input !== null) {
        const value = input.get(key);
        return value !== void 0 && this.evaluate(key, value);
      }
      return false;
    }
    get(key) {
      if (key === void 0) {
        const output = new BTree;
        const keys = this.keyIterator();
        do {
          const next = keys.next();
          if (!next.done) {
            const key = next.value;
            const value = this.input.get(key);
            if (value !== void 0 && this.evaluate(key, value)) {
              output.set(key, value);
            }
            continue;
          }
          break;
        } while (true);
        return output;
      } else {
        const input = this.input;
        if (input !== null) {
          const value = input.get(key);
          if (value !== void 0 && this.evaluate(key, value)) {
            return value;
          }
        }
        return void 0;
      }
    }
    keyIterator() {
      const input = this.input;
      if (input !== null) {
        return input.keyIterator();
      } else {
        return Cursor.empty();
      }
    }
    onDecohereOutputKey(key, effect) {
      this.decohereInputKey(key, effect);
    }
    onRecohereOutputKey(key, effect, version) {
      this.recohereInputKey(key, version);
    }
    willRecohereInputKey(key, effect, version) {
      if (effect === 0) {
        const input = this.input;
        if (input !== null) {
          const value = input.get(key);
          if (value === void 0 || !this.evaluate(key, value)) {
            return 1;
          }
        }
      }
      return effect;
    }
  }
  class FilterFieldsCombinator extends FilterFieldsOperator {
    constructor(func) {
      super();
      this.func = func;
    }
    evaluate(key, value) {
      const func = this.func;
      return func(key, value);
    }
  }
  class MapValueOperator extends AbstractInoutlet {
    get() {
      const input = this.input;
      if (input !== null) {
        return this.evaluate(input.get());
      } else {
        return void 0;
      }
    }
  }
  class MapValueCombinator extends MapValueOperator {
    constructor(func) {
      super();
      this.func = func;
    }
    evaluate(value) {
      if (value !== void 0) {
        const func = this.func;
        return func(value);
      } else {
        return void 0;
      }
    }
  }
  class MapFieldValuesOperator extends AbstractMapInoutlet {
    has(key) {
      const input = this.input;
      if (input !== null) {
        return input.has(key);
      } else {
        return false;
      }
    }
    get(key) {
      if (key === void 0) {
        const output = new BTree;
        const keys = this.keyIterator();
        do {
          const next = keys.next();
          if (!next.done) {
            const key = next.value;
            const value = this.evaluate(key, this.input.get(key));
            if (value !== void 0) {
              output.set(key, value);
            }
            continue;
          }
          break;
        } while (true);
        return output;
      } else {
        const input = this.input;
        if (input !== null) {
          return this.evaluate(key, input.get(key));
        } else {
          return void 0;
        }
      }
    }
    keyIterator() {
      const input = this.input;
      if (input !== null) {
        return input.keyIterator();
      } else {
        return Cursor.empty();
      }
    }
  }
  class MapFieldValuesCombinator extends MapFieldValuesOperator {
    constructor(func) {
      super();
      this.func = func;
    }
    evaluate(key, value) {
      if (value !== void 0) {
        const func = this.func;
        return func(key, value);
      } else {
        return void 0;
      }
    }
  }
  class ReduceFieldsOperator extends AbstractMapInletOutlet {
    constructor() {
      super();
      this.state = new BTree;
    }
    get() {
      return this.state.reduced(this.identity, this.accumulate.bind(this), this.combine.bind(this));
    }
    onRecohereOutputKey(key, effect, version) {
      if (effect === 0) {
        const input = this.input;
        if (input !== null) {
          const value = input.get(key);
          if (value !== void 0) {
            this.state.set(key, value);
          } else {
            this.state.delete(key);
          }
        }
      } else if (effect === 1) {
        this.state.delete(key);
      }
    }
  }
  class ReduceFieldsCombinator extends ReduceFieldsOperator {
    constructor(identity, accumulator, combiner) {
      super();
      this.identity = identity;
      this.accumulator = accumulator;
      this.combiner = combiner;
    }
    get() {
      return this.state.reduced(this.identity, this.accumulator, this.combiner);
    }
    accumulate(result, value) {
      const accumulator = this.accumulator;
      return accumulator(result, value);
    }
    combine(result, value) {
      const combiner = this.combiner;
      return combiner(result, value);
    }
  }
  class WatchValueOperator extends AbstractInlet {
    onRecohereOutput(version) {
      const input = this.input;
      if (input !== null) {
        this.evaluate(input.get());
      }
    }
  }
  class WatchValueCombinator extends WatchValueOperator {
    constructor(func) {
      super();
      this.func = func;
    }
    evaluate(value) {
      if (value !== void 0) {
        const func = this.func;
        return func(value);
      }
    }
  }
  class WatchFieldsOperator extends AbstractMapInlet {
    onRecohereOutputKey(key, effect, version) {
      if (effect === 0) {
        const input = this.input;
        if (input !== null) {
          this.evaluate(key, input.get(key));
        } else {
          this.evaluate(key, void 0);
        }
      } else if (effect === 1) {
        this.evaluate(key, void 0);
      }
    }
  }
  class WatchFieldsCombinator extends WatchFieldsOperator {
    constructor(func) {
      super();
      this.func = func;
    }
    evaluate(key, value) {
      if (value !== void 0) {
        const func = this.func;
        return func(key, value);
      }
    }
  }
  class StreamletInlet extends AbstractInlet {
    constructor(streamlet) {
      super();
      this.streamlet = streamlet;
    }
    willDecohereOutput() {
      const streamlet = this.streamlet;
      if (streamlet.willDecohereInlet !== void 0) {
        streamlet.willDecohereInlet(this);
      }
    }
    didDecohereOutput() {
      const streamlet = this.streamlet;
      if (streamlet.didDecohereInlet !== void 0) {
        streamlet.didDecohereInlet(this);
      } else {
        streamlet.decohere();
      }
    }
    willRecohereOutput(version) {
      const streamlet = this.streamlet;
      if (streamlet.willRecohereInlet !== void 0) {
        streamlet.willRecohereInlet(this, version);
      }
    }
    didRecohereOutput(version) {
      const streamlet = this.streamlet;
      if (streamlet.didRecohereInlet !== void 0) {
        streamlet.didRecohereInlet(this, version);
      } else {
        streamlet.recohere(version);
      }
    }
  }
  class StreamletOutlet extends AbstractOutlet {
    constructor(streamlet) {
      super();
      this.streamlet = streamlet;
    }
    get() {
      const streamlet = this.streamlet;
      if (streamlet.getOutput !== void 0) {
        return streamlet.getOutput(this);
      } else {
        return void 0;
      }
    }
    willDecohereInput() {
      const streamlet = this.streamlet;
      if (streamlet.willDecohereOutlet !== void 0) {
        streamlet.willDecohereOutlet(this);
      }
    }
    didDecohereInput() {
      const streamlet = this.streamlet;
      if (streamlet.didDecohereOutlet !== void 0) {
        streamlet.didDecohereOutlet(this);
      } else {
        streamlet.decohere();
      }
    }
    willRecohereInput(version) {
      const streamlet = this.streamlet;
      if (streamlet.willRecohereOutlet !== void 0) {
        streamlet.willRecohereOutlet(this, version);
      }
    }
    didRecohereInput(version) {
      const streamlet = this.streamlet;
      if (streamlet.didRecohereOutlet !== void 0) {
        streamlet.didRecohereOutlet(this, version);
      }
    }
  }
  class StreamletInoutlet extends AbstractInoutlet {
    constructor(streamlet) {
      super();
      this.streamlet = streamlet;
    }
    get() {
      const streamlet = this.streamlet;
      if (streamlet.getOutput !== void 0) {
        const output = streamlet.getOutput(this);
        if (output !== void 0) {
          return output;
        }
      }
      const input = this.input;
      if (input !== null) {
        return input.get();
      } else {
        return void 0;
      }
    }
    willDecohere() {
      const streamlet = this.streamlet;
      if (streamlet.willDecohereOutlet !== void 0) {
        streamlet.willDecohereOutlet(this);
      }
    }
    didDecohere() {
      const streamlet = this.streamlet;
      if (streamlet.didDecohereOutlet !== void 0) {
        streamlet.didDecohereOutlet(this);
      } else {
        streamlet.decohere();
      }
    }
    willRecohere(version) {
      const streamlet = this.streamlet;
      if (streamlet.willRecohereOutlet !== void 0) {
        streamlet.willRecohereOutlet(this, version);
      }
    }
    didRecohere(version) {
      const streamlet = this.streamlet;
      if (streamlet.didRecohereOutlet !== void 0) {
        streamlet.didRecohereOutlet(this, version);
      }
    }
  }
  class InletDescriptor {
    constructor(key, name, type) {
      this.key = key;
      this.name = name;
      this.type = type;
    }
  }
  class OutletDescriptor {
    constructor(key, name, type) {
      this.key = key;
      this.name = name;
      this.type = type;
    }
  }
  class InoutletDescriptor {
    constructor(key, name, type) {
      this.key = key;
      this.name = name;
      this.type = type;
    }
  }
  class AbstractStreamlet {
    constructor(scope = null) {
      this.streamletScope = scope;
      this.streamletContext = null;
      this.version = -1;
    }
    setStreamletScope(scope) {
      this.streamletScope = scope;
    }
    setStreamletContext(context) {
      this.streamletContext = context;
    }
    inlet(key) {
      if (key === void 0) {
        return new StreamletInlet(this);
      } else {
        return AbstractStreamlet.reflectInletKey(key, this, Object.getPrototypeOf(this));
      }
    }
    bindInput(key, input) {
      const inlet = this.inlet(key);
      if (inlet === null) {
        throw new Error("" + key);
      }
      inlet.bindInput(input);
    }
    unbindInput(key) {
      const inlet = this.inlet(key);
      if (inlet === null) {
        throw new Error("" + key);
      }
      inlet.unbindInput();
    }
    outlet(key) {
      if (key === void 0) {
        return new StreamletOutlet(this);
      } else if (typeof key === "string") {
        return AbstractStreamlet.reflectOutletKey(key, this, Object.getPrototypeOf(this));
      } else {
        return key;
      }
    }
    inoutlet() {
      return new StreamletInoutlet(this);
    }
    decohere() {
      if (this.version >= 0) {
        this.willDecohere();
        this.version = -1;
        this.onDecohere();
        this.onDecohereOutlets();
        this.didDecohere();
      }
    }
    recohere(version) {
      if (this.version < 0) {
        this.willRecohere(version);
        this.version = version;
        this.onRecohereInlets(version);
        this.onRecohere(version);
        this.onRecohereOutlets(version);
        this.didRecohere(version);
      }
    }
    getInput(inlet, orElse) {
      if (typeof inlet === "string") {
        inlet = this.inlet(inlet);
      }
      let object;
      if (inlet !== null) {
        const input = inlet.input;
        if (input !== null) {
          object = input.get();
        }
      }
      if (object === void 0) {
        object = orElse;
      }
      return object;
    }
    getOutput(outlet) {
      return void 0;
    }
    disconnectInputs() {
      AbstractStreamlet.disconnectInputs(this, Object.getPrototypeOf(this));
    }
    static disconnectInputs(streamlet, streamletPrototype) {
      while (streamletPrototype !== null) {
        if (Object.prototype.hasOwnProperty.call(streamletPrototype, "inlets")) {
          for (const name in streamletPrototype.inlets) {
            const inletDescriptor = streamletPrototype.inlets[name];
            if (inletDescriptor instanceof InletDescriptor) {
              const inlet = AbstractStreamlet.reflectInletField(streamlet, inletDescriptor);
              inlet.disconnectInputs();
            } else if (inletDescriptor instanceof InoutletDescriptor) {
              const inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor);
              inoutlet.disconnectInputs();
            }
          }
        }
        streamletPrototype = Object.getPrototypeOf(streamletPrototype);
      }
    }
    disconnectOutputs() {
      AbstractStreamlet.disconnectOutputs(this, Object.getPrototypeOf(this));
    }
    static disconnectOutputs(streamlet, streamletPrototype) {
      while (streamletPrototype !== null) {
        if (Object.prototype.hasOwnProperty.call(streamletPrototype, "outlets")) {
          for (const name in streamletPrototype.outlets) {
            const outletDescriptor = streamletPrototype.outlets[name];
            if (outletDescriptor instanceof OutletDescriptor) {
              const outlet = AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);
              outlet.disconnectOutputs();
            } else if (outletDescriptor instanceof InoutletDescriptor) {
              const inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);
              inoutlet.disconnectOutputs();
            }
          }
        }
        streamletPrototype = Object.getPrototypeOf(streamletPrototype);
      }
    }
    willDecohereInlet(inlet) {}
    didDecohereInlet(inlet) {
      this.decohere();
    }
    willRecohereInlet(inlet, version) {}
    didRecohereInlet(inlet, version) {
      this.recohere(version);
    }
    willDecohereOutlet(outlet) {}
    didDecohereOutlet(outlet) {}
    willRecohereOutlet(outlet, version) {}
    didRecohereOutlet(outlet, version) {}
    willDecohere() {}
    onDecohere() {}
    onDecohereOutlets() {
      AbstractStreamlet.decohereOutlets(this, Object.getPrototypeOf(this));
    }
    static decohereOutlets(streamlet, streamletPrototype) {
      while (streamletPrototype !== null) {
        if (Object.prototype.hasOwnProperty.call(streamletPrototype, "outlets")) {
          for (const name in streamletPrototype.outlets) {
            const outletDescriptor = streamletPrototype.outlets[name];
            if (outletDescriptor instanceof OutletDescriptor) {
              const outlet = AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);
              outlet.decohereInput();
            } else if (outletDescriptor instanceof InoutletDescriptor) {
              const inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);
              inoutlet.decohereInput();
            }
          }
        }
        streamletPrototype = Object.getPrototypeOf(streamletPrototype);
      }
    }
    didDecohere() {}
    willRecohere(version) {}
    onRecohereInlets(version) {
      AbstractStreamlet.recohereInlets(version, this, Object.getPrototypeOf(this));
    }
    static recohereInlets(version, streamlet, streamletPrototype) {
      while (streamletPrototype !== null) {
        if (Object.prototype.hasOwnProperty.call(streamletPrototype, "inlets")) {
          for (const name in streamletPrototype.inlets) {
            const inletDescriptor = streamletPrototype.inlets[name];
            if (inletDescriptor instanceof InletDescriptor) {
              const inlet = AbstractStreamlet.reflectInletField(streamlet, inletDescriptor);
              inlet.recohereOutput(version);
            } else if (inletDescriptor instanceof InoutletDescriptor) {
              const inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor);
              inoutlet.recohereOutput(version);
            }
          }
        }
        streamletPrototype = Object.getPrototypeOf(streamletPrototype);
      }
    }
    onRecohere(version) {}
    onRecohereOutlets(version) {
      AbstractStreamlet.recohereOutlets(version, this, Object.getPrototypeOf(this));
    }
    static recohereOutlets(version, streamlet, streamletPrototype) {
      while (streamletPrototype !== null) {
        if (Object.prototype.hasOwnProperty.call(streamletPrototype, "outlets")) {
          for (const name in streamletPrototype.outlets) {
            const outletDescriptor = streamletPrototype.outlets[name];
            if (outletDescriptor instanceof OutletDescriptor) {
              const outlet = AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);
              outlet.recohereInput(version);
            } else if (outletDescriptor instanceof InoutletDescriptor) {
              const inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);
              inoutlet.recohereInput(version);
            }
          }
        }
        streamletPrototype = Object.getPrototypeOf(streamletPrototype);
      }
    }
    didRecohere(version) {}
    static reflectEachInlet(streamlet, streamletPrototype, callback, thisArg) {
      let index = 0;
      while (streamletPrototype !== null) {
        if (Object.prototype.hasOwnProperty.call(streamletPrototype, "inlets")) {
          for (const name in streamletPrototype.inlets) {
            const inletDescriptor = streamletPrototype.inlets[name];
            let inlet;
            if (inletDescriptor instanceof InletDescriptor) {
              inlet = AbstractStreamlet.reflectInletField(streamlet, inletDescriptor);
            } else if (inletDescriptor instanceof InoutletDescriptor) {
              inlet = AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor);
            } else {
              inlet = null;
            }
            if (inlet !== null) {
              const result = callback.call(thisArg, inlet, inletDescriptor.name, index);
              if (result !== void 0) {
                return result;
              }
              index += 1;
            }
          }
        }
        streamletPrototype = Object.getPrototypeOf(streamletPrototype);
      }
      return void 0;
    }
    static reflectEachOutlet(streamlet, streamletPrototype, callback, thisArg) {
      let index = 0;
      while (streamletPrototype !== null) {
        if (Object.prototype.hasOwnProperty.call(streamletPrototype, "outlets")) {
          for (const name in streamletPrototype.outlets) {
            const outletDescriptor = streamletPrototype.outlets[name];
            let outlet;
            if (outletDescriptor instanceof OutletDescriptor) {
              outlet = AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);
            } else if (outletDescriptor instanceof InoutletDescriptor) {
              outlet = AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);
            } else {
              outlet = null;
            }
            if (outlet !== null) {
              const result = callback.call(thisArg, outlet, outletDescriptor.name, index);
              if (result !== void 0) {
                return result;
              }
              index += 1;
            }
          }
        }
        streamletPrototype = Object.getPrototypeOf(streamletPrototype);
      }
      return void 0;
    }
    static reflectInletCount(streamletPrototype) {
      let count = 0;
      while (streamletPrototype !== null) {
        if (Object.prototype.hasOwnProperty.call(streamletPrototype, "inlets")) {
          for (const _ in streamletPrototype.inlets) {
            count += 1;
          }
        }
        streamletPrototype = Object.getPrototypeOf(streamletPrototype);
      }
      return count;
    }
    static reflectOutletCount(streamletPrototype) {
      let count = 0;
      while (streamletPrototype !== null) {
        if (Object.prototype.hasOwnProperty.call(streamletPrototype, "outlets")) {
          for (const _ in streamletPrototype.outlets) {
            count += 1;
          }
        }
        streamletPrototype = Object.getPrototypeOf(streamletPrototype);
      }
      return count;
    }
    static reflectInletIndex(index, streamlet, streamletPrototype) {
      while (streamletPrototype !== null) {
        if (Object.prototype.hasOwnProperty.call(streamletPrototype, "inlets")) {
          for (const name in streamletPrototype.inlets) {
            if (index === 0) {
              const inletDescriptor = streamletPrototype.inlets[name];
              if (inletDescriptor instanceof InletDescriptor) {
                return [ inletDescriptor.name, AbstractStreamlet.reflectInletField(streamlet, inletDescriptor) ];
              } else if (inletDescriptor instanceof InoutletDescriptor) {
                return [ inletDescriptor.name, AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor) ];
              } else {
                return null;
              }
            }
            index -= 1;
          }
        }
        streamletPrototype = Object.getPrototypeOf(streamletPrototype);
      }
      return null;
    }
    static reflectOutletIndex(index, streamlet, streamletPrototype) {
      while (streamletPrototype !== null) {
        if (Object.prototype.hasOwnProperty.call(streamletPrototype, "outlets")) {
          for (const name in streamletPrototype.outlets) {
            if (index === 0) {
              const outletDescriptor = streamletPrototype.outlets[name];
              if (outletDescriptor instanceof OutletDescriptor) {
                return [ outletDescriptor.name, AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor) ];
              } else if (outletDescriptor instanceof InoutletDescriptor) {
                return [ outletDescriptor.name, AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor) ];
              } else {
                return null;
              }
            }
            index -= 1;
          }
        }
        streamletPrototype = Object.getPrototypeOf(streamletPrototype);
      }
      return null;
    }
    static reflectInletKey(key, streamlet, streamletPrototype) {
      while (streamletPrototype !== null) {
        if (Object.prototype.hasOwnProperty.call(streamletPrototype, "inlets")) {
          const inletDescriptor = streamletPrototype.inlets[key];
          if (inletDescriptor !== void 0) {
            if (inletDescriptor instanceof InletDescriptor) {
              return AbstractStreamlet.reflectInletField(streamlet, inletDescriptor);
            } else if (inletDescriptor instanceof InoutletDescriptor) {
              return AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor);
            } else {
              return null;
            }
          }
        }
        streamletPrototype = Object.getPrototypeOf(streamletPrototype);
      }
      return null;
    }
    static reflectOutletKey(key, streamlet, streamletPrototype) {
      while (streamletPrototype !== null) {
        if (Object.prototype.hasOwnProperty.call(streamletPrototype, "outlets")) {
          const outletDescriptor = streamletPrototype.outlets[key];
          if (outletDescriptor !== void 0) {
            if (outletDescriptor instanceof OutletDescriptor) {
              return AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);
            } else if (outletDescriptor instanceof InoutletDescriptor) {
              return AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);
            } else {
              return null;
            }
          }
        }
        streamletPrototype = Object.getPrototypeOf(streamletPrototype);
      }
      return null;
    }
    static reflectInletField(streamlet, inletDescriptor) {
      if (inletDescriptor.type === "value") {
        return AbstractStreamlet.reflectValueInletField(streamlet, inletDescriptor.key);
      } else if (inletDescriptor.type === "map") {
        return AbstractStreamlet.reflectMapInletField(streamlet, inletDescriptor.key);
      } else {
        throw new TypeError(inletDescriptor.type);
      }
    }
    static reflectValueInletField(streamlet, key) {
      let inlet = streamlet[key];
      if (inlet === void 0) {
        if (streamlet instanceof AbstractStreamlet) {
          inlet = streamlet.inlet();
        } else {
          inlet = new StreamletInlet(streamlet);
        }
        streamlet[key] = inlet;
      }
      return inlet;
    }
    static reflectMapInletField(streamlet, key) {
      return null;
    }
    static reflectOutletField(streamlet, outletDescriptor) {
      if (outletDescriptor.type === "value") {
        return AbstractStreamlet.reflectValueOutletField(streamlet, outletDescriptor.key);
      } else if (outletDescriptor.type === "map") {
        return AbstractStreamlet.reflectMapOutletField(streamlet, outletDescriptor.key);
      } else {
        throw new TypeError(outletDescriptor.type);
      }
    }
    static reflectValueOutletField(streamlet, key) {
      let outlet = streamlet[key];
      if (outlet === void 0) {
        if (streamlet instanceof AbstractStreamlet) {
          outlet = streamlet.outlet();
        } else {
          outlet = new StreamletOutlet(streamlet);
        }
        streamlet[key] = outlet;
      }
      return outlet;
    }
    static reflectMapOutletField(streamlet, key) {
      return null;
    }
    static reflectInoutletField(streamlet, inoutletDescriptor) {
      if (inoutletDescriptor.type === "value") {
        return AbstractStreamlet.reflectValueInoutletField(streamlet, inoutletDescriptor.key);
      } else if (inoutletDescriptor.type === "map") {
        return AbstractStreamlet.reflectMapInoutletField(streamlet, inoutletDescriptor.key);
      } else {
        throw new TypeError(inoutletDescriptor.type);
      }
    }
    static reflectValueInoutletField(streamlet, key) {
      let inoutlet = streamlet[key];
      if (inoutlet === void 0) {
        if (streamlet instanceof AbstractStreamlet) {
          inoutlet = streamlet.inoutlet();
        } else {
          inoutlet = new StreamletInoutlet(streamlet);
        }
        streamlet[key] = inoutlet;
      }
      return inoutlet;
    }
    static reflectMapInoutletField(streamlet, key) {
      return null;
    }
    static init(streamletPrototype) {
      if (!Object.prototype.hasOwnProperty.call(streamletPrototype, "inlets")) {
        streamletPrototype.inlets = {};
      }
      if (!Object.prototype.hasOwnProperty.call(streamletPrototype, "outlets")) {
        streamletPrototype.outlets = {};
      }
      if (!Object.prototype.hasOwnProperty.call(streamletPrototype, "inoutlets")) {
        streamletPrototype.inoutlets = {};
      }
    }
    static decorateInlet(options, target, propertyKey) {
      AbstractStreamlet.init(target);
      const name = options.name !== void 0 ? options.name : propertyKey.toString();
      const type = options.type !== void 0 ? options.type : "value";
      const inletDescriptor = new InletDescriptor(propertyKey.toString(), name, type);
      target.inlets[name] = inletDescriptor;
    }
    static decorateOutlet(options, target, propertyKey) {
      AbstractStreamlet.init(target);
      const name = options.name !== void 0 ? options.name : propertyKey.toString();
      const type = options.type !== void 0 ? options.type : "value";
      const outletDescriptor = new OutletDescriptor(propertyKey.toString(), name, type);
      target.outlets[name] = outletDescriptor;
    }
    static decorateInoutlet(options, target, propertyKey) {
      AbstractStreamlet.init(target);
      const name = options.name !== void 0 ? options.name : propertyKey.toString();
      const type = options.type !== void 0 ? options.type : "value";
      const inoutletDescriptor = new InoutletDescriptor(propertyKey.toString(), name, type);
      target.inlets[name] = inoutletDescriptor;
      target.outlets[name] = inoutletDescriptor;
      target.inoutlets[name] = inoutletDescriptor;
    }
  }
  function In(target, key) {
    if (arguments.length === 1) {
      if (typeof target === "string") {
        target = {
          name: target
        };
      }
      return AbstractStreamlet.decorateInlet.bind(void 0, target);
    } else {
      AbstractStreamlet.decorateInlet({}, target, key);
    }
  }
  function Out(target, key) {
    if (arguments.length === 1) {
      if (typeof target === "string") {
        target = {
          name: target
        };
      }
      return AbstractStreamlet.decorateOutlet.bind(void 0, target);
    } else {
      AbstractStreamlet.decorateOutlet({}, target, key);
    }
  }
  function Inout(target, key) {
    if (arguments.length === 1) {
      if (typeof target === "string") {
        target = {
          name: target
        };
      }
      return AbstractStreamlet.decorateInoutlet.bind(void 0, target);
    } else {
      AbstractStreamlet.decorateInoutlet({}, target, key);
    }
  }
  const RecordOutlet = function() {
    const RecordOutlet = {};
    RecordOutlet.is = function(object) {
      if (typeof object === "object" && object !== null) {
        const outlet = object;
        return MapOutlet.is(outlet) && StreamletScope.is(outlet);
      }
      return false;
    };
    return RecordOutlet;
  }();
  class AbstractRecordOutlet extends Record {
    constructor() {
      super();
      this.effects = new BTree;
      this.outlets = new BTree;
      this.outputs = Arrays.empty;
      this.version = -1;
    }
    get streamletContext() {
      const scope = this.streamletScope;
      if (scope !== null) {
        return scope.streamletContext;
      }
      return null;
    }
    hasOwn(key) {
      return this.has(key);
    }
    get(key) {
      if (key === void 0) {
        return this;
      } else {
        return super.get(key);
      }
    }
    outlet(key) {
      if (typeof key === "string") {
        key = Text.from(key);
      }
      if (!this.hasOwn(key)) {
        const scope = this.streamletScope;
        if (RecordOutlet.is(scope) && scope.has(key)) {
          return scope.outlet(key);
        }
      }
      const oldOutlets = this.outlets;
      let outlet = oldOutlets.get(key);
      if (outlet === void 0) {
        outlet = new KeyOutlet(this, key);
        this.outlets = oldOutlets.updated(key, outlet);
        this.decohereInputKey(key, 0);
      }
      return outlet;
    }
    outputIterator() {
      return Cursor.array(this.outputs);
    }
    bindOutput(output) {
      this.outputs = Arrays.inserted(output, this.outputs);
    }
    unbindOutput(output) {
      this.outputs = Arrays.removed(output, this.outputs);
    }
    unbindOutputs() {
      const oldOutlets = this.outlets;
      if (oldOutlets.isEmpty()) {
        this.outlets = new BTree;
        oldOutlets.forEach((function(key, keyOutlet) {
          keyOutlet.unbindOutputs();
        }), this);
      }
      const oldOutputs = this.outputs;
      this.outputs = Arrays.empty;
      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {
        const output = oldOutputs[i];
        output.unbindInput();
      }
    }
    disconnectOutputs() {
      const oldOutlets = this.outlets;
      if (oldOutlets.isEmpty()) {
        this.outlets = new BTree;
        oldOutlets.forEach((function(key, keyOutlet) {
          keyOutlet.disconnectOutputs();
        }), this);
      }
      const oldOutputs = this.outputs;
      this.outputs = Arrays.empty;
      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {
        const output = oldOutputs[i];
        output.unbindInput();
        output.disconnectOutputs();
      }
      this.forEach((function(member) {
        if (member instanceof Field) {
          member = member.toValue();
        }
        if (member instanceof AbstractRecordOutlet) {
          member.disconnectOutputs();
        } else if (member instanceof RecordStreamlet) {
          member.disconnectOutputs();
        } else if (RecordOutlet.is(member)) {
          member.disconnectOutputs();
        }
      }), this);
    }
    disconnectInputs() {}
    decohereInputKey(key, effect) {
      const oldEffects = this.effects;
      if (oldEffects.get(key) !== effect) {
        this.willDecohereInputKey(key, effect);
        this.effects = oldEffects.updated(key, effect);
        this.version = -1;
        this.onDecohereInputKey(key, effect);
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          const output = outputs[i];
          if (MapInlet.is(output)) {
            output.decohereOutputKey(key, effect);
          } else {
            output.decohereOutput();
          }
        }
        const outlet = this.outlets.get(key);
        if (outlet !== void 0) {
          outlet.decohereInput();
        }
        this.didDecohereInputKey(key, effect);
      }
    }
    decohereInput() {
      if (this.version >= 0) {
        this.willDecohereInput();
        this.version = -1;
        this.onDecohereInput();
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          const output = outputs[i];
          output.decohereOutput();
        }
        this.outlets.forEach((function(key, outlet) {
          outlet.decohereInput();
        }), this);
        this.didDecohereInput();
      }
    }
    recohereInputKey(key, version) {
      if (this.version < 0) {
        const oldEffects = this.effects;
        const effect = oldEffects.get(key);
        if (effect !== void 0) {
          this.willRecohereInputKey(key, effect, version);
          this.effects = oldEffects.removed(key);
          this.onRecohereInputKey(key, effect, version);
          const outputs = this.outputs;
          for (let i = 0, n = outputs.length; i < n; i += 1) {
            const output = outputs[i];
            if (MapInlet.is(output)) {
              output.recohereOutputKey(key, version);
            }
          }
          const outlet = this.outlets.get(key);
          if (outlet !== void 0) {
            outlet.recohereInput(version);
          }
          this.didRecohereInputKey(key, effect, version);
        }
      }
    }
    recohereInput(version) {
      if (this.version < 0) {
        this.willRecohereInput(version);
        this.effects.forEach((function(key) {
          this.recohereInputKey(key, version);
        }), this);
        this.version = version;
        this.onRecohereInput(version);
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          const output = outputs[i];
          output.recohereOutput(version);
        }
        this.forEach((function(member) {
          if (member instanceof Field) {
            member = member.toValue();
          }
          if (member instanceof AbstractRecordOutlet) {
            member.recohereInput(version);
          } else if (member instanceof RecordStreamlet) {
            member.recohere(version);
          } else if (RecordOutlet.is(member)) {
            member.recohereInput(version);
          }
        }), this);
        this.didRecohereInput(version);
      }
    }
    willDecohereInputKey(key, effect) {}
    onDecohereInputKey(key, effect) {}
    didDecohereInputKey(key, effect) {}
    willDecohereInput() {}
    onDecohereInput() {}
    didDecohereInput() {}
    willRecohereInputKey(key, effect, version) {}
    onRecohereInputKey(key, effect, version) {}
    didRecohereInputKey(key, effect, version) {}
    willRecohereInput(version) {}
    onRecohereInput(version) {}
    didRecohereInput(version) {}
    filter(func) {
      if (typeof func !== "function") {
        return super.filter(func);
      } else {
        const combinator = new FilterFieldsCombinator(func);
        combinator.bindInput(this);
        return combinator;
      }
    }
  }
  Object.defineProperty(AbstractRecordOutlet.prototype, "streamletScope", {
    get() {
      return null;
    },
    configurable: true
  });
  MapOutletCombinators.define(AbstractRecordOutlet.prototype);
  class RecordStreamlet extends Record {
    isConstant() {
      return false;
    }
    compile() {
      AbstractStreamlet.reflectEachInlet(this, Object.getPrototypeOf(this), (function(inlet, name) {
        if (inlet.input === null) {
          this.compileInlet(inlet, name);
        }
      }), this);
    }
    compileInlet(inlet, name) {
      const scope = this.streamletScope;
      if (scope !== null) {
        const input = scope.outlet(name);
        if (input !== null) {
          inlet.bindInput(input);
        }
      }
    }
  }
  class AbstractRecordStreamlet extends RecordStreamlet {
    constructor(scope = null) {
      super();
      this.streamletScope = scope;
      this.streamletContext = null;
      this.version = -1;
    }
    setStreamletScope(scope) {
      this.streamletScope = scope;
    }
    setStreamletContext(context) {
      this.streamletContext = context;
    }
    isEmpty() {
      return this.length !== 0;
    }
    get length() {
      return AbstractStreamlet.reflectOutletCount(Object.getPrototypeOf(this));
    }
    has(key) {
      if (key instanceof Text) {
        key = key.value;
      } else if (typeof key !== "string") {
        return false;
      }
      const outlet = this.outlet(key);
      return outlet !== null;
    }
    get(key) {
      if (key instanceof Text) {
        key = key.value;
      } else if (typeof key !== "string") {
        return Value.absent();
      }
      const outlet = this.outlet(key);
      if (outlet !== null) {
        const output = outlet.get();
        if (output !== void 0) {
          return output;
        }
      }
      return Value.absent();
    }
    getAttr(key) {
      return Value.absent();
    }
    getSlot(key) {
      return this.get(key);
    }
    getField(key) {
      if (typeof key === "string") {
        key = Text.from(key);
      } else if (!(key instanceof Text)) {
        return void 0;
      }
      const value = this.get(key);
      if (value.isDefined()) {
        return Slot.of(key, value);
      }
      return void 0;
    }
    getItem(index) {
      if (index instanceof Num) {
        index = index.value;
      }
      const entry = AbstractStreamlet.reflectOutletIndex(index, this, Object.getPrototypeOf(this));
      if (entry !== null) {
        const name = entry[0];
        let output = entry[1].get();
        if (output === void 0) {
          output = Value.extant();
        }
        return Slot.of(name, output);
      }
      return Item.absent();
    }
    set(key, newValue) {
      throw new Error("unsupported");
    }
    setAttr(key, newValue) {
      throw new Error("unsupported");
    }
    setSlot(key, newValue) {
      throw new Error("unsupported");
    }
    setItem(index, item) {
      throw new Error("unsupported");
    }
    push(...items) {
      throw new Error("unsupported");
    }
    splice(start, deleteCount, ...newItems) {
      throw new Error("unsupported");
    }
    delete(key) {
      throw new Error("unsupported");
    }
    clear() {
      throw new Error("unsupported");
    }
    forEach(callback, thisArg) {
      return AbstractStreamlet.reflectEachOutlet(this, Object.getPrototypeOf(this), (function(outlet, name, index) {
        const output = outlet.get();
        if (output !== void 0) {
          const result = callback.call(thisArg, output, index);
          if (result !== void 0) {
            return result;
          }
        }
      }), this);
    }
    inlet(key) {
      if (key === void 0) {
        return new StreamletInlet(this);
      } else {
        return AbstractStreamlet.reflectInletKey(key, this, Object.getPrototypeOf(this));
      }
    }
    bindInput(key, input) {
      const inlet = this.inlet(key);
      if (inlet === null) {
        throw new Error(key);
      }
      inlet.bindInput(input);
    }
    unbindInput(key) {
      const inlet = this.inlet(key);
      if (inlet === null) {
        throw new Error(key);
      }
      inlet.unbindInput();
    }
    outlet(key) {
      if (key === void 0) {
        return new StreamletOutlet(this);
      } else if (typeof key === "string") {
        return AbstractStreamlet.reflectOutletKey(key, this, Object.getPrototypeOf(this));
      } else {
        return key;
      }
    }
    inoutlet() {
      return new StreamletInoutlet(this);
    }
    decohere() {
      if (this.version >= 0) {
        this.willDecohere();
        this.version = -1;
        this.onDecohere();
        this.onDecohereOutlets();
        this.didDecohere();
      }
    }
    recohere(version) {
      if (this.version < 0) {
        this.willRecohere(version);
        this.version = version;
        this.onRecohereInlets(version);
        this.onRecohere(version);
        this.onRecohereOutlets(version);
        this.didRecohere(version);
      }
    }
    getInput(inlet, orElse) {
      if (typeof inlet === "string") {
        inlet = this.inlet(inlet);
      }
      let object;
      if (inlet !== null) {
        const input = inlet.input;
        if (input !== null) {
          object = input.get();
        }
      }
      if (object === void 0) {
        object = orElse;
      }
      return object;
    }
    castInput(inlet, form, orElse) {
      const input = this.getInput(inlet);
      let object;
      if (input !== void 0) {
        object = form.cast(input);
      }
      if (object === void 0) {
        object = orElse;
      }
      return object;
    }
    coerceInput(inlet, form, orElse) {
      const input = this.getInput(inlet);
      let object;
      if (input !== void 0) {
        object = form.cast(input);
      }
      if (object === void 0) {
        object = form.unit;
      }
      if (object === void 0) {
        object = orElse;
      }
      return object;
    }
    getOutput(outlet) {
      return void 0;
    }
    disconnectInputs() {
      AbstractStreamlet.disconnectInputs(this, Object.getPrototypeOf(this));
    }
    disconnectOutputs() {
      AbstractStreamlet.disconnectOutputs(this, Object.getPrototypeOf(this));
    }
    willDecohereInlet(inlet) {}
    didDecohereInlet(inlet) {
      this.decohere();
    }
    willRecohereInlet(inlet, version) {}
    didRecohereInlet(inlet, version) {
      this.recohere(version);
    }
    willDecohereOutlet(outlet) {}
    didDecohereOutlet(outlet) {}
    willRecohereOutlet(outlet, version) {}
    didRecohereOutlet(outlet, version) {}
    willDecohere() {}
    onDecohere() {}
    didDecohere() {}
    onDecohereOutlets() {
      AbstractStreamlet.decohereOutlets(this, Object.getPrototypeOf(this));
    }
    willRecohere(version) {}
    onRecohereInlets(version) {
      AbstractStreamlet.recohereInlets(version, this, Object.getPrototypeOf(this));
    }
    onRecohere(version) {}
    onRecohereOutlets(version) {
      AbstractStreamlet.recohereOutlets(version, this, Object.getPrototypeOf(this));
    }
    didRecohere(version) {}
  }
  class RecordFieldUpdater extends AbstractInlet {
    constructor(record, key) {
      super();
      this.record = record;
      this.key = key;
    }
    onDecohereOutput() {
      const record = this.record;
      if (RecordOutlet.is(record)) {
        record.decohereInputKey(this.key, 0);
      }
    }
    onRecohereOutput(version) {
      const input = this.input;
      if (input !== null) {
        const value = input.get();
        if (value !== void 0) {
          this.record.set(this.key, value);
        } else {
          this.record.delete(this.key);
        }
      }
    }
  }
  class RecordModel extends AbstractRecordOutlet {
    constructor(state) {
      super();
      if (state === void 0) {
        state = Record.create();
      }
      this.state = state;
      this.fieldUpdaters = new BTree;
    }
    isEmpty() {
      return this.state.isEmpty();
    }
    isArray() {
      return this.state.isArray();
    }
    isObject() {
      return this.state.isObject();
    }
    get length() {
      return this.state.length;
    }
    get valueCount() {
      return this.state.valueCount;
    }
    has(key) {
      if (this.state.has(key)) {
        return true;
      } else {
        const scope = this.streamletScope;
        return scope instanceof Record ? scope.has(key) : false;
      }
    }
    hasOwn(key) {
      return this.state.has(key);
    }
    indexOf(item, index) {
      return this.state.indexOf(item, index);
    }
    lastIndexOf(item, index = 0) {
      return this.state.lastIndexOf(item, index);
    }
    get(key) {
      if (key === void 0) {
        return this;
      } else {
        key = Value.fromAny(key);
        let value = this.state.get(key);
        if (!value.isDefined()) {
          const scope = this.streamletScope;
          if (scope instanceof Record) {
            value = scope.get(key);
          }
        }
        return value;
      }
    }
    getAttr(key) {
      key = Text.fromAny(key);
      let value = this.state.getAttr(key);
      if (!value.isDefined()) {
        const scope = this.streamletScope;
        if (scope instanceof Record) {
          value = scope.getAttr(key);
        }
      }
      return value;
    }
    getSlot(key) {
      key = Value.fromAny(key);
      let value = this.state.getSlot(key);
      if (!value.isDefined()) {
        const scope = this.streamletScope;
        if (scope instanceof Record) {
          value = scope.getSlot(key);
        }
      }
      return value;
    }
    getField(key) {
      key = Value.fromAny(key);
      let field = this.state.getField(key);
      if (field === void 0) {
        const scope = this.streamletScope;
        if (scope instanceof Record) {
          field = scope.getField(key);
        }
      }
      return field;
    }
    getItem(index) {
      return this.state.getItem(index);
    }
    bindValue(key, expr) {
      const fieldUpdater = new RecordFieldUpdater(this, key);
      const valueInput = Dataflow.compile(expr, this);
      fieldUpdater.bindInput(valueInput);
      this.fieldUpdaters = this.fieldUpdaters.updated(key, fieldUpdater);
    }
    set(key, newValue) {
      key = Value.fromAny(key);
      if (!this.state.has(key)) {
        const scope = this.streamletScope;
        if (scope instanceof Record && scope.has(key)) {
          scope.set(key, newValue);
        } else {
          this.state.set(key, newValue);
        }
      } else {
        this.state.set(key, newValue);
      }
      this.decohereInputKey(key, 0);
      return this;
    }
    setAttr(key, newValue) {
      key = Text.fromAny(key);
      if (!this.state.has(key)) {
        const scope = this.streamletScope;
        if (scope instanceof Record && scope.has(key)) {
          scope.setAttr(key, newValue);
        } else {
          this.state.setAttr(key, newValue);
        }
      } else {
        this.state.setAttr(key, newValue);
      }
      this.decohereInputKey(key, 0);
      return this;
    }
    setSlot(key, newValue) {
      key = Value.fromAny(key);
      if (!this.state.has(key)) {
        const scope = this.streamletScope;
        if (scope instanceof Record && scope.has(key)) {
          scope.setSlot(key, newValue);
        } else {
          this.state.setSlot(key, newValue);
        }
      } else {
        this.state.setSlot(key, newValue);
      }
      this.decohereInputKey(key, 0);
      return this;
    }
    setItem(index, newItem) {
      const oldItem = this.state.getItem(index);
      newItem = Item.fromAny(newItem);
      this.state.setItem(index, newItem);
      if (oldItem instanceof Field && newItem instanceof Field) {
        if (oldItem.key.equals(newItem.key)) {
          this.decohereInputKey(oldItem.key, 0);
        } else {
          this.decohereInputKey(oldItem.key, 1);
          this.decohereInputKey(newItem.key, 0);
        }
      } else if (oldItem instanceof Field) {
        this.decohereInputKey(oldItem.key, 1);
      } else if (newItem instanceof Field) {
        this.decohereInputKey(newItem.key, 0);
      } else {
        this.decohereInput();
      }
      return this;
    }
    push(...newItems) {
      let i = this.state.length;
      const n = this.state.push(...newItems);
      while (i < n) {
        const newItem = this.state.get(i);
        if (newItem instanceof Field) {
          this.decohereInputKey(newItem.key, 0);
        }
        i += 1;
      }
      return n;
    }
    splice(start, deleteCount = 0, ...newItems) {
      const n = this.state.length;
      if (start < 0) {
        start = n + start;
      }
      start = Math.max(0, start);
      deleteCount = Math.max(0, deleteCount);
      const deleted = this.state.splice(start, deleteCount, ...newItems);
      for (let i = 0; i < deleted.length; i += 1) {
        const oldItem = deleted[i];
        if (oldItem instanceof Field) {
          this.decohereInputKey(oldItem.key, 1);
        }
      }
      for (let i = start; i < start + newItems.length; i += 1) {
        const newItem = this.state.get(i);
        if (newItem instanceof Field) {
          this.decohereInputKey(newItem.key, 0);
        }
      }
      return deleted;
    }
    delete(key) {
      const oldItem = this.state.delete(key);
      if (oldItem instanceof Field) {
        this.decohereInputKey(oldItem.key, 1);
      }
      return oldItem;
    }
    clear() {
      const oldState = this.state.branch();
      this.state.clear();
      oldState.forEach((function(oldItem) {
        if (oldItem instanceof Field) {
          this.decohereInputKey(oldItem.key, 1);
        }
      }), this);
    }
    forEach(callback, thisArg) {
      return this.state.forEach(callback, thisArg);
    }
    keyIterator() {
      throw new Error;
    }
    disconnectInputs() {
      const oldFieldUpdaters = this.fieldUpdaters;
      if (!oldFieldUpdaters.isEmpty()) {
        this.fieldUpdaters = new BTree;
        oldFieldUpdaters.forEach((function(key, inlet) {
          inlet.disconnectInputs();
        }), this);
      }
    }
    memoize() {
      return this;
    }
    materialize(record) {
      record.forEach((function(item) {
        this.materializeItem(item);
      }), this);
    }
    materializeItem(item) {
      if (item instanceof Field) {
        this.materializeField(item);
      } else {
        this.materializeValue(item);
      }
    }
    materializeField(field) {
      const value = field.value;
      if (value instanceof RecordStreamlet) {
        value.setStreamletScope(this);
        this.state.push(field);
      } else if (value instanceof Record) {
        const child = new RecordScope(this);
        child.materialize(value);
        this.state.push(field.updatedValue(child));
      } else {
        this.state.push(field);
      }
    }
    materializeValue(value) {
      if (value instanceof RecordStreamlet) {
        value.setStreamletScope(this);
        this.state.push(value);
      } else if (value instanceof Record) {
        const child = new RecordScope(this);
        child.materialize(value);
        this.state.push(child);
      } else {
        this.state.push(value);
      }
    }
    compile(record) {
      record.forEach((function(item, index) {
        this.compileItem(item, index);
      }), this);
    }
    compileItem(item, index) {
      if (item instanceof Field) {
        this.compileField(item, index);
      } else {
        this.compileValue(item, index);
      }
    }
    compileField(field, index) {
      const key = field.key;
      const value = field.value;
      if (!key.isConstant()) ; else if (!value.isConstant()) {
        if (value instanceof RecordStreamlet) {
          value.compile();
          this.decohereInputKey(key, 0);
        } else if (value instanceof Record) {
          this.state.getItem(index).toValue().compile(value);
          this.decohereInputKey(key, 0);
        } else {
          field.setValue(Value.extant());
          this.bindValue(key, value);
        }
      } else {
        this.decohereInputKey(key, 0);
      }
    }
    compileValue(value, index) {
      if (value instanceof RecordStreamlet) {
        value.compile();
      } else if (value instanceof Record) {
        this.state.getItem(index).compile(value);
      } else if (!value.isConstant()) ; else ;
    }
    reify(reifier = Reifier.system()) {
      this.forEach((function(oldItem, index) {
        const newItem = this.reifyItem(oldItem, reifier);
        if (oldItem !== newItem) {
          this.setItem(index, newItem);
        }
      }), this);
    }
    reifyItem(item, reifier) {
      if (reifier !== null) {
        item = reifier.reify(item);
      }
      const scope = this.streamletScope;
      if (scope instanceof RecordModel) {
        return scope.reifyItem(item, reifier);
      } else {
        return item;
      }
    }
    static from(record) {
      const model = new RecordModel;
      model.materialize(record);
      model.compile(record);
      return model;
    }
    static of(...items) {
      return RecordModel.from(Record.of(...items));
    }
    static globalScope() {
      const model = new RecordModel;
      model.materializeField(Slot.of("math", MathModule.scope.branch()));
      return model;
    }
  }
  Object.defineProperty(RecordModel.prototype, "fieldCount", {
    get() {
      return this.state.fieldCount;
    },
    configurable: true
  });
  class RecordScope extends RecordModel {
    constructor(scope, state) {
      super(state);
      Object.defineProperty(this, "streamletScope", {
        value: scope,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
    static from(record) {
      const scope = new RecordScope(RecordScope.globalScope());
      scope.materialize(record);
      scope.compile(record);
      return scope;
    }
    static of(...items) {
      return RecordScope.from(Record.of(...items));
    }
  }
  class Reifier {
    static system() {
      return null;
    }
  }
  class GetOutlet extends AbstractOutlet {
    constructor() {
      super();
      this.keyInlet = new OutletInlet(this);
      this.mapInlet = new OutletMapInlet(this);
    }
    get() {
      const keyInput = this.keyInlet.input;
      if (keyInput !== null) {
        const key = keyInput.get();
        if (key !== void 0) {
          const mapInput = this.mapInlet.input;
          if (mapInput !== null) {
            const value = mapInput.get(key);
            if (value !== void 0) {
              return value;
            }
          }
        }
      }
      return Value.absent();
    }
  }
  class BinaryOutlet extends AbstractOutlet {
    constructor() {
      super();
      this.operand1Inlet = new OutletInlet(this);
      this.operand2Inlet = new OutletInlet(this);
    }
    get() {
      const operand1Input = this.operand1Inlet.input;
      const operand2Input = this.operand2Inlet.input;
      if (operand1Input !== null && operand2Input !== null) {
        const argument1 = operand1Input.get();
        const argument2 = operand2Input.get();
        if (argument1 !== void 0 && argument2 !== void 0) {
          const result = this.evaluate(argument1, argument2);
          return result.toValue();
        }
      }
      return Value.absent();
    }
  }
  class UnaryOutlet extends AbstractOutlet {
    constructor() {
      super();
      this.operandInlet = new OutletInlet(this);
    }
    get() {
      const operandInput = this.operandInlet.input;
      if (operandInput !== null) {
        const argument = operandInput.get();
        if (argument !== void 0) {
          const result = this.evaluate(argument);
          return result.toValue();
        }
      }
      return Value.absent();
    }
  }
  class ConditionalOutlet extends AbstractOutlet {
    constructor() {
      super();
      this.ifInlet = new OutletInlet(this);
      this.thenInlet = new OutletInlet(this);
      this.elseInlet = new OutletInlet(this);
    }
    get() {
      const ifInput = this.ifInlet.input;
      if (ifInput !== null) {
        const ifTerm = ifInput.get();
        if (ifTerm !== void 0) {
          if (ifTerm.isDefinite()) {
            const thenInput = this.thenInlet.input;
            if (thenInput !== null) {
              const thenTerm = thenInput.get();
              if (thenTerm !== void 0) {
                return thenTerm;
              }
            }
          } else {
            const elseInput = this.elseInlet.input;
            if (elseInput !== null) {
              const elseTerm = elseInput.get();
              if (elseTerm !== void 0) {
                return elseTerm;
              }
            }
          }
        }
      }
      return Value.absent();
    }
  }
  class OrOutlet extends AbstractOutlet {
    constructor() {
      super();
      this.operand1Inlet = new OutletInlet(this);
      this.operand2Inlet = new OutletInlet(this);
    }
    get() {
      const operand1Input = this.operand1Inlet.input;
      const argument1 = operand1Input !== null ? operand1Input.get() : void 0;
      if (argument1 !== void 0 && argument1.isDefinite()) {
        return argument1;
      }
      const operand2Input = this.operand2Inlet.input;
      const argument2 = operand2Input !== null ? operand2Input.get() : void 0;
      if (argument2 !== void 0) {
        return argument2;
      }
      return Value.absent();
    }
  }
  class AndOutlet extends AbstractOutlet {
    constructor() {
      super();
      this.operand1Inlet = new OutletInlet(this);
      this.operand2Inlet = new OutletInlet(this);
    }
    get() {
      const operand1Input = this.operand1Inlet.input;
      const argument1 = operand1Input !== null ? operand1Input.get() : void 0;
      if (argument1 !== void 0) {
        if (argument1.isDefinite()) {
          const operand2Input = this.operand2Inlet.input;
          const argument2 = operand2Input !== null ? operand2Input.get() : void 0;
          if (argument2 !== void 0) {
            return argument2;
          }
        }
        return argument1;
      }
      return Value.absent();
    }
  }
  class BitwiseOrOutlet extends BinaryOutlet {
    evaluate(argument1, argument2) {
      return argument1.bitwiseOr(argument2);
    }
  }
  class BitwiseXorOutlet extends BinaryOutlet {
    evaluate(argument1, argument2) {
      return argument1.bitwiseXor(argument2);
    }
  }
  class BitwiseAndOutlet extends BinaryOutlet {
    evaluate(argument1, argument2) {
      return argument1.bitwiseAnd(argument2);
    }
  }
  class LtOutlet extends BinaryOutlet {
    evaluate(argument1, argument2) {
      return argument1.lt(argument2);
    }
  }
  class LeOutlet extends BinaryOutlet {
    evaluate(argument1, argument2) {
      return argument1.le(argument2);
    }
  }
  class EqOutlet extends BinaryOutlet {
    evaluate(argument1, argument2) {
      return argument1.eq(argument2);
    }
  }
  class NeOutlet extends BinaryOutlet {
    evaluate(argument1, argument2) {
      return argument1.ne(argument2);
    }
  }
  class GeOutlet extends BinaryOutlet {
    evaluate(argument1, argument2) {
      return argument1.ge(argument2);
    }
  }
  class GtOutlet extends BinaryOutlet {
    evaluate(argument1, argument2) {
      return argument1.gt(argument2);
    }
  }
  class PlusOutlet extends BinaryOutlet {
    evaluate(argument1, argument2) {
      return argument1.plus(argument2);
    }
  }
  class MinusOutlet extends BinaryOutlet {
    evaluate(argument1, argument2) {
      return argument1.minus(argument2);
    }
  }
  class TimesOutlet extends BinaryOutlet {
    evaluate(argument1, argument2) {
      return argument1.times(argument2);
    }
  }
  class DivideOutlet extends BinaryOutlet {
    evaluate(argument1, argument2) {
      return argument1.divide(argument2);
    }
  }
  class ModuloOutlet extends BinaryOutlet {
    evaluate(argument1, argument2) {
      return argument1.modulo(argument2);
    }
  }
  class NotOutlet extends UnaryOutlet {
    evaluate(argument) {
      return argument.not();
    }
  }
  class BitwiseNotOutlet extends UnaryOutlet {
    evaluate(argument) {
      return argument.bitwiseNot();
    }
  }
  class NegativeOutlet extends UnaryOutlet {
    evaluate(argument) {
      return argument.negative();
    }
  }
  class PositiveOutlet extends UnaryOutlet {
    evaluate(argument) {
      return argument.positive();
    }
  }
  class InvokeOutlet extends AbstractOutlet {
    constructor(scope) {
      super();
      this.scope = scope;
      this.funcInlet = new OutletInlet(this);
      this.argsInlet = new OutletInlet(this);
    }
    get() {
      const funcInput = this.funcInlet.input;
      const argsInput = this.argsInlet.input;
      if (funcInput !== null && argsInput !== null) {
        const func = funcInput.get();
        if (func instanceof Func) {
          const args = argsInput.get();
          if (args !== void 0) {
            const interpreter = new Interpreter;
            interpreter.pushScope(this.scope);
            const result = func.invoke(args, interpreter, void 0);
            return result.toValue();
          }
        }
      }
      return Value.absent();
    }
  }
  const Dataflow = function() {
    const Dataflow = {};
    Dataflow.compile = function(expr, scope) {
      if (scope instanceof KeyOutlet) {
        const value = scope.get();
        if (Outlet.is(value)) {
          scope = value;
        }
      }
      if (expr.isConstant()) {
        return new ValueInput(expr);
      } else if (expr instanceof Selector) {
        return Dataflow.compileSelector(expr, scope);
      } else if (expr instanceof Operator) {
        return Dataflow.compileOperator(expr, scope);
      }
      throw new TypeError("" + expr);
    };
    Dataflow.compileSelector = function(selector, scope) {
      if (selector instanceof IdentitySelector) {
        return Dataflow.compileIdentitySelector(scope);
      } else if (selector instanceof GetSelector) {
        return Dataflow.compileGetSelector(selector, scope);
      } else if (selector instanceof GetAttrSelector) {
        return Dataflow.compileGetAttrSelector(selector, scope);
      } else if (selector instanceof GetItemSelector) {
        return Dataflow.compileGetItemSelector(selector, scope);
      } else if (selector instanceof KeysSelector) {
        return Dataflow.compileKeysSelector(scope);
      } else if (selector instanceof ValuesSelector) {
        return Dataflow.compileValuesSelector(scope);
      } else if (selector instanceof ChildrenSelector) {
        return Dataflow.compileChildrenSelector(scope);
      } else if (selector instanceof DescendantsSelector) {
        return Dataflow.compileDescendantsSelector(scope);
      } else if (selector instanceof FilterSelector) {
        return Dataflow.compileFilterSelector(selector, scope);
      }
      throw new TypeError("" + selector);
    };
    Dataflow.compileIdentitySelector = function(scope) {
      return scope;
    };
    Dataflow.compileGetSelector = function(selector, scope) {
      const key = selector.item;
      if (key.isConstant()) {
        if (RecordOutlet.is(scope)) {
          const outlet = scope.outlet(key);
          if (outlet !== null) {
            return Dataflow.compile(selector.then, outlet);
          }
        } else if (StreamletScope.is(scope)) {
          const name = key.stringValue(void 0);
          if (name !== void 0) {
            const outlet = scope.outlet(name);
            if (outlet !== null) {
              return Dataflow.compile(selector.then, outlet);
            }
          }
        }
      } else {
        const getOutlet = new GetOutlet;
        const outlet = Dataflow.compile(key, scope);
        getOutlet.keyInlet.bindInput(outlet);
        getOutlet.mapInlet.bindInput(scope);
        return getOutlet;
      }
      return null;
    };
    Dataflow.compileGetAttrSelector = function(selector, scope) {
      throw new Error;
    };
    Dataflow.compileGetItemSelector = function(selector, scope) {
      throw new Error;
    };
    Dataflow.compileKeysSelector = function(scope) {
      throw new Error;
    };
    Dataflow.compileValuesSelector = function(scope) {
      throw new Error;
    };
    Dataflow.compileChildrenSelector = function(scope) {
      throw new Error;
    };
    Dataflow.compileDescendantsSelector = function(scope) {
      throw new Error;
    };
    Dataflow.compileFilterSelector = function(selector, scope) {
      throw new Error;
    };
    Dataflow.compileOperator = function(operator, scope) {
      if (operator instanceof ConditionalOperator) {
        return Dataflow.compileConditionalOperator(operator, scope);
      } else if (operator instanceof BinaryOperator) {
        return Dataflow.compileBinaryOperator(operator, scope);
      } else if (operator instanceof UnaryOperator) {
        return Dataflow.compileUnaryOperator(operator, scope);
      } else if (operator instanceof InvokeOperator) {
        return Dataflow.compileInvokeOperator(operator, scope);
      }
      throw new TypeError("" + operator);
    };
    Dataflow.compileConditionalOperator = function(operator, scope) {
      const outlet = new ConditionalOutlet;
      const ifTerm = operator.ifTerm.toValue();
      const thenTerm = operator.thenTerm.toValue();
      const elseTerm = operator.elseTerm.toValue();
      const ifOutlet = Dataflow.compile(ifTerm, scope);
      const thenOutlet = Dataflow.compile(thenTerm, scope);
      const elseOutlet = Dataflow.compile(elseTerm, scope);
      outlet.ifInlet.bindInput(ifOutlet);
      outlet.thenInlet.bindInput(thenOutlet);
      outlet.elseInlet.bindInput(elseOutlet);
      return outlet;
    };
    Dataflow.compileBinaryOperator = function(operator, scope) {
      if (operator instanceof OrOperator) {
        return Dataflow.compileOrOperator(operator, scope);
      } else if (operator instanceof AndOperator) {
        return Dataflow.compileAndOperator(operator, scope);
      } else if (operator instanceof BitwiseOrOperator) {
        return Dataflow.compileBitwiseOrOperator(operator, scope);
      } else if (operator instanceof BitwiseXorOperator) {
        return Dataflow.compileBitwiseXorOperator(operator, scope);
      } else if (operator instanceof BitwiseAndOperator) {
        return Dataflow.compileBitwiseAndOperator(operator, scope);
      } else if (operator instanceof LtOperator) {
        return Dataflow.compileLtOperator(operator, scope);
      } else if (operator instanceof LeOperator) {
        return Dataflow.compileLeOperator(operator, scope);
      } else if (operator instanceof EqOperator) {
        return Dataflow.compileEqOperator(operator, scope);
      } else if (operator instanceof NeOperator) {
        return Dataflow.compileNeOperator(operator, scope);
      } else if (operator instanceof GeOperator) {
        return Dataflow.compileGeOperator(operator, scope);
      } else if (operator instanceof GtOperator) {
        return Dataflow.compileGtOperator(operator, scope);
      } else if (operator instanceof PlusOperator) {
        return Dataflow.compilePlusOperator(operator, scope);
      } else if (operator instanceof MinusOperator) {
        return Dataflow.compileMinusOperator(operator, scope);
      } else if (operator instanceof TimesOperator) {
        return Dataflow.compileTimesOperator(operator, scope);
      } else if (operator instanceof DivideOperator) {
        return Dataflow.compileDivideOperator(operator, scope);
      } else if (operator instanceof ModuloOperator) {
        return Dataflow.compileModuloOperator(operator, scope);
      }
      throw new TypeError("" + operator);
    };
    Dataflow.compileBinaryOutlet = function(operator, outlet, scope) {
      const operand1 = operator.operand1.toValue();
      const operand2 = operator.operand2.toValue();
      const operand1Outlet = Dataflow.compile(operand1, scope);
      const operand2Outlet = Dataflow.compile(operand2, scope);
      outlet.operand1Inlet.bindInput(operand1Outlet);
      outlet.operand2Inlet.bindInput(operand2Outlet);
      return outlet;
    };
    Dataflow.compileOrOperator = function(operator, scope) {
      const outlet = new OrOutlet;
      const operand1 = operator.operand1.toValue();
      const operand2 = operator.operand2.toValue();
      const operand1Outlet = Dataflow.compile(operand1, scope);
      const operand2Outlet = Dataflow.compile(operand2, scope);
      outlet.operand1Inlet.bindInput(operand1Outlet);
      outlet.operand2Inlet.bindInput(operand2Outlet);
      return outlet;
    };
    Dataflow.compileAndOperator = function(operator, scope) {
      const outlet = new AndOutlet;
      const operand1 = operator.operand1.toValue();
      const operand2 = operator.operand2.toValue();
      const operand1Outlet = Dataflow.compile(operand1, scope);
      const operand2Outlet = Dataflow.compile(operand2, scope);
      outlet.operand1Inlet.bindInput(operand1Outlet);
      outlet.operand2Inlet.bindInput(operand2Outlet);
      return outlet;
    };
    Dataflow.compileBitwiseOrOperator = function(operator, scope) {
      return Dataflow.compileBinaryOutlet(operator, new BitwiseOrOutlet, scope);
    };
    Dataflow.compileBitwiseXorOperator = function(operator, scope) {
      return Dataflow.compileBinaryOutlet(operator, new BitwiseXorOutlet, scope);
    };
    Dataflow.compileBitwiseAndOperator = function(operator, scope) {
      return Dataflow.compileBinaryOutlet(operator, new BitwiseAndOutlet, scope);
    };
    Dataflow.compileLtOperator = function(operator, scope) {
      return Dataflow.compileBinaryOutlet(operator, new LtOutlet, scope);
    };
    Dataflow.compileLeOperator = function(operator, scope) {
      return Dataflow.compileBinaryOutlet(operator, new LeOutlet, scope);
    };
    Dataflow.compileEqOperator = function(operator, scope) {
      return Dataflow.compileBinaryOutlet(operator, new EqOutlet, scope);
    };
    Dataflow.compileNeOperator = function(operator, scope) {
      return Dataflow.compileBinaryOutlet(operator, new NeOutlet, scope);
    };
    Dataflow.compileGeOperator = function(operator, scope) {
      return Dataflow.compileBinaryOutlet(operator, new GeOutlet, scope);
    };
    Dataflow.compileGtOperator = function(operator, scope) {
      return Dataflow.compileBinaryOutlet(operator, new GtOutlet, scope);
    };
    Dataflow.compilePlusOperator = function(operator, scope) {
      return Dataflow.compileBinaryOutlet(operator, new PlusOutlet, scope);
    };
    Dataflow.compileMinusOperator = function(operator, scope) {
      return Dataflow.compileBinaryOutlet(operator, new MinusOutlet, scope);
    };
    Dataflow.compileTimesOperator = function(operator, scope) {
      return Dataflow.compileBinaryOutlet(operator, new TimesOutlet, scope);
    };
    Dataflow.compileDivideOperator = function(operator, scope) {
      return Dataflow.compileBinaryOutlet(operator, new DivideOutlet, scope);
    };
    Dataflow.compileModuloOperator = function(operator, scope) {
      return Dataflow.compileBinaryOutlet(operator, new ModuloOutlet, scope);
    };
    Dataflow.compileUnaryOperator = function(operator, scope) {
      if (operator instanceof NotOperator) {
        return Dataflow.compileNotOperator(operator, scope);
      } else if (operator instanceof BitwiseNotOperator) {
        return Dataflow.compileBitwiseNotOperator(operator, scope);
      } else if (operator instanceof NegativeOperator) {
        return Dataflow.compileNegativeOperator(operator, scope);
      } else if (operator instanceof PositiveOperator) {
        return Dataflow.compilePositiveOperator(operator, scope);
      }
      throw new TypeError("" + operator);
    };
    Dataflow.compileUnaryOutlet = function(operator, outlet, scope) {
      const operand = operator.operand.toValue();
      const operandOutlet = Dataflow.compile(operand, scope);
      outlet.operandInlet.bindInput(operandOutlet);
      return outlet;
    };
    Dataflow.compileNotOperator = function(operator, scope) {
      return Dataflow.compileUnaryOutlet(operator, new NotOutlet, scope);
    };
    Dataflow.compileBitwiseNotOperator = function(operator, scope) {
      return Dataflow.compileUnaryOutlet(operator, new BitwiseNotOutlet, scope);
    };
    Dataflow.compileNegativeOperator = function(operator, scope) {
      return Dataflow.compileUnaryOutlet(operator, new NegativeOutlet, scope);
    };
    Dataflow.compilePositiveOperator = function(operator, scope) {
      return Dataflow.compileUnaryOutlet(operator, new PositiveOutlet, scope);
    };
    Dataflow.compileInvokeOperator = function(operator, scope) {
      const func = operator.func;
      const args = operator.args;
      const invokeOutlet = new InvokeOutlet(scope);
      const funcOutlet = Dataflow.compile(func, scope);
      const argsOutlet = Dataflow.compile(args, scope);
      invokeOutlet.funcInlet.bindInput(funcOutlet);
      invokeOutlet.argsInlet.bindInput(argsOutlet);
      return invokeOutlet;
    };
    return Dataflow;
  }();
  const Recon = function() {
    const Recon = {};
    Object.defineProperty(Recon, "structureParser", {
      value: function() {
        const structureParser = new ReconStructureParser;
        Object.defineProperty(Recon, "structureParser", {
          value: function() {
            return structureParser;
          },
          enumerable: true,
          configurable: true
        });
        return structureParser;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Recon, "structureWriter", {
      value: function() {
        const structureWriter = new ReconStructureWriter;
        Object.defineProperty(Recon, "structureWriter", {
          value: function() {
            return structureWriter;
          },
          enumerable: true,
          configurable: true
        });
        return structureWriter;
      },
      enumerable: true,
      configurable: true
    });
    Recon.parse = function(recon) {
      return Recon.structureParser().parseBlockString(recon);
    };
    Recon.parser = function() {
      return Recon.structureParser().blockParser();
    };
    Recon.sizeOf = function(item) {
      return Recon.structureWriter().sizeOfItem(item);
    };
    Recon.sizeOfBlock = function(item) {
      return Recon.structureWriter().sizeOfBlockItem(item);
    };
    Recon.write = function(output, item) {
      return Recon.structureWriter().writeItem(output, item);
    };
    Recon.writeBlock = function(output, item) {
      return Recon.structureWriter().writeBlockItem(output, item);
    };
    Recon.toString = function(item) {
      let output = Unicode.stringOutput();
      const writer = Recon.write(output, item);
      if (!writer.isDone()) {
        output = Output.error(writer.trap());
      }
      return output.bind();
    };
    Recon.toBlockString = function(item) {
      let output = Unicode.stringOutput();
      const writer = Recon.writeBlock(output, item);
      if (!writer.isDone()) {
        output = Output.error(writer.trap());
      }
      return output.bind();
    };
    Recon.toData = function(item) {
      let output = Utf8.encodedOutput(Data.output());
      const writer = Recon.write(output, item);
      if (!writer.isDone()) {
        output = Output.error(writer.trap());
      }
      return output.bind();
    };
    Recon.toBlockData = function(item) {
      let output = Utf8.encodedOutput(Data.output());
      const writer = Recon.writeBlock(output, item);
      if (!writer.isDone()) {
        output = Output.error(writer.trap());
      }
      return output.bind();
    };
    Recon.isSpace = function(c) {
      return c === 32 || c === 9;
    };
    Recon.isNewline = function(c) {
      return c === 10 || c === 13;
    };
    Recon.isWhitespace = function(c) {
      return Recon.isSpace(c) || Recon.isNewline(c);
    };
    Recon.isIdentStartChar = function(c) {
      return c >= 65 && c <= 90 || c === 95 || c >= 97 && c <= 122 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 767 || c >= 880 && c <= 893 || c >= 895 && c <= 8191 || c >= 8204 && c <= 8205 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
    };
    Recon.isIdentChar = function(c) {
      return c === 45 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c === 95 || c >= 97 && c <= 122 || c === 183 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 893 || c >= 895 && c <= 8191 || c >= 8204 && c <= 8205 || c >= 8255 && c <= 8256 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
    };
    Item.prototype.toRecon = function() {
      return Recon.toString(this);
    };
    Item.prototype.toReconBlock = function() {
      return Recon.toBlockString(this);
    };
    return Recon;
  }();
  Value.parseRecon = function(recon) {
    return Recon.parse(recon);
  };
  class BlockParser extends Parser {
    constructor(recon, builder, keyParser, valueParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.keyParser = keyParser;
      this.valueParser = valueParser;
      this.step = step;
    }
    feed(input) {
      return BlockParser.parse(input, this.recon, this.builder, this.keyParser, this.valueParser, this.step);
    }
    static parse(input, recon, builder, keyParser, valueParser, step = 1) {
      let c = 0;
      block: do {
        if (step === 1) {
          while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
            input = input.step();
          }
          if (input.isCont()) {
            if (c === 33 || c === 34 || c === 36 || c === 37 || c === 39 || c === 40 || c === 43 || c === 45 || c >= 48 && c <= 57 || c === 64 || c === 91 || c === 96 || c === 123 || c === 126 || Recon.isIdentStartChar(c)) {
              builder = builder || recon.valueBuilder();
              step = 2;
            } else if (c === 35) {
              input = input.step();
              step = 7;
            } else {
              if (builder !== void 0) {
                return Parser.done(builder.bind());
              } else {
                return Parser.done(recon.absent());
              }
            }
          } else if (input.isDone()) {
            if (builder !== void 0) {
              return Parser.done(builder.bind());
            } else {
              return Parser.done(recon.absent());
            }
          }
        }
        if (step === 2) {
          if (keyParser === void 0) {
            keyParser = recon.parseBlockExpression(input);
          }
          while (keyParser.isCont() && !input.isEmpty()) {
            keyParser = keyParser.feed(input);
          }
          if (keyParser.isDone()) {
            step = 3;
          } else if (keyParser.isError()) {
            return keyParser;
          }
        }
        if (step === 3) {
          while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
            input = input.step();
          }
          if (input.isCont()) {
            if (c === 58) {
              input = input.step();
              step = 4;
            } else {
              builder.push(recon.item(keyParser.bind()));
              keyParser = void 0;
              step = 6;
            }
          } else if (input.isDone()) {
            builder.push(recon.item(keyParser.bind()));
            return Parser.done(builder.bind());
          }
        }
        if (step === 4) {
          while (input.isCont() && Recon.isSpace(input.head())) {
            input = input.step();
          }
          if (input.isCont()) {
            step = 5;
          } else if (input.isDone()) {
            builder.push(recon.slot(keyParser.bind()));
            return Parser.done(builder.bind());
          }
        }
        if (step === 5) {
          if (valueParser === void 0) {
            valueParser = recon.parseBlockExpression(input);
          }
          while (valueParser.isCont() && !input.isEmpty()) {
            valueParser = valueParser.feed(input);
          }
          if (valueParser.isDone()) {
            builder.push(recon.slot(keyParser.bind(), valueParser.bind()));
            keyParser = void 0;
            valueParser = void 0;
            step = 6;
          } else if (valueParser.isError()) {
            return valueParser;
          }
        }
        if (step === 6) {
          while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
            input = input.step();
          }
          if (input.isCont()) {
            if (c === 44 || c === 59 || Recon.isNewline(c)) {
              input = input.step();
              step = 1;
              continue;
            } else if (c === 35) {
              input = input.step();
              step = 7;
            } else {
              return Parser.done(builder.bind());
            }
          } else if (input.isDone()) {
            return Parser.done(builder.bind());
          }
        }
        if (step === 7) {
          while (input.isCont()) {
            c = input.head();
            if (!Recon.isNewline(c)) {
              input = input.step();
            } else {
              step = 1;
              continue block;
            }
          }
          if (input.isDone()) {
            step = 1;
            continue;
          }
        }
        break;
      } while (true);
      return new BlockParser(recon, builder, keyParser, valueParser, step);
    }
  }
  class AttrParser extends Parser {
    constructor(recon, keyParser, valueParser, step) {
      super();
      this.recon = recon;
      this.keyParser = keyParser;
      this.valueParser = valueParser;
      this.step = step;
    }
    feed(input) {
      return AttrParser.parse(input, this.recon, this.keyParser, this.valueParser, this.step);
    }
    static parse(input, recon, keyParser, valueParser, step = 1) {
      let c = 0;
      if (step === 1) {
        if (input.isCont()) {
          c = input.head();
          if (c === 64) {
            input = input.step();
            step = 2;
          } else {
            return Parser.error(Diagnostic.expected(64, input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected(64, input));
        }
      }
      if (step === 2) {
        if (keyParser === void 0) {
          if (input.isCont()) {
            c = input.head();
            if (c === 34 || c === 39) {
              keyParser = recon.parseString(input);
            } else if (Recon.isIdentStartChar(c)) {
              keyParser = recon.parseIdent(input);
            } else {
              return Parser.error(Diagnostic.expected("attribute name", input));
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.expected("attribute name", input));
          }
        } else {
          keyParser = keyParser.feed(input);
        }
        if (keyParser !== void 0) {
          if (keyParser.isDone()) {
            step = 3;
          } else if (keyParser.isError()) {
            return keyParser.asError();
          }
        }
      }
      if (step === 3) {
        if (input.isCont() && input.head() === 40) {
          input = input.step();
          step = 4;
        } else if (!input.isEmpty()) {
          return Parser.done(recon.attr(keyParser.bind()));
        }
      }
      if (step === 4) {
        while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 41) {
            input = input.step();
            return Parser.done(recon.attr(keyParser.bind()));
          } else {
            step = 5;
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected(")", input));
        }
      }
      if (step === 5) {
        if (valueParser === void 0) {
          valueParser = recon.parseBlock(input);
        }
        while (valueParser.isCont() && !input.isEmpty()) {
          valueParser = valueParser.feed(input);
        }
        if (valueParser.isDone()) {
          step = 6;
        } else if (valueParser.isError()) {
          return valueParser.asError();
        }
      }
      if (step === 6) {
        while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 41) {
            input = input.step();
            return Parser.done(recon.attr(keyParser.bind(), valueParser.bind()));
          } else {
            return Parser.error(Diagnostic.expected(")", input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected(")", input));
        }
      }
      return new AttrParser(recon, keyParser, valueParser, step);
    }
  }
  class BlockItemParser extends Parser {
    constructor(recon, builder, fieldParser, valueParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.fieldParser = fieldParser;
      this.valueParser = valueParser;
      this.step = step;
    }
    feed(input) {
      return BlockItemParser.parse(input, this.recon, this.builder, this.fieldParser, this.valueParser, this.step);
    }
    static parse(input, recon, builder, fieldParser, valueParser, step = 1) {
      let c = 0;
      do {
        if (step === 1) {
          if (input.isCont()) {
            c = input.head();
            if (c === 64) {
              fieldParser = recon.parseAttr(input);
              step = 2;
            } else if (c === 123) {
              builder = builder || recon.recordBuilder();
              valueParser = recon.parseRecord(input, builder);
              step = 5;
            } else if (c === 91) {
              builder = builder || recon.recordBuilder();
              valueParser = recon.parseMarkup(input, builder);
              step = 5;
            } else if (Recon.isIdentStartChar(c)) {
              valueParser = recon.parseIdent(input);
              step = 4;
            } else if (c === 34 || c === 39) {
              valueParser = recon.parseString(input);
              step = 4;
            } else if (c === 96) {
              valueParser = recon.parseRawString(input);
              step = 4;
            } else if (c === 45 || c >= 48 && c <= 57) {
              valueParser = recon.parseNumber(input);
              step = 4;
            } else if (c === 37) {
              valueParser = recon.parseData(input);
              step = 4;
            } else if (c === 36) {
              valueParser = recon.parseSelector(input);
              step = 4;
            } else if (builder === void 0) {
              return Parser.done(recon.extant());
            } else {
              return Parser.done(builder.bind());
            }
          } else if (input.isDone()) {
            if (builder === void 0) {
              return Parser.done(recon.extant());
            } else {
              return Parser.done(builder.bind());
            }
          }
        }
        if (step === 2) {
          while (fieldParser.isCont() && !input.isEmpty()) {
            fieldParser = fieldParser.feed(input);
          }
          if (fieldParser.isDone()) {
            builder = builder || recon.valueBuilder();
            builder.push(fieldParser.bind());
            fieldParser = void 0;
            step = 3;
          } else if (fieldParser.isError()) {
            return fieldParser.asError();
          }
        }
        if (step === 3) {
          while (input.isCont() && Recon.isSpace(input.head())) {
            input = input.step();
          }
          if (input.isCont()) {
            step = 1;
            continue;
          } else if (input.isDone()) {
            return Parser.done(builder.bind());
          }
        }
        if (step === 4) {
          while (valueParser.isCont() && !input.isEmpty()) {
            valueParser = valueParser.feed(input);
          }
          if (valueParser.isDone()) {
            builder = builder || recon.valueBuilder();
            builder.push(recon.item(valueParser.bind()));
            valueParser = void 0;
            step = 6;
          } else if (valueParser.isError()) {
            return valueParser;
          }
        }
        if (step === 5) {
          while (valueParser.isCont() && !input.isEmpty()) {
            valueParser = valueParser.feed(input);
          }
          if (valueParser.isDone()) {
            valueParser = void 0;
            step = 6;
          } else if (valueParser.isError()) {
            return valueParser;
          }
        }
        if (step === 6) {
          while (input.isCont() && Recon.isSpace(input.head())) {
            input = input.step();
          }
          if (input.isCont()) {
            if (input.head() === 64) {
              step = 1;
            } else {
              return Parser.done(builder.bind());
            }
          } else if (input.isDone()) {
            return Parser.done(builder.bind());
          }
        }
        break;
      } while (true);
      return new BlockItemParser(recon, builder, fieldParser, valueParser, step);
    }
  }
  class InlineItemParser extends Parser {
    constructor(recon, builder, fieldParser, valueParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.fieldParser = fieldParser;
      this.valueParser = valueParser;
      this.step = step;
    }
    feed(input) {
      return InlineItemParser.parse(input, this.recon, this.builder, this.fieldParser, this.valueParser, this.step);
    }
    static parse(input, recon, builder, fieldParser, valueParser, step = 1) {
      let c = 0;
      if (step === 1) {
        if (input.isCont()) {
          c = input.head();
          if (c === 64) {
            fieldParser = recon.parseAttr(input);
            step = 2;
          } else if (c === 123) {
            if (builder !== void 0) {
              valueParser = recon.parseRecord(input, builder);
              step = 5;
            } else {
              valueParser = recon.parseRecord(input);
              step = 4;
            }
          } else if (c === 91) {
            if (builder !== void 0) {
              valueParser = recon.parseMarkup(input, builder);
              step = 5;
            } else {
              valueParser = recon.parseMarkup(input);
              step = 4;
            }
          } else if (builder === void 0) {
            return Parser.done(recon.extant());
          } else {
            return Parser.done(builder.bind());
          }
        } else if (input.isDone()) {
          if (builder === void 0) {
            return Parser.done(recon.extant());
          } else {
            return Parser.done(builder.bind());
          }
        }
      }
      if (step === 2) {
        while (fieldParser.isCont() && !input.isEmpty()) {
          fieldParser = fieldParser.feed(input);
        }
        if (fieldParser.isDone()) {
          builder = builder || recon.valueBuilder();
          builder.push(fieldParser.bind());
          fieldParser = void 0;
          step = 3;
        } else if (fieldParser.isError()) {
          return fieldParser.asError();
        }
      }
      if (step === 3) {
        if (input.isCont()) {
          c = input.head();
          if (c === 123) {
            valueParser = recon.parseRecord(input, builder);
            step = 5;
          } else if (c === 91) {
            valueParser = recon.parseMarkup(input, builder);
            step = 5;
          } else {
            return Parser.done(builder.bind());
          }
        } else if (input.isDone()) {
          return Parser.done(builder.bind());
        }
      }
      if (step === 4) {
        while (valueParser.isCont() && !input.isEmpty()) {
          valueParser = valueParser.feed(input);
        }
        if (valueParser.isDone()) {
          builder = builder || recon.valueBuilder();
          builder.push(recon.item(valueParser.bind()));
          return Parser.done(builder.bind());
        } else if (valueParser.isError()) {
          return valueParser;
        }
      }
      if (step === 5) {
        while (valueParser.isCont() && !input.isEmpty()) {
          valueParser = valueParser.feed(input);
        }
        if (valueParser.isDone()) {
          return Parser.done(builder.bind());
        } else if (valueParser.isError()) {
          return valueParser;
        }
      }
      return new InlineItemParser(recon, builder, fieldParser, valueParser, step);
    }
  }
  class RecordParser extends Parser {
    constructor(recon, builder, keyParser, valueParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.keyParser = keyParser;
      this.valueParser = valueParser;
      this.step = step;
    }
    feed(input) {
      return RecordParser.parse(input, this.recon, this.builder, this.keyParser, this.valueParser, this.step);
    }
    static parse(input, recon, builder, keyParser, valueParser, step = 1) {
      let c = 0;
      if (step === 1) {
        if (input.isCont()) {
          c = input.head();
          if (c === 123) {
            input = input.step();
            step = 2;
          } else {
            return Parser.error(Diagnostic.expected(123, input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected(123, input));
        }
      }
      block: do {
        if (step === 2) {
          while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
            input = input.step();
          }
          if (input.isCont()) {
            builder = builder || recon.recordBuilder();
            if (c === 125) {
              input = input.step();
              return Parser.done(builder.bind());
            } else if (c === 35) {
              input = input.step();
              step = 8;
            } else {
              step = 3;
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.expected(125, input));
          }
        }
        if (step === 3) {
          if (keyParser === void 0) {
            keyParser = recon.parseBlockExpression(input);
          }
          while (keyParser.isCont() && !input.isEmpty()) {
            keyParser = keyParser.feed(input);
          }
          if (keyParser.isDone()) {
            step = 4;
          } else if (keyParser.isError()) {
            return keyParser;
          }
        }
        if (step === 4) {
          while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
            input = input.step();
          }
          if (input.isCont()) {
            if (c === 58) {
              input = input.step();
              step = 5;
            } else {
              builder.push(recon.item(keyParser.bind()));
              keyParser = void 0;
              step = 7;
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.expected(125, input));
          }
        }
        if (step === 5) {
          while (input.isCont() && Recon.isSpace(input.head())) {
            input = input.step();
          }
          if (input.isCont()) {
            step = 6;
          } else if (input.isDone()) {
            builder.push(recon.slot(keyParser.bind()));
            return Parser.done(builder.bind());
          }
        }
        if (step === 6) {
          if (valueParser === void 0) {
            valueParser = recon.parseBlockExpression(input);
          }
          while (valueParser.isCont() && !input.isEmpty()) {
            valueParser = valueParser.feed(input);
          }
          if (valueParser.isDone()) {
            builder.push(recon.slot(keyParser.bind(), valueParser.bind()));
            keyParser = void 0;
            valueParser = void 0;
            step = 7;
          } else if (valueParser.isError()) {
            return valueParser;
          }
        }
        if (step === 7) {
          while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
            input = input.step();
          }
          if (input.isCont()) {
            if (c === 44 || c === 59 || Recon.isNewline(c)) {
              input = input.step();
              step = 2;
              continue;
            } else if (c === 35) {
              input = input.step();
              step = 8;
            } else if (c === 125) {
              input = input.step();
              return Parser.done(builder.bind());
            } else {
              return Parser.error(Diagnostic.expected("'}', ';', ',', or newline", input));
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.expected(125, input));
          }
        }
        if (step === 8) {
          while (input.isCont()) {
            c = input.head();
            if (!Recon.isNewline(c)) {
              input = input.step();
            } else {
              step = 2;
              continue block;
            }
          }
          if (input.isDone()) {
            step = 2;
            continue;
          }
        }
        break;
      } while (true);
      return new RecordParser(recon, builder, keyParser, valueParser, step);
    }
  }
  class MarkupParser extends Parser {
    constructor(recon, builder, textOutput, valueParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.textOutput = textOutput;
      this.valueParser = valueParser;
      this.step = step;
    }
    feed(input) {
      return MarkupParser.parse(input, this.recon, this.builder, this.textOutput, this.valueParser, this.step);
    }
    static parse(input, recon, builder, textOutput, valueParser, step = 1) {
      let c = 0;
      if (step === 1) {
        if (input.isCont()) {
          c = input.head();
          if (c === 91) {
            input = input.step();
            step = 2;
          } else {
            return Parser.error(Diagnostic.expected(91, input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected(91, input));
        }
      }
      do {
        if (step === 2) {
          while (input.isCont()) {
            c = input.head();
            if (c !== 64 && c !== 91 && c !== 92 && c !== 93 && c !== 123 && c !== 125) {
              input = input.step();
              textOutput = textOutput || recon.textOutput();
              textOutput.write(c);
            } else {
              break;
            }
          }
          if (input.isCont()) {
            if (c === 93) {
              input = input.step();
              builder = builder || recon.recordBuilder();
              if (textOutput !== void 0) {
                builder.push(recon.item(textOutput.bind()));
              }
              return Parser.done(builder.bind());
            } else if (c === 64) {
              builder = builder || recon.recordBuilder();
              if (textOutput !== void 0) {
                builder.push(recon.item(textOutput.bind()));
                textOutput = void 0;
              }
              valueParser = recon.parseInlineItem(input);
              step = 3;
            } else if (c === 123) {
              builder = builder || recon.recordBuilder();
              if (textOutput !== void 0) {
                builder.push(recon.item(textOutput.bind()));
                textOutput = void 0;
              }
              valueParser = recon.parseRecord(input, builder);
              step = 4;
            } else if (c === 91) {
              builder = builder || recon.recordBuilder();
              if (textOutput !== void 0) {
                builder.push(recon.item(textOutput.bind()));
                textOutput = void 0;
              }
              valueParser = recon.parseMarkup(input, builder);
              step = 4;
            } else if (c === 92) {
              input = input.step();
              step = 5;
            } else {
              return Parser.error(Diagnostic.unexpected(input));
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.unexpected(input));
          }
        }
        if (step === 3) {
          while (valueParser.isCont() && !input.isEmpty()) {
            valueParser = valueParser.feed(input);
          }
          if (valueParser.isDone()) {
            builder.push(recon.item(valueParser.bind()));
            valueParser = void 0;
            step = 2;
            continue;
          } else if (valueParser.isError()) {
            return valueParser;
          }
        }
        if (step === 4) {
          while (valueParser.isCont() && !input.isEmpty()) {
            valueParser = valueParser.feed(input);
          }
          if (valueParser.isDone()) {
            valueParser = void 0;
            step = 2;
            continue;
          } else if (valueParser.isError()) {
            return valueParser;
          }
        }
        if (step === 5) {
          if (input.isCont()) {
            c = input.head();
            textOutput = textOutput || recon.textOutput();
            if (c === 34 || c === 36 || c === 39 || c === 47 || c === 64 || c === 91 || c === 92 || c === 93 || c === 123 || c === 125) {
              input = input.step();
              textOutput.write(c);
              step = 2;
            } else if (c === 98) {
              input = input.step();
              textOutput.write(8);
              step = 2;
            } else if (c === 102) {
              input = input.step();
              textOutput.write(12);
              step = 2;
            } else if (c === 110) {
              input = input.step();
              textOutput.write(10);
              step = 2;
            } else if (c === 114) {
              input = input.step();
              textOutput.write(13);
              step = 2;
            } else if (c === 116) {
              input = input.step();
              textOutput.write(9);
              step = 2;
            } else {
              return Parser.error(Diagnostic.expected("escape character", input));
            }
            continue;
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.expected("escape character", input));
          }
        }
        break;
      } while (true);
      return new MarkupParser(recon, builder, textOutput, valueParser, step);
    }
  }
  class DataParser extends Parser {
    constructor(recon, base64Parser, step) {
      super();
      this.recon = recon;
      this.base64Parser = base64Parser;
      this.step = step;
    }
    feed(input) {
      return DataParser.parse(input, this.recon, this.base64Parser, this.step);
    }
    static parse(input, recon, base64Parser, step = 1) {
      let c = 0;
      if (step === 1) {
        if (input.isCont()) {
          c = input.head();
          if (c === 37) {
            input = input.step();
            step = 2;
          } else {
            return Parser.error(Diagnostic.expected(37, input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected(37, input));
        }
      }
      if (step === 2) {
        if (base64Parser === void 0) {
          base64Parser = Base64.standard().parse(input, recon.dataOutput());
        }
        while (base64Parser.isCont() && !input.isEmpty()) {
          base64Parser = base64Parser.feed(input);
        }
        if (base64Parser.isDone()) {
          return base64Parser;
        } else if (base64Parser.isError()) {
          return base64Parser;
        }
      }
      return new DataParser(recon, base64Parser, step);
    }
  }
  class IdentParser extends Parser {
    constructor(recon, output, step) {
      super();
      this.recon = recon;
      this.output = output;
      this.step = step;
    }
    feed(input) {
      return IdentParser.parse(input, this.recon, this.output, this.step);
    }
    static parse(input, recon, output, step = 1) {
      let c = 0;
      if (step === 1) {
        if (input.isCont()) {
          c = input.head();
          if (Recon.isIdentStartChar(c)) {
            input = input.step();
            output = output || recon.textOutput();
            output = output.write(c);
            step = 2;
          } else {
            return Parser.error(Diagnostic.expected("identifier", input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected("identifier", input));
        }
      }
      if (step === 2) {
        while (input.isCont() && (c = input.head(), Recon.isIdentChar(c))) {
          input = input.step();
          output.write(c);
        }
        if (!input.isEmpty()) {
          return Parser.done(recon.ident(output.bind()));
        }
      }
      return new IdentParser(recon, output, step);
    }
  }
  class StringParser extends Parser {
    constructor(recon, output, quote, code, step) {
      super();
      this.recon = recon;
      this.output = output;
      this.quote = quote;
      this.code = code;
      this.step = step;
    }
    feed(input) {
      return StringParser.parse(input, this.recon, this.output, this.quote, this.code, this.step);
    }
    static parse(input, recon, output, quote = 0, code = 0, step = 1) {
      let c = 0;
      if (step === 1) {
        while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if ((c === 34 || c === 39) && (quote === c || quote === 0)) {
            input = input.step();
            output = output || recon.textOutput();
            quote = c;
            step = 2;
          } else {
            return Parser.error(Diagnostic.expected("string", input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected("string", input));
        }
      }
      string: do {
        if (step === 2) {
          while (input.isCont()) {
            c = input.head();
            if (c >= 32 && c !== quote && c !== 92) {
              input = input.step();
              output = output.write(c);
            } else {
              break;
            }
          }
          if (input.isCont()) {
            if (c === quote) {
              input = input.step();
              return Parser.done(output.bind());
            } else if (c === 92) {
              input = input.step();
              step = 3;
            } else {
              return Parser.error(Diagnostic.expected(quote, input));
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.expected(quote, input));
          }
        }
        if (step === 3) {
          if (input.isCont()) {
            c = input.head();
            if (c === 34 || c === 36 || c === 39 || c === 47 || c === 64 || c === 91 || c === 92 || c === 93 || c === 123 || c === 125) {
              input = input.step();
              output = output.write(c);
              step = 2;
              continue;
            } else if (c === 98) {
              input = input.step();
              output = output.write(8);
              step = 2;
              continue;
            } else if (c === 102) {
              input = input.step();
              output = output.write(12);
              step = 2;
              continue;
            } else if (c === 110) {
              input = input.step();
              output = output.write(10);
              step = 2;
              continue;
            } else if (c === 114) {
              input = input.step();
              output = output.write(13);
              step = 2;
              continue;
            } else if (c === 116) {
              input = input.step();
              output = output.write(9);
              step = 2;
              continue;
            } else if (c === 117) {
              input = input.step();
              step = 4;
            } else {
              return Parser.error(Diagnostic.expected("escape character", input));
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.expected("escape character", input));
          }
        }
        if (step >= 4) {
          do {
            if (input.isCont()) {
              c = input.head();
              if (Base16.isDigit(c)) {
                input = input.step();
                code = 16 * code + Base16.decodeDigit(c);
                if (step <= 6) {
                  step += 1;
                  continue;
                } else {
                  output = output.write(code);
                  code = 0;
                  step = 2;
                  continue string;
                }
              } else {
                return Parser.error(Diagnostic.expected("hex digit", input));
              }
            } else if (input.isDone()) {
              return Parser.error(Diagnostic.expected("hex digit", input));
            }
            break;
          } while (true);
        }
        break;
      } while (true);
      return new StringParser(recon, output, quote, code, step);
    }
  }
  class RawStringParser extends Parser {
    constructor(recon, output, count, step) {
      super();
      this.recon = recon;
      this.output = output;
      this.count = count;
      this.step = step;
    }
    feed(input) {
      return RawStringParser.parse(input, this.recon, this.output, this.count, this.step);
    }
    static parse(input, recon, output, count = 0, step = 1) {
      let c = 0;
      if (step === 1) {
        while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
          input = input.step();
        }
        if (input.isCont() && c === 96) {
          input = input.step();
          count = 1;
          step = 2;
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected("raw string", input));
        }
      }
      if (step === 2) {
        if (input.isCont()) {
          if (input.head() === 96) {
            input = input.step();
            count = 2;
            step = 3;
          } else {
            output = output || recon.textOutput();
            step = 4;
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected("raw string", input));
        }
      }
      if (step === 3) {
        if (input.isCont()) {
          if (input.head() === 96) {
            input = input.step();
            output = output || recon.textOutput();
            count = 3;
            step = 4;
          } else {
            output = output || recon.textOutput();
            return Parser.done(output.bind());
          }
        } else if (input.isDone()) {
          output = output || recon.textOutput();
          return Parser.done(output.bind());
        }
      }
      do {
        if (step === 4) {
          while (input.isCont()) {
            c = input.head();
            if ((count !== 1 || c >= 32) && c !== 96 && c !== 92) {
              input = input.step();
              output = output.write(c);
            } else {
              break;
            }
          }
          if (input.isCont()) {
            if (c === 92) {
              input = input.step();
              step = 5;
            } else if (c === 96) {
              input = input.step();
              if (count === 1) {
                return Parser.done(output.bind());
              } else {
                step = 6;
              }
            } else {
              return Parser.error(Diagnostic.expected(96, input));
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.expected(96, input));
          }
        }
        if (step === 5) {
          if (input.isCont()) {
            c = input.head();
            input = input.step();
            if (c !== 92 && c !== 96) {
              output = output.write(92);
            }
            output = output.write(c);
            step = 4;
            continue;
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.expected("escape character", input));
          }
        }
        if (step === 6) {
          if (input.isCont()) {
            if (input.head() === 96) {
              input = input.step();
              step = 7;
            } else {
              output = output.write(96);
              step = 4;
              continue;
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.message("unclosed raw string", input));
          }
        }
        if (step === 7) {
          if (input.isCont()) {
            if (input.head() === 96) {
              input = input.step();
              return Parser.done(output.bind());
            } else {
              output = output.write(96);
              output = output.write(96);
              step = 4;
              continue;
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.message("unclosed raw string", input));
          }
        }
        break;
      } while (true);
      return new RawStringParser(recon, output, count, step);
    }
  }
  class NumberParser extends Parser {
    constructor(recon, sign, value, mode, step) {
      super();
      this.recon = recon;
      this.sign = sign;
      this.value = value;
      this.mode = mode;
      this.step = step;
    }
    feed(input) {
      return NumberParser.parse(input, this.recon, this.sign, this.value, this.mode, this.step);
    }
    static parse(input, recon, sign = 1, value = 0, mode = 2, step = 1) {
      let c = 0;
      if (step === 1) {
        while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 45) {
            input = input.step();
            sign = -1;
          }
          step = 2;
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected("number", input));
        }
      }
      if (step === 2) {
        if (input.isCont()) {
          c = input.head();
          if (c === 48) {
            input = input.step();
            step = 4;
          } else if (c >= 49 && c <= 57) {
            input = input.step();
            value = sign * (c - 48);
            step = 3;
          } else {
            return Parser.error(Diagnostic.expected("digit", input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected("digit", input));
        }
      }
      if (step === 3) {
        while (input.isCont()) {
          c = input.head();
          if (c >= 48 && c <= 57) {
            const newValue = 10 * value + sign * (c - 48);
            if (-9007199254740991 <= newValue && newValue <= 9007199254740992) {
              value = newValue;
              input = input.step();
            } else {
              return Parser.error(Diagnostic.message("integer overflow", input));
            }
          } else {
            break;
          }
        }
        if (input.isCont()) {
          step = 4;
        } else if (input.isDone()) {
          return Parser.done(recon.num(value));
        }
      }
      if (step === 4) {
        if (input.isCont()) {
          c = input.head();
          if (mode > 0 && c === 46 || mode > 1 && (c === 69 || c === 101)) {
            let output = Unicode.stringOutput();
            if (sign < 0 && value === 0) {
              output = output.write(45).write(48);
            } else {
              output = output.write("" + value);
            }
            return DecimalParser.parse(input, recon, output, mode);
          } else if (c === 120 && sign > 0 && value === 0) {
            input = input.step();
            return HexadecimalParser.parse(input, recon);
          } else {
            return Parser.done(recon.num(value));
          }
        } else if (input.isDone()) {
          return Parser.done(recon.num(value));
        }
      }
      return new NumberParser(recon, sign, value, mode, step);
    }
    static parseInteger(input, recon) {
      return NumberParser.parse(input, recon, void 0, void 0, 0);
    }
    static parseDecimal(input, recon) {
      return NumberParser.parse(input, recon, void 0, void 0, 1);
    }
  }
  class DecimalParser extends Parser {
    constructor(recon, output, mode, step) {
      super();
      this.recon = recon;
      this.output = output;
      this.mode = mode;
      this.step = step;
    }
    feed(input) {
      return DecimalParser.parse(input, this.recon, this.output, this.mode, this.step);
    }
    static parse(input, recon, output, mode = 2, step = 1) {
      let c = 0;
      if (step === 1) {
        if (input.isCont()) {
          c = input.head();
          if (c === 46) {
            input = input.step();
            output = output.write(c);
            step = 2;
          } else if (mode > 1 && (c === 69 || c === 101)) {
            input = input.step();
            output = output.write(c);
            step = 5;
          } else {
            return Parser.error(Diagnostic.expected("decimal or exponent", input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected("decimal or exponent", input));
        }
      }
      if (step === 2) {
        if (input.isCont()) {
          c = input.head();
          if (c >= 48 && c <= 57) {
            input = input.step();
            output = output.write(c);
            step = 3;
          } else {
            return Parser.error(Diagnostic.expected("digit", input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected("digit", input));
        }
      }
      if (step === 3) {
        while (input.isCont()) {
          c = input.head();
          if (c >= 48 && c <= 57) {
            input = input.step();
            output = output.write(c);
          } else {
            break;
          }
        }
        if (input.isCont()) {
          if (mode > 1) {
            step = 4;
          } else {
            return Parser.done(recon.num(output.bind()));
          }
        } else if (input.isDone()) {
          return Parser.done(recon.num(output.bind()));
        }
      }
      if (step === 4) {
        c = input.head();
        if (c === 69 || c === 101) {
          input = input.step();
          output = output.write(c);
          step = 5;
        } else {
          return Parser.done(recon.num(output.bind()));
        }
      }
      if (step === 5) {
        if (input.isCont()) {
          c = input.head();
          if (c === 43 || c === 45) {
            input = input.step();
            output = output.write(c);
          }
          step = 6;
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      if (step === 6) {
        if (input.isCont()) {
          c = input.head();
          if (c >= 48 && c <= 57) {
            input = input.step();
            output = output.write(c);
            step = 7;
          } else {
            return Parser.error(Diagnostic.expected("digit", input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected("digit", input));
        }
      }
      if (step === 7) {
        while (input.isCont()) {
          c = input.head();
          if (c >= 48 && c <= 57) {
            input = input.step();
            output = output.write(c);
          } else {
            break;
          }
        }
        if (!input.isEmpty()) {
          return Parser.done(recon.num(output.bind()));
        }
      }
      return new DecimalParser(recon, output, mode, step);
    }
  }
  class HexadecimalParser extends Parser {
    constructor(recon, value, size) {
      super();
      this.recon = recon;
      this.value = value;
      this.size = size;
    }
    feed(input) {
      return HexadecimalParser.parse(input, this.recon, this.value, this.size);
    }
    static parse(input, recon, value = 0, size = 0) {
      let c = 0;
      while (input.isCont()) {
        c = input.head();
        if (Base16.isDigit(c)) {
          input = input.step();
          value = 16 * value + Base16.decodeDigit(c);
          size += 1;
        } else {
          break;
        }
      }
      if (!input.isEmpty()) {
        if (size > 0) {
          if (size <= 8) {
            return Parser.done(recon.uint32(value));
          } else {
            return Parser.done(recon.uint64(value));
          }
        } else {
          return Parser.error(Diagnostic.expected("hex digit", input));
        }
      }
      return new HexadecimalParser(recon, value, size);
    }
  }
  class LambdaFuncParser extends Parser {
    constructor(recon, builder, bindingsParser, templateParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.bindingsParser = bindingsParser;
      this.templateParser = templateParser;
      this.step = step;
    }
    feed(input) {
      return LambdaFuncParser.parse(input, this.recon, this.builder, this.bindingsParser, this.templateParser, this.step);
    }
    static parse(input, recon, builder, bindingsParser, templateParser, step = 1) {
      let c = 0;
      if (step === 1) {
        if (bindingsParser === void 0) {
          bindingsParser = recon.parseConditionalOperator(input, builder);
        }
        while (bindingsParser.isCont() && !input.isEmpty()) {
          bindingsParser = bindingsParser.feed(input);
        }
        if (bindingsParser.isDone()) {
          step = 2;
        } else if (bindingsParser.isError()) {
          return bindingsParser.asError();
        }
      }
      if (step === 2) {
        if (input.isCont()) {
          c = input.head();
          if (c === 62) {
            input = input.step();
            step = 3;
          } else {
            return bindingsParser;
          }
        } else if (input.isDone()) {
          return bindingsParser;
        }
      }
      if (step === 3) {
        if (templateParser === void 0) {
          templateParser = recon.parseConditionalOperator(input);
        }
        while (templateParser.isCont() && !input.isEmpty()) {
          templateParser = templateParser.feed(input);
        }
        if (templateParser.isDone()) {
          const bindings = bindingsParser.bind();
          const template = templateParser.bind();
          return Parser.done(recon.lambda(bindings, template));
        } else if (templateParser.isError()) {
          return templateParser.asError();
        }
      }
      return new LambdaFuncParser(recon, builder, bindingsParser, templateParser, step);
    }
  }
  class ConditionalOperatorParser extends Parser {
    constructor(recon, builder, ifParser, thenParser, elseParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.ifParser = ifParser;
      this.thenParser = thenParser;
      this.elseParser = elseParser;
      this.step = step;
    }
    feed(input) {
      return ConditionalOperatorParser.parse(input, this.recon, this.builder, this.ifParser, this.thenParser, this.elseParser, this.step);
    }
    static parse(input, recon, builder, ifParser, thenParser, elseParser, step = 1) {
      let c = 0;
      if (step === 1) {
        if (ifParser === void 0) {
          ifParser = recon.parseOrOperator(input, builder);
        }
        while (ifParser.isCont() && !input.isEmpty()) {
          ifParser = ifParser.feed(input);
        }
        if (ifParser.isDone()) {
          step = 2;
        } else if (ifParser.isError()) {
          return ifParser.asError();
        }
      }
      if (step === 2) {
        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 63) {
            input = input.step();
            step = 3;
          } else {
            return ifParser;
          }
        } else if (input.isDone()) {
          return ifParser;
        }
      }
      if (step === 3) {
        if (thenParser === void 0) {
          thenParser = recon.parseConditionalOperator(input, builder);
        }
        while (thenParser.isCont() && !input.isEmpty()) {
          thenParser = thenParser.feed(input);
        }
        if (thenParser.isDone()) {
          step = 4;
        } else if (thenParser.isError()) {
          return thenParser.asError();
        }
      }
      if (step === 4) {
        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 58) {
            input = input.step();
            step = 5;
          } else {
            return Parser.error(Diagnostic.expected(58, input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected(58, input));
        }
      }
      if (step === 5) {
        if (elseParser === void 0) {
          elseParser = recon.parseConditionalOperator(input, builder);
        }
        while (elseParser.isCont() && !input.isEmpty()) {
          elseParser = elseParser.feed(input);
        }
        if (elseParser.isDone()) {
          const ifTerm = ifParser.bind();
          const thenTerm = thenParser.bind();
          const elseTerm = elseParser.bind();
          return Parser.done(recon.conditional(ifTerm, thenTerm, elseTerm));
        } else if (elseParser.isError()) {
          return elseParser.asError();
        }
      }
      return new ConditionalOperatorParser(recon, builder, ifParser, thenParser, elseParser, step);
    }
  }
  class OrOperatorParser extends Parser {
    constructor(recon, builder, lhsParser, rhsParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.lhsParser = lhsParser;
      this.rhsParser = rhsParser;
      this.step = step;
    }
    feed(input) {
      return OrOperatorParser.parse(input, this.recon, this.builder, this.lhsParser, this.rhsParser, this.step);
    }
    static parse(input, recon, builder, lhsParser, rhsParser, step = 1) {
      let c = 0;
      do {
        if (step === 1) {
          if (lhsParser === void 0) {
            lhsParser = recon.parseAndOperator(input, builder);
          }
          while (lhsParser.isCont() && !input.isEmpty()) {
            lhsParser = lhsParser.feed(input);
          }
          if (lhsParser.isDone()) {
            step = 2;
          } else if (lhsParser.isError()) {
            return lhsParser.asError();
          }
        }
        if (step === 2) {
          if (input.isCont()) {
            c = input.head();
            if (c === 124) {
              input = input.step();
              step = 3;
            } else {
              return lhsParser;
            }
          } else if (input.isDone()) {
            return lhsParser;
          }
        }
        if (step === 3) {
          if (rhsParser === void 0) {
            rhsParser = recon.parseAndOperator(input, builder);
          }
          while (rhsParser.isCont() && !input.isEmpty()) {
            rhsParser = rhsParser.feed(input);
          }
          if (rhsParser.isDone()) {
            const lhs = lhsParser.bind();
            const rhs = rhsParser.bind();
            lhsParser = Parser.done(recon.or(lhs, rhs));
            rhsParser = void 0;
            step = 2;
            continue;
          } else if (rhsParser.isError()) {
            return rhsParser.asError();
          }
        }
        break;
      } while (true);
      return new OrOperatorParser(recon, builder, lhsParser, rhsParser, step);
    }
  }
  class AndOperatorParser extends Parser {
    constructor(recon, builder, lhsParser, rhsParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.lhsParser = lhsParser;
      this.rhsParser = rhsParser;
      this.step = step;
    }
    feed(input) {
      return AndOperatorParser.parse(input, this.recon, this.builder, this.lhsParser, this.rhsParser, this.step);
    }
    static parse(input, recon, builder, lhsParser, rhsParser, step = 1) {
      let c = 0;
      do {
        if (step === 1) {
          if (lhsParser === void 0) {
            lhsParser = recon.parseBitwiseOrOperator(input, builder);
          }
          while (lhsParser.isCont() && !input.isEmpty()) {
            lhsParser = lhsParser.feed(input);
          }
          if (lhsParser.isDone()) {
            step = 2;
          } else if (lhsParser.isError()) {
            return lhsParser.asError();
          }
        }
        if (step === 2) {
          if (input.isCont()) {
            c = input.head();
            if (c === 38) {
              input = input.step();
              step = 3;
            } else {
              return lhsParser;
            }
          } else if (input.isDone()) {
            return lhsParser;
          }
        }
        if (step === 3) {
          if (rhsParser === void 0) {
            rhsParser = recon.parseBitwiseOrOperator(input, builder);
          }
          while (rhsParser.isCont() && !input.isEmpty()) {
            rhsParser = rhsParser.feed(input);
          }
          if (rhsParser.isDone()) {
            const lhs = lhsParser.bind();
            const rhs = rhsParser.bind();
            lhsParser = Parser.done(recon.and(lhs, rhs));
            rhsParser = void 0;
            step = 2;
            continue;
          } else if (rhsParser.isError()) {
            return rhsParser.asError();
          }
        }
        break;
      } while (true);
      return new AndOperatorParser(recon, builder, lhsParser, rhsParser, step);
    }
  }
  class BitwiseOrOperatorParser extends Parser {
    constructor(recon, builder, lhsParser, rhsParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.lhsParser = lhsParser;
      this.rhsParser = rhsParser;
      this.step = step;
    }
    feed(input) {
      return BitwiseOrOperatorParser.parse(input, this.recon, this.builder, this.lhsParser, this.rhsParser, this.step);
    }
    static parse(input, recon, builder, lhsParser, rhsParser, step = 1) {
      let c = 0;
      do {
        if (step === 1) {
          if (lhsParser === void 0) {
            lhsParser = recon.parseBitwiseXorOperator(input, builder);
          }
          while (lhsParser.isCont() && !input.isEmpty()) {
            lhsParser = lhsParser.feed(input);
          }
          if (lhsParser.isDone()) {
            step = 2;
          } else if (lhsParser.isError()) {
            return lhsParser.asError();
          }
        }
        if (step === 2) {
          while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
            input = input.step();
          }
          if (input.isCont()) {
            if (c === 124) {
              input = input.step();
              step = 3;
            } else {
              return lhsParser;
            }
          } else if (input.isDone()) {
            return lhsParser;
          }
        }
        if (step === 3) {
          if (input.isCont()) {
            c = input.head();
            if (c === 124) {
              return lhsParser;
            } else {
              step = 4;
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.unexpected(input));
          }
        }
        if (step === 4) {
          if (rhsParser === void 0) {
            rhsParser = recon.parseBitwiseXorOperator(input, builder);
          }
          while (rhsParser.isCont() && !input.isEmpty()) {
            rhsParser = rhsParser.feed(input);
          }
          if (rhsParser.isDone()) {
            const lhs = lhsParser.bind();
            const rhs = rhsParser.bind();
            lhsParser = Parser.done(recon.bitwiseOr(lhs, rhs));
            rhsParser = void 0;
            step = 2;
            continue;
          } else if (rhsParser.isError()) {
            return rhsParser.asError();
          }
        }
        break;
      } while (true);
      return new BitwiseOrOperatorParser(recon, builder, lhsParser, rhsParser, step);
    }
  }
  class BitwiseXorOperatorParser extends Parser {
    constructor(recon, builder, lhsParser, rhsParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.lhsParser = lhsParser;
      this.rhsParser = rhsParser;
      this.step = step;
    }
    feed(input) {
      return BitwiseXorOperatorParser.parse(input, this.recon, this.builder, this.lhsParser, this.rhsParser, this.step);
    }
    static parse(input, recon, builder, lhsParser, rhsParser, step = 1) {
      let c = 0;
      do {
        if (step === 1) {
          if (lhsParser === void 0) {
            lhsParser = recon.parseBitwiseAndOperator(input, builder);
          }
          while (lhsParser.isCont() && !input.isEmpty()) {
            lhsParser = lhsParser.feed(input);
          }
          if (lhsParser.isDone()) {
            step = 2;
          } else if (lhsParser.isError()) {
            return lhsParser.asError();
          }
        }
        if (step === 2) {
          while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
            input = input.step();
          }
          if (input.isCont()) {
            if (c === 94) {
              input = input.step();
              step = 3;
            } else {
              return lhsParser;
            }
          } else if (input.isDone()) {
            return lhsParser;
          }
        }
        if (step === 3) {
          if (rhsParser === void 0) {
            rhsParser = recon.parseBitwiseAndOperator(input, builder);
          }
          while (rhsParser.isCont() && !input.isEmpty()) {
            rhsParser = rhsParser.feed(input);
          }
          if (rhsParser.isDone()) {
            const lhs = lhsParser.bind();
            const rhs = rhsParser.bind();
            lhsParser = Parser.done(recon.bitwiseXor(lhs, rhs));
            rhsParser = void 0;
            step = 2;
            continue;
          } else if (rhsParser.isError()) {
            return rhsParser.asError();
          }
        }
        break;
      } while (true);
      return new BitwiseXorOperatorParser(recon, builder, lhsParser, rhsParser, step);
    }
  }
  class BitwiseAndOperatorParser extends Parser {
    constructor(recon, builder, lhsParser, rhsParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.lhsParser = lhsParser;
      this.rhsParser = rhsParser;
      this.step = step;
    }
    feed(input) {
      return BitwiseAndOperatorParser.parse(input, this.recon, this.builder, this.lhsParser, this.rhsParser, this.step);
    }
    static parse(input, recon, builder, lhsParser, rhsParser, step = 1) {
      let c = 0;
      do {
        if (step === 1) {
          if (lhsParser === void 0) {
            lhsParser = recon.parseComparisonOperator(input, builder);
          }
          while (lhsParser.isCont() && !input.isEmpty()) {
            lhsParser = lhsParser.feed(input);
          }
          if (lhsParser.isDone()) {
            step = 2;
          } else if (lhsParser.isError()) {
            return lhsParser.asError();
          }
        }
        if (step === 2) {
          while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
            input = input.step();
          }
          if (input.isCont()) {
            if (c === 38) {
              input = input.step();
              step = 3;
            } else {
              return lhsParser;
            }
          } else if (input.isDone()) {
            return lhsParser;
          }
        }
        if (step === 3) {
          if (input.isCont()) {
            c = input.head();
            if (c === 38) {
              return lhsParser;
            } else {
              step = 4;
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.unexpected(input));
          }
        }
        if (step === 4) {
          if (rhsParser === void 0) {
            rhsParser = recon.parseComparisonOperator(input, builder);
          }
          while (rhsParser.isCont() && !input.isEmpty()) {
            rhsParser = rhsParser.feed(input);
          }
          if (rhsParser.isDone()) {
            const lhs = lhsParser.bind();
            const rhs = rhsParser.bind();
            lhsParser = Parser.done(recon.bitwiseAnd(lhs, rhs));
            rhsParser = void 0;
            step = 2;
            continue;
          } else if (rhsParser.isError()) {
            return rhsParser.asError();
          }
        }
        break;
      } while (true);
      return new BitwiseAndOperatorParser(recon, builder, lhsParser, rhsParser, step);
    }
  }
  class ComparisonOperatorParser extends Parser {
    constructor(recon, builder, lhsParser, operator, rhsParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.lhsParser = lhsParser;
      this.operator = operator;
      this.rhsParser = rhsParser;
      this.step = step;
    }
    feed(input) {
      return ComparisonOperatorParser.parse(input, this.recon, this.builder, this.lhsParser, this.operator, this.rhsParser, this.step);
    }
    static parse(input, recon, builder, lhsParser, operator, rhsParser, step = 1) {
      let c = 0;
      if (step === 1) {
        if (lhsParser === void 0) {
          lhsParser = recon.parseAttrExpression(input, builder);
        }
        while (lhsParser.isCont() && !input.isEmpty()) {
          lhsParser = lhsParser.feed(input);
        }
        if (lhsParser.isDone()) {
          step = 2;
        } else if (lhsParser.isError()) {
          return lhsParser.asError();
        }
      }
      if (step === 2) {
        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 33) {
            input = input.step();
            step = 3;
          } else if (c === 60) {
            input = input.step();
            step = 4;
          } else if (c === 62) {
            input = input.step();
            step = 5;
          } else if (c === 61) {
            input = input.step();
            step = 6;
          } else {
            return lhsParser;
          }
        } else if (input.isDone()) {
          return lhsParser;
        }
      }
      if (step === 3) {
        if (input.isCont()) {
          c = input.head();
          if (c === 61) {
            input = input.step();
            operator = "!=";
            step = 7;
          } else {
            operator = "!";
            step = 7;
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      if (step === 4) {
        if (input.isCont()) {
          c = input.head();
          if (c === 61) {
            input = input.step();
            operator = "<=";
            step = 7;
          } else {
            operator = "<";
            step = 7;
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      if (step === 5) {
        if (input.isCont()) {
          c = input.head();
          if (c === 61) {
            input = input.step();
            operator = ">=";
            step = 7;
          } else {
            operator = ">";
            step = 7;
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      if (step === 6) {
        if (input.isCont()) {
          c = input.head();
          if (c === 61) {
            input = input.step();
            operator = "==";
            step = 7;
          } else if (c === 62) {
            return lhsParser;
          } else {
            operator = "=";
            step = 7;
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      if (step === 7) {
        if (rhsParser === void 0) {
          rhsParser = recon.parseAttrExpression(input, builder);
        }
        while (rhsParser.isCont() && !input.isEmpty()) {
          rhsParser = rhsParser.feed(input);
        }
        if (rhsParser.isDone()) {
          const lhs = lhsParser.bind();
          const rhs = rhsParser.bind();
          if (operator === "<") {
            return Parser.done(recon.lt(lhs, rhs));
          } else if (operator === "<=") {
            return Parser.done(recon.le(lhs, rhs));
          } else if (operator === "==") {
            return Parser.done(recon.eq(lhs, rhs));
          } else if (operator === "!=") {
            return Parser.done(recon.ne(lhs, rhs));
          } else if (operator === ">=") {
            return Parser.done(recon.ge(lhs, rhs));
          } else if (operator === ">") {
            return Parser.done(recon.gt(lhs, rhs));
          } else {
            return Parser.error(Diagnostic.message(operator, input));
          }
        } else if (rhsParser.isError()) {
          return rhsParser.asError();
        }
      }
      return new ComparisonOperatorParser(recon, builder, lhsParser, operator, rhsParser, step);
    }
  }
  class AttrExpressionParser extends Parser {
    constructor(recon, builder, fieldParser, valueParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.fieldParser = fieldParser;
      this.valueParser = valueParser;
      this.step = step;
    }
    feed(input) {
      return AttrExpressionParser.parse(input, this.recon, this.builder, this.fieldParser, this.valueParser, this.step);
    }
    static parse(input, recon, builder, fieldParser, valueParser, step = 1) {
      let c = 0;
      do {
        if (step === 1) {
          while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
            input = input.step();
          }
          if (input.isCont()) {
            if (c === 64) {
              step = 2;
            } else if (c === 123 || c === 91) {
              builder = builder || recon.recordBuilder();
              step = 5;
            } else if (c === 40) {
              step = 4;
            } else if (c === 33 || c === 34 || c === 36 || c === 37 || c === 39 || c === 43 || c === 45 || c >= 48 && c <= 57 || c === 96 || c === 126 || Recon.isIdentStartChar(c)) {
              step = 3;
            } else if (builder === void 0) {
              return Parser.done(recon.extant());
            } else {
              return Parser.done(builder.bind());
            }
          } else if (input.isDone()) {
            if (builder === void 0) {
              return Parser.done(recon.extant());
            } else {
              return Parser.done(builder.bind());
            }
          }
        }
        if (step === 2) {
          if (fieldParser === void 0) {
            fieldParser = recon.parseAttr(input);
          }
          while (fieldParser.isCont() && !input.isEmpty()) {
            fieldParser = fieldParser.feed(input);
          }
          if (fieldParser.isDone()) {
            builder = builder || recon.recordBuilder();
            builder.push(fieldParser.bind());
            fieldParser = void 0;
            step = 1;
            continue;
          } else if (fieldParser.isError()) {
            return fieldParser.asError();
          }
        }
        if (step === 3) {
          if (valueParser === void 0) {
            valueParser = recon.parseAdditiveOperator(input);
          }
          while (valueParser.isCont() && !input.isEmpty()) {
            valueParser = valueParser.feed(input);
          }
          if (valueParser.isDone()) {
            builder = builder || recon.valueBuilder();
            builder.push(recon.item(valueParser.bind()));
            valueParser = void 0;
            step = 6;
          } else if (valueParser.isError()) {
            return valueParser.asError();
          }
        }
        if (step === 4) {
          if (valueParser === void 0) {
            valueParser = recon.parseAdditiveOperator(input, builder);
          }
          while (valueParser.isCont() && !input.isEmpty()) {
            valueParser = valueParser.feed(input);
          }
          if (valueParser.isDone()) {
            if (builder === void 0) {
              builder = recon.valueBuilder();
              builder.push(recon.item(valueParser.bind()));
            }
            valueParser = void 0;
            step = 6;
          } else if (valueParser.isError()) {
            return valueParser.asError();
          }
        }
        if (step === 5) {
          if (valueParser === void 0) {
            valueParser = recon.parseAdditiveOperator(input, builder);
          }
          while (valueParser.isCont() && !input.isEmpty()) {
            valueParser = valueParser.feed(input);
          }
          if (valueParser.isDone()) {
            valueParser = void 0;
            step = 6;
          } else if (valueParser.isError()) {
            return valueParser.asError();
          }
        }
        if (step === 6) {
          while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
            input = input.step();
          }
          if (input.isCont()) {
            if (c === 64) {
              step = 1;
              continue;
            } else {
              return Parser.done(builder.bind());
            }
          } else if (input.isDone()) {
            return Parser.done(builder.bind());
          }
        }
        break;
      } while (true);
      return new AttrExpressionParser(recon, builder, fieldParser, valueParser, step);
    }
  }
  class AdditiveOperatorParser extends Parser {
    constructor(recon, builder, lhsParser, operator, rhsParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.lhsParser = lhsParser;
      this.operator = operator;
      this.rhsParser = rhsParser;
      this.step = step;
    }
    feed(input) {
      return AdditiveOperatorParser.parse(input, this.recon, this.builder, this.lhsParser, this.operator, this.rhsParser, this.step);
    }
    static parse(input, recon, builder, lhsParser, operator, rhsParser, step = 1) {
      let c = 0;
      do {
        if (step === 1) {
          if (lhsParser === void 0) {
            lhsParser = recon.parseMultiplicativeOperator(input, builder);
          }
          while (lhsParser.isCont() && !input.isEmpty()) {
            lhsParser = lhsParser.feed(input);
          }
          if (lhsParser.isDone()) {
            step = 2;
          } else if (lhsParser.isError()) {
            return lhsParser.asError();
          }
        }
        if (step === 2) {
          while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
            input = input.step();
          }
          if (input.isCont()) {
            if (c === 43) {
              input = input.step();
              operator = "+";
              step = 3;
            } else if (c === 45) {
              input = input.step();
              operator = "-";
              step = 3;
            } else {
              return lhsParser;
            }
          } else if (input.isDone()) {
            return lhsParser;
          }
        }
        if (step === 3) {
          if (rhsParser === void 0) {
            rhsParser = recon.parseMultiplicativeOperator(input, builder);
          }
          while (rhsParser.isCont() && !input.isEmpty()) {
            rhsParser = rhsParser.feed(input);
          }
          if (rhsParser.isDone()) {
            const lhs = lhsParser.bind();
            const rhs = rhsParser.bind();
            if (operator === "+") {
              lhsParser = Parser.done(recon.plus(lhs, rhs));
            } else if (operator === "-") {
              lhsParser = Parser.done(recon.minus(lhs, rhs));
            } else {
              return Parser.error(Diagnostic.message(operator, input));
            }
            rhsParser = void 0;
            operator = void 0;
            step = 2;
            continue;
          } else if (rhsParser.isError()) {
            return rhsParser.asError();
          }
        }
        break;
      } while (true);
      return new AdditiveOperatorParser(recon, builder, lhsParser, operator, rhsParser, step);
    }
  }
  class MultiplicativeOperatorParser extends Parser {
    constructor(recon, builder, lhsParser, operator, rhsParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.lhsParser = lhsParser;
      this.operator = operator;
      this.rhsParser = rhsParser;
      this.step = step;
    }
    feed(input) {
      return MultiplicativeOperatorParser.parse(input, this.recon, this.builder, this.lhsParser, this.operator, this.rhsParser, this.step);
    }
    static parse(input, recon, builder, lhsParser, operator, rhsParser, step = 1) {
      let c = 0;
      do {
        if (step === 1) {
          if (lhsParser === void 0) {
            lhsParser = recon.parsePrefixOperator(input, builder);
          }
          while (lhsParser.isCont() && !input.isEmpty()) {
            lhsParser = lhsParser.feed(input);
          }
          if (lhsParser.isDone()) {
            step = 2;
          } else if (lhsParser.isError()) {
            return lhsParser.asError();
          }
        }
        if (step === 2) {
          while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
            input = input.step();
          }
          if (input.isCont()) {
            if (c === 42) {
              input = input.step();
              operator = "*";
              step = 3;
            } else if (c === 47) {
              input = input.step();
              operator = "/";
              step = 3;
            } else if (c === 37) {
              input = input.step();
              operator = "%";
              step = 3;
            } else {
              return lhsParser;
            }
          } else if (input.isDone()) {
            return lhsParser;
          }
        }
        if (step === 3) {
          if (rhsParser === void 0) {
            rhsParser = recon.parsePrefixOperator(input, builder);
          }
          while (rhsParser.isCont() && !input.isEmpty()) {
            rhsParser = rhsParser.feed(input);
          }
          if (rhsParser.isDone()) {
            const lhs = lhsParser.bind();
            const rhs = rhsParser.bind();
            if (operator === "*") {
              lhsParser = Parser.done(recon.times(lhs, rhs));
            } else if (operator === "/") {
              lhsParser = Parser.done(recon.divide(lhs, rhs));
            } else if (operator === "%") {
              lhsParser = Parser.done(recon.modulo(lhs, rhs));
            } else {
              return Parser.error(Diagnostic.message(operator, input));
            }
            rhsParser = void 0;
            operator = void 0;
            step = 2;
            continue;
          } else if (rhsParser.isError()) {
            return rhsParser.asError();
          }
        }
        break;
      } while (true);
      return new MultiplicativeOperatorParser(recon, builder, lhsParser, operator, rhsParser, step);
    }
  }
  class PrefixOperatorParser extends Parser {
    constructor(recon, builder, operator, rhsParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.operator = operator;
      this.operandParser = rhsParser;
      this.step = step;
    }
    feed(input) {
      return PrefixOperatorParser.parse(input, this.recon, this.builder, this.operator, this.operandParser, this.step);
    }
    static parse(input, recon, builder, operator, rhsParser, step = 1) {
      let c = 0;
      if (step === 1) {
        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 33) {
            input = input.step();
            operator = "!";
          } else if (c === 126) {
            input = input.step();
            operator = "~";
          } else if (c === 45) {
            input = input.step();
            operator = "-";
          } else if (c === 43) {
            input = input.step();
            operator = "+";
          } else {
            return recon.parseInvokeOperator(input, builder);
          }
          step = 2;
        } else if (input.isDone()) {
          return recon.parseInvokeOperator(input, builder);
        }
      }
      if (step === 2) {
        if (rhsParser === void 0) {
          rhsParser = recon.parsePrefixOperator(input, builder);
        }
        while (rhsParser.isCont() && !input.isEmpty()) {
          rhsParser = rhsParser.feed(input);
        }
        if (rhsParser.isDone()) {
          const operand = rhsParser.bind();
          if (!recon.isDistinct(operand)) {
            return Parser.error(Diagnostic.expected("value", input));
          } else if (operator === "!") {
            return Parser.done(recon.not(operand));
          } else if (operator === "~") {
            return Parser.done(recon.bitwiseNot(operand));
          } else if (operator === "-") {
            return Parser.done(recon.negative(operand));
          } else if (operator === "+") {
            return Parser.done(recon.positive(operand));
          } else {
            return Parser.error(Diagnostic.message(operator, input));
          }
        } else if (rhsParser.isError()) {
          return rhsParser.asError();
        }
      }
      return new PrefixOperatorParser(recon, builder, operator, rhsParser, step);
    }
  }
  class InvokeOperatorParser extends Parser {
    constructor(recon, builder, exprParser, argsParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.exprParser = exprParser;
      this.argsParser = argsParser;
      this.step = step;
    }
    feed(input) {
      return InvokeOperatorParser.parse(input, this.recon, this.builder, this.exprParser, this.argsParser, this.step);
    }
    static parse(input, recon, builder, exprParser, argsParser, step = 1) {
      let c = 0;
      if (step === 1) {
        if (exprParser === void 0) {
          exprParser = recon.parsePrimary(input, builder);
        }
        while (exprParser.isCont() && !input.isEmpty()) {
          exprParser = exprParser.feed(input);
        }
        if (exprParser.isDone()) {
          step = 2;
        } else if (exprParser.isError()) {
          return exprParser.asError();
        }
      }
      do {
        if (step === 2) {
          while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
            input = input.step();
          }
          if (input.isCont()) {
            if (c === 40) {
              input = input.step();
              step = 3;
            } else {
              return exprParser;
            }
          } else if (input.isDone()) {
            return exprParser;
          }
        }
        if (step === 3) {
          while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
            input = input.step();
          }
          if (input.isCont()) {
            if (c === 41) {
              input = input.step();
              const expr = exprParser.bind();
              exprParser = Parser.done(recon.invoke(expr, recon.extant()));
              step = 2;
              continue;
            } else {
              step = 4;
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.expected(41, input));
          }
        }
        if (step === 4) {
          if (argsParser === void 0) {
            argsParser = recon.parseBlock(input);
          }
          while (argsParser.isCont() && !input.isEmpty()) {
            argsParser = argsParser.feed(input);
          }
          if (argsParser.isDone()) {
            step = 5;
          } else if (argsParser.isError()) {
            return argsParser.asError();
          }
        }
        if (step === 5) {
          while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
            input = input.step();
          }
          if (input.isCont()) {
            if (c === 41) {
              input = input.step();
              const expr = exprParser.bind();
              const args = argsParser.bind();
              exprParser = Parser.done(recon.invoke(expr, args));
              argsParser = void 0;
              step = 2;
              continue;
            } else {
              return Parser.error(Diagnostic.expected(41, input));
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.expected(41, input));
          }
        }
        break;
      } while (true);
      return new InvokeOperatorParser(recon, builder, exprParser, argsParser, step);
    }
  }
  class PrimaryParser extends Parser {
    constructor(recon, builder, exprParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.exprParser = exprParser;
      this.step = step;
    }
    feed(input) {
      return PrimaryParser.parse(input, this.recon, this.builder, this.exprParser, this.step);
    }
    static parse(input, recon, builder, exprParser, step = 1) {
      let c = 0;
      if (step === 1) {
        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 40) {
            input = input.step();
            step = 3;
          } else {
            step = 2;
          }
        } else if (input.isDone()) {
          step = 2;
        }
      }
      if (step === 2) {
        if (exprParser === void 0) {
          exprParser = recon.parseLiteral(input, builder);
        }
        while (exprParser.isCont() && !input.isEmpty()) {
          exprParser = exprParser.feed(input);
        }
        if (exprParser.isDone()) {
          return exprParser;
        } else if (exprParser.isError()) {
          return exprParser.asError();
        }
      }
      if (step === 3) {
        if (exprParser === void 0) {
          exprParser = recon.parseBlockExpression(input, builder);
        }
        while (exprParser.isCont() && !input.isEmpty()) {
          exprParser = exprParser.feed(input);
        }
        if (exprParser.isDone()) {
          step = 4;
        } else if (exprParser.isError()) {
          return exprParser.asError();
        }
      }
      do {
        if (step === 4) {
          while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
            input = input.step();
          }
          if (input.isCont()) {
            if (c === 44) {
              input = input.step();
              if (exprParser !== void 0) {
                if (builder === void 0) {
                  builder = recon.recordBuilder();
                  builder.push(recon.item(exprParser.bind()));
                }
                exprParser = void 0;
              }
              step = 5;
            } else if (c === 41) {
              input = input.step();
              if (exprParser !== void 0) {
                return exprParser;
              } else {
                return Parser.done(builder.bind());
              }
            } else {
              return Parser.error(Diagnostic.expected(41, input));
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.expected(41, input));
          }
        }
        if (step === 5) {
          if (exprParser === void 0) {
            exprParser = recon.parseBlockExpression(input, builder);
          }
          while (exprParser.isCont() && !input.isEmpty()) {
            exprParser = exprParser.feed(input);
          }
          if (exprParser.isDone()) {
            exprParser = void 0;
            step = 4;
            continue;
          } else if (exprParser.isError()) {
            return exprParser.asError();
          }
        }
        break;
      } while (true);
      return new PrimaryParser(recon, builder, exprParser, step);
    }
  }
  class LiteralParser extends Parser {
    constructor(recon, builder, valueParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.valueParser = valueParser;
      this.step = step;
    }
    feed(input) {
      return LiteralParser.parse(input, this.recon, this.builder, this.valueParser, this.step);
    }
    static parse(input, recon, builder, valueParser, step = 1) {
      let c = 0;
      if (step === 1) {
        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 40) {
            input = input.step();
            step = 4;
          } else if (c === 123) {
            builder = builder || recon.recordBuilder();
            valueParser = recon.parseRecord(input, builder);
            step = 3;
          } else if (c === 91) {
            builder = builder || recon.recordBuilder();
            valueParser = recon.parseMarkup(input, builder);
            step = 3;
          } else if (Recon.isIdentStartChar(c)) {
            valueParser = recon.parseIdent(input);
            step = 2;
          } else if (c === 34 || c === 39) {
            valueParser = recon.parseString(input);
            step = 2;
          } else if (c === 96) {
            valueParser = recon.parseRawString(input);
            step = 2;
          } else if (c === 45 || c >= 48 && c <= 57) {
            valueParser = recon.parseNumber(input);
            step = 2;
          } else if (c === 37) {
            valueParser = recon.parseData(input);
            step = 2;
          } else if (c === 36) {
            valueParser = recon.parseSelector(input);
            step = 2;
          } else if (builder === void 0) {
            return Parser.done(recon.extant());
          } else {
            return Parser.done(builder.bind());
          }
        } else if (input.isDone()) {
          if (builder === void 0) {
            return Parser.done(recon.extant());
          } else {
            return Parser.done(builder.bind());
          }
        }
      }
      if (step === 2) {
        while (valueParser.isCont() && !input.isEmpty()) {
          valueParser = valueParser.feed(input);
        }
        if (valueParser.isDone()) {
          builder = builder || recon.valueBuilder();
          builder.push(recon.item(valueParser.bind()));
          return Parser.done(builder.bind());
        } else if (valueParser.isError()) {
          return valueParser.asError();
        }
      }
      if (step === 3) {
        while (valueParser.isCont() && !input.isEmpty()) {
          valueParser = valueParser.feed(input);
        }
        if (valueParser.isDone()) {
          return Parser.done(builder.bind());
        } else if (valueParser.isError()) {
          return valueParser.asError();
        }
      }
      if (step === 4) {
        if (valueParser === void 0) {
          valueParser = recon.parseBlockExpression(input);
        }
        while (valueParser.isCont() && !input.isEmpty()) {
          valueParser = valueParser.feed(input);
        }
        if (valueParser.isDone()) {
          step = 5;
        } else if (valueParser.isError()) {
          return valueParser.asError();
        }
      }
      if (step === 5) {
        while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 41) {
            input = input.step();
            builder = builder || recon.valueBuilder();
            builder.push(recon.item(valueParser.bind()));
            return Parser.done(builder.bind());
          } else {
            return Parser.error(Diagnostic.expected(41, input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected(41, input));
        }
      }
      return new LiteralParser(recon, builder, valueParser, step);
    }
  }
  class SelectorParser extends Parser {
    constructor(recon, builder, selector, valueParser, step) {
      super();
      this.recon = recon;
      this.builder = builder;
      this.selector = selector;
      this.valueParser = valueParser;
      this.step = step;
    }
    feed(input) {
      return SelectorParser.parse(input, this.recon, this.builder, this.selector, this.valueParser, this.step);
    }
    static parse(input, recon, builder, selector, valueParser, step = 1) {
      let c = 0;
      if (step === 1) {
        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont() && c === 36) {
          input = input.step();
          selector = selector || recon.selector();
          step = 2;
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.expected(36, input));
        }
      }
      if (step === 2) {
        if (input.isCont()) {
          c = input.head();
          if (c === 91) {
            input = input.step();
            step = 8;
          } else if (c === 64) {
            input = input.step();
            step = 7;
          } else if (c === 58) {
            input = input.step();
            step = 6;
          } else if (c === 42) {
            input = input.step();
            step = 5;
          } else if (c === 35) {
            input = input.step();
            step = 4;
          } else {
            step = 3;
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      do {
        if (step === 3) {
          if (valueParser === void 0) {
            valueParser = recon.parseLiteral(input, recon.valueBuilder());
          }
          while (valueParser.isCont() && !input.isEmpty()) {
            valueParser = valueParser.feed(input);
          }
          if (valueParser.isDone()) {
            selector = recon.get(selector, valueParser.bind());
            valueParser = void 0;
            step = 10;
          } else if (valueParser.isError()) {
            return valueParser.asError();
          }
        }
        if (step === 4) {
          if (valueParser === void 0) {
            valueParser = recon.parseInteger(input);
          }
          while (valueParser.isCont() && !input.isEmpty()) {
            valueParser = valueParser.feed(input);
          }
          if (valueParser.isDone()) {
            selector = recon.value(recon.getItem(selector, valueParser.bind()));
            valueParser = void 0;
            step = 10;
          } else if (valueParser.isError()) {
            return valueParser.asError();
          }
        }
        if (step === 5) {
          if (input.isCont()) {
            c = input.head();
            if (c === 58) {
              input = input.step();
              selector = recon.keys(selector);
              step = 10;
            } else if (c === 42) {
              input = input.step();
              selector = recon.descendants(selector);
              step = 10;
            } else {
              selector = recon.children(selector);
              step = 10;
            }
          } else if (input.isDone()) {
            selector = recon.children(selector);
            step = 10;
          }
        }
        if (step === 6) {
          if (input.isCont()) {
            c = input.head();
            if (c === 42) {
              input = input.step();
              selector = recon.values(selector);
              step = 10;
            } else {
              return Parser.error(Diagnostic.expected(42, input));
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.expected(42, input));
          }
        }
        if (step === 7) {
          if (valueParser === void 0) {
            valueParser = recon.parseIdent(input);
          }
          while (valueParser.isCont() && !input.isEmpty()) {
            valueParser = valueParser.feed(input);
          }
          if (valueParser.isDone()) {
            selector = recon.getAttr(selector, valueParser.bind());
            valueParser = void 0;
            step = 10;
          } else if (valueParser.isError()) {
            return valueParser.asError();
          }
        }
        if (step === 8) {
          if (valueParser === void 0) {
            valueParser = recon.parseBlockExpression(input);
          }
          while (valueParser.isCont() && !input.isEmpty()) {
            valueParser = valueParser.feed(input);
          }
          if (valueParser.isDone()) {
            step = 9;
          } else if (valueParser.isError()) {
            return valueParser.asError();
          }
        }
        if (step === 9) {
          while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
            input = input.step();
          }
          if (input.isCont()) {
            if (c === 93) {
              input = input.step();
              selector = recon.filter(selector, valueParser.bind());
              valueParser = void 0;
              step = 10;
            } else {
              return Parser.error(Diagnostic.expected(93, input));
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.expected(93, input));
          }
        }
        if (step === 10) {
          if (input.isCont()) {
            c = input.head();
            if (c === 91) {
              input = input.step();
              step = 8;
              continue;
            } else if (c === 35) {
              input = input.step();
              step = 4;
              continue;
            } else if (c === 46) {
              input = input.step();
              step = 11;
            } else if (builder !== void 0) {
              builder.push(recon.item(selector));
              return Parser.done(builder.bind());
            } else {
              return Parser.done(selector);
            }
          } else if (input.isDone()) {
            if (builder !== void 0) {
              builder.push(recon.item(selector));
              return Parser.done(builder.bind());
            } else {
              return Parser.done(selector);
            }
          }
        }
        if (step === 11) {
          if (input.isCont()) {
            c = input.head();
            if (c === 64) {
              input = input.step();
              step = 7;
              continue;
            } else if (c === 58) {
              input = input.step();
              step = 6;
              continue;
            } else if (c === 42) {
              input = input.step();
              step = 5;
              continue;
            } else {
              step = 3;
              continue;
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.unexpected(input));
          }
        }
        break;
      } while (true);
      return new SelectorParser(recon, builder, selector, valueParser, step);
    }
  }
  class ReconParser {
    parseBlock(input) {
      return BlockParser.parse(input, this);
    }
    parseAttr(input) {
      return AttrParser.parse(input, this);
    }
    parseBlockItem(input) {
      return BlockItemParser.parse(input, this);
    }
    parseInlineItem(input) {
      return InlineItemParser.parse(input, this);
    }
    parseRecord(input, builder) {
      return RecordParser.parse(input, this, builder);
    }
    parseMarkup(input, builder) {
      return MarkupParser.parse(input, this, builder);
    }
    parseData(input) {
      return DataParser.parse(input, this);
    }
    parseIdent(input) {
      return IdentParser.parse(input, this);
    }
    parseString(input) {
      return StringParser.parse(input, this);
    }
    parseRawString(input) {
      return RawStringParser.parse(input, this);
    }
    parseNumber(input) {
      return NumberParser.parse(input, this);
    }
    parseInteger(input) {
      return NumberParser.parseInteger(input, this);
    }
    parseBlockExpression(input, builder) {
      return this.parseLambdaFunc(input, builder);
    }
    parseLambdaFunc(input, builder) {
      return LambdaFuncParser.parse(input, this, builder);
    }
    parseConditionalOperator(input, builder) {
      return ConditionalOperatorParser.parse(input, this, builder);
    }
    parseOrOperator(input, builder) {
      return OrOperatorParser.parse(input, this, builder);
    }
    parseAndOperator(input, builder) {
      return AndOperatorParser.parse(input, this, builder);
    }
    parseBitwiseOrOperator(input, builder) {
      return BitwiseOrOperatorParser.parse(input, this, builder);
    }
    parseBitwiseXorOperator(input, builder) {
      return BitwiseXorOperatorParser.parse(input, this, builder);
    }
    parseBitwiseAndOperator(input, builder) {
      return BitwiseAndOperatorParser.parse(input, this, builder);
    }
    parseComparisonOperator(input, builder) {
      return ComparisonOperatorParser.parse(input, this, builder);
    }
    parseAttrExpression(input, builder) {
      return AttrExpressionParser.parse(input, this, builder);
    }
    parseAdditiveOperator(input, builder) {
      return AdditiveOperatorParser.parse(input, this, builder);
    }
    parseMultiplicativeOperator(input, builder) {
      return MultiplicativeOperatorParser.parse(input, this, builder);
    }
    parsePrefixOperator(input, builder) {
      return PrefixOperatorParser.parse(input, this, builder);
    }
    parseInvokeOperator(input, builder) {
      return InvokeOperatorParser.parse(input, this, builder);
    }
    parsePrimary(input, builder) {
      return PrimaryParser.parse(input, this, builder);
    }
    parseLiteral(input, builder) {
      return LiteralParser.parse(input, this, builder);
    }
    parseSelector(input, builder) {
      return SelectorParser.parse(input, this, builder);
    }
    blockParser() {
      return new BlockParser(this);
    }
    parseBlockString(string) {
      let input = Unicode.stringInput(string);
      while (input.isCont() && Recon.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = this.parseBlock(input);
      if (parser.isDone()) {
        while (input.isCont() && Recon.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
  }
  class ReconStructureParser extends ReconParser {
    isDistinct(value) {
      return value.isDistinct();
    }
    item(value) {
      return value;
    }
    value(item) {
      return item.toValue();
    }
    attr(key, value) {
      if (arguments.length === 1) {
        return Attr.of(key);
      } else {
        return Attr.of(key, value);
      }
    }
    slot(key, value) {
      if (arguments.length === 1) {
        return Slot.of(key);
      } else {
        return Slot.of(key, value);
      }
    }
    valueBuilder() {
      return Value.builder();
    }
    recordBuilder() {
      return Record.create();
    }
    dataOutput() {
      return Data.output();
    }
    textOutput() {
      return Text.output();
    }
    ident(value) {
      if (value instanceof Text) {
        const string = value.stringValue();
        if (string === "true") {
          return Bool.from(true);
        } else if (string === "false") {
          return Bool.from(false);
        }
      }
      return value;
    }
    num(value) {
      if (typeof value === "number") {
        return Num.from(value);
      } else if (typeof value === "string") {
        return Num.from(+value);
      } else {
        throw new TypeError("" + value);
      }
    }
    uint32(value) {
      return Num.uint32(value);
    }
    uint64(value) {
      return Num.uint64(value);
    }
    bool(value) {
      return Bool.from(value);
    }
    selector() {
      return Selector.identity();
    }
    extant() {
      return Value.extant();
    }
    absent() {
      return Value.absent();
    }
    conditional(ifTerm, thenTerm, elseTerm) {
      return ifTerm.conditional(thenTerm, elseTerm);
    }
    or(lhs, rhs) {
      return new OrOperator(lhs, rhs);
    }
    and(lhs, rhs) {
      return new AndOperator(lhs, rhs);
    }
    bitwiseOr(lhs, rhs) {
      return new BitwiseOrOperator(lhs, rhs);
    }
    bitwiseXor(lhs, rhs) {
      return new BitwiseXorOperator(lhs, rhs);
    }
    bitwiseAnd(lhs, rhs) {
      return new BitwiseAndOperator(lhs, rhs);
    }
    lt(lhs, rhs) {
      return new LtOperator(lhs, rhs);
    }
    le(lhs, rhs) {
      return new LeOperator(lhs, rhs);
    }
    eq(lhs, rhs) {
      return new EqOperator(lhs, rhs);
    }
    ne(lhs, rhs) {
      return new NeOperator(lhs, rhs);
    }
    ge(lhs, rhs) {
      return new GeOperator(lhs, rhs);
    }
    gt(lhs, rhs) {
      return new GtOperator(lhs, rhs);
    }
    plus(lhs, rhs) {
      return new PlusOperator(lhs, rhs);
    }
    minus(lhs, rhs) {
      return new MinusOperator(lhs, rhs);
    }
    times(lhs, rhs) {
      return new TimesOperator(lhs, rhs);
    }
    divide(lhs, rhs) {
      return new DivideOperator(lhs, rhs);
    }
    modulo(lhs, rhs) {
      return new ModuloOperator(lhs, rhs);
    }
    not(rhs) {
      return new NotOperator(rhs);
    }
    bitwiseNot(rhs) {
      return new BitwiseNotOperator(rhs);
    }
    negative(rhs) {
      if (rhs instanceof Num) {
        return rhs.negative();
      } else {
        return new NegativeOperator(rhs);
      }
    }
    positive(rhs) {
      return new PositiveOperator(rhs);
    }
    invoke(func, args) {
      return new InvokeOperator(func, args);
    }
    lambda(bindings, template) {
      return bindings.lambda(template);
    }
    get(selector, key) {
      return selector.get(key);
    }
    getAttr(selector, key) {
      return selector.getAttr(key);
    }
    getItem(selector, index) {
      return selector.getItem(index);
    }
    children(selector) {
      return Selector.literal(selector).children();
    }
    descendants(selector) {
      return Selector.literal(selector).descendants();
    }
    keys(selector) {
      return Selector.literal(selector).keys();
    }
    values(selector) {
      return Selector.literal(selector).values();
    }
    filter(selector, predicate) {
      return selector.filter(predicate);
    }
  }
  class AttrWriter extends Writer {
    constructor(recon, key, value, part, step) {
      super();
      this.recon = recon;
      this.key = key;
      this.value = value;
      this.part = part;
      this.step = step;
    }
    pull(output) {
      return AttrWriter.write(output, this.recon, this.key, this.value, this.part, this.step);
    }
    static sizeOf(recon, key, value) {
      let size = 0;
      size += 1;
      size += recon.sizeOfValue(key);
      if (!recon.isExtant(recon.item(value))) {
        size += 1;
        size += recon.sizeOfBlockValue(value);
        size += 1;
      }
      return size;
    }
    static write(output, recon, key, value, part, step = 1) {
      if (step === 1 && output.isCont()) {
        output = output.write(64);
        step = 2;
      }
      if (step === 2) {
        if (part === void 0) {
          part = recon.writeValue(output, key);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          part = void 0;
          if (recon.isExtant(recon.item(value))) {
            return Writer.end();
          } else {
            step = 3;
          }
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (step === 3 && output.isCont()) {
        output = output.write(40);
        step = 4;
      }
      if (step === 4) {
        if (part === void 0) {
          part = recon.writeBlockValue(output, value);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          part = void 0;
          step = 5;
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (step === 5 && output.isCont()) {
        output = output.write(41);
        return Writer.end();
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new AttrWriter(recon, key, value, part, step);
    }
  }
  class SlotWriter extends Writer {
    constructor(recon, key, value, part, step) {
      super();
      this.recon = recon;
      this.key = key;
      this.value = value;
      this.part = part;
      this.step = step;
    }
    pull(output) {
      return SlotWriter.write(output, this.recon, this.key, this.value, this.part, this.step);
    }
    static sizeOf(recon, key, value) {
      let size = 0;
      size += recon.sizeOfValue(key);
      size += 1;
      if (!recon.isExtant(recon.item(value))) {
        size += recon.sizeOfValue(value);
      }
      return size;
    }
    static write(output, recon, key, value, part, step = 1) {
      if (step === 1) {
        if (part === void 0) {
          part = recon.writeValue(output, key);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          part = void 0;
          step = 2;
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (step === 2 && output.isCont()) {
        output = output.write(58);
        if (recon.isExtant(recon.item(value))) {
          return Writer.end();
        } else {
          step = 3;
        }
      }
      if (step === 3) {
        if (part === void 0) {
          part = recon.writeValue(output, value);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          return Writer.end();
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new SlotWriter(recon, key, value, part, step);
    }
  }
  class BlockWriter extends Writer {
    constructor(recon, items, inBlock, inMarkup, inBraces, inBrackets, first, markupSafe, item, next, part, step) {
      super();
      this.recon = recon;
      this.items = items;
      this.inBlock = inBlock;
      this.inMarkup = inMarkup;
      this.inBraces = inBraces;
      this.inBrackets = inBrackets;
      this.first = first;
      this.markupSafe = markupSafe;
      this.item = item;
      this.next = next;
      this.part = part;
      this.step = step;
    }
    pull(output) {
      return BlockWriter.write(output, this.recon, this.items, this.inBlock, this.inMarkup, this.inBraces, this.inBrackets, this.first, this.markupSafe, this.item, this.next, this.part, this.step);
    }
    static sizeOf(recon, items, inBlock, inMarkup) {
      let size = 0;
      let inBraces = false;
      let inBrackets = false;
      let first = true;
      let markupSafe = true;
      let next;
      while (next !== void 0 || items.hasNext()) {
        let item;
        if (next === void 0) {
          item = items.next().value;
        } else {
          item = next;
          next = void 0;
        }
        if (items.hasNext()) {
          next = items.next().value;
        }
        if (recon.isExpression(item)) {
          markupSafe = false;
        }
        if (inBrackets && recon.isAttr(item)) {
          if (inBraces) {
            size += 1;
            inBraces = false;
          }
          size += 1;
          inBrackets = false;
        }
        if (recon.isAttr(item)) {
          if (inBraces) {
            size += 1;
            inBraces = false;
          } else if (inBrackets) {
            size += 1;
            inBrackets = false;
          }
          size += recon.sizeOfItem(item);
          first = false;
        } else if (inBrackets && recon.isText(item)) {
          if (inBraces) {
            size += 1;
            inBraces = false;
          }
          size += recon.sizeOfMarkupText(item);
        } else if (inBraces) {
          if (!first) {
            size += 1;
          } else {
            first = false;
          }
          size += BlockWriter.sizeOfBlockItem(recon, item);
        } else if (inBrackets) {
          if (recon.isRecord(item) && recon.isMarkupSafe(recon.items(item))) {
            size += recon.sizeOfBlock(recon.items(item), false, true);
            if (next !== void 0 && recon.isText(next)) {
              size += recon.sizeOfMarkupText(next);
              next = void 0;
            } else if (next !== void 0 && !recon.isAttr(next)) {
              size += 1;
              inBraces = true;
              first = true;
            } else {
              size += 1;
              inBrackets = false;
            }
          } else {
            size += 1;
            size += recon.sizeOfItem(item);
            inBraces = true;
            first = false;
          }
        } else if (markupSafe && recon.isText(item) && next !== void 0 && !recon.isField(next) && !recon.isText(next) && !recon.isBool(next)) {
          size += 1;
          size += recon.sizeOfMarkupText(item);
          inBrackets = true;
        } else if (inBlock && !inBraces) {
          if (!first) {
            size += 1;
          } else {
            first = false;
          }
          size += BlockWriter.sizeOfBlockItem(recon, item);
        } else if (inMarkup && recon.isText(item) && next === void 0) {
          size += 1;
          size += recon.sizeOfMarkupText(item);
          size += 1;
        } else if (!inMarkup && recon.isValue(item) && !recon.isRecord(item) && (!first && next === void 0 || next !== void 0 && recon.isAttr(next))) {
          if (!first && (recon.isText(item) && recon.isIdent(item) || recon.isNum(item) || recon.isBool(item))) {
            size += 1;
          }
          size += recon.sizeOfItem(item);
        } else {
          size += 1;
          size += recon.sizeOfItem(item);
          inBraces = true;
          first = false;
        }
      }
      if (inBraces) {
        size += 1;
      }
      if (inBrackets) {
        size += 1;
      }
      return size;
    }
    static sizeOfBlockItem(recon, item) {
      let size = 0;
      if (recon.isField(item)) {
        size += recon.sizeOfSlot(recon.key(item), recon.value(item));
      } else {
        size += recon.sizeOfItem(item);
      }
      return size;
    }
    static write(output, recon, items, inBlock, inMarkup, inBraces = false, inBrackets = false, first = true, markupSafe = true, item, next, part, step = 1) {
      do {
        if (step === 1) {
          if (next === void 0 && !items.hasNext()) {
            step = 10;
            break;
          } else {
            if (next === void 0) {
              item = items.next().value;
            } else {
              item = next;
              next = void 0;
            }
            if (items.hasNext()) {
              next = items.next().value;
            }
            if (recon.isExpression(item)) {
              markupSafe = false;
            }
            step = 2;
          }
        }
        if (step === 2 && output.isCont()) {
          if (inBrackets && recon.isAttr(item)) {
            if (inBraces) {
              output = output.write(125);
              inBraces = false;
            }
            step = 3;
          } else {
            step = 4;
          }
        }
        if (step === 3 && output.isCont()) {
          output = output.write(93);
          inBrackets = false;
          step = 4;
        }
        if (step === 4 && output.isCont()) {
          if (recon.isAttr(item)) {
            if (inBraces) {
              output = output.write(125);
              inBraces = false;
            } else if (inBrackets) {
              output = output.write(93);
              inBrackets = false;
            }
            part = recon.writeItem(output, item);
            first = false;
            step = 7;
          } else if (inBrackets && recon.isText(item)) {
            if (inBraces) {
              output = output.write(125);
              inBraces = false;
            }
            part = recon.writeMarkupText(output, item);
            step = 7;
          } else if (inBraces) {
            if (!first) {
              output = output.write(44);
            } else {
              first = false;
            }
            part = BlockWriter.writeBlockItem(output, recon, item);
            step = 7;
          } else if (inBrackets) {
            if (recon.isRecord(item) && recon.isMarkupSafe(recon.items(item))) {
              part = recon.writeBlock(output, recon.items(item), false, true);
              step = 5;
            } else {
              output = output.write(123);
              part = recon.writeItem(output, item);
              inBraces = true;
              first = false;
              step = 7;
            }
          } else if (markupSafe && recon.isText(item) && next !== void 0 && !recon.isField(next) && !recon.isText(next) && !recon.isBool(next)) {
            output = output.write(91);
            part = recon.writeMarkupText(output, item);
            inBrackets = true;
            step = 7;
          } else if (inBlock && !inBraces) {
            if (!first) {
              output = output.write(44);
            } else {
              first = false;
            }
            part = BlockWriter.writeBlockItem(output, recon, item);
            step = 7;
          } else if (inMarkup && recon.isText(item) && next === void 0) {
            output = output.write(91);
            part = recon.writeMarkupText(output, item);
            step = 8;
          } else if (!inMarkup && recon.isValue(item) && !recon.isRecord(item) && (!first && next === void 0 || next !== void 0 && recon.isAttr(next))) {
            if (!first && (recon.isText(item) && recon.isIdent(item) || recon.isNum(item) || recon.isBool(item))) {
              output = output.write(32);
            }
            part = recon.writeItem(output, item);
            step = 7;
          } else {
            output = output.write(123);
            part = recon.writeItem(output, item);
            inBraces = true;
            first = false;
            step = 7;
          }
        }
        if (step === 5) {
          part = part.pull(output);
          if (part.isDone()) {
            part = void 0;
            step = 6;
          } else if (part.isError()) {
            return part.asError();
          }
        }
        if (step === 6 && output.isCont()) {
          if (next !== void 0 && recon.isText(next)) {
            part = recon.writeMarkupText(output, next);
            next = void 0;
            step = 7;
          } else if (next !== void 0 && !recon.isAttr(next)) {
            output = output.write(123);
            inBraces = true;
            first = true;
            step = 1;
            continue;
          } else {
            output = output.write(93);
            inBrackets = false;
            step = 1;
            continue;
          }
        }
        if (step === 7) {
          part = part.pull(output);
          if (part.isDone()) {
            part = void 0;
            step = 1;
            continue;
          } else if (part.isError()) {
            return part.asError();
          }
        }
        if (step === 8) {
          part = part.pull(output);
          if (part.isDone()) {
            part = void 0;
            step = 9;
          } else if (part.isError()) {
            return part.asError();
          }
        }
        if (step === 9 && output.isCont()) {
          output = output.write(93);
          step = 1;
          continue;
        }
        break;
      } while (true);
      if (step === 10) {
        if (inBraces) {
          if (output.isCont()) {
            output = output.write(125);
            step = 11;
          }
        } else {
          step = 11;
        }
      }
      if (step === 11) {
        if (inBrackets) {
          if (output.isCont()) {
            output = output.write(93);
            return Writer.end();
          }
        } else {
          return Writer.end();
        }
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new BlockWriter(recon, items, inBlock, inMarkup, inBraces, inBrackets, first, markupSafe, item, next, part, step);
    }
    static writeBlockItem(output, recon, item) {
      if (recon.isField(item)) {
        return recon.writeSlot(output, recon.key(item), recon.value(item));
      } else {
        return recon.writeItem(output, item);
      }
    }
  }
  class PrimaryWriter extends Writer {
    constructor(recon, items, inParens, first, item, next, part, step) {
      super();
      this.recon = recon;
      this.items = items;
      this.inParens = inParens;
      this.first = first;
      this.item = item;
      this.next = next;
      this.part = part;
      this.step = step;
    }
    pull(output) {
      return PrimaryWriter.write(output, this.recon, this.items, this.inParens, this.first, this.item, this.next, this.part, this.step);
    }
    static sizeOf(recon, items) {
      let size = 0;
      let inParens = false;
      let first = true;
      let next;
      while (next !== void 0 || items.hasNext()) {
        let item;
        if (next === void 0) {
          item = items.next().value;
        } else {
          item = next;
          next = void 0;
        }
        if (items.hasNext()) {
          next = items.next().value;
        }
        if (!inParens && !first) {
          size += 1;
        }
        if (recon.isAttr(item)) {
          if (inParens) {
            size += 1;
            inParens = false;
          }
          size += recon.sizeOfItem(item);
          first = false;
        } else if (inParens) {
          if (!first) {
            size += 1;
          } else {
            first = false;
          }
          size += recon.sizeOfBlockItem(item);
        } else if (recon.isValue(item) && !recon.isRecord(item) && (!first && next === void 0 || next !== void 0 && recon.isAttr(next))) {
          size += recon.sizeOfItem(item);
        } else {
          size += 1;
          size += recon.sizeOfItem(item);
          inParens = true;
          first = false;
        }
      }
      if (inParens) {
        size += 1;
      }
      return size;
    }
    static write(output, recon, items, inParens = false, first = true, item, next, part, step = 1) {
      do {
        if (step === 1) {
          if (next === void 0 && !items.hasNext()) {
            step = 5;
            break;
          } else {
            if (next === void 0) {
              item = items.next().value;
            } else {
              item = next;
              next = void 0;
            }
            if (items.hasNext()) {
              next = items.next().value;
            }
            step = 2;
          }
        }
        if (step === 2 && output.isCont()) {
          if (!inParens && !first) {
            output = output.write(32);
          }
          step = 3;
        }
        if (step === 3 && output.isCont()) {
          if (recon.isAttr(item)) {
            if (inParens) {
              output = output.write(41);
              inParens = false;
            }
            part = recon.writeItem(output, item);
            first = false;
            step = 4;
          } else if (inParens) {
            if (!first) {
              output = output.write(44);
            } else {
              first = false;
            }
            part = recon.writeBlockItem(output, item);
            step = 4;
          } else if (recon.isValue(item) && !recon.isRecord(item) && (!first && next === void 0 || next !== void 0 && recon.isAttr(next))) {
            part = recon.writeItem(output, item);
            step = 4;
          } else {
            output = output.write(40);
            part = recon.writeItem(output, item);
            inParens = true;
            first = false;
            step = 4;
          }
        }
        if (step === 4) {
          part = part.pull(output);
          if (part.isDone()) {
            part = void 0;
            step = 1;
            continue;
          } else if (part.isError()) {
            return part.asError();
          }
        }
        break;
      } while (true);
      if (step === 5) {
        if (inParens) {
          if (output.isCont()) {
            output = output.write(41);
            return Writer.end();
          }
        } else {
          return Writer.end();
        }
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new PrimaryWriter(recon, items, inParens, first, item, next, part, step);
    }
  }
  class MarkupTextWriter extends Writer {
    constructor(text, index, escape, step) {
      super();
      this.text = text;
      this.index = index;
      this.escape = escape;
      this.step = step;
    }
    pull(output) {
      return MarkupTextWriter.write(output, this.text, this.index, this.escape, this.step);
    }
    static sizeOf(text) {
      let size = 0;
      for (let i = 0, n = text.length; i < n; i = Strings.offsetByCodePoints(text, i, 1)) {
        let c = text.codePointAt(i);
        if (c === void 0) {
          c = text.charCodeAt(i);
        }
        if (c === 36 || c === 64 || c === 91 || c === 92 || c === 93 || c === 123 || c === 125 || c === 8 || c === 12 || c === 10 || c === 13 || c === 9) {
          size += 2;
        } else if (c < 32) {
          size += 6;
        } else {
          size += Utf8.sizeOf(c);
        }
      }
      return size;
    }
    static write(output, text, index = 0, escape = 0, step = 1) {
      const length = text.length;
      while (output.isCont()) {
        if (step === 1) {
          if (index < length) {
            let c = text.codePointAt(index);
            if (c === void 0) {
              c = text.charCodeAt(index);
            }
            index = Strings.offsetByCodePoints(text, index, 1);
            if (c === 36 || c === 64 || c === 91 || c === 92 || c === 93 || c === 123 || c === 125) {
              output = output.write(92);
              escape = c;
              step = 2;
            } else if (c === 8) {
              output = output.write(92);
              escape = 98;
              step = 2;
            } else if (c === 12) {
              output = output.write(92);
              escape = 102;
              step = 2;
            } else if (c === 10) {
              output = output.write(92);
              escape = 110;
              step = 2;
            } else if (c === 13) {
              output = output.write(92);
              escape = 114;
              step = 2;
            } else if (c === 9) {
              output = output.write(92);
              escape = 116;
              step = 2;
            } else if (c < 32) {
              output = output.write(92);
              escape = c;
              step = 3;
            } else {
              output = output.write(c);
            }
          } else {
            return Writer.end();
          }
        } else if (step === 2) {
          output = output.write(escape);
          escape = 0;
          step = 1;
        } else if (step === 3) {
          output = output.write(117);
          step = 4;
        } else if (step === 4) {
          output = output.write(Base16.uppercase.encodeDigit(escape >>> 12 & 15));
          step = 5;
        } else if (step === 5) {
          output = output.write(Base16.uppercase.encodeDigit(escape >>> 8 & 15));
          step = 6;
        } else if (step === 6) {
          output = output.write(Base16.uppercase.encodeDigit(escape >>> 4 & 15));
          step = 7;
        } else if (step === 7) {
          output = output.write(Base16.uppercase.encodeDigit(escape & 15));
          escape = 0;
          step = 1;
        }
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new MarkupTextWriter(text, index, escape, step);
    }
  }
  class DataWriter extends Writer {
    constructor(array, part, step) {
      super();
      this.array = array;
      this.part = part;
      this.step = step;
    }
    pull(output) {
      return DataWriter.write(output, this.array, this.part, this.step);
    }
    static sizeOf(length) {
      return 1 + (Math.floor(length * 4 / 3) + 3 & ~3);
    }
    static write(output, array, part, step = 1) {
      if (step === 1 && output.isCont()) {
        output = output.write(37);
        step = 2;
      }
      if (step === 2) {
        if (part === void 0) {
          part = Base64.standard().writeUint8Array(output, array);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          part = void 0;
          return Writer.end();
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new DataWriter(array, part, step);
    }
  }
  class IdentWriter extends Writer {
    constructor(ident, index) {
      super();
      this.ident = ident;
      this.index = index;
    }
    pull(output) {
      return IdentWriter.write(output, this.ident, this.index);
    }
    static sizeOf(ident) {
      return Utf8.sizeOf(ident);
    }
    static write(output, ident, index = 0) {
      let c;
      const length = ident.length;
      if (length === 0) {
        return Writer.error(new WriterException("empty identifier"));
      }
      if (index === 0 && output.isCont()) {
        c = ident.codePointAt(0);
        if (c === void 0) {
          c = ident.charCodeAt(0);
        }
        if (Recon.isIdentStartChar(c)) {
          output = output.write(c);
          index = Strings.offsetByCodePoints(ident, 0, 1);
        }
      }
      while (index < length && output.isCont()) {
        c = ident.codePointAt(index);
        if (c === void 0) {
          c = ident.charCodeAt(index);
        }
        if (Recon.isIdentChar(c)) {
          output = output.write(c);
          index = Strings.offsetByCodePoints(ident, index, 1);
        } else {
          return Writer.error(new WriterException("invalid identifier"));
        }
      }
      if (index >= length) {
        return Writer.end();
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new IdentWriter(ident, index);
    }
  }
  class StringWriter extends Writer {
    constructor(string, index, escape, step) {
      super();
      this.string = string;
      this.index = index;
      this.escape = escape;
      this.step = step;
    }
    pull(output) {
      return StringWriter.write(output, this.string, this.index, this.escape, this.step);
    }
    static sizeOf(string) {
      let size = 0;
      size += 1;
      for (let i = 0, n = string.length; i < n; i = Strings.offsetByCodePoints(string, i, 1)) {
        let c = string.codePointAt(i);
        if (c === void 0) {
          c = string.charCodeAt(i);
        }
        if (c === 34 || c === 92 || c === 8 || c === 12 || c === 10 || c === 13 || c === 9) {
          size += 2;
        } else if (c < 32) {
          size += 6;
        } else {
          size += Utf8.sizeOf(c);
        }
      }
      size += 1;
      return size;
    }
    static write(output, string, index = 0, escape = 0, step = 1) {
      if (step === 1 && output.isCont()) {
        output = output.write(34);
        step = 2;
      }
      const length = string.length;
      while (step >= 2 && step <= 8 && output.isCont()) {
        if (step === 2) {
          if (index < length) {
            let c = string.codePointAt(index);
            if (c === void 0) {
              c = string.charCodeAt(index);
            }
            index = Strings.offsetByCodePoints(string, index, 1);
            if (c === 34 || c === 92) {
              output = output.write(92);
              escape = c;
              step = 3;
            } else if (c === 8) {
              output = output.write(92);
              escape = 98;
              step = 3;
            } else if (c === 12) {
              output = output.write(92);
              escape = 102;
              step = 3;
            } else if (c === 10) {
              output = output.write(92);
              escape = 110;
              step = 3;
            } else if (c === 13) {
              output = output.write(92);
              escape = 114;
              step = 3;
            } else if (c === 9) {
              output = output.write(92);
              escape = 116;
              step = 3;
            } else if (c < 32) {
              output = output.write("\\");
              escape = c;
              step = 4;
            } else {
              output = output.write(c);
            }
          } else {
            step = 9;
            break;
          }
        } else if (step === 3) {
          output = output.write(escape);
          escape = 0;
          step = 2;
        } else if (step === 4) {
          output = output.write(117);
          step = 5;
        } else if (step === 5) {
          output = output.write(Base16.uppercase.encodeDigit(escape >>> 12 & 15));
          step = 6;
        } else if (step === 6) {
          output = output.write(Base16.uppercase.encodeDigit(escape >>> 8 & 15));
          step = 7;
        } else if (step === 7) {
          output = output.write(Base16.uppercase.encodeDigit(escape >>> 4 & 15));
          step = 8;
        } else if (step === 8) {
          output = output.write(Base16.uppercase.encodeDigit(escape & 15));
          escape = 0;
          step = 2;
        }
      }
      if (step === 9 && output.isCont()) {
        output = output.write(34);
        return Writer.end();
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new StringWriter(string, index, escape, step);
    }
  }
  class LambdaFuncWriter extends Writer {
    constructor(recon, bindings, template, part, step) {
      super();
      this.recon = recon;
      this.bindings = bindings;
      this.template = template;
      this.part = part;
      this.step = step;
    }
    pull(output) {
      return LambdaFuncWriter.write(output, this.recon, this.bindings, this.template, this.part, this.step);
    }
    static sizeOf(recon, bindings, template) {
      let size = 0;
      size += recon.sizeOfPrimary(bindings);
      size += 4;
      size += recon.sizeOfValue(template);
      return size;
    }
    static write(output, recon, bindings, template, part, step = 1) {
      if (step === 1) {
        if (part === void 0) {
          part = recon.writePrimary(output, bindings);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          part = void 0;
          step = 2;
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (step === 2 && output.isCont()) {
        output = output.write(32);
        step = 3;
      }
      if (step === 3 && output.isCont()) {
        output = output.write(61);
        step = 4;
      }
      if (step === 4 && output.isCont()) {
        output = output.write(62);
        step = 5;
      }
      if (step === 5 && output.isCont()) {
        output = output.write(32);
        step = 6;
      }
      if (step === 6) {
        if (part === void 0) {
          part = recon.writeValue(output, template);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          return Writer.end();
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new LambdaFuncWriter(recon, bindings, template, part, step);
    }
  }
  class ConditionalOperatorWriter extends Writer {
    constructor(recon, ifTerm, thenTerm, elseTerm, precedence, part, step) {
      super();
      this.recon = recon;
      this.ifTerm = ifTerm;
      this.thenTerm = thenTerm;
      this.elseTerm = elseTerm;
      this.precedence = precedence;
      this.part = part;
      this.step = step;
    }
    pull(output) {
      return ConditionalOperatorWriter.write(output, this.recon, this.ifTerm, this.thenTerm, this.elseTerm, this.precedence, this.part, this.step);
    }
    static sizeOf(recon, ifTerm, thenTerm, elseTerm, precedence) {
      let size = 0;
      if (recon.precedence(ifTerm) > 0 && recon.precedence(ifTerm) <= precedence) {
        size += 1;
        size += recon.sizeOfItem(ifTerm);
        size += 1;
      } else {
        size += recon.sizeOfItem(ifTerm);
      }
      size += 3;
      size += recon.sizeOfItem(thenTerm);
      size += 3;
      size += recon.sizeOfItem(elseTerm);
      return size;
    }
    static write(output, recon, ifTerm, thenTerm, elseTerm, precedence, part, step = 1) {
      if (step === 1) {
        if (recon.precedence(ifTerm) > 0 && recon.precedence(ifTerm) <= precedence) {
          if (output.isCont()) {
            output = output.write(40);
            step = 2;
          }
        } else {
          step = 2;
        }
      }
      if (step === 2) {
        if (part === void 0) {
          part = recon.writeItem(output, ifTerm);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          part = void 0;
          step = 3;
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (step === 3) {
        if (recon.precedence(ifTerm) > 0 && recon.precedence(ifTerm) <= precedence) {
          if (output.isCont()) {
            output = output.write(41);
            step = 4;
          }
        } else {
          step = 4;
        }
      }
      if (step === 4 && output.isCont()) {
        output = output.write(32);
        step = 5;
      }
      if (step === 5 && output.isCont()) {
        output = output.write(63);
        step = 6;
      }
      if (step === 6 && output.isCont()) {
        output = output.write(32);
        step = 7;
      }
      if (step === 7) {
        if (part === void 0) {
          part = recon.writeItem(output, thenTerm);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          part = void 0;
          step = 8;
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (step === 8 && output.isCont()) {
        output = output.write(32);
        step = 9;
      }
      if (step === 9 && output.isCont()) {
        output = output.write(58);
        step = 10;
      }
      if (step === 10 && output.isCont()) {
        output = output.write(32);
        step = 11;
      }
      if (step === 11) {
        if (part === void 0) {
          part = recon.writeItem(output, elseTerm);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          return Writer.end();
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new ConditionalOperatorWriter(recon, ifTerm, thenTerm, elseTerm, precedence, part, step);
    }
  }
  class InfixOperatorWriter extends Writer {
    constructor(recon, lhs, operator, rhs, precedence, part, step) {
      super();
      this.recon = recon;
      this.lhs = lhs;
      this.operator = operator;
      this.rhs = rhs;
      this.precedence = precedence;
      this.part = part;
      this.step = step;
    }
    pull(output) {
      return InfixOperatorWriter.write(output, this.recon, this.lhs, this.operator, this.rhs, this.precedence, this.part, this.step);
    }
    static sizeOf(recon, lhs, operator, rhs, precedence) {
      let size = 0;
      if (recon.precedence(lhs) < precedence) {
        size += 1;
        size += recon.sizeOfItem(lhs);
        size += 1;
      } else {
        size += recon.sizeOfItem(lhs);
      }
      size += 1;
      size += Utf8.sizeOf(operator);
      size += 1;
      if (recon.precedence(rhs) < precedence) {
        size += 1;
        size += recon.sizeOfItem(rhs);
        size += 1;
      } else {
        size += recon.sizeOfItem(rhs);
      }
      return size;
    }
    static write(output, recon, lhs, operator, rhs, precedence, part, step = 1) {
      if (step === 1) {
        if (recon.precedence(lhs) < precedence) {
          if (output.isCont()) {
            output = output.write(40);
            step = 2;
          }
        } else {
          step = 2;
        }
      }
      if (step === 2) {
        if (part === void 0) {
          part = recon.writeItem(output, lhs);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          part = void 0;
          step = 3;
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (step === 3) {
        if (recon.precedence(lhs) < precedence) {
          if (output.isCont()) {
            output = output.write(41);
            step = 4;
          }
        } else {
          step = 4;
        }
      }
      if (step === 4 && output.isCont()) {
        output = output.write(32);
        step = 5;
      }
      if (step === 5) {
        if (part === void 0) {
          part = Unicode.writeString(output, operator);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          part = void 0;
          step = 6;
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (step === 6 && output.isCont()) {
        output = output.write(32);
        step = 7;
      }
      if (step === 7) {
        if (recon.precedence(rhs) < precedence) {
          if (output.isCont()) {
            output = output.write(40);
            step = 8;
          }
        } else {
          step = 8;
        }
      }
      if (step === 8) {
        if (part === void 0) {
          part = recon.writeItem(output, rhs);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          part = void 0;
          step = 9;
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (step === 9) {
        if (recon.precedence(rhs) < precedence) {
          if (output.isCont()) {
            output = output.write(41);
            return Writer.end();
          }
        } else {
          return Writer.end();
        }
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new InfixOperatorWriter(recon, lhs, operator, rhs, precedence, part, step);
    }
  }
  class PrefixOperatorWriter extends Writer {
    constructor(recon, operator, rhs, precedence, part, step) {
      super();
      this.recon = recon;
      this.operator = operator;
      this.rhs = rhs;
      this.precedence = precedence;
      this.part = part;
      this.step = step;
    }
    pull(output) {
      return PrefixOperatorWriter.write(output, this.recon, this.operator, this.rhs, this.precedence, this.part, this.step);
    }
    static sizeOf(recon, operator, rhs, precedence) {
      let size = 0;
      size += Utf8.sizeOf(operator);
      if (recon.precedence(rhs) < precedence) {
        size += 1;
        size += recon.sizeOfItem(rhs);
        size += 1;
      } else {
        size += recon.sizeOfItem(rhs);
      }
      return size;
    }
    static write(output, recon, operator, rhs, precedence, part, step = 1) {
      if (step === 1) {
        if (part === void 0) {
          part = Unicode.writeString(output, operator);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          part = void 0;
          step = 2;
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (step === 2) {
        if (recon.precedence(rhs) < precedence) {
          if (output.isCont()) {
            output = output.write(40);
            step = 3;
          }
        } else {
          step = 3;
        }
      }
      if (step === 3) {
        if (part === void 0) {
          part = recon.writeItem(output, rhs);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          part = void 0;
          step = 4;
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (step === 4) {
        if (recon.precedence(rhs) < precedence) {
          if (output.isCont()) {
            output = output.write(41);
            return Writer.end();
          }
        } else {
          return Writer.end();
        }
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new PrefixOperatorWriter(recon, operator, rhs, precedence, part, step);
    }
  }
  class InvokeOperatorWriter extends Writer {
    constructor(recon, func, args, part, step) {
      super();
      this.recon = recon;
      this.func = func;
      this.args = args;
      this.part = part;
      this.step = step;
    }
    pull(output) {
      return InvokeOperatorWriter.write(output, this.recon, this.func, this.args, this.part, this.step);
    }
    static sizeOf(recon, func, args) {
      let size = 0;
      size += recon.sizeOfValue(func);
      size += 1;
      size += recon.sizeOfBlockValue(args);
      size += 1;
      return size;
    }
    static write(output, recon, func, args, part, step = 1) {
      if (step === 1) {
        if (part === void 0) {
          part = recon.writeValue(output, func);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          part = void 0;
          step = 2;
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (step === 2 && output.isCont()) {
        output = output.write(40);
        step = 3;
      }
      if (step === 3) {
        if (part === void 0) {
          part = recon.writeBlockValue(output, args);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          part = void 0;
          step = 4;
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (step === 4 && output.isCont()) {
        output = output.write(41);
        return Writer.end();
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new InvokeOperatorWriter(recon, func, args, part, step);
    }
  }
  class LiteralSelectorWriter extends Writer {
    constructor(recon, item, then, part, step) {
      super();
      this.recon = recon;
      this.item = item;
      this.then = then;
      this.part = part;
      this.step = step;
    }
    pull(output) {
      return LiteralSelectorWriter.write(output, this.recon, this.item, this.then, this.part, this.step);
    }
    static sizeOf(recon, item, then) {
      let size = 0;
      if (recon.precedence(item) < recon.precedence(recon.item(then))) {
        size += 1;
        size += recon.sizeOfItem(item);
        size += 1;
      } else {
        size += recon.sizeOfItem(item);
      }
      size += recon.sizeOfThen(then);
      return size;
    }
    static write(output, recon, item, then, part, step = 1) {
      if (step === 1) {
        if (recon.precedence(item) < recon.precedence(recon.item(then))) {
          if (output.isCont()) {
            output = output.write(40);
            step = 2;
          }
        } else {
          step = 2;
        }
      }
      if (step === 2) {
        if (part === void 0) {
          part = recon.writeItem(output, item);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          part = void 0;
          step = 3;
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (step === 3) {
        if (recon.precedence(item) < recon.precedence(recon.item(then))) {
          if (output.isCont()) {
            output = output.write(41);
            step = 4;
          }
        } else {
          step = 4;
        }
      }
      if (step === 4) {
        return recon.writeThen(output, then);
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new LiteralSelectorWriter(recon, item, then, part, step);
    }
  }
  class GetSelectorWriter extends Writer {
    constructor(recon, key, then, part, step) {
      super();
      this.recon = recon;
      this.key = key;
      this.then = then;
      this.part = part;
      this.step = step;
    }
    pull(output) {
      return GetSelectorWriter.write(output, this.recon, this.key, this.then, this.part, this.step);
    }
    static sizeOf(recon, key, then) {
      let size = 1;
      if (recon.isRecord(recon.item(key))) {
        size += 1;
        size += recon.sizeOfBlockValue(key);
        size += 1;
      } else {
        size += recon.sizeOfValue(key);
      }
      size += recon.sizeOfThen(then);
      return size;
    }
    static write(output, recon, key, then, part, step = 1) {
      if (step === 1 && output.isCont()) {
        output = output.write(36);
        step = 3;
      } else if (step === 2 && output.isCont()) {
        output = output.write(46);
        step = 3;
      }
      if (step === 3) {
        if (recon.isRecord(recon.item(key))) {
          if (output.isCont()) {
            output = output.write(123);
            step = 4;
          }
        } else {
          step = 4;
        }
      }
      if (step === 4) {
        if (part === void 0) {
          if (recon.isRecord(recon.item(key))) {
            part = recon.writeBlockValue(output, key);
          } else {
            part = recon.writeValue(output, key);
          }
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          part = void 0;
          step = 5;
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (step === 5) {
        if (recon.isRecord(recon.item(key))) {
          if (output.isCont()) {
            output = output.write(125);
            step = 6;
          }
        } else {
          step = 6;
        }
      }
      if (step === 6) {
        return recon.writeThen(output, then);
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new GetSelectorWriter(recon, key, then, part, step);
    }
    static writeThen(output, recon, key, then) {
      return GetSelectorWriter.write(output, recon, key, then, void 0, 2);
    }
  }
  class GetAttrSelectorWriter extends Writer {
    constructor(recon, key, then, part, step) {
      super();
      this.recon = recon;
      this.key = key;
      this.then = then;
      this.part = part;
      this.step = step;
    }
    pull(output) {
      return GetAttrSelectorWriter.write(output, this.recon, this.key, this.then, this.part, this.step);
    }
    static sizeOf(recon, key, then) {
      let size = 2;
      size += recon.sizeOfValue(key);
      size += recon.sizeOfThen(then);
      return size;
    }
    static write(output, recon, key, then, part, step = 1) {
      if (step === 1 && output.isCont()) {
        output = output.write(36);
        step = 3;
      } else if (step === 2 && output.isCont()) {
        output = output.write(46);
        step = 3;
      }
      if (step === 3 && output.isCont()) {
        output = output.write(64);
        step = 4;
      }
      if (step === 4) {
        if (part === void 0) {
          part = recon.writeValue(output, key);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          return recon.writeThen(output, then);
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new GetAttrSelectorWriter(recon, key, then, part, step);
    }
    static writeThen(output, recon, key, then) {
      return GetAttrSelectorWriter.write(output, recon, key, then, void 0, 2);
    }
  }
  class GetItemSelectorWriter extends Writer {
    constructor(recon, index, then, part, step) {
      super();
      this.recon = recon;
      this.index = index;
      this.then = then;
      this.part = part;
      this.step = step;
    }
    pull(output) {
      return GetItemSelectorWriter.write(output, this.recon, this.index, this.then, this.part, this.step);
    }
    static sizeOf(recon, index, then) {
      let size = 2;
      size += recon.sizeOfValue(index);
      size += recon.sizeOfThen(then);
      return size;
    }
    static sizeOfThen(recon, index, then) {
      let size = 1;
      size += recon.sizeOfValue(index);
      size += recon.sizeOfThen(then);
      return size;
    }
    static write(output, recon, index, then, part, step = 1) {
      if (step === 1 && output.isCont()) {
        output = output.write(36);
        step = 2;
      }
      if (step === 2 && output.isCont()) {
        output = output.write(35);
        step = 3;
      }
      if (step === 3) {
        if (part === void 0) {
          part = recon.writeValue(output, index);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          return recon.writeThen(output, then);
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new GetItemSelectorWriter(recon, index, then, part, step);
    }
    static writeThen(output, recon, index, then) {
      return GetItemSelectorWriter.write(output, recon, index, then, void 0, 2);
    }
  }
  class KeysSelectorWriter extends Writer {
    constructor(recon, then, step) {
      super();
      this.recon = recon;
      this.then = then;
      this.step = step;
    }
    pull(output) {
      return KeysSelectorWriter.write(output, this.recon, this.then, this.step);
    }
    static sizeOf(recon, then) {
      let size = 3;
      size += recon.sizeOfThen(then);
      return size;
    }
    static write(output, recon, then, step = 1) {
      if (step === 1 && output.isCont()) {
        output = output.write(36);
        step = 3;
      } else if (step === 2 && output.isCont()) {
        output = output.write(46);
        step = 3;
      }
      if (step === 3 && output.isCont()) {
        output = output.write(42);
        step = 4;
      }
      if (step === 4 && output.isCont()) {
        output = output.write(58);
        return recon.writeThen(output, then);
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new KeysSelectorWriter(recon, then, step);
    }
    static writeThen(output, recon, then) {
      return KeysSelectorWriter.write(output, recon, then, 2);
    }
  }
  class ValuesSelectorWriter extends Writer {
    constructor(recon, then, step) {
      super();
      this.recon = recon;
      this.then = then;
      this.step = step;
    }
    pull(output) {
      return ValuesSelectorWriter.write(output, this.recon, this.then, this.step);
    }
    static sizeOf(recon, then) {
      let size = 3;
      size += recon.sizeOfThen(then);
      return size;
    }
    static write(output, recon, then, step = 1) {
      if (step === 1 && output.isCont()) {
        output = output.write(36);
        step = 3;
      } else if (step === 2 && output.isCont()) {
        output = output.write(46);
        step = 3;
      }
      if (step === 3 && output.isCont()) {
        output = output.write(58);
        step = 4;
      }
      if (step === 4 && output.isCont()) {
        output = output.write(42);
        return recon.writeThen(output, then);
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new ValuesSelectorWriter(recon, then, step);
    }
    static writeThen(output, recon, then) {
      return ValuesSelectorWriter.write(output, recon, then, 2);
    }
  }
  class ChildrenSelectorWriter extends Writer {
    constructor(recon, then, step) {
      super();
      this.recon = recon;
      this.then = then;
      this.step = step;
    }
    pull(output) {
      return ChildrenSelectorWriter.write(output, this.recon, this.then, this.step);
    }
    static sizeOf(recon, then) {
      let size = 2;
      size += recon.sizeOfThen(then);
      return size;
    }
    static write(output, recon, then, step = 1) {
      if (step === 1 && output.isCont()) {
        output = output.write(36);
        step = 3;
      } else if (step === 2 && output.isCont()) {
        output = output.write(46);
        step = 3;
      }
      if (step === 3 && output.isCont()) {
        output = output.write(42);
        return recon.writeThen(output, then);
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new ChildrenSelectorWriter(recon, then, step);
    }
    static writeThen(output, recon, then) {
      return ChildrenSelectorWriter.write(output, recon, then, 2);
    }
  }
  class DescendantsSelectorWriter extends Writer {
    constructor(recon, then, step) {
      super();
      this.recon = recon;
      this.then = then;
      this.step = step;
    }
    pull(output) {
      return DescendantsSelectorWriter.write(output, this.recon, this.then, this.step);
    }
    static sizeOf(recon, then) {
      let size = 3;
      size += recon.sizeOfThen(then);
      return size;
    }
    static write(output, recon, then, step = 1) {
      if (step === 1 && output.isCont()) {
        output = output.write(36);
        step = 3;
      } else if (step === 2 && output.isCont()) {
        output = output.write(46);
        step = 3;
      }
      if (step === 3 && output.isCont()) {
        output = output.write(42);
        step = 4;
      }
      if (step === 4 && output.isCont()) {
        output = output.write(42);
        return recon.writeThen(output, then);
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new DescendantsSelectorWriter(recon, then, step);
    }
    static writeThen(output, recon, then) {
      return DescendantsSelectorWriter.write(output, recon, then, 2);
    }
  }
  class FilterSelectorWriter extends Writer {
    constructor(recon, predicate, then, part, step) {
      super();
      this.recon = recon;
      this.predicate = predicate;
      this.then = then;
      this.part = part;
      this.step = step;
    }
    pull(output) {
      return FilterSelectorWriter.write(output, this.recon, this.predicate, this.then, this.part, this.step);
    }
    static sizeOf(recon, predicate, then) {
      let size = 2;
      size += recon.sizeOfValue(predicate);
      size += 1;
      size += recon.sizeOfThen(then);
      return size;
    }
    static sizeOfThen(recon, predicate, then) {
      let size = 1;
      size += recon.sizeOfValue(predicate);
      size += 1;
      size += recon.sizeOfThen(then);
      return size;
    }
    static write(output, recon, predicate, then, part, step = 1) {
      if (step === 1 && output.isCont()) {
        output = output.write(36);
        step = 2;
      }
      if (step === 2 && output.isCont()) {
        output = output.write(91);
        step = 3;
      }
      if (step === 3) {
        if (part === void 0) {
          part = recon.writeValue(output, predicate);
        } else {
          part = part.pull(output);
        }
        if (part.isDone()) {
          part = void 0;
          step = 4;
        } else if (part.isError()) {
          return part.asError();
        }
      }
      if (step === 4 && output.isCont()) {
        output = output.write(93);
        return recon.writeThen(output, then);
      }
      if (output.isDone()) {
        return Writer.error(new WriterException("truncated"));
      } else if (output.isError()) {
        return Writer.error(output.trap());
      }
      return new FilterSelectorWriter(recon, predicate, then, part, step);
    }
    static writeThen(output, recon, predicate, then) {
      return FilterSelectorWriter.write(output, recon, predicate, then, void 0, 2);
    }
  }
  class ReconWriter {
    sizeOfAttr(key, value) {
      return AttrWriter.sizeOf(this, key, value);
    }
    writeAttr(output, key, value) {
      return AttrWriter.write(output, this, key, value);
    }
    sizeOfSlot(key, value) {
      return SlotWriter.sizeOf(this, key, value);
    }
    writeSlot(output, key, value) {
      return SlotWriter.write(output, this, key, value);
    }
    sizeOfBlock(item, inBlock, inMarkup) {
      if (arguments.length === 3) {
        return BlockWriter.sizeOf(this, item, inBlock, inMarkup);
      } else {
        const items = this.items(item);
        if (items.hasNext()) {
          return BlockWriter.sizeOf(this, items, this.isBlockSafe(this.items(item)), false);
        } else {
          return 2;
        }
      }
    }
    writeBlock(output, item, inBlock, inMarkup) {
      if (arguments.length === 4) {
        return BlockWriter.write(output, this, item, inBlock, inMarkup);
      } else {
        const items = this.items(item);
        if (items.hasNext()) {
          return BlockWriter.write(output, this, items, this.isBlockSafe(this.items(item)), false);
        } else {
          return Unicode.writeString(output, "{}");
        }
      }
    }
    sizeOfRecord(item) {
      const items = this.items(item);
      if (items.hasNext()) {
        return BlockWriter.sizeOf(this, items, false, false);
      } else {
        return 2;
      }
    }
    writeRecord(output, item) {
      const items = this.items(item);
      if (items.hasNext()) {
        return BlockWriter.write(output, this, items, false, false);
      } else {
        return Unicode.writeString(output, "{}");
      }
    }
    sizeOfPrimary(value) {
      if (this.isRecord(this.item(value))) {
        const items = this.items(this.item(value));
        if (items.hasNext()) {
          return PrimaryWriter.sizeOf(this, items);
        }
      } else if (!this.isExtant(this.item(value))) {
        return this.sizeOfValue(value);
      }
      return 2;
    }
    writePrimary(output, value) {
      if (this.isRecord(this.item(value))) {
        const items = this.items(this.item(value));
        if (items.hasNext()) {
          return PrimaryWriter.write(output, this, items);
        }
      } else if (!this.isExtant(this.item(value))) {
        return this.writeValue(output, value);
      }
      return Unicode.writeString(output, "()");
    }
    isBlockSafe(items) {
      while (items.hasNext()) {
        if (this.isAttr(items.next().value)) {
          return false;
        }
      }
      return true;
    }
    isMarkupSafe(items) {
      if (!items.hasNext() || !this.isAttr(items.next().value)) {
        return false;
      }
      while (items.hasNext()) {
        if (this.isAttr(items.next().value)) {
          return false;
        }
      }
      return true;
    }
    sizeOfMarkupText(item) {
      if (typeof item !== "string") {
        item = this.string(item);
      }
      return MarkupTextWriter.sizeOf(item);
    }
    writeMarkupText(output, item) {
      if (typeof item !== "string") {
        item = this.string(item);
      }
      return MarkupTextWriter.write(output, item);
    }
    sizeOfData(length) {
      return DataWriter.sizeOf(length);
    }
    writeData(output, value) {
      if (value !== void 0) {
        return DataWriter.write(output, value);
      } else {
        return Unicode.writeString(output, "%");
      }
    }
    isIdent(value) {
      if (typeof value !== "string") {
        value = this.string(value);
      }
      const n = value.length;
      let c;
      if (n === 0 || (c = value.codePointAt(0), c !== void 0 && !Recon.isIdentStartChar(c))) {
        return false;
      }
      for (let i = Strings.offsetByCodePoints(value, 0, 1); i < n; i = Strings.offsetByCodePoints(value, i, 1)) {
        c = value.codePointAt(i);
        if (c === void 0 || !Recon.isIdentChar(c)) {
          return false;
        }
      }
      return true;
    }
    sizeOfText(value) {
      if (this.isIdent(value)) {
        return IdentWriter.sizeOf(value);
      } else {
        return StringWriter.sizeOf(value);
      }
    }
    writeText(output, value) {
      if (this.isIdent(value)) {
        return IdentWriter.write(output, value);
      } else {
        return StringWriter.write(output, value);
      }
    }
    sizeOfNum(value) {
      if (isFinite(value) && Math.floor(value) === value && Math.abs(value) < 2147483648) {
        let size = Base10.countDigits(value);
        if (value < 0) {
          size += 1;
        }
        return size;
      } else {
        return ("" + value).length;
      }
    }
    writeNum(output, value) {
      if (isFinite(value) && Math.floor(value) === value && Math.abs(value) < 2147483648) {
        return Base10.writeInteger(output, value);
      } else {
        return Unicode.writeString(output, "" + value);
      }
    }
    sizeOfUint32(value) {
      return 10;
    }
    writeUint32(output, value) {
      return Base16.lowercase.writeIntegerLiteral(output, value, 8);
    }
    sizeOfUint64(value) {
      return 18;
    }
    writeUint64(output, value) {
      return Base16.lowercase.writeIntegerLiteral(output, value, 16);
    }
    sizeOfBool(value) {
      return value ? 4 : 5;
    }
    writeBool(output, value) {
      return Unicode.writeString(output, value ? "true" : "false");
    }
    sizeOfLambdaFunc(bindings, template) {
      return LambdaFuncWriter.sizeOf(this, bindings, template);
    }
    writeLambdaFunc(output, bindings, template) {
      return LambdaFuncWriter.write(output, this, bindings, template);
    }
    sizeOfConditionalOperator(ifTerm, thenTerm, elseTerm, precedence) {
      return ConditionalOperatorWriter.sizeOf(this, ifTerm, thenTerm, elseTerm, precedence);
    }
    writeConditionalOperator(output, ifTerm, thenTerm, elseTerm, precedence) {
      return ConditionalOperatorWriter.write(output, this, ifTerm, thenTerm, elseTerm, precedence);
    }
    sizeOfInfixOperator(lhs, operator, rhs, precedence) {
      return InfixOperatorWriter.sizeOf(this, lhs, operator, rhs, precedence);
    }
    writeInfixOperator(output, lhs, operator, rhs, precedence) {
      return InfixOperatorWriter.write(output, this, lhs, operator, rhs, precedence);
    }
    sizeOfPrefixOperator(operator, rhs, precedence) {
      return PrefixOperatorWriter.sizeOf(this, operator, rhs, precedence);
    }
    writePrefixOperator(output, operator, rhs, precedence) {
      return PrefixOperatorWriter.write(output, this, operator, rhs, precedence);
    }
    sizeOfInvokeOperator(func, args) {
      return InvokeOperatorWriter.sizeOf(this, func, args);
    }
    writeInvokeOperator(output, func, args) {
      return InvokeOperatorWriter.write(output, this, func, args);
    }
    sizeOfIdentitySelector() {
      return 0;
    }
    writeIdentitySelector(output) {
      return Writer.end();
    }
    sizeOfThenIdentitySelector() {
      return 0;
    }
    writeThenIdentitySelector(output) {
      return Writer.end();
    }
    sizeOfLiteralSelector(item, then) {
      return LiteralSelectorWriter.sizeOf(this, item, then);
    }
    writeLiteralSelector(output, item, then) {
      return LiteralSelectorWriter.write(output, this, item, then);
    }
    sizeOfThenLiteralSelector(item, then) {
      return 0;
    }
    writeThenLiteralSelector(output, item, then) {
      return Writer.end();
    }
    sizeOfGetSelector(key, then) {
      return GetSelectorWriter.sizeOf(this, key, then);
    }
    writeGetSelector(output, key, then) {
      return GetSelectorWriter.write(output, this, key, then);
    }
    sizeOfThenGetSelector(key, then) {
      return GetSelectorWriter.sizeOf(this, key, then);
    }
    writeThenGetSelector(output, key, then) {
      return GetSelectorWriter.writeThen(output, this, key, then);
    }
    sizeOfGetAttrSelector(key, then) {
      return GetAttrSelectorWriter.sizeOf(this, key, then);
    }
    writeGetAttrSelector(output, key, then) {
      return GetAttrSelectorWriter.write(output, this, key, then);
    }
    sizeOfThenGetAttrSelector(key, then) {
      return GetAttrSelectorWriter.sizeOf(this, key, then);
    }
    writeThenGetAttrSelector(output, key, then) {
      return GetAttrSelectorWriter.writeThen(output, this, key, then);
    }
    sizeOfGetItemSelector(index, then) {
      return GetItemSelectorWriter.sizeOf(this, index, then);
    }
    writeGetItemSelector(output, index, then) {
      return GetItemSelectorWriter.write(output, this, index, then);
    }
    sizeOfThenGetItemSelector(index, then) {
      return GetItemSelectorWriter.sizeOfThen(this, index, then);
    }
    writeThenGetItemSelector(output, index, then) {
      return GetItemSelectorWriter.writeThen(output, this, index, then);
    }
    sizeOfKeysSelector(then) {
      return KeysSelectorWriter.sizeOf(this, then);
    }
    writeKeysSelector(output, then) {
      return KeysSelectorWriter.write(output, this, then);
    }
    sizeOfThenKeysSelector(then) {
      return KeysSelectorWriter.sizeOf(this, then);
    }
    writeThenKeysSelector(output, then) {
      return KeysSelectorWriter.writeThen(output, this, then);
    }
    sizeOfValuesSelector(then) {
      return ValuesSelectorWriter.sizeOf(this, then);
    }
    writeValuesSelector(output, then) {
      return ValuesSelectorWriter.write(output, this, then);
    }
    sizeOfThenValuesSelector(then) {
      return ValuesSelectorWriter.sizeOf(this, then);
    }
    writeThenValuesSelector(output, then) {
      return ValuesSelectorWriter.writeThen(output, this, then);
    }
    sizeOfChildrenSelector(then) {
      return ChildrenSelectorWriter.sizeOf(this, then);
    }
    writeChildrenSelector(output, then) {
      return ChildrenSelectorWriter.write(output, this, then);
    }
    sizeOfThenChildrenSelector(then) {
      return ChildrenSelectorWriter.sizeOf(this, then);
    }
    writeThenChildrenSelector(output, then) {
      return ChildrenSelectorWriter.writeThen(output, this, then);
    }
    sizeOfDescendantsSelector(then) {
      return DescendantsSelectorWriter.sizeOf(this, then);
    }
    writeDescendantsSelector(output, then) {
      return DescendantsSelectorWriter.write(output, this, then);
    }
    sizeOfThenDescendantsSelector(then) {
      return DescendantsSelectorWriter.sizeOf(this, then);
    }
    writeThenDescendantsSelector(output, then) {
      return DescendantsSelectorWriter.writeThen(output, this, then);
    }
    sizeOfFilterSelector(predicate, then) {
      return FilterSelectorWriter.sizeOf(this, predicate, then);
    }
    writeFilterSelector(output, predicate, then) {
      return FilterSelectorWriter.write(output, this, predicate, then);
    }
    sizeOfThenFilterSelector(predicate, then) {
      return FilterSelectorWriter.sizeOfThen(this, predicate, then);
    }
    writeThenFilterSelector(output, predicate, then) {
      return FilterSelectorWriter.writeThen(output, this, predicate, then);
    }
    sizeOfExtant() {
      return 0;
    }
    writeExtant(output) {
      return Writer.end();
    }
    sizeOfAbsent() {
      return 0;
    }
    writeAbsent(output) {
      return Writer.end();
    }
  }
  class ReconStructureWriter extends ReconWriter {
    isField(item) {
      return item instanceof Field;
    }
    isAttr(item) {
      return item instanceof Attr;
    }
    isSlot(item) {
      return item instanceof Slot;
    }
    isValue(item) {
      return item instanceof Value;
    }
    isRecord(item) {
      return item instanceof Record;
    }
    isText(item) {
      return item instanceof Text;
    }
    isNum(item) {
      return item instanceof Num;
    }
    isBool(item) {
      return item instanceof Bool;
    }
    isExpression(item) {
      return item instanceof Expression;
    }
    isExtant(item) {
      return item instanceof Extant;
    }
    items(item) {
      return item.iterator();
    }
    item(value) {
      return value;
    }
    key(item) {
      return item.key;
    }
    value(item) {
      return item.toValue();
    }
    string(item) {
      return item.stringValue("");
    }
    precedence(item) {
      return item.precedence;
    }
    sizeOfItem(item) {
      if (item instanceof Field) {
        if (item instanceof Attr) {
          return this.sizeOfAttr(item.key, item.value);
        } else if (item instanceof Slot) {
          return this.sizeOfSlot(item.key, item.value);
        }
      } else if (item instanceof Value) {
        return this.sizeOfValue(item);
      }
      throw new WriterException("No Recon serialization for " + item);
    }
    writeItem(output, item) {
      if (item instanceof Field) {
        if (item instanceof Attr) {
          return this.writeAttr(output, item.key, item.value);
        } else if (item instanceof Slot) {
          return this.writeSlot(output, item.key, item.value);
        }
      } else if (item instanceof Value) {
        return this.writeValue(output, item);
      }
      return Writer.error(new WriterException("No Recon serialization for " + item));
    }
    sizeOfValue(value) {
      if (value instanceof Record) {
        return this.sizeOfRecord(value);
      } else if (value instanceof Data) {
        return this.sizeOfData(value.size);
      } else if (value instanceof Text) {
        return this.sizeOfText(value.value);
      } else if (value instanceof Num) {
        if (value.isUint32()) {
          return this.sizeOfUint32(value.value);
        } else if (value.isUint64()) {
          return this.sizeOfUint64(value.value);
        } else {
          return this.sizeOfNum(value.value);
        }
      } else if (value instanceof Bool) {
        return this.sizeOfBool(value.value);
      } else if (value instanceof Selector) {
        return this.sizeOfSelector(value);
      } else if (value instanceof Operator) {
        return this.sizeOfOperator(value);
      } else if (value instanceof Func) {
        return this.sizeOfFunc(value);
      } else if (value instanceof Extant) {
        return this.sizeOfExtant();
      } else if (value instanceof Absent) {
        return this.sizeOfAbsent();
      }
      throw new WriterException("No Recon serialization for " + value);
    }
    writeValue(output, value) {
      if (value instanceof Record) {
        return this.writeRecord(output, value);
      } else if (value instanceof Data) {
        return this.writeData(output, value.asUint8Array());
      } else if (value instanceof Text) {
        return this.writeText(output, value.value);
      } else if (value instanceof Num) {
        if (value.isUint32()) {
          return this.writeUint32(output, value.value);
        } else if (value.isUint64()) {
          return this.writeUint64(output, value.value);
        } else {
          return this.writeNum(output, value.value);
        }
      } else if (value instanceof Bool) {
        return this.writeBool(output, value.value);
      } else if (value instanceof Selector) {
        return this.writeSelector(output, value);
      } else if (value instanceof Operator) {
        return this.writeOperator(output, value);
      } else if (value instanceof Func) {
        return this.writeFunc(output, value);
      } else if (value instanceof Extant) {
        return this.writeExtant(output);
      } else if (value instanceof Absent) {
        return this.writeAbsent(output);
      }
      return Writer.error(new WriterException("No Recon serialization for " + value));
    }
    sizeOfSelector(selector) {
      if (selector instanceof IdentitySelector) {
        return this.sizeOfIdentitySelector();
      } else if (selector instanceof LiteralSelector) {
        return this.sizeOfLiteralSelector(selector.item, selector.then);
      } else if (selector instanceof GetSelector) {
        return this.sizeOfGetSelector(selector.item, selector.then);
      } else if (selector instanceof GetAttrSelector) {
        return this.sizeOfGetAttrSelector(selector.item, selector.then);
      } else if (selector instanceof GetItemSelector) {
        return this.sizeOfGetItemSelector(selector.item, selector.then);
      } else if (selector instanceof KeysSelector) {
        return this.sizeOfKeysSelector(selector.then);
      } else if (selector instanceof ValuesSelector) {
        return this.sizeOfValuesSelector(selector.then);
      } else if (selector instanceof ChildrenSelector) {
        return this.sizeOfChildrenSelector(selector.then);
      } else if (selector instanceof DescendantsSelector) {
        return this.sizeOfDescendantsSelector(selector.then);
      } else if (selector instanceof FilterSelector) {
        return this.sizeOfFilterSelector(selector.predicate, selector.then);
      }
      throw new WriterException("No Recon serialization for " + selector);
    }
    writeSelector(output, selector) {
      if (selector instanceof IdentitySelector) {
        return this.writeIdentitySelector(output);
      } else if (selector instanceof LiteralSelector) {
        return this.writeLiteralSelector(output, selector.item, selector.then);
      } else if (selector instanceof GetSelector) {
        return this.writeGetSelector(output, selector.item, selector.then);
      } else if (selector instanceof GetAttrSelector) {
        return this.writeGetAttrSelector(output, selector.item, selector.then);
      } else if (selector instanceof GetItemSelector) {
        return this.writeGetItemSelector(output, selector.item, selector.then);
      } else if (selector instanceof KeysSelector) {
        return this.writeKeysSelector(output, selector.then);
      } else if (selector instanceof ValuesSelector) {
        return this.writeValuesSelector(output, selector.then);
      } else if (selector instanceof ChildrenSelector) {
        return this.writeChildrenSelector(output, selector.then);
      } else if (selector instanceof DescendantsSelector) {
        return this.writeDescendantsSelector(output, selector.then);
      } else if (selector instanceof FilterSelector) {
        return this.writeFilterSelector(output, selector.predicate, selector.then);
      }
      return Writer.error(new WriterException("No Recon serialization for " + selector));
    }
    sizeOfOperator(operator) {
      if (operator instanceof BinaryOperator) {
        return this.sizeOfInfixOperator(operator.operand1, operator.operator, operator.operand2, operator.precedence);
      } else if (operator instanceof UnaryOperator) {
        return this.sizeOfPrefixOperator(operator.operator, operator.operand, operator.precedence);
      } else if (operator instanceof InvokeOperator) {
        return this.sizeOfInvokeOperator(operator.func, operator.args);
      } else if (operator instanceof ConditionalOperator) {
        return this.sizeOfConditionalOperator(operator.ifTerm, operator.thenTerm, operator.elseTerm, operator.precedence);
      }
      throw new WriterException("No Recon serialization for " + operator);
    }
    writeOperator(output, operator) {
      if (operator instanceof BinaryOperator) {
        return this.writeInfixOperator(output, operator.operand1, operator.operator, operator.operand2, operator.precedence);
      } else if (operator instanceof UnaryOperator) {
        return this.writePrefixOperator(output, operator.operator, operator.operand, operator.precedence);
      } else if (operator instanceof InvokeOperator) {
        return this.writeInvokeOperator(output, operator.func, operator.args);
      } else if (operator instanceof ConditionalOperator) {
        return this.writeConditionalOperator(output, operator.ifTerm, operator.thenTerm, operator.elseTerm, operator.precedence);
      }
      return Writer.error(new WriterException("No Recon serialization for " + operator));
    }
    sizeOfFunc(func) {
      if (func instanceof LambdaFunc) {
        return this.sizeOfLambdaFunc(func.bindings, func.template);
      } else if (func instanceof BridgeFunc) {
        return 0;
      }
      throw new WriterException("No Recon serialization for " + func);
    }
    writeFunc(output, func) {
      if (func instanceof LambdaFunc) {
        return this.writeLambdaFunc(output, func.bindings, func.template);
      } else if (func instanceof BridgeFunc) {
        return Writer.end();
      }
      return Writer.error(new WriterException("No Recon serialization for " + func));
    }
    sizeOfBlockItem(item) {
      if (item instanceof Field) {
        return this.sizeOfItem(item);
      } else if (item instanceof Value) {
        return this.sizeOfBlockValue(item);
      }
      throw new WriterException("No Recon serialization for " + item);
    }
    writeBlockItem(output, item) {
      if (item instanceof Field) {
        return this.writeItem(output, item);
      } else if (item instanceof Value) {
        return this.writeBlockValue(output, item);
      }
      return Writer.error(new WriterException("No Recon serialization for " + item));
    }
    sizeOfBlockValue(value) {
      if (value instanceof Record) {
        return this.sizeOfBlock(value);
      }
      return this.sizeOfValue(value);
    }
    writeBlockValue(output, value) {
      if (value instanceof Record) {
        return this.writeBlock(output, value);
      }
      return this.writeValue(output, value);
    }
    sizeOfThen(then) {
      if (then instanceof Selector) {
        if (then instanceof IdentitySelector) {
          return this.sizeOfThenIdentitySelector();
        } else if (then instanceof LiteralSelector) {
          return this.sizeOfThenLiteralSelector(then.item, then.then);
        } else if (then instanceof GetSelector) {
          return this.sizeOfThenGetSelector(then.item, then.then);
        } else if (then instanceof GetAttrSelector) {
          return this.sizeOfThenGetAttrSelector(then.item, then.then);
        } else if (then instanceof GetItemSelector) {
          return this.sizeOfThenGetItemSelector(then.item, then.then);
        } else if (then instanceof KeysSelector) {
          return this.sizeOfThenKeysSelector(then.then);
        } else if (then instanceof ValuesSelector) {
          return this.sizeOfThenValuesSelector(then.then);
        } else if (then instanceof ChildrenSelector) {
          return this.sizeOfThenChildrenSelector(then.then);
        } else if (then instanceof DescendantsSelector) {
          return this.sizeOfThenDescendantsSelector(then.then);
        } else if (then instanceof FilterSelector) {
          return this.sizeOfThenFilterSelector(then.predicate, then.then);
        }
      }
      throw new WriterException("No Recon serialization for " + then);
    }
    writeThen(output, then) {
      if (then instanceof Selector) {
        if (then instanceof IdentitySelector) {
          return this.writeThenIdentitySelector(output);
        } else if (then instanceof LiteralSelector) {
          return this.writeThenLiteralSelector(output, then.item, then.then);
        } else if (then instanceof GetSelector) {
          return this.writeThenGetSelector(output, then.item, then.then);
        } else if (then instanceof GetAttrSelector) {
          return this.writeThenGetAttrSelector(output, then.item, then.then);
        } else if (then instanceof GetItemSelector) {
          return this.writeThenGetItemSelector(output, then.item, then.then);
        } else if (then instanceof KeysSelector) {
          return this.writeThenKeysSelector(output, then.then);
        } else if (then instanceof ValuesSelector) {
          return this.writeThenValuesSelector(output, then.then);
        } else if (then instanceof ChildrenSelector) {
          return this.writeThenChildrenSelector(output, then.then);
        } else if (then instanceof DescendantsSelector) {
          return this.writeThenDescendantsSelector(output, then.then);
        } else if (then instanceof FilterSelector) {
          return this.writeThenFilterSelector(output, then.predicate, then.then);
        }
      }
      return Writer.error(new WriterException("No Recon serialization for " + then));
    }
  }
  class UriException extends Error {
    constructor(message) {
      super(message instanceof Diagnostic ? message.message : message);
      Object.setPrototypeOf(this, UriException.prototype);
      this.diagnostic = message instanceof Diagnostic ? message : null;
    }
    toString() {
      if (this.diagnostic !== null) {
        return this.diagnostic.toString();
      } else {
        return super.toString();
      }
    }
  }
  class Uri {
    constructor(scheme, authority, path, query, fragment) {
      this.scheme = scheme;
      this.authority = authority;
      this.path = path;
      this.query = query;
      this.fragment = fragment;
      this.hashValue = void 0;
      this.stringValue = void 0;
    }
    isDefined() {
      return this.scheme.isDefined() || this.authority.isDefined() || this.path.isDefined() || this.query.isDefined() || this.fragment.isDefined();
    }
    isEmpty() {
      return !this.scheme.isDefined() && !this.authority.isDefined() && this.path.isEmpty() && !this.query.isDefined() && !this.fragment.isDefined();
    }
    withScheme(scheme) {
      scheme = UriScheme.fromAny(scheme);
      if (scheme !== this.scheme) {
        return this.copy(scheme, this.authority, this.path, this.query, this.fragment);
      } else {
        return this;
      }
    }
    get schemePart() {
      return this.scheme.toString();
    }
    withSchemePart(schemePart) {
      return this.withScheme(UriScheme.parse(schemePart));
    }
    get schemeName() {
      return this.scheme.name;
    }
    withSchemeName(schemeName) {
      return this.withScheme(UriScheme.create(schemeName));
    }
    withAuthority(authority) {
      authority = UriAuthority.fromAny(authority);
      if (authority !== this.authority) {
        return this.copy(this.scheme, authority, this.path, this.query, this.fragment);
      } else {
        return this;
      }
    }
    get authorityPart() {
      return this.authority.toString();
    }
    withAuthorityPart(authorityPart) {
      return this.withAuthority(UriAuthority.parse(authorityPart));
    }
    get user() {
      return this.authority.user;
    }
    withUser(user) {
      return this.withAuthority(this.authority.withUser(user));
    }
    get userPart() {
      return this.authority.userPart;
    }
    withUserPart(userPart) {
      return this.withAuthority(this.authority.withUserPart(userPart));
    }
    get username() {
      return this.authority.username;
    }
    withUsername(username, password) {
      if (arguments.length === 1) {
        return this.withAuthority(this.authority.withUsername(username));
      } else {
        return this.withAuthority(this.authority.withUsername(username, password));
      }
    }
    get password() {
      return this.authority.password;
    }
    withPassword(password) {
      return this.withAuthority(this.authority.withPassword(password));
    }
    get host() {
      return this.authority.host;
    }
    withHost(host) {
      return this.withAuthority(this.authority.withHost(host));
    }
    get hostPart() {
      return this.authority.hostPart;
    }
    withHostPart(hostPart) {
      return this.withAuthority(this.authority.withHostPart(hostPart));
    }
    get hostAddress() {
      return this.authority.hostAddress;
    }
    get hostName() {
      return this.authority.hostName;
    }
    withHostName(hostName) {
      return this.withAuthority(this.authority.withHostName(hostName));
    }
    get hostIPv4() {
      return this.authority.hostIPv4;
    }
    withHostIPv4(hostIPv4) {
      return this.withAuthority(this.authority.withHostIPv4(hostIPv4));
    }
    get hostIPv6() {
      return this.authority.hostIPv6;
    }
    withHostIPv6(hostIPv6) {
      return this.withAuthority(this.authority.withHostIPv6(hostIPv6));
    }
    get port() {
      return this.authority.port;
    }
    withPort(port) {
      return this.withAuthority(this.authority.withPort(port));
    }
    get portPart() {
      return this.authority.portPart;
    }
    withPortPart(portPart) {
      return this.withAuthority(this.authority.withPortPart(portPart));
    }
    get portNumber() {
      return this.authority.portNumber;
    }
    withPortNumber(portNumber) {
      return this.withAuthority(this.authority.withPortNumber(portNumber));
    }
    withPath(...components) {
      const path = UriPath.of(...components);
      if (path !== this.path) {
        return this.copy(this.scheme, this.authority, path, this.query, this.fragment);
      } else {
        return this;
      }
    }
    get pathPart() {
      return this.path.toString();
    }
    withPathPart(pathPart) {
      return this.withPath(UriPath.parse(pathPart));
    }
    get pathName() {
      return this.path.name;
    }
    withPathName(pathName) {
      return this.withPath(this.path.withName(pathName));
    }
    parentPath() {
      return this.path.parent();
    }
    basePath() {
      return this.path.base();
    }
    parent() {
      return Uri.create(this.scheme, this.authority, this.path.parent());
    }
    base() {
      return Uri.create(this.scheme, this.authority, this.path.base());
    }
    appendedPath(...components) {
      return this.withPath(this.path.appended(...components));
    }
    appendedSlash() {
      return this.withPath(this.path.appendedSlash());
    }
    appendedSegment(segment) {
      return this.withPath(this.path.appendedSegment(segment));
    }
    prependedPath(...components) {
      return this.withPath(this.path.prepended(...components));
    }
    prependedSlash() {
      return this.withPath(this.path.prependedSlash());
    }
    prependedSegment(segment) {
      return this.withPath(this.path.prependedSegment(segment));
    }
    withQuery(query) {
      query = UriQuery.fromAny(query);
      if (query !== this.query) {
        return this.copy(this.scheme, this.authority, this.path, query, this.fragment);
      } else {
        return this;
      }
    }
    get queryPart() {
      return this.query.toString();
    }
    withQueryPart(query) {
      return this.withQuery(UriQuery.parse(query));
    }
    updatedQuery(key, value) {
      return this.withQuery(this.query.updated(key, value));
    }
    removedQuery(key) {
      return this.withQuery(this.query.removed(key));
    }
    appendedQuery(key, value) {
      return this.withQuery(this.query.appended(key, value));
    }
    prependedQuery(key, value) {
      return this.withQuery(this.query.prepended(key, value));
    }
    withFragment(fragment) {
      fragment = UriFragment.fromAny(fragment);
      if (fragment !== this.fragment) {
        return Uri.create(this.scheme, this.authority, this.path, this.query, fragment);
      } else {
        return this;
      }
    }
    get fragmentPart() {
      return this.fragment.toString();
    }
    withFragmentPart(fragmentPart) {
      return this.withFragment(UriFragment.parse(fragmentPart));
    }
    get fragmentIdentifier() {
      return this.fragment.identifier;
    }
    withFragmentIdentifier(fragmentIdentifier) {
      return this.withFragment(UriFragment.create(fragmentIdentifier));
    }
    endpoint() {
      if (this.path.isDefined() || this.query.isDefined() || this.fragment.isDefined()) {
        return Uri.create(this.scheme, this.authority);
      } else {
        return this;
      }
    }
    resolve(relative) {
      const that = Uri.fromAny(relative);
      if (that.scheme.isDefined()) {
        return this.copy(that.scheme, that.authority, that.path.removeDotSegments(), that.query, that.fragment);
      } else if (that.authority.isDefined()) {
        return this.copy(this.scheme, that.authority, that.path.removeDotSegments(), that.query, that.fragment);
      } else if (that.path.isEmpty()) {
        return this.copy(this.scheme, this.authority, this.path, that.query.isDefined() ? that.query : this.query, that.fragment);
      } else if (that.path.isAbsolute()) {
        return this.copy(this.scheme, this.authority, that.path.removeDotSegments(), that.query, that.fragment);
      } else {
        return this.copy(this.scheme, this.authority, this.merge(that.path).removeDotSegments(), that.query, that.fragment);
      }
    }
    merge(relative) {
      if (this.authority.isDefined() && this.path.isEmpty()) {
        return relative.prependedSlash();
      } else if (this.path.isEmpty()) {
        return relative;
      } else {
        return this.path.merge(relative);
      }
    }
    unresolve(absolute) {
      const that = Uri.fromAny(absolute);
      if (!this.scheme.equals(that.scheme) || !this.authority.equals(that.authority)) {
        return that;
      } else {
        return Uri.create(UriScheme.undefined(), UriAuthority.undefined(), this.path.unmerge(that.path), that.query, that.fragment);
      }
    }
    copy(scheme, authority, path, query, fragment) {
      return Uri.create(scheme, authority, path, query, fragment);
    }
    toAny() {
      const uri = {};
      uri.scheme = this.scheme.toAny();
      this.authority.toAny(uri);
      uri.path = this.path.toAny();
      uri.query = this.query.toAny();
      uri.fragment = this.fragment.toAny();
      return uri;
    }
    compareTo(that) {
      if (that instanceof Uri) {
        return this.toString().localeCompare(that.toString());
      }
      return NaN;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof Uri) {
        return this.toString() === that.toString();
      }
      return false;
    }
    hashCode() {
      let hashValue = this.hashValue;
      if (hashValue === void 0) {
        hashValue = Strings.hash(this.toString());
        this.hashValue = hashValue;
      }
      return hashValue;
    }
    debug(output) {
      output = output.write("Uri").write(46);
      if (this.isDefined()) {
        output = output.write("parse").write(40).write(34).display(this).write(34).write(41);
      } else {
        output = output.write("empty").write(40).write(41);
      }
      return output;
    }
    display(output) {
      const stringValue = this.stringValue;
      if (stringValue !== void 0) {
        output = output.write(stringValue);
      } else {
        if (this.scheme.isDefined()) {
          output = output.display(this.scheme).write(58);
        }
        if (this.authority.isDefined()) {
          output = output.write(47).write(47).display(this.authority);
        }
        output = output.display(this.path);
        if (this.query.isDefined()) {
          output = output.write(63).display(this.query);
        }
        if (this.fragment.isDefined()) {
          output = output.write(35).display(this.fragment);
        }
      }
      return output;
    }
    toString() {
      let stringValue = this.stringValue;
      if (stringValue === void 0) {
        stringValue = Format.display(this);
        this.stringValue = stringValue;
      }
      return stringValue;
    }
    static empty() {
      return new Uri(UriScheme.undefined(), UriAuthority.undefined(), UriPath.empty(), UriQuery.undefined(), UriFragment.undefined());
    }
    static create(scheme = UriScheme.undefined(), authority = UriAuthority.undefined(), path = UriPath.empty(), query = UriQuery.undefined(), fragment = UriFragment.undefined()) {
      if (scheme.isDefined() || authority.isDefined() || path.isDefined() || query.isDefined() || fragment.isDefined()) {
        return new Uri(scheme, authority, path, query, fragment);
      } else {
        return Uri.empty();
      }
    }
    static fromInit(init) {
      const scheme = UriScheme.fromAny(init.scheme);
      const authority = UriAuthority.fromAny(init.authority !== void 0 ? init.authority : init);
      const path = UriPath.fromAny(init.path);
      const query = UriQuery.fromAny(init.query);
      const fragment = UriFragment.fromAny(init.fragment);
      if (scheme.isDefined() || authority.isDefined() || path.isDefined() || query.isDefined() || fragment.isDefined()) {
        return new Uri(scheme, authority, path, query, fragment);
      } else {
        return Uri.empty();
      }
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return Uri.empty();
      } else if (value instanceof Uri) {
        return value;
      } else if (typeof value === "object") {
        return Uri.fromInit(value);
      } else if (typeof value === "string") {
        return Uri.parse(value);
      } else {
        throw new TypeError("" + value);
      }
    }
    static scheme(scheme) {
      scheme = UriScheme.fromAny(scheme);
      return Uri.create(scheme, void 0, void 0, void 0, void 0);
    }
    static schemePart(schemePart) {
      const scheme = UriScheme.parse(schemePart);
      return Uri.create(scheme, void 0, void 0, void 0, void 0);
    }
    static schemeName(name) {
      const scheme = UriScheme.create(name);
      return Uri.create(scheme, void 0, void 0, void 0, void 0);
    }
    static authority(authority) {
      authority = UriAuthority.fromAny(authority);
      return Uri.create(void 0, authority, void 0, void 0, void 0);
    }
    static authorityPart(authorityPart) {
      const authority = UriAuthority.parse(authorityPart);
      return Uri.create(void 0, authority, void 0, void 0, void 0);
    }
    static user(user) {
      const authority = UriAuthority.user(user);
      return Uri.create(void 0, authority, void 0, void 0, void 0);
    }
    static userPart(userPart) {
      const authority = UriAuthority.userPart(userPart);
      return Uri.create(void 0, authority, void 0, void 0, void 0);
    }
    static username(username, password) {
      const authority = UriAuthority.username(username, password);
      return Uri.create(void 0, authority, void 0, void 0, void 0);
    }
    static password(password) {
      const authority = UriAuthority.password(password);
      return Uri.create(void 0, authority, void 0, void 0, void 0);
    }
    static host(host) {
      const authority = UriAuthority.host(host);
      return Uri.create(void 0, authority, void 0, void 0, void 0);
    }
    static hostPart(hostPart) {
      const authority = UriAuthority.hostPart(hostPart);
      return Uri.create(void 0, authority, void 0, void 0, void 0);
    }
    static hostName(hostName) {
      const authority = UriAuthority.hostName(hostName);
      return Uri.create(void 0, authority, void 0, void 0, void 0);
    }
    static hostIPv4(hostIPv4) {
      const authority = UriAuthority.hostIPv4(hostIPv4);
      return Uri.create(void 0, authority, void 0, void 0, void 0);
    }
    static hostIPv6(hostIPv6) {
      const authority = UriAuthority.hostIPv6(hostIPv6);
      return Uri.create(void 0, authority, void 0, void 0, void 0);
    }
    static port(port) {
      const authority = UriAuthority.port(port);
      return Uri.create(void 0, authority, void 0, void 0, void 0);
    }
    static portPart(portPart) {
      const authority = UriAuthority.portPart(portPart);
      return Uri.create(void 0, authority, void 0, void 0, void 0);
    }
    static portNumber(portNumber) {
      const authority = UriAuthority.portNumber(portNumber);
      return Uri.create(void 0, authority, void 0, void 0, void 0);
    }
    static path(...components) {
      const path = UriPath.of(...components);
      return Uri.create(void 0, void 0, path, void 0, void 0);
    }
    static pathPart(pathPart) {
      const path = UriPath.parse(pathPart);
      return Uri.create(void 0, void 0, path, void 0, void 0);
    }
    static query(query) {
      query = UriQuery.fromAny(query);
      return Uri.create(void 0, void 0, void 0, query, void 0);
    }
    static queryPart(queryPart) {
      const query = UriQuery.parse(queryPart);
      return Uri.create(void 0, void 0, void 0, query, void 0);
    }
    static fragment(fragment) {
      fragment = UriFragment.fromAny(fragment);
      return Uri.create(void 0, void 0, void 0, void 0, fragment);
    }
    static fragmentPart(fragmentPart) {
      const fragment = UriFragment.parse(fragmentPart);
      return Uri.create(void 0, void 0, void 0, void 0, fragment);
    }
    static fragmentIdentifier(fragmentIdentifier) {
      const fragment = UriFragment.create(fragmentIdentifier);
      return Uri.create(void 0, void 0, void 0, void 0, fragment);
    }
    static get standardParser() {
      return new UriParser;
    }
    static parse(string) {
      return Uri.standardParser.parseAbsoluteString(string);
    }
    static pathBuilder() {
      return new UriPathBuilder;
    }
    static queryBuilder() {
      return new UriQueryBuilder;
    }
    static form() {
      return new UriForm(Uri.empty());
    }
    static isUnreservedChar(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122 || c >= 48 && c <= 57 || c === 45 || c === 46 || c === 95 || c === 126;
    }
    static isSubDelimChar(c) {
      return c === 33 || c === 36 || c === 38 || c === 40 || c === 41 || c === 42 || c === 43 || c === 44 || c === 59 || c === 61 || c === 39;
    }
    static isSchemeChar(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122 || c >= 48 && c <= 57 || c === 43 || c === 45 || c === 46;
    }
    static isUserInfoChar(c) {
      return Uri.isUnreservedChar(c) || Uri.isSubDelimChar(c) || c === 58;
    }
    static isUserChar(c) {
      return Uri.isUnreservedChar(c) || Uri.isSubDelimChar(c);
    }
    static isHostChar(c) {
      return Uri.isUnreservedChar(c) || Uri.isSubDelimChar(c);
    }
    static isPathChar(c) {
      return Uri.isUnreservedChar(c) || Uri.isSubDelimChar(c) || c === 58 || c === 64;
    }
    static isQueryChar(c) {
      return Uri.isUnreservedChar(c) || Uri.isSubDelimChar(c) || c === 47 || c === 58 || c === 63 || c === 64;
    }
    static isParamChar(c) {
      return Uri.isUnreservedChar(c) || c === 33 || c === 36 || c === 40 || c === 41 || c === 42 || c === 43 || c === 44 || c === 47 || c === 58 || c === 59 || c === 63 || c === 64 || c === 39;
    }
    static isFragmentChar(c) {
      return Uri.isUnreservedChar(c) || Uri.isSubDelimChar(c) || c === 47 || c === 58 || c === 63 || c === 64;
    }
    static isAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    static toLowerCase(c) {
      if (c >= 65 && c <= 90) {
        return c + (97 - 65);
      } else {
        return c;
      }
    }
    static writeScheme(output, scheme) {
      for (let i = 0, n = scheme.length; i < n; i += 1) {
        const c = scheme.charCodeAt(i);
        if (i > 0 && Uri.isSchemeChar(c) || i === 0 && Uri.isAlpha(c)) {
          output = output.write(c);
        } else {
          output = Output.error(new UriException("Invalid scheme: " + scheme));
        }
      }
      return output;
    }
    static writeUserInfo(output, userInfo) {
      for (let i = 0, n = userInfo.length; i < n; i += 1) {
        const c = userInfo.charCodeAt(i);
        if (Uri.isUserInfoChar(c)) {
          output = output.write(c);
        } else {
          output = Uri.writeEncoded(output, c);
        }
      }
      return output;
    }
    static writeUser(output, user) {
      for (let i = 0, n = user.length; i < n; i += 1) {
        const c = user.charCodeAt(i);
        if (Uri.isUserChar(c)) {
          output = output.write(c);
        } else {
          output = Uri.writeEncoded(output, c);
        }
      }
      return output;
    }
    static writeHost(output, address) {
      for (let i = 0, n = address.length; i < n; i += 1) {
        const c = address.charCodeAt(i);
        if (Uri.isHostChar(c)) {
          output = output.write(c);
        } else {
          output = Uri.writeEncoded(output, c);
        }
      }
      return output;
    }
    static writeHostLiteral(output, address) {
      for (let i = 0, n = address.length; i < n; i += 1) {
        const c = address.charCodeAt(i);
        if (Uri.isHostChar(c) || c === 58) {
          output = output.write(c);
        } else {
          output = Uri.writeEncoded(output, c);
        }
      }
      return output;
    }
    static writePathSegment(output, segment) {
      for (let i = 0, n = segment.length; i < n; i += 1) {
        const c = segment.charCodeAt(i);
        if (Uri.isPathChar(c)) {
          output = output.write(c);
        } else {
          output = Uri.writeEncoded(output, c);
        }
      }
      return output;
    }
    static writeQuery(output, query) {
      for (let i = 0, n = query.length; i < n; i += 1) {
        const c = query.charCodeAt(i);
        if (Uri.isQueryChar(c)) {
          output = output.write(c);
        } else {
          output = Uri.writeEncoded(output, c);
        }
      }
      return output;
    }
    static writeParam(output, param) {
      for (let i = 0, n = param.length; i < n; i += 1) {
        const c = param.charCodeAt(i);
        if (Uri.isParamChar(c)) {
          output = output.write(c);
        } else {
          output = Uri.writeEncoded(output, c);
        }
      }
      return output;
    }
    static writeFragment(output, fragment) {
      for (let i = 0, n = fragment.length; i < n; i += 1) {
        const c = fragment.charCodeAt(i);
        if (Uri.isFragmentChar(c)) {
          output = output.write(c);
        } else {
          output = Uri.writeEncoded(output, c);
        }
      }
      return output;
    }
    static writeEncoded(output, c) {
      if (c === 0) {
        output = Uri.writePctEncoded(output, 192);
        output = Uri.writePctEncoded(output, 128);
      } else if (c >= 0 && c <= 127) {
        output = Uri.writePctEncoded(output, c);
      } else if (c >= 128 && c <= 2047) {
        output = Uri.writePctEncoded(output, 192 | c >>> 6);
        output = Uri.writePctEncoded(output, 128 | c & 63);
      } else if (c >= 2048 && c <= 65535) {
        output = Uri.writePctEncoded(output, 224 | c >>> 12);
        output = Uri.writePctEncoded(output, 128 | c >>> 6 & 63);
        output = Uri.writePctEncoded(output, 128 | c & 63);
      } else if (c >= 65536 && c <= 1114111) {
        output = Uri.writePctEncoded(output, 240 | c >>> 18);
        output = Uri.writePctEncoded(output, 128 | c >>> 12 & 63);
        output = Uri.writePctEncoded(output, 128 | c >>> 6 & 63);
        output = Uri.writePctEncoded(output, 128 | c & 63);
      } else {
        output = Uri.writePctEncoded(output, 239);
        output = Uri.writePctEncoded(output, 191);
        output = Uri.writePctEncoded(output, 189);
      }
      return output;
    }
    static writePctEncoded(output, c) {
      const base16 = Base16.lowercase;
      output = output.write(37).write(base16.encodeDigit(c >>> 4 & 15)).write(base16.encodeDigit(c & 15));
      return output;
    }
  }
  __decorate([ Lazy ], Uri, "empty", null);
  __decorate([ Lazy ], Uri, "standardParser", null);
  __decorate([ Lazy ], Uri, "form", null);
  class UriScheme {
    constructor(name) {
      this.name = name;
    }
    isDefined() {
      return this.name.length !== 0;
    }
    toAny() {
      return this.name.length !== 0 ? this.name : void 0;
    }
    compareTo(that) {
      if (that instanceof UriScheme) {
        return this.name.localeCompare(that.name);
      }
      return NaN;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof UriScheme) {
        return this.name === that.name;
      }
      return false;
    }
    hashCode() {
      return Strings.hash(this.name);
    }
    debug(output) {
      output = output.write("UriScheme").write(46);
      if (this.isDefined()) {
        output = output.write("parse").write(40).write(34).display(this).write(34).write(41);
      } else {
        output = output.write("undefined").write(40).write(41);
      }
      return output;
    }
    display(output) {
      output = Uri.writeScheme(output, this.name);
      return output;
    }
    toString() {
      return this.name;
    }
    static undefined() {
      return new UriScheme("");
    }
    static create(schemeName) {
      const cache = UriScheme.cache;
      const scheme = cache.get(schemeName);
      if (scheme !== void 0) {
        return scheme;
      } else {
        return cache.put(schemeName, new UriScheme(schemeName));
      }
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return UriScheme.undefined();
      } else if (value instanceof UriScheme) {
        return value;
      } else if (typeof value === "string") {
        return UriScheme.parse(value);
      } else {
        throw new TypeError("" + value);
      }
    }
    static parse(schemePart) {
      return Uri.standardParser.parseSchemeString(schemePart);
    }
    static get cache() {
      const cacheSize = 4;
      return new HashGenCacheMap(cacheSize);
    }
  }
  __decorate([ Lazy ], UriScheme, "undefined", null);
  __decorate([ Lazy ], UriScheme, "cache", null);
  class UriAuthority {
    constructor(user, host, port) {
      this.user = user;
      this.host = host;
      this.port = port;
      this.hashValue = void 0;
      this.stringValue = void 0;
    }
    isDefined() {
      return this.user.isDefined() || this.host.isDefined() || this.port.isDefined();
    }
    withUser(user) {
      user = UriUser.fromAny(user);
      if (user !== this.user) {
        return this.copy(user, this.host, this.port);
      } else {
        return this;
      }
    }
    get userPart() {
      return this.user.toString();
    }
    withUserPart(userPart) {
      return this.withUser(UriUser.parse(userPart));
    }
    get username() {
      return this.user.username;
    }
    withUsername(username, password) {
      if (arguments.length === 1) {
        return this.withUser(this.user.withUsername(username));
      } else {
        return this.withUser(UriUser.create(username, password));
      }
    }
    get password() {
      return this.user.password;
    }
    withPassword(password) {
      return this.withUser(this.user.withPassword(password));
    }
    withHost(host) {
      host = UriHost.fromAny(host);
      if (host !== this.host) {
        return this.copy(this.user, host, this.port);
      } else {
        return this;
      }
    }
    get hostPart() {
      return this.host.toString();
    }
    withHostPart(hostPart) {
      return this.withHost(UriHost.parse(hostPart));
    }
    get hostAddress() {
      return this.host.address;
    }
    get hostName() {
      return this.host.name;
    }
    withHostName(hostName) {
      return this.withHost(UriHost.hostname(hostName));
    }
    get hostIPv4() {
      return this.host.ipv4;
    }
    withHostIPv4(hostIPv4) {
      return this.withHost(UriHost.ipv4(hostIPv4));
    }
    get hostIPv6() {
      return this.host.ipv6;
    }
    withHostIPv6(hostIPv5) {
      return this.withHost(UriHost.ipv6(hostIPv5));
    }
    withPort(port) {
      port = UriPort.fromAny(port);
      if (port !== this.port) {
        return this.copy(this.user, this.host, port);
      } else {
        return this;
      }
    }
    get portPart() {
      return this.port.toString();
    }
    withPortPart(portPart) {
      return this.withPort(UriPort.parse(portPart));
    }
    get portNumber() {
      return this.port.number;
    }
    withPortNumber(portNumber) {
      return this.withPort(UriPort.create(portNumber));
    }
    copy(user, host, port) {
      return UriAuthority.create(user, host, port);
    }
    toAny(authority) {
      if (this.isDefined()) {
        if (authority === void 0) {
          authority = {};
        }
        this.user.toAny(authority);
        if (this.host.isDefined()) {
          authority.host = this.host.toAny();
        }
        if (this.port.isDefined()) {
          authority.port = this.port.toAny();
        }
      }
      return authority;
    }
    compareTo(that) {
      if (that instanceof UriAuthority) {
        return this.toString().localeCompare(that.toString());
      }
      return NaN;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof UriAuthority) {
        return this.toString() === that.toString();
      }
      return false;
    }
    hashCode() {
      let hashValue = this.hashValue;
      if (hashValue === void 0) {
        hashValue = Strings.hash(this.toString());
        this.hashValue = hashValue;
      }
      return hashValue;
    }
    debug(output) {
      output = output.write("UriAuthority").write(46);
      if (this.isDefined()) {
        output = output.write("parse").write(40).write(34).display(this).write(34).write(41);
      } else {
        output = output.write("undefined").write(40).write(41);
      }
      return output;
    }
    display(output) {
      const stringValue = this.stringValue;
      if (stringValue !== void 0) {
        output = output.write(stringValue);
      } else {
        const user = this.user;
        if (user.isDefined()) {
          output = output.display(user).write(64);
        }
        output = output.display(this.host);
        const port = this.port;
        if (port.isDefined()) {
          output = output.write(58).display(port);
        }
      }
      return output;
    }
    toString() {
      let stringValue = this.stringValue;
      if (stringValue === void 0) {
        stringValue = Format.display(this);
        this.stringValue = stringValue;
      }
      return stringValue;
    }
    static undefined() {
      return new UriAuthority(UriUser.undefined(), UriHost.undefined(), UriPort.undefined());
    }
    static create(user = UriUser.undefined(), host = UriHost.undefined(), port = UriPort.undefined()) {
      if (user.isDefined() || host.isDefined() || port.isDefined()) {
        return new UriAuthority(user, host, port);
      } else {
        return UriAuthority.undefined();
      }
    }
    static fromInit(init) {
      const user = UriUser.fromAny(init.user !== void 0 ? init.user : init);
      const host = UriHost.fromAny(init.host);
      const port = UriPort.fromAny(init.port);
      return UriAuthority.create(user, host, port);
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return UriAuthority.undefined();
      } else if (value instanceof UriAuthority) {
        return value;
      } else if (typeof value === "object") {
        return UriAuthority.fromInit(value);
      } else if (typeof value === "string") {
        return UriAuthority.parse(value);
      } else {
        throw new TypeError("" + value);
      }
    }
    static user(user) {
      user = UriUser.fromAny(user);
      return UriAuthority.create(user, void 0, void 0);
    }
    static userPart(userPart) {
      const user = UriUser.parse(userPart);
      return UriAuthority.create(user, void 0, void 0);
    }
    static username(username, password) {
      const user = UriUser.create(username, password);
      return UriAuthority.create(user, void 0, void 0);
    }
    static password(password) {
      const user = UriUser.create("", password);
      return UriAuthority.create(user, void 0, void 0);
    }
    static host(host) {
      host = UriHost.fromAny(host);
      return UriAuthority.create(void 0, host, void 0);
    }
    static hostPart(hostPart) {
      const host = UriHost.parse(hostPart);
      return UriAuthority.create(void 0, host, void 0);
    }
    static hostName(hostName) {
      const host = UriHost.hostname(hostName);
      return UriAuthority.create(void 0, host, void 0);
    }
    static hostIPv4(hostIPv4) {
      const host = UriHost.ipv4(hostIPv4);
      return UriAuthority.create(void 0, host, void 0);
    }
    static hostIPv6(hostIPv6) {
      const host = UriHost.ipv6(hostIPv6);
      return UriAuthority.create(void 0, host, void 0);
    }
    static port(port) {
      port = UriPort.fromAny(port);
      return UriAuthority.create(void 0, void 0, port);
    }
    static portPart(portPart) {
      const port = UriPort.parse(portPart);
      return UriAuthority.create(void 0, void 0, port);
    }
    static portNumber(portNumber) {
      const port = UriPort.create(portNumber);
      return UriAuthority.create(void 0, void 0, port);
    }
    static parse(authorityPart) {
      return Uri.standardParser.parseAuthorityString(authorityPart);
    }
  }
  __decorate([ Lazy ], UriAuthority, "undefined", null);
  class UriUser {
    constructor(username, password) {
      this.username = username;
      this.password = password;
    }
    isDefined() {
      return this.username !== void 0;
    }
    withUsername(username) {
      if (username !== this.username) {
        return this.copy(username, this.password);
      } else {
        return this;
      }
    }
    withPassword(password) {
      if (password !== this.password) {
        return this.copy(this.username, password);
      } else {
        return this;
      }
    }
    copy(username, password) {
      return UriUser.create(username, password);
    }
    toAny(user) {
      if (this.username !== void 0) {
        if (user === void 0) {
          user = {};
        }
        user.username = this.username;
        if (this.password !== void 0) {
          user.password = this.password;
        }
      }
      return user;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof UriUser) {
        return this.username === that.username && this.password === that.password;
      }
      return false;
    }
    hashCode() {
      return Strings.hash(this.toString());
    }
    debug(output) {
      output = output.write("UriUser").write(46);
      if (this.isDefined()) {
        output = output.write("parse").write(40).write(34).display(this).write(34).write(41);
      } else {
        output = output.write("undefined").write(40).write(41);
      }
      return output;
    }
    display(output) {
      if (this.username !== void 0) {
        output = Uri.writeUser(output, this.username);
        if (this.password !== void 0) {
          output = output.write(58);
          output = Uri.writeUser(output, this.password);
        }
      }
      return output;
    }
    toString() {
      return Format.display(this);
    }
    static undefined() {
      return new UriUser(void 0, void 0);
    }
    static create(username, password) {
      if (username !== void 0 || password !== void 0) {
        return new UriUser(username, password);
      } else {
        return UriUser.undefined();
      }
    }
    static fromInit(init) {
      return UriUser.create(init.username, init.password);
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return UriUser.undefined();
      } else if (value instanceof UriUser) {
        return value;
      } else if (typeof value === "object") {
        return UriUser.fromInit(value);
      } else if (typeof value === "string") {
        return UriUser.parse(value);
      } else {
        throw new TypeError("" + value);
      }
    }
    static parse(userPart) {
      return Uri.standardParser.parseUserString(userPart);
    }
  }
  __decorate([ Lazy ], UriUser, "undefined", null);
  class UriHost {
    constructor() {}
    isDefined() {
      return true;
    }
    get name() {
      return void 0;
    }
    get ipv4() {
      return void 0;
    }
    get ipv6() {
      return void 0;
    }
    toAny() {
      return this.toString();
    }
    compareTo(that) {
      if (that instanceof UriHost) {
        return this.toString().localeCompare(that.toString());
      }
      return NaN;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof UriHost) {
        return this.toString() === that.toString();
      }
      return false;
    }
    hashCode() {
      return Strings.hash(this.toString());
    }
    static undefined() {
      return new UriHostUndefined;
    }
    static hostname(name) {
      const cache = UriHost.cache;
      const host = cache.get(name);
      if (host instanceof UriHostName) {
        return host;
      } else {
        return cache.put(name, new UriHostName(name));
      }
    }
    static ipv4(ipv4) {
      const cache = UriHost.cache;
      const host = cache.get(ipv4);
      if (host instanceof UriHostIPv4) {
        return host;
      } else {
        return cache.put(ipv4, new UriHostIPv4(ipv4));
      }
    }
    static ipv6(ipv6) {
      const cache = UriHost.cache;
      const host = cache.get(ipv6);
      if (host instanceof UriHostIPv6) {
        return host;
      } else {
        return cache.put(ipv6, new UriHostIPv6(ipv6));
      }
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return UriHost.undefined();
      } else if (value instanceof UriHost) {
        return value;
      } else if (typeof value === "string") {
        return UriHost.parse(value);
      } else {
        throw new TypeError("" + value);
      }
    }
    static parse(hostPart) {
      return Uri.standardParser.parseHostString(hostPart);
    }
    static get cache() {
      const cacheSize = 16;
      return new HashGenCacheMap(cacheSize);
    }
  }
  __decorate([ Lazy ], UriHost, "undefined", null);
  __decorate([ Lazy ], UriHost, "cache", null);
  class UriHostName extends UriHost {
    constructor(address) {
      super();
      this.address = address;
    }
    get name() {
      return this.address;
    }
    debug(output) {
      output = output.write("UriHost").write(46).write("hostname").write(40).debug(this.address).write(41);
      return output;
    }
    display(output) {
      output = Uri.writeHost(output, this.address);
      return output;
    }
    toString() {
      return this.address;
    }
  }
  class UriHostIPv4 extends UriHost {
    constructor(address) {
      super();
      this.address = address;
    }
    get ipv4() {
      return this.address;
    }
    debug(output) {
      output = output.write("UriHost").write(46).write("ipv4").write(40).debug(this.address).write(41);
      return output;
    }
    display(output) {
      output = Uri.writeHost(output, this.address);
      return output;
    }
    toString() {
      return this.address;
    }
  }
  class UriHostIPv6 extends UriHost {
    constructor(address) {
      super();
      this.address = address;
    }
    get ipv6() {
      return this.address;
    }
    debug(output) {
      output = output.write("UriHost").write(46).write("ipv6").write(40).debug(this.address).write(41);
      return output;
    }
    display(output) {
      output = output.write(91);
      output = Uri.writeHostLiteral(output, this.address);
      output = output.write(93);
      return output;
    }
    toString() {
      return "[" + this.address + "]";
    }
  }
  class UriHostUndefined extends UriHost {
    constructor() {
      super();
    }
    isDefined() {
      return false;
    }
    get address() {
      return "";
    }
    debug(output) {
      output = output.write("UriHost").write(46).write("undefined").write(40).write(41);
      return output;
    }
    display(output) {
      return output;
    }
    toString() {
      return "";
    }
  }
  class UriPort {
    constructor(portNumber) {
      this.number = portNumber;
    }
    isDefined() {
      return this.number !== 0;
    }
    valueOf() {
      return this.number;
    }
    toAny() {
      return this.number;
    }
    compareTo(that) {
      if (that instanceof UriPort) {
        return this.number < that.number ? -1 : this.number > that.number ? 1 : 0;
      }
      return NaN;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof UriPort) {
        return this.number === that.number;
      }
      return false;
    }
    hashCode() {
      return Strings.hash(this.toString());
    }
    debug(output) {
      output = output.write("UriPort").write(46);
      if (this.isDefined()) {
        output = output.write("create").write(40);
        output = Format.displayNumber(output, this.number);
      } else {
        output = output.write("undefined").write(40);
      }
      output = output.write(41);
      return output;
    }
    display(output) {
      output = Format.displayNumber(output, this.number);
      return output;
    }
    toString() {
      return "" + this.number;
    }
    static undefined() {
      return new UriPort(0);
    }
    static create(number) {
      if (number === 0) {
        return UriPort.undefined();
      } else if (number > 0) {
        const cache = UriPort.cache;
        const port = cache.get(number);
        if (port !== void 0) {
          return port;
        } else {
          return cache.put(number, new UriPort(number));
        }
      } else {
        throw new TypeError("" + number);
      }
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return UriPort.undefined();
      } else if (value instanceof UriPort) {
        return value;
      } else if (typeof value === "number") {
        return UriPort.create(value);
      } else if (typeof value === "string") {
        return UriPort.parse(value);
      } else {
        throw new TypeError("" + value);
      }
    }
    static parse(portPart) {
      return Uri.standardParser.parsePortString(portPart);
    }
    static get cache() {
      const cacheSize = 16;
      return new HashGenCacheMap(cacheSize);
    }
  }
  __decorate([ Lazy ], UriPort, "undefined", null);
  __decorate([ Lazy ], UriPort, "cache", null);
  class UriPath {
    constructor() {}
    get length() {
      let n = 0;
      let path = this;
      while (!path.isEmpty()) {
        n += 1;
        path = path.tail();
      }
      return n;
    }
    get(index) {
      let i = 0;
      let path = this;
      while (!path.isEmpty()) {
        if (i < index) {
          i += 1;
          path = path.tail();
        } else {
          return path.head();
        }
      }
      return void 0;
    }
    get name() {
      if (this.isEmpty()) {
        return "";
      }
      let path = this;
      do {
        const tail = path.tail();
        if (tail.isEmpty()) {
          return path.isRelative() ? path.head() : "";
        } else {
          path = tail;
        }
      } while (true);
    }
    withName(name) {
      const builder = new UriPathBuilder;
      builder.addPath(this.base());
      builder.addSegment(name);
      return builder.bind();
    }
    foot() {
      if (this.isEmpty()) {
        return this;
      }
      let path = this;
      do {
        const tail = path.tail();
        if (tail.isEmpty()) {
          return path;
        } else {
          path = tail;
        }
      } while (true);
    }
    isSubpathOf(b) {
      b = UriPath.fromAny(b);
      let a = this;
      while (!a.isEmpty() && !b.isEmpty()) {
        if (a.head() !== b.head()) {
          return false;
        }
        a = a.tail();
        b = b.tail();
      }
      return b.isEmpty();
    }
    appended(...components) {
      if (arguments.length > 0) {
        const builder = new UriPathBuilder;
        builder.addPath(this);
        builder.push(...components);
        return builder.bind();
      } else {
        return this;
      }
    }
    appendedSlash() {
      const builder = new UriPathBuilder;
      builder.addPath(this);
      builder.addSlash();
      return builder.bind();
    }
    appendedSegment(segment) {
      const builder = new UriPathBuilder;
      builder.addPath(this);
      builder.addSegment(segment);
      return builder.bind();
    }
    prepended(...components) {
      if (arguments.length > 0) {
        const builder = new UriPathBuilder;
        builder.push(...components);
        builder.addPath(this);
        return builder.bind();
      } else {
        return this;
      }
    }
    prependedSlash() {
      return new UriPathSlash(this);
    }
    prependedSegment(segment) {
      if (this.isEmpty() || this.isAbsolute()) {
        return UriPath.segment(segment, this);
      } else {
        return UriPath.segment(segment, this.prependedSlash());
      }
    }
    resolve(that) {
      if (that.isEmpty()) {
        return this;
      } else if (that.isAbsolute() || this.isEmpty()) {
        return that.removeDotSegments();
      } else {
        return this.merge(that).removeDotSegments();
      }
    }
    removeDotSegments() {
      let path = this;
      const builder = new UriPathBuilder;
      while (!path.isEmpty()) {
        const head = path.head();
        if (head === "." || head === "..") {
          path = path.tail();
          if (!path.isEmpty()) {
            path = path.tail();
          }
        } else if (path.isAbsolute()) {
          const rest = path.tail();
          if (!rest.isEmpty()) {
            const next = rest.head();
            if (next === ".") {
              path = rest.tail();
              if (path.isEmpty()) {
                path = UriPath.slash();
              }
            } else if (next === "..") {
              path = rest.tail();
              if (path.isEmpty()) {
                path = UriPath.slash();
              }
              if (!builder.isEmpty() && !builder.pop().isAbsolute()) {
                if (!builder.isEmpty()) {
                  builder.pop();
                }
              }
            } else {
              builder.push(head, next);
              path = rest.tail();
            }
          } else {
            builder.push(path.head());
            path = path.tail();
          }
        } else {
          builder.push(path.head());
          path = path.tail();
        }
      }
      return builder.bind();
    }
    merge(that) {
      if (!this.isEmpty()) {
        const builder = new UriPathBuilder;
        let prev = this;
        do {
          const next = prev.tail();
          if (!next.isEmpty()) {
            if (prev.isAbsolute()) {
              builder.addSlash();
            } else {
              builder.addSegment(prev.head());
            }
            prev = next;
          } else {
            if (prev.isAbsolute()) {
              builder.addSlash();
            }
            break;
          }
        } while (true);
        builder.addPath(that);
        return builder.bind();
      } else {
        return that;
      }
    }
    unmerge(relative, root = relative) {
      let base = this;
      do {
        if (base.isEmpty()) {
          if (!relative.isEmpty() && !relative.tail().isEmpty()) {
            return relative.tail();
          } else {
            return relative;
          }
        } else if (base.isRelative()) {
          return relative;
        } else if (relative.isRelative()) {
          return relative.prependedSlash();
        } else {
          let a = base.tail();
          let b = relative.tail();
          if (!a.isEmpty() && b.isEmpty()) {
            return UriPath.slash();
          } else if (a.isEmpty() || b.isEmpty() || a.head() !== b.head()) {
            return b;
          } else {
            a = a.tail();
            b = b.tail();
            if (!a.isEmpty() && b.isEmpty()) {
              return root;
            } else {
              base = a;
              relative = b;
            }
          }
        }
      } while (true);
    }
    toAny() {
      const components = [];
      let path = this;
      while (!path.isEmpty()) {
        components.push(path.head());
        path = path.tail();
      }
      return components;
    }
    compareTo(that) {
      if (that instanceof UriPath) {
        return this.toString().localeCompare(that.toString());
      }
      return NaN;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof UriPath) {
        return this.toString() === that.toString();
      }
      return false;
    }
    hashCode() {
      return Strings.hash(this.toString());
    }
    display(output) {
      let path = this;
      while (!path.isEmpty()) {
        if (path.isAbsolute()) {
          output = output.write(47);
        } else {
          output = Uri.writePathSegment(output, path.head());
        }
        path = path.tail();
      }
      return output;
    }
    static empty() {
      return new UriPathEmpty;
    }
    static slash() {
      return new UriPathSlash(UriPath.empty());
    }
    static segment(segment, tail) {
      if (tail === void 0) {
        tail = UriPath.empty();
      }
      segment = this.cacheSegment(segment);
      return new UriPathSegment(segment, tail);
    }
    static of(...components) {
      const builder = new UriPathBuilder;
      builder.push(...components);
      return builder.bind();
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return UriPath.empty();
      } else if (value instanceof UriPath) {
        return value;
      } else if (Array.isArray(value)) {
        return UriPath.of(...value);
      } else if (typeof value === "string") {
        return UriPath.parse(value);
      } else {
        throw new TypeError("" + value);
      }
    }
    static parse(pathPart) {
      return Uri.standardParser.parsePathString(pathPart);
    }
    static builder() {
      return new UriPathBuilder;
    }
    static pathForm() {
      return new UriPathForm(UriPath.empty());
    }
    static get segmentCache() {
      const segmentCacheSize = 64;
      return new HashGenCacheSet(segmentCacheSize);
    }
    static cacheSegment(segment) {
      if (segment.length <= 32) {
        return this.segmentCache.put(segment);
      } else {
        return segment;
      }
    }
  }
  __decorate([ Lazy ], UriPath, "empty", null);
  __decorate([ Lazy ], UriPath, "slash", null);
  __decorate([ Lazy ], UriPath, "pathForm", null);
  __decorate([ Lazy ], UriPath, "segmentCache", null);
  class UriPathSegment extends UriPath {
    constructor(head, tail) {
      super();
      this.segment = head;
      this.rest = tail;
      this.stringValue = void 0;
    }
    isDefined() {
      return true;
    }
    isAbsolute() {
      return false;
    }
    isRelative() {
      return true;
    }
    isEmpty() {
      return false;
    }
    head() {
      return this.segment;
    }
    tail() {
      return this.rest;
    }
    setTail(tail) {
      if (tail instanceof UriPathSegment) {
        throw new Error("adjacent path segments");
      }
      this.rest = tail;
    }
    dealias() {
      return new UriPathSegment(this.segment, this.rest);
    }
    parent() {
      const tail = this.rest;
      if (tail.isEmpty()) {
        return UriPath.empty();
      } else {
        const rest = tail.tail();
        if (rest.isEmpty()) {
          return UriPath.empty();
        } else {
          return new UriPathSegment(this.segment, tail.parent());
        }
      }
    }
    base() {
      const tail = this.rest;
      if (tail.isEmpty()) {
        return UriPath.empty();
      } else {
        return new UriPathSegment(this.segment, tail.base());
      }
    }
    prependedSegment(segment) {
      return UriPath.segment(segment, this.prependedSlash());
    }
    debug(output) {
      output = output.write("UriPath").write(46).write("parse").write(40).write(34).display(this).write(34).write(41);
      return output;
    }
    display(output) {
      const stringValue = this.stringValue;
      if (stringValue !== void 0) {
        output = output.write(stringValue);
      } else {
        output = super.display(output);
      }
      return output;
    }
    toString() {
      let stringValue = this.stringValue;
      if (stringValue === void 0) {
        stringValue = Format.display(this);
        this.stringValue = stringValue;
      }
      return stringValue;
    }
  }
  class UriPathSlash extends UriPath {
    constructor(tail) {
      super();
      this.rest = tail;
      this.stringValue = void 0;
    }
    isDefined() {
      return true;
    }
    isAbsolute() {
      return true;
    }
    isRelative() {
      return false;
    }
    isEmpty() {
      return false;
    }
    head() {
      return "/";
    }
    tail() {
      return this.rest;
    }
    setTail(tail) {
      this.rest = tail;
    }
    dealias() {
      return new UriPathSlash(this.rest);
    }
    parent() {
      const tail = this.rest;
      if (tail.isEmpty()) {
        return UriPath.empty();
      } else {
        const rest = tail.tail();
        if (rest.isEmpty()) {
          return UriPath.slash();
        } else {
          return new UriPathSlash(tail.parent());
        }
      }
    }
    base() {
      const tail = this.rest;
      if (tail.isEmpty()) {
        return this;
      } else {
        return new UriPathSlash(tail.base());
      }
    }
    prependedSegment(segment) {
      return UriPath.segment(segment, this);
    }
    debug(output) {
      output = output.write("UriPath").write(46).write("parse").write(40).write(34).display(this).write(34).write(41);
      return output;
    }
    display(output) {
      const stringValue = this.stringValue;
      if (stringValue !== void 0) {
        output = output.write(stringValue);
      } else {
        output = super.display(output);
      }
      return output;
    }
    toString() {
      let stringValue = this.stringValue;
      if (stringValue === void 0) {
        stringValue = Format.display(this);
        this.stringValue = stringValue;
      }
      return stringValue;
    }
  }
  class UriPathEmpty extends UriPath {
    constructor() {
      super();
    }
    isDefined() {
      return false;
    }
    isAbsolute() {
      return false;
    }
    isRelative() {
      return true;
    }
    isEmpty() {
      return true;
    }
    head() {
      throw new Error("empty path");
    }
    tail() {
      throw new Error("empty path");
    }
    setTail(tail) {
      throw new Error("empty path");
    }
    dealias() {
      return this;
    }
    parent() {
      return this;
    }
    base() {
      return this;
    }
    appended(...components) {
      return UriPath.of(...components);
    }
    appendedSlash() {
      return UriPath.slash();
    }
    appendedSegment(segment) {
      return UriPath.segment(segment);
    }
    prepended(...components) {
      return UriPath.of(...components);
    }
    prependedSlash() {
      return UriPath.slash();
    }
    prependedSegment(segment) {
      return UriPath.segment(segment);
    }
    merge(that) {
      return that;
    }
    debug(output) {
      output = output.write("UriPath").write(46).write("empty").write(40).write(41);
      return output;
    }
    display(output) {
      return output;
    }
    toString() {
      return "";
    }
  }
  class UriPathBuilder {
    constructor() {
      this.first = UriPath.empty();
      this.last = null;
      this.size = 0;
      this.aliased = 0;
    }
    isEmpty() {
      return this.size === 0;
    }
    push(...components) {
      for (let i = 0; i < components.length; i += 1) {
        const component = components[i];
        if (component instanceof UriPath) {
          this.addPath(component);
        } else if (Array.isArray(component)) {
          this.push(...component);
        } else if (component === "/") {
          this.addSlash();
        } else {
          this.addSegment(component);
        }
      }
    }
    bind() {
      this.aliased = 0;
      return this.first;
    }
    addSlash() {
      const tail = UriPath.slash().dealias();
      const size = this.size;
      if (size === 0) {
        this.first = tail;
      } else {
        this.dealias(size - 1).setTail(tail);
      }
      this.last = tail;
      this.size = size + 1;
      this.aliased += 1;
    }
    addSegment(segment) {
      const tail = UriPath.segment(segment, UriPath.empty());
      let size = this.size;
      if (size === 0) {
        this.first = tail;
      } else {
        const last = this.dealias(size - 1);
        if (last.isAbsolute()) {
          last.setTail(tail);
        } else {
          last.setTail(tail.prependedSlash());
          size += 1;
          this.aliased += 1;
        }
      }
      this.last = tail;
      this.size = size + 1;
      this.aliased += 1;
    }
    addPath(path) {
      if (!path.isEmpty()) {
        let size = this.size;
        if (size === 0) {
          this.first = path;
        } else {
          const last = this.dealias(size - 1);
          if (last.isAbsolute() || path.isAbsolute()) {
            last.setTail(path);
          } else {
            last.setTail(path.prependedSlash());
            size += 1;
            this.aliased += 1;
          }
        }
        size += 1;
        do {
          const tail = path.tail();
          if (!tail.isEmpty()) {
            path = tail;
            size += 1;
          } else {
            break;
          }
        } while (true);
        this.last = path;
        this.size = size;
      }
    }
    pop() {
      const size = this.size;
      const aliased = this.aliased;
      if (size === 0) {
        throw new Error("Empty UriPath");
      } else if (size === 1) {
        const first = this.first;
        this.first = first.tail();
        if (first.tail().isEmpty()) {
          this.last = null;
        }
        this.size = size - 1;
        if (aliased > 0) {
          this.aliased = aliased - 1;
        }
        return first;
      } else {
        const last = this.dealias(size - 2);
        last.setTail(UriPath.empty());
        this.last = last;
        this.size = size - 1;
        this.aliased = aliased - 1;
        return last.tail();
      }
    }
    dealias(n) {
      let i = 0;
      let xi = null;
      let xs = this.first;
      if (this.aliased <= n) {
        while (i < this.aliased) {
          xi = xs;
          xs = xs.tail();
          i += 1;
        }
        while (i <= n) {
          const xn = xs.dealias();
          if (i === 0) {
            this.first = xn;
          } else {
            xi.setTail(xn);
          }
          xi = xn;
          xs = xs.tail();
          i += 1;
        }
        if (i === this.size) {
          this.last = xi;
        }
        this.aliased = i;
      } else if (n === 0) {
        xi = this.first;
      } else if (n === this.size - 1) {
        xi = this.last;
      } else {
        while (i <= n) {
          xi = xs;
          xs = xs.tail();
          i += 1;
        }
      }
      return xi;
    }
  }
  class UriPathForm extends Form {
    constructor(unit) {
      super();
      Object.defineProperty(this, "unit", {
        value: unit,
        enumerable: true
      });
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new UriPathForm(unit);
      } else {
        return this;
      }
    }
    mold(object, item) {
      object = UriPath.fromAny(object);
      if (item === void 0) {
        return Text.from(object.toString());
      } else {
        return item.concat(Text.from(object.toString()));
      }
    }
    cast(item, object) {
      const value = item.target;
      try {
        const string = value.stringValue();
        if (typeof string === "string") {
          return UriPath.parse(string);
        }
      } catch (error) {}
      return void 0;
    }
  }
  class UriQuery {
    get length() {
      let n = 0;
      let query = this;
      while (!query.isEmpty()) {
        n += 1;
        query = query.tail();
      }
      return n;
    }
    has(key) {
      let query = this;
      while (!query.isEmpty()) {
        if (key === query.key) {
          return true;
        }
        query = query.tail();
      }
      return false;
    }
    get(key) {
      let query = this;
      while (!query.isEmpty()) {
        if (key === query.key) {
          return query.value;
        }
        query = query.tail();
      }
      return void 0;
    }
    updated(key, value) {
      let query = this;
      const builder = new UriQueryBuilder;
      let updated = false;
      while (!query.isEmpty()) {
        if (key === query.key) {
          builder.addParam(key, value);
          updated = true;
        } else {
          builder.addParam(query.key, query.value);
        }
        query = query.tail();
      }
      if (!updated) {
        builder.addParam(key, value);
      }
      return builder.bind();
    }
    removed(key) {
      let query = this;
      const builder = new UriQueryBuilder;
      let updated = false;
      while (!query.isEmpty()) {
        if (key === query.key) {
          updated = true;
        } else {
          builder.addParam(query.key, query.value);
        }
        query = query.tail();
      }
      if (updated) {
        return builder.bind();
      } else {
        return this;
      }
    }
    appended(key, value) {
      const builder = new UriQueryBuilder;
      builder.addQuery(this);
      builder.add(key, value);
      return builder.bind();
    }
    prepended(key, value) {
      const builder = new UriQueryBuilder;
      builder.add(key, value);
      builder.addQuery(this);
      return builder.bind();
    }
    toAny(params) {
      if (this.isDefined()) {
        params = params || {};
        let query = this;
        let i = 0;
        while (!query.isEmpty()) {
          const key = query.key;
          if (key !== void 0) {
            params[key] = query.value;
          } else {
            params["$" + i] = query.value;
          }
          query = query.tail();
          i += 1;
        }
      }
      return params;
    }
    compareTo(that) {
      if (that instanceof UriQuery) {
        return this.toString().localeCompare(that.toString());
      }
      return NaN;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof UriQuery) {
        return this.toString() === that.toString();
      }
      return false;
    }
    hashCode() {
      return Strings.hash(this.toString());
    }
    display(output) {
      let query = this;
      let first = true;
      while (!query.isEmpty()) {
        if (!first) {
          output = output.write(38);
        } else {
          first = false;
        }
        const key = query.key;
        if (key !== void 0) {
          output = Uri.writeParam(output, key);
          output = output.write(61);
        }
        output = Uri.writeQuery(output, query.value);
        query = query.tail();
      }
      return output;
    }
    static undefined() {
      return new UriQueryUndefined;
    }
    static param(key, value, tail) {
      if (tail === void 0) {
        tail = value;
        value = key;
        key = void 0;
      } else if (key !== void 0) {
        key = this.cacheKey(key);
      }
      if (tail === void 0) {
        tail = UriQuery.undefined();
      }
      return new UriQueryParam(key, value, tail);
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return UriQuery.undefined();
      } else if (value instanceof UriQuery) {
        return value;
      } else if (typeof value === "object") {
        const builder = new UriQueryBuilder;
        builder.add(value);
        return builder.bind();
      } else if (typeof value === "string") {
        return UriQuery.parse(value);
      } else {
        throw new TypeError("" + value);
      }
    }
    static parse(queryPart) {
      return Uri.standardParser.parseQueryString(queryPart);
    }
    static builder() {
      return new UriQueryBuilder;
    }
    static get keyCache() {
      const keyCacheSize = 64;
      return new HashGenCacheSet(keyCacheSize);
    }
    static cacheKey(key) {
      if (key.length <= 32) {
        return UriQuery.keyCache.put(key);
      } else {
        return key;
      }
    }
  }
  __decorate([ Lazy ], UriQuery, "undefined", null);
  __decorate([ Lazy ], UriQuery, "keyCache", null);
  class UriQueryParam extends UriQuery {
    constructor(key, value, tail) {
      super();
      this.key = key;
      this.value = value;
      this.rest = tail;
      this.stringValue = void 0;
    }
    isDefined() {
      return true;
    }
    isEmpty() {
      return false;
    }
    head() {
      return [ this.key, this.value ];
    }
    tail() {
      return this.rest;
    }
    setTail(tail) {
      this.rest = tail;
    }
    dealias() {
      return new UriQueryParam(this.key, this.value, this.rest);
    }
    debug(output) {
      output = output.write("UriQuery").write(46).write("parse").write(40).write(34).display(this).write(34).write(41);
      return output;
    }
    display(output) {
      const stringValue = this.stringValue;
      if (stringValue !== void 0) {
        output = output.write(stringValue);
      } else {
        output = super.display(output);
      }
      return output;
    }
    toString() {
      let stringValue = this.stringValue;
      if (stringValue === void 0) {
        stringValue = Format.display(this);
        this.stringValue = stringValue;
      }
      return stringValue;
    }
  }
  class UriQueryUndefined extends UriQuery {
    isDefined() {
      return false;
    }
    isEmpty() {
      return true;
    }
    head() {
      throw new Error("undefined query");
    }
    get key() {
      throw new Error("undefined query");
    }
    get value() {
      throw new Error("undefined query");
    }
    tail() {
      throw new Error("undefined query");
    }
    setTail(tail) {
      throw new Error("undefined query");
    }
    dealias() {
      return this;
    }
    updated(key, value) {
      return UriQuery.param(key, value, this);
    }
    removed(key) {
      return this;
    }
    appended(key, value) {
      const builder = new UriQueryBuilder;
      builder.add(key, value);
      return builder.bind();
    }
    prepended(key, value) {
      const builder = new UriQueryBuilder;
      builder.add(key, value);
      return builder.bind();
    }
    debug(output) {
      output = output.write("UriQuery").write(46).write("undefined").write(40).write(41);
      return output;
    }
    display(output) {
      return output;
    }
    toString() {
      return "";
    }
  }
  class UriQueryBuilder {
    constructor() {
      this.first = UriQuery.undefined();
      this.last = null;
      this.size = 0;
      this.aliased = 0;
    }
    isEmpty() {
      return this.size === 0;
    }
    add(key, value) {
      if (value !== void 0) {
        this.addParam(key, value);
      } else if (typeof key === "string") {
        this.addParam(void 0, key);
      } else if (key instanceof UriQuery) {
        this.addQuery(key);
      } else {
        const params = key;
        for (const k in params) {
          let key = k;
          const value = params[k];
          if (k.charCodeAt(0) === 36) {
            key = void 0;
          }
          this.addParam(key, value);
        }
      }
    }
    bind() {
      this.aliased = 0;
      return this.first;
    }
    addParam(key, value) {
      if (value === void 0) {
        value = key;
        key = void 0;
      }
      const tail = UriQuery.param(key, value, UriQuery.undefined());
      const size = this.size;
      if (size === 0) {
        this.first = tail;
      } else {
        this.dealias(size - 1).setTail(tail);
      }
      this.last = tail;
      this.size = size + 1;
      this.aliased += 1;
    }
    addQuery(query) {
      if (!query.isEmpty()) {
        let size = this.size;
        if (size === 0) {
          this.first = query;
        } else {
          this.dealias(size - 1).setTail(query);
        }
        size += 1;
        do {
          const tail = query.tail();
          if (!tail.isEmpty()) {
            query = tail;
            size += 1;
          } else {
            break;
          }
        } while (true);
        this.last = query;
        this.size = size;
      }
    }
    dealias(n) {
      let i = 0;
      let xi = null;
      let xs = this.first;
      if (this.aliased <= n) {
        while (i < this.aliased) {
          xi = xs;
          xs = xs.tail();
          i += 1;
        }
        while (i <= n) {
          const xn = xs.dealias();
          if (i === 0) {
            this.first = xn;
          } else {
            xi.setTail(xn);
          }
          xi = xn;
          xs = xs.tail();
          i += 1;
        }
        if (i === this.size) {
          this.last = xi;
        }
        this.aliased = i;
      } else if (n === 0) {
        xi = this.first;
      } else if (n === this.size - 1) {
        xi = this.last;
      } else {
        while (i <= n) {
          xi = xs;
          xs = xs.tail();
          i += 1;
        }
      }
      return xi;
    }
  }
  class UriFragment {
    constructor(identifier) {
      this.identifier = identifier;
      this.stringValue = void 0;
    }
    isDefined() {
      return this.identifier !== void 0;
    }
    toAny() {
      return this.identifier;
    }
    compareTo(that) {
      if (that instanceof UriFragment) {
        return this.toString().localeCompare(that.toString());
      }
      return NaN;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof UriFragment) {
        return this.identifier === that.identifier;
      }
      return false;
    }
    hashCode() {
      return Strings.hash(this.identifier);
    }
    debug(output) {
      output = output.write("UriFragment").write(46);
      if (this.isDefined()) {
        output = output.write("parse").write(40).write(34).display(this).write(34).write(41);
      } else {
        output = output.write("undefined").write(40).write(41);
      }
      return output;
    }
    display(output) {
      const stringValue = this.stringValue;
      if (stringValue !== void 0) {
        output = output.write(stringValue);
      } else if (this.identifier !== void 0) {
        output = Uri.writeFragment(output, this.identifier);
      }
      return output;
    }
    toString() {
      let stringValue = this.stringValue;
      if (stringValue === void 0) {
        stringValue = Format.display(this);
        this.stringValue = stringValue;
      }
      return stringValue;
    }
    static undefined() {
      return new UriFragment(void 0);
    }
    static create(identifier) {
      if (identifier !== void 0) {
        const cache = UriFragment.cache;
        const fragment = cache.get(identifier);
        if (fragment !== void 0) {
          return fragment;
        } else {
          return cache.put(identifier, new UriFragment(identifier));
        }
      } else {
        return UriFragment.undefined();
      }
    }
    static fromAny(value) {
      if (value === void 0 || value === null) {
        return UriFragment.undefined();
      } else if (value instanceof UriFragment) {
        return value;
      } else if (typeof value === "string") {
        return UriFragment.parse(value);
      } else {
        throw new TypeError("" + value);
      }
    }
    static parse(fragmentPart) {
      return Uri.standardParser.parseFragmentString(fragmentPart);
    }
    static get cache() {
      const cacheSize = 32;
      return new HashGenCacheMap(cacheSize);
    }
  }
  __decorate([ Lazy ], UriFragment, "undefined", null);
  __decorate([ Lazy ], UriFragment, "cache", null);
  class UriForm extends Form {
    constructor(unit) {
      super();
      Object.defineProperty(this, "unit", {
        value: unit,
        enumerable: true
      });
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new UriForm(unit);
      } else {
        return this;
      }
    }
    mold(object, item) {
      object = Uri.fromAny(object);
      if (item === void 0) {
        return Text.from(object.toString());
      } else {
        return item.concat(Text.from(object.toString()));
      }
    }
    cast(item, object) {
      const value = item.target;
      try {
        const string = value.stringValue();
        if (typeof string === "string") {
          return Uri.parse(string);
        }
      } catch (error) {}
      return void 0;
    }
  }
  class UriCache {
    constructor(base, size = 32) {
      this.base = base;
      this.resolveCache = new HashGenCacheMap(size);
      this.unresolveCache = new HashGenCacheMap(size);
    }
    resolve(relative) {
      relative = Uri.fromAny(relative);
      let absolute = this.resolveCache.get(relative);
      if (absolute === void 0) {
        absolute = this.base.resolve(relative);
        this.resolveCache.put(relative, absolute);
      }
      return absolute;
    }
    unresolve(absolute) {
      absolute = Uri.fromAny(absolute);
      let relative = this.unresolveCache.get(absolute);
      if (relative === void 0) {
        relative = this.base.unresolve(absolute);
        this.unresolveCache.put(absolute, relative);
      }
      return relative;
    }
  }
  class UriParser {
    absolute(scheme, authority, path, query, fragment) {
      return Uri.create(scheme, authority, path, query, fragment);
    }
    scheme(name) {
      return UriScheme.create(name);
    }
    authority(user, host, port) {
      return UriAuthority.create(user, host, port);
    }
    user(username, password) {
      return UriUser.create(username, password);
    }
    hostName(address) {
      return UriHost.hostname(address);
    }
    hostIPv4(address) {
      return UriHost.ipv4(address);
    }
    hostIPv6(address) {
      return UriHost.ipv6(address);
    }
    port(number) {
      return UriPort.create(number);
    }
    pathEmpty() {
      return UriPath.empty();
    }
    pathBuilder() {
      return new UriPathBuilder;
    }
    queryBuilder() {
      return new UriQueryBuilder;
    }
    fragment(identifier) {
      return UriFragment.create(identifier);
    }
    absoluteParser() {
      return new UriAbsoluteParser(this);
    }
    parseAbsolute(input) {
      return UriAbsoluteParser.parse(input, this);
    }
    parseAbsoluteString(string) {
      const input = Unicode.stringInput(string);
      let parser = this.parseAbsolute(input);
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    schemeParser() {
      return new UriSchemeParser(this);
    }
    parseScheme(input) {
      return UriSchemeParser.parse(input, this);
    }
    parseSchemeString(string) {
      const input = Unicode.stringInput(string);
      let parser = this.parseScheme(input);
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    authorityParser() {
      return new UriAuthorityParser(this);
    }
    parseAuthority(input) {
      return UriAuthorityParser.parse(input, this);
    }
    parseAuthorityString(string) {
      const input = Unicode.stringInput(string);
      let parser = this.parseAuthority(input);
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    userParser() {
      return new UriUserParser(this);
    }
    parseUser(input) {
      return UriUserParser.parse(input, this);
    }
    parseUserString(string) {
      const input = Unicode.stringInput(string);
      let parser = this.parseUser(input);
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    hostParser() {
      return new UriHostParser(this);
    }
    parseHost(input) {
      return UriHostParser.parse(input, this);
    }
    parseHostString(string) {
      const input = Unicode.stringInput(string);
      let parser = this.parseHost(input);
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    hostAddressParser() {
      return new UriHostAddressParser(this);
    }
    parseHostAddress(input) {
      return UriHostAddressParser.parse(input, this);
    }
    hostLiteralParser() {
      return new UriHostLiteralParser(this);
    }
    parseHostLiteral(input) {
      return UriHostLiteralParser.parse(input, this);
    }
    portParser() {
      return new UriPortParser(this);
    }
    parsePort(input) {
      return UriPortParser.parse(input, this);
    }
    parsePortString(string) {
      const input = Unicode.stringInput(string);
      let parser = this.parsePort(input);
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    pathParser(builder) {
      return new UriPathParser(this, builder);
    }
    parsePath(input, builder) {
      return UriPathParser.parse(input, this, builder);
    }
    parsePathString(string) {
      const input = Unicode.stringInput(string);
      let parser = this.parsePath(input);
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    queryParser(builder) {
      return new UriQueryParser(this, builder);
    }
    parseQuery(input, builder) {
      return UriQueryParser.parse(input, this, builder);
    }
    parseQueryString(string) {
      const input = Unicode.stringInput(string);
      let parser = this.parseQuery(input);
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    fragmentParser() {
      return new UriFragmentParser(this);
    }
    parseFragment(input) {
      return UriFragmentParser.parse(input, this);
    }
    parseFragmentString(string) {
      const input = Unicode.stringInput(string);
      let parser = this.parseFragment(input);
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
  }
  class UriAbsoluteParser extends Parser {
    constructor(uri, schemeParser, authorityParser, pathParser, queryParser, fragmentParser, step) {
      super();
      this.uri = uri;
      this.schemeParser = schemeParser;
      this.authorityParser = authorityParser;
      this.pathParser = pathParser;
      this.queryParser = queryParser;
      this.fragmentParser = fragmentParser;
      this.step = step;
    }
    feed(input) {
      return UriAbsoluteParser.parse(input, this.uri, this.schemeParser, this.authorityParser, this.pathParser, this.queryParser, this.fragmentParser, this.step);
    }
    static parse(input, uri, schemeParser, authorityParser, pathParser, queryParser, fragmentParser, step = 1) {
      let c = 0;
      if (step === 1) {
        if (input.isCont()) {
          const look = input.clone();
          while (look.isCont() && (c = look.head(), Uri.isSchemeChar(c))) {
            look.step();
          }
          if (look.isCont() && c === 58) {
            step = 2;
          } else {
            step = 3;
          }
        } else if (input.isDone()) {
          step = 3;
        }
      }
      if (step === 2) {
        if (schemeParser === void 0) {
          schemeParser = uri.parseScheme(input);
        } else {
          schemeParser = schemeParser.feed(input);
        }
        if (schemeParser.isDone()) {
          if (input.isCont() && input.head() === 58) {
            input = input.step();
            step = 3;
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected(58, input));
          }
        } else if (schemeParser.isError()) {
          return schemeParser.asError();
        }
      }
      if (step === 3) {
        if (input.isCont()) {
          c = input.head();
          if (c === 47) {
            input = input.step();
            step = 4;
          } else if (c === 63) {
            input = input.step();
            step = 7;
          } else if (c === 35) {
            input = input.step();
            step = 8;
          } else {
            step = 6;
          }
        } else if (input.isDone()) {
          return Parser.done(uri.absolute(schemeParser !== void 0 ? schemeParser.bind() : void 0));
        }
      }
      if (step === 4) {
        if (input.isCont() && input.head() === 47) {
          input = input.step();
          step = 5;
        } else if (input.isCont()) {
          const pathBuilder = uri.pathBuilder();
          pathBuilder.addSlash();
          pathParser = uri.parsePath(input, pathBuilder);
          step = 6;
        } else if (input.isDone()) {
          return Parser.done(uri.absolute(schemeParser !== void 0 ? schemeParser.bind() : void 0, void 0, UriPath.slash()));
        }
      }
      if (step === 5) {
        if (authorityParser === void 0) {
          authorityParser = uri.parseAuthority(input);
        } else {
          authorityParser = authorityParser.feed(input);
        }
        if (authorityParser.isDone()) {
          if (input.isCont()) {
            c = input.head();
            if (c === 63) {
              input = input.step();
              step = 7;
            } else if (c === 35) {
              input = input.step();
              step = 8;
            } else {
              step = 6;
            }
          } else if (input.isDone()) {
            return Parser.done(uri.absolute(schemeParser !== void 0 ? schemeParser.bind() : void 0, authorityParser !== void 0 ? authorityParser.bind() : void 0));
          }
        } else if (authorityParser.isError()) {
          return authorityParser.asError();
        }
      }
      if (step === 6) {
        if (pathParser === void 0) {
          pathParser = uri.parsePath(input);
        } else {
          pathParser = pathParser.feed(input);
        }
        if (pathParser.isDone()) {
          if (input.isCont() && input.head() === 63) {
            input = input.step();
            step = 7;
          } else if (input.isCont() && input.head() === 35) {
            input = input.step();
            step = 8;
          } else if (!input.isEmpty()) {
            return Parser.done(uri.absolute(schemeParser !== void 0 ? schemeParser.bind() : void 0, authorityParser !== void 0 ? authorityParser.bind() : void 0, pathParser.bind()));
          }
        } else if (pathParser.isError()) {
          return pathParser.asError();
        }
      }
      if (step === 7) {
        if (queryParser === void 0) {
          queryParser = uri.parseQuery(input);
        } else {
          queryParser = queryParser.feed(input);
        }
        if (queryParser.isDone()) {
          if (input.isCont() && input.head() === 35) {
            input = input.step();
            step = 8;
          } else if (!input.isEmpty()) {
            return Parser.done(uri.absolute(schemeParser !== void 0 ? schemeParser.bind() : void 0, authorityParser !== void 0 ? authorityParser.bind() : void 0, pathParser !== void 0 ? pathParser.bind() : void 0, queryParser.bind()));
          }
        } else if (queryParser.isError()) {
          return queryParser.asError();
        }
      }
      if (step === 8) {
        if (fragmentParser === void 0) {
          fragmentParser = uri.parseFragment(input);
        } else {
          fragmentParser = fragmentParser.feed(input);
        }
        if (fragmentParser.isDone()) {
          return Parser.done(uri.absolute(schemeParser !== void 0 ? schemeParser.bind() : void 0, authorityParser !== void 0 ? authorityParser.bind() : void 0, pathParser !== void 0 ? pathParser.bind() : void 0, queryParser !== void 0 ? queryParser.bind() : void 0, fragmentParser.bind()));
        } else if (fragmentParser.isError()) {
          return fragmentParser.asError();
        }
      }
      return new UriAbsoluteParser(uri, schemeParser, authorityParser, pathParser, queryParser, fragmentParser, step);
    }
  }
  class UriSchemeParser extends Parser {
    constructor(uri, output, step) {
      super();
      this.uri = uri;
      this.output = output;
      this.step = step;
    }
    feed(input) {
      return UriSchemeParser.parse(input, this.uri, this.output, this.step);
    }
    static parse(input, uri, output, step = 1) {
      let c = 0;
      if (step === 1) {
        if (input.isCont() && (c = input.head(), Uri.isAlpha(c))) {
          input = input.step();
          output = output || Utf8.decodedString();
          output = output.write(Uri.toLowerCase(c));
          step = 2;
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.expected("scheme", input));
        }
      }
      if (step === 2) {
        while (input.isCont() && (c = input.head(), Uri.isSchemeChar(c))) {
          input = input.step();
          output.write(Uri.toLowerCase(c));
        }
        if (!input.isEmpty()) {
          return Parser.done(uri.scheme(output.bind()));
        }
      }
      return new UriSchemeParser(uri, output, step);
    }
  }
  class UriAuthorityParser extends Parser {
    constructor(uri, userParser, hostParser, portParser, step) {
      super();
      this.uri = uri;
      this.userParser = userParser;
      this.hostParser = hostParser;
      this.portParser = portParser;
      this.step = step;
    }
    feed(input) {
      return UriAuthorityParser.parse(input, this.uri, this.userParser, this.hostParser, this.portParser, this.step);
    }
    static parse(input, uri, userParser, hostParser, portParser, step = 1) {
      let c = 0;
      if (step === 1) {
        if (input.isCont()) {
          const look = input.clone();
          while (look.isCont() && (c = look.head(), c !== 64 && c !== 47)) {
            look.step();
          }
          if (look.isCont() && c === 64) {
            step = 2;
          } else {
            step = 3;
          }
        } else if (input.isDone()) {
          step = 3;
        }
      }
      if (step === 2) {
        if (userParser === void 0) {
          userParser = uri.parseUser(input);
        } else {
          userParser = userParser.feed(input);
        }
        if (userParser.isDone()) {
          if (input.isCont() && input.head() === 64) {
            input = input.step();
            step = 3;
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected(64, input));
          }
        } else if (userParser.isError()) {
          return userParser.asError();
        }
      }
      if (step === 3) {
        if (hostParser === void 0) {
          hostParser = uri.parseHost(input);
        } else {
          hostParser = hostParser.feed(input);
        }
        if (hostParser.isDone()) {
          if (input.isCont() && input.head() === 58) {
            input = input.step();
            step = 4;
          } else if (!input.isEmpty()) {
            return Parser.done(uri.authority(userParser !== void 0 ? userParser.bind() : void 0, hostParser.bind()));
          }
        } else if (hostParser.isError()) {
          return hostParser.asError();
        }
      }
      if (step === 4) {
        if (portParser === void 0) {
          portParser = uri.parsePort(input);
        } else {
          portParser = portParser.feed(input);
        }
        if (portParser.isDone()) {
          return Parser.done(uri.authority(userParser !== void 0 ? userParser.bind() : void 0, hostParser.bind(), portParser.bind()));
        } else if (portParser.isError()) {
          return portParser.asError();
        }
      }
      return new UriAuthorityParser(uri, userParser, hostParser, portParser, step);
    }
  }
  class UriUserParser extends Parser {
    constructor(uri, usernameOutput, passwordOutput, c1, step) {
      super();
      this.uri = uri;
      this.usernameOutput = usernameOutput;
      this.passwordOutput = passwordOutput;
      this.c1 = c1;
      this.step = step;
    }
    feed(input) {
      return UriUserParser.parse(input, this.uri, this.usernameOutput, this.passwordOutput, this.c1, this.step);
    }
    static parse(input, uri, usernameOutput, passwordOutput, c1 = 0, step = 1) {
      let c = 0;
      do {
        if (step === 1) {
          usernameOutput = usernameOutput || Utf8.decodedString();
          while (input.isCont() && (c = input.head(), Uri.isUserChar(c))) {
            input = input.step();
            usernameOutput.write(c);
          }
          if (input.isCont() && c === 58) {
            input = input.step();
            step = 4;
          } else if (input.isCont() && c === 37) {
            input = input.step();
            step = 2;
          } else if (!input.isEmpty()) {
            return Parser.done(uri.user(usernameOutput.bind()));
          }
        }
        if (step === 2) {
          if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
            input = input.step();
            c1 = c;
            step = 3;
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected("hex digit", input));
          }
        }
        if (step === 3) {
          if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
            input = input.step();
            usernameOutput.write(Base16.decodeDigit(c1) << 4 | Base16.decodeDigit(c));
            c1 = 0;
            step = 1;
            continue;
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected("hex digit", input));
          }
        }
        if (step === 4) {
          passwordOutput = passwordOutput || Utf8.decodedString();
          while (input.isCont() && (c = input.head(), Uri.isUserInfoChar(c))) {
            input = input.step();
            passwordOutput.write(c);
          }
          if (input.isCont() && c === 37) {
            input = input.step();
            step = 5;
          } else if (!input.isEmpty()) {
            return Parser.done(uri.user(usernameOutput.bind(), passwordOutput.bind()));
          }
        }
        if (step === 5) {
          if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
            input = input.step();
            c1 = c;
            step = 6;
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected("hex digit", input));
          }
        }
        if (step === 6) {
          if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
            input = input.step();
            passwordOutput.write(Base16.decodeDigit(c1) << 4 | Base16.decodeDigit(c));
            c1 = 0;
            step = 4;
            continue;
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected("hex digit", input));
          }
        }
        break;
      } while (true);
      return new UriUserParser(uri, usernameOutput, passwordOutput, c1, step);
    }
  }
  class UriHostParser extends Parser {
    constructor(uri) {
      super();
      this.uri = uri;
    }
    feed(input) {
      return UriHostParser.parse(input, this.uri);
    }
    static parse(input, uri) {
      if (input.isCont()) {
        const c = input.head();
        if (c === 91) {
          return uri.parseHostLiteral(input);
        } else {
          return uri.parseHostAddress(input);
        }
      } else if (input.isDone()) {
        return Parser.done(uri.hostName(""));
      }
      return new UriHostParser(uri);
    }
  }
  class UriHostAddressParser extends Parser {
    constructor(uri, output, c1, x, step) {
      super();
      this.uri = uri;
      this.output = output;
      this.c1 = c1;
      this.x = x;
      this.step = step;
    }
    feed(input) {
      return UriHostAddressParser.parse(input, this.uri, this.output, this.c1, this.x, this.step);
    }
    static parse(input, uri, output, c1 = 0, x = 0, step = 1) {
      let c = 0;
      output = output || Utf8.decodedString();
      while (step <= 4) {
        while (input.isCont() && (c = input.head(), Base10.isDigit(c))) {
          input = input.step();
          output = output.write(c);
          x = 10 * x + Base10.decodeDigit(c);
        }
        if (input.isCont()) {
          if (c === 46 && step < 4 && x <= 255) {
            input = input.step();
            output = output.write(c);
            x = 0;
            step += 1;
          } else if (!Uri.isHostChar(c) && c !== 37 && step === 4 && x <= 255) {
            return Parser.done(uri.hostIPv4(output.bind()));
          } else {
            x = 0;
            step = 5;
            break;
          }
        } else if (!input.isEmpty()) {
          if (step === 4 && x <= 255) {
            return Parser.done(uri.hostIPv4(output.bind()));
          } else {
            return Parser.done(uri.hostName(output.bind()));
          }
        } else {
          break;
        }
      }
      do {
        if (step === 5) {
          while (input.isCont() && (c = input.head(), Uri.isHostChar(c))) {
            input = input.step();
            output.write(Uri.toLowerCase(c));
          }
          if (input.isCont() && c === 37) {
            input = input.step();
            step = 6;
          } else if (!input.isEmpty()) {
            return Parser.done(uri.hostName(output.bind()));
          }
        }
        if (step === 6) {
          if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
            input = input.step();
            c1 = c;
            step = 7;
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected("hex digit", input));
          }
        }
        if (step === 7) {
          if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
            input = input.step();
            output.write(Base16.decodeDigit(c1) << 4 | Base16.decodeDigit(c));
            c1 = 0;
            step = 5;
            continue;
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected("hex digit", input));
          }
        }
        break;
      } while (true);
      return new UriHostAddressParser(uri, output, c1, x, step);
    }
  }
  class UriHostLiteralParser extends Parser {
    constructor(uri, output, step) {
      super();
      this.uri = uri;
      this.output = output;
      this.step = step;
    }
    feed(input) {
      return UriHostLiteralParser.parse(input, this.uri, this.output, this.step);
    }
    static parse(input, uri, output, step = 1) {
      let c = 0;
      if (step === 1) {
        if (input.isCont() && input.head() === 91) {
          input = input.step();
          step = 2;
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.expected(91, input));
        }
      }
      if (step === 2) {
        output = output || Utf8.decodedString();
        while (input.isCont() && (c = input.head(), Uri.isHostChar(c) || c === 58)) {
          input = input.step();
          output = output.write(Uri.toLowerCase(c));
        }
        if (input.isCont() && c === 93) {
          input = input.step();
          return Parser.done(uri.hostIPv6(output.bind()));
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.expected(93, input));
        }
      }
      return new UriHostLiteralParser(uri, output, step);
    }
  }
  class UriPortParser extends Parser {
    constructor(uri, number) {
      super();
      this.uri = uri;
      this.number = number;
    }
    feed(input) {
      return UriPortParser.parse(input, this.uri, this.number);
    }
    static parse(input, uri, number = 0) {
      let c = 0;
      while (input.isCont() && (c = input.head(), Base10.isDigit(c))) {
        input = input.step();
        number = 10 * number + Base10.decodeDigit(c);
      }
      if (!input.isEmpty()) {
        return Parser.done(uri.port(number));
      }
      return new UriPortParser(uri, number);
    }
  }
  class UriPathParser extends Parser {
    constructor(uri, builder, output, c1, step) {
      super();
      this.uri = uri;
      this.builder = builder;
      this.output = output;
      this.c1 = c1;
      this.step = step;
    }
    feed(input) {
      return UriPathParser.parse(input, this.uri, this.builder, this.output, this.c1, this.step);
    }
    static parse(input, uri, builder, output, c1 = 0, step = 1) {
      let c = 0;
      do {
        if (step === 1) {
          while (input.isCont() && (c = input.head(), Uri.isPathChar(c))) {
            output = output || Utf8.decodedString();
            input = input.step();
            output = output.write(c);
          }
          if (input.isCont() && c === 47) {
            input = input.step();
            builder = builder || uri.pathBuilder();
            if (output !== void 0) {
              builder.addSegment(output.bind());
              output = void 0;
            }
            builder.addSlash();
            continue;
          } else if (input.isCont() && c === 37) {
            input = input.step();
            step = 2;
          } else if (!input.isEmpty()) {
            if (output !== void 0) {
              builder = builder || uri.pathBuilder();
              builder.addSegment(output.bind());
            }
            if (builder !== void 0) {
              return Parser.done(builder.bind());
            } else {
              return Parser.done(uri.pathEmpty());
            }
          }
        }
        if (step === 2) {
          if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
            input = input.step();
            c1 = c;
            step = 3;
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected("hex digit", input));
          }
        }
        if (step === 3) {
          if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
            output = output || Utf8.decodedString();
            input = input.step();
            output = output.write(Base16.decodeDigit(c1) << 4 | Base16.decodeDigit(c));
            c1 = 0;
            step = 1;
            continue;
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected("hex digit", input));
          }
        }
        break;
      } while (true);
      return new UriPathParser(uri, builder, output, c1, step);
    }
  }
  class UriQueryParser extends Parser {
    constructor(uri, builder, keyOutput, valueOutput, c1, step) {
      super();
      this.uri = uri;
      this.builder = builder;
      this.keyOutput = keyOutput;
      this.valueOutput = valueOutput;
      this.c1 = c1;
      this.step = step;
    }
    feed(input) {
      return UriQueryParser.parse(input, this.uri, this.builder, this.keyOutput, this.valueOutput, this.c1, this.step);
    }
    static parse(input, uri, builder, keyOutput, valueOutput, c1 = 0, step = 1) {
      let c = 0;
      do {
        if (step === 1) {
          keyOutput = keyOutput || Utf8.decodedString();
          while (input.isCont() && (c = input.head(), Uri.isParamChar(c))) {
            input = input.step();
            keyOutput.write(c);
          }
          if (input.isCont() && c === 61) {
            input = input.step();
            step = 4;
          } else if (input.isCont() && c === 38) {
            input = input.step();
            builder = builder || uri.queryBuilder();
            builder.addParam(keyOutput.bind());
            keyOutput = void 0;
            continue;
          } else if (input.isCont() && c === 37) {
            input = input.step();
            step = 2;
          } else if (!input.isEmpty()) {
            builder = builder || uri.queryBuilder();
            builder.addParam(keyOutput.bind());
            return Parser.done(builder.bind());
          }
        }
        if (step === 2) {
          if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
            input = input.step();
            c1 = c;
            step = 3;
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected("hex digit", input));
          }
        }
        if (step === 3) {
          if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
            input = input.step();
            keyOutput.write(Base16.decodeDigit(c1) << 4 | Base16.decodeDigit(c));
            c1 = 0;
            step = 1;
            continue;
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected("hex digit", input));
          }
        }
        if (step === 4) {
          valueOutput = valueOutput || Utf8.decodedString();
          while (input.isCont() && (c = input.head(), Uri.isParamChar(c) || c === 61)) {
            input = input.step();
            valueOutput.write(c);
          }
          if (input.isCont() && c === 38) {
            input = input.step();
            builder = builder || uri.queryBuilder();
            builder.addParam(keyOutput.bind(), valueOutput.bind());
            keyOutput = void 0;
            valueOutput = void 0;
            step = 1;
            continue;
          } else if (input.isCont() && c === 37) {
            input = input.step();
            step = 5;
          } else if (!input.isEmpty()) {
            builder = builder || uri.queryBuilder();
            builder.addParam(keyOutput.bind(), valueOutput.bind());
            return Parser.done(builder.bind());
          }
        }
        if (step === 5) {
          if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
            input = input.step();
            c1 = c;
            step = 6;
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected("hex digit", input));
          }
        }
        if (step === 6) {
          if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
            input = input.step();
            valueOutput.write(Base16.decodeDigit(c1) << 4 | Base16.decodeDigit(c));
            c1 = 0;
            step = 4;
            continue;
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected("hex digit", input));
          }
        }
        break;
      } while (true);
      return new UriQueryParser(uri, builder, keyOutput, valueOutput, c1, step);
    }
  }
  class UriFragmentParser extends Parser {
    constructor(uri, output, c1, step) {
      super();
      this.uri = uri;
      this.output = output;
      this.c1 = c1;
      this.step = step;
    }
    feed(input) {
      return UriFragmentParser.parse(input, this.uri, this.output, this.c1, this.step);
    }
    static parse(input, uri, output, c1 = 0, step = 1) {
      let c = 0;
      output = output || Utf8.decodedString();
      do {
        if (step === 1) {
          while (input.isCont() && (c = input.head(), Uri.isFragmentChar(c))) {
            input = input.step();
            output = output.write(c);
          }
          if (input.isCont() && c === 37) {
            input = input.step();
            step = 2;
          } else if (!input.isEmpty()) {
            return Parser.done(uri.fragment(output.bind()));
          }
        }
        if (step === 2) {
          if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
            input = input.step();
            c1 = c;
            step = 3;
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected("hex digit", input));
          }
        }
        if (step === 3) {
          if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {
            input = input.step();
            output = output.write(Base16.decodeDigit(c1) << 4 | Base16.decodeDigit(c));
            c1 = 0;
            step = 1;
            continue;
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.expected("hex digit", input));
          }
        }
        break;
      } while (true);
      return new UriFragmentParser(uri, output, c1, step);
    }
  }
  class LengthException extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, LengthException.prototype);
    }
  }
  class Length {
    isDefined() {
      return isFinite(this.value);
    }
    plus(that, units = this.units, basis) {
      that = Length.fromAny(that);
      return Length.create(this.toValue(units, basis) + that.toValue(units, basis), units);
    }
    negative(units = this.units, basis) {
      return Length.create(-this.toValue(units, basis), units);
    }
    minus(that, units = this.units, basis) {
      that = Length.fromAny(that);
      return Length.create(this.toValue(units, basis) - that.toValue(units, basis), units);
    }
    times(scalar, units = this.units, basis) {
      return Length.create(this.toValue(units, basis) * scalar, units);
    }
    divide(scalar, units = this.units, basis) {
      return Length.create(this.toValue(units, basis) / scalar, units);
    }
    combine(that, scalar = 1, units = this.units, basis) {
      that = Length.fromAny(that);
      return Length.create(this.toValue(units, basis) + that.toValue(units, basis) * scalar, units);
    }
    emValue(basis) {
      return this.value !== 0 ? this.pxValue(basis) / Length.emUnit(basis) : 0;
    }
    remValue(basis) {
      return this.value !== 0 ? this.pxValue(basis) / Length.remUnit(basis) : 0;
    }
    pctValue(basis) {
      return this.value !== 0 ? this.pxValue(basis) / Length.pctUnit(basis) : 0;
    }
    px(basis) {
      return Length.px(this.pxValue(basis));
    }
    em(basis) {
      return Length.em(this.emValue(basis));
    }
    rem(basis) {
      return Length.rem(this.remValue(basis));
    }
    pct(basis) {
      return Length.pct(this.pctValue(basis));
    }
    toValue(units, basis) {
      if (units === void 0) {
        return Text.from(this.toString());
      } else {
        switch (units) {
         case "px":
          return this.pxValue(basis);

         case "em":
          return this.emValue(basis);

         case "rem":
          return this.remValue(basis);

         case "%":
          return this.pctValue(basis);

         default:
          throw new LengthException("unknown length units: " + units);
        }
      }
    }
    to(units, basis) {
      switch (units) {
       case "px":
        return this.px(basis);

       case "em":
        return this.em(basis);

       case "rem":
        return this.rem(basis);

       case "%":
        return this.pct(basis);

       default:
        throw new LengthException("unknown length units: " + units);
      }
    }
    interpolateTo(that) {
      if (that instanceof Length) {
        return LengthInterpolator(this, that);
      } else {
        return null;
      }
    }
    static zero(units) {
      switch (units) {
       case void 0:
       case "px":
        return PxLength.zero();

       case "em":
        return EmLength.zero();

       case "rem":
        return RemLength.zero();

       case "%":
        return PctLength.zero();

       case "":
        return UnitlessLength.zero();

       default:
        throw new LengthException("unknown length units: " + units);
      }
    }
    static px(value) {
      return new PxLength(value);
    }
    static em(value) {
      return new EmLength(value);
    }
    static rem(value) {
      return new RemLength(value);
    }
    static pct(value) {
      return new PctLength(value);
    }
    static unitless(value) {
      return new UnitlessLength(value);
    }
    static create(value, units) {
      switch (units) {
       case void 0:
       case "px":
        return Length.px(value);

       case "em":
        return Length.em(value);

       case "rem":
        return Length.rem(value);

       case "%":
        return Length.pct(value);

       case "":
        return Length.unitless(value);

       default:
        throw new LengthException("unknown length units: " + units);
      }
    }
    static fromCssValue(value) {
      if (value instanceof CSSUnitValue) {
        return Length.create(value.value, value.unit);
      } else {
        throw new TypeError("" + value);
      }
    }
    static fromAny(value, defaultUnits) {
      if (value === void 0 || value === null || value instanceof Length) {
        return value;
      } else if (typeof value === "number") {
        return Length.create(value, defaultUnits);
      } else if (typeof value === "string") {
        return Length.parse(value, defaultUnits);
      }
      throw new TypeError("" + value);
    }
    static fromValue(value) {
      if (value.length === 2) {
        const num = value.getItem(0).numberValue(void 0);
        const units = value.getItem(1);
        if (num !== void 0 && isFinite(num) && units instanceof Attr && units.value === Value.extant()) {
          switch (units.key.value) {
           case "px":
            return Length.px(num);

           case "em":
            return Length.em(num);

           case "rem":
            return Length.rem(num);

           case "pct":
            return Length.pct(num);
          }
        }
      }
      return null;
    }
    static parse(string, defaultUnits) {
      let input = Unicode.stringInput(string);
      while (input.isCont() && Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = LengthParser.parse(input, defaultUnits);
      if (parser.isDone()) {
        while (input.isCont() && Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    static form() {
      return new LengthForm(void 0, Length.zero());
    }
    static isAny(value) {
      return value instanceof Length || typeof value === "number" || typeof value === "string";
    }
    static emUnit(basis) {
      if (typeof basis === "object" && typeof basis.emUnit === "number") {
        return basis.emUnit;
      } else if (typeof basis === "object" && basis.emUnit instanceof Node) {
        let node = basis.emUnit;
        while (node !== null) {
          if (node instanceof Element) {
            const fontSize = getComputedStyle(node).fontSize;
            if (typeof fontSize === "string") {
              return parseFloat(fontSize);
            }
          }
          node = node.parentNode;
        }
      }
      throw new LengthException("unknown em unit");
    }
    static remUnit(basis) {
      if (typeof basis === "object" && typeof basis.remUnit === "number") {
        return basis.remUnit;
      } else {
        const fontSize = getComputedStyle(document.documentElement).fontSize;
        if (typeof fontSize === "string") {
          return parseFloat(fontSize);
        }
      }
      throw new LengthException("unknown rem unit");
    }
    static pctUnit(basis) {
      if (typeof basis === "number") {
        return basis;
      } else if (typeof basis === "object" && typeof basis.pctUnit === "number") {
        return basis.pctUnit;
      }
      throw new LengthException("unknown percentage unit");
    }
  }
  __decorate([ Lazy ], Length, "form", null);
  class PxLength extends Length {
    constructor(value) {
      super();
      this.value = value;
    }
    get units() {
      return "px";
    }
    pxValue(basis) {
      return this.value;
    }
    px(basis) {
      return this;
    }
    toCssValue() {
      if (typeof CSSUnitValue !== "undefined") {
        return new CSSUnitValue(this.value, "px");
      } else {
        return null;
      }
    }
    compareTo(that) {
      if (that instanceof Length) {
        const x = this.value;
        const y = that.pxValue();
        return x < y ? -1 : x > y ? 1 : isNaN(y) ? isNaN(x) ? 0 : -1 : isNaN(x) ? 1 : 0;
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (that instanceof Length) {
        return Numbers.equivalent(this.value, that.pxValue());
      }
      return false;
    }
    equals(that) {
      if (that instanceof PxLength) {
        return this.value === that.value;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(PxLength), Numbers.hash(this.value)));
    }
    debug(output) {
      output = output.write("Length").write(46).write("px").write(40).debug(this.value).write(41);
      return output;
    }
    toString() {
      return this.value + "px";
    }
    static zero() {
      return new PxLength(0);
    }
  }
  __decorate([ Lazy ], PxLength, "zero", null);
  class EmLength extends Length {
    constructor(value) {
      super();
      this.value = value;
    }
    get units() {
      return "em";
    }
    pxValue(basis) {
      return this.value !== 0 ? this.value * Length.emUnit(basis) : 0;
    }
    emValue(basis) {
      return this.value;
    }
    em(basis) {
      return this;
    }
    toCssValue() {
      if (typeof CSSUnitValue !== "undefined") {
        return new CSSUnitValue(this.value, "em");
      } else {
        return null;
      }
    }
    compareTo(that) {
      if (that instanceof Length) {
        const x = this.value;
        const y = that.emValue();
        return x < y ? -1 : x > y ? 1 : isNaN(y) ? isNaN(x) ? 0 : -1 : isNaN(x) ? 1 : 0;
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (that instanceof Length) {
        return Numbers.equivalent(this.value, that.emValue());
      }
      return false;
    }
    equals(that) {
      if (that instanceof EmLength) {
        return this.value === that.value;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(EmLength), Numbers.hash(this.value)));
    }
    debug(output) {
      output = output.write("Length").write(46).write("em").write(40).debug(this.value).write(41);
      return output;
    }
    toString() {
      return this.value + "em";
    }
    static zero() {
      return new EmLength(0);
    }
  }
  __decorate([ Lazy ], EmLength, "zero", null);
  class RemLength extends Length {
    constructor(value) {
      super();
      this.value = value;
    }
    get units() {
      return "rem";
    }
    pxValue(basis) {
      return this.value !== 0 ? this.value * Length.remUnit(basis) : 0;
    }
    remValue(basis) {
      return this.value;
    }
    rem(basis) {
      return this;
    }
    toCssValue() {
      if (typeof CSSUnitValue !== "undefined") {
        return new CSSUnitValue(this.value, "rem");
      } else {
        return null;
      }
    }
    compareTo(that) {
      if (that instanceof RemLength) {
        const x = this.value;
        const y = that.remValue();
        return x < y ? -1 : x > y ? 1 : isNaN(y) ? isNaN(x) ? 0 : -1 : isNaN(x) ? 1 : 0;
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (that instanceof RemLength) {
        return Numbers.equivalent(this.value, that.remValue());
      }
      return false;
    }
    equals(that) {
      if (that instanceof RemLength) {
        return this.value === that.value;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(RemLength), Numbers.hash(this.value)));
    }
    debug(output) {
      output = output.write("Length").write(46).write("rem").write(40).debug(this.value).write(41);
      return output;
    }
    toString() {
      return this.value + "rem";
    }
    static zero() {
      return new RemLength(0);
    }
  }
  __decorate([ Lazy ], RemLength, "zero", null);
  class PctLength extends Length {
    constructor(value) {
      super();
      this.value = value;
    }
    get units() {
      return "%";
    }
    pxValue(basis) {
      return this.value !== 0 ? this.value * Length.pctUnit(basis) / 100 : 0;
    }
    pctValue(basis) {
      return this.value;
    }
    pct(basis) {
      return this;
    }
    toCssValue() {
      if (typeof CSSUnitValue !== "undefined") {
        return new CSSUnitValue(this.value, "percent");
      } else {
        return null;
      }
    }
    compareTo(that) {
      if (that instanceof Length) {
        const x = this.value;
        const y = that.pctValue();
        return x < y ? -1 : x > y ? 1 : isNaN(y) ? isNaN(x) ? 0 : -1 : isNaN(x) ? 1 : 0;
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (that instanceof Length) {
        return Numbers.equivalent(this.value, that.pctValue());
      }
      return false;
    }
    equals(that) {
      if (that instanceof PctLength) {
        return this.value === that.value;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(PctLength), Numbers.hash(this.value)));
    }
    debug(output) {
      output = output.write("Length").write(46).write("pct").write(40).debug(this.value).write(41);
      return output;
    }
    toString() {
      return this.value + "%";
    }
    static zero() {
      return new PctLength(0);
    }
  }
  __decorate([ Lazy ], PctLength, "zero", null);
  class UnitlessLength extends Length {
    constructor(value) {
      super();
      this.value = value;
    }
    get units() {
      return "";
    }
    pxValue(basis) {
      throw new LengthException("unitless length");
    }
    toCssValue() {
      return null;
    }
    compareTo(that) {
      if (that instanceof Length) {
        const x = this.value;
        const y = that.value;
        return x < y ? -1 : x > y ? 1 : isNaN(y) ? isNaN(x) ? 0 : -1 : isNaN(x) ? 1 : 0;
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (that instanceof Length) {
        return Numbers.equivalent(this.value, that.value);
      }
      return false;
    }
    equals(that) {
      if (that instanceof UnitlessLength) {
        return this.value === that.value;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(UnitlessLength), Numbers.hash(this.value)));
    }
    debug(output) {
      output = output.write("Length").write(46).write("unitless").write(40).debug(this.value).write(41);
      return output;
    }
    toString() {
      return this.value + "";
    }
    static zero() {
      return new UnitlessLength(0);
    }
  }
  __decorate([ Lazy ], UnitlessLength, "zero", null);
  const LengthInterpolator = function(_super) {
    const LengthInterpolator = function(l0, l1) {
      const interpolator = function(u) {
        const l0 = interpolator[0];
        const l1 = interpolator[1];
        return Length.create(l0.value + u * (l1.value - l0.value), l1.units);
      };
      Object.setPrototypeOf(interpolator, LengthInterpolator.prototype);
      interpolator[0] = l0.to(l1.units);
      interpolator[1] = l1;
      return interpolator;
    };
    LengthInterpolator.prototype = Object.create(_super.prototype);
    LengthInterpolator.prototype.constructor = LengthInterpolator;
    return LengthInterpolator;
  }(Interpolator);
  class LengthForm extends Form {
    constructor(defaultUnits, unit) {
      super();
      this.defaultUnits = defaultUnits;
      Object.defineProperty(this, "unit", {
        value: unit,
        enumerable: true
      });
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new LengthForm(this.defaultUnits, unit);
      } else {
        return this;
      }
    }
    mold(length) {
      length = Length.fromAny(length, this.defaultUnits);
      return Text.from(length.toString());
    }
    cast(item) {
      const value = item.toValue();
      let length = null;
      try {
        length = Length.fromValue(value);
        if (length !== void 0) {
          const string = value.stringValue(void 0);
          if (string !== void 0) {
            length = Length.parse(string, this.defaultUnits);
          }
        }
      } catch (e) {}
      return length !== null ? length : void 0;
    }
  }
  class LengthParser extends Parser {
    constructor(defaultUnits, valueParser, unitsOutput, step) {
      super();
      this.defaultUnits = defaultUnits;
      this.valueParser = valueParser;
      this.unitsOutput = unitsOutput;
      this.step = step;
    }
    feed(input) {
      return LengthParser.parse(input, this.defaultUnits, this.valueParser, this.unitsOutput, this.step);
    }
    static parse(input, defaultUnits, valueParser, unitsOutput, step = 1) {
      let c = 0;
      if (step === 1) {
        if (valueParser === void 0) {
          valueParser = Base10.parseDecimal(input);
        } else {
          valueParser = valueParser.feed(input);
        }
        if (valueParser.isDone()) {
          step = 2;
        } else if (valueParser.isError()) {
          return valueParser.asError();
        }
      }
      if (step === 2) {
        unitsOutput = unitsOutput || Unicode.stringOutput();
        while (input.isCont() && (c = input.head(), Unicode.isAlpha(c) || c === 37)) {
          input = input.step();
          unitsOutput.push(c);
        }
        if (!input.isEmpty()) {
          const value = valueParser.bind();
          const units = unitsOutput.bind() || defaultUnits;
          switch (units) {
           case "px":
            return Parser.done(Length.px(value));

           case "em":
            return Parser.done(Length.em(value));

           case "rem":
            return Parser.done(Length.rem(value));

           case "%":
            return Parser.done(Length.pct(value));

           case "":
           case void 0:
            return Parser.done(Length.unitless(value));

           default:
            return Parser.error(Diagnostic.message("unknown length units: " + units, input));
          }
        }
      }
      return new LengthParser(defaultUnits, valueParser, unitsOutput, step);
    }
  }
  class Angle {
    isDefined() {
      return isFinite(this.value);
    }
    plus(that, units = this.units) {
      that = Angle.fromAny(that);
      return Angle.create(this.toValue(units) + that.toValue(units), units);
    }
    negative(units = this.units) {
      return Angle.create(-this.toValue(units), units);
    }
    minus(that, units = this.units) {
      that = Angle.fromAny(that);
      return Angle.create(this.toValue(units) - that.toValue(units), units);
    }
    times(scalar, units = this.units) {
      return Angle.create(this.toValue(units) * scalar, units);
    }
    divide(scalar, units = this.units) {
      return Angle.create(this.toValue(units) / scalar, units);
    }
    combine(that, scalar = 1, units = this.units) {
      that = Angle.fromAny(that);
      return Angle.create(this.toValue(units) + that.toValue(units) * scalar, units);
    }
    norm(total, units = this.units) {
      total = Angle.fromAny(total);
      return Angle.create(this.toValue(units) / total.toValue(units), units);
    }
    deg() {
      return Angle.deg(this.degValue());
    }
    rad() {
      return Angle.rad(this.radValue());
    }
    grad() {
      return Angle.grad(this.gradValue());
    }
    turn() {
      return Angle.turn(this.turnValue());
    }
    toValue(units) {
      if (units === void 0) {
        return Text.from(this.toString());
      } else {
        switch (units) {
         case "deg":
          return this.degValue();

         case "rad":
          return this.radValue();

         case "grad":
          return this.gradValue();

         case "turn":
          return this.turnValue();

         default:
          throw new Error("unknown angle units: " + units);
        }
      }
    }
    to(units) {
      switch (units) {
       case "deg":
        return this.deg();

       case "rad":
        return this.rad();

       case "grad":
        return this.grad();

       case "turn":
        return this.turn();

       default:
        throw new Error("unknown angle units: " + units);
      }
    }
    interpolateTo(that) {
      if (that instanceof Angle) {
        return AngleInterpolator(this, that);
      } else {
        return null;
      }
    }
    static zero(units) {
      switch (units) {
       case "deg":
        return DegAngle.zero();

       case void 0:
       case "rad":
        return RadAngle.zero();

       case "grad":
        return GradAngle.zero();

       case "turn":
        return TurnAngle.zero();

       default:
        throw new Error("unknown angle units: " + units);
      }
    }
    static deg(value) {
      return new DegAngle(value);
    }
    static rad(value) {
      return new RadAngle(value);
    }
    static grad(value) {
      return new GradAngle(value);
    }
    static turn(value) {
      return new TurnAngle(value);
    }
    static create(value, units) {
      switch (units) {
       case "deg":
        return Angle.deg(value);

       case void 0:
       case "rad":
        return Angle.rad(value);

       case "grad":
        return Angle.grad(value);

       case "turn":
        return Angle.turn(value);

       default:
        throw new Error("unknown angle units: " + units);
      }
    }
    static fromCssValue(value) {
      if (value instanceof CSSUnitValue) {
        return Angle.create(value.value, value.unit);
      } else {
        throw new TypeError("" + value);
      }
    }
    static fromAny(value, defaultUnits) {
      if (value === void 0 || value === null || value instanceof Angle) {
        return value;
      } else if (typeof value === "number") {
        return Angle.create(value, defaultUnits);
      } else if (typeof value === "string") {
        return Angle.parse(value, defaultUnits);
      }
      throw new TypeError("" + value);
    }
    static fromValue(value) {
      if (value.length === 2) {
        const num = value.getItem(0).numberValue();
        const units = value.getItem(1);
        if (num !== void 0 && isFinite(num) && units instanceof Attr && units.toValue() === Value.extant()) {
          switch (units.key.value) {
           case "deg":
            return Angle.deg(num);

           case "rad":
            return Angle.rad(num);

           case "grad":
            return Angle.grad(num);

           case "turn":
            return Angle.turn(num);
          }
        }
      }
      return null;
    }
    static parse(string, defaultUnits) {
      let input = Unicode.stringInput(string);
      while (input.isCont() && Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = AngleParser.parse(input, defaultUnits);
      if (parser.isDone()) {
        while (input.isCont() && Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    static form() {
      return new AngleForm(void 0, Angle.zero());
    }
    static isAny(value) {
      return value instanceof Angle || typeof value === "number" || typeof value === "string";
    }
  }
  __decorate([ Lazy ], Angle, "form", null);
  class DegAngle extends Angle {
    constructor(value) {
      super();
      this.value = value;
    }
    get units() {
      return "deg";
    }
    degValue() {
      return this.value;
    }
    gradValue() {
      return this.value * 10 / 9;
    }
    radValue() {
      return this.value * Math.PI / 180;
    }
    turnValue() {
      return this.value / 360;
    }
    deg() {
      return this;
    }
    toCssValue() {
      if (typeof CSSUnitValue !== "undefined") {
        return new CSSUnitValue(this.value, "deg");
      } else {
        return null;
      }
    }
    compareTo(that) {
      if (that instanceof Angle) {
        const x = this.value;
        const y = that.degValue();
        return x < y ? -1 : x > y ? 1 : isNaN(y) ? isNaN(x) ? 0 : -1 : isNaN(x) ? 1 : 0;
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (that instanceof Angle) {
        return Numbers.equivalent(this.value, that.degValue());
      }
      return false;
    }
    equals(that) {
      if (that instanceof DegAngle) {
        return this.value === that.value;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(DegAngle), Numbers.hash(this.value)));
    }
    debug(output) {
      output = output.write("Angle").write(46).write("deg").write(40).debug(this.value).write(41);
      return output;
    }
    toString() {
      return this.value + "deg";
    }
    static zero() {
      return new DegAngle(0);
    }
  }
  __decorate([ Lazy ], DegAngle, "zero", null);
  class RadAngle extends Angle {
    constructor(value) {
      super();
      this.value = value;
    }
    get units() {
      return "rad";
    }
    degValue() {
      return this.value * 180 / Math.PI;
    }
    gradValue() {
      return this.value * 200 / Math.PI;
    }
    radValue() {
      return this.value;
    }
    turnValue() {
      return this.value / (2 * Math.PI);
    }
    rad() {
      return this;
    }
    toCssValue() {
      if (typeof CSSUnitValue !== "undefined") {
        return new CSSUnitValue(this.value, "rad");
      } else {
        return null;
      }
    }
    compareTo(that) {
      if (that instanceof Angle) {
        const x = this.value;
        const y = that.radValue();
        return x < y ? -1 : x > y ? 1 : isNaN(y) ? isNaN(x) ? 0 : -1 : isNaN(x) ? 1 : 0;
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (that instanceof Angle) {
        return Numbers.equivalent(this.value, that.radValue());
      }
      return false;
    }
    equals(that) {
      if (that instanceof RadAngle) {
        return this.value === that.value;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(RadAngle), Numbers.hash(this.value)));
    }
    debug(output) {
      output = output.write("Angle").write(46).write("rad").write(40).debug(this.value).write(41);
      return output;
    }
    toString() {
      return this.value + "rad";
    }
    static zero() {
      return new RadAngle(0);
    }
  }
  __decorate([ Lazy ], RadAngle, "zero", null);
  class GradAngle extends Angle {
    constructor(value) {
      super();
      this.value = value;
    }
    get units() {
      return "grad";
    }
    degValue() {
      return this.value * .9;
    }
    gradValue() {
      return this.value;
    }
    radValue() {
      return this.value * Math.PI / 200;
    }
    turnValue() {
      return this.value / 400;
    }
    grad() {
      return this;
    }
    toCssValue() {
      if (typeof CSSUnitValue !== "undefined") {
        return new CSSUnitValue(this.value, "grad");
      } else {
        return null;
      }
    }
    compareTo(that) {
      if (that instanceof Angle) {
        const x = this.value;
        const y = that.gradValue();
        return x < y ? -1 : x > y ? 1 : isNaN(y) ? isNaN(x) ? 0 : -1 : isNaN(x) ? 1 : 0;
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (that instanceof Angle) {
        return Numbers.equivalent(this.value, that.gradValue());
      }
      return false;
    }
    equals(that) {
      if (that instanceof GradAngle) {
        return this.value === that.value;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(GradAngle), Numbers.hash(this.value)));
    }
    debug(output) {
      output = output.write("Angle").write(46).write("grad").write(40).debug(this.value).write(41);
      return output;
    }
    toString() {
      return this.value + "grad";
    }
    static zero() {
      return new GradAngle(0);
    }
  }
  __decorate([ Lazy ], GradAngle, "zero", null);
  class TurnAngle extends Angle {
    constructor(value) {
      super();
      this.value = value;
    }
    get units() {
      return "turn";
    }
    degValue() {
      return this.value * 360;
    }
    gradValue() {
      return this.value * 400;
    }
    radValue() {
      return this.value * (2 * Math.PI);
    }
    turnValue() {
      return this.value;
    }
    turn() {
      return this;
    }
    toCssValue() {
      if (typeof CSSUnitValue !== "undefined") {
        return new CSSUnitValue(this.value, "turn");
      } else {
        return null;
      }
    }
    compareTo(that) {
      if (that instanceof Angle) {
        const x = this.value;
        const y = that.turnValue();
        return x < y ? -1 : x > y ? 1 : isNaN(y) ? isNaN(x) ? 0 : -1 : isNaN(x) ? 1 : 0;
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (that instanceof Angle) {
        return Numbers.equivalent(this.value, that.turnValue());
      }
      return false;
    }
    equals(that) {
      if (that instanceof TurnAngle) {
        return this.value === that.value;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(TurnAngle), Numbers.hash(this.value)));
    }
    debug(output) {
      output = output.write("Angle").write(46).write("turn").write(40).debug(this.value).write(41);
      return output;
    }
    toString() {
      return this.value + "turn";
    }
    static zero() {
      return new TurnAngle(0);
    }
  }
  __decorate([ Lazy ], TurnAngle, "zero", null);
  const AngleInterpolator = function(_super) {
    const AngleInterpolator = function(a0, a1) {
      const interpolator = function(u) {
        const a0 = interpolator[0];
        const a1 = interpolator[1];
        return Angle.create(a0.value + u * (a1.value - a0.value), a1.units);
      };
      Object.setPrototypeOf(interpolator, AngleInterpolator.prototype);
      interpolator[0] = a0.to(a1.units);
      interpolator[1] = a1;
      return interpolator;
    };
    AngleInterpolator.prototype = Object.create(_super.prototype);
    AngleInterpolator.prototype.constructor = AngleInterpolator;
    return AngleInterpolator;
  }(Interpolator);
  class AngleForm extends Form {
    constructor(defaultUnits, unit) {
      super();
      this.defaultUnits = defaultUnits;
      Object.defineProperty(this, "unit", {
        value: unit,
        enumerable: true
      });
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new AngleForm(this.defaultUnits, unit);
      } else {
        return this;
      }
    }
    mold(angle) {
      angle = Angle.fromAny(angle, this.defaultUnits);
      return Text.from(angle.toString());
    }
    cast(item) {
      const value = item.toValue();
      let angle = null;
      try {
        angle = Angle.fromValue(value);
        if (angle === void 0) {
          const string = value.stringValue(void 0);
          if (string !== void 0) {
            angle = Angle.parse(string, this.defaultUnits);
          }
        }
      } catch (e) {}
      return angle !== null ? angle : void 0;
    }
  }
  class AngleParser extends Parser {
    constructor(defaultUnits, valueParser, unitsOutput, step) {
      super();
      this.defaultUnits = defaultUnits;
      this.valueParser = valueParser;
      this.unitsOutput = unitsOutput;
      this.step = step;
    }
    feed(input) {
      return AngleParser.parse(input, this.defaultUnits, this.valueParser, this.unitsOutput, this.step);
    }
    static parse(input, defaultUnits, valueParser, unitsOutput, step = 1) {
      let c = 0;
      if (step === 1) {
        if (valueParser === void 0) {
          valueParser = Base10.parseDecimal(input);
        } else {
          valueParser = valueParser.feed(input);
        }
        if (valueParser.isDone()) {
          step = 2;
        } else if (valueParser.isError()) {
          return valueParser.asError();
        }
      }
      if (step === 2) {
        unitsOutput = unitsOutput || Unicode.stringOutput();
        while (input.isCont() && (c = input.head(), Unicode.isAlpha(c))) {
          input = input.step();
          unitsOutput.push(c);
        }
        if (!input.isEmpty()) {
          const value = valueParser.bind();
          const units = unitsOutput.bind() || defaultUnits;
          switch (units) {
           case "deg":
            return Parser.done(Angle.deg(value));

           case "":
           case "rad":
            return Parser.done(Angle.rad(value));

           case "grad":
            return Parser.done(Angle.grad(value));

           case "turn":
            return Parser.done(Angle.turn(value));

           default:
            return Parser.error(Diagnostic.message("unknown units: " + units, input));
          }
        }
      }
      return new AngleParser(defaultUnits, valueParser, unitsOutput, step);
    }
  }
  class R2Vector {
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }
    isDefined() {
      return isFinite(this.x) && isFinite(this.y);
    }
    plus(that) {
      return new R2Vector(this.x + that.x, this.y + that.y);
    }
    negative() {
      return new R2Vector(-this.x, -this.y);
    }
    minus(that) {
      return new R2Vector(this.x - that.x, this.y - that.y);
    }
    times(scalar) {
      return new R2Vector(this.x * scalar, this.y * scalar);
    }
    toAny() {
      return {
        x: this.x,
        y: this.y
      };
    }
    interpolateTo(that) {
      if (that instanceof R2Vector) {
        return R2VectorInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof R2Vector) {
        return Numbers.equivalent(this.x, that.x, epsilon) && Numbers.equivalent(this.y, that.y, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof R2Vector) {
        return this.x === that.x && this.y === that.y;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(R2Vector), Numbers.hash(this.x)), Numbers.hash(this.y)));
    }
    debug(output) {
      output = output.write("R2Vector").write(46).write("of").write(40).debug(this.x).write(", ").debug(this.y).write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static zero() {
      return new R2Vector(0, 0);
    }
    static of(x, y) {
      return new R2Vector(x, y);
    }
    static fromInit(init) {
      return new R2Vector(init.x, init.y);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof R2Vector) {
        return value;
      } else if (R2Vector.isInit(value)) {
        return R2Vector.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return typeof init.x === "number" && typeof init.y === "number";
      }
      return false;
    }
    static isAny(value) {
      return value instanceof R2Vector || R2Vector.isInit(value);
    }
  }
  __decorate([ Lazy ], R2Vector, "zero", null);
  const R2VectorInterpolator = function(_super) {
    const R2VectorInterpolator = function(v0, v1) {
      const interpolator = function(u) {
        const v0 = interpolator[0];
        const v1 = interpolator[1];
        const x = v0.x + u * (v1.x - v0.x);
        const y = v0.y + u * (v1.y - v0.y);
        return new R2Vector(x, y);
      };
      Object.setPrototypeOf(interpolator, R2VectorInterpolator.prototype);
      interpolator[0] = v0;
      interpolator[1] = v1;
      return interpolator;
    };
    R2VectorInterpolator.prototype = Object.create(_super.prototype);
    R2VectorInterpolator.prototype.constructor = R2VectorInterpolator;
    return R2VectorInterpolator;
  }(Interpolator);
  class R2Shape {
    union(that) {
      that = R2Shape.fromAny(that);
      return new R2Box(Math.min(this.xMin, that.xMin), Math.min(this.yMin, that.yMin), Math.max(this.xMax, that.xMax), Math.max(this.yMax, that.yMax));
    }
    get bounds() {
      return new R2Box(this.xMin, this.yMin, this.xMax, this.yMax);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof R2Shape) {
        return value;
      } else if (R2Point.isInit(value)) {
        return R2Point.fromInit(value);
      } else if (R2Point.isTuple(value)) {
        return R2Point.fromTuple(value);
      } else if (R2Segment.isInit(value)) {
        return R2Segment.fromInit(value);
      } else if (R2Box.isInit(value)) {
        return R2Box.fromInit(value);
      } else if (R2Circle.isInit(value)) {
        return R2Circle.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static isAny(value) {
      return value instanceof R2Shape || R2Point.isInit(value) || R2Point.isTuple(value) || R2Segment.isInit(value) || R2Box.isInit(value) || R2Circle.isInit(value);
    }
  }
  class R2Point extends R2Shape {
    constructor(x, y) {
      super();
      this.x = x;
      this.y = y;
    }
    isDefined() {
      return isFinite(this.x) && isFinite(this.y);
    }
    get xMin() {
      return this.x;
    }
    get yMin() {
      return this.y;
    }
    get xMax() {
      return this.x;
    }
    get yMax() {
      return this.y;
    }
    plus(vector) {
      return new R2Point(this.x + vector.x, this.y + vector.y);
    }
    minus(that) {
      if (that instanceof R2Vector) {
        return new R2Point(this.x - that.x, this.y - that.y);
      } else {
        return new R2Vector(this.x - that.x, this.y - that.y);
      }
    }
    contains(that, y) {
      if (typeof that === "number") {
        return this.x === that && this.y === y;
      } else {
        that = R2Shape.fromAny(that);
        if (that instanceof R2Point) {
          return this.x === that.x && this.y === that.y;
        } else if (that instanceof R2Shape) {
          return this.x <= that.xMin && that.xMax <= this.x && this.y <= that.yMin && that.yMax <= this.y;
        }
        return false;
      }
    }
    intersects(that) {
      that = R2Shape.fromAny(that);
      return that.intersects(this);
    }
    transform(f) {
      return new R2Point(f.transformX(this.x, this.y), f.transformY(this.x, this.y));
    }
    toAny() {
      return {
        x: this.x,
        y: this.y
      };
    }
    interpolateTo(that) {
      if (that instanceof R2Point) {
        return R2PointInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof R2Point) {
        return Numbers.equivalent(this.x, that.x, epsilon) && Numbers.equivalent(this.y, that.y, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof R2Point) {
        return this.x === that.x && this.y === that.y;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(R2Point), Numbers.hash(this.x)), Numbers.hash(this.y)));
    }
    debug(output) {
      output = output.write("R2Point").write(46).write("of").write(40).debug(this.x).write(", ").debug(this.y).write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static origin() {
      return new R2Point(0, 0);
    }
    static undefined() {
      return new R2Point(NaN, NaN);
    }
    static of(x, y) {
      return new R2Point(x, y);
    }
    static fromInit(value) {
      return new R2Point(value.x, value.y);
    }
    static fromTuple(value) {
      return new R2Point(value[0], value[1]);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof R2Point) {
        return value;
      } else if (R2Point.isInit(value)) {
        return R2Point.fromInit(value);
      } else if (R2Point.isTuple(value)) {
        return R2Point.fromTuple(value);
      }
      throw new TypeError("" + value);
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return typeof init.x === "number" && typeof init.y === "number";
      }
      return false;
    }
    static isTuple(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
    }
    static isAny(value) {
      return value instanceof R2Point || R2Point.isInit(value) || R2Point.isTuple(value);
    }
  }
  __decorate([ Lazy ], R2Point, "origin", null);
  __decorate([ Lazy ], R2Point, "undefined", null);
  const R2PointInterpolator = function(_super) {
    const R2PointInterpolator = function(p0, p1) {
      const interpolator = function(u) {
        const p0 = interpolator[0];
        const p1 = interpolator[1];
        const x = p0.x + u * (p1.x - p0.x);
        const y = p0.y + u * (p1.y - p0.y);
        return new R2Point(x, y);
      };
      Object.setPrototypeOf(interpolator, R2PointInterpolator.prototype);
      interpolator[0] = p0;
      interpolator[1] = p1;
      return interpolator;
    };
    R2PointInterpolator.prototype = Object.create(_super.prototype);
    R2PointInterpolator.prototype.constructor = R2PointInterpolator;
    return R2PointInterpolator;
  }(Interpolator);
  class R2Curve extends R2Shape {
    draw(context) {
      this.drawMove(context);
      this.drawRest(context);
    }
    transformDraw(context, f) {
      this.transformDrawMove(context, f);
      this.transformDrawRest(context, f);
    }
    writePath(output) {
      output = this.writeMove(output);
      output = this.writeRest(output);
      return output;
    }
    toPathString(outputSettings) {
      let output = Unicode.stringOutput(outputSettings);
      output = this.writePath(output);
      return output.toString();
    }
    static linear(x0, y0, x1, y1) {
      return new R2Segment(x0, y0, x1, y1);
    }
    static quadratic(x0, y0, x1, y1, x2, y2) {
      return new R2QuadraticCurve(x0, y0, x1, y1, x2, y2);
    }
    static cubic(x0, y0, x1, y1, x2, y2, x3, y3) {
      return new R2CubicCurve(x0, y0, x1, y1, x2, y2, x3, y3);
    }
    static elliptic(cx, cy, rx, ry, phi, a0, da) {
      return new R2EllipticCurve(cx, cy, rx, ry, phi, a0, da);
    }
    static parse(string) {
      let input = Unicode.stringInput(string);
      while (input.isCont() && Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = R2CurveParser.parse(input);
      if (parser.isDone()) {
        while (input.isCont() && Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
  }
  class R2CurveParser extends Parser {
    constructor(x0Parser, y0Parser, command, step) {
      super();
      this.x0Parser = x0Parser;
      this.y0Parser = y0Parser;
      this.command = command;
      this.step = step;
    }
    feed(input) {
      return R2CurveParser.parse(input, this.x0Parser, this.y0Parser, this.command, this.step);
    }
    static parse(input, x0Parser, y0Parser, command, step = 1) {
      let c = 0;
      if (step === 1) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 77 || c === 109) {
            input = input.step();
            command = c;
            step = 2;
          } else {
            return Parser.error(Diagnostic.expected("moveto", input));
          }
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      if (step === 2) {
        if (x0Parser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            x0Parser = Base10.parseDecimal(input);
          }
        } else {
          x0Parser = x0Parser.feed(input);
        }
        if (x0Parser !== void 0) {
          if (x0Parser.isDone()) {
            step = 3;
          } else if (x0Parser.isError()) {
            return x0Parser.asError();
          }
        }
      }
      if (step === 3) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 4;
        } else if (!input.isEmpty()) {
          step = 4;
        }
      }
      if (step === 4) {
        if (y0Parser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            y0Parser = Base10.parseDecimal(input);
          }
        } else {
          y0Parser = y0Parser.feed(input);
        }
        if (y0Parser !== void 0) {
          if (y0Parser.isDone()) {
            step = 5;
          } else if (y0Parser.isError()) {
            return y0Parser.asError();
          }
        }
      }
      if (step === 5) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          switch (c) {
           case 76:
           case 108:
           case 72:
           case 104:
           case 86:
           case 118:
            return R2SegmentParser.parse(input, x0Parser, y0Parser);

           case 81:
           case 113:
            return R2QuadraticCurveParser.parse(input, x0Parser, y0Parser);

           case 84:
            return R2QuadraticCurveParser.parse(input, x0Parser, y0Parser, x0Parser, y0Parser);

           case 116:
            return R2QuadraticCurveParser.parse(input, x0Parser, y0Parser, Parser.done(0), Parser.done(0));

           case 67:
           case 99:
            return R2CubicCurveParser.parse(input, x0Parser, y0Parser);

           case 83:
            return R2CubicCurveParser.parse(input, x0Parser, y0Parser, x0Parser, y0Parser);

           case 115:
            return R2CubicCurveParser.parse(input, x0Parser, y0Parser, Parser.done(0), Parser.done(0));

           case 65:
           case 97:
            return R2EllipticCurveParser.parse(input, x0Parser, y0Parser);

           case 44:
            input = input.step();

           case 43:
           case 45:
           case 46:
           case 48:
           case 49:
           case 50:
           case 51:
           case 52:
           case 53:
           case 54:
           case 55:
           case 56:
           case 57:
            switch (command) {
             case 77:
             case 109:
              return R2SegmentParser.parseRest(input, command, x0Parser, y0Parser);
            }

           default:
            return Parser.error(Diagnostic.expected("draw command", input));
          }
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      return new R2CurveParser(x0Parser, y0Parser, command, step);
    }
  }
  class R2BezierCurve extends R2Curve {}
  class R2Segment extends R2BezierCurve {
    constructor(x0, y0, x1, y1) {
      super();
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
    }
    isDefined() {
      return isFinite(this.x0) && isFinite(this.y0) && isFinite(this.x1) && isFinite(this.y1);
    }
    get xMin() {
      return Math.min(this.x0, this.x1);
    }
    get yMin() {
      return Math.min(this.y0, this.y1);
    }
    get xMax() {
      return Math.max(this.x0, this.x1);
    }
    get yMax() {
      return Math.max(this.y0, this.y1);
    }
    interpolateX(u) {
      return (1 - u) * this.x0 + u * this.x1;
    }
    interpolateY(u) {
      return (1 - u) * this.y0 + u * this.y1;
    }
    interpolate(u) {
      const v = 1 - u;
      const x01 = v * this.x0 + u * this.x1;
      const y01 = v * this.y0 + u * this.y1;
      return new R2Point(x01, y01);
    }
    contains(that, y) {
      if (typeof that === "number") {
        return R2Segment.contains(this.x0, this.y0, this.x1, this.y1, that, y);
      } else {
        that = R2Shape.fromAny(that);
        if (that instanceof R2Point) {
          return this.containsPoint(that);
        } else if (that instanceof R2Segment) {
          return this.containsSegment(that);
        }
        return false;
      }
    }
    containsPoint(that) {
      return R2Segment.contains(this.x0, this.y0, this.x1, this.y1, that.x, that.y);
    }
    containsSegment(that) {
      return R2Segment.contains(this.x0, this.y0, this.x1, this.y1, that.x0, that.y0) && R2Segment.contains(this.x0, this.y0, this.x1, this.y1, that.x1, that.y1);
    }
    static contains(ax, ay, bx, by, cx, cy) {
      return (ax <= cx && cx <= bx || bx <= cx && cx <= ax) && (ay <= cy && cy <= by || by <= cy && cy <= ay) && (bx - ax) * (cy - ay) === (cx - ax) * (by - ay);
    }
    intersects(that) {
      that = R2Shape.fromAny(that);
      if (that instanceof R2Point) {
        return this.intersectsPoint(that);
      } else if (that instanceof R2Segment) {
        return this.intersectsSegment(that);
      } else {
        return that.intersects(this);
      }
    }
    intersectsPoint(that) {
      return R2Segment.contains(this.x0, this.y0, this.x1, this.y1, that.x, that.y);
    }
    intersectsSegment(that) {
      return R2Segment.intersects(this.x0, this.y0, this.x1 - this.x0, this.y1 - this.y0, that.x0, that.y0, that.x1 - that.x0, that.y1 - that.y0);
    }
    static intersects(px, py, rx, ry, qx, qy, sx, sy) {
      const pqx = qx - px;
      const pqy = qy - py;
      const pqr = pqx * ry - pqy * rx;
      const rs = rx * sy - ry * sx;
      if (pqr === 0 && rs === 0) {
        const rr = rx * rx + ry * ry;
        const sr = sx * rx + sy * ry;
        const t0 = (pqx * rx + pqy * ry) / rr;
        const t1 = t0 + sr / rr;
        return sr >= 0 ? 0 < t1 && t0 < 1 : 0 < t0 && t1 < 1;
      } else if (rs === 0) {
        return false;
      } else {
        const pqs = pqx * sy - pqy * sx;
        const t = pqs / rs;
        const u = pqr / rs;
        return 0 <= t && t <= 1 && 0 <= u && u <= 1;
      }
    }
    split(u) {
      const v = 1 - u;
      const x01 = v * this.x0 + u * this.x1;
      const y01 = v * this.y0 + u * this.y1;
      const c0 = new R2Segment(this.x0, this.y0, x01, y01);
      const c1 = new R2Segment(x01, y01, this.x1, this.y1);
      return [ c0, c1 ];
    }
    transform(f) {
      return new R2Segment(f.transformX(this.x0, this.y0), f.transformY(this.x0, this.y0), f.transformX(this.x1, this.y1), f.transformY(this.x1, this.y1));
    }
    toAny() {
      return {
        x0: this.x0,
        y0: this.y0,
        x1: this.x1,
        y1: this.y1
      };
    }
    drawMove(context) {
      context.moveTo(this.x0, this.y0);
    }
    drawRest(context) {
      context.lineTo(this.x1, this.y1);
    }
    transformDrawMove(context, f) {
      context.moveTo(f.transformX(this.x0, this.y0), f.transformY(this.x0, this.y0));
    }
    transformDrawRest(context, f) {
      context.lineTo(f.transformX(this.x1, this.y1), f.transformY(this.x1, this.y1));
    }
    writeMove(output) {
      output = output.write(77);
      output = Format.displayNumber(output, this.x0);
      output = output.write(44);
      output = Format.displayNumber(output, this.y0);
      return output;
    }
    writeRest(output) {
      output = output.write(76);
      output = Format.displayNumber(output, this.x1);
      output = output.write(44);
      output = Format.displayNumber(output, this.y1);
      return output;
    }
    interpolateTo(that) {
      if (that instanceof R2Segment) {
        return R2SegmentInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof R2Segment) {
        return Numbers.equivalent(this.x0, that.x0, epsilon) && Numbers.equivalent(this.y0, that.y0, epsilon) && Numbers.equivalent(this.x1, that.x1, epsilon) && Numbers.equivalent(this.y1, that.y1, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof R2Segment) {
        return this.x0 === that.x0 && this.y0 === that.y0 && this.x1 === that.x1 && this.y1 === that.y1;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(Constructors.hash(R2Segment), Numbers.hash(this.x0)), Numbers.hash(this.y0)), Numbers.hash(this.x1)), Numbers.hash(this.y1)));
    }
    debug(output) {
      output = output.write("R2Segment").write(46).write("of").write(40).debug(this.x0).write(", ").debug(this.y0).write(", ").debug(this.x1).write(", ").debug(this.y1).write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static of(x0, y0, x1, y1) {
      return new R2Segment(x0, y0, x1, y1);
    }
    static fromInit(value) {
      return new R2Segment(value.x0, value.y0, value.x1, value.y1);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof R2Segment) {
        return value;
      } else if (R2Segment.isInit(value)) {
        return R2Segment.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return typeof init.x0 === "number" && typeof init.y0 === "number" && typeof init.x1 === "number" && typeof init.y1 === "number";
      }
      return false;
    }
    static isAny(value) {
      return value instanceof R2Segment || R2Segment.isInit(value);
    }
  }
  const R2SegmentInterpolator = function(_super) {
    const R2SegmentInterpolator = function(s0, s1) {
      const interpolator = function(u) {
        const s0 = interpolator[0];
        const s1 = interpolator[1];
        const x0 = s0.x0 + u * (s1.x0 - s0.x0);
        const y0 = s0.y0 + u * (s1.y0 - s0.y0);
        const x1 = s0.x1 + u * (s1.x1 - s0.x1);
        const y1 = s0.y1 + u * (s1.y1 - s0.y1);
        return new R2Segment(x0, y0, x1, y1);
      };
      Object.setPrototypeOf(interpolator, R2SegmentInterpolator.prototype);
      interpolator[0] = s0;
      interpolator[1] = s1;
      return interpolator;
    };
    R2SegmentInterpolator.prototype = Object.create(_super.prototype);
    R2SegmentInterpolator.prototype.constructor = R2SegmentInterpolator;
    return R2SegmentInterpolator;
  }(Interpolator);
  class R2SegmentParser extends Parser {
    constructor(x0Parser, y0Parser, x1Parser, y1Parser, command, step) {
      super();
      this.x0Parser = x0Parser;
      this.y0Parser = y0Parser;
      this.x1Parser = x1Parser;
      this.y1Parser = y1Parser;
      this.command = command;
      this.step = step;
    }
    feed(input) {
      return R2SegmentParser.parse(input, this.x0Parser, this.y0Parser, this.x1Parser, this.y1Parser, this.command, this.step);
    }
    static parse(input, x0Parser, y0Parser, x1Parser, y1Parser, command, step = 1) {
      let c = 0;
      if (step === 1) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          switch (c) {
           case 77:
           case 109:
           case 76:
           case 108:
            input = input.step();
            command = c;
            step = 2;
            break;

           case 72:
            input = input.step();
            y1Parser = y0Parser;
            command = c;
            step = 2;
            break;

           case 104:
            input = input.step();
            y1Parser = Parser.done(0);
            command = c;
            step = 2;
            break;

           case 86:
            input = input.step();
            x1Parser = x0Parser;
            command = c;
            step = 4;
            break;

           case 118:
            input = input.step();
            x1Parser = Parser.done(0);
            command = c;
            step = 4;
            break;

           default:
            return Parser.error(Diagnostic.expected("lineto", input));
          }
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      if (step === 2) {
        if (x1Parser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            x1Parser = Base10.parseDecimal(input);
          }
        } else {
          x1Parser = x1Parser.feed(input);
        }
        if (x1Parser !== void 0) {
          if (x1Parser.isDone()) {
            if (y1Parser === void 0 || !y1Parser.isDone()) {
              step = 3;
            } else {
              step = 4;
            }
          } else if (x1Parser.isError()) {
            return x1Parser.asError();
          }
        }
      }
      if (step === 3) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 4;
        } else if (!input.isEmpty()) {
          step = 4;
        }
      }
      if (step === 4) {
        if (y1Parser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            y1Parser = Base10.parseDecimal(input);
          }
        } else {
          y1Parser = y1Parser.feed(input);
        }
        if (y1Parser !== void 0) {
          if (y1Parser.isDone()) {
            const x0 = x0Parser.bind();
            const y0 = y0Parser.bind();
            let x1 = x1Parser.bind();
            let y1 = y1Parser.bind();
            if (command === 109 || command === 108 || command === 104 || command === 118) {
              x1 += x0;
              y1 += y0;
            }
            return Parser.done(new R2Segment(x0, y0, x1, y1));
          } else if (y1Parser.isError()) {
            return y1Parser.asError();
          }
        }
      }
      return new R2SegmentParser(x0Parser, y0Parser, x1Parser, y1Parser, command, step);
    }
    static parseRest(input, command, x0Parser, y0Parser) {
      let x1Parser;
      let y1Parser;
      let step;
      switch (command) {
       case 72:
        y1Parser = y0Parser;
        step = 2;
        break;

       case 104:
        y1Parser = Parser.done(0);
        step = 2;
        break;

       case 86:
        x1Parser = x0Parser;
        step = 4;
        break;

       case 118:
        x1Parser = Parser.done(0);
        step = 4;
        break;

       default:
        step = 2;
      }
      return this.parse(input, x0Parser, y0Parser, x1Parser, y1Parser, command, step);
    }
  }
  class R2QuadraticCurve extends R2BezierCurve {
    constructor(x0, y0, x1, y1, x2, y2) {
      super();
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x2;
      this.y2 = y2;
    }
    isDefined() {
      return isFinite(this.x0) && isFinite(this.y0) && isFinite(this.x1) && isFinite(this.y1) && isFinite(this.x2) && isFinite(this.y2);
    }
    get xMin() {
      return Math.min(this.x0, this.x1, this.x2);
    }
    get yMin() {
      return Math.min(this.y0, this.y1, this.y2);
    }
    get xMax() {
      return Math.max(this.x0, this.x1, this.x2);
    }
    get yMax() {
      return Math.max(this.y0, this.y1, this.y2);
    }
    interpolateX(u) {
      const v = 1 - u;
      const x01 = v * this.x0 + u * this.x1;
      const x12 = v * this.x1 + u * this.x2;
      return v * x01 + u * x12;
    }
    interpolateY(u) {
      const v = 1 - u;
      const y01 = v * this.y0 + u * this.y1;
      const y12 = v * this.y1 + u * this.y2;
      return v * y01 + u * y12;
    }
    interpolate(u) {
      const v = 1 - u;
      const x01 = v * this.x0 + u * this.x1;
      const y01 = v * this.y0 + u * this.y1;
      const x12 = v * this.x1 + u * this.x2;
      const y12 = v * this.y1 + u * this.y2;
      const x02 = v * x01 + u * x12;
      const y02 = v * y01 + u * y12;
      return new R2Point(x02, y02);
    }
    contains(that, y) {
      return false;
    }
    intersects(that) {
      return false;
    }
    split(u) {
      const v = 1 - u;
      const x01 = v * this.x0 + u * this.x1;
      const y01 = v * this.y0 + u * this.y1;
      const x12 = v * this.x1 + u * this.x2;
      const y12 = v * this.y1 + u * this.y2;
      const x02 = v * x01 + u * x12;
      const y02 = v * y01 + u * y12;
      const c0 = new R2QuadraticCurve(this.x0, this.y0, x01, y01, x02, y02);
      const c1 = new R2QuadraticCurve(x02, y02, x12, y12, this.x2, this.y2);
      return [ c0, c1 ];
    }
    transform(f) {
      return new R2QuadraticCurve(f.transformX(this.x0, this.y0), f.transformY(this.x0, this.y0), f.transformX(this.x1, this.y1), f.transformY(this.x1, this.y1), f.transformX(this.x2, this.y2), f.transformY(this.x2, this.y2));
    }
    drawMove(context) {
      context.moveTo(this.x0, this.y0);
    }
    drawRest(context) {
      context.quadraticCurveTo(this.x1, this.y1, this.x2, this.y2);
    }
    transformDrawMove(context, f) {
      context.moveTo(f.transformX(this.x0, this.y0), f.transformY(this.x0, this.y0));
    }
    transformDrawRest(context, f) {
      context.quadraticCurveTo(f.transformX(this.x1, this.y1), f.transformY(this.x1, this.y1), f.transformX(this.x2, this.y2), f.transformY(this.x2, this.y2));
    }
    writeMove(output) {
      output = output.write(77);
      output = Format.displayNumber(output, this.x0);
      output = output.write(44);
      output = Format.displayNumber(output, this.y0);
      return output;
    }
    writeRest(output) {
      output = output.write(81);
      output = Format.displayNumber(output, this.x1);
      output = output.write(44);
      output = Format.displayNumber(output, this.y1);
      output = output.write(44);
      output = Format.displayNumber(output, this.x2);
      output = output.write(44);
      output = Format.displayNumber(output, this.y2);
      return output;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof R2QuadraticCurve) {
        return Numbers.equivalent(this.x0, that.x0, epsilon) && Numbers.equivalent(this.y0, that.y0, epsilon) && Numbers.equivalent(this.x1, that.x1, epsilon) && Numbers.equivalent(this.y1, that.y1, epsilon) && Numbers.equivalent(this.x2, that.x2, epsilon) && Numbers.equivalent(this.y2, that.y2, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof R2QuadraticCurve) {
        return this.x0 === that.x0 && this.y0 === that.y0 && this.x1 === that.x1 && this.y1 === that.y1 && this.x2 === that.x2 && this.y2 === that.y2;
      }
      return false;
    }
    debug(output) {
      output = output.write("R2Curve").write(46).write("quadratic").write(40).debug(this.x0).write(", ").debug(this.y0).write(", ").debug(this.x1).write(", ").debug(this.y1).write(", ").debug(this.x2).write(", ").debug(this.y2).write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
  }
  class R2QuadraticCurveParser extends Parser {
    constructor(x0Parser, y0Parser, x1Parser, y1Parser, x2Parser, y2Parser, command, step) {
      super();
      this.x0Parser = x0Parser;
      this.y0Parser = y0Parser;
      this.x1Parser = x1Parser;
      this.y1Parser = y1Parser;
      this.x2Parser = x2Parser;
      this.y2Parser = y2Parser;
      this.command = command;
      this.step = step;
    }
    feed(input) {
      return R2QuadraticCurveParser.parse(input, this.x0Parser, this.y0Parser, this.x1Parser, this.y1Parser, this.x2Parser, this.y2Parser, this.command, this.step);
    }
    static parse(input, x0Parser, y0Parser, x1Parser, y1Parser, x2Parser, y2Parser, command, step = 1) {
      let c = 0;
      if (step === 1) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          switch (c) {
           case 81:
           case 113:
            input = input.step();
            command = c;
            step = 2;
            break;

           case 84:
           case 116:
            input = input.step();
            command = c;
            step = 6;
            break;

           default:
            return Parser.error(Diagnostic.expected("curveto", input));
          }
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      if (step === 2) {
        if (x1Parser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            x1Parser = Base10.parseDecimal(input);
          }
        } else {
          x1Parser = x1Parser.feed(input);
        }
        if (x1Parser !== void 0) {
          if (x1Parser.isDone()) {
            step = 3;
          } else if (x1Parser.isError()) {
            return x1Parser.asError();
          }
        }
      }
      if (step === 3) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 4;
        } else if (!input.isEmpty()) {
          step = 4;
        }
      }
      if (step === 4) {
        if (y1Parser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            y1Parser = Base10.parseDecimal(input);
          }
        } else {
          y1Parser = y1Parser.feed(input);
        }
        if (y1Parser !== void 0) {
          if (y1Parser.isDone()) {
            step = 5;
          } else if (y1Parser.isError()) {
            return y1Parser.asError();
          }
        }
      }
      if (step === 5) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 6;
        } else if (!input.isEmpty()) {
          step = 6;
        }
      }
      if (step === 6) {
        if (x2Parser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            x2Parser = Base10.parseDecimal(input);
          }
        } else {
          x2Parser = x2Parser.feed(input);
        }
        if (x2Parser !== void 0) {
          if (x2Parser.isDone()) {
            step = 7;
          } else if (x2Parser.isError()) {
            return x2Parser.asError();
          }
        }
      }
      if (step === 7) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 8;
        } else if (!input.isEmpty()) {
          step = 8;
        }
      }
      if (step === 8) {
        if (y2Parser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            y2Parser = Base10.parseDecimal(input);
          }
        } else {
          y2Parser = y2Parser.feed(input);
        }
        if (y2Parser !== void 0) {
          if (y2Parser.isDone()) {
            const x0 = x0Parser.bind();
            const y0 = y0Parser.bind();
            let x1 = x1Parser.bind();
            let y1 = y1Parser.bind();
            let x2 = x2Parser.bind();
            let y2 = y2Parser.bind();
            if (command === 113 || command === 116) {
              x1 += x0;
              y1 += y0;
              x2 += x0;
              y2 += y0;
            }
            return Parser.done(new R2QuadraticCurve(x0, y0, x1, y1, x2, y2));
          } else if (y2Parser.isError()) {
            return y2Parser.asError();
          }
        }
      }
      return new R2QuadraticCurveParser(x0Parser, y0Parser, x1Parser, y1Parser, x2Parser, y2Parser, command, step);
    }
    static parseRest(input, command, x0Parser, y0Parser, x1Parser, y1Parser) {
      const step = command === 84 || command === 116 ? 6 : 2;
      return R2QuadraticCurveParser.parse(input, x0Parser, y0Parser, x1Parser, y1Parser, void 0, void 0, command, step);
    }
  }
  class R2CubicCurve extends R2BezierCurve {
    constructor(x0, y0, x1, y1, x2, y2, x3, y3) {
      super();
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x2;
      this.y2 = y2;
      this.x3 = x3;
      this.y3 = y3;
    }
    isDefined() {
      return isFinite(this.x0) && isFinite(this.y0) && isFinite(this.x1) && isFinite(this.y1) && isFinite(this.x2) && isFinite(this.y2) && isFinite(this.x3) && isFinite(this.y3);
    }
    get xMin() {
      return Math.min(this.x0, this.x1, this.x2, this.x3);
    }
    get yMin() {
      return Math.min(this.y0, this.y1, this.y2, this.y3);
    }
    get xMax() {
      return Math.max(this.x0, this.x1, this.x2, this.x3);
    }
    get yMax() {
      return Math.max(this.y0, this.y1, this.y2, this.y3);
    }
    interpolateX(u) {
      const v = 1 - u;
      const x01 = v * this.x0 + u * this.x1;
      const x12 = v * this.x1 + u * this.x2;
      const x23 = v * this.x2 + u * this.x3;
      const x02 = v * x01 + u * x12;
      const x13 = v * x12 + u * x23;
      return v * x02 + u * x13;
    }
    interpolateY(u) {
      const v = 1 - u;
      const y01 = v * this.y0 + u * this.y1;
      const y12 = v * this.y1 + u * this.y2;
      const y23 = v * this.y2 + u * this.y3;
      const y02 = v * y01 + u * y12;
      const y13 = v * y12 + u * y23;
      return v * y02 + u * y13;
    }
    interpolate(u) {
      const v = 1 - u;
      const x01 = v * this.x0 + u * this.x1;
      const y01 = v * this.y0 + u * this.y1;
      const x12 = v * this.x1 + u * this.x2;
      const y12 = v * this.y1 + u * this.y2;
      const x23 = v * this.x2 + u * this.x3;
      const y23 = v * this.y2 + u * this.y3;
      const x02 = v * x01 + u * x12;
      const y02 = v * y01 + u * y12;
      const x13 = v * x12 + u * x23;
      const y13 = v * y12 + u * y23;
      const x03 = v * x02 + u * x13;
      const y03 = v * y02 + u * y13;
      return new R2Point(x03, y03);
    }
    contains(that, y) {
      return false;
    }
    intersects(that) {
      return false;
    }
    split(u) {
      const v = 1 - u;
      const x01 = v * this.x0 + u * this.x1;
      const y01 = v * this.y0 + u * this.y1;
      const x12 = v * this.x1 + u * this.x2;
      const y12 = v * this.y1 + u * this.y2;
      const x23 = v * this.x2 + u * this.x3;
      const y23 = v * this.y2 + u * this.y3;
      const x02 = v * x01 + u * x12;
      const y02 = v * y01 + u * y12;
      const x13 = v * x12 + u * x23;
      const y13 = v * y12 + u * y23;
      const x03 = v * x02 + u * x13;
      const y03 = v * y02 + u * y13;
      const c0 = new R2CubicCurve(this.x0, this.y0, x01, y01, x02, y02, x03, y03);
      const c1 = new R2CubicCurve(x03, y03, x13, y13, x23, y23, this.x3, this.y3);
      return [ c0, c1 ];
    }
    transform(f) {
      return new R2CubicCurve(f.transformX(this.x0, this.y0), f.transformY(this.x0, this.y0), f.transformX(this.x1, this.y1), f.transformY(this.x1, this.y1), f.transformX(this.x2, this.y2), f.transformY(this.x2, this.y2), f.transformX(this.x3, this.y3), f.transformY(this.x3, this.y3));
    }
    drawMove(context) {
      context.moveTo(this.x0, this.y0);
    }
    drawRest(context) {
      context.bezierCurveTo(this.x1, this.y1, this.x2, this.y2, this.x3, this.y3);
    }
    transformDrawMove(context, f) {
      context.moveTo(f.transformX(this.x0, this.y0), f.transformY(this.x0, this.y0));
    }
    transformDrawRest(context, f) {
      context.bezierCurveTo(f.transformX(this.x1, this.y1), f.transformY(this.x1, this.y1), f.transformX(this.x2, this.y2), f.transformY(this.x2, this.y2), f.transformX(this.x3, this.y3), f.transformY(this.x3, this.y3));
    }
    writeMove(output) {
      output = output.write(77);
      output = Format.displayNumber(output, this.x0);
      output = output.write(44);
      output = Format.displayNumber(output, this.y0);
      return output;
    }
    writeRest(output) {
      output = output.write(67);
      output = Format.displayNumber(output, this.x1);
      output = output.write(44);
      output = Format.displayNumber(output, this.y1);
      output = output.write(44);
      output = Format.displayNumber(output, this.x2);
      output = output.write(44);
      output = Format.displayNumber(output, this.y2);
      output = output.write(44);
      output = Format.displayNumber(output, this.x3);
      output = output.write(44);
      output = Format.displayNumber(output, this.y3);
      return output;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof R2CubicCurve) {
        return Numbers.equivalent(this.x0, that.x0, epsilon) && Numbers.equivalent(this.y0, that.y0, epsilon) && Numbers.equivalent(this.x1, that.x1, epsilon) && Numbers.equivalent(this.y1, that.y1, epsilon) && Numbers.equivalent(this.x2, that.x2, epsilon) && Numbers.equivalent(this.y2, that.y2, epsilon) && Numbers.equivalent(this.x3, that.x3, epsilon) && Numbers.equivalent(this.y3, that.y3, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof R2CubicCurve) {
        return this.x0 === that.x0 && this.y0 === that.y0 && this.x1 === that.x1 && this.y1 === that.y1 && this.x2 === that.x2 && this.y2 === that.y2 && this.x3 === that.x3 && this.y3 === that.y3;
      }
      return false;
    }
    debug(output) {
      output = output.write("R2Curve").write(46).write("cubic").write(40).debug(this.x0).write(", ").debug(this.y0).write(", ").debug(this.x1).write(", ").debug(this.y1).write(", ").debug(this.x2).write(", ").debug(this.y2).write(", ").debug(this.x3).write(", ").debug(this.y3).write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
  }
  class R2CubicCurveParser extends Parser {
    constructor(x0Parser, y0Parser, x1Parser, y1Parser, x2Parser, y2Parser, x3Parser, y3Parser, command, step) {
      super();
      this.x0Parser = x0Parser;
      this.y0Parser = y0Parser;
      this.x1Parser = x1Parser;
      this.y1Parser = y1Parser;
      this.x2Parser = x2Parser;
      this.y2Parser = y2Parser;
      this.x3Parser = x3Parser;
      this.y3Parser = y3Parser;
      this.command = command;
      this.step = step;
    }
    feed(input) {
      return R2CubicCurveParser.parse(input, this.x0Parser, this.y0Parser, this.x1Parser, this.y1Parser, this.x2Parser, this.y2Parser, this.x3Parser, this.y3Parser, this.command, this.step);
    }
    static parse(input, x0Parser, y0Parser, x1Parser, y1Parser, x2Parser, y2Parser, x3Parser, y3Parser, command, step = 1) {
      let c = 0;
      if (step === 1) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          switch (c) {
           case 67:
           case 99:
            input = input.step();
            command = c;
            step = 2;
            break;

           case 83:
           case 115:
            input = input.step();
            command = c;
            step = 6;
            break;

           default:
            return Parser.error(Diagnostic.expected("curveto", input));
          }
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      if (step === 2) {
        if (x1Parser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            x1Parser = Base10.parseDecimal(input);
          }
        } else {
          x1Parser = x1Parser.feed(input);
        }
        if (x1Parser !== void 0) {
          if (x1Parser.isDone()) {
            step = 3;
          } else if (x1Parser.isError()) {
            return x1Parser.asError();
          }
        }
      }
      if (step === 3) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 4;
        } else if (!input.isEmpty()) {
          step = 4;
        }
      }
      if (step === 4) {
        if (y1Parser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            y1Parser = Base10.parseDecimal(input);
          }
        } else {
          y1Parser = y1Parser.feed(input);
        }
        if (y1Parser !== void 0) {
          if (y1Parser.isDone()) {
            step = 5;
          } else if (y1Parser.isError()) {
            return y1Parser.asError();
          }
        }
      }
      if (step === 5) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 6;
        } else if (!input.isEmpty()) {
          step = 6;
        }
      }
      if (step === 6) {
        if (x2Parser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            x2Parser = Base10.parseDecimal(input);
          }
        } else {
          x2Parser = x2Parser.feed(input);
        }
        if (x2Parser !== void 0) {
          if (x2Parser.isDone()) {
            step = 7;
          } else if (x2Parser.isError()) {
            return x2Parser.asError();
          }
        }
      }
      if (step === 7) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 8;
        } else if (!input.isEmpty()) {
          step = 8;
        }
      }
      if (step === 8) {
        if (y2Parser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            y2Parser = Base10.parseDecimal(input);
          }
        } else {
          y2Parser = y2Parser.feed(input);
        }
        if (y2Parser !== void 0) {
          if (y2Parser.isDone()) {
            step = 9;
          } else if (y2Parser.isError()) {
            return y2Parser.asError();
          }
        }
      }
      if (step === 9) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 10;
        } else if (!input.isEmpty()) {
          step = 10;
        }
      }
      if (step === 10) {
        if (x3Parser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            x3Parser = Base10.parseDecimal(input);
          }
        } else {
          x3Parser = x3Parser.feed(input);
        }
        if (x3Parser !== void 0) {
          if (x3Parser.isDone()) {
            step = 11;
          } else if (x3Parser.isError()) {
            return x3Parser.asError();
          }
        }
      }
      if (step === 11) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 12;
        } else if (!input.isEmpty()) {
          step = 12;
        }
      }
      if (step === 12) {
        if (y3Parser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            y3Parser = Base10.parseDecimal(input);
          }
        } else {
          y3Parser = y3Parser.feed(input);
        }
        if (y3Parser !== void 0) {
          if (y3Parser.isDone()) {
            const x0 = x0Parser.bind();
            const y0 = y0Parser.bind();
            let x1 = x1Parser.bind();
            let y1 = y1Parser.bind();
            let x2 = x2Parser.bind();
            let y2 = y2Parser.bind();
            let x3 = x3Parser.bind();
            let y3 = y3Parser.bind();
            if (command === 99 || command === 115) {
              x1 += x0;
              y1 += y0;
              x2 += x0;
              y2 += y0;
              x3 += x0;
              y3 += y0;
            }
            return Parser.done(new R2CubicCurve(x0, y0, x1, y1, x2, y2, x3, y3));
          } else if (y3Parser.isError()) {
            return y3Parser.asError();
          }
        }
      }
      return new R2CubicCurveParser(x0Parser, y0Parser, x1Parser, y1Parser, x2Parser, y2Parser, x3Parser, y3Parser, command, step);
    }
    static parseRest(input, command, x0Parser, y0Parser, x1Parser, y1Parser) {
      const step = command === 83 || command === 115 ? 6 : 2;
      return R2CubicCurveParser.parse(input, x0Parser, y0Parser, x1Parser, y1Parser, void 0, void 0, void 0, void 0, command, step);
    }
  }
  class R2EllipticCurve extends R2Curve {
    constructor(cx, cy, rx, ry, phi, a0, da) {
      super();
      this.cx = cx;
      this.cy = cy;
      this.rx = rx;
      this.ry = ry;
      this.phi = phi;
      this.a0 = a0;
      this.da = da;
    }
    get xMin() {
      return this.cx - Math.max(this.rx, this.ry);
    }
    get yMin() {
      return this.cy - Math.max(this.rx, this.ry);
    }
    get xMax() {
      return this.cx + Math.max(this.rx, this.ry);
    }
    get yMax() {
      return this.cy + Math.max(this.rx, this.ry);
    }
    interpolateX(u) {
      const a0 = this.a0;
      const da = this.da;
      const a = a0 + u * da;
      const dx = this.rx * Math.cos(a);
      const dy = this.ry * Math.sin(a);
      const phi = this.phi;
      if (phi === 0) {
        return this.cx + dx;
      } else {
        return this.cx + dx * Math.cos(phi) - dy * Math.sin(phi);
      }
    }
    interpolateY(u) {
      const a0 = this.a0;
      const da = this.da;
      const a = a0 + u * da;
      const dx = this.rx * Math.cos(a);
      const dy = this.ry * Math.sin(a);
      const phi = this.phi;
      if (phi === 0) {
        return this.cy + dy;
      } else {
        return this.cy + dx * Math.sin(phi) + dy * Math.cos(phi);
      }
    }
    interpolate(u) {
      const a0 = this.a0;
      const da = this.da;
      const a = a0 + u * da;
      const dx = this.rx * Math.cos(a);
      const dy = this.ry * Math.sin(a);
      const phi = this.phi;
      if (phi === 0) {
        return new R2Point(this.cx + dx, this.cy + dy);
      } else {
        return new R2Point(this.cx + dx * Math.cos(phi) - dy * Math.sin(phi), this.cy + dx * Math.sin(phi) + dy * Math.cos(phi));
      }
    }
    contains(that, y) {
      return false;
    }
    intersects(that) {
      return false;
    }
    split(u) {
      const a0 = this.a0;
      const da = this.da;
      const a = a0 + u * da;
      const c0 = new R2EllipticCurve(this.cx, this.cy, this.rx, this.ry, this.phi, a0, a - a0);
      const c1 = new R2EllipticCurve(this.cx, this.cy, this.rx, this.ry, this.phi, a, a0 + da - a);
      return [ c0, c1 ];
    }
    transform(f) {
      const cx = f.transformX(this.cx, this.cy);
      const cy = f.transformY(this.cx, this.cy);
      const rx = f.transformX(this.cx + this.rx, this.cy + this.ry) - cx;
      const ry = f.transformY(this.cx + this.rx, this.cy + this.ry) - cy;
      const a0 = this.a0;
      const da = this.da;
      const a1 = a0 + da;
      const a0x = Math.cos(a0);
      const a0y = Math.sin(a0);
      const a1x = Math.cos(a1);
      const a1y = Math.sin(a1);
      const b0x = f.transformX(this.cx + a0x, this.cy - a0y) - cx;
      const b0y = f.transformY(this.cx + a0x, this.cy - a0y) - cy;
      const b1x = f.transformX(this.cx + a1x, this.cy - a1y) - cx;
      const b1y = f.transformY(this.cx + a1x, this.cy - a1y) - cy;
      const b0 = Math.atan2(b0y, b0x);
      let b1 = Math.atan2(b1y, b1x);
      if (Math.abs(da) > Math.PI) {
        if (b1 > 0) {
          b1 = -2 * Math.PI + b1;
        } else if (b1 < 0) {
          b1 = 2 * Math.PI - b1;
        }
      }
      const db = b1 - b0;
      return new R2EllipticCurve(cx, cy, rx, ry, this.phi, b0, db);
    }
    drawMove(context) {
      const {x0: x0, y0: y0} = this.toEndpoints();
      context.moveTo(x0, y0);
    }
    drawRest(context) {
      context.ellipse(this.cx, this.cy, this.rx, this.ry, this.phi, this.a0, this.a0 + this.da, this.da < 0);
    }
    transformDrawMove(context, f) {
      const {x0: x0, y0: y0} = this.toEndpoints();
      context.moveTo(f.transformX(x0, y0), f.transformY(x0, y0));
    }
    transformDrawRest(context, f) {
      const cx = f.transformX(this.cx, this.cy);
      const cy = f.transformY(this.cx, this.cy);
      const rx = f.transformX(this.cx + this.rx, this.cy + this.ry) - cx;
      const ry = f.transformY(this.cx + this.rx, this.cy + this.ry) - cy;
      const a0 = this.a0;
      const da = this.da;
      const a1 = a0 + da;
      const a0x = Math.cos(a0);
      const a0y = Math.sin(a0);
      const a1x = Math.cos(a1);
      const a1y = Math.sin(a1);
      const b0x = f.transformX(this.cx + a0x, this.cy - a0y) - cx;
      const b0y = f.transformY(this.cx + a0x, this.cy - a0y) - cy;
      const b1x = f.transformX(this.cx + a1x, this.cy - a1y) - cx;
      const b1y = f.transformY(this.cx + a1x, this.cy - a1y) - cy;
      const b0 = Math.atan2(b0y, b0x);
      let b1 = Math.atan2(b1y, b1x);
      if (Math.abs(da) > Math.PI) {
        if (b1 > 0) {
          b1 = -2 * Math.PI + b1;
        } else if (b1 < 0) {
          b1 = 2 * Math.PI - b1;
        }
      }
      const ccw = b1 < b0;
      context.ellipse(cx, cy, rx, ry, this.phi, b0, b1, ccw);
    }
    writeMove(output) {
      const {x0: x0, y0: y0} = this.toEndpoints();
      output = output.write(77);
      output = Format.displayNumber(output, x0);
      output = output.write(44);
      output = Format.displayNumber(output, y0);
      return output;
    }
    writeRest(output) {
      const {rx: rx, ry: ry, phi: phi, large: large, sweep: sweep, x1: x1, y1: y1} = this.toEndpoints();
      output = output.write(65);
      output = Format.displayNumber(output, rx);
      output = output.write(44);
      output = Format.displayNumber(output, ry);
      output = output.write(32);
      output = Format.displayNumber(output, phi);
      output = output.write(32);
      output = output.write(large ? 49 : 48);
      output = output.write(44);
      output = output.write(sweep ? 49 : 48);
      output = output.write(32);
      output = Format.displayNumber(output, x1);
      output = output.write(44);
      output = Format.displayNumber(output, y1);
      return output;
    }
    toEndpoints() {
      const cx = this.cx;
      const cy = this.cy;
      const rx = this.rx;
      const ry = this.ry;
      const phi = this.phi;
      const a0 = this.a0;
      const da = this.da;
      const a1 = a0 + da;
      const cosPhi = Math.cos(phi);
      const sinPhi = Math.sin(phi);
      const cosA0 = Math.cos(a0);
      const sinA0 = Math.sin(a0);
      const cosA1 = Math.cos(a1);
      const sinA1 = Math.sin(a1);
      const x0 = cosPhi * rx * cosA0 - sinPhi * ry * sinA0 + cx;
      const y0 = sinPhi * rx * cosA0 + cosPhi * ry * sinA0 + cy;
      const x1 = cosPhi * rx * cosA1 - sinPhi * ry * sinA1 + cx;
      const y1 = sinPhi * rx * cosA1 + cosPhi * ry * sinA1 + cy;
      const large = Math.abs(da) > Math.PI;
      const sweep = da > 0;
      return {
        x0: x0,
        y0: y0,
        rx: rx,
        ry: ry,
        phi: phi,
        large: large,
        sweep: sweep,
        x1: x1,
        y1: y1
      };
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof R2EllipticCurve) {
        return Numbers.equivalent(this.cx, that.cx, epsilon) && Numbers.equivalent(this.cy, that.cy, epsilon) && Numbers.equivalent(this.rx, that.rx, epsilon) && Numbers.equivalent(this.ry, that.ry, epsilon) && Numbers.equivalent(this.phi, that.phi, epsilon) && Numbers.equivalent(this.a0, that.a0, epsilon) && Numbers.equivalent(this.da, that.da, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof R2EllipticCurve) {
        return this.cx === that.cx && this.cy === that.cy && this.rx === that.rx && this.ry === that.ry && this.phi === that.phi && this.a0 === that.a0 && this.da === that.da;
      }
      return false;
    }
    debug(output) {
      output = output.write("R2Curve").write(46).write("elliptic").write(40).debug(this.cx).write(", ").debug(this.cy).write(", ").debug(this.rx).write(", ").debug(this.ry).write(", ").debug(this.phi).write(", ").debug(this.a0).write(", ").debug(this.da).write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static fromEndpoints(x0, y0, rx, ry, phi, large, sweep, x1, y1) {
      const cosPhi = Math.cos(phi);
      const sinPhi = Math.sin(phi);
      const x0p = cosPhi * ((x0 - x1) / 2) + sinPhi * ((y0 - y1) / 2);
      const y0p = -sinPhi * ((x0 - x1) / 2) + cosPhi * ((y0 - y1) / 2);
      const rx2 = rx * rx;
      const ry2 = ry * ry;
      const x0p2 = x0p * x0p;
      const y0p2 = y0p * y0p;
      let sp = Math.sqrt((rx2 * ry2 - rx2 * y0p2 - ry2 * x0p2) / (rx2 * y0p2 + ry2 * x0p2));
      if (large === sweep) {
        sp = -sp;
      }
      const cxp = sp * rx * y0p / ry;
      const cyp = -sp * ry * x0p / rx;
      const cx = cosPhi * cxp - sinPhi * cyp + (x0 + x1) / 2;
      const cy = sinPhi * cxp + cosPhi * cyp + (y0 + y1) / 2;
      function angle(ux, uy, vx, vy) {
        const uv = ux * vx + uy * vy;
        const uu = ux * ux + uy * uy;
        const vv = vx * vx + vy * vy;
        let a = Math.acos(uv / (Math.sqrt(uu) * Math.sqrt(vv)));
        if (ux * vy - uy * vx < 0) {
          a = -a;
        }
        return a;
      }
      const a0 = angle(1, 0, (x0p - cxp) / rx, (y0p - cyp) / ry);
      let da = angle((x0p - cxp) / rx, (y0p - cyp) / ry, (-x0p - cxp) / rx, (-y0p - cyp) / ry) % (2 * Math.PI);
      if (sweep && da < 0) {
        da += 2 * Math.PI;
      } else if (!sweep && da > 0) {
        da -= 2 * Math.PI;
      }
      return new R2EllipticCurve(cx, cy, rx, ry, phi, a0, da);
    }
  }
  class R2EllipticCurveParser extends Parser {
    constructor(x0Parser, y0Parser, rxParser, ryParser, phiParser, large, sweep, x1Parser, y1Parser, command, step) {
      super();
      this.x0Parser = x0Parser;
      this.y0Parser = y0Parser;
      this.rxParser = rxParser;
      this.ryParser = ryParser;
      this.phiParser = phiParser;
      this.large = large;
      this.sweep = sweep;
      this.x1Parser = x1Parser;
      this.y1Parser = y1Parser;
      this.command = command;
      this.step = step;
    }
    feed(input) {
      return R2EllipticCurveParser.parse(input, this.x0Parser, this.y0Parser, this.rxParser, this.ryParser, this.phiParser, this.large, this.sweep, this.x1Parser, this.y1Parser, this.command, this.step);
    }
    static parse(input, x0Parser, y0Parser, rxParser, ryParser, phiParser, large, sweep, x1Parser, y1Parser, command, step = 1) {
      let c = 0;
      if (step === 1) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          switch (c) {
           case 65:
           case 97:
            input = input.step();
            command = c;
            step = 2;
            break;

           default:
            return Parser.error(Diagnostic.expected("arcto", input));
          }
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      if (step === 2) {
        if (rxParser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            rxParser = Base10.parseDecimal(input);
          }
        } else {
          rxParser = rxParser.feed(input);
        }
        if (rxParser !== void 0) {
          if (rxParser.isDone()) {
            step = 3;
          } else if (rxParser.isError()) {
            return rxParser.asError();
          }
        }
      }
      if (step === 3) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 4;
        } else if (!input.isEmpty()) {
          step = 4;
        }
      }
      if (step === 4) {
        if (ryParser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            ryParser = Base10.parseDecimal(input);
          }
        } else {
          ryParser = ryParser.feed(input);
        }
        if (ryParser !== void 0) {
          if (ryParser.isDone()) {
            step = 5;
          } else if (ryParser.isError()) {
            return ryParser.asError();
          }
        }
      }
      if (step === 5) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 6;
        } else if (!input.isEmpty()) {
          step = 6;
        }
      }
      if (step === 6) {
        if (phiParser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            phiParser = Base10.parseDecimal(input);
          }
        } else {
          phiParser = phiParser.feed(input);
        }
        if (phiParser !== void 0) {
          if (phiParser.isDone()) {
            step = 7;
          } else if (phiParser.isError()) {
            return phiParser.asError();
          }
        }
      }
      if (step === 7) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 8;
        } else if (!input.isEmpty()) {
          step = 8;
        }
      }
      if (step === 8) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 48) {
            input = input.step();
            large = false;
            step = 9;
          } else if (c === 49) {
            input = input.step();
            large = true;
            step = 9;
          } else {
            return Parser.error(Diagnostic.expected("flag", input));
          }
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      if (step === 9) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 10;
        } else if (!input.isEmpty()) {
          step = 10;
        }
      }
      if (step === 10) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 48) {
            input = input.step();
            sweep = false;
            step = 11;
          } else if (c === 49) {
            input = input.step();
            sweep = true;
            step = 11;
          } else {
            return Parser.error(Diagnostic.expected("flag", input));
          }
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      if (step === 11) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 12;
        } else if (!input.isEmpty()) {
          step = 12;
        }
      }
      if (step === 12) {
        if (x1Parser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            x1Parser = Base10.parseDecimal(input);
          }
        } else {
          x1Parser = x1Parser.feed(input);
        }
        if (x1Parser !== void 0) {
          if (x1Parser.isDone()) {
            step = 13;
          } else if (x1Parser.isError()) {
            return x1Parser.asError();
          }
        }
      }
      if (step === 13) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 14;
        } else if (!input.isEmpty()) {
          step = 14;
        }
      }
      if (step === 14) {
        if (y1Parser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            y1Parser = Base10.parseDecimal(input);
          }
        } else {
          y1Parser = y1Parser.feed(input);
        }
        if (y1Parser !== void 0) {
          if (y1Parser.isDone()) {
            const x0 = x0Parser.bind();
            const y0 = y0Parser.bind();
            const rx = rxParser.bind();
            const ry = ryParser.bind();
            const phi = phiParser.bind() * Math.PI / 180;
            let x1 = x1Parser.bind();
            let y1 = y1Parser.bind();
            if (command === 97) {
              x1 += x0;
              y1 += y0;
            }
            return Parser.done(R2EllipticCurve.fromEndpoints(x0, y0, rx, ry, phi, large, sweep, x1, y1));
          } else if (y1Parser.isError()) {
            return y1Parser.asError();
          }
        }
      }
      return new R2EllipticCurveParser(x0Parser, y0Parser, rxParser, ryParser, phiParser, large, sweep, x1Parser, y1Parser, command, step);
    }
    static parseRest(input, command, x0Parser, y0Parser) {
      return R2EllipticCurveParser.parse(input, x0Parser, y0Parser, void 0, void 0, void 0, void 0, void 0, void 0, void 0, command, 2);
    }
  }
  class R2Spline extends R2Curve {
    constructor(curves, closed) {
      super();
      this.curves = curves;
      this.closed = closed;
      this.boundingBox = null;
      this.pathString = void 0;
    }
    isDefined() {
      return this.curves.length !== 0;
    }
    isClosed() {
      return this.closed;
    }
    get xMin() {
      return this.bounds.xMin;
    }
    get yMin() {
      return this.bounds.yMin;
    }
    get xMax() {
      return this.bounds.xMax;
    }
    get yMax() {
      return this.bounds.yMax;
    }
    interpolateX(u) {
      const curves = this.curves;
      const n = curves.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n - 1);
        const v = n * (u - k * l);
        return curves[k].interpolateX(v);
      } else {
        return NaN;
      }
    }
    interpolateY(u) {
      const curves = this.curves;
      const n = curves.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n - 1);
        const v = n * (u - k * l);
        return curves[k].interpolateY(v);
      } else {
        return NaN;
      }
    }
    interpolate(u) {
      const curves = this.curves;
      const n = curves.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n - 1);
        const v = n * (u - k * l);
        return curves[k].interpolate(v);
      } else {
        return new R2Point(NaN, NaN);
      }
    }
    contains(that, y) {
      return false;
    }
    intersects(that) {
      return false;
    }
    split(u) {
      const curves = this.curves;
      const n = curves.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n - 1);
        const v = n * (u - k * l);
        const [c0, c1] = curves[k].split(v);
        const curves0 = new Array(k + 1);
        const curves1 = new Array(n - k);
        for (let i = 0; i < k; i += 1) {
          curves0[i] = curves[i];
        }
        curves0[k] = c0;
        curves1[0] = c1;
        for (let i = k + 1; i < n; i += 1) {
          curves1[i - k] = curves[i];
        }
        return [ new R2Spline(curves0, false), new R2Spline(curves1, false) ];
      } else {
        return [ R2Spline.empty(), R2Spline.empty() ];
      }
    }
    subdivide(u) {
      const oldCurves = this.curves;
      const n = oldCurves.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n - 1);
        const v = n * (u - k * l);
        const [c0, c1] = oldCurves[k].split(v);
        const newCurves = new Array(n + 1);
        for (let i = 0; i < k; i += 1) {
          newCurves[i] = oldCurves[i];
        }
        newCurves[k] = c0;
        newCurves[k + 1] = c1;
        for (let i = k + 1; i < n; i += 1) {
          newCurves[i + 1] = oldCurves[i];
        }
        return new R2Spline(newCurves, this.closed);
      } else {
        return R2Spline.empty();
      }
    }
    transform(f) {
      const oldCurves = this.curves;
      const n = oldCurves.length;
      if (n > 0) {
        const newCurves = new Array(n);
        for (let i = 0; i < n; i += 1) {
          newCurves[i] = oldCurves[i].transform(f);
        }
        return new R2Spline(newCurves, this.closed);
      } else {
        return R2Spline.empty();
      }
    }
    get bounds() {
      let boundingBox = this.boundingBox;
      if (boundingBox === null) {
        let xMin = Infinity;
        let yMin = Infinity;
        let xMax = -Infinity;
        let yMax = -Infinity;
        const curves = this.curves;
        for (let i = 0, n = curves.length; i < n; i += 1) {
          const curve = curves[i];
          xMin = Math.min(xMin, curve.xMin);
          yMin = Math.min(yMin, curve.yMin);
          xMax = Math.max(curve.xMax, xMax);
          yMax = Math.max(curve.yMax, yMax);
        }
        boundingBox = new R2Box(xMin, yMin, xMax, yMax);
        this.boundingBox = boundingBox;
      }
      return boundingBox;
    }
    drawMove(context) {
      const curves = this.curves;
      if (curves.length !== 0) {
        curves[0].drawMove(context);
      }
    }
    drawRest(context) {
      const curves = this.curves;
      const closed = this.closed;
      const n = curves.length - (closed && context.closePath !== void 0 ? 1 : 0);
      for (let i = 0; i < n; i += 1) {
        curves[i].drawRest(context);
      }
      if (closed && context.closePath !== void 0) {
        context.closePath();
      }
    }
    transformDrawMove(context, f) {
      const curves = this.curves;
      if (curves.length !== 0) {
        curves[0].transformDrawMove(context, f);
      }
    }
    transformDrawRest(context, f) {
      const curves = this.curves;
      const closed = this.closed;
      const n = curves.length - (closed && context.closePath !== void 0 ? 1 : 0);
      for (let i = 0; i < n; i += 1) {
        curves[i].transformDrawRest(context, f);
      }
      if (closed && context.closePath !== void 0) {
        context.closePath();
      }
    }
    writeMove(output) {
      const curves = this.curves;
      if (curves.length !== 0) {
        output = curves[0].writeMove(output);
      }
      return output;
    }
    writeRest(output) {
      const curves = this.curves;
      const closed = this.closed;
      const n = curves.length - (closed ? 1 : 0);
      for (let i = 0; i < n; i += 1) {
        output = curves[i].writeRest(output);
      }
      if (closed) {
        output = output.write(90);
      }
      return output;
    }
    toPathString(outputSettings) {
      let pathString;
      if (outputSettings !== void 0 || (pathString = this.pathString, pathString === void 0)) {
        const output = Unicode.stringOutput(outputSettings);
        this.writePath(output);
        pathString = output.bind();
        if (outputSettings === void 0) {
          this.pathString = pathString;
        }
      }
      return pathString;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof R2Spline) {
        return Arrays.equivalent(this.curves, that.curves, epsilon) && this.closed === that.closed;
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof R2Spline) {
        return Arrays.equal(this.curves, that.curves) && this.closed === that.closed;
      }
      return false;
    }
    debug(output) {
      const curves = this.curves;
      const n = curves.length;
      output = output.write("R2Spline").write(46);
      if (n === 0) {
        output = output.write("empty").write(40);
      } else if (n !== 0) {
        output = output.write(this.closed ? "closed" : "open").write(40);
        output = output.debug(curves[0]);
        for (let i = 1; i < n; i += 1) {
          output = output.write(", ").debug(curves[i]);
        }
      }
      output = output.write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static empty() {
      return new R2Spline([], false);
    }
    static open(...curves) {
      return new R2Spline(curves, false);
    }
    static closed(...curves) {
      return new R2Spline(curves, true);
    }
    static builder() {
      return new R2SplineBuilder;
    }
    static parse(string) {
      let input = Unicode.stringInput(string);
      while (input.isCont() && Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = R2SplineParser.parse(input);
      if (parser.isDone()) {
        while (input.isCont() && Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
  }
  class R2SplineBuilder {
    constructor() {
      this.curves = [];
      this.closed = false;
      this.aliased = false;
      this.x0 = 0;
      this.y0 = 0;
      this.x = 0;
      this.y = 0;
    }
    dealias() {
      if (this.aliased) {
        this.curves = this.curves.slice(0);
        this.aliased = false;
      }
    }
    moveTo(x, y) {
      if (this.aliased) {
        this.curves = [];
        this.aliased = false;
      } else {
        this.curves.length = 0;
      }
      this.closed = false;
      this.x0 = x;
      this.y0 = y;
      this.x = x;
      this.y = y;
    }
    closePath() {
      this.dealias();
      this.curves.push(new R2Segment(this.x, this.y, this.x0, this.y0));
      this.closed = true;
      this.x = this.x0;
      this.y = this.y0;
    }
    lineTo(x, y) {
      this.dealias();
      this.curves.push(new R2Segment(this.x, this.y, x, y));
      this.x = x;
      this.y = y;
    }
    quadraticCurveTo(x1, y1, x, y) {
      this.dealias();
      this.curves.push(new R2QuadraticCurve(this.x, this.y, x1, y1, x, y));
      this.x = x;
      this.y = y;
    }
    bezierCurveTo(x1, y1, x2, y2, x, y) {
      this.dealias();
      this.curves.push(new R2CubicCurve(this.x, this.y, x1, y1, x2, y2, x, y));
      this.x = x;
      this.y = y;
    }
    arcTo(x1, y1, x2, y2, r) {
      this.dealias();
      const x0 = this.x;
      const y0 = this.y;
      const dx01 = x1 - x0;
      const dy01 = y1 - y0;
      const dx12 = x2 - x1;
      const dy12 = y2 - y1;
      const a0 = Math.atan2(dy01, dx01) - Math.PI / 2;
      const a1 = Math.atan2(dy12, dx12) - Math.PI / 2;
      const da = a1 - a0;
      const r0x = Math.cos(a0);
      const r0y = Math.sin(a0);
      const r1x = Math.cos(a1);
      const r1y = Math.sin(a1);
      const r0x0 = x0 - r0x;
      const r0y0 = y0 - r0y;
      const r0x1 = x1 - r0x;
      const r0y1 = y1 - r0y;
      const r1x1 = x1 - r1x;
      const r1y1 = y1 - r1y;
      const r1x2 = x2 - r1x;
      const r1y2 = y2 - r1y;
      const u = R2SplineBuilder.intersection(r0x0, r0y0, r0x1 - r0x0, r0y1 - r0y0, r1x1, r1y1, r1x2 - r1x1, r1y2 - r1y1);
      const cx = r0x0 + u * (r0x1 - r0x0);
      const cy = r0y0 + u * (r0y1 - r0y0);
      this.curves.push(new R2EllipticCurve(cx, cy, r, r, 0, a0, da));
      this.x = x2;
      this.y = y2;
    }
    static intersection(px, py, rx, ry, qx, qy, sx, sy) {
      const pqx = qx - px;
      const pqy = qy - py;
      const pqr = pqx * ry - pqy * rx;
      const rs = rx * sy - ry * sx;
      if (pqr === 0 && rs === 0) {
        const rr = rx * rx + ry * ry;
        const sr = sx * rx + sy * ry;
        const t0 = (pqx * rx + pqy * ry) / rr;
        const t1 = t0 + sr / rr;
        if (sr >= 0 ? 0 < t1 && t0 < 1 : 0 < t0 && t1 < 1) {
          return t0;
        } else {
          return NaN;
        }
      } else if (rs === 0) {
        return NaN;
      } else {
        const pqs = pqx * sy - pqy * sx;
        const t = pqs / rs;
        const u = pqr / rs;
        if (0 <= t && t <= 1 && 0 <= u && u <= 1) {
          return t;
        } else {
          return NaN;
        }
      }
    }
    arc(cx, cy, r, a0, a1, ccw = false) {
      this.dealias();
      let da = a1 - a0;
      if (ccw === true && da > 0) {
        da -= 2 * Math.PI;
      } else if (ccw === false && da < 0) {
        da += 2 * Math.PI;
      }
      const curve = new R2EllipticCurve(cx, cy, r, r, 0, a0, da);
      this.curves.push(curve);
      const {x: x, y: y} = curve.interpolate(1);
      this.x = x;
      this.y = y;
    }
    ellipse(cx, cy, rx, ry, phi, a0, a1, ccw) {
      this.dealias();
      let da = a1 - a0;
      if (ccw === true && da > 0) {
        da -= 2 * Math.PI;
      } else if (ccw === false && da < 0) {
        da += 2 * Math.PI;
      }
      const curve = new R2EllipticCurve(cx, cy, rx, ry, phi, a0, da);
      this.curves.push(curve);
      const {x: x, y: y} = curve.interpolate(1);
      this.x = x;
      this.y = y;
    }
    rect(x, y, w, h) {
      this.dealias();
      this.curves.push(new R2Segment(x, y, x + w, y), new R2Segment(x + w, y, x + w, y + h), new R2Segment(x + w, y + h, x, y + h), new R2Segment(x, y + h, x, y));
      this.x = x;
      this.y = y;
    }
    bind() {
      this.aliased = true;
      return new R2Spline(this.curves, this.closed);
    }
  }
  class R2SplineParser extends Parser {
    constructor(xParser, yParser, x0Parser, y0Parser, curveParser, curves, command, step) {
      super();
      this.xParser = xParser;
      this.yParser = yParser;
      this.x0Parser = x0Parser;
      this.y0Parser = y0Parser;
      this.curveParser = curveParser;
      this.curves = curves;
      this.command = command;
      this.step = step;
    }
    feed(input) {
      return R2SplineParser.parse(input, this.xParser, this.yParser, this.x0Parser, this.y0Parser, this.curveParser, this.curves, this.command, this.step);
    }
    static parse(input, xParser, yParser, x0Parser, y0Parser, curveParser, curves, command, step = 1) {
      let c = 0;
      if (step === 1) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 77 || c === 109) {
            input = input.step();
            command = c;
            step = 2;
          } else {
            return Parser.error(Diagnostic.expected("moveto", input));
          }
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      if (step === 2) {
        if (x0Parser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            x0Parser = Base10.parseDecimal(input);
          }
        } else {
          x0Parser = x0Parser.feed(input);
        }
        if (x0Parser !== void 0) {
          if (x0Parser.isDone()) {
            if (command === 109 && xParser !== void 0) {
              x0Parser = Parser.done(xParser.bind() + x0Parser.bind());
            }
            xParser = x0Parser;
            step = 3;
          } else if (x0Parser.isError()) {
            return x0Parser.asError();
          }
        }
      }
      if (step === 3) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont()) {
          if (c === 44) {
            input = input.step();
          }
          step = 4;
        } else if (!input.isEmpty()) {
          step = 4;
        }
      }
      if (step === 4) {
        if (y0Parser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input = input.step();
          }
          if (!input.isEmpty()) {
            y0Parser = Base10.parseDecimal(input);
          }
        } else {
          y0Parser = y0Parser.feed(input);
        }
        if (y0Parser !== void 0) {
          if (y0Parser.isDone()) {
            if (command === 109 && yParser !== void 0) {
              y0Parser = Parser.done(yParser.bind() + y0Parser.bind());
            }
            yParser = y0Parser;
            step = 5;
          } else if (y0Parser.isError()) {
            return y0Parser.asError();
          }
        }
      }
      do {
        if (step === 5) {
          if (curveParser === void 0) {
            while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
              input = input.step();
            }
            if (input.isCont()) {
              const prevCurve = curves !== void 0 && curves.length !== 0 ? curves[curves.length - 1] : null;
              switch (c) {
               case 76:
               case 108:
               case 72:
               case 104:
               case 86:
               case 118:
                curveParser = R2SegmentParser.parse(input, xParser, yParser);
                command = c;
                break;

               case 81:
               case 113:
                curveParser = R2QuadraticCurveParser.parse(input, xParser, yParser);
                command = c;
                break;

               case 84:
                if (prevCurve instanceof R2QuadraticCurve) {
                  const dx = prevCurve.x2 - prevCurve.x1;
                  const dy = prevCurve.y2 - prevCurve.y1;
                  const x1 = xParser.bind() + dx;
                  const y1 = yParser.bind() + dy;
                  curveParser = R2QuadraticCurveParser.parse(input, xParser, yParser, Parser.done(x1), Parser.done(y1));
                } else {
                  curveParser = R2QuadraticCurveParser.parse(input, xParser, yParser, xParser, yParser);
                }
                command = c;
                break;

               case 116:
                if (prevCurve instanceof R2QuadraticCurve) {
                  const dx = prevCurve.x2 - prevCurve.x1;
                  const dy = prevCurve.y2 - prevCurve.y1;
                  curveParser = R2QuadraticCurveParser.parse(input, xParser, yParser, Parser.done(dx), Parser.done(dy));
                } else {
                  curveParser = R2QuadraticCurveParser.parse(input, xParser, yParser, Parser.done(0), Parser.done(0));
                }
                command = c;
                break;

               case 67:
               case 99:
                curveParser = R2CubicCurveParser.parse(input, xParser, yParser);
                command = c;
                break;

               case 83:
                if (prevCurve instanceof R2CubicCurve) {
                  const dx = prevCurve.x3 - prevCurve.x2;
                  const dy = prevCurve.y3 - prevCurve.y2;
                  const x1 = xParser.bind() + dx;
                  const y1 = yParser.bind() + dy;
                  curveParser = R2CubicCurveParser.parse(input, xParser, yParser, Parser.done(x1), Parser.done(y1));
                } else {
                  curveParser = R2CubicCurveParser.parse(input, xParser, yParser, xParser, yParser);
                }
                command = c;
                break;

               case 115:
                if (prevCurve instanceof R2CubicCurve) {
                  const dx = prevCurve.x3 - prevCurve.x2;
                  const dy = prevCurve.y3 - prevCurve.y2;
                  curveParser = R2CubicCurveParser.parse(input, xParser, yParser, Parser.done(dx), Parser.done(dy));
                } else {
                  curveParser = R2CubicCurveParser.parse(input, xParser, yParser, Parser.done(0), Parser.done(0));
                }
                command = c;
                break;

               case 65:
               case 97:
                curveParser = R2EllipticCurveParser.parse(input, xParser, yParser);
                command = c;
                break;

               case 90:
               case 122:
                input = input.step();
                if (curves === void 0) {
                  curves = [];
                }
                curves.push(new R2Segment(xParser.bind(), yParser.bind(), x0Parser.bind(), y0Parser.bind()));
                return Parser.done(new R2Spline(curves, true));

               case 44:
                input = input.step();

               case 43:
               case 45:
               case 46:
               case 48:
               case 49:
               case 50:
               case 51:
               case 52:
               case 53:
               case 54:
               case 55:
               case 56:
               case 57:
                switch (command) {
                 case 77:
                 case 109:
                 case 76:
                 case 108:
                 case 72:
                 case 104:
                 case 86:
                 case 118:
                  curveParser = R2SegmentParser.parseRest(input, command, xParser, yParser);
                  break;

                 case 81:
                 case 113:
                  curveParser = R2QuadraticCurveParser.parseRest(input, command, xParser, yParser);
                  break;

                 case 84:
                  if (prevCurve instanceof R2QuadraticCurve) {
                    const dx = prevCurve.x2 - prevCurve.x1;
                    const dy = prevCurve.y2 - prevCurve.y1;
                    const x1 = xParser.bind() + dx;
                    const y1 = yParser.bind() + dy;
                    curveParser = R2QuadraticCurveParser.parseRest(input, command, xParser, yParser, Parser.done(x1), Parser.done(y1));
                  } else {
                    curveParser = R2QuadraticCurveParser.parseRest(input, command, xParser, yParser, xParser, yParser);
                  }
                  break;

                 case 116:
                  if (prevCurve instanceof R2QuadraticCurve) {
                    const dx = prevCurve.x2 - prevCurve.x1;
                    const dy = prevCurve.y2 - prevCurve.y1;
                    curveParser = R2QuadraticCurveParser.parseRest(input, command, xParser, yParser, Parser.done(dx), Parser.done(dy));
                  } else {
                    curveParser = R2QuadraticCurveParser.parseRest(input, command, xParser, yParser, Parser.done(0), Parser.done(0));
                  }
                  break;

                 case 67:
                 case 99:
                  curveParser = R2CubicCurveParser.parseRest(input, command, xParser, yParser);
                  break;

                 case 83:
                  if (prevCurve instanceof R2CubicCurve) {
                    const dx = prevCurve.x3 - prevCurve.x2;
                    const dy = prevCurve.y3 - prevCurve.y2;
                    const x1 = xParser.bind() + dx;
                    const y1 = yParser.bind() + dy;
                    curveParser = R2CubicCurveParser.parseRest(input, command, xParser, yParser, Parser.done(x1), Parser.done(y1));
                  } else {
                    curveParser = R2CubicCurveParser.parseRest(input, command, xParser, yParser, xParser, yParser);
                  }
                  break;

                 case 115:
                  if (prevCurve instanceof R2CubicCurve) {
                    const dx = prevCurve.x3 - prevCurve.x2;
                    const dy = prevCurve.y3 - prevCurve.y2;
                    curveParser = R2CubicCurveParser.parseRest(input, command, xParser, yParser, Parser.done(dx), Parser.done(dy));
                  } else {
                    curveParser = R2CubicCurveParser.parseRest(input, command, xParser, yParser, Parser.done(0), Parser.done(0));
                  }
                  break;

                 case 65:
                 case 97:
                  curveParser = R2EllipticCurveParser.parseRest(input, command, xParser, yParser);
                  break;

                 default:
                  if (curves !== void 0) {
                    return Parser.done(new R2Spline(curves, false));
                  } else {
                    return Parser.done(R2Spline.empty());
                  }
                }
                break;

               default:
                if (curves !== void 0) {
                  return Parser.done(new R2Spline(curves, false));
                } else {
                  return Parser.done(R2Spline.empty());
                }
              }
            } else if (!input.isEmpty()) {
              if (curves !== void 0) {
                return Parser.done(new R2Spline(curves, false));
              } else {
                return Parser.done(R2Spline.empty());
              }
            }
          } else {
            curveParser = curveParser.feed(input);
          }
          if (curveParser !== void 0) {
            if (curveParser.isDone()) {
              const curve = curveParser.bind();
              curveParser = void 0;
              if (curves === void 0) {
                curves = [];
              }
              curves.push(curve);
              xParser = Parser.done(curve.interpolateX(1));
              yParser = Parser.done(curve.interpolateY(1));
              continue;
            } else if (curveParser.isError()) {
              return curveParser.asError();
            }
          }
        }
        break;
      } while (true);
      return new R2SplineParser(xParser, yParser, x0Parser, y0Parser, curveParser, curves, command, step);
    }
  }
  class R2Path extends R2Shape {
    constructor(splines) {
      super();
      this.splines = splines;
      this.boundingBox = null;
      this.pathString = void 0;
    }
    isDefined() {
      return this.splines.length !== 0;
    }
    get xMin() {
      return this.bounds.xMin;
    }
    get yMin() {
      return this.bounds.yMin;
    }
    get xMax() {
      return this.bounds.xMax;
    }
    get yMax() {
      return this.bounds.yMax;
    }
    interpolateX(u) {
      const splines = this.splines;
      const n = splines.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n);
        const v = u * n - k * l;
        return splines[k].interpolateX(v);
      } else {
        return NaN;
      }
    }
    interpolateY(u) {
      const splines = this.splines;
      const n = splines.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n);
        const v = u * n - k * l;
        return splines[k].interpolateY(v);
      } else {
        return NaN;
      }
    }
    interpolate(u) {
      const splines = this.splines;
      const n = splines.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n);
        const v = u * n - k * l;
        return splines[k].interpolate(v);
      } else {
        return new R2Point(NaN, NaN);
      }
    }
    contains(that, y) {
      return false;
    }
    intersects(that) {
      return false;
    }
    split(u) {
      const splines = this.splines;
      const n = splines.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n);
        const v = u * n - k * l;
        const [s0, s1] = splines[k].split(v);
        const splines0 = new Array(k + 1);
        const splines1 = new Array(n - k);
        for (let i = 0; i < k; i += 1) {
          splines0[i] = splines[i];
        }
        splines0[k] = s0;
        splines1[0] = s1;
        for (let i = k + 1; i < n; i += 1) {
          splines1[i - k] = splines[i];
        }
        return [ new R2Path(splines0), new R2Path(splines1) ];
      } else {
        return [ R2Path.empty(), R2Path.empty() ];
      }
    }
    subdivide(u) {
      const oldSplines = this.splines;
      const n = oldSplines.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n);
        const v = u * n - k * l;
        const newSplines = new Array(n);
        for (let i = 0; i < k; i += 1) {
          newSplines[i] = oldSplines[i];
        }
        newSplines[k] = oldSplines[k].subdivide(v);
        for (let i = k + 1; i < n; i += 1) {
          newSplines[i] = oldSplines[i];
        }
        return new R2Path(newSplines);
      } else {
        return R2Path.empty();
      }
    }
    transform(f) {
      const oldSplines = this.splines;
      const n = oldSplines.length;
      if (n > 0) {
        const newSplines = new Array(n);
        for (let i = 0; i < n; i += 1) {
          newSplines[i] = oldSplines[i].transform(f);
        }
        return new R2Path(newSplines);
      } else {
        return R2Path.empty();
      }
    }
    get bounds() {
      let boundingBox = this.boundingBox;
      if (boundingBox === null) {
        let xMin = Infinity;
        let yMin = Infinity;
        let xMax = -Infinity;
        let yMax = -Infinity;
        const splines = this.splines;
        for (let i = 0, n = splines.length; i < n; i += 1) {
          const spline = splines[i];
          xMin = Math.min(xMin, spline.xMin);
          yMin = Math.min(yMin, spline.yMin);
          xMax = Math.max(spline.xMax, xMax);
          yMax = Math.max(spline.yMax, yMax);
        }
        boundingBox = new R2Box(xMin, yMin, xMax, yMax);
        this.boundingBox = boundingBox;
      }
      return boundingBox;
    }
    draw(context) {
      const splines = this.splines;
      for (let i = 0, n = splines.length; i < n; i += 1) {
        splines[i].draw(context);
      }
    }
    transformDraw(context, f) {
      const splines = this.splines;
      for (let i = 0, n = splines.length; i < n; i += 1) {
        splines[i].transformDraw(context, f);
      }
    }
    writePath(output) {
      const splines = this.splines;
      const n = splines.length;
      if (output.settings === OutputSettings.standard()) {
        for (let i = 0; i < n; i += 1) {
          output = output.write(splines[i].toPathString());
        }
      } else {
        for (let i = 0; i < n; i += 1) {
          output = splines[i].writePath(output);
        }
      }
      return output;
    }
    toPathString(outputSettings) {
      let pathString;
      if (outputSettings !== void 0 || (pathString = this.pathString, pathString === void 0)) {
        const output = Unicode.stringOutput(outputSettings);
        this.writePath(output);
        pathString = output.bind();
        if (outputSettings === void 0) {
          this.pathString = pathString;
        }
      }
      return pathString;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof R2Path) {
        return Arrays.equivalent(this.splines, that.splines, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof R2Path) {
        return Arrays.equal(this.splines, that.splines);
      }
      return false;
    }
    debug(output) {
      const splines = this.splines;
      const n = splines.length;
      output = output.write("R2Path").write(46);
      if (n === 0) {
        output = output.write("empty").write(40);
      } else if (n === 1) {
        const spline = splines[0];
        output = output.write(spline.closed ? "closed" : "open").write(40);
        const curves = spline.curves;
        const m = curves.length;
        if (m !== 0) {
          output = output.debug(curves[0]);
          for (let i = 1; i < m; i += 1) {
            output = output.write(", ").debug(curves[i]);
          }
        }
      } else {
        output = output.write("of").write(40);
        output = output.debug(splines[0]);
        for (let i = 1; i < n; i += 1) {
          output = output.write(", ").debug(splines[i]);
        }
      }
      output = output.write(41);
      return output;
    }
    toAttributeString() {
      return this.toPathString();
    }
    toString() {
      return Format.debug(this);
    }
    static empty() {
      return new R2Path([]);
    }
    static of(...splines) {
      return new R2Path(splines);
    }
    static open(...curves) {
      return new R2Path([ new R2Spline(curves, false) ]);
    }
    static closed(...curves) {
      return new R2Path([ new R2Spline(curves, true) ]);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof R2Path) {
        return value;
      } else if (typeof value === "string") {
        return R2Path.parse(value);
      } else {
        throw new TypeError("" + value);
      }
    }
    static builder() {
      return new R2PathBuilder;
    }
    static parse(string) {
      let input = Unicode.stringInput(string);
      while (input.isCont() && Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = R2PathParser.parse(input);
      if (parser.isDone()) {
        while (input.isCont() && Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
  }
  class R2PathBuilder {
    constructor() {
      this.splines = [];
      this.builder = null;
    }
    moveTo(x, y) {
      let builder = this.builder;
      if (builder !== null) {
        const spline = builder.bind();
        if (spline.isDefined()) {
          this.splines.push(spline);
        }
      }
      builder = new R2SplineBuilder;
      this.builder = builder;
      builder.moveTo(x, y);
    }
    closePath() {
      const builder = this.builder;
      if (builder !== null) {
        builder.closePath();
      } else {
        throw new Error;
      }
    }
    lineTo(x, y) {
      const builder = this.builder;
      if (builder !== null) {
        builder.lineTo(x, y);
      } else {
        throw new Error;
      }
    }
    quadraticCurveTo(x1, y1, x, y) {
      const builder = this.builder;
      if (builder !== null) {
        builder.quadraticCurveTo(x1, y1, x, y);
      } else {
        throw new Error;
      }
    }
    bezierCurveTo(x1, y1, x2, y2, x, y) {
      const builder = this.builder;
      if (builder !== null) {
        builder.bezierCurveTo(x1, y1, x2, y2, x, y);
      } else {
        throw new Error;
      }
    }
    arcTo(x1, y1, x2, y2, r) {
      const builder = this.builder;
      if (builder !== null) {
        builder.arcTo(x1, y1, x2, y2, r);
      } else {
        throw new Error;
      }
    }
    arc(cx, cy, r, a0, a1, ccw) {
      const builder = this.builder;
      if (builder !== null) {
        builder.arc(cx, cy, r, a0, a1, ccw);
      } else {
        throw new Error;
      }
    }
    ellipse(cx, cy, rx, ry, phi, a0, a1, ccw) {
      const builder = this.builder;
      if (builder !== null) {
        builder.ellipse(cx, cy, rx, ry, phi, a0, a1, ccw);
      } else {
        throw new Error;
      }
    }
    rect(x, y, w, h) {
      const builder = this.builder;
      if (builder !== null) {
        builder.rect(x, y, w, h);
      } else {
        throw new Error;
      }
    }
    bind() {
      const splines = this.splines.slice(0);
      const builder = this.builder;
      if (builder !== null) {
        const spline = builder.bind();
        if (spline.isDefined()) {
          splines.push(spline);
        }
      }
      return new R2Path(splines);
    }
  }
  class R2PathParser extends Parser {
    constructor(splineParser, splines, step) {
      super();
      this.splineParser = splineParser;
      this.splines = splines;
      this.step = step;
    }
    feed(input) {
      return R2PathParser.parse(input, this.splineParser, this.splines, this.step);
    }
    static parse(input, splineParser, splines, step = 1) {
      let c = 0;
      do {
        if (step === 1) {
          if (splineParser === void 0) {
            while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
              input = input.step();
            }
            if (input.isCont()) {
              switch (c) {
               case 77:
                splineParser = R2SplineParser.parse(input);
                break;

               case 109:
                {
                  let xParser;
                  let yParser;
                  if (splines !== void 0 && splines.length !== 0) {
                    const spline = splines[splines.length - 1];
                    xParser = Parser.done(spline.interpolateX(1));
                    yParser = Parser.done(spline.interpolateY(1));
                  }
                  splineParser = R2SplineParser.parse(input, xParser, yParser);
                  break;
                }

               case 110:
                step = 2;
                break;

               default:
                if (splines !== void 0) {
                  return Parser.done(new R2Path(splines));
                } else {
                  return Parser.done(R2Path.empty());
                }
              }
            } else if (!input.isEmpty()) {
              if (splines !== void 0) {
                return Parser.done(new R2Path(splines));
              } else {
                return Parser.done(R2Path.empty());
              }
            }
          } else {
            splineParser = splineParser.feed(input);
          }
          if (splineParser !== void 0) {
            if (splineParser.isDone()) {
              const spline = splineParser.bind();
              splineParser = void 0;
              if (spline.isDefined()) {
                if (splines === void 0) {
                  splines = [];
                }
                splines.push(spline);
              }
              continue;
            } else if (splineParser.isError()) {
              return splineParser.asError();
            }
          }
        }
        break;
      } while (true);
      if (step >= 2 && step <= 5) {
        do {
          if (input.isCont()) {
            if (input.head() === "none".charCodeAt(step - 2)) {
              input = input.step();
              if (step < 5) {
                step += 1;
                continue;
              } else {
                return Parser.done(R2Path.empty());
              }
            } else {
              return Parser.error(Diagnostic.expected("none", input));
            }
          } else if (!input.isEmpty()) {
            return Parser.error(Diagnostic.unexpected(input));
          }
          break;
        } while (true);
      }
      return new R2PathParser(splineParser, splines, step);
    }
  }
  class R2Circle extends R2Shape {
    constructor(cx, cy, r) {
      super();
      this.cx = cx;
      this.cy = cy;
      this.r = r;
    }
    isDefined() {
      return isFinite(this.cx) && isFinite(this.cy) && isFinite(this.r);
    }
    get xMin() {
      return this.cx - this.r;
    }
    get yMin() {
      return this.cy - this.r;
    }
    get xMax() {
      return this.cx + this.r;
    }
    get yMax() {
      return this.cy + this.r;
    }
    contains(that, y) {
      if (typeof that === "number") {
        const dx = that - this.cx;
        const dy = y - this.cy;
        return dx * dx + dy * dy <= this.r * this.r;
      } else {
        that = R2Shape.fromAny(that);
        if (that instanceof R2Point) {
          return this.containsPoint(that);
        } else if (that instanceof R2Segment) {
          return this.containsSegment(that);
        } else if (that instanceof R2Box) {
          return this.containsBox(that);
        } else if (that instanceof R2Circle) {
          return this.containsCircle(that);
        }
        return false;
      }
    }
    containsPoint(that) {
      const dx = that.x - this.cx;
      const dy = that.y - this.cy;
      return dx * dx + dy * dy <= this.r * this.r;
    }
    containsSegment(that) {
      const dx0 = that.x0 - this.cx;
      const dy0 = that.y0 - this.cy;
      const dx1 = that.x1 - this.cx;
      const dy1 = that.y1 - this.cy;
      const r2 = this.r * this.r;
      return dx0 * dx0 + dy0 * dy0 <= r2 && dx1 * dx1 + dy1 * dy1 <= r2;
    }
    containsBox(that) {
      const dxMin = that.xMin - this.cx;
      const dyMin = that.yMin - this.cy;
      const dxMax = that.xMax - this.cx;
      const dyMax = that.yMax - this.cy;
      const r2 = this.r * this.r;
      return dxMin * dxMin + dyMin * dyMin <= r2 && dxMin * dxMin + dyMax * dyMax <= r2 && dxMax * dxMax + dyMin * dyMin <= r2 && dxMax * dxMax + dyMax * dyMax <= r2;
    }
    containsCircle(that) {
      const dx = that.cx - this.cx;
      const dy = that.cy - this.cy;
      return dx * dx + dy * dy + that.r * that.r <= this.r * this.r;
    }
    intersects(that) {
      that = R2Shape.fromAny(that);
      if (that instanceof R2Point) {
        return this.intersectsPoint(that);
      } else if (that instanceof R2Segment) {
        return this.intersectsSegment(that);
      } else if (that instanceof R2Box) {
        return this.intersectsBox(that);
      } else if (that instanceof R2Circle) {
        return this.intersectsCircle(that);
      } else {
        return that.intersects(this);
      }
    }
    intersectsPoint(that) {
      const dx = that.x - this.cx;
      const dy = that.y - this.cy;
      return dx * dx + dy * dy <= this.r * this.r;
    }
    intersectsSegment(that) {
      const cx = this.cx;
      const cy = this.cy;
      const r = this.r;
      const x0 = that.x0;
      const y0 = that.y0;
      const x1 = that.x1;
      const y1 = that.y1;
      const dx = x1 - x0;
      const dy = y1 - y0;
      const l = Math.sqrt(dx * dx + dy * dy);
      const unitX = dx / l;
      const unitY = dy / l;
      const d = (cx - x0) * unitY - (cy - y0) * unitX;
      if (d < -r || r < d) {
        return false;
      } else {
        const dcx0 = x0 - cx;
        const dcy0 = y0 - cy;
        const dcx1 = x1 - cx;
        const dcy1 = y1 - cy;
        const r2 = r * r;
        if (dcx0 * dcx0 + dcy0 * dcy0 <= r2 || dcx1 * dcx1 + dcy1 * dcy1 <= r2) {
          return true;
        } else {
          const uc = unitX * cx + unitY * cy;
          const u0 = unitX * x0 + unitY * y0;
          const u1 = unitX * x1 + unitY * y1;
          return u0 < uc && uc <= u1 || u1 < uc && uc <= u0;
        }
      }
    }
    intersectsBox(that) {
      const dx = (this.cx < that.xMin ? that.xMin : that.xMax < this.cx ? that.xMax : this.cx) - this.cx;
      const dy = (this.cy < that.yMin ? that.yMin : that.yMax < this.cy ? that.yMax : this.cy) - this.cy;
      return dx * dx + dy * dy <= this.r * this.r;
    }
    intersectsCircle(that) {
      const dx = that.cx - this.cx;
      const dy = that.cy - this.cy;
      const rr = this.r + that.r;
      return dx * dx + dy * dy <= rr * rr;
    }
    transform(f) {
      const cx = f.transformX(this.cx, this.cy);
      const cy = f.transformY(this.cx, this.cy);
      const rx = f.transformX(this.cx + this.r, this.cy);
      const ry = f.transformY(this.cx + this.r, this.cy);
      const dx = rx - cx;
      const dy = ry - cy;
      const r = Math.sqrt(dx * dx + dy * dy);
      return new R2Circle(cx, cy, r);
    }
    toAny() {
      return {
        cx: this.cx,
        cy: this.cy,
        r: this.r
      };
    }
    interpolateTo(that) {
      if (that instanceof R2Circle) {
        return R2CircleInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof R2Circle) {
        return Numbers.equivalent(this.cx, that.cx, epsilon) && Numbers.equivalent(this.cy, that.cy, epsilon) && Numbers.equivalent(this.r, that.r, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof R2Circle) {
        return this.cx === that.cx && this.cy === that.cy && this.r === that.r;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Constructors.hash(R2Circle), Numbers.hash(this.cx)), Numbers.hash(this.cy)), Numbers.hash(this.r)));
    }
    debug(output) {
      output = output.write("R2Circle").write(46).write("of").write(40).debug(this.cx).write(", ").debug(this.cy).write(", ").debug(this.r).write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static of(cx, cy, r) {
      return new R2Circle(cx, cy, r);
    }
    static fromInit(value) {
      return new R2Circle(value.cx, value.cy, value.r);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof R2Circle) {
        return value;
      } else if (R2Circle.isInit(value)) {
        return R2Circle.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return typeof init.cx === "number" && typeof init.cy === "number" && typeof init.r === "number";
      }
      return false;
    }
    static isAny(value) {
      return value instanceof R2Circle || R2Circle.isInit(value);
    }
  }
  class R2Box extends R2Shape {
    constructor(xMin, yMin, xMax, yMax) {
      super();
      this.xMin = xMin;
      this.yMin = yMin;
      this.xMax = xMax;
      this.yMax = yMax;
    }
    isDefined() {
      return isFinite(this.xMin) && isFinite(this.yMin) && isFinite(this.xMax) && isFinite(this.yMax);
    }
    get x() {
      return this.xMin;
    }
    get y() {
      return this.yMin;
    }
    get width() {
      return this.xMax - this.xMin;
    }
    get height() {
      return this.yMax - this.yMin;
    }
    get top() {
      return this.yMin;
    }
    get right() {
      return this.xMax;
    }
    get bottom() {
      return this.yMax;
    }
    get left() {
      return this.xMin;
    }
    get center() {
      return new R2Point((this.xMin + this.xMax) / 2, (this.yMin + this.yMax) / 2);
    }
    contains(that, y) {
      if (typeof that === "number") {
        return this.xMin <= that && that <= this.xMax && this.yMin <= y && y <= this.yMax;
      } else {
        that = R2Shape.fromAny(that);
        if (that instanceof R2Shape) {
          if (that instanceof R2Point) {
            return this.containsPoint(that);
          } else if (that instanceof R2Segment) {
            return this.containsSegment(that);
          } else if (that instanceof R2Box) {
            return this.containsBox(that);
          } else if (that instanceof R2Circle) {
            return this.containsCircle(that);
          } else {
            return this.xMin <= that.xMin && that.xMax <= this.xMax && this.yMin <= that.yMin && that.yMax <= this.yMax;
          }
        }
        return false;
      }
    }
    containsPoint(that) {
      return this.xMin <= that.x && that.x <= this.xMax && this.yMin <= that.y && that.y <= this.yMax;
    }
    containsSegment(that) {
      return this.xMin <= that.x0 && that.x0 <= this.xMax && this.yMin <= that.y0 && that.y0 <= this.yMax && this.xMin <= that.x1 && that.x1 <= this.xMax && this.yMin <= that.y1 && that.y1 <= this.yMax;
    }
    containsBox(that) {
      return this.xMin <= that.xMin && that.xMax <= this.xMax && this.yMin <= that.yMin && that.yMax <= this.yMax;
    }
    containsCircle(that) {
      return this.xMin <= that.cx - that.r && that.cx + that.r <= this.xMax && this.yMin <= that.cy - that.r && that.cy + that.r <= this.yMax;
    }
    intersects(that) {
      that = R2Shape.fromAny(that);
      if (that instanceof R2Point) {
        return this.intersectsPoint(that);
      } else if (that instanceof R2Segment) {
        return this.intersectsSegment(that);
      } else if (that instanceof R2Box) {
        return this.intersectsBox(that);
      } else if (that instanceof R2Circle) {
        return this.intersectsCircle(that);
      } else {
        return that.intersects(this);
      }
    }
    intersectsPoint(that) {
      return this.xMin <= that.x && that.x <= this.xMax && this.yMin <= that.y && that.y <= this.yMax;
    }
    intersectsSegment(that) {
      const xMin = this.xMin;
      const yMin = this.yMin;
      const xMax = this.xMax;
      const yMax = this.yMax;
      const x0 = that.x0;
      const y0 = that.y0;
      const x1 = that.x1;
      const y1 = that.y1;
      if (x0 < xMin && x1 < xMin || x0 > xMax && x1 > xMax || y0 < yMin && y1 < yMin || y0 > yMax && y1 > yMax) {
        return false;
      } else if (x0 > xMin && x0 < xMax && y0 > yMin && y0 < yMax) {
        return true;
      } else if (R2Box.intersectsSegment(x0 - xMin, x1 - xMin, x0, y0, x1, y1) && R2Box.hitY > yMin && R2Box.hitY < yMax || R2Box.intersectsSegment(y0 - yMin, y1 - yMin, x0, y0, x1, y1) && R2Box.hitX > xMin && R2Box.hitX < xMax || R2Box.intersectsSegment(x0 - xMax, x1 - xMax, x0, y0, x1, y1) && R2Box.hitY > yMin && R2Box.hitY < yMax || R2Box.intersectsSegment(y0 - yMax, y1 - yMax, x0, y0, x1, y1) && R2Box.hitX > xMin && R2Box.hitX < xMax) {
        return true;
      } else {
        return false;
      }
    }
    static intersectsSegment(d0, d1, x0, y0, x1, y1) {
      if (d0 !== d1 || d0 * d1 < 0) {
        const scale = -d0 / (d1 - d0);
        R2Box.hitX = x0 + (x1 - x0) * scale;
        R2Box.hitY = y0 + (y1 - y0) * scale;
        return true;
      }
      return false;
    }
    intersectsBox(that) {
      return this.xMin <= that.xMax && that.xMin <= this.xMax && this.yMin <= that.yMax && that.yMin <= this.yMax;
    }
    intersectsCircle(that) {
      const dx = (that.cx < this.xMin ? this.xMin : this.xMax < that.cx ? this.xMax : that.cx) - that.cx;
      const dy = (that.cy < this.yMin ? this.yMin : this.yMax < that.cy ? this.yMax : that.cy) - that.cy;
      return dx * dx + dy * dy <= that.r * that.r;
    }
    union(that) {
      return super.union(that);
    }
    transform(f) {
      return new R2Box(f.transformX(this.xMin, this.yMin), f.transformY(this.xMin, this.yMin), f.transformX(this.xMax, this.yMax), f.transformY(this.xMax, this.yMax));
    }
    get bounds() {
      return this;
    }
    toAny() {
      return {
        xMin: this.xMin,
        yMin: this.yMin,
        xMax: this.xMax,
        yMax: this.yMax
      };
    }
    interpolateTo(that) {
      if (that instanceof R2Box) {
        return R2BoxInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof R2Box) {
        return Numbers.equivalent(this.xMin, that.xMin, epsilon) && Numbers.equivalent(this.yMin, that.yMin, epsilon) && Numbers.equivalent(this.xMax, that.xMax, epsilon) && Numbers.equivalent(this.yMax, that.yMax, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof R2Box) {
        return this.xMin === that.xMin && this.yMin === that.yMin && this.xMax === that.xMax && this.yMax === that.yMax;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(Constructors.hash(R2Box), Numbers.hash(this.xMin)), Numbers.hash(this.yMin)), Numbers.hash(this.xMax)), Numbers.hash(this.yMax)));
    }
    debug(output) {
      output = output.write("R2Box").write(46).write("of").write(40).debug(this.xMin).write(", ").debug(this.yMin).write(", ").debug(this.xMax).write(", ").debug(this.yMax).write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static undefined() {
      return new R2Box(Infinity, Infinity, -Infinity, -Infinity);
    }
    static of(xMin, yMin, xMax, yMax) {
      if (xMax === void 0) {
        xMax = xMin;
      }
      if (yMax === void 0) {
        yMax = yMin;
      }
      return new R2Box(xMin, yMin, xMax, yMax);
    }
    static fromInit(value) {
      return new R2Box(value.xMin, value.yMin, value.xMax, value.yMax);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof R2Box) {
        return value;
      } else if (R2Box.isInit(value)) {
        return R2Box.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return typeof init.xMin === "number" && typeof init.yMin === "number" && typeof init.xMax === "number" && typeof init.yMax === "number";
      }
      return false;
    }
    static isAny(value) {
      return value instanceof R2Box || R2Box.isInit(value);
    }
  }
  R2Box.hitX = 0;
  R2Box.hitY = 0;
  __decorate([ Lazy ], R2Box, "undefined", null);
  const R2BoxInterpolator = function(_super) {
    const R2BoxInterpolator = function(s0, s1) {
      const interpolator = function(u) {
        const s0 = interpolator[0];
        const s1 = interpolator[1];
        const xMin = s0.xMin + u * (s1.xMin - s0.xMin);
        const yMin = s0.yMin + u * (s1.yMin - s0.yMin);
        const xMax = s0.xMax + u * (s1.xMax - s0.xMax);
        const yMax = s0.yMax + u * (s1.yMax - s0.yMax);
        return new R2Box(xMin, yMin, xMax, yMax);
      };
      Object.setPrototypeOf(interpolator, R2BoxInterpolator.prototype);
      interpolator[0] = s0;
      interpolator[1] = s1;
      return interpolator;
    };
    R2BoxInterpolator.prototype = Object.create(_super.prototype);
    R2BoxInterpolator.prototype.constructor = R2BoxInterpolator;
    return R2BoxInterpolator;
  }(Interpolator);
  const R2CircleInterpolator = function(_super) {
    const R2CircleInterpolator = function(s0, s1) {
      const interpolator = function(u) {
        const s0 = interpolator[0];
        const s1 = interpolator[1];
        const cx = s0.cx + u * (s1.cx - s0.cx);
        const cy = s0.cy + u * (s1.cy - s0.cy);
        const r = s0.r + u * (s1.r - s0.r);
        return new R2Circle(cx, cy, r);
      };
      Object.setPrototypeOf(interpolator, R2CircleInterpolator.prototype);
      interpolator[0] = s0;
      interpolator[1] = s1;
      return interpolator;
    };
    R2CircleInterpolator.prototype = Object.create(_super.prototype);
    R2CircleInterpolator.prototype.constructor = R2CircleInterpolator;
    return R2CircleInterpolator;
  }(Interpolator);
  class R2Group extends R2Shape {
    constructor(shapes) {
      super();
      this.shapes = shapes;
      this.boundingBox = null;
    }
    isDefined() {
      return this.shapes.length !== 0;
    }
    get xMin() {
      return this.bounds.xMin;
    }
    get yMin() {
      return this.bounds.yMin;
    }
    get xMax() {
      return this.bounds.xMax;
    }
    get yMax() {
      return this.bounds.yMax;
    }
    contains(that, y) {
      return false;
    }
    intersects(that) {
      return false;
    }
    transform(f) {
      const oldShapes = this.shapes;
      const n = oldShapes.length;
      if (n > 0) {
        const newShapes = new Array(n);
        for (let i = 0; i < n; i += 1) {
          newShapes[i] = oldShapes[i].transform(f);
        }
        return new R2Group(newShapes);
      } else {
        return R2Group.empty();
      }
    }
    get bounds() {
      let boundingBox = this.boundingBox;
      if (boundingBox === null) {
        let xMin = Infinity;
        let yMin = Infinity;
        let xMax = -Infinity;
        let yMax = -Infinity;
        const shapes = this.shapes;
        for (let i = 0, n = shapes.length; i < n; i += 1) {
          const shape = shapes[i];
          xMin = Math.min(xMin, shape.xMin);
          yMin = Math.min(yMin, shape.yMin);
          xMax = Math.max(shape.xMax, xMax);
          yMax = Math.max(shape.yMax, yMax);
        }
        boundingBox = new R2Box(xMin, yMin, xMax, yMax);
        this.boundingBox = boundingBox;
      }
      return boundingBox;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof R2Group) {
        return Arrays.equivalent(this.shapes, that.shapes, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof R2Group) {
        return Arrays.equal(this.shapes, that.shapes);
      }
      return false;
    }
    debug(output) {
      const shapes = this.shapes;
      const n = shapes.length;
      output = output.write("R2Group").write(46);
      if (n === 0) {
        output = output.write("empty").write(40);
      } else {
        output = output.write("of").write(40);
        output = output.debug(shapes[0]);
        for (let i = 1; i < n; i += 1) {
          output = output.write(", ").debug(shapes[i]);
        }
      }
      output = output.write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static empty() {
      return new R2Group(Arrays.empty);
    }
    static of(...shapes) {
      return new R2Group(shapes);
    }
  }
  __decorate([ Lazy ], R2Group, "empty", null);
  class Transform {
    translate(x, y) {
      return this.transform(Transform.translate(x, y));
    }
    translateX(x) {
      return this.transform(Transform.translateX(x));
    }
    translateY(y) {
      return this.transform(Transform.translateY(y));
    }
    scale(x, y) {
      return this.transform(Transform.scale(x, y));
    }
    scaleX(x) {
      return this.transform(Transform.scaleX(x));
    }
    scaleY(y) {
      return this.transform(Transform.scaleY(y));
    }
    rotate(a) {
      return this.transform(Transform.rotate(a));
    }
    skew(x, y) {
      return this.transform(Transform.skew(x, y));
    }
    skewX(x) {
      return this.transform(Transform.skewX(x));
    }
    skewY(y) {
      return this.transform(Transform.skewY(y));
    }
    toMatrix() {
      return this.toAffine().toMatrix();
    }
    toCssTransformComponent() {
      return null;
    }
    toCssValue() {
      if (typeof CSSTransformValue !== "undefined") {
        const component = this.toCssTransformComponent();
        if (component !== null) {
          return new CSSTransformValue([ component ]);
        }
      }
      return null;
    }
    interpolateTo(that) {
      if (that instanceof Transform) {
        return AffineTransformInterpolator(this.toAffine(), that.toAffine());
      } else {
        return null;
      }
    }
    toAttributeString() {
      return this.toString();
    }
    static identity() {
      return new IdentityTransform;
    }
    static translate(x, y) {
      x = Length.fromAny(x);
      y = Length.fromAny(y);
      return new TranslateTransform(x, y);
    }
    static translateX(x) {
      x = Length.fromAny(x);
      return new TranslateTransform(x, PxLength.zero());
    }
    static translateY(y) {
      y = Length.fromAny(y);
      return new TranslateTransform(PxLength.zero(), y);
    }
    static scale(x, y) {
      return new ScaleTransform(x, y);
    }
    static scaleX(x) {
      return new ScaleTransform(x, 1);
    }
    static scaleY(y) {
      return new ScaleTransform(1, y);
    }
    static rotate(a) {
      a = Angle.fromAny(a, "deg");
      return new RotateTransform(a);
    }
    static skew(x, y) {
      x = Angle.fromAny(x, "deg");
      y = Angle.fromAny(y, "deg");
      return new SkewTransform(x, y);
    }
    static skewX(x) {
      x = Angle.fromAny(x, "deg");
      return new SkewTransform(x, DegAngle.zero());
    }
    static skewY(y) {
      y = Angle.fromAny(y, "deg");
      return new SkewTransform(DegAngle.zero(), y);
    }
    static affine(x0 = 1, y0 = 0, x1 = 0, y1 = 1, tx = 0, ty = 0) {
      return new AffineTransform(x0, y0, x1, y1, tx, ty);
    }
    static list(...transforms) {
      const list = [];
      for (let i = 0; i < transforms.length; i += 1) {
        const transform = Transform.fromAny(transforms[i]);
        if (transform instanceof TransformList) {
          list.push(...transform.transforms);
        } else if (!(transform instanceof IdentityTransform)) {
          list.push(transform);
        }
      }
      return new TransformList(list);
    }
    static fromCssValue(value) {
      if (value instanceof CSSTransformValue) {
        return Transform.fromCssTransform(value);
      } else {
        throw new TypeError("" + value);
      }
    }
    static fromCssTransform(value) {
      const n = value.length;
      if (n === 1) {
        return Transform.fromCssTransformComponent(value[0]);
      } else {
        const transforms = new Array(n);
        for (let i = 0; i < n; i += 1) {
          transforms[i] = Transform.fromCssTransformComponent(value[i]);
        }
        return new TransformList(transforms);
      }
    }
    static fromCssTransformComponent(component) {
      if (component instanceof CSSTranslate) {
        return TranslateTransform.fromCssTransformComponent(component);
      } else if (component instanceof CSSRotate) {
        return RotateTransform.fromCssTransformComponent(component);
      } else if (component instanceof CSSScale) {
        return ScaleTransform.fromCssTransformComponent(component);
      } else if (component instanceof CSSSkew) {
        return SkewTransform.fromCssTransformComponent(component);
      } else if (component instanceof CSSMatrixComponent) {
        return AffineTransform.fromCssTransformComponent(component);
      } else {
        throw new TypeError("" + component);
      }
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof Transform) {
        return value;
      } else if (typeof value === "string") {
        return Transform.parse(value);
      } else {
        throw new TypeError("" + value);
      }
    }
    static fromValue(value) {
      const tag = value.tag;
      switch (tag) {
       case "identity":
        return IdentityTransform.fromValue(value);

       case "translate":
        return TranslateTransform.fromValue(value);

       case "scale":
        return ScaleTransform.fromValue(value);

       case "rotate":
        return RotateTransform.fromValue(value);

       case "skew":
        return SkewTransform.fromValue(value);

       case "matrix":
        return AffineTransform.fromValue(value);

       default:
        return TransformList.fromValue(value);
      }
    }
    static parse(string) {
      let input = Unicode.stringInput(string);
      while (input.isCont() && Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = TransformListParser.parse(input);
      if (parser.isDone()) {
        while (input.isCont() && Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    static form() {
      return new TransformForm(Transform.identity());
    }
    static isAny(value) {
      return value instanceof Transform || typeof value === "string";
    }
  }
  __decorate([ Lazy ], Transform, "identity", null);
  __decorate([ Lazy ], Transform, "form", null);
  class TransformForm extends Form {
    constructor(unit) {
      super();
      Object.defineProperty(this, "unit", {
        value: unit,
        enumerable: true
      });
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new TransformForm(unit);
      } else {
        return this;
      }
    }
    mold(transform) {
      transform = Transform.fromAny(transform);
      return transform.toValue();
    }
    cast(item) {
      const value = item.toValue();
      try {
        if (value instanceof Record) {
          const transform = Transform.fromValue(value);
          return transform !== null ? transform : void 0;
        } else {
          const string = value.stringValue(void 0);
          if (string !== void 0) {
            return Transform.parse(string);
          }
        }
      } catch (e) {}
      return void 0;
    }
  }
  class TransformParser extends Parser {
    constructor(identOutput) {
      super();
      this.identOutput = identOutput;
    }
    feed(input) {
      return TransformParser.parse(input, this.identOutput);
    }
    static parse(input, identOutput) {
      let c = 0;
      identOutput = identOutput || Unicode.stringOutput();
      while (input.isCont() && (c = input.head(), Unicode.isAlpha(c) || Unicode.isDigit(c) || c === 45)) {
        input = input.step();
        identOutput.write(c);
      }
      if (!input.isEmpty()) {
        const ident = identOutput.bind();
        switch (ident) {
         case "translate3d":
         case "translateX":
         case "translateY":
         case "translate":
          return TranslateTransformParser.parseRest(input, identOutput);

         case "scaleX":
         case "scaleY":
         case "scale":
          return ScaleTransformParser.parseRest(input, identOutput);

         case "rotate":
          return RotateTransformParser.parseRest(input, identOutput);

         case "skewX":
         case "skewY":
         case "skew":
          return SkewTransformParser.parseRest(input, identOutput);

         case "matrix":
          return AffineTransformParser.parseRest(input, identOutput);

         case "none":
          return Parser.done(Transform.identity());

         default:
          return Parser.error(Diagnostic.message("unknown transform function: " + ident, input));
        }
      }
      return new TransformParser(identOutput);
    }
  }
  class IdentityTransform extends Transform {
    transform(x, y) {
      if (arguments.length === 1) {
        return x;
      } else {
        return new R2Point(x, y);
      }
    }
    transformX(x, y) {
      return x;
    }
    transformY(x, y) {
      return y;
    }
    inverse() {
      return this;
    }
    toAffine() {
      return new AffineTransform(1, 0, 0, 1, 0, 0);
    }
    toCssValue() {
      return new CSSKeywordValue("identity");
    }
    toValue() {
      return Record.create(1).attr("identity");
    }
    interpolateTo(that) {
      if (that instanceof IdentityTransform) {
        return IdentityInterpolator(this);
      } else {
        return super.interpolateTo(that);
      }
    }
    conformsTo(that) {
      return that instanceof IdentityTransform;
    }
    equivalentTo(that, epsilon) {
      return that instanceof IdentityTransform;
    }
    equals(that) {
      return that instanceof IdentityTransform;
    }
    hashCode() {
      return Constructors.hash(IdentityTransform);
    }
    debug(output) {
      output = output.write("Transform").write(46).write("identity").write(40).write(41);
      return output;
    }
    toString() {
      return "none";
    }
    static fromValue(value) {
      if (value.tag === "identity") {
        return Transform.identity();
      }
      return null;
    }
  }
  class TranslateTransform extends Transform {
    constructor(x, y) {
      super();
      this.x = x;
      this.y = y;
      this.stringValue = void 0;
    }
    transform(x, y) {
      if (arguments.length === 1) {
        if (x instanceof IdentityTransform) {
          return this;
        } else if (x instanceof TranslateTransform) {
          return new TranslateTransform(this.x.plus(x.x), this.y.plus(x.y));
        } else {
          return Transform.list(this, x);
        }
      } else {
        return new R2Point(this.x.pxValue() + x, this.y.pxValue() + y);
      }
    }
    transformX(x, y) {
      return this.x.pxValue() + x;
    }
    transformY(x, y) {
      return this.y.pxValue() + y;
    }
    inverse() {
      return new TranslateTransform(this.x.negative(), this.y.negative());
    }
    toAffine() {
      return new AffineTransform(1, 0, 0, 1, this.x.pxValue(), this.y.pxValue());
    }
    toCssTransformComponent() {
      if (typeof CSSTranslate !== "undefined") {
        const x = this.x.toCssValue();
        const y = this.y.toCssValue();
        return new CSSTranslate(x, y);
      }
      return null;
    }
    toValue() {
      return Record.create(1).attr("translate", Record.create(2).slot("x", this.x.toValue()).slot("y", this.y.toValue()));
    }
    interpolateTo(that) {
      if (that instanceof TranslateTransform) {
        return TranslateTransformInterpolator(this, that);
      } else {
        return super.interpolateTo(that);
      }
    }
    conformsTo(that) {
      return that instanceof TranslateTransform;
    }
    equivalentTo(that, epsilon) {
      if (that instanceof TranslateTransform) {
        return this.x.equivalentTo(that.x, epsilon) && this.y.equivalentTo(that.y, epsilon);
      }
      return false;
    }
    equals(that) {
      if (that instanceof TranslateTransform) {
        return this.x.equals(that.x) && this.y.equals(that.y);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(TranslateTransform), this.x.hashCode()), this.y.hashCode()));
    }
    debug(output) {
      output = output.write("Transform").write(46).write("translate");
      if (this.x.isDefined() && !this.y.isDefined()) {
        output = output.write("X").write(40).debug(this.x);
      } else if (!this.x.isDefined() && this.y.isDefined()) {
        output = output.write("Y").write(40).debug(this.y);
      } else {
        output = output.write(40).debug(this.x).write(", ").debug(this.y);
      }
      output = output.write(41);
      return output;
    }
    toString() {
      let stringValue = this.stringValue;
      if (stringValue === void 0) {
        if (this.x.isDefined() && !this.y.isDefined()) {
          stringValue = "translate(" + this.x + ",0)";
        } else if (!this.x.isDefined() && this.y.isDefined()) {
          stringValue = "translate(0," + this.y + ")";
        } else {
          stringValue = "translate(" + this.x + "," + this.y + ")";
        }
        this.stringValue = stringValue;
      }
      return stringValue;
    }
    toAttributeString() {
      if (this.x.isDefined() && !this.y.isDefined()) {
        return "translate(" + this.x.pxValue() + ",0)";
      } else if (!this.x.isDefined() && this.y.isDefined()) {
        return "translate(0," + this.y.pxValue() + ")";
      } else {
        return "translate(" + this.x.pxValue() + "," + this.y.pxValue() + ")";
      }
    }
    static fromCssTransformComponent(component) {
      const x = typeof component.x === "number" ? Length.px(component.x) : Length.fromCssValue(component.x);
      const y = typeof component.y === "number" ? Length.px(component.y) : Length.fromCssValue(component.y);
      return new TranslateTransform(x, y);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof TranslateTransform) {
        return value;
      } else if (typeof value === "string") {
        return TranslateTransform.parse(value);
      }
      throw new TypeError("" + value);
    }
    static fromValue(value) {
      const header = value.header("translate");
      if (header.isDefined()) {
        let x = Length.zero();
        let y = Length.zero();
        header.forEach((function(item, index) {
          const key = item.key.stringValue();
          if (key !== void 0) {
            if (key === "x") {
              x = item.toValue().cast(Length.form(), x);
            } else if (key === "y") {
              y = item.toValue().cast(Length.form(), y);
            }
          } else if (item instanceof Value) {
            if (index === 0) {
              x = item.cast(Length.form(), x);
            } else if (index === 1) {
              y = item.cast(Length.form(), y);
            }
          }
        }), this);
        return new TranslateTransform(x, y);
      }
      return null;
    }
    static parse(string) {
      let input = Unicode.stringInput(string);
      while (input.isCont() && Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = TranslateTransformParser.parse(input);
      if (parser.isDone()) {
        while (input.isCont() && Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
  }
  const TranslateTransformInterpolator = function(_super) {
    const TranslateTransformInterpolator = function(f0, f1) {
      const interpolator = function(u) {
        const f0 = interpolator[0];
        const f1 = interpolator[1];
        const x = Length.create(f0.x.value + u * (f1.x.value - f0.x.value), f1.x.units);
        const y = Length.create(f0.y.value + u * (f1.y.value - f0.y.value), f1.y.units);
        return new TranslateTransform(x, y);
      };
      Object.setPrototypeOf(interpolator, TranslateTransformInterpolator.prototype);
      interpolator[0] = f0.x.units === f1.x.units && f0.y.units === f1.y.units ? f0 : new TranslateTransform(f0.x.to(f1.x.units), f0.y.to(f1.y.units));
      interpolator[1] = f1;
      return interpolator;
    };
    TranslateTransformInterpolator.prototype = Object.create(_super.prototype);
    TranslateTransformInterpolator.prototype.constructor = TranslateTransformInterpolator;
    return TranslateTransformInterpolator;
  }(Interpolator);
  class TranslateTransformParser extends Parser {
    constructor(identOutput, xParser, yParser, zParser, step) {
      super();
      this.identOutput = identOutput;
      this.xParser = xParser;
      this.yParser = yParser;
      this.zParser = zParser;
      this.step = step;
    }
    feed(input) {
      return TranslateTransformParser.parse(input, this.identOutput, this.xParser, this.yParser, this.zParser, this.step);
    }
    static parse(input, identOutput, xParser, yParser, zParser, step = 1) {
      let c = 0;
      if (step === 1) {
        identOutput = identOutput || Unicode.stringOutput();
        while (input.isCont() && (c = input.head(), Unicode.isAlpha(c) || Unicode.isDigit(c) || c === 45)) {
          input = input.step();
          identOutput.write(c);
        }
        if (!input.isEmpty()) {
          const ident = identOutput.bind();
          switch (ident) {
           case "translate3d":
           case "translateX":
           case "translateY":
           case "translate":
            step = 2;
            break;

           default:
            return Parser.error(Diagnostic.message("unknown transform function: " + ident, input));
          }
        }
      }
      if (step === 2) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont() && c === 40) {
          input.step();
          step = 3;
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.expected("(", input));
        }
      }
      if (step === 3) {
        if (xParser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input.step();
          }
          if (!input.isEmpty()) {
            xParser = LengthParser.parse(input, "px");
          }
        } else {
          xParser = xParser.feed(input);
        }
        if (xParser !== void 0) {
          if (xParser.isDone()) {
            step = 4;
          } else if (xParser.isError()) {
            return xParser.asError();
          }
        }
      }
      if (step === 4) {
        while (input.isCont() && Unicode.isSpace(input.head())) {
          input.step();
        }
        if (input.isCont()) {
          c = input.head();
          if (c === 41) {
            input.step();
            const ident = identOutput.bind();
            switch (ident) {
             case "translateX":
              return Parser.done(new TranslateTransform(xParser.bind(), PxLength.zero()));

             case "translateY":
              return Parser.done(new TranslateTransform(PxLength.zero(), xParser.bind()));

             default:
              return Parser.error(Diagnostic.message("unknown transform function: " + ident, input));
            }
          } else if (c === 44) {
            input.step();
            step = 5;
          } else {
            return Parser.error(Diagnostic.expected(",", input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      if (step === 5) {
        if (yParser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input.step();
          }
          if (!input.isEmpty()) {
            yParser = LengthParser.parse(input, "px");
          }
        } else {
          yParser = yParser.feed(input);
        }
        if (yParser !== void 0) {
          if (yParser.isDone()) {
            step = 6;
          } else if (yParser.isError()) {
            return yParser.asError();
          }
        }
      }
      if (step === 6) {
        while (input.isCont() && Unicode.isSpace(input.head())) {
          input.step();
        }
        if (input.isCont()) {
          c = input.head();
          if (c === 41) {
            input.step();
            const ident = identOutput.bind();
            switch (ident) {
             case "translate":
              return Parser.done(new TranslateTransform(xParser.bind(), yParser.bind()));

             default:
              return Parser.error(Diagnostic.message("unknown transform function: " + ident, input));
            }
          } else if (c === 44) {
            input.step();
            step = 7;
          } else {
            return Parser.error(Diagnostic.expected(",", input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      if (step === 7) {
        if (zParser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input.step();
          }
          if (!input.isEmpty()) {
            zParser = LengthParser.parse(input, "px");
          }
        } else {
          zParser = zParser.feed(input);
        }
        if (zParser !== void 0) {
          if (zParser.isDone()) {
            step = 8;
          } else if (zParser.isError()) {
            return zParser.asError();
          }
        }
      }
      if (step === 8) {
        while (input.isCont() && Unicode.isSpace(input.head())) {
          input.step();
        }
        if (input.isCont() && input.head() === 41) {
          input.step();
          const ident = identOutput.bind();
          switch (ident) {
           case "translate3d":
            if (zParser.bind().value === 0) {
              return Parser.done(new TranslateTransform(xParser.bind(), yParser.bind()));
            }

           default:
            return Parser.error(Diagnostic.message("unknown transform function: " + ident, input));
          }
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.expected(")", input));
        }
      }
      return new TranslateTransformParser(identOutput, xParser, yParser, zParser, step);
    }
    static parseRest(input, identOutput) {
      return TranslateTransformParser.parse(input, identOutput, void 0, void 0, void 0, 2);
    }
  }
  class ScaleTransform extends Transform {
    constructor(x, y) {
      super();
      this.x = x;
      this.y = y;
      this.stringValue = void 0;
    }
    transform(x, y) {
      if (arguments.length === 1) {
        if (x instanceof IdentityTransform) {
          return this;
        } else {
          return Transform.list(this, x);
        }
      } else {
        return new R2Point(this.x * x, this.y * y);
      }
    }
    transformX(x, y) {
      return this.x * x;
    }
    transformY(x, y) {
      return this.y * y;
    }
    inverse() {
      return new ScaleTransform(1 / (this.x || 1), 1 / (this.y || 1));
    }
    toAffine() {
      return new AffineTransform(this.x, 0, 0, this.y, 0, 0);
    }
    toCssTransformComponent() {
      if (typeof CSSTranslate !== "undefined") {
        return new CSSScale(this.x, this.y);
      }
      return null;
    }
    toValue() {
      return Record.create(1).attr("scale", Record.create(2).slot("x", this.x).slot("y", this.y));
    }
    interpolateTo(that) {
      if (that instanceof ScaleTransform) {
        return ScaleTransformInterpolator(this, that);
      } else {
        return super.interpolateTo(that);
      }
    }
    conformsTo(that) {
      return that instanceof ScaleTransform;
    }
    equivalentTo(that, epsilon) {
      if (that instanceof ScaleTransform) {
        return Numbers.equivalent(this.x, that.x, epsilon) && Numbers.equivalent(this.y, that.y, epsilon);
      }
      return false;
    }
    equals(that) {
      if (that instanceof ScaleTransform) {
        return this.x === that.x && this.y === that.y;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(ScaleTransform), Numbers.hash(this.x)), Numbers.hash(this.y)));
    }
    debug(output) {
      output = output.write("Transform").write(46).write("scale");
      if (this.x !== 0 && this.y === 0) {
        output = output.write("X").write(40).debug(this.x);
      } else if (this.x === 0 && this.y !== 0) {
        output = output.write("Y").write(40).debug(this.y);
      } else {
        output = output.write(40).debug(this.x).write(", ").debug(this.y);
      }
      output = output.write(41);
      return output;
    }
    toString() {
      let stringValue = this.stringValue;
      if (stringValue === void 0) {
        if (this.x !== 0 && this.y === 0) {
          stringValue = "scaleX(" + this.x + ")";
        } else if (this.x === 0 && this.y !== 0) {
          stringValue = "scaleY(" + this.y + ")";
        } else {
          stringValue = "scale(" + this.x + "," + this.y + ")";
        }
        this.stringValue = stringValue;
      }
      return stringValue;
    }
    static fromCssTransformComponent(component) {
      const x = typeof component.x === "number" ? component.x : component.x.to("number").value;
      const y = typeof component.y === "number" ? component.y : component.y.to("number").value;
      return new ScaleTransform(x, y);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof ScaleTransform) {
        return value;
      } else if (typeof value === "string") {
        return ScaleTransform.parse(value);
      }
      throw new TypeError("" + value);
    }
    static fromValue(value) {
      const header = value.header("scale");
      if (header.isDefined()) {
        let x = 0;
        let y = 0;
        header.forEach((function(item, index) {
          const key = item.key.stringValue();
          if (key !== void 0) {
            if (key === "x") {
              x = item.toValue().numberValue(x);
            } else if (key === "y") {
              y = item.toValue().numberValue(y);
            }
          } else if (item instanceof Value) {
            if (index === 0) {
              x = item.numberValue(x);
            } else if (index === 1) {
              y = item.numberValue(y);
            }
          }
        }), this);
        return new ScaleTransform(x, y);
      }
      return null;
    }
    static parse(string) {
      let input = Unicode.stringInput(string);
      while (input.isCont() && Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = ScaleTransformParser.parse(input);
      if (parser.isDone()) {
        while (input.isCont() && Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
  }
  const ScaleTransformInterpolator = function(_super) {
    const ScaleTransformInterpolator = function(f0, f1) {
      const interpolator = function(u) {
        const f0 = interpolator[0];
        const f1 = interpolator[1];
        const x = f0.x + u * (f1.x - f0.x);
        const y = f0.y + u * (f1.y - f0.y);
        return new ScaleTransform(x, y);
      };
      Object.setPrototypeOf(interpolator, ScaleTransformInterpolator.prototype);
      interpolator[0] = f0;
      interpolator[1] = f1;
      return interpolator;
    };
    ScaleTransformInterpolator.prototype = Object.create(_super.prototype);
    ScaleTransformInterpolator.prototype.constructor = Interpolator;
    return ScaleTransformInterpolator;
  }(Interpolator);
  class ScaleTransformParser extends Parser {
    constructor(identOutput, xParser, yParser, step) {
      super();
      this.identOutput = identOutput;
      this.xParser = xParser;
      this.yParser = yParser;
      this.step = step;
    }
    feed(input) {
      return ScaleTransformParser.parse(input, this.identOutput, this.xParser, this.yParser, this.step);
    }
    static parse(input, identOutput, xParser, yParser, step = 1) {
      let c = 0;
      if (step === 1) {
        identOutput = identOutput || Unicode.stringOutput();
        while (input.isCont() && (c = input.head(), Unicode.isAlpha(c))) {
          input = input.step();
          identOutput.write(c);
        }
        if (!input.isEmpty()) {
          const ident = identOutput.bind();
          switch (ident) {
           case "scaleX":
           case "scaleY":
           case "scale":
            step = 2;
            break;

           default:
            return Parser.error(Diagnostic.message("unknown transform function: " + ident, input));
          }
        }
      }
      if (step === 2) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont() && c === 40) {
          input.step();
          step = 3;
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.expected("(", input));
        }
      }
      if (step === 3) {
        if (xParser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input.step();
          }
          if (!input.isEmpty()) {
            xParser = Base10.parseNumber(input);
          }
        } else {
          xParser = xParser.feed(input);
        }
        if (xParser !== void 0) {
          if (xParser.isDone()) {
            step = 4;
          } else if (xParser.isError()) {
            return xParser.asError();
          }
        }
      }
      if (step === 4) {
        while (input.isCont() && Unicode.isSpace(input.head())) {
          input.step();
        }
        if (input.isCont()) {
          c = input.head();
          if (c === 41) {
            input.step();
            const ident = identOutput.bind();
            switch (ident) {
             case "scaleX":
              return Parser.done(new ScaleTransform(xParser.bind(), 1));

             case "scaleY":
              return Parser.done(new ScaleTransform(1, xParser.bind()));

             default:
              return Parser.error(Diagnostic.message("unknown transform function: " + ident, input));
            }
          } else if (c === 44) {
            input.step();
            step = 5;
          } else {
            return Parser.error(Diagnostic.expected(",", input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      if (step === 5) {
        if (yParser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input.step();
          }
          if (!input.isEmpty()) {
            yParser = Base10.parseNumber(input);
          }
        } else {
          yParser = yParser.feed(input);
        }
        if (yParser !== void 0) {
          if (yParser.isDone()) {
            step = 6;
          } else if (yParser.isError()) {
            return yParser.asError();
          }
        }
      }
      if (step === 6) {
        while (input.isCont() && Unicode.isSpace(input.head())) {
          input.step();
        }
        if (input.isCont() && input.head() === 41) {
          input.step();
          const ident = identOutput.bind();
          switch (ident) {
           case "scale":
            return Parser.done(new ScaleTransform(xParser.bind(), yParser.bind()));

           default:
            return Parser.error(Diagnostic.message("unknown transform function: " + ident, input));
          }
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.expected(")", input));
        }
      }
      return new ScaleTransformParser(identOutput, xParser, yParser, step);
    }
    static parseRest(input, identOutput) {
      return ScaleTransformParser.parse(input, identOutput, void 0, void 0, 2);
    }
  }
  class RotateTransform extends Transform {
    constructor(angle) {
      super();
      this.angle = angle;
      this.stringValue = void 0;
    }
    transform(x, y) {
      if (arguments.length === 1) {
        if (x instanceof IdentityTransform) {
          return this;
        } else {
          return Transform.list(this, x);
        }
      } else {
        const angle = this.angle.radValue();
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);
        return new R2Point(x * cosA - y * sinA, x * sinA + y * cosA);
      }
    }
    transformX(x, y) {
      const angle = this.angle.radValue();
      return x * Math.cos(angle) - y * Math.sin(angle);
    }
    transformY(x, y) {
      const angle = this.angle.radValue();
      return x * Math.sin(angle) + y * Math.cos(angle);
    }
    inverse() {
      return new RotateTransform(this.angle.negative());
    }
    toAffine() {
      const angle = this.angle.radValue();
      return new AffineTransform(Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0, 0);
    }
    toCssTransformComponent() {
      if (typeof CSSTranslate !== "undefined") {
        const angle = this.angle.toCssValue();
        return new CSSRotate(angle);
      }
      return null;
    }
    toValue() {
      return Record.create(1).attr("rotate", this.angle.toString());
    }
    interpolateTo(that) {
      if (that instanceof RotateTransform) {
        return RotateTransformInterpolator(this, that);
      } else {
        return super.interpolateTo(that);
      }
    }
    conformsTo(that) {
      return that instanceof RotateTransform;
    }
    equivalentTo(that, epsilon) {
      if (that instanceof RotateTransform) {
        return this.angle.equivalentTo(that.angle, epsilon);
      }
      return false;
    }
    equals(that) {
      if (that instanceof RotateTransform) {
        return this.angle.equals(that.angle);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(RotateTransform), this.angle.hashCode()));
    }
    debug(output) {
      output = output.write("Transform").write(46).write("rotate").write(40).debug(this.angle).write(41);
      return output;
    }
    toString() {
      let stringValue = this.stringValue;
      if (stringValue === void 0) {
        stringValue = "rotate(" + this.angle + ")";
        this.stringValue = stringValue;
      }
      return stringValue;
    }
    toAttributeString() {
      return "rotate(" + this.angle.degValue() + ")";
    }
    static fromCssTransformComponent(component) {
      const angle = Angle.fromCssValue(component.angle);
      return new RotateTransform(angle);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof RotateTransform) {
        return value;
      } else if (typeof value === "string") {
        return RotateTransform.parse(value);
      }
      throw new TypeError("" + value);
    }
    static fromValue(value) {
      const header = value.header("rotate");
      if (header.isDefined()) {
        let angle = Angle.zero();
        header.forEach((function(item, index) {
          const key = item.key.stringValue();
          if (key === "angle") {
            angle = item.toValue().cast(Angle.form(), angle);
          } else if (item instanceof Value && index === 0) {
            angle = item.cast(Angle.form(), angle);
          }
        }), this);
        return new RotateTransform(angle);
      }
      return null;
    }
    static parse(string) {
      let input = Unicode.stringInput(string);
      while (input.isCont() && Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = RotateTransformParser.parse(input);
      if (parser.isDone()) {
        while (input.isCont() && Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
  }
  const RotateTransformInterpolator = function(_super) {
    const RotateTransformInterpolator = function(f0, f1) {
      const interpolator = function(u) {
        const f0 = interpolator[0];
        const f1 = interpolator[1];
        const a = Angle.create(f0.angle.value + u * (f1.angle.value - f0.angle.value), f1.angle.units);
        return new RotateTransform(a);
      };
      Object.setPrototypeOf(interpolator, RotateTransformInterpolator.prototype);
      interpolator[0] = f0.angle.units === f1.angle.units ? f0 : new RotateTransform(f0.angle.to(f1.angle.units));
      interpolator[1] = f1;
      return interpolator;
    };
    RotateTransformInterpolator.prototype = Object.create(_super.prototype);
    RotateTransformInterpolator.prototype.constructor = RotateTransformInterpolator;
    return RotateTransformInterpolator;
  }(Interpolator);
  class RotateTransformParser extends Parser {
    constructor(identOutput, angleParser, step) {
      super();
      this.identOutput = identOutput;
      this.angleParser = angleParser;
      this.step = step;
    }
    feed(input) {
      return RotateTransformParser.parse(input, this.identOutput, this.angleParser, this.step);
    }
    static parse(input, identOutput, angleParser, step = 1) {
      let c = 0;
      if (step === 1) {
        identOutput = identOutput || Unicode.stringOutput();
        while (input.isCont() && (c = input.head(), Unicode.isAlpha(c))) {
          input = input.step();
          identOutput.write(c);
        }
        if (!input.isEmpty()) {
          const ident = identOutput.bind();
          switch (ident) {
           case "rotate":
            step = 2;
            break;

           default:
            return Parser.error(Diagnostic.message("unknown transform function: " + ident, input));
          }
        }
      }
      if (step === 2) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont() && c === 40) {
          input.step();
          step = 3;
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.expected("(", input));
        }
      }
      if (step === 3) {
        if (angleParser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input.step();
          }
          if (!input.isEmpty()) {
            angleParser = AngleParser.parse(input, "deg");
          }
        } else {
          angleParser = angleParser.feed(input);
        }
        if (angleParser !== void 0) {
          if (angleParser.isDone()) {
            step = 4;
          } else if (angleParser.isError()) {
            return angleParser.asError();
          }
        }
      }
      if (step === 4) {
        while (input.isCont() && Unicode.isSpace(input.head())) {
          input.step();
        }
        if (input.isCont() && input.head() === 41) {
          input.step();
          const ident = identOutput.bind();
          switch (ident) {
           case "rotate":
            return Parser.done(new RotateTransform(angleParser.bind()));

           default:
            return Parser.error(Diagnostic.message("unknown transform function: " + ident, input));
          }
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.expected(")", input));
        }
      }
      return new RotateTransformParser(identOutput, angleParser, step);
    }
    static parseRest(input, identOutput) {
      return RotateTransformParser.parse(input, identOutput, void 0, 2);
    }
  }
  class SkewTransform extends Transform {
    constructor(x, y) {
      super();
      this.x = x;
      this.y = y;
      this.stringValue = void 0;
    }
    transform(x, y) {
      if (arguments.length === 1) {
        if (x instanceof IdentityTransform) {
          return this;
        } else {
          return Transform.list(this, x);
        }
      } else {
        return new R2Point(Math.tan(this.x.radValue()) * y + x, Math.tan(this.y.radValue()) * x + y);
      }
    }
    transformX(x, y) {
      return Math.tan(this.x.radValue()) * y + x;
    }
    transformY(x, y) {
      return Math.tan(this.y.radValue()) * x + y;
    }
    inverse() {
      return new SkewTransform(this.x.negative(), this.y.negative());
    }
    toAffine() {
      const x = this.x.radValue();
      const y = this.y.radValue();
      return new AffineTransform(1, Math.tan(y), Math.tan(x), 1, 0, 0);
    }
    toCssTransformComponent() {
      if (typeof CSSTranslate !== "undefined") {
        const x = this.x.toCssValue();
        const y = this.y.toCssValue();
        return new CSSSkew(x, y);
      }
      return null;
    }
    toValue() {
      return Record.create(1).attr("skew", Record.create(2).slot("x", this.x.toValue()).slot("y", this.y.toValue()));
    }
    interpolateTo(that) {
      if (that instanceof SkewTransform) {
        return SkewTransformInterpolator(this, that);
      } else {
        return super.interpolateTo(that);
      }
    }
    conformsTo(that) {
      return that instanceof SkewTransform;
    }
    equivalentTo(that, epsilon) {
      if (that instanceof SkewTransform) {
        return this.x.equivalentTo(that.x, epsilon) && this.y.equivalentTo(that.y, epsilon);
      }
      return false;
    }
    equals(that) {
      if (that instanceof SkewTransform) {
        return this.x.equals(that.x) && this.y.equals(that.y);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(SkewTransform), this.x.hashCode()), this.y.hashCode()));
    }
    debug(output) {
      output = output.write("Transform").write(46).write("skew");
      if (this.x.isDefined() && !this.y.isDefined()) {
        output = output.write("X").write(40).debug(this.x);
      } else if (!this.x.isDefined() && this.y.isDefined()) {
        output = output.write("Y").write(40).debug(this.y);
      } else {
        output = output.write(40).debug(this.x).write(", ").debug(this.y);
      }
      output = output.write(41);
      return output;
    }
    toString() {
      let stringValue = this.stringValue;
      if (stringValue === void 0) {
        if (this.x.isDefined() && !this.y.isDefined()) {
          stringValue = "skewX(" + this.x + ")";
        } else if (!this.x.isDefined() && this.y.isDefined()) {
          stringValue = "skewY(" + this.y + ")";
        } else {
          stringValue = "skew(" + this.x + "," + this.y + ")";
        }
        this.stringValue = stringValue;
      }
      return stringValue;
    }
    toAttributeString() {
      if (this.x.isDefined() && !this.y.isDefined()) {
        return "skewX(" + this.x.degValue() + ")";
      } else if (!this.x.isDefined() && this.y.isDefined()) {
        return "skewY(" + this.y.degValue() + ")";
      } else {
        return "skew(" + this.x.degValue() + "," + this.y.degValue() + ")";
      }
    }
    static fromCssTransformComponent(component) {
      const x = typeof component.ax === "number" ? Angle.rad(component.ax) : Angle.fromCssValue(component.ax);
      const y = typeof component.ay === "number" ? Angle.rad(component.ay) : Angle.fromCssValue(component.ay);
      return new SkewTransform(x, y);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof SkewTransform) {
        return value;
      } else if (typeof value === "string") {
        return SkewTransform.parse(value);
      }
      throw new TypeError("" + value);
    }
    static fromValue(value) {
      const header = value.header("skew");
      if (header.isDefined()) {
        let x = Angle.zero();
        let y = Angle.zero();
        header.forEach((function(item, index) {
          const key = item.key.stringValue();
          if (key !== void 0) {
            if (key === "x") {
              x = item.toValue().cast(Angle.form(), x);
            } else if (key === "y") {
              y = item.toValue().cast(Angle.form(), y);
            }
          } else if (item instanceof Value) {
            if (index === 0) {
              x = item.cast(Angle.form(), x);
            } else if (index === 1) {
              y = item.cast(Angle.form(), y);
            }
          }
        }), this);
        return new SkewTransform(x, y);
      }
      return null;
    }
    static parse(string) {
      let input = Unicode.stringInput(string);
      while (input.isCont() && Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = SkewTransformParser.parse(input);
      if (parser.isDone()) {
        while (input.isCont() && Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
  }
  const SkewTransformInterpolator = function(_super) {
    const SkewTransformInterpolator = function(f0, f1) {
      const interpolator = function(u) {
        const f0 = interpolator[0];
        const f1 = interpolator[1];
        const x = Angle.create(f0.x.value + u * (f1.x.value - f0.x.value), f1.x.units);
        const y = Angle.create(f0.y.value + u * (f1.y.value - f0.y.value), f1.y.units);
        return new SkewTransform(x, y);
      };
      Object.setPrototypeOf(interpolator, SkewTransformInterpolator.prototype);
      interpolator[0] = f0.x.units === f1.x.units && f0.y.units === f1.y.units ? f0 : new SkewTransform(f0.x.to(f1.x.units), f0.y.to(f1.y.units));
      interpolator[1] = f1;
      return interpolator;
    };
    SkewTransformInterpolator.prototype = Object.create(_super.prototype);
    SkewTransformInterpolator.prototype.constructor = SkewTransformInterpolator;
    return SkewTransformInterpolator;
  }(Interpolator);
  class SkewTransformParser extends Parser {
    constructor(identOutput, xParser, yParser, step) {
      super();
      this.identOutput = identOutput;
      this.xParser = xParser;
      this.yParser = yParser;
      this.step = step;
    }
    feed(input) {
      return SkewTransformParser.parse(input, this.identOutput, this.xParser, this.yParser, this.step);
    }
    static parse(input, identOutput, xParser, yParser, step = 1) {
      let c = 0;
      if (step === 1) {
        identOutput = identOutput || Unicode.stringOutput();
        while (input.isCont() && (c = input.head(), Unicode.isAlpha(c))) {
          input = input.step();
          identOutput.write(c);
        }
        if (!input.isEmpty()) {
          const ident = identOutput.bind();
          switch (ident) {
           case "skewX":
           case "skewY":
           case "skew":
            step = 2;
            break;

           default:
            return Parser.error(Diagnostic.message("unknown transform function: " + ident, input));
          }
        }
      }
      if (step === 2) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont() && c === 40) {
          input.step();
          step = 3;
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.expected("(", input));
        }
      }
      if (step === 3) {
        if (xParser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input.step();
          }
          if (!input.isEmpty()) {
            xParser = AngleParser.parse(input, "deg");
          }
        } else {
          xParser = xParser.feed(input);
        }
        if (xParser !== void 0) {
          if (xParser.isDone()) {
            step = 4;
          } else if (xParser.isError()) {
            return xParser.asError();
          }
        }
      }
      if (step === 4) {
        while (input.isCont() && Unicode.isSpace(input.head())) {
          input.step();
        }
        if (input.isCont()) {
          c = input.head();
          if (c === 41) {
            input.step();
            const ident = identOutput.bind();
            switch (ident) {
             case "skewX":
              return Parser.done(new SkewTransform(xParser.bind(), DegAngle.zero()));

             case "skewY":
              return Parser.done(new SkewTransform(DegAngle.zero(), xParser.bind()));

             default:
              return Parser.error(Diagnostic.message("unknown transform function: " + ident, input));
            }
          } else if (c === 44) {
            input.step();
            step = 5;
          } else {
            return Parser.error(Diagnostic.expected(",", input));
          }
        } else if (input.isDone()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
      }
      if (step === 5) {
        if (yParser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input.step();
          }
          if (!input.isEmpty()) {
            yParser = AngleParser.parse(input, "deg");
          }
        } else {
          yParser = yParser.feed(input);
        }
        if (yParser !== void 0) {
          if (yParser.isDone()) {
            step = 6;
          } else if (yParser.isError()) {
            return yParser.asError();
          }
        }
      }
      if (step === 6) {
        while (input.isCont() && Unicode.isSpace(input.head())) {
          input.step();
        }
        if (input.isCont() && input.head() === 41) {
          input.step();
          const ident = identOutput.bind();
          switch (ident) {
           case "skew":
            return Parser.done(new SkewTransform(xParser.bind(), yParser.bind()));

           default:
            return Parser.error(Diagnostic.message("unknown transform function: " + ident, input));
          }
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.expected(")", input));
        }
      }
      return new SkewTransformParser(identOutput, xParser, yParser, step);
    }
    static parseRest(input, identOutput) {
      return SkewTransformParser.parse(input, identOutput, void 0, void 0, 2);
    }
  }
  class AffineTransform extends Transform {
    constructor(x0, y0, x1, y1, tx, ty) {
      super();
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
      this.tx = tx;
      this.ty = ty;
      this.stringValue = void 0;
    }
    transform(x, y) {
      if (arguments.length === 1) {
        if (x instanceof IdentityTransform) {
          return this;
        } else {
          return this.multiply(x.toAffine());
        }
      } else {
        return new R2Point(this.x0 * x + this.x1 * y + this.tx, this.y0 * x + this.y1 * y + this.ty);
      }
    }
    transformX(x, y) {
      return this.x0 * x + this.x1 * y + this.tx;
    }
    transformY(x, y) {
      return this.y0 * x + this.y1 * y + this.ty;
    }
    inverse() {
      const m00 = this.x0;
      const m10 = this.y0;
      const m01 = this.x1;
      const m11 = this.y1;
      const m02 = this.tx;
      const m12 = this.ty;
      const det = m00 * m11 - m01 * m10;
      if (Math.abs(det) >= Number.MIN_VALUE) {
        return new AffineTransform(m11 / det, -m10 / det, -m01 / det, m00 / det, (m01 * m12 - m11 * m02) / det, (m10 * m02 - m00 * m12) / det);
      } else {
        throw new Error("non-invertible affine transform with determinant " + det);
      }
    }
    multiply(that) {
      const x0 = this.x0 * that.x0 + this.x1 * that.y0;
      const y0 = this.y0 * that.x0 + this.y1 * that.y0;
      const x1 = this.x0 * that.x1 + this.x1 * that.y1;
      const y1 = this.y0 * that.x1 + this.y1 * that.y1;
      const tx = this.x0 * that.tx + this.x1 * that.ty;
      const ty = this.y0 * that.tx + this.y1 * that.ty;
      return new AffineTransform(x0, y0, x1, y1, tx, ty);
    }
    toAffine() {
      return this;
    }
    toMatrix() {
      return new DOMMatrix([ this.x0, this.y0, this.x1, this.y1, this.tx, this.ty ]);
    }
    toCssTransformComponent() {
      if (typeof CSSTranslate !== "undefined") {
        return new CSSMatrixComponent(this.toMatrix());
      }
      return null;
    }
    toValue() {
      return Record.create(1).attr("matrix", Record.create(6).item(this.x0).item(this.y0).item(this.x1).item(this.y1).item(this.tx).item(this.ty));
    }
    interpolateTo(that) {
      if (that instanceof AffineTransform) {
        return AffineTransformInterpolator(this, that);
      } else {
        return super.interpolateTo(that);
      }
    }
    conformsTo(that) {
      return that instanceof AffineTransform;
    }
    equivalentTo(that, epsilon) {
      if (that instanceof AffineTransform) {
        return Numbers.equivalent(this.x0, that.x0, epsilon) && Numbers.equivalent(this.y0, that.y0, epsilon) && Numbers.equivalent(this.x1, that.x1, epsilon) && Numbers.equivalent(this.y1, that.y1, epsilon) && Numbers.equivalent(this.tx, that.tx, epsilon) && Numbers.equivalent(this.ty, that.ty, epsilon);
      }
      return false;
    }
    equals(that) {
      if (that instanceof AffineTransform) {
        return this.x0 === that.x0 && this.y0 === that.y0 && this.x1 === that.x1 && this.y1 === that.y1 && this.tx === that.tx && this.ty === that.ty;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(Constructors.hash(AffineTransform), Numbers.hash(this.x0)), Numbers.hash(this.y0)), Numbers.hash(this.x1)), Numbers.hash(this.y1)), Numbers.hash(this.tx)), Numbers.hash(this.ty)));
    }
    debug(output) {
      output = output.write("Transform").write(46).write("affine").write(40).debug(this.x0).write(", ").debug(this.y0).write(", ").debug(this.x1).write(", ").debug(this.y1).write(", ").debug(this.tx).write(", ").debug(this.ty).write(41);
      return output;
    }
    toString() {
      let stringValue = this.stringValue;
      if (stringValue === void 0) {
        stringValue = "matrix(" + this.x0 + "," + this.y0 + "," + this.x1 + "," + this.y1 + "," + this.tx + "," + this.ty + ")";
        this.stringValue = stringValue;
      }
      return stringValue;
    }
    static identity() {
      return new AffineTransform(1, 0, 0, 1, 0, 0);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof AffineTransform) {
        return value;
      } else if (typeof value === "string") {
        return AffineTransform.parse(value);
      }
      throw new TypeError("" + value);
    }
    static fromMatrix(matrix) {
      return new AffineTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
    }
    static fromCssTransformComponent(component) {
      return AffineTransform.fromMatrix(component.matrix);
    }
    static fromValue(value) {
      const header = value.header("matrix");
      if (header.isDefined()) {
        let x0 = 0;
        let y0 = 0;
        let x1 = 0;
        let y1 = 0;
        let tx = 0;
        let ty = 0;
        header.forEach((function(item, index) {
          const key = item.key.stringValue();
          if (key !== void 0) {
            if (key === "x0") {
              x0 = item.toValue().numberValue(x0);
            } else if (key === "y0") {
              y0 = item.toValue().numberValue(y0);
            } else if (key === "x1") {
              x1 = item.toValue().numberValue(x1);
            } else if (key === "y1") {
              y1 = item.toValue().numberValue(y1);
            } else if (key === "tx") {
              tx = item.toValue().numberValue(tx);
            } else if (key === "ty") {
              ty = item.toValue().numberValue(ty);
            }
          } else if (item instanceof Value) {
            switch (index) {
             case 0:
              x0 = item.numberValue(x0);
              break;

             case 1:
              y0 = item.numberValue(y0);
              break;

             case 2:
              x1 = item.numberValue(x1);
              break;

             case 3:
              y1 = item.numberValue(y1);
              break;

             case 4:
              tx = item.numberValue(tx);
              break;

             case 5:
              ty = item.numberValue(ty);
              break;
            }
          }
        }), this);
        return new AffineTransform(x0, y0, x1, y1, tx, ty);
      }
      return null;
    }
    static parse(string) {
      let input = Unicode.stringInput(string);
      while (input.isCont() && Unicode.isWhitespace(input.head())) {
        input = input.step();
      }
      let parser = AffineTransformParser.parse(input);
      if (parser.isDone()) {
        while (input.isCont() && Unicode.isWhitespace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
  }
  __decorate([ Lazy ], AffineTransform, "identity", null);
  const AffineTransformInterpolator = function(_super) {
    const AffineTransformInterpolator = function(f0, f1) {
      const interpolator = function(u) {
        const f0 = interpolator[0];
        const f1 = interpolator[1];
        const x0 = f0.x0 + u * (f1.x0 - f0.x0);
        const y0 = f0.y0 + u * (f1.y0 - f0.y0);
        const x1 = f0.x1 + u * (f1.x1 - f0.x1);
        const y1 = f0.y1 + u * (f1.y1 - f0.y1);
        const tx = f0.tx + u * (f1.tx - f0.tx);
        const ty = f0.ty + u * (f1.ty - f0.ty);
        return new AffineTransform(x0, y0, x1, y1, tx, ty);
      };
      Object.setPrototypeOf(interpolator, AffineTransformInterpolator.prototype);
      interpolator[0] = f0;
      interpolator[1] = f1;
      return interpolator;
    };
    AffineTransformInterpolator.prototype = Object.create(_super.prototype);
    AffineTransformInterpolator.prototype.constructor = AffineTransformInterpolator;
    return AffineTransformInterpolator;
  }(Interpolator);
  class AffineTransformParser extends Parser {
    constructor(identOutput, entries, entryParser, step) {
      super();
      this.identOutput = identOutput;
      this.entries = entries;
      this.entryParser = entryParser;
      this.step = step;
    }
    feed(input) {
      return AffineTransformParser.parse(input, this.identOutput, this.entries, this.entryParser, this.step);
    }
    static parse(input, identOutput, entries = [], entryParser, step = 1) {
      let c = 0;
      if (step === 1) {
        identOutput = identOutput || Unicode.stringOutput();
        while (input.isCont() && (c = input.head(), Unicode.isAlpha(c))) {
          input = input.step();
          identOutput.write(c);
        }
        if (!input.isEmpty()) {
          const ident = identOutput.bind();
          switch (ident) {
           case "matrix":
            step = 2;
            break;

           default:
            return Parser.error(Diagnostic.message("unknown transform function: " + ident, input));
          }
        }
      }
      if (step === 2) {
        while (input.isCont() && (c = input.head(), Unicode.isSpace(c))) {
          input = input.step();
        }
        if (input.isCont() && c === 40) {
          input.step();
          step = 3;
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.expected("(", input));
        }
      }
      do {
        if (step === 3) {
          if (entryParser === void 0) {
            while (input.isCont() && Unicode.isSpace(input.head())) {
              input.step();
            }
            if (!input.isEmpty()) {
              entryParser = Base10.parseNumber(input);
            }
          } else {
            entryParser = entryParser.feed(input);
          }
          if (entryParser !== void 0) {
            if (entryParser.isDone()) {
              entries.push(entryParser.bind());
              entryParser = void 0;
              step = 4;
            } else if (entryParser.isError()) {
              return entryParser.asError();
            }
          }
        }
        if (step === 4) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input.step();
          }
          if (input.isCont()) {
            c = input.head();
            if (c === 41) {
              input.step();
              const ident = identOutput.bind();
              switch (ident) {
               case "matrix":
                return Parser.done(Transform.affine(...entries));

               default:
                return Parser.error(Diagnostic.message("unknown transform function: " + ident, input));
              }
            } else if (entries.length >= 6) {
              return Parser.error(Diagnostic.expected(")", input));
            } else if (c === 44) {
              input.step();
              step = 3;
              continue;
            } else {
              return Parser.error(Diagnostic.expected(",", input));
            }
          } else if (input.isDone()) {
            return Parser.error(Diagnostic.unexpected(input));
          }
        }
        break;
      } while (true);
      return new AffineTransformParser(identOutput, entries, entryParser, step);
    }
    static parseRest(input, identOutput) {
      return AffineTransformParser.parse(input, identOutput, void 0, void 0, 2);
    }
  }
  class TransformList extends Transform {
    constructor(transforms) {
      super();
      this.transforms = transforms;
      this.stringValue = void 0;
    }
    transform(x, y) {
      if (arguments.length === 1) {
        if (x instanceof IdentityTransform) {
          return this;
        } else {
          return Transform.list(this, x);
        }
      } else {
        const transforms = this.transforms;
        for (let i = 0, n = transforms.length; i < n; i += 1) {
          const transform = transforms[i];
          const xi = transform.transformX(x, y);
          const yi = transform.transformY(x, y);
          x = xi;
          y = yi;
        }
        return new R2Point(x, y);
      }
    }
    transformX(x, y) {
      const transforms = this.transforms;
      for (let i = 0, n = transforms.length; i < n; i += 1) {
        const transform = transforms[i];
        const xi = transform.transformX(x, y);
        const yi = transform.transformY(x, y);
        x = xi;
        y = yi;
      }
      return x;
    }
    transformY(x, y) {
      const transforms = this.transforms;
      for (let i = 0, n = transforms.length; i < n; i += 1) {
        const transform = transforms[i];
        const xi = transform.transformX(x, y);
        const yi = transform.transformY(x, y);
        x = xi;
        y = yi;
      }
      return y;
    }
    inverse() {
      const transforms = this.transforms;
      const n = transforms.length;
      const inverseTransforms = new Array(n);
      for (let i = 0; i < n; i += 1) {
        inverseTransforms[i] = transforms[n - i - 1].inverse();
      }
      return new TransformList(inverseTransforms);
    }
    toAffine() {
      let matrix = AffineTransform.identity();
      const transforms = this.transforms;
      for (let i = 0, n = transforms.length; i < n; i += 1) {
        matrix = matrix.multiply(transforms[i].toAffine());
      }
      return matrix;
    }
    toCssTransformComponent() {
      if (typeof CSSTranslate !== "undefined") {
        return new CSSMatrixComponent(this.toMatrix());
      }
      return null;
    }
    toCssValue() {
      if (typeof CSSTransformValue !== "undefined") {
        const transforms = this.transforms;
        const n = transforms.length;
        const components = new Array(n);
        for (let i = 0, n = transforms.length; i < n; i += 1) {
          const transform = transforms[i];
          const component = transform.toCssTransformComponent();
          if (component !== null) {
            components[i] = component;
          } else {
            return null;
          }
        }
        return new CSSTransformValue(components);
      }
      return null;
    }
    toValue() {
      const transforms = this.transforms;
      const n = transforms.length;
      const record = Record.create(n);
      for (let i = 0; i < n; i += 1) {
        record.push(transforms[i].toValue());
      }
      return record;
    }
    interpolateTo(that) {
      if (that instanceof TransformList) {
        return TransformListInterpolator(this, that);
      } else {
        return super.interpolateTo(that);
      }
    }
    conformsTo(that) {
      if (that instanceof TransformList) {
        const n = this.transforms.length;
        if (n === that.transforms.length) {
          for (let i = 0; i < n; i += 1) {
            if (!this.transforms[i].conformsTo(that.transforms[i])) {
              return false;
            }
          }
          return true;
        }
      }
      return false;
    }
    equivalentTo(that, epsilon) {
      if (that instanceof TransformList) {
        const n = this.transforms.length;
        if (n === that.transforms.length) {
          for (let i = 0; i < n; i += 1) {
            if (!this.transforms[i].equivalentTo(that.transforms[i], epsilon)) {
              return false;
            }
          }
          return true;
        }
      }
      return false;
    }
    equals(that) {
      if (that instanceof TransformList) {
        const n = this.transforms.length;
        if (n === that.transforms.length) {
          for (let i = 0; i < n; i += 1) {
            if (!this.transforms[i].equals(that.transforms[i])) {
              return false;
            }
          }
          return true;
        }
      }
      return false;
    }
    hashCode() {
      let hashValue = Constructors.hash(TransformList);
      const transforms = this.transforms;
      for (let i = 0, n = transforms.length; i < n; i += 1) {
        hashValue = Murmur3.mix(hashValue, transforms[i].hashCode());
      }
      return Murmur3.mash(hashValue);
    }
    debug(output) {
      output = output.write("Transform").write(46).write("list").write(40);
      const transforms = this.transforms;
      const n = transforms.length;
      if (n > 0) {
        output = output.debug(transforms[0]);
        for (let i = 1; i < n; i += 1) {
          output = output.write(", ").debug(transforms[i]);
        }
      }
      output = output.write(41);
      return output;
    }
    toString() {
      let stringValue = this.stringValue;
      if (stringValue === void 0) {
        const transforms = this.transforms;
        const n = transforms.length;
        if (n > 0) {
          stringValue = transforms[0].toString();
          for (let i = 1; i < n; i += 1) {
            stringValue += " ";
            stringValue += transforms[i].toString();
          }
        } else {
          stringValue = "none";
        }
        this.stringValue = stringValue;
      }
      return stringValue;
    }
    toAttributeString() {
      const transforms = this.transforms;
      const n = transforms.length;
      if (n > 0) {
        let s = transforms[0].toAttributeString();
        for (let i = 1; i < n; i += 1) {
          s += " ";
          s += transforms[i].toAttributeString();
        }
        return s;
      } else {
        return "";
      }
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof TransformList) {
        return value;
      } else if (typeof value === "string") {
        return TransformList.parse(value);
      }
      throw new TypeError("" + value);
    }
    static fromValue(value) {
      const transforms = [];
      value.forEach((function(item) {
        const transform = Transform.fromValue(item.toValue());
        if (transform !== null) {
          transforms.push(transform);
        }
      }), this);
      if (transforms.length !== 0) {
        return new TransformList(transforms);
      }
      return null;
    }
    static parse(string) {
      const transform = Transform.parse(string);
      if (transform instanceof TransformList) {
        return transform;
      } else {
        return new TransformList([ transform ]);
      }
    }
  }
  const TransformListInterpolator = function(_super) {
    const TransformListInterpolator = function(f0, f1) {
      const interpolator = function(u) {
        const interpolators = interpolator.interpolators;
        const interpolatorCount = interpolators.length;
        const transforms = new Array(interpolatorCount);
        for (let i = 0; i < interpolatorCount; i += 1) {
          transforms[i] = interpolators[i](u);
        }
        return new TransformList(transforms);
      };
      Object.setPrototypeOf(interpolator, TransformListInterpolator.prototype);
      const transforms0 = f0.transforms;
      const transforms1 = f1.transforms;
      const interpolatorCount = Math.min(transforms0.length, transforms1.length);
      const interpolators = new Array(interpolatorCount);
      for (let i = 0; i < interpolatorCount; i += 1) {
        interpolators[i] = transforms0[i].interpolateTo(transforms1[i]);
      }
      interpolator.interpolators = interpolators;
      return interpolator;
    };
    TransformListInterpolator.prototype = Object.create(_super.prototype);
    TransformListInterpolator.prototype.constructor = TransformListInterpolator;
    Object.defineProperty(TransformListInterpolator.prototype, 0, {
      get() {
        const interpolators = this.interpolators;
        const interpolatorCount = interpolators.length;
        const transforms = new Array(interpolatorCount);
        for (let i = 0; i < interpolatorCount; i += 1) {
          transforms[i] = interpolators[i][0];
        }
        return new TransformList(transforms);
      },
      configurable: true
    });
    Object.defineProperty(TransformListInterpolator.prototype, 1, {
      get() {
        const interpolators = this.interpolators;
        const interpolatorCount = interpolators.length;
        const transforms = new Array(interpolatorCount);
        for (let i = 0; i < interpolatorCount; i += 1) {
          transforms[i] = interpolators[i][1];
        }
        return new TransformList(transforms);
      },
      configurable: true
    });
    TransformListInterpolator.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof TransformListInterpolator) {
        const n = this.interpolators.length;
        if (n === that.interpolators.length) {
          for (let i = 0; i < n; i += 1) {
            if (!this.interpolators[i].equals(that.interpolators[i])) {
              return false;
            }
          }
          return true;
        }
      }
      return false;
    };
    return TransformListInterpolator;
  }(Interpolator);
  class TransformListParser extends Parser {
    constructor(transform, transformParser) {
      super();
      this.transform = transform;
      this.transformParser = transformParser;
    }
    feed(input) {
      return TransformListParser.parse(input, this.transform, this.transformParser);
    }
    static parse(input, transform = Transform.identity(), transformParser) {
      do {
        if (transformParser === void 0) {
          while (input.isCont() && Unicode.isSpace(input.head())) {
            input.step();
          }
          if (input.isCont()) {
            transformParser = TransformParser.parse(input);
          } else if (input.isDone()) {
            return Parser.done(transform);
          }
        }
        if (transformParser !== void 0) {
          transformParser = transformParser.feed(input);
          if (transformParser.isDone()) {
            transform = transform.transform(transformParser.bind());
            transformParser = void 0;
            continue;
          } else if (transformParser.isError()) {
            return transformParser.asError();
          }
        }
        break;
      } while (true);
      return new TransformListParser(transform, transformParser);
    }
  }
  const GeoProjection = function() {
    const GeoProjection = {};
    GeoProjection.is = function(object) {
      if (object !== void 0 && object !== null) {
        const projection = object;
        return typeof projection.project === "function" && typeof projection.unproject === "function";
      }
      return false;
    };
    return GeoProjection;
  }();
  class GeoShape {
    union(that) {
      that = GeoShape.fromAny(that);
      return new GeoBox(Math.min(this.lngMin, that.lngMin), Math.min(this.latMin, that.latMin), Math.max(this.lngMax, that.lngMax), Math.max(this.latMax, that.latMax));
    }
    get bounds() {
      return new GeoBox(this.lngMin, this.latMin, this.lngMax, this.latMax);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof GeoShape) {
        return value;
      } else if (GeoPoint.isInit(value)) {
        return GeoPoint.fromInit(value);
      } else if (GeoPoint.isTuple(value)) {
        return GeoPoint.fromTuple(value);
      } else if (GeoSegment.isInit(value)) {
        return GeoSegment.fromInit(value);
      } else if (GeoTile.isInit(value)) {
        return GeoTile.fromInit(value);
      } else if (GeoTile.isTuple(value)) {
        return GeoTile.fromTuple(value);
      } else if (GeoBox.isInit(value)) {
        return GeoBox.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static isAny(value) {
      return value instanceof GeoShape || GeoPoint.isInit(value) || GeoPoint.isTuple(value) || GeoSegment.isInit(value) || GeoTile.isInit(value) || GeoBox.isInit(value);
    }
  }
  class GeoPoint extends GeoShape {
    constructor(lng, lat) {
      super();
      this.lng = lng;
      this.lat = lat;
    }
    isDefined() {
      return isFinite(this.lng) && isFinite(this.lat);
    }
    get lngMin() {
      return this.lng;
    }
    get latMin() {
      return this.lat;
    }
    get lngMax() {
      return this.lng;
    }
    get latMax() {
      return this.lat;
    }
    contains(that, lat) {
      if (typeof that === "number") {
        return this.lng === that && this.lat === lat;
      } else {
        that = GeoShape.fromAny(that);
        if (that instanceof GeoPoint) {
          return this.lng === that.lng && this.lat === that.lat;
        } else if (that instanceof GeoShape) {
          return this.lng <= that.lngMin && that.lngMax <= this.lng && this.lat <= that.latMin && that.latMax <= this.lat;
        }
        return false;
      }
    }
    intersects(that) {
      that = GeoShape.fromAny(that);
      return that.intersects(this);
    }
    project(f) {
      return f.project(this);
    }
    normalized() {
      const oldLng = this.lng;
      const oldLat = this.lat;
      const newLng = GeoPoint.normalizeLng(oldLng);
      const newLat = GeoPoint.normalizeLat(oldLat);
      if (oldLng === newLng && oldLat === newLat) {
        return this;
      } else {
        return new GeoPoint(newLng, newLat);
      }
    }
    toAny() {
      return {
        lng: this.lng,
        lat: this.lat
      };
    }
    interpolateTo(that) {
      if (that instanceof GeoPoint) {
        return GeoPointInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof GeoPoint) {
        return Numbers.equivalent(this.lng, that.lng, epsilon) && Numbers.equivalent(this.lat, that.lat, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof GeoPoint) {
        return this.lng === that.lng && this.lat === that.lat;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(GeoPoint), Numbers.hash(this.lng)), Numbers.hash(this.lat)));
    }
    debug(output) {
      output = output.write("GeoPoint").write(46).write("of").write(40).debug(this.lng).write(", ").debug(this.lat).write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static origin() {
      return new GeoPoint(0, 0);
    }
    static undefined() {
      return new GeoPoint(NaN, NaN);
    }
    static of(lng, lat) {
      return new GeoPoint(lng, lat);
    }
    static fromInit(value) {
      return new GeoPoint(value.lng, value.lat);
    }
    static fromTuple(value) {
      return new GeoPoint(value[0], value[1]);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof GeoPoint) {
        return value;
      } else if (GeoPoint.isInit(value)) {
        return GeoPoint.fromInit(value);
      } else if (GeoPoint.isTuple(value)) {
        return GeoPoint.fromTuple(value);
      }
      throw new TypeError("" + value);
    }
    static normalized(lng, lat) {
      lng = GeoPoint.normalizeLng(lng);
      lat = GeoPoint.normalizeLat(lat);
      return new GeoPoint(lng, lat);
    }
    static normalizeLng(lng) {
      if (lng < -180) {
        lng = 180 - (-lng + 180) % 360;
      } else if (lng > 180) {
        lng = -180 + (lng - 180) % 360;
      }
      return lng;
    }
    static normalizeLat(lat) {
      lat = Math.min(Math.max(-90 + Equivalent.Epsilon, lat), 90 - Equivalent.Epsilon);
      return lat;
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return typeof init.lng === "number" && typeof init.lat === "number";
      }
      return false;
    }
    static isTuple(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
    }
    static isAny(value) {
      return value instanceof GeoPoint || GeoPoint.isInit(value) || GeoPoint.isTuple(value);
    }
  }
  __decorate([ Lazy ], GeoPoint, "origin", null);
  __decorate([ Lazy ], GeoPoint, "undefined", null);
  const GeoPointInterpolator = function(_super) {
    const GeoPointInterpolator = function(p0, p1) {
      const interpolator = function(u) {
        const p0 = interpolator[0];
        const lng0 = p0.lng;
        const lat0 = p0.lat;
        const p1 = interpolator[1];
        const lng1 = p1.lng;
        const lat1 = p1.lat;
        let lng;
        if (lng0 > 0 && lng1 < 0 && lng0 - lng1 > 180) {
          const w = 180 - lng0;
          const e = 180 + lng1;
          const uw = w / (w + e);
          if (u < uw) {
            lng = lng0 + u / uw * w;
          } else {
            const ue = 1 - uw;
            lng = -180 + (u - uw) / ue * e;
          }
        } else if (lng0 < 0 && lng1 > 0 && lng1 - lng0 > 180) {
          const e = 180 + lng0;
          const w = 180 - lng1;
          const ue = e / (e + w);
          if (u < ue) {
            lng = lng0 - u / ue * e;
          } else {
            const uw = 1 - ue;
            lng = 180 - (u - ue) / uw * w;
          }
        } else {
          lng = lng0 + u * (lng1 - lng0);
        }
        const lat = lat0 + u * (lat1 - lat0);
        return new GeoPoint(lng, lat);
      };
      Object.setPrototypeOf(interpolator, GeoPointInterpolator.prototype);
      interpolator[0] = p0.normalized();
      interpolator[1] = p1.normalized();
      return interpolator;
    };
    GeoPointInterpolator.prototype = Object.create(_super.prototype);
    GeoPointInterpolator.prototype.constructor = GeoPointInterpolator;
    return GeoPointInterpolator;
  }(Interpolator);
  class GeoCurve extends GeoShape {}
  class GeoSegment extends GeoCurve {
    constructor(lng0, lat0, lng1, lat1) {
      super();
      this.lng0 = lng0;
      this.lat0 = lat0;
      this.lng1 = lng1;
      this.lat1 = lat1;
    }
    isDefined() {
      return isFinite(this.lng0) && isFinite(this.lat0) && isFinite(this.lng1) && isFinite(this.lat1);
    }
    get lngMin() {
      return Math.min(this.lng0, this.lng1);
    }
    get latMin() {
      return Math.min(this.lat0, this.lat1);
    }
    get lngMax() {
      return Math.max(this.lng0, this.lng1);
    }
    get latMax() {
      return Math.max(this.lat0, this.lat1);
    }
    interpolateLng(u) {
      return (1 - u) * this.lng0 + u * this.lng1;
    }
    interpolateLat(u) {
      return (1 - u) * this.lat0 + u * this.lat1;
    }
    interpolate(u) {
      const v = 1 - u;
      const lng01 = v * this.lng0 + u * this.lng1;
      const lat01 = v * this.lat0 + u * this.lat1;
      return new GeoPoint(lng01, lat01);
    }
    contains(that, lat) {
      if (typeof that === "number") {
        return R2Segment.contains(this.lng0, this.lat0, this.lng1, this.lat1, that, lat);
      } else {
        that = GeoShape.fromAny(that);
        if (that instanceof GeoPoint) {
          return this.containsPoint(that);
        } else if (that instanceof GeoSegment) {
          return this.containsSegment(that);
        }
        return false;
      }
    }
    containsPoint(that) {
      return R2Segment.contains(this.lng0, this.lat0, this.lng1, this.lat1, that.lng, that.lat);
    }
    containsSegment(that) {
      return R2Segment.contains(this.lng0, this.lat0, this.lng1, this.lat1, that.lng0, that.lat0) && R2Segment.contains(this.lng0, this.lat0, this.lng1, this.lat1, that.lng1, that.lat1);
    }
    intersects(that) {
      that = GeoShape.fromAny(that);
      if (that instanceof GeoPoint) {
        return this.intersectsPoint(that);
      } else if (that instanceof GeoSegment) {
        return this.intersectsSegment(that);
      } else {
        return that.intersects(this);
      }
    }
    intersectsPoint(that) {
      return R2Segment.contains(this.lng0, this.lat0, this.lng1, this.lat1, that.lng, that.lat);
    }
    intersectsSegment(that) {
      return R2Segment.intersects(this.lng0, this.lat0, this.lng1 - this.lat0, this.lng1 - this.lat0, that.lng0, that.lat0, that.lng1 - that.lat0, that.lng1 - that.lat0);
    }
    split(u) {
      const v = 1 - u;
      const lng01 = v * this.lng0 + u * this.lng1;
      const lat01 = v * this.lat0 + u * this.lat1;
      const c0 = new GeoSegment(this.lng0, this.lat0, lng01, lat01);
      const c1 = new GeoSegment(lng01, lat01, this.lng1, this.lat1);
      return [ c0, c1 ];
    }
    project(f) {
      const p0 = f.project(this.lng0, this.lat0);
      const p1 = f.project(this.lng1, this.lat1);
      return new R2Segment(p0.x, p0.y, p1.x, p1.y);
    }
    forEachCoord(callback, thisArg) {
      let result;
      result = callback.call(thisArg, this.lng0, this.lat0);
      if (result !== void 0) {
        return result;
      }
      result = callback.call(thisArg, this.lng1, this.lat1);
      if (result !== void 0) {
        return result;
      }
      return void 0;
    }
    forEachCoordRest(callback, thisArg) {
      const result = callback.call(thisArg, this.lng1, this.lat1);
      if (result !== void 0) {
        return result;
      }
      return void 0;
    }
    toAny() {
      return {
        lng0: this.lng0,
        lat0: this.lat0,
        lng1: this.lng1,
        lat1: this.lat1
      };
    }
    interpolateTo(that) {
      if (that instanceof GeoSegment) {
        return GeoSegmentInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof GeoSegment) {
        return Numbers.equivalent(this.lng0, that.lng0, epsilon) && Numbers.equivalent(this.lat0, that.lat0, epsilon) && Numbers.equivalent(this.lng1, that.lng1, epsilon) && Numbers.equivalent(this.lat1, that.lat1, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof GeoSegment) {
        return this.lng0 === that.lng0 && this.lat0 === that.lat0 && this.lng1 === that.lng1 && this.lat1 === that.lat1;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(Constructors.hash(GeoSegment), Numbers.hash(this.lng0)), Numbers.hash(this.lat0)), Numbers.hash(this.lng1)), Numbers.hash(this.lat1)));
    }
    debug(output) {
      output = output.write("GeoSegment").write(46).write("of").write(40).debug(this.lng0).write(", ").debug(this.lat0).write(", ").debug(this.lng1).write(", ").debug(this.lat1).write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static of(lng0, lat0, lng1, lat1) {
      return new GeoSegment(lng0, lat0, lng1, lat1);
    }
    static fromInit(value) {
      return new GeoSegment(value.lng0, value.lat0, value.lng1, value.lat1);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof GeoSegment) {
        return value;
      } else if (GeoSegment.isInit(value)) {
        return GeoSegment.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return typeof init.lng0 === "number" && typeof init.lat0 === "number" && typeof init.lng1 === "number" && typeof init.lat1 === "number";
      }
      return false;
    }
    static isAny(value) {
      return value instanceof GeoSegment || GeoSegment.isInit(value);
    }
  }
  const GeoSegmentInterpolator = function(_super) {
    const GeoSegmentInterpolator = function(s0, s1) {
      const interpolator = function(u) {
        const s0 = interpolator[0];
        const s1 = interpolator[1];
        const lng0 = s0.lng0 + u * (s1.lng0 - s0.lng0);
        const lat0 = s0.lat0 + u * (s1.lat0 - s0.lat0);
        const lng1 = s0.lng1 + u * (s1.lng1 - s0.lng1);
        const lat1 = s0.lat1 + u * (s1.lat1 - s0.lat1);
        return new GeoSegment(lng0, lat0, lng1, lat1);
      };
      Object.setPrototypeOf(interpolator, GeoSegmentInterpolator.prototype);
      interpolator[0] = s0;
      interpolator[1] = s1;
      return interpolator;
    };
    GeoSegmentInterpolator.prototype = Object.create(_super.prototype);
    GeoSegmentInterpolator.prototype.constructor = GeoSegmentInterpolator;
    return GeoSegmentInterpolator;
  }(Interpolator);
  class GeoSpline extends GeoCurve {
    constructor(curves, closed) {
      super();
      this.curves = curves;
      this.closed = closed;
      this.boundingBox = null;
    }
    isDefined() {
      return this.curves.length !== 0;
    }
    isClosed() {
      return this.closed;
    }
    get lngMin() {
      return this.bounds.lngMin;
    }
    get latMin() {
      return this.bounds.latMin;
    }
    get lngMax() {
      return this.bounds.lngMax;
    }
    get latMax() {
      return this.bounds.latMax;
    }
    interpolateLng(u) {
      const curves = this.curves;
      const n = curves.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n);
        const v = u * n - k * l;
        return curves[k].interpolateLng(v);
      } else {
        return NaN;
      }
    }
    interpolateLat(u) {
      const curves = this.curves;
      const n = curves.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n);
        const v = u * n - k * l;
        return curves[k].interpolateLat(v);
      } else {
        return NaN;
      }
    }
    interpolate(u) {
      const curves = this.curves;
      const n = curves.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n);
        const v = u * n - k * l;
        return curves[k].interpolate(v);
      } else {
        return new GeoPoint(NaN, NaN);
      }
    }
    contains(that, lat) {
      return false;
    }
    intersects(that) {
      return false;
    }
    split(u) {
      const curves = this.curves;
      const n = curves.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n);
        const v = u * n - k * l;
        const [c0, c1] = curves[k].split(v);
        const curves0 = new Array(k + 1);
        const curves1 = new Array(n - k);
        for (let i = 0; i < k; i += 1) {
          curves0[i] = curves[i];
        }
        curves0[k] = c0;
        curves1[0] = c1;
        for (let i = k + 1; i < n; i += 1) {
          curves1[i - k] = curves[i];
        }
        return [ new GeoSpline(curves0, false), new GeoSpline(curves1, false) ];
      } else {
        return [ GeoSpline.empty(), GeoSpline.empty() ];
      }
    }
    subdivide(u) {
      const oldCurves = this.curves;
      const n = oldCurves.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n);
        const v = u * n - k * l;
        const [c0, c1] = oldCurves[k].split(v);
        const newCurves = new Array(n + 1);
        for (let i = 0; i < k; i += 1) {
          newCurves[i] = oldCurves[i];
        }
        newCurves[k] = c0;
        newCurves[k + 1] = c1;
        for (let i = k + 1; i < n; i += 1) {
          newCurves[i + 1] = oldCurves[i];
        }
        return new GeoSpline(newCurves, this.closed);
      } else {
        return GeoSpline.empty();
      }
    }
    project(f) {
      const oldCurves = this.curves;
      const n = oldCurves.length;
      if (n > 0) {
        let i = 0;
        const newCurves = new Array(n);
        let curve = oldCurves[0];
        if (curve instanceof GeoSegment) {
          let p0 = f.project(curve.lng0, curve.lat0);
          while (i < n) {
            curve = oldCurves[i];
            if (curve instanceof GeoSegment) {
              const p1 = f.project(curve.lng1, curve.lat1);
              newCurves[i] = new R2Segment(p0.x, p0.y, p1.x, p1.y);
              p0 = p1;
              i += 1;
            } else {
              break;
            }
          }
        }
        while (i < n) {
          curve = oldCurves[i];
          newCurves[i] = curve.project(f);
          i += 1;
        }
        return new R2Spline(newCurves, this.closed);
      } else {
        return R2Spline.empty();
      }
    }
    get bounds() {
      let boundingBox = this.boundingBox;
      if (boundingBox === null) {
        let lngMin = Infinity;
        let latMin = Infinity;
        let lngMax = -Infinity;
        let latMax = -Infinity;
        const curves = this.curves;
        for (let i = 0, n = curves.length; i < n; i += 1) {
          const curve = curves[i];
          lngMin = Math.min(lngMin, curve.lngMin);
          latMin = Math.min(latMin, curve.latMin);
          lngMax = Math.max(curve.lngMax, lngMax);
          latMax = Math.max(curve.latMax, latMax);
        }
        boundingBox = new GeoBox(lngMin, latMin, lngMax, latMax);
        this.boundingBox = boundingBox;
      }
      return boundingBox;
    }
    forEachCoord(callback, thisArg) {
      const curves = this.curves;
      const n = curves.length;
      if (n > 0) {
        let curve = curves[0];
        let result = curve.forEachCoord(callback, thisArg);
        if (result !== void 0) {
          return result;
        }
        for (let i = 1; i < n; i += 1) {
          curve = curves[i];
          result = curve.forEachCoordRest(callback, thisArg);
          if (result !== void 0) {
            return result;
          }
        }
      }
      return void 0;
    }
    forEachCoordRest(callback, thisArg) {
      const curves = this.curves;
      for (let i = 0, n = curves.length; i < n; i += 1) {
        const curve = curves[i];
        const result = curve.forEachCoordRest(callback, thisArg);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof GeoSpline) {
        return Arrays.equivalent(this.curves, that.curves, epsilon) && this.closed === that.closed;
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof GeoSpline) {
        return Arrays.equal(this.curves, that.curves) && this.closed === that.closed;
      }
      return false;
    }
    debug(output) {
      const curves = this.curves;
      const n = curves.length;
      output = output.write("GeoSpline").write(46);
      if (n === 0) {
        output = output.write("empty").write(40);
      } else if (n !== 0) {
        output = output.write(this.closed ? "closed" : "open").write(40);
        output = output.debug(curves[0]);
        for (let i = 1; i < n; i += 1) {
          output = output.write(", ").debug(curves[i]);
        }
      }
      output = output.write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static empty() {
      return new GeoSpline([], false);
    }
    static open(...curves) {
      return new GeoSpline(curves, false);
    }
    static closed(...curves) {
      return new GeoSpline(curves, true);
    }
    static fromPoints(points) {
      const n = points.length;
      if (n > 1) {
        const curves = new Array(n - 1);
        const p0 = GeoPoint.fromAny(points[0]);
        let p1 = p0;
        for (let i = 1; i < n; i += 1) {
          const p2 = GeoPoint.fromAny(points[i]);
          curves[i - 1] = new GeoSegment(p1.lng, p1.lat, p2.lng, p2.lat);
          p1 = p2;
        }
        const closed = p0.equals(p1);
        return new GeoSpline(curves, closed);
      } else {
        return GeoSpline.empty();
      }
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof GeoSpline) {
        return value;
      } else if (GeoSpline.isPoints(value)) {
        return GeoSpline.fromPoints(value);
      } else {
        return GeoShape.fromAny(value);
      }
    }
    static builder() {
      return new GeoSplineBuilder;
    }
    static isPoints(value) {
      return Array.isArray(value) && value.length >= 2 && GeoPoint.isAny(value[0]);
    }
    static isAnySpline(value) {
      return value instanceof GeoSpline || GeoSpline.isPoints(value);
    }
  }
  class GeoSplineBuilder {
    constructor() {
      this.curves = [];
      this.closed = false;
      this.aliased = false;
      this.lng0 = 0;
      this.lat0 = 0;
      this.lng = 0;
      this.lat = 0;
    }
    dealias() {
      if (this.aliased) {
        this.curves = this.curves.slice(0);
        this.aliased = false;
      }
    }
    moveTo(lng, lat) {
      if (this.aliased) {
        this.curves = [];
        this.aliased = false;
      } else {
        this.curves.length = 0;
      }
      this.closed = false;
      this.lng0 = lng;
      this.lat0 = lat;
      this.lng = lng;
      this.lat = lat;
    }
    closePath() {
      this.dealias();
      this.curves.push(new GeoSegment(this.lng, this.lat, this.lng0, this.lat0));
      this.closed = true;
      this.lng = this.lng0;
      this.lat = this.lat0;
    }
    lineTo(lng, lat) {
      this.dealias();
      this.curves.push(new GeoSegment(this.lng, this.lat, lng, lat));
      this.lng = lng;
      this.lat = lat;
    }
    bind() {
      this.aliased = true;
      return new GeoSpline(this.curves, this.closed);
    }
  }
  class GeoPath extends GeoShape {
    constructor(splines) {
      super();
      this.splines = splines;
      this.boundingBox = null;
    }
    isDefined() {
      return this.splines.length !== 0;
    }
    get lngMin() {
      return this.bounds.lngMin;
    }
    get latMin() {
      return this.bounds.latMin;
    }
    get lngMax() {
      return this.bounds.lngMax;
    }
    get latMax() {
      return this.bounds.latMax;
    }
    interpolateLng(u) {
      const splines = this.splines;
      const n = splines.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n);
        const v = u * n - k * l;
        return splines[k].interpolateLng(v);
      } else {
        return NaN;
      }
    }
    interpolateLat(u) {
      const splines = this.splines;
      const n = splines.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n);
        const v = u * n - k * l;
        return splines[k].interpolateLat(v);
      } else {
        return NaN;
      }
    }
    interpolate(u) {
      const splines = this.splines;
      const n = splines.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n);
        const v = u * n - k * l;
        return splines[k].interpolate(v);
      } else {
        return new GeoPoint(NaN, NaN);
      }
    }
    contains(that, y) {
      return false;
    }
    intersects(that) {
      return false;
    }
    split(u) {
      const splines = this.splines;
      const n = splines.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n);
        const v = u * n - k * l;
        const [s0, s1] = splines[k].split(v);
        const splines0 = new Array(k + 1);
        const splines1 = new Array(n - k);
        for (let i = 0; i < k; i += 1) {
          splines0[i] = splines[i];
        }
        splines0[k] = s0;
        splines1[0] = s1;
        for (let i = k + 1; i < n; i += 1) {
          splines1[i - k] = splines[i];
        }
        return [ new GeoPath(splines0), new GeoPath(splines1) ];
      } else {
        return [ GeoPath.empty(), GeoPath.empty() ];
      }
    }
    subdivide(u) {
      const oldSplines = this.splines;
      const n = oldSplines.length;
      if (n > 0) {
        const l = 1 / n;
        const k = Math.min(Math.max(0, Math.floor(u / l)), n);
        const v = u * n - k * l;
        const newSplines = new Array(n);
        for (let i = 0; i < k; i += 1) {
          newSplines[i] = oldSplines[i];
        }
        newSplines[k] = oldSplines[k].subdivide(v);
        for (let i = k + 1; i < n; i += 1) {
          newSplines[i] = oldSplines[i];
        }
        return new GeoPath(newSplines);
      } else {
        return GeoPath.empty();
      }
    }
    project(f) {
      const oldSplines = this.splines;
      const n = oldSplines.length;
      if (n > 0) {
        const newSplines = new Array(n);
        for (let i = 0; i < n; i += 1) {
          newSplines[i] = oldSplines[i].project(f);
        }
        return new R2Path(newSplines);
      } else {
        return R2Path.empty();
      }
    }
    get bounds() {
      let boundingBox = this.boundingBox;
      if (boundingBox === null) {
        let lngMin = Infinity;
        let latMin = Infinity;
        let lngMax = -Infinity;
        let latMax = -Infinity;
        const splines = this.splines;
        for (let i = 0, n = splines.length; i < n; i += 1) {
          const spline = splines[i];
          lngMin = Math.min(lngMin, spline.lngMin);
          latMin = Math.min(latMin, spline.latMin);
          lngMax = Math.max(spline.lngMax, lngMax);
          latMax = Math.max(spline.latMax, latMax);
        }
        boundingBox = new GeoBox(lngMin, latMin, lngMax, latMax);
        this.boundingBox = boundingBox;
      }
      return boundingBox;
    }
    centroid() {
      let lngSum = 0;
      let latSum = 0;
      let n = 0;
      this.forEachCoord((function(lng, lat) {
        lngSum += lng;
        latSum += lat;
        n += 1;
      }), this);
      if (n !== 0) {
        return new GeoPoint(lngSum / n, latSum / n);
      } else {
        return GeoPoint.undefined();
      }
    }
    forEachCoord(callback, thisArg) {
      const splines = this.splines;
      for (let i = 0, n = splines.length; i < n; i += 1) {
        const spline = splines[i];
        const result = spline.forEachCoord(callback, thisArg);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof GeoPath) {
        return Arrays.equivalent(this.splines, that.splines, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof GeoPath) {
        return Arrays.equal(this.splines, that.splines);
      }
      return false;
    }
    debug(output) {
      const splines = this.splines;
      const n = splines.length;
      output = output.write("GeoPath").write(46);
      if (n === 0) {
        output = output.write("empty").write(40);
      } else if (n === 1) {
        const spline = splines[0];
        output = output.write(spline.closed ? "closed" : "open").write(40);
        const curves = spline.curves;
        const m = curves.length;
        if (m !== 0) {
          output = output.debug(curves[0]);
          for (let i = 1; i < m; i += 1) {
            output = output.write(", ").debug(curves[i]);
          }
        }
      } else {
        output = output.write("of").write(40);
        output = output.debug(splines[0]);
        for (let i = 1; i < n; i += 1) {
          output = output.write(", ").debug(splines[i]);
        }
      }
      output = output.write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static empty() {
      return new GeoPath([]);
    }
    static of(...splines) {
      return new GeoPath(splines);
    }
    static open(...curves) {
      return new GeoPath([ new GeoSpline(curves, false) ]);
    }
    static closed(...curves) {
      return new GeoPath([ new GeoSpline(curves, true) ]);
    }
    static fromPoints(points) {
      return new GeoPath([ GeoSpline.fromPoints(points) ]);
    }
    static fromSplines(values) {
      const n = values.length;
      const splines = new Array(n);
      for (let i = 0; i < n; i += 1) {
        splines[i] = GeoSpline.fromAny(values[i]);
      }
      return new GeoPath(splines);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof GeoPath) {
        return value;
      } else if (GeoPath.isSplines(value)) {
        return GeoPath.fromSplines(value);
      } else if (GeoSpline.isAnySpline(value)) {
        return GeoPath.of(GeoSpline.fromAny(value));
      } else {
        return GeoShape.fromAny(value);
      }
    }
    static builder() {
      return new GeoPathBuilder;
    }
    static isSplines(value) {
      return Array.isArray(value) && value.length > 0 && GeoSpline.isAnySpline(value[0]);
    }
    static isAnyPath(value) {
      return value instanceof GeoPath || GeoPath.isSplines(value);
    }
  }
  class GeoPathBuilder {
    constructor() {
      this.splines = [];
      this.builder = null;
    }
    moveTo(lng, lat) {
      let builder = this.builder;
      if (builder !== null) {
        const spline = builder.bind();
        if (spline.isDefined()) {
          this.splines.push(spline);
        }
      }
      builder = new GeoSplineBuilder;
      this.builder = builder;
      builder.moveTo(lng, lat);
    }
    closePath() {
      const builder = this.builder;
      if (builder !== null) {
        builder.closePath();
      } else {
        throw new Error;
      }
    }
    lineTo(lng, lat) {
      const builder = this.builder;
      if (builder !== null) {
        builder.lineTo(lng, lat);
      } else {
        throw new Error;
      }
    }
    bind() {
      const splines = this.splines.slice(0);
      const builder = this.builder;
      if (builder !== null) {
        const spline = builder.bind();
        if (spline.isDefined()) {
          splines.push(spline);
        }
      }
      return new GeoPath(splines);
    }
  }
  class GeoBox extends GeoShape {
    constructor(lngMin, latMin, lngMax, latMax) {
      super();
      this.lngMin = lngMin;
      this.latMin = latMin;
      this.lngMax = lngMax;
      this.latMax = latMax;
    }
    isDefined() {
      return isFinite(this.lngMin) && isFinite(this.latMin) && isFinite(this.lngMax) && isFinite(this.latMax);
    }
    get west() {
      return this.lngMin;
    }
    get south() {
      return this.latMin;
    }
    get east() {
      return this.lngMax;
    }
    get north() {
      return this.latMax;
    }
    get southWest() {
      return new GeoPoint(this.lngMin, this.latMin);
    }
    get northWest() {
      return new GeoPoint(this.lngMin, this.latMax);
    }
    get southEast() {
      return new GeoPoint(this.lngMax, this.latMin);
    }
    get northEast() {
      return new GeoPoint(this.lngMax, this.latMax);
    }
    get center() {
      return new GeoPoint((this.lngMin + this.lngMax) / 2, (this.latMin + this.latMax) / 2);
    }
    contains(that, y) {
      if (typeof that === "number") {
        return this.lngMin <= that && that <= this.lngMax && this.latMin <= y && y <= this.latMax;
      } else if (GeoPoint.isAny(that)) {
        return this.containsPoint(GeoPoint.fromAny(that));
      } else if (GeoSegment.isAny(that)) {
        return this.containsSegment(GeoSegment.fromAny(that));
      } else if (GeoTile.isAny(that)) {
        return this.containsTile(GeoTile.fromAny(that));
      } else if (GeoBox.isAny(that)) {
        return this.containsBox(GeoBox.fromAny(that));
      } else {
        throw new TypeError("" + that);
      }
    }
    containsPoint(that) {
      return this.lngMin <= that.lng && that.lng <= this.lngMax && this.latMin <= that.lat && that.lat <= this.latMax;
    }
    containsSegment(that) {
      return this.lngMin <= that.lng0 && that.lng0 <= this.lngMax && this.latMin <= that.lat0 && that.lat0 <= this.latMax && this.lngMin <= that.lng1 && that.lng1 <= this.lngMax && this.latMin <= that.lat1 && that.lat1 <= this.latMax;
    }
    containsTile(that) {
      return this.lngMin <= that.lngMin && that.lngMax <= this.lngMax && this.latMin <= that.latMin && that.latMax <= this.latMax;
    }
    containsBox(that) {
      return this.lngMin <= that.lngMin && that.lngMax <= this.lngMax && this.latMin <= that.latMin && that.latMax <= this.latMax;
    }
    intersects(that) {
      if (GeoPoint.isAny(that)) {
        return this.intersectsPoint(GeoPoint.fromAny(that));
      } else if (GeoSegment.isAny(that)) {
        return this.intersectsSegment(GeoSegment.fromAny(that));
      } else if (GeoTile.isAny(that)) {
        return this.intersectsTile(GeoTile.fromAny(that));
      } else if (GeoBox.isAny(that)) {
        return this.intersectsBox(GeoBox.fromAny(that));
      } else {
        throw new TypeError("" + that);
      }
    }
    intersectsPoint(that) {
      return this.lngMin <= that.lng && that.lng <= this.lngMax && this.latMin <= that.lat && that.lat <= this.latMax;
    }
    intersectsSegment(that) {
      const lngMin = this.lngMin;
      const latMin = this.latMin;
      const lngMax = this.lngMax;
      const latMax = this.latMax;
      const lng0 = that.lng0;
      const lat0 = that.lat0;
      const lng1 = that.lng1;
      const lat1 = that.lat1;
      if (lng0 < lngMin && lng1 < lngMin || lng0 > lngMax && lng1 > lngMax || lat0 < latMin && lat1 < latMin || lat0 > latMax && lat1 > latMax) {
        return false;
      } else if (lng0 > lngMin && lng0 < lngMax && lat0 > latMin && lat0 < latMax) {
        return true;
      } else if (R2Box.intersectsSegment(lng0 - lngMin, lng1 - lngMin, lng0, lat0, lng1, lat1) && R2Box.hitY > latMin && R2Box.hitY < latMax || R2Box.intersectsSegment(lat0 - latMin, lat1 - latMin, lng0, lat0, lng1, lat1) && R2Box.hitX > lngMin && R2Box.hitX < lngMax || R2Box.intersectsSegment(lng0 - lngMax, lng1 - lngMax, lng0, lat0, lng1, lat1) && R2Box.hitY > latMin && R2Box.hitY < latMax || R2Box.intersectsSegment(lat0 - latMax, lat1 - latMax, lng0, lat0, lng1, lat1) && R2Box.hitX > lngMin && R2Box.hitX < lngMax) {
        return true;
      } else {
        return false;
      }
    }
    intersectsTile(that) {
      return this.lngMin <= that.lngMax && that.lngMin <= this.lngMax && this.latMin <= that.latMax && that.latMin <= this.latMax;
    }
    intersectsBox(that) {
      return this.lngMin <= that.lngMax && that.lngMin <= this.lngMax && this.latMin <= that.latMax && that.latMin <= this.latMax;
    }
    union(that) {
      return super.union(that);
    }
    project(f) {
      const bottomLeft = f.project(this.lngMin, this.latMin);
      const topRight = f.project(this.lngMax, this.latMax);
      let xMin = bottomLeft.x;
      let yMin = bottomLeft.y;
      let xMax = topRight.x;
      let yMax = topRight.y;
      if (xMin > xMax) {
        const x = xMin;
        xMin = xMax;
        xMax = x;
      }
      if (yMin > yMax) {
        const y = yMin;
        yMin = yMax;
        yMax = y;
      }
      if (!isFinite(xMin)) {
        xMin = -Infinity;
      }
      if (!isFinite(yMin)) {
        yMin = -Infinity;
      }
      if (!isFinite(xMax)) {
        xMax = Infinity;
      }
      if (!isFinite(yMax)) {
        yMax = Infinity;
      }
      return new R2Box(xMin, yMin, xMax, yMax);
    }
    get bounds() {
      return this;
    }
    toAny() {
      return {
        lngMin: this.lngMin,
        latMin: this.latMin,
        lngMax: this.lngMax,
        latMax: this.latMax
      };
    }
    interpolateTo(that) {
      if (that instanceof GeoBox) {
        return GeoBoxInterpolator(this, that);
      } else {
        return null;
      }
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof GeoBox) {
        return Numbers.equivalent(this.lngMin, that.lngMin, epsilon) && Numbers.equivalent(this.latMin, that.latMin, epsilon) && Numbers.equivalent(this.lngMax, that.lngMax, epsilon) && Numbers.equivalent(this.latMax, that.latMax, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof GeoBox) {
        return this.lngMin === that.lngMin && this.latMin === that.latMin && this.lngMax === that.lngMax && this.latMax === that.latMax;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(Constructors.hash(GeoBox), Numbers.hash(this.lngMin)), Numbers.hash(this.latMin)), Numbers.hash(this.lngMax)), Numbers.hash(this.latMax)));
    }
    debug(output) {
      output = output.write("GeoBox").write(46).write("of").write(40).debug(this.lngMin).write(", ").debug(this.latMin).write(", ").debug(this.lngMax).write(", ").debug(this.latMax).write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static undefined() {
      return new GeoBox(Infinity, Infinity, -Infinity, -Infinity);
    }
    static globe() {
      return new GeoBox(-180, -90, 180, 90);
    }
    static of(lngMin, latMin, lngMax, latMax) {
      if (lngMax === void 0) {
        lngMax = lngMin;
      }
      if (latMax === void 0) {
        latMax = latMin;
      }
      return new GeoBox(lngMin, latMin, lngMax, latMax);
    }
    static fromInit(value) {
      return new GeoBox(value.lngMin, value.latMin, value.lngMax, value.latMax);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof GeoBox) {
        return value;
      } else if (GeoBox.isInit(value)) {
        return GeoBox.fromInit(value);
      }
      throw new TypeError("" + value);
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return typeof init.lngMin === "number" && typeof init.latMin === "number" && typeof init.lngMax === "number" && typeof init.latMax === "number";
      }
      return false;
    }
    static isAny(value) {
      return value instanceof GeoBox || GeoBox.isInit(value);
    }
  }
  __decorate([ Lazy ], GeoBox, "undefined", null);
  __decorate([ Lazy ], GeoBox, "globe", null);
  class GeoTile extends GeoShape {
    constructor(x, y, z) {
      super();
      this.x = x;
      this.y = y;
      this.z = z;
    }
    get lngMin() {
      return GeoTile.unprojectX(this.x / (1 << this.z));
    }
    get latMin() {
      return GeoTile.unprojectY(this.y / (1 << this.z));
    }
    get lngMax() {
      return GeoTile.unprojectX((this.x + 1) / (1 << this.z));
    }
    get latMax() {
      return GeoTile.unprojectY((this.y + 1) / (1 << this.z));
    }
    get west() {
      return this.lngMin;
    }
    get south() {
      return this.latMin;
    }
    get east() {
      return this.lngMax;
    }
    get north() {
      return this.latMax;
    }
    get southWest() {
      return new GeoPoint(this.lngMin, this.latMin);
    }
    get northWest() {
      return new GeoPoint(this.lngMin, this.latMax);
    }
    get southEast() {
      return new GeoPoint(this.lngMax, this.latMin);
    }
    get northEast() {
      return new GeoPoint(this.lngMax, this.latMax);
    }
    get center() {
      return new GeoPoint((this.lngMin + this.lngMax) / 2, (this.latMin + this.latMax) / 2);
    }
    get southWestTile() {
      return new GeoTile(this.x * 2, this.y * 2, this.z + 1);
    }
    get northWestTile() {
      return new GeoTile(this.x * 2, this.y * 2 + 1, this.z + 1);
    }
    get southEastTile() {
      return new GeoTile(this.x * 2 + 1, this.y * 2, this.z + 1);
    }
    get northEastTile() {
      return new GeoTile(this.x * 2 + 1, this.y * 2 + 1, this.z + 1);
    }
    get parentTile() {
      return new GeoTile(this.x >> 1, this.y >> 1, this.z - 1);
    }
    contains(that, lat) {
      if (typeof that === "number") {
        return this.lngMin <= that && that <= this.lngMax && this.latMin <= lat && lat <= this.latMax;
      } else if (GeoPoint.isAny(that)) {
        return this.containsPoint(GeoPoint.fromAny(that));
      } else if (GeoSegment.isAny(that)) {
        return this.containsSegment(GeoSegment.fromAny(that));
      } else if (GeoTile.isAny(that)) {
        return this.containsTile(GeoTile.fromAny(that));
      } else if (GeoBox.isAny(that)) {
        return this.containsBox(GeoBox.fromAny(that));
      } else {
        throw new TypeError("" + that);
      }
    }
    containsPoint(that) {
      return this.lngMin <= that.lng && that.lng <= this.lngMax && this.latMin <= that.lat && that.lat <= this.latMax;
    }
    containsSegment(that) {
      return this.lngMin <= that.lng0 && that.lng0 <= this.lngMax && this.latMin <= that.lat0 && that.lat0 <= this.latMax && this.lngMin <= that.lng1 && that.lng1 <= this.lngMax && this.latMin <= that.lat1 && that.lat1 <= this.latMax;
    }
    containsTile(that) {
      return this.lngMin <= that.lngMin && that.lngMax <= this.lngMax && this.latMin <= that.latMin && that.latMax <= this.latMax;
    }
    containsBox(that) {
      return this.lngMin <= that.lngMin && that.lngMax <= this.lngMax && this.latMin <= that.latMin && that.latMax <= this.latMax;
    }
    intersects(that) {
      if (GeoPoint.isAny(that)) {
        return this.intersectsPoint(GeoPoint.fromAny(that));
      } else if (GeoSegment.isAny(that)) {
        return this.intersectsSegment(GeoSegment.fromAny(that));
      } else if (GeoTile.isAny(that)) {
        return this.intersectsTile(GeoTile.fromAny(that));
      } else if (GeoBox.isAny(that)) {
        return this.intersectsBox(GeoBox.fromAny(that));
      } else {
        throw new TypeError("" + that);
      }
    }
    intersectsPoint(that) {
      return this.lngMin <= that.lng && that.lng <= this.lngMax && this.latMin <= that.lat && that.lat <= this.latMax;
    }
    intersectsSegment(that) {
      const lngMin = this.lngMin;
      const latMin = this.latMin;
      const lngMax = this.lngMax;
      const latMax = this.latMax;
      const lng0 = that.lng0;
      const lat0 = that.lat0;
      const lng1 = that.lng1;
      const lat1 = that.lat1;
      if (lng0 < lngMin && lng1 < lngMin || lng0 > lngMax && lng1 > lngMax || lat0 < latMin && lat1 < latMin || lat0 > latMax && lat1 > latMax) {
        return false;
      } else if (lng0 > lngMin && lng0 < lngMax && lat0 > latMin && lat0 < latMax) {
        return true;
      } else if (R2Box.intersectsSegment(lng0 - lngMin, lng1 - lngMin, lng0, lat0, lng1, lat1) && R2Box.hitY > latMin && R2Box.hitY < latMax || R2Box.intersectsSegment(lat0 - latMin, lat1 - latMin, lng0, lat0, lng1, lat1) && R2Box.hitX > lngMin && R2Box.hitX < lngMax || R2Box.intersectsSegment(lng0 - lngMax, lng1 - lngMax, lng0, lat0, lng1, lat1) && R2Box.hitY > latMin && R2Box.hitY < latMax || R2Box.intersectsSegment(lat0 - latMax, lat1 - latMax, lng0, lat0, lng1, lat1) && R2Box.hitX > lngMin && R2Box.hitX < lngMax) {
        return true;
      } else {
        return false;
      }
    }
    intersectsTile(that) {
      return this.lngMin <= that.lngMax && that.lngMin <= this.lngMax && this.latMin <= that.latMax && that.latMin <= this.latMax;
    }
    intersectsBox(that) {
      return this.lngMin <= that.lngMax && that.lngMin <= this.lngMax && this.latMin <= that.latMax && that.latMin <= this.latMax;
    }
    project(f) {
      const bottomLeft = f.project(this.lngMin, this.latMin);
      const topRight = f.project(this.lngMax, this.latMax);
      let xMin = bottomLeft.x;
      let yMin = bottomLeft.y;
      let xMax = topRight.x;
      let yMax = topRight.y;
      if (xMin > xMax) {
        const x = xMin;
        xMin = xMax;
        xMax = x;
      }
      if (yMin > yMax) {
        const y = yMin;
        yMin = yMax;
        yMax = y;
      }
      if (!isFinite(xMin)) {
        xMin = -Infinity;
      }
      if (!isFinite(yMin)) {
        yMin = -Infinity;
      }
      if (!isFinite(xMax)) {
        xMax = Infinity;
      }
      if (!isFinite(yMax)) {
        yMax = Infinity;
      }
      return new R2Box(xMin, yMin, xMax, yMax);
    }
    toAny() {
      return {
        x: this.x,
        y: this.y,
        z: this.z
      };
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof GeoTile) {
        return Numbers.equivalent(this.x, that.x, epsilon) && Numbers.equivalent(this.y, that.y, epsilon) && Numbers.equivalent(this.z, that.z, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof GeoTile) {
        return this.x === that.x && this.y === that.y && this.z === that.z;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Constructors.hash(GeoTile), Numbers.hash(this.x)), Numbers.hash(this.y)), Numbers.hash(this.z)));
    }
    debug(output) {
      output = output.write("GeoTile").write(46).write("of").write(40).debug(this.x).write(", ").debug(this.y).write(", ").debug(this.z).write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static root() {
      return new GeoTile(0, 0, 0);
    }
    static of(x, y, z) {
      return new GeoTile(x, y, z);
    }
    static fromInit(value) {
      return new GeoTile(value.x, value.y, value.z);
    }
    static fromTuple(value) {
      return new GeoTile(value[0], value[1], value[2]);
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof GeoTile) {
        return value;
      } else if (GeoTile.isInit(value)) {
        return GeoTile.fromInit(value);
      } else if (GeoTile.isTuple(value)) {
        return GeoTile.fromTuple(value);
      }
      throw new TypeError("" + value);
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return typeof init.x === "number" && typeof init.y === "number" && typeof init.z === "number";
      }
      return false;
    }
    static isTuple(value) {
      return Array.isArray(value) && value.length === 3 && typeof value[0] === "number" && typeof value[1] === "number" && typeof value[2] === "number";
    }
    static isAny(value) {
      return value instanceof GeoTile || GeoTile.isInit(value) || GeoTile.isTuple(value);
    }
    static unprojectX(x) {
      return (x * Math.PI * 2 - Math.PI) * (180 / Math.PI);
    }
    static unprojectY(y) {
      return (Math.atan(Math.exp(y * Math.PI * 2 - Math.PI)) * 2 - Math.PI / 2) * (180 / Math.PI);
    }
  }
  __decorate([ Lazy ], GeoTile, "root", null);
  const GeoBoxInterpolator = function(_super) {
    const GeoBoxInterpolator = function(s0, s1) {
      const interpolator = function(u) {
        const s0 = interpolator[0];
        const s1 = interpolator[1];
        const lngMin = s0.lngMin + u * (s1.lngMin - s0.lngMin);
        const latMin = s0.latMin + u * (s1.latMin - s0.latMin);
        const lngMax = s0.lngMax + u * (s1.lngMax - s0.lngMax);
        const latMax = s0.latMax + u * (s1.latMax - s0.latMax);
        return new GeoBox(lngMin, latMin, lngMax, latMax);
      };
      Object.setPrototypeOf(interpolator, GeoBoxInterpolator.prototype);
      interpolator[0] = s0;
      interpolator[1] = s1;
      return interpolator;
    };
    GeoBoxInterpolator.prototype = Object.create(_super.prototype);
    GeoBoxInterpolator.prototype.constructor = GeoBoxInterpolator;
    return GeoBoxInterpolator;
  }(Interpolator);
  class GeoGroup extends GeoShape {
    constructor(shapes) {
      super();
      this.shapes = shapes;
      this.boundingBox = null;
    }
    isDefined() {
      return this.shapes.length !== 0;
    }
    get lngMin() {
      return this.bounds.lngMin;
    }
    get latMin() {
      return this.bounds.latMin;
    }
    get lngMax() {
      return this.bounds.lngMax;
    }
    get latMax() {
      return this.bounds.latMax;
    }
    contains(that, y) {
      return false;
    }
    intersects(that) {
      return false;
    }
    project(f) {
      const oldShapes = this.shapes;
      const n = oldShapes.length;
      if (n > 0) {
        const newShapes = new Array(n);
        for (let i = 0; i < n; i += 1) {
          newShapes[i] = oldShapes[i].project(f);
        }
        return new R2Group(newShapes);
      } else {
        return R2Group.empty();
      }
    }
    get bounds() {
      let boundingBox = this.boundingBox;
      if (boundingBox === null) {
        let lngMin = Infinity;
        let latMin = Infinity;
        let lngMax = -Infinity;
        let latMax = -Infinity;
        const shapes = this.shapes;
        for (let i = 0, n = shapes.length; i < n; i += 1) {
          const shape = shapes[i];
          lngMin = Math.min(lngMin, shape.lngMin);
          latMin = Math.min(latMin, shape.latMin);
          lngMax = Math.max(shape.lngMax, lngMax);
          latMax = Math.max(shape.latMax, latMax);
        }
        boundingBox = new GeoBox(lngMin, latMin, lngMax, latMax);
        this.boundingBox = boundingBox;
      }
      return boundingBox;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof GeoGroup) {
        return Arrays.equivalent(this.shapes, that.shapes, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof GeoGroup) {
        return Arrays.equal(this.shapes, that.shapes);
      }
      return false;
    }
    debug(output) {
      const shapes = this.shapes;
      const n = shapes.length;
      output = output.write("GeoGroup").write(46);
      if (n === 0) {
        output = output.write("empty").write(40);
      } else {
        output = output.write("of").write(40);
        output = output.debug(shapes[0]);
        for (let i = 1; i < n; i += 1) {
          output = output.write(", ").debug(shapes[i]);
        }
      }
      output = output.write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static empty() {
      return new GeoGroup(Arrays.empty);
    }
    static of(...shapes) {
      return new GeoGroup(shapes);
    }
  }
  __decorate([ Lazy ], GeoGroup, "empty", null);
  const GeoJson = function() {
    const GeoJson = {};
    GeoJson.is = function(value) {
      return GeoJsonGeometry.is(value) || GeoJsonFeature.is(value) || GeoJsonFeatureCollection.is(value);
    };
    GeoJson.toShape = function(object) {
      if (object.type === "Feature") {
        return GeoJsonFeature.toShape(object);
      } else if (object.type === "FeatureCollection") {
        return GeoJsonFeatureCollection.toShapes(object);
      } else {
        return GeoJsonGeometry.toShape(object);
      }
    };
    return GeoJson;
  }();
  const GeoJsonGeometry = function() {
    const GeoJsonGeometry = {};
    GeoJsonGeometry.is = function(value) {
      if (typeof value === "object" && value !== null) {
        const object = value;
        return (object.type === "Point" || object.type === "MultiPoint" || object.type === "LineString" || object.type === "MultiLineString" || object.type === "Polygon" || object.type === "MultiPolygon") && Array.isArray(object.coordinates) || object.type === "GeometryCollection" && Array.isArray(object.geometries);
      }
      return false;
    };
    GeoJsonGeometry.toShape = function(object) {
      if (object.type === "Point") {
        return GeoJsonPoint.toShape(object);
      } else if (object.type === "MultiPoint") {
        return GeoJsonMultiPoint.toShape(object);
      } else if (object.type === "LineString") {
        return GeoJsonLineString.toShape(object);
      } else if (object.type === "MultiLineString") {
        return GeoJsonMultiLineString.toShape(object);
      } else if (object.type === "Polygon") {
        return GeoJsonPolygon.toShape(object);
      } else if (object.type === "MultiPolygon") {
        return GeoJsonMultiPolygon.toShape(object);
      } else if (object.type === "GeometryCollection") {
        return GeoJsonGeometryCollection.toShape(object);
      } else {
        throw new TypeError("" + object);
      }
    };
    return GeoJsonGeometry;
  }();
  const GeoJsonPoint = function() {
    const GeoJsonPoint = {};
    GeoJsonPoint.is = function(value) {
      if (typeof value === "object" && value !== null) {
        const object = value;
        return object.type === "Point" && Array.isArray(object.coordinates);
      }
      return false;
    };
    GeoJsonPoint.toShape = function(object) {
      const position = object.coordinates;
      return new GeoPoint(position[0], position[1]);
    };
    return GeoJsonPoint;
  }();
  const GeoJsonMultiPoint = function() {
    const GeoJsonMultiPoint = {};
    GeoJsonMultiPoint.is = function(value) {
      if (typeof value === "object" && value !== null) {
        const object = value;
        return object.type === "MultiPoint" && Array.isArray(object.coordinates);
      }
      return false;
    };
    GeoJsonMultiPoint.toShape = function(object) {
      const positions = object.coordinates;
      const n = positions.length;
      const shapes = new Array(n);
      for (let i = 0; i < n; i += 1) {
        const position = positions[i];
        shapes[i] = new GeoPoint(position[0], position[1]);
      }
      return new GeoGroup(shapes);
    };
    return GeoJsonMultiPoint;
  }();
  const GeoJsonLineString = function() {
    const GeoJsonLineString = {};
    GeoJsonLineString.is = function(value) {
      if (typeof value === "object" && value !== null) {
        const object = value;
        return object.type === "LineString" && Array.isArray(object.coordinates);
      }
      return false;
    };
    GeoJsonLineString.toShape = function(object) {
      const lineString = object.coordinates;
      const n = lineString.length;
      if (n > 0) {
        const curves = new Array(n - 1);
        let position = lineString[0];
        let lng = position[0];
        let lat = position[1];
        for (let i = 1; i < n; i += 1) {
          position = lineString[i];
          curves[i - 1] = new GeoSegment(lng, lat, (lng = position[0], lng), (lat = position[1], 
          lat));
        }
        return new GeoSpline(curves, false);
      } else {
        return GeoSpline.empty();
      }
    };
    return GeoJsonLineString;
  }();
  const GeoJsonMultiLineString = function() {
    const GeoJsonMultiLineString = {};
    GeoJsonMultiLineString.is = function(value) {
      if (typeof value === "object" && value !== null) {
        const object = value;
        return object.type === "MultiLineString" && Array.isArray(object.coordinates);
      }
      return false;
    };
    GeoJsonMultiLineString.toShape = function(object) {
      const multiLineString = object.coordinates;
      const n = multiLineString.length;
      const shapes = new Array(n);
      for (let i = 0; i < n; i += 1) {
        const lineString = multiLineString[i];
        const m = lineString.length;
        if (m > 0) {
          const curves = new Array(m - 1);
          let position = lineString[0];
          let lng = position[0];
          let lat = position[1];
          for (let j = 1; j < m; j += 1) {
            position = lineString[j];
            curves[j - 1] = new GeoSegment(lng, lat, (lng = position[0], lng), (lat = position[1], 
            lat));
          }
          shapes[i] = new GeoSpline(curves, false);
        } else {
          shapes[i] = GeoSpline.empty();
        }
      }
      return new GeoGroup(shapes);
    };
    return GeoJsonMultiLineString;
  }();
  const GeoJsonPolygon = function() {
    const GeoJsonPolygon = {};
    GeoJsonPolygon.is = function(value) {
      if (typeof value === "object" && value !== null) {
        const object = value;
        return object.type === "Polygon" && Array.isArray(object.coordinates);
      }
      return false;
    };
    GeoJsonPolygon.toShape = function(object) {
      const polygons = object.coordinates;
      const n = polygons.length;
      const splines = new Array(n);
      for (let i = 0; i < n; i += 1) {
        const polygon = polygons[i];
        const m = polygon.length;
        if (m > 0) {
          const curves = new Array(m - 1);
          let position = polygon[0];
          let lng = position[0];
          let lat = position[1];
          for (let j = 1; j < m; j += 1) {
            position = polygon[j];
            curves[j - 1] = new GeoSegment(lng, lat, (lng = position[0], lng), (lat = position[1], 
            lat));
          }
          splines[i] = new GeoSpline(curves, true);
        } else {
          splines[i] = GeoSpline.empty();
        }
      }
      return new GeoPath(splines);
    };
    return GeoJsonPolygon;
  }();
  const GeoJsonMultiPolygon = function() {
    const GeoJsonMultiPolygon = {};
    GeoJsonMultiPolygon.is = function(value) {
      if (typeof value === "object" && value !== null) {
        const object = value;
        return object.type === "MultiPolygon" && Array.isArray(object.coordinates);
      }
      return false;
    };
    GeoJsonMultiPolygon.toShape = function(object) {
      const multiPolygon = object.coordinates;
      const n = multiPolygon.length;
      const shapes = new Array(n);
      for (let i = 0; i < n; i += 1) {
        const polygons = multiPolygon[i];
        const m = polygons.length;
        const splines = new Array(m);
        for (let j = 0; j < m; j += 1) {
          const polygon = polygons[j];
          const o = polygon.length;
          if (o > 0) {
            const curves = new Array(o - 1);
            let position = polygon[0];
            let lng = position[0];
            let lat = position[1];
            for (let k = 1; k < o; k += 1) {
              position = polygon[k];
              curves[k - 1] = new GeoSegment(lng, lat, (lng = position[0], lng), (lat = position[1], 
              lat));
            }
            splines[j] = new GeoSpline(curves, true);
          } else {
            splines[j] = GeoSpline.empty();
          }
        }
        shapes[i] = new GeoPath(splines);
      }
      return new GeoGroup(shapes);
    };
    return GeoJsonMultiPolygon;
  }();
  const GeoJsonGeometryCollection = function() {
    const GeoJsonGeometryCollection = {};
    GeoJsonGeometryCollection.is = function(value) {
      if (typeof value === "object" && value !== null) {
        const object = value;
        return object.type === "GeometryCollection" && Array.isArray(object.geometries);
      }
      return false;
    };
    GeoJsonGeometryCollection.toShape = function(object) {
      const geometries = object.geometries;
      const n = geometries.length;
      const shapes = new Array(n);
      for (let i = 0; i < n; i += 1) {
        shapes[i] = GeoJsonGeometry.toShape(geometries[i]);
      }
      return new GeoGroup(shapes);
    };
    return GeoJsonGeometryCollection;
  }();
  const GeoJsonFeature = function() {
    const GeoJsonFeature = {};
    GeoJsonFeature.is = function(value) {
      if (typeof value === "object" && value !== null) {
        const object = value;
        return object.type === "Feature" && GeoJsonGeometry.is(object.geometry) && typeof object.properties === "object";
      }
      return false;
    };
    GeoJsonFeature.toShape = function(feature) {
      const geometry = feature.geometry;
      return geometry !== null ? GeoJsonGeometry.toShape(geometry) : null;
    };
    return GeoJsonFeature;
  }();
  const GeoJsonFeatureCollection = function() {
    const GeoJsonFeatureCollection = {};
    GeoJsonFeatureCollection.is = function(value) {
      if (typeof value === "object" && value !== null) {
        const object = value;
        return object.type === "FeatureCollection" && Array.isArray(object.features);
      }
      return false;
    };
    GeoJsonFeatureCollection.toShapes = function(object) {
      const features = object.features;
      const n = features.length;
      const shapes = new Array(n);
      for (let i = 0; i < n; i += 1) {
        shapes[i] = GeoJsonFeature.toShape(features[i]);
      }
      return shapes;
    };
    return GeoJsonFeatureCollection;
  }();
  class TimeZone {
    constructor(name, offset) {
      this.name = name;
      this.offset = offset;
    }
    isUTC() {
      return this.offset === 0;
    }
    isLocal() {
      return this.offset === -(new Date).getTimezoneOffset();
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof TimeZone) {
        return this.offset === that.offset;
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(TimeZone), Numbers.hash(this.offset)));
    }
    debug(output) {
      output = output.write("TimeZone").write(46);
      if (this.name === "UTC" && this.offset === 0) {
        output = output.write("utc").write(40);
      } else if (this.name === void 0) {
        output = output.write("forOffset").write(40).debug(this.offset);
      } else {
        output = output.write("create").write(40).debug(this.name).write(", ").debug(this.offset);
      }
      output = output.write(41);
      return output;
    }
    toString() {
      return Format.debug(this);
    }
    static get utc() {
      return new TimeZone("UTC", 0);
    }
    static get local() {
      return TimeZone.forOffset(-(new Date).getTimezoneOffset());
    }
    static create(name, offset) {
      if (name === "UTC" && offset === 0) {
        return TimeZone.utc;
      } else {
        return new TimeZone(name, offset);
      }
    }
    static forName(name) {
      switch (name) {
       case "UTC":
        return TimeZone.utc;

       default:
        return null;
      }
    }
    static forOffset(offset) {
      switch (offset) {
       case 0:
        return TimeZone.utc;

       default:
        return new TimeZone(void 0, offset);
      }
    }
    static fromAny(value) {
      if (value === void 0 || value === null || value instanceof TimeZone) {
        return value;
      } else if (typeof value === "string") {
        const zone = TimeZone.forName(value);
        if (zone !== null) {
          return zone;
        }
      } else if (typeof value === "number") {
        return TimeZone.forOffset(value);
      }
      throw new TypeError("" + value);
    }
    static fromValue(value) {
      const name = value.stringValue(void 0);
      if (name !== void 0) {
        return TimeZone.forName(name);
      }
      const offset = value.numberValue(void 0);
      if (offset !== void 0) {
        return TimeZone.forOffset(offset);
      }
      return null;
    }
    static isAny(value) {
      return value instanceof TimeZone || typeof value === "string" || typeof value === "number";
    }
    static form() {
      return new TimeZoneForm(TimeZone.utc);
    }
  }
  __decorate([ Lazy ], TimeZone, "utc", null);
  __decorate([ Lazy ], TimeZone, "local", null);
  __decorate([ Lazy ], TimeZone, "form", null);
  class TimeZoneForm extends Form {
    constructor(unit) {
      super();
      Object.defineProperty(this, "unit", {
        value: unit,
        enumerable: true
      });
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new TimeZoneForm(unit);
      } else {
        return this;
      }
    }
    mold(zone) {
      zone = TimeZone.fromAny(zone);
      const name = zone.name;
      if (name !== void 0) {
        return Text.from(name);
      } else {
        return Num.from(zone.offset);
      }
    }
    cast(item) {
      const value = item.toValue();
      const zone = TimeZone.fromValue(value);
      return zone !== null ? zone : void 0;
    }
  }
  class DateTime {
    constructor(time, zone = TimeZone.utc) {
      this.time = time;
      this.zone = zone;
    }
    isDefined() {
      return isFinite(new Date(this.time).getTime());
    }
    get year() {
      return this.toUTCLocalDate().getUTCFullYear();
    }
    withYear(year, month, day, hour, minute, second, millisecond) {
      const date = this.toUTCLocalDate();
      date.setUTCFullYear(year);
      if (month !== void 0) {
        date.setUTCMonth(month);
      }
      if (day !== void 0) {
        date.setUTCDate(day);
      }
      if (hour !== void 0) {
        date.setUTCHours(hour);
      }
      if (minute !== void 0) {
        date.setUTCMinutes(minute);
      }
      if (second !== void 0) {
        date.setUTCSeconds(second);
      }
      if (millisecond !== void 0) {
        date.setUTCMilliseconds(millisecond);
      }
      return DateTime.fromUTCLocalDate(date, this.zone);
    }
    get month() {
      return this.toUTCLocalDate().getUTCMonth();
    }
    withMonth(month, day, hour, minute, second, millisecond) {
      const date = this.toUTCLocalDate();
      date.setUTCMonth(month);
      if (day !== void 0) {
        date.setUTCDate(day);
      }
      if (hour !== void 0) {
        date.setUTCHours(hour);
      }
      if (minute !== void 0) {
        date.setUTCMinutes(minute);
      }
      if (second !== void 0) {
        date.setUTCSeconds(second);
      }
      if (millisecond !== void 0) {
        date.setUTCMilliseconds(millisecond);
      }
      return DateTime.fromUTCLocalDate(date, this.zone);
    }
    get day() {
      return this.toUTCLocalDate().getUTCDate();
    }
    withDay(day, hour, minute, second, millisecond) {
      const date = this.toUTCLocalDate();
      date.setUTCDate(day);
      if (hour !== void 0) {
        date.setUTCHours(hour);
      }
      if (minute !== void 0) {
        date.setUTCMinutes(minute);
      }
      if (second !== void 0) {
        date.setUTCSeconds(second);
      }
      if (millisecond !== void 0) {
        date.setUTCMilliseconds(millisecond);
      }
      return DateTime.fromUTCLocalDate(date, this.zone);
    }
    get hour() {
      return this.toUTCLocalDate().getUTCHours();
    }
    withHour(hour, minute, second, millisecond) {
      const date = this.toUTCLocalDate();
      date.setUTCHours(hour);
      if (minute !== void 0) {
        date.setUTCMinutes(minute);
      }
      if (second !== void 0) {
        date.setUTCSeconds(second);
      }
      if (millisecond !== void 0) {
        date.setUTCMilliseconds(millisecond);
      }
      return DateTime.fromUTCLocalDate(date, this.zone);
    }
    get minute() {
      return this.toUTCLocalDate().getUTCMinutes();
    }
    withMinute(minute, second, millisecond) {
      const date = this.toUTCLocalDate();
      date.setUTCMinutes(minute);
      if (second !== void 0) {
        date.setUTCSeconds(second);
      }
      if (millisecond !== void 0) {
        date.setUTCMilliseconds(millisecond);
      }
      return DateTime.fromUTCLocalDate(date, this.zone);
    }
    get second() {
      return this.toUTCLocalDate().getUTCSeconds();
    }
    withSecond(second, millisecond) {
      const date = this.toUTCLocalDate();
      date.setUTCSeconds(second);
      if (millisecond !== void 0) {
        date.setUTCMilliseconds(millisecond);
      }
      return DateTime.fromUTCLocalDate(date, this.zone);
    }
    get millisecond() {
      return this.toUTCLocalDate().getUTCMilliseconds();
    }
    withMillisecond(millisecond) {
      const date = this.toUTCLocalDate();
      date.setUTCMilliseconds(millisecond);
      return DateTime.fromUTCLocalDate(date, this.zone);
    }
    get weekday() {
      return this.toUTCLocalDate().getUTCDay();
    }
    toUTCLocalDate() {
      return new Date(this.time + 6e4 * this.zone.offset);
    }
    toDate() {
      return new Date(this.time);
    }
    valueOf() {
      return this.time;
    }
    interpolateTo(that) {
      if (that instanceof DateTime) {
        return DateTimeInterpolator(this, that);
      } else {
        return null;
      }
    }
    compareTo(that) {
      if (that instanceof DateTime) {
        const x = this.time;
        const y = that.time;
        return x < y ? -1 : x > y ? 1 : x === y ? 0 : NaN;
      }
      return NaN;
    }
    equivalentTo(that, epsilon) {
      if (this === that) {
        return true;
      } else if (that instanceof DateTime) {
        return Numbers.equivalent(this.time, that.time, epsilon);
      }
      return false;
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof DateTime) {
        return this.time === that.time && this.zone.equals(that.zone);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(DateTime), Numbers.hash(this.time)), this.zone.hashCode()));
    }
    display(output, format = DateTimeFormat.iso8601) {
      output = format.writeDate(output, this);
      return output;
    }
    toString(format = DateTimeFormat.iso8601) {
      return format.format(this);
    }
    static current(zone) {
      zone = zone !== void 0 ? TimeZone.fromAny(zone) : TimeZone.local;
      return new DateTime(Date.now(), zone);
    }
    static fromUTCLocalDate(date, zone) {
      return new DateTime(date.getTime() - 6e4 * zone.offset, zone);
    }
    static fromInit(init, zone) {
      let time = Date.UTC(init.year !== void 0 ? init.year : 1970, init.month !== void 0 ? init.month : 0, init.day !== void 0 ? init.day : 1, init.hour !== void 0 ? init.hour : 0, init.minute !== void 0 ? init.minute : 0, init.second !== void 0 ? init.second : 0, init.millisecond !== void 0 ? init.millisecond : 0);
      if (init.zone !== void 0) {
        zone = TimeZone.fromAny(init.zone);
      }
      if (zone !== void 0) {
        zone = TimeZone.fromAny(zone);
        time += 6e4 * zone.offset;
      } else {
        zone = TimeZone.utc;
      }
      return new DateTime(time, zone);
    }
    static fromAny(value, zone) {
      if (value === void 0 || value === null || value instanceof DateTime) {
        return value;
      } else if (value instanceof Date) {
        zone = zone !== void 0 ? TimeZone.fromAny(zone) : TimeZone.utc;
        return new DateTime(value.getTime(), zone);
      } else if (typeof value === "number") {
        zone = zone !== void 0 ? TimeZone.fromAny(zone) : TimeZone.utc;
        return new DateTime(value, zone);
      } else if (typeof value === "string") {
        return DateTime.parse(value, zone);
      } else if (DateTime.isInit(value)) {
        return DateTime.fromInit(value, zone);
      }
      throw new TypeError("" + value);
    }
    static fromValue(value) {
      let positional;
      const header = value.header("date");
      if (header.isDefined()) {
        value = header;
        positional = true;
      } else {
        positional = false;
      }
      const init = {};
      value.forEach((function(item, index) {
        const key = item.key.stringValue(void 0);
        if (key !== void 0) {
          if (key === "year") {
            init.year = item.toValue().numberValue(init.year);
          } else if (key === "month") {
            init.month = item.toValue().numberValue(init.month);
          } else if (key === "day") {
            init.day = item.toValue().numberValue(init.day);
          } else if (key === "hour") {
            init.hour = item.toValue().numberValue(init.hour);
          } else if (key === "minute") {
            init.minute = item.toValue().numberValue(init.minute);
          } else if (key === "second") {
            init.second = item.toValue().numberValue(init.second);
          } else if (key === "millisecond") {
            init.millisecond = item.toValue().numberValue(init.millisecond);
          } else if (key === "zone") {
            init.zone = item.toValue().cast(TimeZone.form(), init.zone);
          }
        } else if (item instanceof Value && positional) {
          if (index === 0) {
            init.year = item.numberValue(init.year);
          } else if (index === 1) {
            init.month = item.numberValue(init.month);
          } else if (index === 2) {
            init.day = item.numberValue(init.day);
          } else if (index === 3) {
            init.hour = item.numberValue(init.hour);
          } else if (index === 4) {
            init.minute = item.numberValue(init.minute);
          } else if (index === 5) {
            init.second = item.numberValue(init.second);
          } else if (index === 6) {
            init.millisecond = item.numberValue(init.millisecond);
          } else if (index === 7) {
            init.zone = item.cast(TimeZone.form(), init.zone);
          }
        }
      }));
      if (DateTime.isInit(init)) {
        return DateTime.fromInit(init);
      }
      return null;
    }
    static parse(date, zone) {
      return DateTimeFormat.iso8601.parse(date);
    }
    static time(date) {
      if (date instanceof DateTime) {
        return date.time;
      } else if (date instanceof Date) {
        return date.getTime();
      } else if (typeof date === "number") {
        return date;
      } else if (typeof date === "string") {
        return DateTime.parse(date).time;
      } else if (DateTime.isInit(date)) {
        return DateTime.fromInit(date).time;
      }
      throw new TypeError("" + date);
    }
    static zone(date) {
      if (date instanceof DateTime) {
        return date.zone;
      } else {
        return TimeZone.utc;
      }
    }
    static isInit(value) {
      if (typeof value === "object" && value !== null) {
        const init = value;
        return (typeof init.year === "undefined" || typeof init.year === "number") && (typeof init.month === "undefined" || typeof init.month === "number") && (typeof init.day === "undefined" || typeof init.day === "number") && (typeof init.hour === "undefined" || typeof init.hour === "number") && (typeof init.minute === "undefined" || typeof init.minute === "number") && (typeof init.second === "undefined" || typeof init.second === "number") && (typeof init.millisecond === "undefined" || typeof init.millisecond === "number") && (typeof init.zone === "undefined" || TimeZone.isAny(init.zone)) && (typeof init.year === "number" || typeof init.month === "number" || typeof init.day === "number" || typeof init.hour === "number" || typeof init.minute === "number" || typeof init.second === "number" || typeof init.millisecond === "number");
      }
      return false;
    }
    static isAny(value) {
      return value instanceof DateTime || value instanceof Date || typeof value === "number" || typeof value === "string" || DateTime.isInit(value);
    }
    static form() {
      return new DateTimeForm(new DateTime(0));
    }
  }
  __decorate([ Lazy ], DateTime, "form", null);
  const DateTimeInterpolator = function(_super) {
    const DateTimeInterpolator = function(d0, d1) {
      const interpolator = function(u) {
        const d0 = interpolator[0];
        const d1 = interpolator[1];
        return new DateTime(d0.time + u * (d1.time - d0.time), d1.zone);
      };
      Object.setPrototypeOf(interpolator, DateTimeInterpolator.prototype);
      interpolator[0] = d0;
      interpolator[1] = d1;
      return interpolator;
    };
    DateTimeInterpolator.prototype = Object.create(_super.prototype);
    DateTimeInterpolator.prototype.constructor = DateTimeInterpolator;
    return DateTimeInterpolator;
  }(Interpolator);
  class DateTimeForm extends Form {
    constructor(unit) {
      super();
      Object.defineProperty(this, "unit", {
        value: unit,
        enumerable: true
      });
    }
    withUnit(unit) {
      if (unit !== this.unit) {
        return new DateTimeForm(unit);
      } else {
        return this;
      }
    }
    mold(date) {
      date = DateTime.fromAny(date);
      return Text.from(date.toString());
    }
    cast(value) {
      let date = null;
      try {
        date = DateTime.fromValue(value);
        if (date === void 0) {
          const millis = value.numberValue(void 0);
          if (millis !== void 0) {
            date = new DateTime(millis);
          } else {
            const string = value.stringValue(void 0);
            if (string !== void 0) {
              date = DateTime.parse(string);
            }
          }
        }
      } catch (e) {}
      return date !== null ? date : void 0;
    }
  }
  class DateTimeParser extends Parser {
    constructor(dateParser) {
      super();
      this.dateParser = dateParser;
    }
    feed(input) {
      return DateTimeParser.parse(input, this.dateParser);
    }
    static parse(input, dateParser) {
      dateParser = dateParser.feed(input);
      if (dateParser.isDone()) {
        return Parser.done(DateTime.fromAny(dateParser.bind()));
      } else if (dateParser.isError()) {
        return dateParser.asError();
      }
      return new DateTimeParser(dateParser);
    }
  }
  class DateTimeLocale {
    constructor(periods = DateTimeLocale.Periods, weekdays = DateTimeLocale.Weekdays, shortWeekdays = DateTimeLocale.ShortWeekdays, months = DateTimeLocale.Months, shortMonths = DateTimeLocale.ShortMonths) {
      this.periods = periods;
      this.weekdays = weekdays;
      this.shortWeekdays = shortWeekdays;
      this.months = months;
      this.shortMonths = shortMonths;
    }
    static standard() {
      return new DateTimeLocale;
    }
  }
  DateTimeLocale.Periods = [ "AM", "PM" ];
  DateTimeLocale.Weekdays = [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ];
  DateTimeLocale.ShortWeekdays = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ];
  DateTimeLocale.Months = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ];
  DateTimeLocale.ShortMonths = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
  __decorate([ Lazy ], DateTimeLocale, "standard", null);
  const DateTimeSpecifiers = function() {
    const DateTimeSpecifiers = {};
    let standard = null;
    DateTimeSpecifiers.standard = function(locale) {
      let specifiers = null;
      if (locale === void 0) {
        locale = DateTimeLocale.standard();
      }
      if (locale === DateTimeLocale.standard()) {
        specifiers = standard;
      }
      if (specifiers === null) {
        specifiers = {
          Y: DateTimeFormat.year,
          m: DateTimeFormat.monthOfYear,
          B: DateTimeFormat.month.withLocale(locale),
          b: DateTimeFormat.shortMonth.withLocale(locale),
          d: DateTimeFormat.dayOfMonth,
          A: DateTimeFormat.weekday.withLocale(locale),
          a: DateTimeFormat.shortWeekday.withLocale(locale),
          H: DateTimeFormat.hour24,
          I: DateTimeFormat.hour12,
          p: DateTimeFormat.period.withLocale(locale),
          M: DateTimeFormat.minute,
          S: DateTimeFormat.second,
          L: DateTimeFormat.millisecond
        };
        if (locale === DateTimeLocale.standard()) {
          standard = specifiers;
        }
      }
      return specifiers;
    };
    return DateTimeSpecifiers;
  }();
  class DateTimeFormat {
    withLocale(locale) {
      return this;
    }
    format(date) {
      date = DateTime.fromAny(date);
      let output = Unicode.stringOutput();
      output = this.writeDate(output, date);
      return output.bind();
    }
    parse(input) {
      if (typeof input === "string") {
        input = Unicode.stringInput(input);
      }
      while (input.isCont() && Unicode.isSpace(input.head())) {
        input = input.step();
      }
      let parser = this.parseDate(input, {});
      if (parser.isDone()) {
        while (input.isCont() && Unicode.isSpace(input.head())) {
          input = input.step();
        }
      }
      if (input.isCont() && !parser.isError()) {
        parser = Parser.error(Diagnostic.unexpected(input));
      }
      return parser.bind();
    }
    parseDate(input, date) {
      const dateParser = this.parseDateTime(input, date);
      if (dateParser.isDone()) {
        return Parser.done(DateTime.fromAny(dateParser.bind()));
      } else if (dateParser.isError()) {
        return dateParser.asError();
      }
      return new DateTimeParser(dateParser);
    }
    static get year() {
      return new YearFormat;
    }
    static get monthOfYear() {
      return new MonthOfYearFormat;
    }
    static get month() {
      return new MonthFormat(DateTimeLocale.standard());
    }
    static get shortMonth() {
      return new ShortMonthFormat(DateTimeLocale.standard());
    }
    static get dayOfMonth() {
      return new DayOfMonthFormat;
    }
    static get weekday() {
      return new WeekdayFormat(DateTimeLocale.standard());
    }
    static get shortWeekday() {
      return new ShortWeekdayFormat(DateTimeLocale.standard());
    }
    static get hour24() {
      return new Hour24Format;
    }
    static get hour12() {
      return new Hour12Format;
    }
    static get period() {
      return new PeriodFormat(DateTimeLocale.standard());
    }
    static get minute() {
      return new MinuteFormat;
    }
    static get second() {
      return new SecondFormat;
    }
    static get millisecond() {
      return new MillisecondFormat;
    }
    static pattern(pattern, specifiers) {
      if (specifiers === void 0 || specifiers instanceof DateTimeLocale) {
        specifiers = DateTimeSpecifiers.standard(specifiers);
      }
      return new PatternFormat(pattern, specifiers);
    }
    static get iso8601() {
      return new PatternFormat("%Y-%m-%dT%H:%M:%S.%LZ", DateTimeSpecifiers.standard());
    }
    static parseDateNumber(input, factory, desc, minDigits, maxDigits, date, value = 0, step = 0) {
      let c = 0;
      while (step < maxDigits) {
        if (input.isCont() && (c = input.head(), Base10.isDigit(c))) {
          input.step();
          value = 10 * value + Base10.decodeDigit(c);
          step += 1;
          continue;
        }
        break;
      }
      if (!input.isEmpty()) {
        if (step >= minDigits) {
          return factory.term(value, date || {}, input);
        } else {
          return Parser.error(Diagnostic.expected(desc, input));
        }
      }
      return factory.cont(date !== void 0 ? date : {}, value, step, input);
    }
    static parseDateString(input, factory, locale, date, output) {
      let c = 0;
      output = output !== void 0 ? output : Unicode.stringOutput();
      do {
        if (input.isCont() && (c = input.head(), Unicode.isAlpha(c))) {
          input.step();
          output.write(c);
          continue;
        } else if (!input.isEmpty()) {
          return factory.term(locale, output.bind(), date !== void 0 ? date : {}, input);
        }
        break;
      } while (true);
      return factory.cont(locale, date !== void 0 ? date : {}, output, input);
    }
    static writeDateNumber2(output, value) {
      const c1 = 48 + value % 10;
      value /= 10;
      const c0 = 48 + value % 10;
      output = output.write(c0).write(c1);
      return output;
    }
    static writeDateNumber3(output, value) {
      const c2 = 48 + value % 10;
      value /= 10;
      const c1 = 48 + value % 10;
      value /= 10;
      const c0 = 48 + value % 10;
      output = output.write(c0).write(c1).write(c2);
      return output;
    }
    static writeDateNumber4(output, value) {
      const c3 = 48 + value % 10;
      value /= 10;
      const c2 = 48 + value % 10;
      value /= 10;
      const c1 = 48 + value % 10;
      value /= 10;
      const c0 = 48 + value % 10;
      output = output.write(c0).write(c1).write(c2).write(c3);
      return output;
    }
  }
  __decorate([ Lazy ], DateTimeFormat, "year", null);
  __decorate([ Lazy ], DateTimeFormat, "monthOfYear", null);
  __decorate([ Lazy ], DateTimeFormat, "month", null);
  __decorate([ Lazy ], DateTimeFormat, "shortMonth", null);
  __decorate([ Lazy ], DateTimeFormat, "dayOfMonth", null);
  __decorate([ Lazy ], DateTimeFormat, "weekday", null);
  __decorate([ Lazy ], DateTimeFormat, "shortWeekday", null);
  __decorate([ Lazy ], DateTimeFormat, "hour24", null);
  __decorate([ Lazy ], DateTimeFormat, "hour12", null);
  __decorate([ Lazy ], DateTimeFormat, "period", null);
  __decorate([ Lazy ], DateTimeFormat, "minute", null);
  __decorate([ Lazy ], DateTimeFormat, "second", null);
  __decorate([ Lazy ], DateTimeFormat, "millisecond", null);
  __decorate([ Lazy ], DateTimeFormat, "iso8601", null);
  class YearFormat extends DateTimeFormat {
    writeDate(output, date) {
      output = DateTimeFormat.writeDateNumber4(output, date.year);
      return output;
    }
    parseDateTime(input, date) {
      return YearParser.parse(input, date);
    }
  }
  class MonthOfYearFormat extends DateTimeFormat {
    writeDate(output, date) {
      output = DateTimeFormat.writeDateNumber2(output, date.month + 1);
      return output;
    }
    parseDateTime(input, date) {
      return MonthOfYearParser.parse(input, date);
    }
  }
  class MonthFormat extends DateTimeFormat {
    constructor(locale) {
      super();
      this.locale = locale;
    }
    withLocale(locale) {
      if (locale !== this.locale) {
        return new MonthFormat(locale);
      } else {
        return this;
      }
    }
    writeDate(output, date) {
      output = output.write(this.locale.months[date.month]);
      return output;
    }
    parseDateTime(input, date) {
      return MonthParser.parse(input, this.locale, date);
    }
  }
  class ShortMonthFormat extends DateTimeFormat {
    constructor(locale) {
      super();
      this.locale = locale;
    }
    withLocale(locale) {
      if (locale !== this.locale) {
        return new ShortMonthFormat(locale);
      } else {
        return this;
      }
    }
    writeDate(output, date) {
      output = output.write(this.locale.shortMonths[date.month]);
      return output;
    }
    parseDateTime(input, date) {
      return ShortMonthParser.parse(input, this.locale, date);
    }
  }
  class DayOfMonthFormat extends DateTimeFormat {
    writeDate(output, date) {
      output = DateTimeFormat.writeDateNumber2(output, date.day);
      return output;
    }
    parseDateTime(input, date) {
      return DayOfMonthParser.parse(input, date);
    }
  }
  class WeekdayFormat extends DateTimeFormat {
    constructor(locale) {
      super();
      this.locale = locale;
    }
    withLocale(locale) {
      if (locale !== this.locale) {
        return new WeekdayFormat(locale);
      } else {
        return this;
      }
    }
    writeDate(output, date) {
      output = output.write(this.locale.weekdays[date.weekday]);
      return output;
    }
    parseDateTime(input, date) {
      return WeekdayParser.parse(input, this.locale, date);
    }
  }
  class ShortWeekdayFormat extends DateTimeFormat {
    constructor(locale) {
      super();
      this.locale = locale;
    }
    withLocale(locale) {
      if (locale !== this.locale) {
        return new ShortWeekdayFormat(locale);
      } else {
        return this;
      }
    }
    writeDate(output, date) {
      output = output.write(this.locale.shortWeekdays[date.weekday]);
      return output;
    }
    parseDateTime(input, date) {
      return ShortWeekdayParser.parse(input, this.locale, date);
    }
  }
  class Hour24Format extends DateTimeFormat {
    writeDate(output, date) {
      output = DateTimeFormat.writeDateNumber2(output, date.hour);
      return output;
    }
    parseDateTime(input, date) {
      return Hour24Parser.parse(input, date);
    }
  }
  class Hour12Format extends DateTimeFormat {
    writeDate(output, date) {
      let hour = date.hour % 12;
      if (hour === 0) {
        hour = 12;
      }
      output = DateTimeFormat.writeDateNumber2(output, hour);
      return output;
    }
    parseDateTime(input, date) {
      return Hour12Parser.parse(input, date);
    }
  }
  class PeriodFormat extends DateTimeFormat {
    constructor(locale) {
      super();
      this.locale = locale;
    }
    withLocale(locale) {
      if (locale !== this.locale) {
        return new PeriodFormat(locale);
      } else {
        return this;
      }
    }
    writeDate(output, date) {
      output = output.write(this.locale.periods[date.hour >= 12 ? 1 : 0]);
      return output;
    }
    parseDateTime(input, date) {
      return PeriodParser.parse(input, this.locale, date);
    }
  }
  class MinuteFormat extends DateTimeFormat {
    writeDate(output, date) {
      output = DateTimeFormat.writeDateNumber2(output, date.minute);
      return output;
    }
    parseDateTime(input, date) {
      return MinuteParser.parse(input, date);
    }
  }
  class SecondFormat extends DateTimeFormat {
    writeDate(output, date) {
      output = DateTimeFormat.writeDateNumber2(output, date.second);
      return output;
    }
    parseDateTime(input, date) {
      return SecondParser.parse(input, date);
    }
  }
  class MillisecondFormat extends DateTimeFormat {
    writeDate(output, date) {
      output = DateTimeFormat.writeDateNumber3(output, date.millisecond);
      return output;
    }
    parseDateTime(input, date) {
      return MillisecondParser.parse(input, date);
    }
  }
  class PatternFormat extends DateTimeFormat {
    constructor(pattern, specifiers) {
      super();
      this.pattern = pattern;
      this.specifiers = specifiers;
    }
    writeDate(output, date) {
      const pattern = this.pattern;
      const specifiers = this.specifiers;
      let i = 0;
      let j = 0;
      const n = pattern.length;
      while (j < n) {
        if (pattern.charCodeAt(j) === 37) {
          if (i !== j) {
            output = output.write(pattern.slice(i, j));
          }
          const s = pattern.charAt(j + 1);
          const f = specifiers[s];
          if (f !== void 0) {
            output = f.writeDate(output, date);
          }
          j += 2;
          i = j;
        } else {
          j += 1;
        }
      }
      if (i !== j) {
        output = output.write(pattern.slice(i, j));
      }
      return output;
    }
    parseDateTime(input, date) {
      return PatternParser.parse(input, this.pattern, this.specifiers, date);
    }
  }
  class YearParser extends Parser {
    constructor(date, year, step) {
      super();
      this.date = date;
      this.year = year;
      this.step = step;
    }
    feed(input) {
      return YearParser.parse(input, this.date, this.year, this.step);
    }
    static parse(input, date, year, step) {
      return DateTimeFormat.parseDateNumber(input, YearParser, "full year", 4, 4, date, year, step);
    }
    static term(year, date) {
      date.year = year;
      return Parser.done(date);
    }
    static cont(date, year, step) {
      return new YearParser(date, year, step);
    }
  }
  class MonthOfYearParser extends Parser {
    constructor(date, month, step) {
      super();
      this.date = date;
      this.month = month;
      this.step = step;
    }
    feed(input) {
      return MonthOfYearParser.parse(input, this.date, this.month, this.step);
    }
    static parse(input, date, month, step) {
      return DateTimeFormat.parseDateNumber(input, MonthOfYearParser, "month number", 2, 2, date, month, step);
    }
    static term(month, date) {
      date.month = month - 1;
      return Parser.done(date);
    }
    static cont(date, month, step) {
      return new MonthOfYearParser(date, month, step);
    }
  }
  class MonthParser extends Parser {
    constructor(locale, date, output) {
      super();
      this.locale = locale;
      this.date = date;
      this.output = output;
    }
    feed(input) {
      return MonthParser.parse(input, this.locale, this.date, this.output);
    }
    static parse(input, locale, date, output) {
      return DateTimeFormat.parseDateString(input, MonthParser, locale, date, output);
    }
    static term(locale, value, date, input) {
      const month = locale.months.indexOf(value);
      if (month >= 0) {
        date.month = month;
        return Parser.done(date);
      } else {
        return Parser.error(Diagnostic.message("expected month, but found " + value, input));
      }
    }
    static cont(locale, date, output) {
      return new MonthParser(locale, date, output);
    }
  }
  class ShortMonthParser extends Parser {
    constructor(locale, date, output) {
      super();
      this.locale = locale;
      this.date = date;
      this.output = output;
    }
    feed(input) {
      return ShortMonthParser.parse(input, this.locale, this.date, this.output);
    }
    static parse(input, locale, date, output) {
      return DateTimeFormat.parseDateString(input, ShortMonthParser, locale, date, output);
    }
    static term(locale, value, date, input) {
      const month = locale.shortMonths.indexOf(value);
      if (month >= 0) {
        date.month = month;
        return Parser.done(date);
      } else {
        return Parser.error(Diagnostic.message("expected short month, but found " + value, input));
      }
    }
    static cont(locale, date, output) {
      return new ShortMonthParser(locale, date, output);
    }
  }
  class DayOfMonthParser extends Parser {
    constructor(date, day, step) {
      super();
      this.date = date;
      this.day = day;
      this.step = step;
    }
    feed(input) {
      return DayOfMonthParser.parse(input, this.date, this.day, this.step);
    }
    static parse(input, date, day, step) {
      return DateTimeFormat.parseDateNumber(input, DayOfMonthParser, "day of month", 2, 2, date, day, step);
    }
    static term(day, date) {
      date.day = day;
      return Parser.done(date);
    }
    static cont(date, month, step) {
      return new DayOfMonthParser(date, month, step);
    }
  }
  class WeekdayParser extends Parser {
    constructor(locale, date, output) {
      super();
      this.locale = locale;
      this.date = date;
      this.output = output;
    }
    feed(input) {
      return WeekdayParser.parse(input, this.locale, this.date, this.output);
    }
    static parse(input, locale, date, output) {
      return DateTimeFormat.parseDateString(input, WeekdayParser, locale, date, output);
    }
    static term(locale, value, date, input) {
      const day = locale.weekdays.indexOf(value);
      if (day >= 0) {
        return Parser.done(date);
      } else {
        return Parser.error(Diagnostic.message("expected weekday, but found " + value, input));
      }
    }
    static cont(locale, date, output) {
      return new WeekdayParser(locale, date, output);
    }
  }
  class ShortWeekdayParser extends Parser {
    constructor(locale, date, output) {
      super();
      this.locale = locale;
      this.date = date;
      this.output = output;
    }
    feed(input) {
      return ShortWeekdayParser.parse(input, this.locale, this.date, this.output);
    }
    static parse(input, locale, date, output) {
      return DateTimeFormat.parseDateString(input, ShortWeekdayParser, locale, date, output);
    }
    static term(locale, value, date, input) {
      const day = locale.shortWeekdays.indexOf(value);
      if (day >= 0) {
        return Parser.done(date);
      } else {
        return Parser.error(Diagnostic.message("expected short weekday, but found " + value, input));
      }
    }
    static cont(locale, date, output) {
      return new ShortWeekdayParser(locale, date, output);
    }
  }
  class Hour24Parser extends Parser {
    constructor(date, hour, step) {
      super();
      this.date = date;
      this.hour = hour;
      this.step = step;
    }
    feed(input) {
      return Hour24Parser.parse(input, this.date, this.hour, this.step);
    }
    static parse(input, date, hour, step) {
      return DateTimeFormat.parseDateNumber(input, Hour24Parser, "hour (24)", 2, 2, date, hour, step);
    }
    static term(hour, date) {
      date.hour = hour;
      return Parser.done(date);
    }
    static cont(date, hour, step) {
      return new Hour24Parser(date, hour, step);
    }
  }
  class Hour12Parser extends Parser {
    constructor(date, hour, step) {
      super();
      this.date = date;
      this.hour = hour;
      this.step = step;
    }
    feed(input) {
      return Hour12Parser.parse(input, this.date, this.hour, this.step);
    }
    static parse(input, date, hour, step) {
      return DateTimeFormat.parseDateNumber(input, Hour12Parser, "hour (12)", 2, 2, date, hour, step);
    }
    static term(hour, date) {
      date.hour = (date.hour !== void 0 ? date.hour : 0) + hour;
      return Parser.done(date);
    }
    static cont(date, hour, step) {
      return new Hour12Parser(date, hour, step);
    }
  }
  class PeriodParser extends Parser {
    constructor(locale, date, output) {
      super();
      this.locale = locale;
      this.date = date;
      this.output = output;
    }
    feed(input) {
      return PeriodParser.parse(input, this.locale, this.date, this.output);
    }
    static parse(input, locale, date, output) {
      return DateTimeFormat.parseDateString(input, PeriodParser, locale, date, output);
    }
    static term(locale, value, date, input) {
      const period = locale.months.indexOf(value);
      if (period >= 0) {
        date.hour = (date.hour || 0) + 12 * period;
        return Parser.done(date);
      } else {
        return Parser.error(Diagnostic.message("expected period of day, but found " + value, input));
      }
    }
    static cont(locale, date, output) {
      return new PeriodParser(locale, date, output);
    }
  }
  class MinuteParser extends Parser {
    constructor(date, minute, step) {
      super();
      this.date = date;
      this.minute = minute;
      this.step = step;
    }
    feed(input) {
      return MinuteParser.parse(input, this.date, this.minute, this.step);
    }
    static parse(input, date, minute, step) {
      return DateTimeFormat.parseDateNumber(input, MinuteParser, "minute", 2, 2, date, minute, step);
    }
    static term(minute, date) {
      date.minute = minute;
      return Parser.done(date);
    }
    static cont(date, minute, step) {
      return new MinuteParser(date, minute, step);
    }
  }
  class SecondParser extends Parser {
    constructor(date, second, step) {
      super();
      this.date = date;
      this.second = second;
      this.step = step;
    }
    feed(input) {
      return SecondParser.parse(input, this.date, this.second, this.step);
    }
    static parse(input, date, second, step) {
      return DateTimeFormat.parseDateNumber(input, SecondParser, "second", 2, 2, date, second, step);
    }
    static term(second, date) {
      date.second = second;
      return Parser.done(date);
    }
    static cont(date, second, step) {
      return new SecondParser(date, second, step);
    }
  }
  class MillisecondParser extends Parser {
    constructor(date, millisecond, step) {
      super();
      this.date = date;
      this.millisecond = millisecond;
      this.step = step;
    }
    feed(input) {
      return MillisecondParser.parse(input, this.date, this.millisecond, this.step);
    }
    static parse(input, date, millisecond, step) {
      return DateTimeFormat.parseDateNumber(input, MillisecondParser, "millisecond", 1, 3, date, millisecond, step);
    }
    static term(millisecond, date) {
      date.millisecond = millisecond;
      return Parser.done(date);
    }
    static cont(date, millisecond, step) {
      return new MillisecondParser(date, millisecond, step);
    }
  }
  class PatternParser extends Parser {
    constructor(pattern, specifiers, date, dateParser, step) {
      super();
      this.pattern = pattern;
      this.specifiers = specifiers;
      this.date = date;
      this.dateParser = dateParser;
      this.step = step;
    }
    feed(input) {
      return PatternParser.parse(input, this.pattern, this.specifiers, this.date, this.dateParser, this.step);
    }
    static parse(input, pattern, specifiers, date = {}, dateParser, step = 0) {
      let c = 0;
      const n = pattern.length;
      while (step < n) {
        const p = pattern.charCodeAt(step);
        if (p === 37) {
          if (dateParser === void 0) {
            const s = pattern.charAt(step + 1);
            const format = specifiers[s];
            if (format !== void 0) {
              dateParser = format.parseDateTime(input, date);
            } else {
              return Parser.error(Diagnostic.message("unknown format specifier: " + s, input));
            }
          } else {
            dateParser = dateParser.feed(input);
          }
          if (dateParser.isDone()) {
            date = dateParser.bind();
            dateParser = void 0;
            step += 2;
            continue;
          } else if (dateParser.isError()) {
            return dateParser.asError();
          }
        } else if (input.isCont()) {
          c = input.head();
          if (c === p) {
            input.step();
            step += 1;
            continue;
          } else {
            return Parser.error(Diagnostic.expected(p, input));
          }
        } else if (!input.isEmpty()) {
          return Parser.error(Diagnostic.unexpected(input));
        }
        break;
      }
      if (step === n) {
        return Parser.done(date);
      }
      return new PatternParser(pattern, specifiers, date, dateParser, step);
    }
  }
  class TimeInterval {
    next(d, k) {
      return this.floor(this.offset(d, k));
    }
    ceil(d) {
      if (d instanceof DateTime) {
        d = new DateTime(d.time - 1, d.zone);
      } else {
        d = DateTime.time(d) - 1;
      }
      return this.next(this.floor(d), 1);
    }
    round(t) {
      const d = DateTime.fromAny(t);
      const d0 = this.floor(d);
      const d1 = this.ceil(d);
      return d.time - d0.time < d1.time - d.time ? d0 : d1;
    }
    range(t0, t1, step) {
      let d0 = this.ceil(t0);
      const d1 = DateTime.time(t1);
      const ds = [];
      step = typeof step === "number" ? Math.floor(step) : 1;
      if (step > 0) {
        while (d0.isDefined() && d0.time < d1) {
          ds.push(d0);
          d0 = this.next(d0, step);
        }
      }
      return ds;
    }
    filter(predicate) {
      return new FilterTimeInterval(this, predicate);
    }
    static get year() {
      return new YearInterval;
    }
    static get month() {
      return new MonthInterval;
    }
    static get week() {
      return new WeekInterval;
    }
    static get day() {
      return new DayInterval;
    }
    static get hour() {
      return new HourInterval;
    }
    static get minute() {
      return new MinuteInterval;
    }
    static get second() {
      return new SecondInterval;
    }
    static get millisecond() {
      return new MillisecondInterval;
    }
    static years(d0, d1, step) {
      return TimeInterval.year.range(d0, d1, step);
    }
    static months(d0, d1, step) {
      return TimeInterval.month.range(d0, d1, step);
    }
    static weeks(d0, d1, step) {
      return TimeInterval.week.range(d0, d1, step);
    }
    static days(d0, d1, step) {
      return TimeInterval.day.range(d0, d1, step);
    }
    static hours(d0, d1, step) {
      return TimeInterval.hour.range(d0, d1, step);
    }
    static minutes(d0, d1, step) {
      return TimeInterval.minute.range(d0, d1, step);
    }
    static seconds(d0, d1, step) {
      return TimeInterval.second.range(d0, d1, step);
    }
    static milliseconds(d0, d1, step) {
      return TimeInterval.millisecond.range(d0, d1, step);
    }
  }
  TimeInterval.MillisPerSecond = 1e3;
  TimeInterval.MillisPerMinute = 60 * TimeInterval.MillisPerSecond;
  TimeInterval.MillisPerHour = 60 * TimeInterval.MillisPerMinute;
  __decorate([ Lazy ], TimeInterval, "year", null);
  __decorate([ Lazy ], TimeInterval, "month", null);
  __decorate([ Lazy ], TimeInterval, "week", null);
  __decorate([ Lazy ], TimeInterval, "day", null);
  __decorate([ Lazy ], TimeInterval, "hour", null);
  __decorate([ Lazy ], TimeInterval, "minute", null);
  __decorate([ Lazy ], TimeInterval, "second", null);
  __decorate([ Lazy ], TimeInterval, "millisecond", null);
  class UnitTimeInterval extends TimeInterval {}
  class FilterTimeInterval extends TimeInterval {
    constructor(unit, predicate) {
      super();
      this.unit = unit;
      this.predicate = predicate;
    }
    offset(t, k) {
      let d = DateTime.fromAny(t);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      while (k < 0) {
        do {
          d = this.unit.offset(d, -1);
        } while (d.isDefined() && !this.predicate(d));
        k += 1;
      }
      while (k > 0) {
        do {
          d = this.unit.offset(d, 1);
        } while (d.isDefined() && !this.predicate(d));
        k -= 1;
      }
      return d;
    }
    floor(t) {
      let d = DateTime.fromAny(t);
      while (d = this.unit.floor(d), d.isDefined() && !this.predicate(d)) {
        d = new DateTime(d.time - 1, d.zone);
      }
      return d;
    }
  }
  class YearInterval extends UnitTimeInterval {
    offset(t, k) {
      let d = DateTime.fromAny(t);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      d = d.withYear(d.year + k);
      return d;
    }
    next(t, k) {
      const d = DateTime.fromAny(t);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      return d.withYear(d.year + k).withMonth(0, 1).withHour(0, 0, 0, 0);
    }
    floor(t) {
      const d = DateTime.fromAny(t);
      return d.withMonth(0, 1).withHour(0, 0, 0, 0);
    }
    ceil(t) {
      let d = DateTime.fromAny(t);
      d = new DateTime(d.time - 1, d.zone);
      d = d.withMonth(0, 1).withHour(0, 0, 0, 0);
      d = d.withYear(d.year + 1);
      return d.withMonth(0, 1).withHour(0, 0, 0, 0);
    }
    every(k) {
      if (k === 1) {
        return this;
      } else if (isFinite(k) && k >= 1) {
        return new YearsInterval(k);
      } else {
        throw new Error("" + k);
      }
    }
  }
  class YearsInterval extends TimeInterval {
    constructor(stride) {
      super();
      this.stride = stride;
    }
    offset(t, k) {
      const d = DateTime.fromAny(t);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      return d.withYear(d.year + k * this.stride);
    }
    next(t, k) {
      let d = DateTime.fromAny(t);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      d = d.withYear(Math.floor((d.year + k * this.stride) / this.stride) * this.stride);
      return d.withMonth(0, 1).withHour(0, 0, 0, 0);
    }
    floor(t) {
      let d = DateTime.fromAny(t);
      d = d.withYear(Math.floor(d.year / this.stride) * this.stride);
      return d.withMonth(0, 1).withHour(0, 0, 0, 0);
    }
    ceil(t) {
      let d = DateTime.fromAny(t);
      d = new DateTime(d.time - 1, d.zone);
      d = d.withYear(Math.floor(d.year / this.stride) * this.stride);
      d = d.withMonth(0, 1).withHour(0, 0, 0, 0);
      d = d.withYear(Math.floor((d.year + this.stride) / this.stride) * this.stride);
      return d.withMonth(0, 1).withHour(0, 0, 0, 0);
    }
  }
  class MonthInterval extends UnitTimeInterval {
    offset(t, k) {
      const d = DateTime.fromAny(t);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      return d.withMonth(d.month + k);
    }
    next(t, k) {
      let d = DateTime.fromAny(t);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      d = d.withMonth(d.month + k);
      return d.withDay(1).withHour(0, 0, 0, 0);
    }
    floor(t) {
      const d = DateTime.fromAny(t);
      return d.withDay(1).withHour(0, 0, 0, 0);
    }
    ceil(t) {
      let d = DateTime.fromAny(t);
      d = new DateTime(d.time - 1, d.zone);
      d = d.withDay(1).withHour(0, 0, 0, 0);
      d = d.withMonth(d.month + 1);
      return d.withDay(1).withHour(0, 0, 0, 0);
    }
    every(k) {
      if (k === 1) {
        return this;
      } else if (isFinite(k) && k >= 1) {
        return new FilterTimeInterval(this, MonthInterval.modulo.bind(void 0, k));
      } else {
        throw new Error("" + k);
      }
    }
    static modulo(k, d) {
      const month = d.month;
      return isFinite(month) && month % k === 0;
    }
  }
  class WeekInterval extends TimeInterval {
    constructor(day = 0) {
      super();
      this.day = day;
    }
    offset(t, k) {
      const d = DateTime.fromAny(t);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      return d.withDay(d.day + 7 * k);
    }
    next(t, k) {
      let d = DateTime.fromAny(t);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      d = d.withDay(d.day + 7 * k);
      d = d.withDay(d.day - (d.weekday + 7 - this.day) % 7);
      return d.withHour(0, 0, 0, 0);
    }
    floor(t) {
      let d = DateTime.fromAny(t);
      d = d.withDay(d.day - (d.weekday + 7 - this.day) % 7);
      return d.withHour(0, 0, 0, 0);
    }
    ceil(t) {
      let d = DateTime.fromAny(t);
      d = new DateTime(d.time - 1, d.zone);
      d = d.withDay(d.day - (d.weekday + 7 - this.day) % 7);
      d = d.withHour(0, 0, 0, 0);
      d = d.withDay(d.day + 7);
      return d.withHour(0, 0, 0, 0);
    }
  }
  class DayInterval extends UnitTimeInterval {
    offset(t, k) {
      const d = DateTime.fromAny(t);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      return d.withDay(d.day + k);
    }
    next(t, k) {
      let d = DateTime.fromAny(t);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      d = d.withDay(d.day + k);
      return d.withHour(0, 0, 0, 0);
    }
    floor(t) {
      const d = DateTime.fromAny(t);
      return d.withHour(0, 0, 0, 0);
    }
    ceil(t) {
      let d = DateTime.fromAny(t);
      d = new DateTime(d.time - 1, d.zone);
      d = d.withHour(0, 0, 0, 0);
      d = d.withDay(d.day + 1);
      return d.withHour(0, 0, 0, 0);
    }
    every(k) {
      if (k === 1) {
        return this;
      } else if (isFinite(k) && k >= 1) {
        return new FilterTimeInterval(this, DayInterval.modulo.bind(void 0, k));
      } else {
        throw new Error("" + k);
      }
    }
    static modulo(k, d) {
      const day = d.day;
      return isFinite(day) && day % k === 0;
    }
  }
  class HourInterval extends UnitTimeInterval {
    offset(d, k) {
      const z = DateTime.zone(d);
      d = DateTime.time(d);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      d += k * TimeInterval.MillisPerHour;
      return new DateTime(d, z);
    }
    next(d, k) {
      const z = DateTime.zone(d);
      d = DateTime.time(d);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      d += k * TimeInterval.MillisPerHour;
      let dtz = z.offset * TimeInterval.MillisPerMinute % TimeInterval.MillisPerHour;
      if (dtz < 0) {
        dtz += TimeInterval.MillisPerHour;
      }
      d = Math.floor((d - dtz) / TimeInterval.MillisPerHour) * TimeInterval.MillisPerHour + dtz;
      return new DateTime(d, z);
    }
    floor(d) {
      const z = DateTime.zone(d);
      d = DateTime.time(d);
      let dtz = z.offset * TimeInterval.MillisPerMinute % TimeInterval.MillisPerHour;
      if (dtz < 0) {
        dtz += TimeInterval.MillisPerHour;
      }
      d = Math.floor((d - dtz) / TimeInterval.MillisPerHour) * TimeInterval.MillisPerHour + dtz;
      return new DateTime(d, z);
    }
    ceil(d) {
      const z = DateTime.zone(d);
      d = DateTime.time(d);
      d -= 1;
      let dtz = z.offset * TimeInterval.MillisPerMinute % TimeInterval.MillisPerHour;
      if (dtz < 0) {
        dtz += TimeInterval.MillisPerHour;
      }
      d = Math.floor((d - dtz) / TimeInterval.MillisPerHour) * TimeInterval.MillisPerHour + dtz + TimeInterval.MillisPerHour;
      d = Math.floor((d - dtz) / TimeInterval.MillisPerHour) * TimeInterval.MillisPerHour + dtz;
      return new DateTime(d, z);
    }
    every(k) {
      if (k === 1) {
        return this;
      } else if (isFinite(k) && k >= 1) {
        return new FilterTimeInterval(this, HourInterval.modulo.bind(void 0, k));
      } else {
        throw new Error("" + k);
      }
    }
    static modulo(k, d) {
      const hour = d.hour;
      return isFinite(hour) && hour % k === 0;
    }
  }
  class MinuteInterval extends UnitTimeInterval {
    offset(d, k) {
      const z = DateTime.zone(d);
      d = DateTime.time(d);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      d += k * TimeInterval.MillisPerMinute;
      return new DateTime(d, z);
    }
    next(d, k) {
      const z = DateTime.zone(d);
      d = DateTime.time(d);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      d = Math.floor((d + k * TimeInterval.MillisPerMinute) / TimeInterval.MillisPerMinute) * TimeInterval.MillisPerMinute;
      return new DateTime(d, z);
    }
    floor(d) {
      const z = DateTime.zone(d);
      d = DateTime.time(d);
      d = Math.floor(d / TimeInterval.MillisPerMinute) * TimeInterval.MillisPerMinute;
      return new DateTime(d, z);
    }
    ceil(d) {
      const z = DateTime.zone(d);
      d = DateTime.time(d);
      d = Math.floor((Math.floor((d - 1) / TimeInterval.MillisPerMinute) * TimeInterval.MillisPerMinute + TimeInterval.MillisPerMinute) / TimeInterval.MillisPerMinute) * TimeInterval.MillisPerMinute;
      return new DateTime(d, z);
    }
    every(k) {
      if (k === 1) {
        return this;
      } else if (isFinite(k) && k >= 1) {
        return new FilterTimeInterval(this, MinuteInterval.modulo.bind(void 0, k));
      } else {
        throw new Error("" + k);
      }
    }
    static modulo(k, d) {
      const minute = d.minute;
      return isFinite(minute) && minute % k === 0;
    }
  }
  class SecondInterval extends UnitTimeInterval {
    offset(d, k) {
      const z = DateTime.zone(d);
      d = DateTime.time(d);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      d += k * TimeInterval.MillisPerSecond;
      return new DateTime(d, z);
    }
    next(d, k) {
      const z = DateTime.zone(d);
      d = DateTime.time(d);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      d += k * TimeInterval.MillisPerSecond;
      d = Math.floor(d / TimeInterval.MillisPerSecond) * TimeInterval.MillisPerSecond;
      return new DateTime(d, z);
    }
    floor(d) {
      const z = DateTime.zone(d);
      d = DateTime.time(d);
      d = Math.floor(d / TimeInterval.MillisPerSecond) * TimeInterval.MillisPerSecond;
      return new DateTime(d, z);
    }
    ceil(d) {
      const z = DateTime.zone(d);
      d = DateTime.time(d);
      d = Math.floor((Math.floor((d - 1) / TimeInterval.MillisPerSecond) * TimeInterval.MillisPerSecond + TimeInterval.MillisPerSecond) / TimeInterval.MillisPerSecond) * TimeInterval.MillisPerSecond;
      return new DateTime(d, z);
    }
    every(k) {
      if (k === 1) {
        return this;
      } else if (isFinite(k) && k >= 1) {
        return new FilterTimeInterval(this, SecondInterval.modulo.bind(void 0, k));
      } else {
        throw new Error("" + k);
      }
    }
    static modulo(k, d) {
      const second = d.second;
      return isFinite(second) && second % k === 0;
    }
  }
  class MillisecondInterval extends UnitTimeInterval {
    offset(d, k) {
      const z = DateTime.zone(d);
      d = DateTime.time(d);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      d += k;
      return new DateTime(d, z);
    }
    next(d, k) {
      const z = DateTime.zone(d);
      d = DateTime.time(d);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      d += k;
      return new DateTime(d, z);
    }
    floor(d) {
      return DateTime.fromAny(d);
    }
    ceil(d) {
      return DateTime.fromAny(d);
    }
    every(k) {
      if (k === 1) {
        return this;
      } else if (isFinite(k) && k >= 1) {
        return new MillisecondsInterval(k);
      } else {
        throw new Error("" + k);
      }
    }
  }
  class MillisecondsInterval extends TimeInterval {
    constructor(stride) {
      super();
      if (!isFinite(stride)) {
        stride = 1;
      }
      this.stride = stride;
    }
    offset(d, k) {
      const z = DateTime.zone(d);
      d = DateTime.time(d);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      d += k * this.stride;
      return new DateTime(d, z);
    }
    next(d, k) {
      const z = DateTime.zone(d);
      d = DateTime.time(d);
      k = Math.max(1, typeof k === "number" ? Math.floor(k) : 1);
      const stride = this.stride;
      d = Math.floor((d + k * stride) / stride) * stride;
      return new DateTime(d, z);
    }
    floor(d) {
      const z = DateTime.zone(d);
      d = DateTime.time(d);
      const stride = this.stride;
      d = Math.floor(d / stride) * stride;
      return new DateTime(d, z);
    }
    ceil(d) {
      const z = DateTime.zone(d);
      d = DateTime.time(d);
      const stride = this.stride;
      d = Math.floor((Math.floor((d - 1) / stride) * stride + stride) / stride) * stride;
      return new DateTime(d, z);
    }
  }
  const TimeDomain = function(_super) {
    const TimeDomain = function(x0, x1) {
      const domain = function(t) {
        const t0 = domain[0].time;
        const t1 = domain[1].time;
        const dt = t1 - t0;
        return dt !== 0 ? (t.time - t0) / dt : 0;
      };
      Object.setPrototypeOf(domain, TimeDomain.prototype);
      domain[0] = x0;
      domain[1] = x1;
      return domain;
    };
    TimeDomain.prototype = Object.create(_super.prototype);
    TimeDomain.prototype.constructor = TimeDomain;
    Object.defineProperty(TimeDomain.prototype, "inverse", {
      get() {
        return TimeRange(this[0], this[1]);
      },
      configurable: true
    });
    TimeDomain.prototype.contains = function(t) {
      t = DateTime.time(t);
      return this[0].time <= t && t <= this[1].time;
    };
    TimeDomain.prototype.interpolateTo = function(that) {
      if (that instanceof TimeDomain) {
        return TimeDomainInterpolator(this, that);
      }
      return null;
    };
    TimeDomain.prototype.canEqual = function(that) {
      return that instanceof TimeDomain;
    };
    TimeDomain.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof TimeDomain) {
        return that.canEqual(this) && this[0].equals(that[0]) && this[1].equals(that[1]);
      }
      return false;
    };
    TimeDomain.prototype.toString = function() {
      return "TimeDomain(" + this[0] + ", " + this[1] + ")";
    };
    return TimeDomain;
  }(Domain);
  const TimeDomainInterpolator = function(_super) {
    const TimeDomainInterpolator = function(x0, x1) {
      const interpolator = function(u) {
        const x0 = interpolator[0];
        const x00 = x0[0];
        const x01 = x0[1];
        const x1 = interpolator[1];
        const x10 = x1[0];
        const x11 = x1[1];
        return TimeDomain(new DateTime(x00.time + u * (x10.time - x00.time), u === 0 ? x00.zone : x10.zone), new DateTime(x01.time + u * (x11.time - x01.time), u === 0 ? x01.zone : x11.zone));
      };
      Object.setPrototypeOf(interpolator, TimeDomainInterpolator.prototype);
      interpolator[0] = x0;
      interpolator[1] = x1;
      return interpolator;
    };
    TimeDomainInterpolator.prototype = Object.create(_super.prototype);
    TimeDomainInterpolator.prototype.constructor = TimeDomainInterpolator;
    return TimeDomainInterpolator;
  }(Interpolator);
  const TimeRange = function(_super) {
    const TimeRange = function(y0, y1) {
      const range = function(u) {
        const t0 = range[0].time;
        const t1 = range[1].time;
        return new DateTime(t0 + u * (t1 - t0), u === 0 ? range[0].zone : range[1].zone);
      };
      Object.setPrototypeOf(range, TimeRange.prototype);
      range[0] = y0;
      range[1] = y1;
      return range;
    };
    TimeRange.prototype = Object.create(_super.prototype);
    TimeRange.prototype.constructor = TimeRange;
    Object.defineProperty(TimeRange.prototype, "inverse", {
      get() {
        return TimeDomain(this[0], this[1]);
      },
      configurable: true
    });
    TimeRange.prototype.interpolateTo = function(that) {
      if (that instanceof TimeRange) {
        return TimeRangeInterpolator(this, that);
      }
      return null;
    };
    TimeRange.prototype.canEqual = function(that) {
      return that instanceof TimeRange;
    };
    TimeRange.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof TimeRange) {
        return that.canEqual(this) && this[0].equals(that[0]) && this[1].equals(that[1]);
      }
      return false;
    };
    TimeRange.prototype.toString = function() {
      return "TimeRange(" + this[0] + ", " + this[1] + ")";
    };
    return TimeRange;
  }(Range);
  const TimeRangeInterpolator = function(_super) {
    const TimeRangeInterpolator = function(y0, y1) {
      const interpolator = function(u) {
        const y0 = interpolator[0];
        const y00 = y0[0];
        const y01 = y0[1];
        const y1 = interpolator[1];
        const y10 = y1[0];
        const y11 = y1[1];
        return TimeRange(new DateTime(y00.time + u * (y10.time - y00.time), u === 0 ? y00.zone : y10.zone), new DateTime(y01.time + u * (y11.time - y01.time), u === 0 ? y01.zone : y11.zone));
      };
      Object.setPrototypeOf(interpolator, TimeRangeInterpolator.prototype);
      interpolator[0] = y0;
      interpolator[1] = y1;
      return interpolator;
    };
    TimeRangeInterpolator.prototype = Object.create(_super.prototype);
    TimeRangeInterpolator.prototype.constructor = TimeRangeInterpolator;
    return TimeRangeInterpolator;
  }(Interpolator);
  const TimeScale = function(_super) {
    const TimeScale = function(domain, range) {
      const scale = function(x) {
        return scale.range(scale.domain(x));
      };
      Object.setPrototypeOf(scale, TimeScale.prototype);
      scale.domain = domain;
      scale.range = range;
      return scale;
    };
    TimeScale.prototype = Object.create(_super.prototype);
    TimeScale.prototype.constructor = TimeScale;
    Object.defineProperty(TimeScale.prototype, "inverse", {
      get() {
        return Mapping(this.range.inverse, this.domain.inverse);
      },
      configurable: true
    });
    TimeScale.prototype.withDomain = function(x0, x1) {
      let domain;
      if (arguments.length === 1) {
        domain = x0;
      } else {
        x0 = DateTime.fromAny(x0);
        x1 = DateTime.fromAny(x1);
        domain = TimeDomain(x0, x1);
      }
      return TimeScale(domain, this.range);
    };
    TimeScale.prototype.overRange = function(y0, y1) {
      let range;
      if (arguments.length === 1) {
        range = y0;
      } else {
        range = LinearRange(y0, y1);
      }
      return TimeScale(this.domain, range);
    };
    TimeScale.prototype.clampDomain = function(xMin, xMax, zMin, zMax, epsilon) {
      if (epsilon === void 0) {
        epsilon = Equivalent.Epsilon;
      }
      const x0 = this.domain[0];
      const x1 = this.domain[1];
      let t0 = x0.time;
      let t1 = x1.time;
      const tMin = xMin !== void 0 ? xMin.time : void 0;
      const tMax = xMax !== void 0 ? xMax.time : void 0;
      if (tMin !== void 0 && tMax !== void 0 && Math.abs(t1 - t0) > tMax - tMin) {
        if (t0 < t1) {
          t0 = tMin;
          t1 = tMax;
        } else {
          t1 = tMin;
          t0 = tMax;
        }
      } else {
        if (tMin !== void 0) {
          if (t0 < t1 && t0 < tMin) {
            t1 += tMin - t0;
            t0 = tMin;
          } else if (t1 < t0 && t1 < tMin) {
            t0 += tMin - t1;
            t1 = tMin;
          }
        }
        if (tMax !== void 0) {
          if (t0 < t1 && t1 > tMax) {
            t0 -= t1 - tMax;
            t1 = tMax;
          } else if (t1 < t0 && t0 > tMax) {
            t1 -= t0 - tMax;
            t0 = tMax;
          }
        }
      }
      const y0 = this(x0);
      const y1 = this(x1);
      const dy = y0 < y1 ? y1 - y0 : y0 - y1;
      const z = Math.abs(dy / (t1 - t0));
      if (zMin !== void 0 && z < 1 / zMin) {
        const dz = dy * zMin;
        const tSum = t0 + t1;
        t0 = (tSum - dz) / 2;
        t1 = (tSum + dz) / 2;
      } else if (zMax !== void 0 && z > 1 / zMax) {
        const dz = dy * zMax;
        const tSum = t0 + t1;
        t0 = (tSum - dz) / 2;
        t1 = (tSum + dz) / 2;
      }
      if (Math.abs(t0 - x0.time) < epsilon && Math.abs(t1 - x1.time) < epsilon) {
        return this;
      } else {
        return TimeScale(TimeDomain(new DateTime(t0, x0.zone), new DateTime(t1, x1.zone)), this.range);
      }
    };
    TimeScale.prototype.solveDomain = function(x1, y1, x2, y2, reflect, epsilon) {
      if (epsilon === void 0) {
        epsilon = Equivalent.Epsilon;
      }
      const dt = this.domain[1].time - this.domain[0].time;
      const y0 = this.range[0];
      const y3 = this.range[1];
      const t1 = x1.time;
      const t2 = x2 !== void 0 ? x2.time : void 0;
      let m;
      if (t2 === void 0 || y2 === void 0 || Math.abs(t2 - t1) < epsilon || Math.abs(y2 - y1) < epsilon) {
        m = (y3 - y0) / (dt !== 0 ? dt : epsilon);
      } else {
        m = (y2 - y1) / (t2 - t1);
        if ((reflect === void 0 || !reflect) && m < 0 !== (y3 - y0) / dt < 0) {
          m = -m;
        }
      }
      const b = y1 - m * t1;
      const t0 = (y0 - b) / m;
      const t3 = (y3 - b) / m;
      if (Math.abs(t0 - this.domain[0].time) < epsilon && Math.abs(t3 - this.domain[1].time) < epsilon) {
        return this;
      } else {
        return TimeScale(TimeDomain(new DateTime(t0, this.domain[0].zone), new DateTime(t3, this.domain[1].zone)), this.range);
      }
    };
    TimeScale.prototype.interpolateTo = function(that) {
      if (that instanceof TimeScale) {
        return TimeScaleInterpolator(this, that);
      }
      return null;
    };
    TimeScale.prototype.canEqual = function(that) {
      return that instanceof TimeScale;
    };
    TimeScale.prototype.equals = function(that) {
      if (this === that) {
        return true;
      } else if (that instanceof TimeScale) {
        return this.domain.equals(that.domain) && this.range.equals(that.range);
      }
      return false;
    };
    TimeScale.prototype.toString = function() {
      return "TimeScale(" + this.domain + ", " + this.range + ")";
    };
    return TimeScale;
  }(ContinuousScale);
  const TimeScaleInterpolator = function(_super) {
    const TimeScaleInterpolator = function(s0, s1) {
      const interpolator = function(u) {
        const s0 = interpolator[0];
        const s1 = interpolator[1];
        const x0 = s0.domain;
        const x00 = x0[0].time;
        const x01 = x0[1].time;
        const x1 = s1.domain;
        const x10 = x1[0].time;
        const x11 = x1[1].time;
        const domain = TimeDomain(new DateTime(x00 + u * (x10 - x00), u === 0 ? x0[0].zone : x1[0].zone), new DateTime(x01 + u * (x11 - x01), u === 0 ? x0[1].zone : x1[1].zone));
        const y0 = s0.range;
        const y00 = y0[0];
        const y01 = y0[1];
        const y1 = s1.range;
        const y10 = y1[0];
        const y11 = y1[1];
        const range = LinearRange(y00 + u * (y10 - y00), y01 + u * (y11 - y01));
        return TimeScale(domain, range);
      };
      Object.setPrototypeOf(interpolator, TimeScaleInterpolator.prototype);
      interpolator[0] = s0;
      interpolator[1] = s1;
      return interpolator;
    };
    TimeScaleInterpolator.prototype = Object.create(_super.prototype);
    TimeScaleInterpolator.prototype.constructor = TimeScaleInterpolator;
    return TimeScaleInterpolator;
  }(Interpolator);
  class Message {
    get tag() {
      return this.constructor.tag;
    }
    toAny() {
      return this.toValue().toAny();
    }
    toRecon() {
      return Recon.toString(this.toValue());
    }
    toString() {
      return Format.debug(this);
    }
    static fromValue(value) {
      switch (value.tag) {
       case "open":
        return OpenSignal.fromValue(value);

       case "opened":
        return OpenedSignal.fromValue(value);

       case "close":
        return CloseSignal.fromValue(value);

       case "closed":
        return ClosedSignal.fromValue(value);

       case "connect":
        return ConnectSignal.fromValue(value);

       case "connected":
        return ConnectedSignal.fromValue(value);

       case "disconnect":
        return DisconnectSignal.fromValue(value);

       case "disconnected":
        return DisconnectedSignal.fromValue(value);

       case "error":
        return ErrorSignal.fromValue(value);

       case "event":
        return EventMessage.fromValue(value);

       case "command":
        return CommandMessage.fromValue(value);

       case "link":
        return LinkRequest.fromValue(value);

       case "linked":
        return LinkedResponse.fromValue(value);

       case "sync":
        return SyncRequest.fromValue(value);

       case "synced":
        return SyncedResponse.fromValue(value);

       case "unlink":
        return UnlinkRequest.fromValue(value);

       case "unlinked":
        return UnlinkedResponse.fromValue(value);

       case "auth":
        return AuthRequest.fromValue(value);

       case "authed":
        return AuthedResponse.fromValue(value);

       case "deauth":
        return DeauthRequest.fromValue(value);

       case "deauthed":
        return DeauthedResponse.fromValue(value);

       default:
        return null;
      }
    }
    static parseRecon(input) {
      return this.fromValue(Recon.parse(input));
    }
  }
  class Signal extends Message {
    static fromValue(value) {
      switch (value.tag) {
       case "open":
        return OpenSignal.fromValue(value);

       case "opened":
        return OpenedSignal.fromValue(value);

       case "close":
        return CloseSignal.fromValue(value);

       case "closed":
        return ClosedSignal.fromValue(value);

       case "connect":
        return ConnectSignal.fromValue(value);

       case "connected":
        return ConnectedSignal.fromValue(value);

       case "disconnect":
        return DisconnectSignal.fromValue(value);

       case "disconnected":
        return DisconnectedSignal.fromValue(value);

       case "error":
        return ErrorSignal.fromValue(value);

       default:
        return null;
      }
    }
    static parseRecon(input) {
      return this.fromValue(Recon.parse(input));
    }
  }
  class WorkerAddressed extends Signal {
    constructor(host, body) {
      super();
      this.host = host;
      this.body = body;
    }
    withHost(host) {
      host = Uri.fromAny(host);
      return this.copy(host, this.body);
    }
    withBody(body) {
      body = Value.fromAny(body);
      return this.copy(this.host, body);
    }
    copy(host, body) {
      return new this.constructor(host, body);
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof WorkerAddressed) {
        return this.constructor === that.constructor && this.host.equals(that.host) && this.body.equals(that.body);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Constructors.hash(this.constructor), this.host.hashCode()), this.body.hashCode()));
    }
    debug(output) {
      output = output.write(this.constructor.name).write(46).write("create").write(40).debug(this.host.toString());
      if (this.body.isDefined()) {
        output = output.write(", ").debug(this.body);
      }
      output = output.write(41);
      return output;
    }
    toValue() {
      const header = Record.create(1).slot("host", this.host.toString());
      return Attr.of(this.tag, header).concat(this.body);
    }
    static fromValue(value) {
      let host;
      const header = value.header(this.tag);
      header.forEach((function(header, index) {
        const key = header.key.stringValue(void 0);
        if (key !== void 0) {
          if (key === "host") {
            host = Uri.parse(header.toValue().stringValue(""));
          }
        } else if (header instanceof Value) {
          if (index === 0) {
            host = Uri.parse(header.stringValue(""));
          }
        }
      }));
      if (host !== void 0) {
        const body = value.body();
        return new this(host, body);
      }
      return null;
    }
    static create(host, body) {
      host = Uri.fromAny(host);
      if (body === void 0) {
        body = Value.absent();
      } else {
        body = Value.fromAny(body);
      }
      return new this(host, body);
    }
  }
  class OpenSignal extends WorkerAddressed {}
  OpenSignal.tag = "open";
  class OpenedSignal extends WorkerAddressed {}
  OpenedSignal.tag = "opened";
  class CloseSignal extends WorkerAddressed {}
  CloseSignal.tag = "close";
  class ClosedSignal extends WorkerAddressed {}
  ClosedSignal.tag = "closed";
  class ConnectSignal extends WorkerAddressed {}
  ConnectSignal.tag = "connect";
  class ConnectedSignal extends WorkerAddressed {}
  ConnectedSignal.tag = "connected";
  class DisconnectSignal extends WorkerAddressed {}
  DisconnectSignal.tag = "disconnect";
  class DisconnectedSignal extends WorkerAddressed {}
  DisconnectedSignal.tag = "disconnected";
  class ErrorSignal extends WorkerAddressed {}
  ErrorSignal.tag = "error";
  class Envelope extends Message {
    withPrio(prio) {
      return this;
    }
    withRate(rate) {
      return this;
    }
    static fromValue(value) {
      switch (value.tag) {
       case "event":
        return EventMessage.fromValue(value);

       case "command":
        return CommandMessage.fromValue(value);

       case "link":
        return LinkRequest.fromValue(value);

       case "linked":
        return LinkedResponse.fromValue(value);

       case "sync":
        return SyncRequest.fromValue(value);

       case "synced":
        return SyncedResponse.fromValue(value);

       case "unlink":
        return UnlinkRequest.fromValue(value);

       case "unlinked":
        return UnlinkedResponse.fromValue(value);

       case "auth":
        return AuthRequest.fromValue(value);

       case "authed":
        return AuthedResponse.fromValue(value);

       case "deauth":
        return DeauthRequest.fromValue(value);

       case "deauthed":
        return DeauthedResponse.fromValue(value);

       default:
        return null;
      }
    }
    static parseRecon(input) {
      return this.fromValue(Recon.parse(input));
    }
  }
  Object.defineProperty(Envelope.prototype, "prio", {
    get() {
      return 0;
    },
    configurable: true
  });
  Object.defineProperty(Envelope.prototype, "rate", {
    get() {
      return 0;
    },
    configurable: true
  });
  class HostAddressed extends Envelope {
    constructor(body) {
      super();
      this.body = body;
    }
    get node() {
      return Uri.empty();
    }
    withNode(node) {
      return this;
    }
    get lane() {
      return Uri.empty();
    }
    withLane(lane) {
      return this;
    }
    withBody(body) {
      body = Value.fromAny(body);
      return this.copy(body);
    }
    copy(body) {
      return new this.constructor(body);
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof HostAddressed) {
        return this.constructor === that.constructor && this.body.equals(that.body);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Constructors.hash(this.constructor), this.body.hashCode()));
    }
    debug(output) {
      output = output.write(this.constructor.name).write(46).write("create").write(40);
      if (this.body.isDefined()) {
        output = output.debug(this.body);
      }
      output = output.write(41);
      return output;
    }
    toValue() {
      return Attr.of(this.tag).concat(this.body);
    }
    static fromValue(value) {
      const header = value.header(this.tag);
      if (header.isDefined()) {
        const body = value.body();
        return new this(body);
      }
      return null;
    }
    static create(body) {
      if (body === void 0) {
        body = Value.absent();
      } else {
        body = Value.fromAny(body);
      }
      return new this(body);
    }
  }
  class LaneAddressed extends Envelope {
    constructor(node, lane, body) {
      super();
      this.node = node;
      this.lane = lane;
      this.body = body;
    }
    withNode(node) {
      node = Uri.fromAny(node);
      return this.copy(node, this.lane, this.body);
    }
    withLane(lane) {
      lane = Uri.fromAny(lane);
      return this.copy(this.node, lane, this.body);
    }
    withBody(body) {
      body = Value.fromAny(body);
      return this.copy(this.node, this.lane, body);
    }
    copy(node, lane, body) {
      return new this.constructor(node, lane, body);
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof LaneAddressed) {
        return this.constructor === that.constructor && this.node.equals(that.node) && this.lane.equals(that.lane) && this.body.equals(that.body);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Constructors.hash(this.constructor), this.node.hashCode()), this.lane.hashCode()), this.body.hashCode()));
    }
    debug(output) {
      output = output.write(this.constructor.name).write(46).write("create").write(40).debug(this.node.toString()).write(", ").debug(this.lane.toString());
      if (this.body.isDefined()) {
        output = output.write(", ").debug(this.body);
      }
      output = output.write(41);
      return output;
    }
    toValue() {
      const header = Record.create(2).slot("node", this.node.toString()).slot("lane", this.lane.toString());
      return Attr.of(this.tag, header).concat(this.body);
    }
    static fromValue(value) {
      let node;
      let lane;
      const header = value.header(this.tag);
      header.forEach((function(header, index) {
        const key = header.key.stringValue(void 0);
        if (key !== void 0) {
          if (key === "node") {
            node = Uri.parse(header.toValue().stringValue(""));
          } else if (key === "lane") {
            lane = Uri.parse(header.toValue().stringValue(""));
          }
        } else if (header instanceof Value) {
          if (index === 0) {
            node = Uri.parse(header.stringValue(""));
          } else if (index === 1) {
            lane = Uri.parse(header.stringValue(""));
          }
        }
      }));
      if (node !== void 0 && lane !== void 0) {
        const body = value.body();
        return new this(node, lane, body);
      }
      return null;
    }
    static create(node, lane, body) {
      node = Uri.fromAny(node);
      lane = Uri.fromAny(lane);
      if (body === void 0) {
        body = Value.absent();
      } else {
        body = Value.fromAny(body);
      }
      return new this(node, lane, body);
    }
  }
  class LinkAddressed extends Envelope {
    constructor(node, lane, prio, rate, body) {
      super();
      this.node = node;
      this.lane = lane;
      Object.defineProperty(this, "prio", {
        value: prio,
        writable: true,
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(this, "rate", {
        value: rate,
        writable: true,
        enumerable: true,
        configurable: true
      });
      this.body = body;
    }
    withNode(node) {
      node = Uri.fromAny(node);
      return this.copy(node, this.lane, this.prio, this.rate, this.body);
    }
    withLane(lane) {
      lane = Uri.fromAny(lane);
      return this.copy(this.node, lane, this.prio, this.rate, this.body);
    }
    withPrio(prio) {
      return this.copy(this.node, this.lane, prio, this.rate, this.body);
    }
    withRate(rate) {
      return this.copy(this.node, this.lane, this.prio, rate, this.body);
    }
    withBody(body) {
      body = Value.fromAny(body);
      return this.copy(this.node, this.lane, this.prio, this.rate, body);
    }
    copy(node, lane, prio, rate, body) {
      return new this.constructor(node, lane, prio, rate, body);
    }
    equals(that) {
      if (this === that) {
        return true;
      } else if (that instanceof LinkAddressed) {
        return this.constructor === that.constructor && this.node.equals(that.node) && this.lane.equals(that.lane) && this.prio === that.prio && this.rate === that.rate && this.body.equals(that.body);
      }
      return false;
    }
    hashCode() {
      return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(Constructors.hash(this.constructor), this.node.hashCode()), this.lane.hashCode()), Numbers.hash(this.prio)), Numbers.hash(this.rate)), this.body.hashCode()));
    }
    debug(output) {
      output = output.write(this.constructor.name).write(46).write("create").write(40).debug(this.node.toString()).write(", ").debug(this.lane.toString());
      if (this.prio !== 0 || this.rate !== 0) {
        output = output.write(", ").debug(this.prio).write(", ").debug(this.rate);
      }
      if (this.body.isDefined()) {
        output = output.write(", ").debug(this.body);
      }
      output = output.write(41);
      return output;
    }
    toValue() {
      const header = Record.create(4).slot("node", this.node.toString()).slot("lane", this.lane.toString());
      if (this.prio !== 0) {
        header.slot("prio", this.prio);
      }
      if (this.rate !== 0) {
        header.slot("rate", this.rate);
      }
      return Attr.of(this.tag, header).concat(this.body);
    }
    static fromValue(value) {
      let node;
      let lane;
      let prio = 0;
      let rate = 0;
      const header = value.header(this.tag);
      header.forEach((function(header, index) {
        const key = header.key.stringValue(void 0);
        if (key !== void 0) {
          if (key === "node") {
            node = Uri.parse(header.toValue().stringValue(""));
          } else if (key === "lane") {
            lane = Uri.parse(header.toValue().stringValue(""));
          } else if (key === "prio") {
            prio = header.numberValue(prio);
          } else if (key === "rate") {
            rate = header.numberValue(rate);
          }
        } else if (header instanceof Value) {
          if (index === 0) {
            node = Uri.parse(header.stringValue(""));
          } else if (index === 1) {
            lane = Uri.parse(header.stringValue(""));
          }
        }
      }));
      if (node !== void 0 && lane !== void 0) {
        const body = value.body();
        return new this(node, lane, prio, rate, body);
      }
      return null;
    }
    static create(node, lane, prio, rate, body) {
      node = Uri.fromAny(node);
      lane = Uri.fromAny(lane);
      if (prio === void 0) {
        prio = 0;
      }
      if (rate === void 0) {
        rate = 0;
      }
      if (body === void 0) {
        body = Value.absent();
      } else {
        body = Value.fromAny(body);
      }
      return new this(node, lane, prio, rate, body);
    }
  }
  class EventMessage extends LaneAddressed {}
  EventMessage.tag = "event";
  class CommandMessage extends LaneAddressed {}
  CommandMessage.tag = "command";
  class LinkRequest extends LinkAddressed {}
  LinkRequest.tag = "link";
  class LinkedResponse extends LinkAddressed {}
  LinkedResponse.tag = "linked";
  class SyncRequest extends LinkAddressed {}
  SyncRequest.tag = "sync";
  class SyncedResponse extends LaneAddressed {}
  SyncedResponse.tag = "synced";
  class UnlinkRequest extends LaneAddressed {}
  UnlinkRequest.tag = "unlink";
  class UnlinkedResponse extends LaneAddressed {}
  UnlinkedResponse.tag = "unlinked";
  class AuthRequest extends HostAddressed {}
  AuthRequest.tag = "auth";
  class AuthedResponse extends HostAddressed {}
  AuthedResponse.tag = "authed";
  class DeauthRequest extends HostAddressed {}
  DeauthRequest.tag = "deauth";
  class DeauthedResponse extends HostAddressed {}
  DeauthedResponse.tag = "deauthed";
  const e = '// @swim/client/webworker v4.0.0-dev.20210927.1 (c) 2015-2021 Swim.inc\n!function(){"use strict";function e(e,t,r,i){var n,s=arguments.length,o=s<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,r,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(o=(s<3?n(o):s>3?n(t,r,o):n(t,r))||o);return s>3&&o&&Object.defineProperty(t,r,o),o}const t=function(){const e={};return"undefined"!=typeof window&&void 0!==window.crypto?e.fillBytes=function(e){window.crypto.getRandomValues(e)}:"undefined"!=typeof window&&void 0!==window.msCrypto?e.fillBytes=function(e){window.msCrypto.getRandomValues(e)}:e.fillBytes=function(e){if(e instanceof Int8Array)for(let t=0;t<e.length;t+=1)e[t]=128-Math.round(256*Math.random());else if(e instanceof Uint8Array)for(let t=0;t<e.length;t+=1)e[t]=Math.round(256*Math.random());else if(e instanceof Int16Array)for(let t=0;t<e.length;t+=1)e[t]=32768-Math.round(65536*Math.random());else if(e instanceof Uint16Array)for(let t=0;t<e.length;t+=1)e[t]=Math.round(65536*Math.random());else if(e instanceof Int32Array)for(let t=0;t<e.length;t+=1)e[t]=2147483648-Math.round(4294967296*Math.random());else{if(!(e instanceof Uint32Array))throw new TypeError(""+e);for(let t=0;t<e.length;t+=1)e[t]=Math.round(4294967296*Math.random())}},e}(),r=function(){const e={};return Object.defineProperty(e,"BigEndian",{value:"BE",enumerable:!0}),Object.defineProperty(e,"LittleEndian",{value:"LE",enumerable:!0}),Object.defineProperty(e,"NativeOrder",{get(){let t;const r=new ArrayBuffer(2);new Uint16Array(r)[0]=65279;const i=new Uint8Array(r);if(254===i[0]&&255===i[1])t=e.BigEndian;else{if(255!==i[0]||254!==i[1])throw new Error;t=e.LittleEndian}return Object.defineProperty(e,"NativeOrder",{value:t,enumerable:!0}),t},configurable:!0,enumerable:!0}),e}(),i=function(){const e={mix:function(t,r){return r=3432918353*(65535&r)+((3432918353*(r>>>16)&65535)<<16)&4294967295,t^=r=461845907*(65535&(r=e.rotl(r,15)))+((461845907*(r>>>16)&65535)<<16)&4294967295,t=27492+(65535&(t=5*(65535&(t=e.rotl(t,13)))+((5*(t>>>16)&65535)<<16)&4294967295))+((58964+(t>>>16)&65535)<<16)},mixUint8Array:function(t,i){if(r.NativeOrder===r.BigEndian)return e.mixUint8ArrayBE(t,i);if(r.NativeOrder===r.LittleEndian)return e.mixUInt8ArrayLE(t,i);throw new Error},mixUint8ArrayBE:function(t,r){let i=0;const n=r.length;for(;i+3<n;){const n=(255&r[i])<<24|(255&r[i+1])<<16|(255&r[i+2])<<8|255&r[i+3];t=e.mix(t,n),i+=4}if(i<n){let s=(255&r[i])<<24;i+1<n&&(s|=(255&r[i+1])<<16,i+2<n&&(s|=(255&r[i+2])<<8)),s=3432918353*(65535&s)+((3432918353*(s>>>16)&65535)<<16)&4294967295,s=e.rotl(s,15),s=461845907*(65535&s)+((461845907*(s>>>16)&65535)<<16)&4294967295,t^=s}return t^n},mixUInt8ArrayLE:function(t,r){let i=0;const n=r.length;for(;i+3<n;){const n=255&r[i]|(255&r[i+1])<<8|(255&r[i+2])<<16|(255&r[i+3])<<24;t=e.mix(t,n),i+=4}if(i<n){let s=255&r[i];i+1<n&&(s|=(255&r[i+1])<<8,i+2<n&&(s|=(255&r[i+2])<<16)),s=3432918353*(65535&s)+((3432918353*(s>>>16)&65535)<<16)&4294967295,s=e.rotl(s,15),s=461845907*(65535&s)+((461845907*(s>>>16)&65535)<<16)&4294967295,t^=s}return t^n},mixString:function(t,i){if(r.NativeOrder===r.BigEndian)return e.mixStringBE(t,i);if(r.NativeOrder===r.LittleEndian)return e.mixStringLE(t,i);throw new Error},mixStringBE:function(t,r){let i=0,n=32,s=0;const o=r.length;let a=0;for(;s<o;){let o=r.codePointAt(s);void 0===o&&(o=r.charCodeAt(s)),o>=0&&o<=127?(n-=8,i|=o<<n,0===n&&(t=e.mix(t,i),i=0,n=32),a+=1):o>=128&&o<=2047?(n-=8,i|=(192|o>>>6)<<n,0===n&&(t=e.mix(t,i),i=0,n=32),n-=8,i|=(128|63&o)<<n,0===n&&(t=e.mix(t,i),i=0,n=32),a+=2):o>=2048&&o<=65535||o>=57344&&o<=65535?(n-=8,i|=(224|o>>>12)<<n,0===n&&(t=e.mix(t,i),i=0,n=32),n-=8,i|=(128|o>>>6&63)<<n,0===n&&(t=e.mix(t,i),i=0,n=32),n-=8,i|=(128|63&o)<<n,0===n&&(t=e.mix(t,i),i=0,n=32),a+=3):o>=65536&&o<=1114111?(n-=8,i|=(240|o>>>18)<<n,0===n&&(t=e.mix(t,i),i=0,n=32),n-=8,i|=(128|o>>>12&63)<<n,0===n&&(t=e.mix(t,i),i=0,n=32),n-=8,i|=(128|o>>>6&63)<<n,0===n&&(t=e.mix(t,i),i=0,n=32),n-=8,i|=(128|63&o)<<n,0===n&&(t=e.mix(t,i),i=0,n=32),a+=4):(n-=8,i|=239<<n,0===n&&(t=e.mix(t,i),i=0,n=32),n-=8,i|=191<<n,0===n&&(t=e.mix(t,i),i=0,n=32),n-=8,i|=189<<n,0===n&&(t=e.mix(t,i),i=0,n=32),a+=3),s=u.offsetByCodePoints(r,s,1)}return 32!==n&&(i=3432918353*(65535&i)+((3432918353*(i>>>16)&65535)<<16)&4294967295,i=e.rotl(i,15),i=461845907*(65535&i)+((461845907*(i>>>16)&65535)<<16)&4294967295,t^=i),t^a},mixStringLE:function(t,r){let i=0,n=0,s=0;const o=r.length;let a=0;for(;s<o;){let o=r.codePointAt(s);void 0===o&&(o=r.charCodeAt(s)),o>=0&&o<=127?(i|=o<<n,n+=8,32===n&&(t=e.mix(t,i),i=0,n=0),a+=1):o>=128&&o<=2047?(i|=(192|o>>>6)<<n,n+=8,32===n&&(t=e.mix(t,i),i=0,n=0),i|=(128|63&o)<<n,n+=8,32===n&&(t=e.mix(t,i),i=0,n=0),a+=2):o>=2048&&o<=65535||o>=57344&&o<=65535?(i|=(224|o>>>12)<<n,n+=8,32===n&&(t=e.mix(t,i),i=0,n=0),i|=(128|o>>>6&63)<<n,n+=8,32===n&&(t=e.mix(t,i),i=0,n=0),i|=(128|63&o)<<n,n+=8,32===n&&(t=e.mix(t,i),i=0,n=0),a+=3):o>=65536&&o<=1114111?(i|=(240|o>>>18)<<n,n+=8,32===n&&(t=e.mix(t,i),i=0,n=0),i|=(128|o>>>12&63)<<n,n+=8,32===n&&(t=e.mix(t,i),i=0,n=0),i|=(128|o>>>6&63)<<n,n+=8,32===n&&(t=e.mix(t,i),i=0,n=0),i|=(128|63&o)<<n,n+=8,32===n&&(t=e.mix(t,i),i=0,n=0),a+=4):(i|=239<<n,n+=8,32===n&&(t=e.mix(t,i),i=0,n=0),i|=191<<n,n+=8,32===n&&(t=e.mix(t,i),i=0,n=0),i|=189<<n,n+=8,32===n&&(t=e.mix(t,i),i=0,n=0),a+=3),s=u.offsetByCodePoints(r,s,1)}return 32!==n&&(i=3432918353*(65535&i)+((3432918353*(i>>>16)&65535)<<16)&4294967295,i=e.rotl(i,15),i=461845907*(65535&i)+((461845907*(i>>>16)&65535)<<16)&4294967295,t^=i),t^a},mash:function(e){return e=2246822507*(65535&(e^=e>>>16))+((2246822507*(e>>>16)&65535)<<16)&4294967295,e=3266489909*(65535&(e^=e>>>13))+((3266489909*(e>>>16)&65535)<<16)&4294967295,(e^=e>>>16)>>>0},rotl:function(e,t){return e<<t|e>>>32-t}};return e}(),n=function(e,t,r){const i=r.writable,n=r.enumerable,s=r.configurable;if(void 0!==r.get){const o=r.get;r.get=function(){const r=o.call(this);return Object.defineProperty(e,t,{value:r,writable:i,enumerable:n,configurable:s}),r}}else{if(void 0===r.value)throw new Error("invalid lazy property descriptor");{const o=r.value;r.value=function(){const r=o.call(this);return Object.defineProperty(e,t,{value:function(){return r},writable:i,enumerable:n,configurable:s}),r}}}},s=function(){const e={compare:function(e,t){return"boolean"==typeof e?"boolean"==typeof t?e&&!t?-1:!e&&t?1:0:-1:null===e?void 0===t?-1:null===t?0:1:void 0===e?void 0===t?0:1:NaN},hash:function(e){if(!0===e)return 3;if(!1===e)return 2;if(null===e)return 1;if(void 0===e)return 0;throw new TypeError(""+e)}};return e}(),o=function(){const e=function(e,t,r){return e===t||null!=e&&"function"==typeof e.equivalentTo&&e.equivalentTo(t,r)};return e.is=function(e){return null!=e&&"function"==typeof e.equivalentTo},e.Epsilon=1e-8,e}(),a=function(){const e={equal:function(e,t){return e===t||"number"==typeof e&&"number"==typeof t&&isNaN(e)&&isNaN(t)},equivalent:function(e,t,r){return e===t||"number"==typeof e&&"number"==typeof t&&(isNaN(e)&&isNaN(t)||Math.abs(t-e)<(void 0!==r?r:o.Epsilon))},compare:function(e,t){return"number"==typeof e?"number"==typeof t?e<t?-1:e>t?1:isNaN(t)?isNaN(e)?0:-1:isNaN(e)?1:0:-1:null===e?void 0===t?-1:null===t?0:1:void 0===e?void 0===t?0:1:NaN}},t=new ArrayBuffer(8),r=new Float64Array(t),i=new Int32Array(t);return e.hash=function(e){if("number"==typeof e)return e===~~e?~~e:(r[0]=e,i[0]^i[1]);if(null===e)return 1;if(void 0===e)return 0;throw new TypeError(""+e)},e}(),u=function(){const e={compare:function(e,t){return"string"==typeof e?"string"==typeof t?e<t?-1:e>t?1:0:-1:null===e?void 0===t?-1:null===t?0:1:void 0===e?void 0===t?0:1:NaN},hash:function(e){if("string"==typeof e)return i.mash(i.mixString(0,e));if(null===e)return 1;if(void 0===e)return 0;throw new TypeError(""+e)},codePointAt:function(e,t){const r=e.length;if((t=t?Number(t):0)!=t&&(t=0),t>=0&&t<r){const i=e.charCodeAt(t);if(i<=55295||i>=57344)return i;if(i<=56319&&t+1<r){const r=e.charCodeAt(t+1);if(r>=56320&&r<=57343)return 65536+((1023&i)<<10+r&1023)}}},offsetByCodePoints:function(e,t,r){if(r>0){const i=e.length;for(;r>0&&t<i;){const n=e.charCodeAt(t);if(n<=55295||n>=57344)t+=1;else if(n<=56319&&t+1<i){const r=e.charCodeAt(t+1);t+=r>=56320&&r<=57343?2:1}else t+=1;r-=1}}else if(r<0)for(;r<0&&t>0;){const i=e.charCodeAt(t-1);if(i<=55295||i>=57344)t-=1;else if(i>=56320&&i<=57343&&t-1>0){const r=e.charCodeAt(t-2);t-=r>=55296&&r<=57343?2:1}else t-=1;r-=1}return t}};return e}(),h=function(){const e={compare:function(t,r){if("function"==typeof t){if("function"==typeof r){const i=e.hash(t),n=e.hash(r);return i<n?-1:i>n?1:0}return-1}return null===t?void 0===r?-1:null===r?0:1:void 0===t?void 0===r?0:1:NaN}};let t=-1;return e.hash=function(e){if("function"==typeof e){let r=e._hashCode;return void 0===r&&(r=~~t,t-=1,Object.defineProperty(e,"_hashCode",{value:r,configurable:!0})),r}if(null===e)return 1;if(void 0===e)return 0;throw new TypeError(""+e)},e}(),l=function(){const e={compare:function(t,r){if("function"==typeof t){if("function"==typeof r){const i=e.hash(t),n=e.hash(r);return i<n?-1:i>n?1:0}return-1}return null===t?void 0===r?-1:null===r?0:1:void 0===t?void 0===r?0:1:NaN},hash:function(e){if("function"==typeof e){let t=e._hashCode;return void 0===t&&(t=i.mash(i.mixString(0,e.name)),Object.defineProperty(e,"_hashCode",{value:t,configurable:!0})),t}if(null===e)return 1;if(void 0===e)return 0;throw new TypeError(""+e)}};return e}(),c=function(){const e=function(e,t){return e===t||null!=e&&"function"==typeof e.equals&&e.equals(t)};return e.is=function(e){return null!=e&&"function"==typeof e.equals},e}(),d=function(){const e=function(e){return void 0===e?0:null===e?1:e.hashCode()};return e.is=function(e){return null!=e&&"function"==typeof e.hashCode},e}(),p=function(){const e=function(e,t){return void 0===e?void 0===t?0:1:null===e?void 0===t?-1:null===t?0:1:"function"==typeof e.compareTo?null==t?-1:e.compareTo(t):NaN};return e.is=function(e){return null!=e&&"function"==typeof e.compareTo},e}(),f=function(){const e={equal:function(e,t){if(e===t)return!0;if("object"==typeof e&&null!==e&&"object"==typeof t&&null!==t){const r=Object.keys(e),i=Object.keys(t),n=r.length;if(n!==i.length)return!1;for(let s=0;s<n;s+=1){const n=r[s];if(n!==i[s]||!w.equal(e[n],t[n]))return!1}return!0}return!1},equivalent:function(e,t,r){if(e===t)return!0;if("object"==typeof e&&null!==e&&"object"==typeof t&&null!==t){const i=Object.keys(e),n=Object.keys(t),s=i.length;if(s!==n.length)return!1;for(let o=0;o<s;o+=1){const s=i[o];if(s!==n[o]||!w.equivalent(e[s],t[s],r))return!1}return!0}return!1},compare:function(e,t){if("object"==typeof e&&null!==e){if("object"==typeof t&&null!==t){if(e!==t){const r=Object.keys(e),i=Object.keys(t),n=r.length,s=i.length,o=Math.min(n,s);let a=0;for(let n=0;n<o&&0===a;n+=1){const s=r[n],o=i[n];a=u.compare(s,o),0===a&&(a=w.compare(e[s],t[o]))}return 0!==a?a:n>s?1:n<s?-1:0}return 0}return-1}return null===e?void 0===t?-1:null===t?0:1:void 0===e?void 0===t?0:1:NaN},hash:function(e){if("object"==typeof e&&null!==e){let t=0;const r=Object.keys(e);for(let n=0,s=r.length;n<s;n+=1){const s=r[n];t=i.mix(i.mix(t,u.hash(s)),w.hash(e[s]))}return i.mash(t)}if(null===e)return 1;if(void 0===e)return 0;throw new TypeError(""+e)}};return e}(),w=function(){const e={equal:function(e,t){if(e instanceof Date&&(e=e.getTime()),t instanceof Date&&(t=t.getTime()),e===t)return!0;if("number"==typeof e){if("number"==typeof t)return isNaN(e)&&isNaN(t)}else{if(c.is(e))return e.equals(t);if(Array.isArray(e)){if(Array.isArray(t))return m.equal(e,t)}else if("object"==typeof e&&null!==e&&"object"==typeof t&&null!==t)return f.equal(e,t)}return!1},hash:function(e){if(void 0===e)return 0;if(null===e)return 1;if(!1===e)return 2;if(!0===e)return 3;if("number"==typeof e)return a.hash(e);if("string"==typeof e)return u.hash(e);if(d.is(e))return e.hashCode();if("function"==typeof e)return h.hash(e);if(Array.isArray(e))return m.hash(e);if("object"==typeof e)return f.hash(e);throw new TypeError(""+e)},equivalent:function(e,t,r=o.Epsilon){if(e instanceof Date&&(e=e.getTime()),t instanceof Date&&(t=t.getTime()),e===t)return!0;if("number"==typeof e){if("number"==typeof t)return isNaN(e)&&isNaN(t)||Math.abs(t-e)<r}else{if(o.is(e))return e.equivalentTo(t,r);if(Array.isArray(e)){if(Array.isArray(t))return m.equivalent(e,t,r)}else if("object"==typeof e&&null!==e&&"object"==typeof t&&null!==t)return f.equivalent(e,t,r)}return!1},compare:function(e,t){return e instanceof Date&&(e=e.getTime()),t instanceof Date&&(t=t.getTime()),void 0===e?void 0===t?0:1:null===e?void 0===t?-1:null===t?0:1:"boolean"==typeof e?null==t?-1:"boolean"==typeof t?e&&!t?-1:!e&&t?1:0:1:"number"==typeof e?null==t||"boolean"==typeof t?-1:"number"==typeof t?e<t?-1:e>t?1:isNaN(t)?isNaN(e)?0:-1:isNaN(e)?1:0:1:"string"==typeof e?null==t||"boolean"==typeof t||"number"==typeof t?-1:"string"==typeof t?e<t?-1:e>t?1:0:1:p.is(e)?e.compareTo(t):"function"==typeof e?null==t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t?-1:"function"==typeof t?h.compare(e,t):1:Array.isArray(e)?null==t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||"function"==typeof t?-1:Array.isArray(t)?m.compare(e,t):1:"object"==typeof e?null==t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||"function"==typeof t||Array.isArray(t)?-1:"object"==typeof t?f.compare(e,t):1:NaN}};return e}(),m=function(){const e={};return Object.defineProperty(e,"empty",{value:Object.freeze([]),enumerable:!0,configurable:!0}),e.inserted=function(e,t){const r=null!=t?t.length:0,i=new Array(r+1);for(let n=0;n<r;n+=1){const r=t[n];if(r===e)return t;i[n]=r}return i[r]=e,i},e.removed=function(t,r){const i=null!=r?r.length:0;if(0===i)return null!=r?r:e.empty;if(1===i)return r[0]!==t?r:e.empty;{const e=new Array(i-1);let n=0;for(;n<i;){const s=r[n];if(s===t){for(n+=1;n<i;)e[n-1]=r[n],n+=1;return e}e[n]=s,n+=1}return r}},e.equal=function(e,t){if(e===t)return!0;if("object"==typeof e&&null!==e&&"object"==typeof t&&null!==t){const r=e.length;if(r!==t.length)return!1;for(let i=0;i<r;i+=1)if(!w.equal(e[i],t[i]))return!1;return!0}return!1},e.equivalent=function(e,t,r){if(e===t)return!0;if("object"==typeof e&&null!==e&&"object"==typeof t&&null!==t){const i=e.length;if(i!==t.length)return!1;for(let n=0;n<i;n+=1)if(!w.equivalent(e[n],t[n],r))return!1;return!0}return!1},e.compare=function(e,t){if("object"==typeof e&&null!==e){if("object"==typeof t&&null!==t){if(e!==t){const r=e.length,i=t.length;let n=0;for(let s=0,o=Math.min(r,i);s<o&&0===n;s+=1)n=w.compare(e[s],t[s]);return 0!==n?n:r>i?1:r<i?-1:0}return 0}return-1}return null===e?void 0===t?-1:null===t?0:1:void 0===e?void 0===t?0:1:NaN},e.hash=function(e){if("object"==typeof e&&null!==e){let t=0;for(let r=0,n=e.length;r<n;r+=1)t=i.mix(t,w.hash(e[r]));return i.mash(t)}if(null===e)return 1;if(void 0===e)return 0;throw new TypeError(""+e)},e}(),g=function(e){const t=function(e,r){const i=function(e){return i.range(i.domain(e))};return Object.setPrototypeOf(i,t.prototype),i.domain=e,i.range=r,i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t.prototype.equivalentTo=function(e,r){return this===e||e instanceof t&&(this.domain.equivalentTo(e.domain,r)&&this.range.equivalentTo(e.range,r))},t.prototype.canEqual=function(e){return e instanceof t},t.prototype.equals=function(e){return this===e||e instanceof t&&(e.canEqual(this)&&this.domain.equals(e.domain)&&this.range.equals(e.range))},t.prototype.toString=function(){return"Mapping("+this.domain+", "+this.range+")"},t}(Function),y=function(e){const t=function(e,r){const i=function(e){return w.equal(e,i[1])?1:0};return Object.setPrototypeOf(i,t.prototype),i[0]=e,i[1]=r,i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,Object.defineProperty(t.prototype,"domain",{get(){return this},configurable:!0}),Object.defineProperty(t.prototype,"range",{get:()=>b.unit,configurable:!0}),t.prototype.contains=function(e){return w.compare(this[0],e)<=0&&w.compare(e,this[1])<=0},t.prototype.equivalentTo=function(e,r){return this===e||e instanceof t&&(w.equivalent(this[0],e[0],r)&&w.equivalent(this[1],e[1],r))},t.prototype.canEqual=function(e){return e instanceof t},t.prototype.equals=function(e){return this===e||e instanceof t&&(e.canEqual(this)&&w.equal(this[0],e[0])&&w.equal(this[1],e[1]))},t.prototype.toString=function(){return"Domain("+this[0]+", "+this[1]+")"},Object.defineProperty(t,"unit",{get(){const e=q(0,1);return Object.defineProperty(t,"unit",{value:e,enumerable:!0,configurable:!0}),e},enumerable:!0,configurable:!0}),t}(g),b=function(e){const t=function(e,r){const i=function(e){return e<1?i[0]:i[1]};return Object.setPrototypeOf(i,t.prototype),i[0]=e,i[1]=r,i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,Object.defineProperty(t.prototype,"domain",{get:()=>y.unit,configurable:!0}),Object.defineProperty(t.prototype,"range",{get(){return this},configurable:!0}),t.prototype.equivalentTo=function(e,r){return this===e||e instanceof t&&(w.equivalent(this[0],e[0],r)&&w.equivalent(this[1],e[1],r))},t.prototype.canEqual=function(e){return e instanceof t},t.prototype.equals=function(e){return this===e||e instanceof t&&(e.canEqual(this)&&w.equal(this[0],e[0])&&w.equal(this[1],e[1]))},t.prototype.toString=function(){return"Range("+this[0]+", "+this[1]+")"},Object.defineProperty(t,"unit",{get(){const e=V(0,1);return Object.defineProperty(t,"unit",{value:e,enumerable:!0,configurable:!0}),e},enumerable:!0,configurable:!0}),t}(g),v=function(){const e=function(e,t){return null!=e&&"function"==typeof e.interpolateTo?e.interpolateTo(t):null};return e.is=function(e){return null!=e&&"function"==typeof e.interpolateTo},e}(),x=function(e){const t=function(e,t){let r;return e===t?r=E(e):"number"==typeof e&&"number"==typeof t?r=A(e,t):Array.isArray(e)&&Array.isArray(t)?r=S(e,t):(r=v(e,t),null===r&&(r=C(e,t))),r};return(t.prototype=Object.create(e.prototype)).constructor=t,t.prototype.map=function(e){return O(this,e)},t.prototype.interpolateTo=function(e){return e instanceof t?k(this,e):null},t.prototype.canEqual=function(e){return e instanceof this.constructor},t.prototype.equals=function(e){return this===e||e instanceof t&&(e.canEqual(this)&&w.equal(this[0],e[0])&&w.equal(this[1],e[1]))},t.prototype.toString=function(){return"Interpolator("+this[0]+", "+this[1]+")"},t}(b),O=function(e){const t=function(e,r){const i=function(e){return i.transform(i.interpolator(e))};return Object.setPrototypeOf(i,t.prototype),i.interpolator=e,i.transform=r,i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,Object.defineProperty(t.prototype,0,{get(){return this.transform(this.interpolator[0])},configurable:!0}),Object.defineProperty(t.prototype,1,{get(){return this.transform(this.interpolator[1])},configurable:!0}),t.prototype.equals=function(e){return this===e||e instanceof t&&(this.interpolator.equals(e.interpolator)&&this.transform===e.transform)},t}(x),E=function(e){const t=function(e){const r=function(e){return r.value};return Object.setPrototypeOf(r,t.prototype),r.value=e,r};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,Object.defineProperty(t.prototype,0,{get(){return this.value},configurable:!0}),Object.defineProperty(t.prototype,1,{get(){return this.value},configurable:!0}),t.prototype.equals=function(e){return this===e||e instanceof t&&this.value===e.value},t}(x),C=function(e){const t=function(e,r){const i=function(e){return e<1?i[0]:i[1]};return Object.setPrototypeOf(i,t.prototype),i[0]=e,i[1]=r,i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t}(x),A=function(e){const t=function(e,r){const i=function(e){const t=i[0];return t+e*(i[1]-t)};return Object.setPrototypeOf(i,t.prototype),i[0]=e,i[1]=r,i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t}(x),S=function(e){const t=function(e,r){const i=function(e){const t=i.interpolators,r=t.length,n=new Array(r);for(let i=0;i<r;i+=1)n[i]=t[i](e);return n};Object.setPrototypeOf(i,t.prototype);const n=Math.min(e.length,r.length),s=new Array(n);for(let t=0;t<n;t+=1)s[t]=x(e[t],r[t]);return i.interpolators=s,i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,Object.defineProperty(t.prototype,0,{get(){const e=this.interpolators,t=e.length,r=new Array(t);for(let i=0;i<t;i+=1)r[i]=e[i][0];return r},configurable:!0}),Object.defineProperty(t.prototype,1,{get(){const e=this.interpolators,t=e.length,r=new Array(t);for(let i=0;i<t;i+=1)r[i]=e[i][1];return r},configurable:!0}),t.prototype.equals=function(e){if(this===e)return!0;if(e instanceof t){const t=this.interpolators.length;if(t===e.interpolators.length){for(let r=0;r<t;r+=1)if(!this.interpolators[r].equals(e.interpolators[r]))return!1;return!0}}return!1},t}(x),k=function(e){const t=function(e,r){const i=function(e){return 0===e?i[0]:1===e?i[1]:x(i[0](e),i[1](e))};return Object.setPrototypeOf(i,t.prototype),i[0]=e,i[1]=r,i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t}(x),T=function(e){const t=function(e,r,i){const n=function(e){const t=n[0],r=n[1];return n.easing(Math.min(Math.max(0,(e-t)/(r-t)),1))};return Object.setPrototypeOf(n,t.prototype),n.easing=e,n[0]=r,n[1]=i,n};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,Object.defineProperty(t.prototype,"duration",{get(){return this[1]-this[0]},configurable:!0}),t.prototype.contains=function(e){return this[0]<=e&&e<=this[1]},t.prototype.withDomain=function(e,r){return t(this.easing,e,r)},t.prototype.withDuration=function(e){const r=this[0];return t(this.easing,r,r+e)},t.prototype.overRange=function(e,t){let r;return r=1===arguments.length?e:x(e,t),D(this,r)},t.prototype.equivalentTo=function(e,r){return this===e||e instanceof t&&(this.easing.equivalentTo(e.easing,r)&&w.equivalent(this[0],e[0],r)&&w.equivalent(this[1],e[1],r))},t.prototype.canEqual=function(e){return e instanceof t},t.prototype.equals=function(e){return this===e||e instanceof t&&(e.canEqual(this)&&this.easing.equals(e.easing)&&w.equal(this[0],e[0])&&w.equal(this[1],e[1]))},t.prototype.toString=function(){return"Timing("+this.easing+", "+this[0]+", "+this[1]+")"},t.fromInit=function(e){let r=e.easing;void 0===r?r=P.linear:"string"==typeof r&&(r=P(r));let i=e.t0;void 0===i&&(i=0);let n=e.t1;if(void 0===n){const t=e.dt;n=void 0!==t?i+t:i}return t(r,i,n)},t.fromAny=function(e){if(null==e)return!1;if(e instanceof t||"boolean"==typeof e)return e;if("object"==typeof e)return t.fromInit(e);throw new TypeError(""+e)},t}(y),P=function(e){const t=function(e){switch(e){case"linear":return t.linear;case"quad-in":return t.quadIn;case"quad-out":return t.quadOut;case"quad-in-out":return t.quadInOut;case"cubic-in":return t.cubicIn;case"cubic-out":return t.cubicOut;case"cubic-in-out":return t.cubicInOut;case"quart-in":return t.quartIn;case"quart-out":return t.quartOut;case"quart-in-out":return t.quartInOut;case"expo-in":return t.expoIn;case"expo-out":return t.expoOut;case"expo-in-out":return t.expoInOut;case"circ-in":return t.circIn;case"circ-out":return t.circOut;case"circ-in-out":return t.circInOut;case"back-in":return t.backIn;case"back-out":return t.backOut;case"back-in-out":return t.backInOut;case"elastic-in":return t.elasticIn;case"elastic-out":return t.elasticOut;case"elastic-in-out":return t.elasticInOut;case"bounce-in":return t.bounceIn;case"bounce-out":return t.bounceOut;case"bounce-in-out":return t.bounceInOut;default:throw new Error("unknown easing: "+e)}};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,Object.defineProperty(t.prototype,0,{value:0}),Object.defineProperty(t.prototype,1,{value:1}),Object.defineProperty(t.prototype,"easing",{get(){return this}}),t.prototype.equivalentTo=function(e,t){return this===e},t.prototype.canEqual=function(e){return e instanceof t},t.prototype.equals=function(e){return this===e},t.prototype.toString=function(){return\'Easing("\'+this.type+\'")\'},t.fromAny=function(e){if(e instanceof t)return e;if("string"==typeof e)return t(e);throw new TypeError(""+e)},t.linear=function(e){return e},Object.setPrototypeOf(t.linear,t.prototype),t.linear.type="linear",t.quadIn=function(e){return e*e},Object.setPrototypeOf(t.quadIn,t.prototype),t.quadIn.type="quad-in",t.quadOut=function(e){return e*(2-e)},Object.setPrototypeOf(t.quadOut,t.prototype),t.quadOut.type="quad-out",t.quadInOut=function(e){return(e*=2)<=1?e*=e:(e-=1,e*=2-e,e+=1),e/=2},Object.setPrototypeOf(t.quadInOut,t.prototype),t.quadInOut.type="quad-in-out",t.cubicIn=function(e){return e*e*e},Object.setPrototypeOf(t.cubicIn,t.prototype),t.cubicIn.type="cubic-in",t.cubicOut=function(e){return e-=1,e*=e*e,e+=1},Object.setPrototypeOf(t.cubicOut,t.prototype),t.cubicOut.type="cubic-out",t.cubicInOut=function(e){return(e*=2)<=1?e*=e*e:(e-=2,e*=e*e,e+=2),e/=2},Object.setPrototypeOf(t.cubicInOut,t.prototype),t.cubicInOut.type="cubic-in-out",t.quartIn=function(e){return e*e*e*e},Object.setPrototypeOf(t.quartIn,t.prototype),t.quartIn.type="quart-in",t.quartOut=function(e){return 1-(e-=1)*e*e*e},Object.setPrototypeOf(t.quartOut,t.prototype),t.quartOut.type="quart-out",t.quartInOut=function(e){const t=e-1;return e<.5?8*e*e*e*e:1-8*t*t*t*t},Object.setPrototypeOf(t.quartInOut,t.prototype),t.quartInOut.type="quart-in-out",t.expoIn=function(e){return 0===e?0:Math.pow(2,10*(e-1))},Object.setPrototypeOf(t.expoIn,t.prototype),t.expoIn.type="expo-in",t.expoOut=function(e){return 1===e?1:1-Math.pow(2,-10*e)},Object.setPrototypeOf(t.expoOut,t.prototype),t.expoOut.type="expo-out",t.expoInOut=function(e){return 1===e||0===e?e:(e*=2)<1?.5*Math.pow(2,10*(e-1)):.5*(2-Math.pow(2,-10*(e-1)))},Object.setPrototypeOf(t.expoInOut,t.prototype),t.expoInOut.type="expo-in-out",t.circIn=function(e){return-1*(Math.sqrt(1-e/1*e)-1)},Object.setPrototypeOf(t.circIn,t.prototype),t.circIn.type="circ-in",t.circOut=function(e){return e-=1,Math.sqrt(1-e*e)},Object.setPrototypeOf(t.circOut,t.prototype),t.circOut.type="circ-out",t.circInOut=function(e){if((e*=2)<1)return-.5*(Math.sqrt(1-e*e)-1);const t=e-2;return.5*(Math.sqrt(1-t*t)+1)},Object.setPrototypeOf(t.circInOut,t.prototype),t.circInOut.type="circ-in-out",t.backIn=function(e){const t=1.70158;return e*e*((t+1)*e-t)},Object.setPrototypeOf(t.backIn,t.prototype),t.backIn.type="back-in",t.backOut=function(e){const t=1.70158,r=e/1-1;return r*r*((t+1)*t+t)+1},Object.setPrototypeOf(t.backOut,t.prototype),t.backOut.type="back-out",t.backInOut=function(e){const t=2.5949095;if((e*=2)<1)return.5*e*e*((t+1)*e-t);const r=e-2;return.5*(r*r*((t+1)*r+t)+2)},Object.setPrototypeOf(t.backInOut,t.prototype),t.backInOut.type="back-in-out",t.elasticIn=function(e){if(0===e||1===e)return e;const t=e/1-1,r=(1-.7)/2*Math.PI*Math.asin(1);return-Math.pow(2,10*t)*Math.sin(2*(t-r)*Math.PI/(1-.7))},Object.setPrototypeOf(t.elasticIn,t.prototype),t.elasticIn.type="elastic-in",t.elasticOut=function(e){if(0===e||1===e)return e;const t=(1-.7)/(2*Math.PI)*Math.asin(1);return e*=2,Math.pow(2,-10*e)*Math.sin(2*(e-t)*Math.PI/(1-.7))+1},Object.setPrototypeOf(t.elasticOut,t.prototype),t.elasticOut.type="elastic-out",t.elasticInOut=function(e){if(0===e||1===e)return e;const t=.65,r=(1-t)/(2*Math.PI)*Math.asin(1),i=2*e,n=i-1;return i<1?Math.pow(2,10*n)*Math.sin(2*(n-r)*Math.PI/(1-t))*-.5:Math.pow(2,-10*n)*Math.sin(2*(n-r)*Math.PI/(1-t))*.5+1},Object.setPrototypeOf(t.elasticInOut,t.prototype),t.elasticInOut.type="elastic-in-out",t.bounceIn=function(e){const t=7.5625;return(e=1-e)<1/2.75?1-t*e*e:e<2/2.75?1-(t*(e-=1.5/2.75)*e+.75):e<2.5/2.75?1-(t*(e-=2.25/2.75)*e+.9375):1-(t*(e-=2.625/2.75)*e+.984375)},Object.setPrototypeOf(t.bounceIn,t.prototype),t.bounceIn.type="bounce-in",t.bounceOut=function(e){const t=7.5625;return e<1/2.75?t*e*e:e<2/2.75?t*(e-=1.5/2.75)*e+.75:e<2.5/2.75?t*(e-=2.25/2.75)*e+.9375:t*(e-=2.625/2.75)*e+.984375},Object.setPrototypeOf(t.bounceOut,t.prototype),t.bounceOut.type="bounce-out",t.bounceInOut=function(e){const t=e<.5,r=7.5625;return(e=t?1-2*e:2*e-1)<1/2.75?e*=r*e:e=e<2/2.75?r*(e-=1.5/2.75)*e+.75:e<2.5/2.75?r*(e-=2.25/2.75)*e+.9375:r*(e-=2.625/2.75)*e+.984375,t?.5*(1-e):.5*e+.5},Object.setPrototypeOf(t.bounceInOut,t.prototype),t.bounceInOut.type="bounce-in-out",t}(T),D=function(e){const t=function(e,r){const i=function(e){return i.range(i.domain(e))};return Object.setPrototypeOf(i,t.prototype),i.domain=e,i.range=r,i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t.prototype.withDomain=function(e,t){return this.domain.withDomain(e,t).overRange(this.range)},t.prototype.canEqual=function(e){return e instanceof t},t.prototype.equals=function(e){return this===e||e instanceof t&&(this.domain.equals(e.domain)&&this.range.equals(e.range))},t.prototype.toString=function(){return"Tweening("+this.domain+", "+this.range+")"},t}(g),q=function(e){const t=function(e,r){const i=function(e){const t=i[0],r=i[1]-t;return 0!==r?(e-t)/r:0};return Object.setPrototypeOf(i,t.prototype),i[0]=e,i[1]=r,i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,Object.defineProperty(t.prototype,"inverse",{get(){return V(this[0],this[1])},configurable:!0}),t.prototype.contains=function(e){return this[0]<=e&&e<=this[1]},t.prototype.interpolateTo=function(e){return e instanceof t?I(this,e):null},t.prototype.canEqual=function(e){return e instanceof t},t.prototype.equals=function(e){return this===e||e instanceof t&&(e.canEqual(this)&&this[0]===e[0]&&this[1]===e[1])},t.prototype.toString=function(){return"LinearDomain("+this[0]+", "+this[1]+")"},t}(y),I=function(e){const t=function(e,r){const i=function(e){const t=i[0],r=t[0],n=t[1],s=i[1],o=s[0],a=s[1];return q(r+e*(o-r),n+e*(a-n))};return Object.setPrototypeOf(i,t.prototype),i[0]=e,i[1]=r,i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t}(x),V=function(e){const t=function(e,r){const i=function(e){const t=i[0];return t+e*(i[1]-t)};return Object.setPrototypeOf(i,t.prototype),i[0]=e,i[1]=r,i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,Object.defineProperty(t.prototype,"inverse",{get(){return q(this[0],this[1])},configurable:!0}),t.prototype.interpolateTo=function(e){return e instanceof t?N(this,e):null},t.prototype.canEqual=function(e){return e instanceof t},t.prototype.equals=function(e){return this===e||e instanceof t&&(e.canEqual(this)&&this[0]===e[0]&&this[1]===e[1])},t.prototype.toString=function(){return"LinearRange("+this[0]+", "+this[1]+")"},t}(b),N=function(e){const t=function(e,r){const i=function(e){const t=i[0],r=t[0],n=t[1],s=i[1],o=s[0],a=s[1];return V(r+e*(o-r),n+e*(a-n))};return Object.setPrototypeOf(i,t.prototype),i[0]=e,i[1]=r,i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t}(x),z=function(e){const t=function(e,r){const i=function(e){return i.range(i.domain(e))};return Object.setPrototypeOf(i,t.prototype),i.domain=e,i.range=r,i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,Object.defineProperty(t.prototype,"inverse",{get(){return t(this.range.inverse,this.domain.inverse)},configurable:!0}),t.prototype.withDomain=function(e,r){let i;return i=1===arguments.length?e:q(e,r),t(i,this.range)},t.prototype.overRange=function(e,r){let i;return i=1===arguments.length?e:V(e,r),t(this.domain,i)},t.prototype.clampDomain=function(e,r,i,n,s){void 0===s&&(s=o.Epsilon);let a=this.domain[0],u=this.domain[1];void 0!==e&&void 0!==r&&Math.abs(u-a)>r-e?a<u?(a=e,u=r):(u=e,a=r):(void 0!==e&&(a<u&&a<e?(u+=e-a,a=e):u<a&&u<e&&(a+=e-u,u=e)),void 0!==r&&(a<u&&u>r?(a-=u-r,u=r):u<a&&a>r&&(u-=a-r,a=r)));const h=this(a),l=this(u),c=h<l?l-h:h-l,d=Math.abs(c/(u-a));if(void 0!==i&&d<1/i){const e=c*i,t=a+u;a=(t-e)/2,u=(t+e)/2}else if(void 0!==n&&d>1/n){const e=c*n,t=a+u;a=(t-e)/2,u=(t+e)/2}return Math.abs(a-this.domain[0])<s&&Math.abs(u-this.domain[1])<s?this:t(q(a,u),this.range)},t.prototype.solveDomain=function(e,r,i,n,s,a){void 0===a&&(a=o.Epsilon);const u=this.domain[1]-this.domain[0],h=this.range[0],l=this.range[1];let c;void 0===i||void 0===n||Math.abs(i-e)<a||Math.abs(n-r)<a?c=(l-h)/(0!==u?u:a):(c=(n-r)/(i-e),void 0!==s&&s||c<0==(l-h)/u<0||(c=-c));const d=r-c*e,p=(h-d)/c,f=(l-d)/c;return Math.abs(p-this.domain[0])<a&&Math.abs(f-this.domain[1])<a?this:t(q(p,f),this.range)},t.prototype.interpolateTo=function(e){return e instanceof t?M(this,e):null},t.prototype.canEqual=function(e){return e instanceof t},t.prototype.equals=function(e){return this===e||e instanceof t&&(this.domain.equals(e.domain)&&this.range.equals(e.range))},t.prototype.toString=function(){return"LinearScale("+this.domain+", "+this.range+")"},t}(function(e){const t=function(){throw new Error};return(t.prototype=Object.create(e.prototype)).constructor=t,t.prototype.canEqual=function(e){return e instanceof t},t.prototype.equals=function(e){return this===e||e instanceof t&&(this.domain.equals(e.domain)&&this.range.equals(e.range))},t.prototype.toString=function(){return"ContinuousScale("+this.domain+", "+this.range+")"},t}(function(e){const t=function(){throw new Error};return(t.prototype=Object.create(e.prototype)).constructor=t,t.prototype.canEqual=function(e){return e instanceof t},t.prototype.equals=function(e){return this===e||e instanceof t&&(this.domain.equals(e.domain)&&this.range.equals(e.range))},t.prototype.toString=function(){return"Scale("+this.domain+", "+this.range+")"},t}(g))),M=function(e){const t=function(e,r){const i=function(e){const t=i[0],r=i[1],n=t.domain,s=n[0],o=n[1],a=r.domain,u=a[0],h=a[1],l=q(s+e*(u-s),o+e*(h-o)),c=t.range,d=c[0],p=c[1],f=r.range,w=f[0],m=f[1],g=V(d+e*(w-d),p+e*(m-p));return z(l,g)};return Object.setPrototypeOf(i,t.prototype),i[0]=e,i[1]=r,i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t}(x);class j{set(e){throw new Error("immutable")}delete(){throw new Error("immutable")}static empty(){return new L}static unary(e){return new F(e)}static array(e,t,r){return void 0===t&&(t=0),void 0===r&&(r=e.length),new B(e,t,r)}}e([n],j,"empty",null);class L extends j{isEmpty(){return!0}head(){throw new Error("empty")}step(){throw new Error("empty")}skip(e){}hasNext(){return!1}nextIndex(){return 0}next(){return{done:!0}}hasPrevious(){return!1}previousIndex(){return-1}previous(){return{done:!0}}}class F extends j{constructor(e){super(),this.value=e,this.index=0}isEmpty(){return 0!==this.index}head(){if(0===this.index)return this.value;throw new Error("empty")}step(){if(0!==this.index)throw new Error("empty");this.index=1}skip(e){this.index=Math.min(Math.max(0,this.index+e),1)}hasNext(){return 0===this.index}nextIndex(){return this.index}next(){return 0===this.index?(this.index=1,{value:this.value,done:!0}):{done:!0}}hasPrevious(){return 1===this.index}previousIndex(){return this.index-1}previous(){return 1===this.index?(this.index=0,{value:this.value,done:!0}):{done:!0}}}class B extends j{constructor(e,t,r){super(),this.array=e,this.index=t,this.limit=r}isEmpty(){return this.index>=this.limit}head(){if(this.index<this.limit)return this.array[this.index];throw new Error("empty")}step(){if(!(this.index<this.limit))throw new Error("empty");this.index+=1}skip(e){this.index=Math.min(this.index+e,this.limit)}hasNext(){return this.index<this.limit}nextIndex(){return this.index}next(){const e=this.index;return e<this.limit?(this.index+=1,{value:this.array[e],done:this.index===this.limit}):(this.index=this.limit,{done:!0})}hasPrevious(){return this.index>0}previousIndex(){return this.index-1}previous(){const e=this.index-1;return e>=0?(this.index=e,{value:this.array[e],done:0===e}):(this.index=0,{done:!0})}}class U{constructor(e){this.buckets=new Array(e),this.gen4Hits=0,this.gen3Hits=0,this.gen2Hits=0,this.gen1Hits=0,this.misses=0}get(e){if(0===this.buckets.length)return;const t=Math.abs(w.hash(e))%this.buckets.length,r=this.buckets[t];if(void 0===r)return;const i=r.gen4Key;if(void 0!==i&&w.equal(e,i)){const e=r.gen4Val;if(void 0!==e)return this.gen4Hits+=1,r.gen4Weight++,e;r.gen4Key=void 0}const n=r.gen3Key;if(void 0!==n&&w.equal(e,n)){const e=r.gen3Val;if(void 0!==e)return this.gen3Hits+=1,r.gen3Weight++>r.gen4Weight&&(this.buckets[t]=new W(r.gen3Key,r.gen3Val,r.gen3Weight,r.gen4Key,r.gen4Val,r.gen4Weight,r.gen2Key,r.gen2Val,r.gen2Weight,r.gen1Key,r.gen1Val,r.gen1Weight)),e;r.gen3Key=void 0}const s=r.gen2Key;if(void 0!==s&&w.equal(e,s)){const e=r.gen2Val;if(void 0!==e)return this.gen2Hits+=1,r.gen2Weight++>r.gen3Weight&&(this.buckets[t]=new W(r.gen4Key,r.gen4Val,r.gen4Weight,r.gen2Key,r.gen2Val,r.gen2Weight,r.gen3Key,r.gen3Val,r.gen3Weight,r.gen1Key,r.gen1Val,r.gen1Weight)),e;r.gen2Key=void 0}const o=r.gen1Key;if(void 0!==o&&w.equal(e,o)){const e=r.gen1Val;if(void 0!==e)return this.gen1Hits+=1,r.gen1Weight++>r.gen2Weight&&(this.buckets[t]=new W(r.gen4Key,r.gen4Val,r.gen4Weight,r.gen3Key,r.gen3Val,r.gen3Weight,r.gen1Key,r.gen1Val,r.gen1Weight,r.gen2Key,r.gen2Val,r.gen2Weight)),e;r.gen1Key=void 0}this.misses+=1}put(e,t){if(0===this.buckets.length)return t;const r=Math.abs(w.hash(e))%this.buckets.length,i=this.buckets[r]||new W;let n=i.gen4Key;if(void 0!==n&&w.equal(e,n)){const e=i.gen4Val;if(void 0!==e)return this.gen4Hits+=1,i.gen4Weight++,e;i.gen4Key=void 0,n=void 0}let s=i.gen3Key;if(void 0!==s&&w.equal(e,s)){const e=i.gen3Val;if(void 0!==e)return this.gen3Hits+=1,i.gen3Weight++>i.gen4Weight&&(this.buckets[r]=new W(i.gen3Key,i.gen3Val,i.gen3Weight,i.gen4Key,i.gen4Val,i.gen4Weight,i.gen2Key,i.gen2Val,i.gen2Weight,i.gen1Key,i.gen1Val,i.gen1Weight)),e;i.gen3Key=void 0,s=void 0}let o=i.gen2Key;if(void 0!==o&&w.equal(e,o)){const e=i.gen2Val;if(void 0!==e)return this.gen2Hits+=1,i.gen2Weight++>i.gen3Weight&&(this.buckets[r]=new W(i.gen4Key,i.gen4Val,i.gen4Weight,i.gen2Key,i.gen2Val,i.gen2Weight,i.gen3Key,i.gen3Val,i.gen3Weight,i.gen1Key,i.gen1Val,i.gen1Weight)),e;i.gen2Key=void 0,o=void 0}let a=i.gen1Key;if(void 0!==a&&w.equal(e,a)){const e=i.gen1Val;if(void 0!==e)return this.gen1Hits+=1,i.gen1Weight++>i.gen2Weight&&(this.buckets[r]=new W(i.gen4Key,i.gen4Val,i.gen4Weight,i.gen3Key,i.gen3Val,i.gen3Weight,i.gen1Key,i.gen1Val,i.gen1Weight,i.gen2Key,i.gen2Val,i.gen2Weight)),e;i.gen1Key=void 0,a=void 0}return this.misses+=1,this.buckets[r]=void 0===n?new W(i.gen3Key,i.gen3Val,i.gen3Weight,i.gen2Key,i.gen2Val,i.gen2Weight,i.gen1Key,i.gen1Val,i.gen1Weight,e,t,1):void 0===s?new W(i.gen4Key,i.gen4Val,i.gen4Weight,i.gen2Key,i.gen2Val,i.gen2Weight,i.gen1Key,i.gen1Val,i.gen1Weight,e,t,1):void 0===o?new W(i.gen4Key,i.gen4Val,i.gen4Weight,i.gen3Key,i.gen3Val,i.gen3Weight,i.gen1Key,i.gen1Val,i.gen1Weight,e,t,1):void 0===a?new W(i.gen4Key,i.gen4Val,i.gen4Weight,i.gen3Key,i.gen3Val,i.gen3Weight,i.gen2Key,i.gen2Val,i.gen2Weight,e,t,1):new W(i.gen4Key,i.gen4Val,i.gen4Weight-1,i.gen3Key,i.gen3Val,i.gen3Weight-1,i.gen1Key,i.gen1Val,i.gen1Weight,e,t,1),t}remove(e){if(0===this.buckets.length)return;const t=Math.abs(w.hash(e))%this.buckets.length,r=this.buckets[t];if(void 0===r)return;const i=r.gen4Key;if(void 0!==i&&w.equal(e,i)){const e=r.gen4Val;return this.buckets[t]=new W(r.gen3Key,r.gen3Val,r.gen3Weight,r.gen2Key,r.gen2Val,r.gen2Weight,r.gen1Key,r.gen1Val,r.gen1Weight,void 0,void 0,0),e}const n=r.gen3Key;if(void 0!==n&&w.equal(e,n)){const e=r.gen3Val;return this.buckets[t]=new W(r.gen4Key,r.gen4Val,r.gen4Weight,r.gen2Key,r.gen2Val,r.gen2Weight,r.gen1Key,r.gen1Val,r.gen1Weight,void 0,void 0,0),e}const s=r.gen2Key;if(void 0!==s&&w.equal(e,s)){const e=r.gen2Val;return this.buckets[t]=new W(r.gen4Key,r.gen4Val,r.gen4Weight,r.gen3Key,r.gen3Val,r.gen3Weight,r.gen1Key,r.gen1Val,r.gen1Weight,void 0,void 0,0),e}const o=r.gen1Key;if(void 0!==o&&w.equal(e,o)){const e=r.gen1Val;return this.buckets[t]=new W(r.gen4Key,r.gen4Val,r.gen4Weight,r.gen3Key,r.gen3Val,r.gen3Weight,r.gen2Key,r.gen2Val,r.gen2Weight,void 0,void 0,0),e}}clear(){for(let e=0;e<this.buckets.length;e+=1)this.buckets[e]=void 0}hits(){return this.gen4Hits+this.gen3Hits+this.gen2Hits+this.gen1Hits}hitRatio(){const e=this.hits();return e/(e+this.misses)}}class W{constructor(e,t,r=0,i,n,s=0,o,a,u=0,h,l,c=0){this.gen4Key=e,this.gen4Val=t,this.gen4Weight=r,this.gen3Key=i,this.gen3Val=n,this.gen3Weight=s,this.gen2Key=o,this.gen2Val=a,this.gen2Weight=u,this.gen1Key=h,this.gen1Val=l,this.gen1Weight=c}}class R{constructor(e){this.buckets=new Array(e),this.gen4Hits=0,this.gen3Hits=0,this.gen2Hits=0,this.gen1Hits=0,this.misses=0}put(e){if(0===this.buckets.length)return e;const t=Math.abs(w.hash(e))%this.buckets.length,r=this.buckets[t]||new H,i=r.gen4Val;if(void 0!==i&&w.equal(e,i))return this.gen4Hits+=1,r.gen4Weight++,i;const n=r.gen3Val;if(void 0!==n&&w.equal(e,n))return this.gen3Hits+=1,r.gen3Weight++>r.gen4Weight&&(this.buckets[t]=new H(r.gen3Val,r.gen3Weight,r.gen4Val,r.gen4Weight,r.gen2Val,r.gen2Weight,r.gen1Val,r.gen1Weight)),n;const s=r.gen2Val;if(void 0!==s&&w.equal(e,s))return this.gen2Hits+=1,r.gen2Weight++>r.gen3Weight&&(this.buckets[t]=new H(r.gen4Val,r.gen4Weight,r.gen2Val,r.gen2Weight,r.gen3Val,r.gen3Weight,r.gen1Val,r.gen1Weight)),s;const o=r.gen1Val;return void 0!==o&&w.equal(e,o)?(this.gen1Hits+=1,r.gen1Weight++>r.gen2Weight&&(this.buckets[t]=new H(r.gen4Val,r.gen4Weight,r.gen3Val,r.gen3Weight,r.gen1Val,r.gen1Weight,r.gen2Val,r.gen2Weight)),o):(this.misses+=1,this.buckets[t]=void 0===i?new H(r.gen3Val,r.gen3Weight,r.gen2Val,r.gen2Weight,r.gen1Val,r.gen1Weight,e,1):void 0===n?new H(r.gen4Val,r.gen4Weight,r.gen2Val,r.gen2Weight,r.gen1Val,r.gen1Weight,e,1):void 0===s?new H(r.gen4Val,r.gen4Weight,r.gen3Val,r.gen3Weight,r.gen1Val,r.gen1Weight,e,1):void 0===o?new H(r.gen4Val,r.gen4Weight,r.gen3Val,r.gen3Weight,r.gen2Val,r.gen2Weight,e,1):new H(r.gen4Val,r.gen4Weight-1,r.gen3Val,r.gen3Weight-1,r.gen1Val,r.gen1Weight,e,1),e)}remove(e){if(0===this.buckets.length)return!1;const t=Math.abs(w.hash(e))%this.buckets.length,r=this.buckets[t];if(void 0===r)return!1;const i=r.gen4Val;if(void 0!==i&&w.equal(e,i))return this.buckets[t]=new H(r.gen3Val,r.gen3Weight,r.gen2Val,r.gen2Weight,r.gen1Val,r.gen1Weight,void 0,0),!0;const n=r.gen3Val;if(void 0!==n&&w.equal(e,n))return this.buckets[t]=new H(r.gen4Val,r.gen4Weight,r.gen2Val,r.gen2Weight,r.gen1Val,r.gen1Weight,void 0,0),!0;const s=r.gen2Val;if(void 0!==s&&w.equal(e,s))return this.buckets[t]=new H(r.gen4Val,r.gen4Weight,r.gen3Val,r.gen3Weight,r.gen1Val,r.gen1Weight,void 0,0),!0;const o=r.gen1Val;return!(void 0===o||!w.equal(e,o))&&(this.buckets[t]=new H(r.gen4Val,r.gen4Weight,r.gen3Val,r.gen3Weight,r.gen2Val,r.gen2Weight,void 0,0),!0)}clear(){for(let e=0;e<this.buckets.length;e+=1)this.buckets[e]=void 0}get hits(){return this.gen4Hits+this.gen3Hits+this.gen2Hits+this.gen1Hits}get hitRatio(){const e=this.hits;return e/(e+this.misses)}}class H{constructor(e,t=0,r,i=0,n,s=0,o,a=0){this.gen4Val=e,this.gen4Weight=t,this.gen3Val=r,this.gen3Weight=i,this.gen2Val=n,this.gen2Weight=s,this.gen1Val=o,this.gen1Weight=a}}class K{constructor(e,t){this.level=e,this.label=t}isTrace(){return this.level===K.TRACE_LEVEL}isDebug(){return this.level===K.DEBUG_LEVEL}isInfo(){return this.level===K.INFO_LEVEL}isNote(){return this.level===K.NOTE_LEVEL}isWarning(){return this.level===K.WARNING_LEVEL}isError(){return this.level===K.ERROR_LEVEL}isAlert(){return this.level===K.ALERT_LEVEL}isFatal(){return this.level===K.FATAL_LEVEL}compareTo(e){return this===e?0:e instanceof K?this.level<e.level?-1:this.level>e.level?1:this.label.localeCompare(e.label):NaN}equals(e){return this===e||e instanceof K&&(this.level===e.level&&this.label===e.label)}hashCode(){return i.mash(i.mix(i.mix(l.hash(K),a.hash(this.level)),u.hash(this.label)))}toString(){return this.label}static create(e,t){switch(e){case K.TRACE_LEVEL:return K.trace(t);case K.DEBUG_LEVEL:return K.debug(t);case K.INFO_LEVEL:return K.info(t);case K.NOTE_LEVEL:return K.note(t);case K.WARNING_LEVEL:return K.warning(t);case K.ERROR_LEVEL:return K.error(t);case K.ALERT_LEVEL:return K.alert(t);case K.FATAL_LEVEL:return K.fatal(t);default:throw new Error(""+e)}}static trace(e="trace"){return"trace"===e?(void 0===K._trace&&(K._trace=new K(K.TRACE_LEVEL,e)),K._trace):new K(K.TRACE_LEVEL,e)}static debug(e="debug"){return"debug"===e?(void 0===K._debug&&(K._debug=new K(K.DEBUG_LEVEL,e)),K._debug):new K(K.DEBUG_LEVEL,e)}static info(e="info"){return"info"===e?(void 0===K._info&&(K._info=new K(K.INFO_LEVEL,e)),K._info):new K(K.INFO_LEVEL,e)}static note(e="note"){return"note"===e?(void 0===K._note&&(K._note=new K(K.NOTE_LEVEL,e)),K._note):new K(K.NOTE_LEVEL,e)}static warning(e="warning"){return"warning"===e?(void 0===K._warning&&(K._warning=new K(K.WARNING_LEVEL,e)),K._warning):new K(K.WARNING_LEVEL,e)}static error(e="error"){return"error"===e?(void 0===K._error&&(K._error=new K(K.ERROR_LEVEL,e)),K._error):new K(K.ERROR_LEVEL,e)}static alert(e="alert"){return"alert"===e?(void 0===K._alert&&(K._alert=new K(K.ALERT_LEVEL,e)),K._alert):new K(K.ALERT_LEVEL,e)}static fatal(e="fatal"){return"fatal"===e?(void 0===K._fatal&&(K._fatal=new K(K.FATAL_LEVEL,e)),K._fatal):new K(K.FATAL_LEVEL,e)}}K.TRACE_LEVEL=0,K.DEBUG_LEVEL=1,K.INFO_LEVEL=2,K.NOTE_LEVEL=3,K.WARNING_LEVEL=4,K.ERROR_LEVEL=5,K.ALERT_LEVEL=6,K.FATAL_LEVEL=7;class _{}class G extends _{constructor(e,t,r,i){super(),this.offset=e,this.line=t,this.column=r,this.note=i}withNote(e){return this.note!==e?G.at(this.offset,this.line,this.column,e):this}min(e){return this.offset<=e.offset?this:e}max(e){return this.offset>=e.offset?this:e}get start(){return this}get end(){return this}union(e){if(e instanceof G)return this.offset===e.offset&&this.line===e.line&&this.column===e.column?this:Q.from(this,e);if(e instanceof Q){const t=this.min(e.start),r=this.max(e.end);return t===e.start&&r===e.end?e:Q.from(t,r)}throw new Error(e.toString())}shift(e){const t=this.offset+(this.offset-e.offset),r=this.line+(this.line-e.line);let i=this.column;return 1===r&&(i+=this.column-e.column),t===this.offset&&r===this.line&&i===this.column?this:G.at(t,r,i,this.note)}equals(e){return this===e||e instanceof G&&(this.offset===e.offset&&this.line===e.line&&this.column===e.column&&this.note===e.note)}hashCode(){return i.mash(i.mix(i.mix(i.mix(i.mix(l.hash(G),a.hash(this.offset)),a.hash(this.line)),a.hash(this.column)),u.hash(this.note)))}display(e){return e=(e=he.displayNumber(e,this.line)).write(58),e=he.displayNumber(e,this.column),void 0!==this.note&&(e=e.write(58).write(32).write(this.note)),e}debug(e){return e=e.write("Mark").write(".").write("at").write("("),e=(e=he.debugNumber(e,this.offset)).write(", "),e=(e=he.debugNumber(e,this.line)).write(", "),e=he.debugNumber(e,this.column),void 0!==this.note&&(e=e.write(", "),e=he.debugString(e,this.note)),e=e.write(")")}toString(){return he.display(this)}static get zero(){return new G(0,1,1,void 0)}static at(e,t,r,i){return new G(e,t,r,i)}}e([n],G,"zero",null);class Q extends _{constructor(e,t){super(),this.start=e,this.end=t}union(e){if(e instanceof G){const t=this.start.min(e),r=this.end.max(e);return t===this.start&&r===this.end?this:Q.from(t,r)}if(e instanceof Q){const t=this.start.min(e.start),r=this.end.max(e.end);return t===this.start&&r===this.end?this:Q.from(t,r)}throw new Error(e.toString())}shift(e){const t=this.start.shift(e),r=this.end.shift(e);return t===this.start&&r===this.end?this:Q.from(t,r)}equals(e){return this===e||e instanceof Q&&(this.start.equals(e.start)&&this.end.equals(e.end))}hashCode(){return i.mash(i.mix(i.mix(l.hash(Q),this.start.hashCode()),this.end.hashCode()))}display(e){return void 0!==this.start.note&&(e=e.write(this.start.note).write(58).write(32)),e=(e=he.displayNumber(e,this.start.line)).write(58),e=(e=he.displayNumber(e,this.start.column)).write(45),e=(e=he.displayNumber(e,this.end.line)).write(58),e=he.displayNumber(e,this.end.column),void 0!==this.end.note&&(e=e.write(58).write(32).write(this.end.note)),e}debug(e){return e=e.write("Span").write(".").write("from").write("("),e=(e=this.start.debug(e)).write(", "),e=(e=this.end.debug(e)).write(")")}toString(){return he.display(this)}static from(e,t){if(e.offset>t.offset){const r=e;e=t,t=r}return new Q(e,t)}}const Z=function(){const e={reset:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(48).write(109)),e},bold:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(49).write(109)),e},faint:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(50).write(109)),e},black:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(48).write(59).write(51).write(48).write(109)),e},red:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(48).write(59).write(51).write(49).write(109)),e},green:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(48).write(59).write(51).write(50).write(109)),e},yellow:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(48).write(59).write(51).write(51).write(109)),e},blue:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(48).write(59).write(51).write(52).write(109)),e},magenta:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(48).write(59).write(51).write(53).write(109)),e},cyan:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(48).write(59).write(51).write(54).write(109)),e},gray:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(48).write(59).write(51).write(55).write(109)),e},blackBold:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(49).write(59).write(51).write(48).write(109)),e},redBold:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(49).write(59).write(51).write(49).write(109)),e},greenBold:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(49).write(59).write(51).write(50).write(109)),e},yellowBold:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(49).write(59).write(51).write(51).write(109)),e},blueBold:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(49).write(59).write(51).write(52).write(109)),e},magentaBold:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(49).write(59).write(51).write(53).write(109)),e},cyanBold:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(49).write(59).write(51).write(54).write(109)),e},grayBold:function(e){return e.settings.isStyled()&&(e=e.write(27).write(91).write(49).write(59).write(51).write(55).write(109)),e}};return e}();class X{constructor(e,t,r,i){Object.defineProperty(this,"lineSeparator",{value:e,enumerable:!0}),Object.defineProperty(this,"pretty",{value:t,enumerable:!0}),Object.defineProperty(this,"styled",{value:r,enumerable:!0}),Object.defineProperty(this,"precision",{value:i,enumerable:!0})}withLineSeparator(e){return this.copy(e,this.pretty,this.styled,this.precision)}isPretty(){return this.pretty}asPretty(e){return this.copy(this.lineSeparator,e,this.styled,this.precision)}isStyled(){return this.styled}asStyled(e){return this.copy(this.lineSeparator,this.pretty,e,this.precision)}withPrecision(e){return this.copy(this.lineSeparator,this.pretty,this.styled,e)}copy(e,t,r,i){return X.create(e,t,r,i)}canEqual(e){return e instanceof X}equals(e){return this===e||e instanceof X&&(e.canEqual(this)&&this.lineSeparator===e.lineSeparator&&this.pretty===e.pretty&&this.styled===e.styled&&this.precision===e.precision)}hashCode(){return i.mash(i.mix(i.mix(i.mix(i.mix(l.hash(X),u.hash(this.lineSeparator)),s.hash(this.pretty)),s.hash(this.styled)),a.hash(this.precision)))}debug(e){return e=e.write("OutputSettings").write(46),e=(e=this.pretty||this.styled?this.pretty&&!this.styled?e.write("pretty"):!this.pretty&&this.styled?e.write("styled"):e.write("prettyStyled"):e.write("standard")).write(40).write(41),this.lineSeparator!==he.lineSeparator&&(e=e.write(46).write("lineSeparator").write(40).display(this.lineSeparator).write(41)),-1!==this.precision&&(e=e.write(46).write("precision").write(40).display(this.precision).write(41)),e}toString(){return he.debug(this)}static standard(){return new X(he.lineSeparator,!1,!1,-1)}static pretty(){return new X(he.lineSeparator,!0,!1,-1)}static styled(){return new X(he.lineSeparator,!1,!0,-1)}static prettyStyled(){return new X(he.lineSeparator,!0,!0,-1)}static create(e,t,r,i){return"string"!=typeof e&&(e=he.lineSeparator),"boolean"!=typeof t&&(t=!1),"boolean"!=typeof r&&(r=!1),"number"!=typeof i&&(i=-1),e===he.lineSeparator&&-1===i?t||r?t&&!r?X.pretty():!t&&r?X.styled():X.prettyStyled():X.standard():new X(e,t,r,i)}static fromInit(e){return X.create(e.lineSeparator,e.isPretty,e.isStyled,e.precision)}static fromAny(e){return e instanceof X?e:"object"==typeof e&&null!==e?X.fromInit(e):X.standard()}}e([n],X,"standard",null),e([n],X,"pretty",null),e([n],X,"styled",null),e([n],X,"prettyStyled",null);class $ extends Error{constructor(e){super(e),Object.setPrototypeOf(this,$.prototype)}}class Y{constructor(e){Object.defineProperty(this,"stripped",{value:e,enumerable:!0})}isStripped(){return this.stripped}asStripped(e){return this.copy(e)}copy(e){return Y.create(e)}canEqual(e){return e instanceof Y}equals(e){return this===e||e instanceof Y&&(e.canEqual(this)&&this.stripped===e.stripped)}hashCode(){return i.mash(i.mix(l.hash(Y),s.hash(this.stripped)))}debug(e){return e=e.write("InputSettings").write(46),e=(e=this.stripped?e.write("stripped"):e.write("standard")).write(40).write(41)}toString(){return he.debug(this)}static standard(){return new Y(!1)}static stripped(){return new Y(!0)}static create(e){return e?Y.stripped():Y.standard()}static fromAny(e){return e instanceof Y?e:"object"==typeof e&&null!==e?Y.create(e.isStripped):Y.standard()}}e([n],Y,"standard",null),e([n],Y,"stripped",null);class J{trap(){throw new $}static empty(){return new de(void 0,G.zero,Y.standard())}static done(){return new pe(void 0,G.zero,Y.standard())}static error(e){return new ee(e,void 0,G.zero,Y.standard())}}e([n],J,"empty",null),e([n],J,"done",null);class ee extends J{constructor(e,t,r,i){super(),Object.defineProperty(this,"error",{value:e,enumerable:!0}),Object.defineProperty(this,"id",{value:t,enumerable:!0}),Object.defineProperty(this,"mark",{value:r,enumerable:!0}),Object.defineProperty(this,"settings",{value:i,enumerable:!0})}isCont(){return!1}isEmpty(){return!1}isDone(){return!1}isError(){return!0}isPart(){return!1}asPart(e){return this}head(){throw new $}step(){const e=new $("error step");return new ee(e,this.id,this.mark,this.settings)}trap(){return this.error}seek(e){const t=new $("error seek");return new ee(t,this.id,this.mark,this.settings)}withId(e){return new ee(this.error,e,this.mark,this.settings)}withMark(e){return new ee(this.error,this.id,e,this.settings)}get offset(){return this.mark.offset}get line(){return this.mark.line}get column(){return this.mark.column}withSettings(e){return e=Y.fromAny(e),new ee(this.error,this.id,this.mark,e)}clone(){return this}}class te extends J{constructor(e,t,r,i,n,s,o,a){super(),this.string=e,this.index=o,this.part=a,this.id=t,this.offset=r,this.line=i,this.column=n,this.settings=s}isCont(){return this.index<this.string.length}isEmpty(){return this.part&&this.index>=this.string.length}isDone(){return!this.part&&this.index>=this.string.length}isError(){return!1}isPart(){return this.part}asPart(e){return this.part=e,this}head(){const e=this.string,t=this.index;if(t<e.length){const r=e.codePointAt(t);return void 0!==r?r:e.charCodeAt(t)}throw new $}step(){const e=this.string,t=this.index;if(t<e.length){const r=e.codePointAt(t);return this.index=u.offsetByCodePoints(e,t,1),this.offset+=this.index-t,10===r?(this.line+=1,this.column=1):this.column+=1,this}{const e=new $("invalid step");return new ee(e,this.id,this.mark,this.settings)}}seek(e){if(void 0!==e){const t=this.index+(e.offset-this.offset);if(0<=t&&t<=this.string.length)return this.index=t,this.offset=e.offset,this.line=e.line,this.column=e.column,this;{const t=new $("invalid seek to "+e);return new ee(t,this.id,this.mark,this.settings)}}return this.index=0,this.offset=0,this.line=1,this.column=1,this}withId(e){return this.id=e,this}get mark(){return G.at(this.offset,this.line,this.column)}withMark(e){return this.offset=e.offset,this.line=e.line,this.column=e.column,this}withSettings(e){return e=Y.fromAny(e),this.settings=e,this}clone(){return new te(this.string,this.id,this.offset,this.line,this.column,this.settings,this.index,this.part)}static create(e){return new te(e,void 0,0,1,1,Y.standard(),0,!1)}}class re extends Error{constructor(e){super(e),Object.setPrototypeOf(this,re.prototype)}}class ie{writeln(e){return"string"==typeof e&&this.write(e),this.write(this.settings.lineSeparator)}display(e){return he.displayAny(this,e)}debug(e){return he.debugAny(this,e)}flush(){return this}push(...e){const t=e.length;for(let r=0;r<t;r+=1)this.write(e[r])}trap(){throw new re}clone(){throw new Error}static full(){return new ye(X.standard())}static done(){return new be(X.standard())}static error(e){return new ve(e,X.standard())}}e([n],ie,"full",null),e([n],ie,"done",null);class ne extends ie{constructor(e,t){super(),this.string=e,this.settings=t}isCont(){return!0}isFull(){return!1}isDone(){return!1}isError(){return!1}isPart(){return!1}asPart(e){return this}write(e){if("number"==typeof e)if(e>=0&&e<=55295||e>=57344&&e<=65535)e=String.fromCharCode(e);else if(e>=65536&&e<=1114111){const t=e-65536;e=String.fromCharCode(55296|t>>>10,56320|1023&t)}else e="";return this.string+=e,this}writeln(e){return void 0!==e&&(this.string=this.string.concat(e)),this.string=this.string.concat(this.settings.lineSeparator),this}withSettings(e){return e=X.fromAny(e),this.settings=e,this}bind(){return this.string}clone(){return new ne(this.string,this.settings)}toString(){return this.string}}class se extends Error{constructor(e){super(e),Object.setPrototypeOf(this,se.prototype)}}class oe{isCont(){return!0}isDone(){return!1}isError(){return!1}feed(e){throw new se}fork(e){return this}bind(){throw new se}trap(){throw new se}asDone(){throw new se}asError(){throw new se}andThen(e){return new Ie(this,e)}static end(){return new Pe}static done(e){return new De(e)}static error(e){return new qe(e)}}e([n],oe,"end",null);class ae extends oe{constructor(e,t,r=0){super(),this.value=e,this.input=t,this.index=r}feed(e){return new ae(e,""+e)}pull(e){return ae.write(e,this.value,this.input,this.index)}static write(e,t,r,i=0){const n=r.length;for(;i<n&&e.isCont();){let t=r.codePointAt(i);void 0===t&&(t=r.charCodeAt(i)),e=e.write(t),i=u.offsetByCodePoints(r,i,1)}return i===n?oe.done(t):e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new ae(t,r,i)}}const ue=function(){const e={stringInput:function(e){return te.create(e)},stringOutput:function(e,t){return void 0===t&&"string"!=typeof e?(t=e,e=""):"string"!=typeof e&&(e=""),t=X.fromAny(t),new ne(e,t)},stringWriter:function(e){return void 0===e?new ae(void 0,""):new ae(e,""+e)},writeString:function(e,t){return ae.write(e,void 0,""+t)},isAlpha:function(e){return e>=65&&e<=90||e>=97&&e<=122},isDigit:function(e){return e>=48&&e<=57},isSpace:function(e){return 32===e||9===e},isNewline:function(e){return 10===e||13===e},isWhitespace:function(t){return e.isSpace(t)||e.isNewline(t)}};return e}(),he=function(){const e={};return Object.defineProperty(e,"lineSeparator",{value:"\\n",enumerable:!0,configurable:!0}),e.display=function(e,t){if(void 0===e)return"undefined";if(null===e)return"null";if("number"==typeof e)return""+e;if("string"==typeof e)return e;if("function"==typeof e.display){let r=ue.stringOutput(t);return r=e.display(r),r.bind()}return""+e},e.debug=function(t,r){if(void 0===t)return"undefined";if(null===t)return"null";if("number"==typeof t)return""+t;if("string"==typeof t){let i=ue.stringOutput(r);return i=e.debugString(i,t),i.bind()}if("function"==typeof t.debug){let e=ue.stringOutput(r);return e=t.debug(e),e.bind()}return""+t},e.displayAny=function(t,r){return t=void 0===r?t.write("undefined"):null===r?t.write("null"):"number"==typeof r?e.displayNumber(t,r):"string"==typeof r?t.write(r):"function"==typeof r.display?r.display(t):t.write(""+r)},e.debugAny=function(t,r){return t=void 0===r?t.write("undefined"):null===r?t.write("null"):"number"==typeof r?e.debugNumber(t,r):"string"==typeof r?e.debugString(t,r):"function"==typeof r.debug?r.debug(t):t.write(""+r)},e.displayNumber=function(t,r){if(isFinite(r)&&Math.floor(r)===r&&Math.abs(r)<2147483648)if(r<0&&(t=t.write(45)),r>-10&&r<10)t=t.write(48+Math.abs(r));else{const e=new Array(19);let i=r,n=18;for(;0!==i;)e[n]=Math.abs(i%10|0),i=i/10|0,n-=1;for(n+=1;n<19;)t=t.write(48+e[n]),n+=1}else t=t.write(e.decimal(r,t.settings.precision));return t},e.debugNumber=function(t,r){return e.displayNumber(t,r)},e.debugChar=function(t,r){switch(t=t.write(39),r){case 8:t.write(92).write(98);break;case 9:t.write(92).write(116);break;case 10:t.write(92).write(110);break;case 12:t.write(92).write(102);break;case 13:t.write(92).write(114);break;case 34:t.write(92).write(34);break;case 39:t.write(92).write(39);break;case 92:t.write(92).write(92);break;default:t=r>=0&&r<=31||r>=127&&r<=159?t.write(92).write(117).write(e.encodeHex(r>>>12&15)).write(e.encodeHex(r>>>8&15)).write(e.encodeHex(r>>>4&15)).write(e.encodeHex(15&r)):t.write(r)}return t=t.write(39)},e.debugString=function(t,r){t=t.write(34);let i=ue.stringInput(r);for(;i.isCont();){const r=i.head();switch(r){case 8:t.write(92).write(98);break;case 9:t.write(92).write(116);break;case 10:t.write(92).write(110);break;case 12:t.write(92).write(102);break;case 13:t.write(92).write(114);break;case 34:t.write(92).write(34);break;case 92:t.write(92).write(92);break;default:t=r>=0&&r<=31||r>=127&&r<=159?t.write(92).write(117).write(e.encodeHex(r>>>12&15)).write(e.encodeHex(r>>>8&15)).write(e.encodeHex(r>>>4&15)).write(e.encodeHex(15&r)):t.write(r)}i=i.step()}return t=t.write(34)},e.encodeHex=function(e){return e<10?48+e:e-10+65},e.prefix=function(){const t=["y","z","a","f","p","n","","m","","k","M","G","T","P","E"," Z","Y"];return function(r,i=1){if(isFinite(r)){const n=Math.abs(r).toExponential(),s=n.indexOf("e"),o=s>=0?+n.slice(s+1):NaN,a=3*Math.min(Math.max(-8,Math.floor(o/3)),8),u=Math.pow(10,-a)*r;let h=e.trimTrailingZeros(Math.abs(u).toFixed(i));return u<0&&0!=+h&&(h="-"+h),h+=t[8+a/3],h}return""+r}}(),e.decimal=function(t,r=-1){if(r>=0){let i=e.trimTrailingZeros(Math.abs(t).toFixed(r));return t<0&&0!=+i&&(i="-"+i),i}return""+t},e.trimTrailingZeros=function(e){let t,r=-1;for(let i=1,n=e.length;i<n;i+=1){const n=e.charCodeAt(i);if(46===n)r=i,t=i;else if(48===n)0===r&&(r=i),t=i;else if(n>=49&&n<=57)r>0&&(r=0);else if(r>0)break}return r>0&&(e=e.slice(0,r)+e.slice(t+1)),e},e.duration=function(e,t=" "){if(isFinite(e)){const r=1e3,i=60*r,n=60*i,s=24*n,o=7*s;let a,u,h,l,c;e>o&&(a=Math.floor(e/o),e%=o),e>s&&(u=Math.floor(e/s),e%=s),e>n&&(h=Math.floor(e/n),e%=n),e>i&&(l=Math.floor(e/i),e%=i),e>r&&(c=Math.floor(e/r),e%=r);let d="";return void 0!==a&&(d+=a+"w"),void 0!==u&&(d+=(0!==d.length?t:"")+u+"d"),void 0!==h&&(d+=(0!==d.length?t:"")+h+"h"),void 0!==l&&(d+=(0!==d.length?t:"")+l+"m"),void 0===c&&0!==e||(d+=(0!==d.length?t:"")+(void 0!==c?c:0)+"s"),0!==e&&0===d.length&&(d+=e+"ms"),d}return""+e},e}(),le=function(){const e={isDigit:function(e){return e>=48&&e<=57},decodeDigit:function(e){if(e>=48&&e<=57)return e-48;{let t=ue.stringOutput();throw t=t.write("Invalid base-10 digit: "),t=he.debugChar(t,e),new Error(t.bind())}},encodeDigit:function(e){if(e>=0&&e<=9)return 48+e;throw new Error(""+e)},countDigits:function(e){let t=0;do{t+=1,e=e/10|0}while(0!==e);return t},integerParser:function(){return new He(void 0,void 0,0)},parseInteger:function(e){return He.parse(e,void 0,void 0,0)},decimalParser:function(){return new He(void 0,void 0,1)},parseDecimal:function(e){return He.parse(e,void 0,void 0,1)},numberParser:function(){return new He},parseNumber:function(e){return He.parse(e)},integerWriter:function(e){return new _e(void 0,void 0===e?0:e)},writeInteger:function(e,t){return _e.write(e,void 0,t)}};return e}();class ce{constructor(e,t,r,i,n,s){this.input=e,this.tag=t,this.severity=r,this.message=i,this.note=n,this.cause=s}lineDigits(){let e=le.countDigits(this.tag.end.line);return null!==this.cause&&(e=Math.max(e,this.cause.lineDigits())),e}display(e){const t=this.input.clone(),r=this.tag.start,i=this.tag.end,n=this.severity,s=this.message,o=this.note,a=this.cause,u=this.lineDigits();return e=ce.display(e,t,r,i,n,s,o,a,2,u)}static display(e,t,r,i,n,s,o,a,u,h){for(;;){void 0!==s&&(e=(e=ce.displayMessage(e,n,s)).writeln()),e=(e=ce.displayAnchor(e,t,r,h)).writeln();const l=ce.displayContext(e,t,r,i,n,o,a,u,h),c=l[0];if(e=l[1],null===c)break;e=e.writeln(),t=c.input.clone(),r=c.tag.start,i=c.tag.end,n=c.severity,s=c.message,o=c.note,a=c.cause}return e}static displayMessage(e,t,r){return e=(e=ce.formatSeverity(e,t)).write(t.label),e=Z.reset(e),e=(e=Z.bold(e)).write(58),void 0!==r&&(e=e.write(32).write(r)),e=Z.reset(e)}static displayAnchor(e,t,r,i){e=(e=ce.displayLineLeadArrow(e,i)).write(32);const n=t.id;return void 0!==n&&(e=he.displayAny(e,n)),e=e.write(58),e=(e=he.displayNumber(e,r.line)).write(58),e=(e=he.displayNumber(e,r.column)).writeln(),e=ce.displayLineLead(e,i)}static displayContext(e,t,r,i,n,s,o,a,u){let h=o;const l=null!==o&&void 0===o.message&&w.equal(t.id,o.input.id)?r.offset<=o.tag.start.offset?-1:1:0;if(1===l){const t=ce.displayContext(e,o.input.clone(),o.tag.start,o.tag.end,o.severity,o.note,o.cause,a,u);h=t[0],e=(e=t[1]).writeln(),e=(e=ce.displayLineLeadEllipsis(e,u)).writeln()}if(e=ce.displayLines(e,t,r,i,n,a,u),void 0!==s&&(e=ce.displayNote(e,s,u)),-1===l){e=e.writeln(),e=(e=ce.displayLineLeadEllipsis(e,u)).writeln();const t=ce.displayContext(e,o.input.clone(),o.tag.start,o.tag.end,o.severity,o.note,o.cause,a,u);h=t[0],e=t[1]}return[h,e]}static displayLines(e,t,r,i,n,s,o){const a=r.line,u=i.line;let h=t.line;for(;h<a;)ce.consumeLineText(t,h),h+=1;if(u-a>2*s+2){for(;h<=a+s;)e=ce.displayLine(e,t,r,i,n,h,o),h+=1;for(e=(e=ce.displayLineLeadEllipsis(e,o)).write(32),e=(e=ce.formatSeverity(e,n)).write(124),e=(e=Z.reset(e)).writeln();h<u-s;)ce.consumeLineText(t,h),h+=1}for(;h<=u;)e=ce.displayLine(e,t,r,i,n,h,o),h+=1;return e}static displayNote(e,t,r){return e=e.writeln(),e=(e=ce.displayLineLead(e,r)).writeln(),e=ce.displayLineComment(e,"note",t,r)}static displayLine(e,t,r,i,n,s,o){return e=r.line===s&&i.line===s?ce.displaySingleLine(e,t,r,i,n,s,o):r.line===s?ce.displayStartLine(e,t,r,n,s,o):i.line===s?ce.displayEndLine(e,t,i,n,s,o):ce.displayMidLine(e,t,n,s,o)}static displaySingleLine(e,t,r,i,n,s,o){e=(e=ce.displayLineLeadNumber(e,s,o)).write(32);for(let r=1;r<t.column;r+=1)e=e.write(32);e=ce.displayLineText(e,t,s),e=(e=ce.displayLineLead(e,o)).write(32);let a=1;for(;a<r.column;)e=e.write(32),a+=1;for(e=ce.formatSeverity(e,n);a<=i.column;)e=e.write(94),a+=1;return void 0!==i.note&&(e=e.write(32).write(i.note)),e=Z.reset(e)}static displayStartLine(e,t,r,i,n,s){e=(e=ce.displayLineLeadNumber(e,n,s)).write(32).write(32).write(32);for(let r=1;r<t.column;r+=1)e=e.write(32);e=ce.displayLineText(e,t,n),e=(e=ce.displayLineLead(e,s)).write(32).write(32),e=(e=ce.formatSeverity(e,i)).write(95);let o=1;for(;o<r.column;)e=e.write(95),o+=1;return e=e.write(94),void 0!==r.note&&(e=e.write(32).write(r.note)),e=(e=Z.reset(e)).writeln()}static displayEndLine(e,t,r,i,n,s){e=(e=ce.displayLineLeadNumber(e,n,s)).write(32),e=(e=ce.formatSeverity(e,i)).write(124),e=(e=Z.reset(e)).write(32),e=ce.displayLineText(e,t,n),e=(e=ce.displayLineLead(e,s)).write(32),e=(e=ce.formatSeverity(e,i)).write(124).write(95);let o=1;for(;o<r.column;)e=e.write(95),o+=1;return e=e.write(94),void 0!==r.note&&(e=e.write(32).write(r.note)),e=Z.reset(e)}static displayMidLine(e,t,r,i,n){return e=(e=ce.displayLineLeadNumber(e,i,n)).write(32),e=(e=ce.formatSeverity(e,r)).write(124),e=(e=Z.reset(e)).write(32),e=ce.displayLineText(e,t,i)}static displayLineComment(e,t,r,i){return e=(e=ce.displayLineLeadComment(e,i)).write(32),e=(e=Z.bold(e)).write(t).write(58),e=Z.reset(e),void 0!==r&&(e=e.write(32).write(r)),e}static displayLineLead(e,t){e=Z.blueBold(e);const r=1+t;for(let t=0;t<r;t+=1)e=e.write(32);return e=e.write(124),e=Z.reset(e)}static displayLineLeadComment(e,t){e=Z.blueBold(e);const r=1+t;for(let t=0;t<r;t+=1)e=e.write(32);return e=e.write(61),e=Z.reset(e)}static displayLineLeadArrow(e,t){for(let r=0;r<t;r+=1)e=e.write(32);return e=(e=Z.blueBold(e)).write(45).write(45).write(62),e=Z.reset(e)}static displayLineLeadEllipsis(e,t){e=Z.blueBold(e);for(let r=0;r<t;r+=1)e=e.write(46);return e=(e=Z.reset(e)).write(32).write(32)}static displayLineLeadNumber(e,t,r){const i=r-le.countDigits(t);for(let t=0;t<i;t+=1)e=e.write(32);return e=Z.blueBold(e),e=(e=he.displayNumber(e,t)).write(32).write(124),e=Z.reset(e)}static displayLineText(e,t,r){for(;t.isCont()&&t.line===r;)e=e.write(t.head()),t=t.step();return t.line===r&&(e=e.writeln()),e}static consumeLineText(e,t){for(;e.isCont()&&e.line===t;)e=e.step()}static formatSeverity(e,t){switch(t.level){case K.FATAL_LEVEL:case K.ALERT_LEVEL:case K.ERROR_LEVEL:e=Z.redBold(e);break;case K.WARNING_LEVEL:e=Z.yellowBold(e);break;case K.NOTE_LEVEL:e=Z.greenBold(e);break;case K.INFO_LEVEL:e=Z.cyanBold(e);break;case K.DEBUG_LEVEL:case K.TRACE_LEVEL:default:e=Z.magentaBold(e)}return e}toString(e){return he.display(this,e)}static create(e,t,r,i,n,s){return 3===arguments.length?(s=null,n=void 0,i=void 0):4===arguments.length?null===i||i instanceof ce?(s=i,i=void 0):s=null:5===arguments.length?null===n||n instanceof ce?(s=n,n=void 0):s=null:void 0===s&&(s=null),new ce(e.clone(),t,r,i,n,s)}static message(e,t,r,i,n){2===arguments.length?(n=null,i=void 0,r=K.error()):3===arguments.length?null===r||r instanceof ce?(n=r,r=K.error()):"string"==typeof r?(n=null,i=r,r=K.error()):n=null:4===arguments.length?"string"==typeof r?(n=i,i=r,r=K.error()):null===i||i instanceof ce?(n=i,i=void 0):n=null:void 0===n&&(n=null);const s=t.mark,o=t.clone();return o.seek(),new ce(o,s,r,e,i,n)}static unexpected(e,t,r,i){let n;if(1===arguments.length?(i=null,t=K.error()):2===arguments.length?null===t||t instanceof ce?(i=t,t=K.error()):"string"==typeof t?(i=null,r=t,t=K.error()):i=null:3===arguments.length?"string"==typeof t?(i=r,r=t,t=K.error()):null===r||r instanceof ce?(i=r,r=void 0):i=null:void 0===i&&(i=null),e.isCont()){let t=ue.stringOutput().write("unexpected").write(32);t=he.debugChar(t,e.head()),n=t.bind()}else n="unexpected end of input";const s=e.mark,o=e.clone();return o.seek(),new ce(o,s,t,n,r,i)}static expected(e,t,r,i,n){2===arguments.length?(n=null,r=K.error()):3===arguments.length?null===r||r instanceof ce?(n=r,r=K.error()):"string"==typeof r?(n=null,i=r,r=K.error()):n=null:4===arguments.length?"string"==typeof r?(n=i,i=r,r=K.error()):null===i||i instanceof ce?(n=i,i=void 0):n=null:void 0===n&&(n=null);let s=ue.stringOutput().write("expected").write(32);s="number"==typeof e?he.debugChar(s,e):s.write(e),s=s.write(44).write(32).write("but found").write(32),s=t.isCont()?he.debugChar(s,t.head()):s.write("end of input");const o=s.bind(),a=t.mark,u=t.clone();return u.seek(),new ce(u,a,r,o,i,n)}}class de extends J{constructor(e,t,r){super(),Object.defineProperty(this,"id",{value:e,enumerable:!0}),Object.defineProperty(this,"mark",{value:t,enumerable:!0}),Object.defineProperty(this,"settings",{value:r,enumerable:!0})}isCont(){return!1}isEmpty(){return!0}isDone(){return!1}isError(){return!1}isPart(){return!0}asPart(e){return e?this:new pe(this.id,this.mark,this.settings)}head(){throw new $}step(){const e=new $("empty step");return new ee(e,this.id,this.mark,this.settings)}seek(e){const t=new $("empty seek");return new ee(t,this.id,this.mark,this.settings)}withId(e){return new de(e,this.mark,this.settings)}withMark(e){return new de(this.id,e,this.settings)}get offset(){return this.mark.offset}get line(){return this.mark.line}get column(){return this.mark.column}withSettings(e){return e=Y.fromAny(e),new de(this.id,this.mark,e)}clone(){return this}}class pe extends J{constructor(e,t,r){super(),Object.defineProperty(this,"id",{value:e,enumerable:!0}),Object.defineProperty(this,"mark",{value:t,enumerable:!0}),Object.defineProperty(this,"settings",{value:r,enumerable:!0})}isCont(){return!1}isEmpty(){return!1}isDone(){return!0}isError(){return!1}isPart(){return!1}asPart(e){return e?new de(this.id,this.mark,this.settings):this}head(){throw new $}step(){const e=new $("done step");return new ee(e,this.id,this.mark,this.settings)}seek(e){const t=new $("empty seek");return new ee(t,this.id,this.mark,this.settings)}withId(e){return new pe(e,this.mark,this.settings)}withMark(e){return new pe(this.id,e,this.settings)}get offset(){return this.mark.offset}get line(){return this.mark.line}get column(){return this.mark.column}withSettings(e){return e=Y.fromAny(e),new pe(this.id,this.mark,e)}clone(){return this}}class fe extends J{static empty(){return new we(void 0,G.zero,Y.standard())}static done(){return new me(void 0,G.zero,Y.standard())}static error(e){return new ge(e,void 0,G.zero,Y.standard())}}e([n],fe,"empty",null),e([n],fe,"done",null);class we extends fe{constructor(e,t,r){super(),Object.defineProperty(this,"id",{value:e,enumerable:!0}),Object.defineProperty(this,"mark",{value:t,enumerable:!0}),Object.defineProperty(this,"settings",{value:r,enumerable:!0})}isCont(){return!1}isEmpty(){return!0}isDone(){return!1}isError(){return!1}isPart(){return!0}asPart(e){return e?this:new me(this.id,this.mark,this.settings)}get index(){return 0}withIndex(e){if(0===e)return this;{const e=new $("invalid index");return new ge(e,this.id,this.mark,this.settings)}}get limit(){return 0}withLimit(e){if(0===e)return this;{const e=new $("invalid limit");return new ge(e,this.id,this.mark,this.settings)}}get capacity(){return 0}get remaining(){return 0}has(e){return!1}get(e){throw new $}set(e,t){throw new $}head(){throw new $}step(e){const t=new $("empty step");return new ge(t,this.id,this.mark,this.settings)}seek(e){const t=new $("empty seek");return new ge(t,this.id,this.mark,this.settings)}withId(e){return new we(e,this.mark,this.settings)}withMark(e){return new we(this.id,e,this.settings)}get offset(){return this.mark.offset}get line(){return this.mark.line}get column(){return this.mark.column}withSettings(e){return e=Y.fromAny(e),new we(this.id,this.mark,e)}clone(){return this}}class me extends fe{constructor(e,t,r){super(),Object.defineProperty(this,"id",{value:e,enumerable:!0}),Object.defineProperty(this,"mark",{value:t,enumerable:!0}),Object.defineProperty(this,"settings",{value:r,enumerable:!0})}isCont(){return!1}isEmpty(){return!1}isDone(){return!0}isError(){return!1}isPart(){return!1}asPart(e){return e?new we(this.id,this.mark,this.settings):this}get index(){return 0}withIndex(e){if(0===e)return this;{const e=new $("invalid index");return new ge(e,this.id,this.mark,this.settings)}}get limit(){return 0}withLimit(e){if(0===e)return this;{const e=new $("invalid limit");return new ge(e,this.id,this.mark,this.settings)}}get capacity(){return 0}get remaining(){return 0}has(e){return!1}get(e){throw new $}set(e,t){throw new $}head(){throw new $}step(e){const t=new $("done step");return new ge(t,this.id,this.mark,this.settings)}seek(e){const t=new $("done seek");return new ge(t,this.id,this.mark,this.settings)}withId(e){return new me(e,this.mark,this.settings)}withMark(e){return new me(this.id,e,this.settings)}get offset(){return this.mark.offset}get line(){return this.mark.line}get column(){return this.mark.column}withSettings(e){return e=Y.fromAny(e),new me(this.id,this.mark,e)}clone(){return this}}class ge extends fe{constructor(e,t,r,i){super(),Object.defineProperty(this,"error",{value:e,enumerable:!0}),Object.defineProperty(this,"id",{value:t,enumerable:!0}),Object.defineProperty(this,"mark",{value:r,enumerable:!0}),Object.defineProperty(this,"settings",{value:i,enumerable:!0})}isCont(){return!1}isEmpty(){return!1}isDone(){return!1}isError(){return!0}isPart(){return!1}asPart(e){return this}get index(){return 0}withIndex(e){if(0===e)return this;{const e=new $("invalid index");return new ge(e,this.id,this.mark,this.settings)}}get limit(){return 0}withLimit(e){if(0===e)return this;{const e=new $("invalid limit");return new ge(e,this.id,this.mark,this.settings)}}get capacity(){return 0}get remaining(){return 0}has(e){return!1}get(e){throw new $}set(e,t){throw new $}head(){throw new $}step(e){const t=new $("error step");return new ge(t,this.id,this.mark,this.settings)}trap(){return this.error}seek(e){const t=new $("error seek");return new ge(t,this.id,this.mark,this.settings)}withId(e){return new ge(this.error,e,this.mark,this.settings)}withMark(e){return new ge(this.error,this.id,e,this.settings)}get offset(){return this.mark.offset}get line(){return this.mark.line}get column(){return this.mark.column}withSettings(e){return e=Y.fromAny(e),new ge(this.error,this.id,this.mark,e)}clone(){return this}}class ye extends ie{constructor(e){super(),Object.defineProperty(this,"settings",{value:e,enumerable:!0})}isCont(){return!1}isFull(){return!0}isDone(){return!1}isError(){return!1}isPart(){return!0}asPart(e){return e?this:new be(this.settings)}write(e){return new ve(new re("full"),this.settings)}writeln(e){return new ve(new re("full"),this.settings)}bind(){throw new re}withSettings(e){return e=X.fromAny(e),new ye(e)}clone(){return this}}class be extends ie{constructor(e){super(),Object.defineProperty(this,"settings",{value:e,enumerable:!0})}isCont(){return!1}isFull(){return!1}isDone(){return!0}isError(){return!1}isPart(){return!1}asPart(e){return e?new ye(this.settings):this}write(e){return new ve(new re("done"),this.settings)}writeln(e){return new ve(new re("done"),this.settings)}bind(){throw new re}withSettings(e){return e=X.fromAny(e),new be(e)}clone(){return this}}class ve extends ie{constructor(e,t){super(),Object.defineProperty(this,"error",{value:e,enumerable:!0}),Object.defineProperty(this,"settings",{value:t,enumerable:!0})}isCont(){return!1}isFull(){return!1}isDone(){return!1}isError(){return!0}isPart(){return!1}asPart(e){return this}write(e){return this}writeln(e){return this}bind(){throw new re}trap(){return this.error}withSettings(e){return e=X.fromAny(e),new ve(this.error,e)}clone(){return this}}class xe extends ie{writeln(e){return"string"==typeof e&&this.write(e),this.write(this.settings.lineSeparator)}flush(){return this}clone(){throw new Error}static full(){return new Oe(X.standard())}static done(){return new Ee(X.standard())}static error(e){return new Ce(e,X.standard())}}e([n],xe,"full",null),e([n],xe,"done",null);class Oe extends xe{constructor(e){super(),Object.defineProperty(this,"settings",{value:e,enumerable:!0})}isCont(){return!1}isFull(){return!0}isDone(){return!1}isError(){return!1}isPart(){return!0}asPart(e){return e?this:new Ee(this.settings)}get index(){return 0}withIndex(e){return 0===e?this:new Ce(new re("invalid index"),this.settings)}get limit(){return 0}withLimit(e){return 0===e?this:new Ce(new re("invalid limit"),this.settings)}get capacity(){return 0}get remaining(){return 0}has(e){return!1}get(e){throw new re}set(e,t){throw new re}write(e){return new Ce(new re("full"),this.settings)}writeln(e){return new Ce(new re("full"),this.settings)}step(e=1){return 0===e?this:new Ce(new re("invalid step"),this.settings)}bind(){throw new re}withSettings(e){return e=X.fromAny(e),new Oe(e)}clone(){return this}}class Ee extends xe{constructor(e){super(),Object.defineProperty(this,"settings",{value:e,enumerable:!0})}isCont(){return!1}isFull(){return!1}isDone(){return!0}isError(){return!1}isPart(){return!1}asPart(e){return e?new Oe(this.settings):this}get index(){return 0}withIndex(e){return 0===e?this:new Ce(new re("invalid index"),this.settings)}get limit(){return 0}withLimit(e){return 0===e?this:new Ce(new re("invalid limit"),this.settings)}get capacity(){return 0}get remaining(){return 0}has(e){return!1}get(e){throw new re}set(e,t){throw new re}write(e){return new Ce(new re("done"),this.settings)}writeln(e){return new Ce(new re("done"),this.settings)}step(e=1){return 0===e?this:new Ce(new re("invalid step"),this.settings)}bind(){throw new re}withSettings(e){return e=X.fromAny(e),new Ee(e)}clone(){return this}}class Ce extends xe{constructor(e,t){super(),Object.defineProperty(this,"error",{value:e,enumerable:!0}),Object.defineProperty(this,"settings",{value:t,enumerable:!0})}isCont(){return!1}isFull(){return!1}isDone(){return!1}isError(){return!0}isPart(){return!1}asPart(e){return this}get index(){return 0}withIndex(e){return 0===e?this:new Ce(new re("invalid index"),this.settings)}get limit(){return 0}withLimit(e){return 0===e?this:new Ce(new re("invalid limit"),this.settings)}get capacity(){return 0}get remaining(){return 0}has(e){return!1}get(e){throw new re}set(e,t){throw new re}write(e){return this}writeln(e){return this}step(e=1){return 0===e?this:new Ce(new re("invalid step"),this.settings)}bind(){throw new re}trap(){return this.error}withSettings(e){return e=X.fromAny(e),new Ce(this.error,e)}clone(){return this}}class Ae extends Error{constructor(e){super(e instanceof ce?e.message:e),Object.setPrototypeOf(this,Ae.prototype),this.diagnostic=e instanceof ce?e:null}toString(){return null!==this.diagnostic?this.diagnostic.toString():super.toString()}}class Se{isCont(){return!0}isDone(){return!1}isError(){return!1}fork(e){return this}bind(){throw new Ae}trap(){throw new Ae}asError(){throw new Ae}static done(e){return new ke(e)}static error(e){return e instanceof Error?new Te(e):new Te(new Ae(e))}}class ke extends Se{constructor(e){super(),Object.defineProperty(this,"value",{value:e,enumerable:!0})}isCont(){return!1}isDone(){return!0}feed(e){return this}bind(){return this.value}}class Te extends Se{constructor(e){super(),Object.defineProperty(this,"error",{value:e,enumerable:!0})}isCont(){return!1}isError(){return!0}feed(e){return this}bind(){throw this.error}trap(){return this.error}asError(){return this}}class Pe extends oe{constructor(){super()}isCont(){return!1}isDone(){return!0}pull(e){return this}bind(){throw new se}asDone(){return this}andThen(e){return e}}class De extends oe{constructor(e){super(),Object.defineProperty(this,"value",{value:e,enumerable:!0})}isCont(){return!1}isDone(){return!0}pull(e){return this}bind(){return this.value}asDone(){return this}andThen(e){return e}}class qe extends oe{constructor(e){super(),Object.defineProperty(this,"error",{value:e,enumerable:!0})}isCont(){return!1}isError(){return!0}pull(e){return this}bind(){throw this.error}trap(){return this.error}asError(){return this}andThen(e){return this}}class Ie extends oe{constructor(e,t){super(),this.head=e,this.tail=t}pull(e){let t=this.head;return t.isCont()&&(t=t.pull(e)),t.isError()?t.asError():t.isDone()?this.tail.pull(e):new Ie(t,this.tail)}}class Ve extends ie{constructor(e,t,r){super(),this.array=e,this.size=t,this.settings=r}isCont(){return!0}isFull(){return!1}isDone(){return!1}isError(){return!1}isPart(){return!1}asPart(e){return this}write(e){if("number"==typeof e){const t=this.size,r=this.array;let i;return null===r||t+1>r.length?(i=new Uint8Array(Ve.expand(t+1)),null!==r&&i.set(r,0),this.array=i):i=r,i[t]=e,this.size=t+1,this}throw new TypeError(""+e)}writeln(e){throw new TypeError(""+e)}toUint8Array(){const e=this.size,t=this.array;if(null!==t&&e===t.length)return t;{const r=new Uint8Array(e);return null!==t&&r.set(t.slice(0,e),0),this.array=r,r}}cloneArray(){const e=this.array;return null!==e?e.slice(0,this.size):null}withSettings(e){return e=X.fromAny(e),this.settings=e,this}static expand(e){return e=Math.max(32,e)-1,e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,(e|=e>>16)+1}}class Ne extends Ve{constructor(e,t,r){super(e,t,r)}bind(){return this.toUint8Array()}clone(){return new Ne(this.cloneArray(),this.size,this.settings)}}class ze extends xe{constructor(e,t,r,i,n){super(),this.array=e,this.index=t,this.limit=r,this.part=i,this.settings=n}isCont(){return this.index<this.limit}isFull(){return this.part&&this.index>=this.limit}isDone(){return!this.part&&this.index>=this.limit}isError(){return!1}isPart(){return this.part}asPart(e){return this.part=e,this}withIndex(e){return 0<=e&&e<=this.limit?(this.index=e,this):new Ce(new re("invalid index"),this.settings)}withLimit(e){return 0<=e&&e<=this.array.length?(this.limit=e,this):new Ce(new re("invalid limit"),this.settings)}get capacity(){return this.array.length}get remaining(){return this.limit-this.index}has(e){return 0<=e&&e<this.limit}get(e){if(0<=e&&e<this.limit)return this.array[e];throw new re}set(e,t){if(!(0<=e&&e<this.limit))throw new re;this.array[e]=t}write(e){if("number"==typeof e){const t=this.index;return t<this.limit?(this.array[t]=e,this.index+=1,this):new Ce(new re("full"),this.settings)}return new Ce(new re("binary output"),this.settings)}writeln(e){return new Ce(new re("binary output"),this.settings)}step(e){const t=this.index+e;return 0<=t&&t<=this.limit?(this.index=t,this):new Ce(new re("invalid step"),this.settings)}bind(){return new Uint8Array(this.array.buffer,0,this.index)}withSettings(e){return e=X.fromAny(e),this.settings=e,this}clone(){return new ze(this.array,this.index,this.limit,this.part,this.settings)}static create(e,t,r){return void 0===t&&(t=0),void 0===r&&(r=e.length),new ze(e,t,t+r,!1,X.standard())}}const Me=function(){const e={output:function(e,t){let r;return void 0===t&&"number"!=typeof e?(t=e,e=void 0):"number"!=typeof e&&(e=void 0),r="number"==typeof e?new Uint8Array(e):null,t=X.fromAny(t),new Ne(r,0,t)},outputBuffer:function(e,t,r){return ze.create(e,t,r)}};return e}();class je{isFatal(){return!1}isReplacement(){return!1}toString(){return he.debug(this)}static fatal(){return new Le(!1)}static fatalNonZero(){return new Le(!0)}static replacement(){return new Fe(65533,!1)}static replacementNonZero(){return new Fe(65533,!0)}}e([n],je,"fatal",null),e([n],je,"fatalNonZero",null),e([n],je,"replacement",null),e([n],je,"replacementNonZero",null);class Le extends je{constructor(e){super(),Object.defineProperty(this,"nonZero",{value:e,enumerable:!0})}isFatal(){return!0}get replacementChar(){return 65533}isNonZero(){return this.nonZero}asNonZero(e){return e?je.fatalNonZero():je.fatal()}equals(e){return this===e||e instanceof Le&&this.nonZero===e.nonZero}hashCode(){return i.mash(i.mix(l.hash(Le),s.hash(this.nonZero)))}debug(e){return e=e.write("UtfErrorMode").write(46).write(this.nonZero?"fatalNonZero":"fatal").write(40).write(41)}}class Fe extends je{constructor(e,t){super(),Object.defineProperty(this,"replacementChar",{value:e,enumerable:!0}),Object.defineProperty(this,"nonZero",{value:t,enumerable:!0})}isReplacement(){return!0}isNonZero(){return this.nonZero}asNonZero(e){return 65533===this.replacementChar?e?je.replacementNonZero():je.replacement():new Fe(this.replacementChar,e)}equals(e){return this===e||e instanceof Fe&&(this.replacementChar===e.replacementChar&&this.nonZero===e.nonZero)}hashCode(){return i.mash(i.mix(i.mix(l.hash(Fe),a.hash(this.replacementChar)),s.hash(this.nonZero)))}debug(e){return e=e.write("UtfErrorMode").write(46).write(this.nonZero?"replacementNonZero":"replacement").write(40).write(41)}}class Be{constructor(e){Object.defineProperty(this,"alphabet",{value:e,enumerable:!0})}encodeDigit(e){return this.alphabet.charCodeAt(e)}uint8ArrayWriter(e){return void 0===e?new Qe(this,void 0,null):new Qe(this,e,e)}writeUint8Array(e,t){return Qe.write(e,this,void 0,t)}writeInteger(e,t,r=0){return Ze.write(e,this,void 0,t,r)}writeIntegerLiteral(e,t,r=0){return Ze.writeLiteral(e,this,void 0,t,r)}static get lowercase(){return new Be("0123456789abcdef")}static get uppercase(){return new Be("0123456789ABCDEF")}static isDigit(e){return e>=48&&e<=57||e>=65&&e<=70||e>=97&&e<=102}static decodeDigit(e){if(e>=48&&e<=57)return e-48;if(e>=65&&e<=70)return e-65+10;if(e>=97&&e<=102)return e-97+10;{let t=ue.stringOutput();throw t=t.write("Invalid base-16 digit: "),t=he.debugChar(t,e),new Error(t.bind())}}static writeQuantum(e,t,r){const i=Be.decodeDigit(t),n=Be.decodeDigit(r);return e=e.write(i<<4|n)}static parser(e){return new Ge(e)}static parse(e,t){return Ge.parse(e,t)}static parseUint8Array(e){return Ge.parse(e,Me.output())}}e([n],Be,"lowercase",null),e([n],Be,"uppercase",null);class Ue extends ie{constructor(e,t,r,i,n,s){super(),this.output=e,this.errorMode=t,this.c1=r,this.c2=i,this.c3=n,this.have=s}isCont(){return this.output.isCont()}isFull(){return this.output.isFull()}isDone(){return this.output.isDone()}isError(){return this.output.isError()}isPart(){return this.output.isPart()}asPart(e){return this.output=this.output.asPart(e),this}write(e){if("number"==typeof e){let t=this.c1,r=this.c2,i=this.c3,n=-1,s=this.have;if(e>=0)switch(s){case 0:t=255&e,s=1;break;case 1:r=255&e,s=2;break;case 2:i=255&e,s=3;break;case 3:n=255&e,s=4;break;default:throw new Error("unreachable")}if(0===t&&this.errorMode.isNonZero())return ie.error(new re("unexpected NUL byte"));if(t>=0&&t<=127)this.output=this.output.write(t),this.have=0;else if(t>=194&&t<=244)if(t>=194&&t<=223&&r>=128&&r<=191)this.output=this.output.write((31&t)<<6|63&r),this.c1=-1,this.have=0;else if(224===t&&r>=160&&r<=191||t>=225&&t<=236&&r>=128&&r<=191||237===t&&r>=128&&r<=159||t>=238&&t<=239&&r>=128&&r<=191)if(i>=128&&i<=191)this.output=this.output.write((15&t)<<12|(63&r)<<6|63&i),this.c1=-1,this.c2=-1,this.have=0;else if(i>=0){if(this.errorMode.isFatal())return ie.error(new re(Ue.invalid(t,r,i)));this.output=this.output.write(this.errorMode.replacementChar),this.c1=i,this.c2=-1,this.have=1}else{if(e<0||this.output.isDone())return ie.error(new re(Ue.invalid(t,r)));this.c2=r,this.have=2}else if(240===t&&r>=144&&r<=191||t>=241&&t<=243&&r>=128&&r<=191||244===t&&r>=128&&r<=143)if(i>=128&&i<=191)if(n>=128&&n<=191)this.have=4,this.output=this.output.write((7&t)<<18|(63&r)<<12|(63&i)<<6|63&n),this.c1=-1,this.c2=-1,this.c3=-1,this.have=0;else if(n>=0){if(this.errorMode.isFatal())return ie.error(new re(Ue.invalid(t,r,i,n)));this.output=this.output.write(this.errorMode.replacementChar),this.c1=n,this.c2=-1,this.c3=-1,this.have=1}else{if(e<0||this.output.isDone())return ie.error(new re(Ue.invalid(t,r,i)));this.c3=i,this.have=3}else if(i>=0){if(this.errorMode.isFatal())return ie.error(new re(Ue.invalid(t,r,i)));this.output=this.output.write(this.errorMode.replacementChar),this.c1=i,this.c2=-1,this.have=1}else{if(e<0||this.output.isDone())return ie.error(new re(Ue.invalid(t,r)));this.c2=r,this.have=2}else if(r>=0){if(this.errorMode.isFatal())return ie.error(new re(Ue.invalid(t,r)));this.output=this.output.write(this.errorMode.replacementChar),this.c1=r,this.have=1}else{if(e<0||this.output.isDone())return ie.error(new re(Ue.invalid(t)));this.c1=t,this.have=1}else if(t>=0){if(this.errorMode.isFatal())return ie.error(new re(Ue.invalid(t)));this.output=this.output.write(this.errorMode.replacementChar),this.have=0}return this.output.isError()?this.output:this}if("string"==typeof e)return this.output=this.output.write(e),this;throw new TypeError(""+e)}static invalid(e,t,r,i){let n=ue.stringOutput();n=n.write("invalid UTF-8 code unit sequence: ");const s=Be.uppercase;return s.writeIntegerLiteral(n,e,2),void 0!==t&&(n=n.write(" "),s.writeIntegerLiteral(n,t,2),void 0!==r&&(n=n.write(" "),s.writeIntegerLiteral(n,r,2),void 0!==i&&(n=n.write(" "),s.writeIntegerLiteral(n,i,2)))),n.bind()}get settings(){return this.output.settings}withSettings(e){return this.output=this.output.withSettings(e),this}bind(){return 0===this.have?this.output.bind():this.write(-1).bind()}trap(){return this.output.trap()}clone(){return new Ue(this.output.clone(),this.errorMode,this.c1,this.c2,this.c3,this.have)}static create(e,t){return void 0===t&&(t=je.fatal()),new Ue(e,t,-1,-1,-1,0)}}class We extends ie{constructor(e,t,r,i,n,s){super(),this.output=e,this.errorMode=t,this.c2=r,this.c3=i,this.c4=n,this.index=s}isCont(){return this.output.isCont()}isFull(){return this.output.isFull()}isDone(){return this.output.isDone()}isError(){return!1}isPart(){return this.output.isPart()}asPart(e){return this.output=this.output.asPart(e),this}write(e){if("number"==typeof e){let t=0,r=this.c2,i=this.c3,n=this.c4,s=this.output,o=this.index;for(;o<4;){if(!s.isCont())return ie.error(new re("unable to flush buffered code units"));switch(o){case 1:s=s.write(r),this.c2=0;break;case 2:s=s.write(i),this.c3=0;break;case 3:s=s.write(n),this.c4=0;break;default:throw new Error("unreachable")}o+=1}if(e>=0&&e<=127)n=e,o=3;else if(e>=128&&e<=2047)i=192|e>>>6,n=128|63&e,o=2;else if(e>=2048&&e<=65535||e>=57344&&e<=65535)r=224|e>>>12,i=128|e>>>6&63,n=128|63&e,o=1;else{if(!(e>=65536&&e<=1114111))return this.errorMode.isFatal()?ie.error(new re("invalid code point: "+e)):this.write(this.errorMode.replacementChar);t=240|e>>>18,r=128|e>>>12&63,i=128|e>>>6&63,n=128|63&e,o=0}do{switch(o){case 0:s=s.write(t);break;case 1:s=s.write(r),this.c2=0;break;case 2:s=s.write(i),this.c3=0;break;case 3:s=s.write(n),this.c4=0;break;default:throw new Error("unreachable")}this.output=s,o+=1}while(o<4&&s.isCont());return o<4&&(o<3&&(o<2&&(this.c2=r),this.c3=i),this.c4=n),this.output=s,this.index=o,this}if("string"==typeof e)return this.output=this.output.write(e),this;throw new TypeError(""+e)}flush(){let e=this.output,t=this.index;for(;t<4;){if(!e.isCont())return ie.error(new re("unable to flush buffered code units"));switch(t){case 1:e=e.write(this.c2),this.c2=0;break;case 2:e=e.write(this.c3),this.c3=0;break;case 3:e=e.write(this.c4),this.c4=0;break;default:throw new Error("unreachable")}t+=1}return this.output=e,this.index=t,this}get settings(){return this.output.settings}withSettings(e){return this.output=this.output.withSettings(e),this}bind(){return this.output.bind()}clone(){return new We(this.output.clone(),this.errorMode,this.c2,this.c3,this.c4,this.index)}static create(e,t){return void 0===t&&(t=je.fatal()),new We(e,t,0,0,0,4)}}const Re=function(){const e={sizeOf:function(t,r){if("number"==typeof t||void 0===t){if("number"==typeof t){if(0===t&&void 0!==r&&r.isNonZero())return 2;if(t>=0&&t<=127)return 1;if(t>=128&&t<=2047)return 2;if(t>=2048&&t<=65535||t>=57344&&t<=65535)return 3;if(t>=65536&&t<=1114111)return 4}return void 0===r?3:r.isReplacement()?e.sizeOf(r.replacementChar):0}if("string"==typeof t){let i=0;for(let n=0,s=t.length;n<s;n=u.offsetByCodePoints(t,n,1))i+=e.sizeOf(t.charCodeAt(n),r);return i}throw new TypeError(""+t)},decodedOutput:function(e,t){return Ue.create(e,t)},encodedOutput:function(e,t){return We.create(e,t)},decodedString:function(){return e.decodedOutput(ue.stringOutput())}};return e}();class He extends Se{constructor(e=1,t=0,r=2,i=1){super(),this.sign=e,this.value=t,this.mode=r,this.step=i}feed(e){return He.parse(e,this.sign,this.value,this.mode,this.step)}static parse(e,t=1,r=0,i=2,n=1){let s=0;if(1===n)if(e.isCont())s=e.head(),45===s?(e=e.step(),t=-1):43===s&&(e=e.step(),t=1),n=2;else if(e.isDone())return Se.error(ce.expected("number",e));if(2===n)if(e.isCont())if(s=e.head(),48===s)e=e.step(),n=4;else{if(!(s>=49&&s<=57)){if(i>0&&46===s){let r=ue.stringOutput();return t<0&&(r=r.write(45)),Ke.parse(e,r,i)}return Se.error(ce.expected("number",e))}e=e.step(),r=t*(s-48),n=3}else if(e.isDone())return Se.error(ce.expected("number",e));if(3===n){for(;e.isCont()&&(s=e.head(),s>=48&&s<=57);){const i=10*r+t*(s-48);if(!(-9007199254740991<=i&&i<=9007199254740992))return Se.error(ce.message("integer overflow",e));r=i,e=e.step()}if(e.isCont())n=4;else if(e.isDone())return Se.done(r)}if(4===n){if(e.isCont()){if(s=e.head(),i>0&&46===s||i>1&&(69===s||101===s)){let n=ue.stringOutput();return n=t<0&&0===r?n.write(45).write(48):n.write(""+r),Ke.parse(e,n,i)}return Se.done(r)}if(e.isDone())return Se.done(r)}return new He(t,r,i,n)}}class Ke extends Se{constructor(e,t=2,r=1){super(),this.output=e,this.mode=t,this.step=r}feed(e){return Ke.parse(e,this.output,this.mode,this.step)}static parse(e,t,r=2,i=1){let n=0;if(1===i)if(e.isCont())if(n=e.head(),46===n)e=e.step(),t=t.write(n),i=2;else{if(!(r>1)||69!==n&&101!==n)return Se.error(ce.expected("decimal or exponent",e));e=e.step(),t=t.write(n),i=5}else if(e.isDone())return Se.error(ce.expected("decimal or exponent",e));if(2===i)if(e.isCont()){if(n=e.head(),!(n>=48&&n<=57))return Se.error(ce.expected("digit",e));e=e.step(),t=t.write(n),i=3}else if(e.isDone())return Se.error(ce.expected("digit",e));if(3===i){for(;e.isCont()&&(n=e.head(),n>=48&&n<=57);)e=e.step(),t=t.write(n);if(e.isCont()){if(!(r>1))return Se.done(+t.bind());i=4}else if(e.isDone())return Se.done(+t.bind())}if(4===i){if(n=e.head(),69!==n&&101!==n)return Se.done(+t.bind());e=e.step(),t=t.write(n),i=5}if(5===i)if(e.isCont())n=e.head(),43!==n&&45!==n||(e=e.step(),t=t.write(n)),i=6;else if(e.isDone())return Se.error(ce.unexpected(e));if(6===i)if(e.isCont()){if(n=e.head(),!(n>=48&&n<=57))return Se.error(ce.expected("digit",e));e=e.step(),t=t.write(n),i=7}else if(e.isDone())return Se.error(ce.expected("digit",e));if(7===i){for(;e.isCont()&&(n=e.head(),n>=48&&n<=57);)e=e.step(),t=t.write(n);if(!e.isEmpty())return Se.done(+t.bind())}return new Ke(t,r,i)}}class _e extends oe{constructor(e,t,r=0,i=1){super(),this.value=e,this.input=t,this.index=r,this.step=i}pull(e){return _e.write(e,this.value,this.input,this.index,this.step)}static write(e,t,r,i=0,n=1){if(0===n)return oe.end();if(1===n&&(r<0?e.isCont()&&(e=e.write(45),n=2):n=2),2===n)if(r>-10&&r<10){if(e.isCont())return e=e.write(le.encodeDigit(Math.abs(0|r))),oe.done(t)}else{const n=new Array(19);let s=r,o=18;for(;0!==s;)n[o]=Math.abs(s%10|0),s=s/10|0,o-=1;for(o+=1+i;o<19&&e.isCont();)e=e.write(le.encodeDigit(n[o])),i+=1,o+=1;if(19===o)return oe.done(t)}return e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new _e(t,r,i,n)}}class Ge extends Se{constructor(e,t=0,r=1){super(),this.output=e,this.p=t,this.step=r}feed(e){return Ge.parse(e,this.output.clone(),this.p,this.step)}static parse(e,t,r=0,i=1){let n=0;for(;!e.isEmpty();){if(1===i)if(e.isCont()&&(n=e.head(),Be.isDigit(n)))e=e.step(),r=n,i=2;else if(!e.isEmpty())return Se.done(t.bind());if(2===i)if(e.isCont()&&(n=e.head(),Be.isDigit(n)))e=e.step(),t=Be.writeQuantum(t,r,n),r=0,i=1;else if(!e.isEmpty())return Se.error(ce.expected("base16 digit",e))}return new Ge(t,r,i)}}class Qe extends oe{constructor(e,t,r,i=0,n=1){super(),this.base16=e,this.value=t,this.input=r,this.index=i,this.step=n}feed(e){if(e instanceof Uint8Array)return new Qe(this.base16,void 0,e);throw new TypeError(""+e)}pull(e){if(null===this.input)throw new se;return Qe.write(e,this.base16,this.value,this.input,this.index,this.step)}static write(e,t,r,i,n=0,s=1){for(;n<i.length;){const r=i[n];1===s&&e.isCont()&&(e=e.write(t.encodeDigit(r>>>4)),s=2),2===s&&e.isCont()&&(e=e.write(t.encodeDigit(15&r)),n+=1,s=1)}return n===i.length?oe.done(r):e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new Qe(t,r,i,n,s)}}class Ze extends oe{constructor(e,t,r,i,n=0,s=3){super(),this.base16=e,this.value=t,this.input=r,this.width=i,this.index=n,this.step=s}pull(e){return Ze.write(e,this.base16,this.value,this.input,this.width,this.index,this.step)}static write(e,t,r,i,n,s=0,o=3){if(o<=0)return oe.end();if(1===o&&e.isCont()&&(e=e.write(48),o=2),2===o&&e.isCont()&&(e=e.write(120),o=3),3===o)if(i>=0&&i<16&&n<=1){if(e.isCont())return e=e.write(t.encodeDigit(i)),oe.done(r)}else{let o=15;const a=new Array(16);let u=i;for(;0!==u||o>=16-n;)a[o]=15&u,u>>>=4,o-=1;for(o+=1+s;o<16&&e.isCont();)e=e.write(t.encodeDigit(a[o])),s+=1,o+=1;if(16===o)return oe.done(r)}return e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new Ze(t,r,i,n,s,o)}static writeLiteral(e,t,r,i,n){return Ze.write(e,t,r,i,n,0,1)}}class Xe{decodeDigit(e){if(e>=65&&e<=90)return e-65;if(e>=97&&e<=122)return e+-71;if(e>=48&&e<=57)return e+4;if(43===e||45===e)return 62;if(47===e||95===e)return 63;{let t=ue.stringOutput();throw t=t.write("Invalid base-64 digit: "),t=he.debugChar(t,e),new Error(t.bind())}}encodeDigit(e){return this.alphabet.charCodeAt(e)}writeQuantum(e,t,r,i,n){const s=this.decodeDigit(t),o=this.decodeDigit(r);if(61!==i){const t=this.decodeDigit(i);if(61!==n){const r=this.decodeDigit(n);e=(e=(e=e.write(s<<2|o>>>4)).write(o<<4|t>>>2)).write(t<<6|r)}else e=(e=e.write(s<<2|o>>>4)).write(o<<4|t>>>2)}else{if(61!==n)return ie.error(new Error("Improperly padded base-64"));e=e.write(s<<2|o>>>4)}return e}parser(e){return new Je(this,e)}parse(e,t){return Je.parse(e,this,t)}parseUint8Array(e){return Je.parse(e,this,Me.output())}uint8ArrayWriter(e){return void 0===e?new et(this,void 0,null):new et(this,e,e)}writeUint8Array(e,t){return et.write(e,this,void 0,t)}static get standardPadded(){return new $e(!0)}static get standardUnpadded(){return new $e(!1)}static standard(e=!0){return e?Xe.standardPadded:Xe.standardUnpadded}static get urlPadded(){return new Ye(!0)}static get urlUnpadded(){return new Ye(!1)}static url(e=!0){return e?Xe.urlPadded:Xe.urlUnpadded}}e([n],Xe,"standardPadded",null),e([n],Xe,"standardUnpadded",null),e([n],Xe,"urlPadded",null),e([n],Xe,"urlUnpadded",null);class $e extends Xe{constructor(e){super(),Object.defineProperty(this,"padded",{value:e,enumerable:!0})}get alphabet(){return"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"}isPadded(){return this.padded}asPadded(e){return e===this.padded?this:Xe.standard(e)}isDigit(e){return e>=48&&e<=57||e>=65&&e<=90||e>=97&&e<=122||43===e||47===e}}class Ye extends Xe{constructor(e){super(),Object.defineProperty(this,"padded",{value:e,enumerable:!0})}get alphabet(){return"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"}isPadded(){return this.padded}asPadded(e){return e===this.padded?this:Xe.url(e)}isDigit(e){return e>=48&&e<=57||e>=65&&e<=90||e>=97&&e<=122||45===e||95===e}}class Je extends Se{constructor(e,t,r=0,i=0,n=0,s=1){super(),this.base64=e,this.output=t,this.p=r,this.q=i,this.r=n,this.step=s}feed(e){return Je.parse(e,this.base64,this.output.clone(),this.p,this.q,this.r,this.step)}static parse(e,t,r,i=0,n=0,s=0,o=1){let a=0;for(;!e.isEmpty();){if(1===o)if(e.isCont()&&(a=e.head(),t.isDigit(a)))e=e.step(),i=a,o=2;else if(!e.isEmpty())return Se.done(r.bind());if(2===o)if(e.isCont()&&(a=e.head(),t.isDigit(a)))e=e.step(),n=a,o=3;else if(!e.isEmpty())return Se.error(ce.expected("base64 digit",e));if(3===o)if(e.isCont()&&(a=e.head(),t.isDigit(a)||61===a))e=e.step(),s=a,o=61!==a?4:5;else if(!e.isEmpty())return t.isPadded()?Se.error(ce.unexpected(e)):(r=t.writeQuantum(r,i,n,61,61),Se.done(r.bind()));if(4===o){if(e.isCont()&&(a=e.head(),t.isDigit(a)||61===a)){if(e=e.step(),r=t.writeQuantum(r,i,n,s,a),s=0,n=0,i=0,61===a)return Se.done(r.bind());o=1}else if(!e.isEmpty())return t.isPadded()?Se.error(ce.unexpected(e)):(r=t.writeQuantum(r,i,n,s,61),Se.done(r.bind()))}else if(5===o){if(e.isCont()&&(a=e.head(),61===a))return e=e.step(),r=t.writeQuantum(r,i,n,s,a),s=0,n=0,i=0,Se.done(r.bind());if(!e.isEmpty())return Se.error(ce.expected(61,e))}}return new Je(t,r,i,n,s,o)}}class et extends oe{constructor(e,t,r,i=0,n=1){super(),this.base64=e,this.value=t,this.input=r,this.index=i,this.step=n}feed(e){if(e instanceof Uint8Array)return new et(this.base64,null,e);throw new TypeError(""+e)}pull(e){if(null===this.input)throw new se;return et.write(e,this.base64,this.value,this.input,this.index,this.step)}static write(e,t,r,i,n=0,s=1){for(;n+2<i.length&&e.isCont();){const r=i[n],o=i[n+1],a=i[n+2];1===s&&e.isCont()&&(e=e.write(t.encodeDigit(r>>>2)),s=2),2===s&&e.isCont()&&(e=e.write(t.encodeDigit(63&(r<<4|o>>>4))),s=3),3===s&&e.isCont()&&(e=e.write(t.encodeDigit(63&(o<<2|a>>>6))),s=4),4===s&&e.isCont()&&(e=e.write(t.encodeDigit(63&a)),n+=3,s=1)}if(n+1<i.length&&e.isCont()){const r=i[n],o=i[n+1];1===s&&e.isCont()&&(e=e.write(t.encodeDigit(r>>>2)),s=2),2===s&&e.isCont()&&(e=e.write(t.encodeDigit(63&(r<<4|o>>>4))),s=3),3===s&&e.isCont()&&(e=e.write(t.encodeDigit(o<<2&63)),s=4),4===s&&(t.isPadded()?e.isCont()&&(e=e.write(61),n+=2):n+=2)}else if(n<i.length&&e.isCont()){const r=i[n];1===s&&e.isCont()&&(e=e.write(t.encodeDigit(r>>>2)),s=2),2===s&&e.isCont()&&(e=e.write(t.encodeDigit(r<<4&63)),s=3),3===s&&(t.isPadded()?e.isCont()&&(e=e.write(61),s=4):n+=1),4===s&&e.isCont()&&(e=e.write(61),n+=1)}return n===i.length?oe.done(r):e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new et(t,r,i,n,s)}}class tt{constructor(){}updated(e,t){const r=lt.create(2);return r.push(this),r.set(e,t),r}updatedAttr(e,t){const r=lt.create(2);return r.push(this),r.setAttr(e,t),r}updatedSlot(e,t){const r=lt.create(2);return r.push(this),r.setSlot(e,t),r}appended(...e){const t=lt.create(1+arguments.length);return t.push(this),t.push(...e),t}prepended(...e){const t=lt.create(arguments.length+1);return t.push(...e),t.push(this),t}concat(...e){const t=lt.create();t.push(this);for(let r=0,i=e.length;r<i;r+=1)tt.fromAny(e[r]).forEach((function(e){t.push(e)}));return t}lt(e){return e=tt.fromAny(e),this.compareTo(e)<0?Ot.from(!0):tt.absent()}le(e){return e=tt.fromAny(e),this.compareTo(e)<=0?Ot.from(!0):tt.absent()}eq(e){return e=tt.fromAny(e),this.equals(e)?Ot.from(!0):tt.absent()}ne(e){return e=tt.fromAny(e),this.equals(e)?tt.absent():Ot.from(!0)}ge(e){return e=tt.fromAny(e),this.compareTo(e)>=0?Ot.from(!0):tt.absent()}gt(e){return e=tt.fromAny(e),this.compareTo(e)>0?Ot.from(!0):tt.absent()}invoke(e){return tt.absent()}filter(e){const t=nr.literal(this);return 0===arguments.length?t.filter():t.filter(e)}max(e){return this.compareTo(e)>=0?this:e}min(e){return this.compareTo(e)<=0?this:e}evaluate(e){return this}substitute(e){return this}cast(e,t){let r=e.cast(this);return void 0===r&&(r=t),r}coerce(e,t){let r=e.cast(this);return void 0===r&&(r=e.unit),void 0===r&&(r=t),r}get precedence(){return 11}forEach(e,t){return e.call(t,this,0)}iterator(){return j.unary(this)}interpolateTo(e){return e instanceof tt?rt(this,e):null}display(e){return this.debug(e)}toString(){return he.debug(this)}static empty(){return lt.empty()}static extant(){return Et.extant()}static absent(){return Ct.absent()}static fromAny(e){return e instanceof tt?e:ht.fromAny(e)}static globalScope(){return lt.create(1).slot("math",yr.scope).commit()}}e([n],tt,"globalScope",null);const rt=function(e){const t=function(e,r){const i=function(e){return e<1?i[0]:i[1]};return Object.setPrototypeOf(i,t.prototype),i[0]=e.commit(),i[1]=r.commit(),i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t}(x);class it extends tt{constructor(){super()}isDefined(){return!0}isDistinct(){return!0}isDefinite(){return!0}toValue(){return this.value}get tag(){}get target(){return this.value}flattened(){return ht.absent()}unflattened(){return lt.of(this)}header(e){return ht.absent()}headers(e){}head(){return tt.absent()}tail(){return lt.empty()}body(){return ht.absent()}get length(){return 0}has(e){return!1}get(e){return ht.absent()}getAttr(e){return ht.absent()}getSlot(e){return ht.absent()}getField(e){}getItem(e){return tt.absent()}deleted(e){return this}conditional(e,t){return e=tt.fromAny(e)}or(e){return this}and(e){return e=tt.fromAny(e)}lambda(e){return ht.absent()}stringValue(e){return this.value.stringValue(e)}numberValue(e){return this.value.numberValue(e)}booleanValue(e){return this.value.booleanValue(e)}interpolateTo(e){return e instanceof it?st(this,e):super.interpolateTo(e)}static of(e,t){let r;return"string"==typeof e?r=e:e instanceof yt&&(r=e.value),void 0!==r&&64===r.charCodeAt(0)?(r=r.slice(1),1===arguments.length?ot.of(r):ot.of(r,t)):1===arguments.length?nt.of(e):nt.of(e,t)}static fromAny(e){if(e instanceof it)return e;if("object"==typeof e&&null!==e){if(void 0!==e.$key)return it.of(e.$key,e.$value);for(const t in e)return it.of(t,e[t])}throw new TypeError(""+e)}}it.ImmutableFlag=1;class nt extends it{constructor(e,t,r){super(),this.key=e.commit(),this.value=t,this.flags=void 0!==r?r:0}isConstant(){return this.key.isConstant()&&this.value.isConstant()}setValue(e){if(0!=(this.flags&it.ImmutableFlag))throw new Error("immutable");const t=this.value;return this.value=e,t}updatedValue(e){return new nt(this.key,e)}bitwiseOr(e){if((e=tt.fromAny(e))instanceof At)return new Lt(this,e);let t;return t=e instanceof nt&&this.key.equals(e.key)?this.value.bitwiseOr(e.value):e instanceof ht?this.value.bitwiseOr(e):ht.absent(),t.isDefined()?new nt(this.key,t):tt.absent()}bitwiseXor(e){if((e=tt.fromAny(e))instanceof At)return new Ft(this,e);let t;return t=e instanceof nt&&this.key.equals(e.key)?this.value.bitwiseXor(e.value):e instanceof ht?this.value.bitwiseXor(e):ht.absent(),t.isDefined()?new nt(this.key,t):tt.absent()}bitwiseAnd(e){if((e=tt.fromAny(e))instanceof At)return new Bt(this,e);let t;return t=e instanceof nt&&this.key.equals(e.key)?this.value.bitwiseAnd(e.value):e instanceof ht?this.value.bitwiseAnd(e):ht.absent(),t.isDefined()?new nt(this.key,t):tt.absent()}plus(e){if((e=tt.fromAny(e))instanceof At)return new Gt(this,e);let t;return t=e instanceof nt&&this.key.equals(e.key)?this.value.plus(e.value):e instanceof ht?this.value.plus(e):ht.absent(),t.isDefined()?new nt(this.key,t):tt.absent()}minus(e){if((e=tt.fromAny(e))instanceof At)return new Qt(this,e);let t;return t=e instanceof nt&&this.key.equals(e.key)?this.value.minus(e.value):e instanceof ht?this.value.minus(e):ht.absent(),t.isDefined()?new nt(this.key,t):tt.absent()}times(e){if((e=tt.fromAny(e))instanceof At)return new Zt(this,e);let t;return t=e instanceof nt&&this.key.equals(e.key)?this.value.times(e.value):e instanceof ht?this.value.times(e):ht.absent(),t.isDefined()?new nt(this.key,t):tt.absent()}divide(e){if((e=tt.fromAny(e))instanceof At)return new Xt(this,e);let t;return t=e instanceof nt&&this.key.equals(e.key)?this.value.divide(e.value):e instanceof ht?this.value.divide(e):ht.absent(),t.isDefined()?new nt(this.key,t):tt.absent()}modulo(e){if((e=tt.fromAny(e))instanceof At)return new $t(this,e);let t;return t=e instanceof nt&&this.key.equals(e.key)?this.value.modulo(e.value):e instanceof ht?this.value.modulo(e):ht.absent(),t.isDefined()?new nt(this.key,t):tt.absent()}not(){const e=this.value.not();return e.isDefined()?new nt(this.key,e):tt.absent()}bitwiseNot(){const e=this.value.bitwiseNot();return e.isDefined()?new nt(this.key,e):tt.absent()}negative(){const e=this.value.negative();return e.isDefined()?new nt(this.key,e):tt.absent()}positive(){const e=this.value.positive();return e.isDefined()?new nt(this.key,e):tt.absent()}inverse(){const e=this.value.inverse();return e.isDefined()?new nt(this.key,e):tt.absent()}evaluate(e){e=zt.fromAny(e);const t=this.key.evaluate(e).toValue(),r=this.value.evaluate(e).toValue();return t===this.key&&r===this.value?this:t.isDefined()&&r.isDefined()?new nt(t,r):tt.absent()}substitute(e){e=zt.fromAny(e);const t=this.key.substitute(e).toValue(),r=this.value.substitute(e).toValue();return t===this.key&&r===this.value?this:t.isDefined()&&r.isDefined()?new nt(t,r):tt.absent()}toAny(){const e={};return this.key instanceof yt?e[this.key.value]=this.value.toAny():(e.$key=this.key.toAny(),e.$value=this.value.toAny()),e}isAliased(){return!1}isMutable(){return 0==(this.flags&it.ImmutableFlag)}alias(){this.flags|=it.ImmutableFlag}branch(){return 0!=(this.flags&it.ImmutableFlag)?new nt(this.key,this.value,this.flags&~it.ImmutableFlag):this}clone(){return new nt(this.key.clone(),this.value.clone())}commit(){return this.flags|=it.ImmutableFlag,this.value.commit(),this}interpolateTo(e){return e instanceof nt?ut(this,e):super.interpolateTo(e)}get typeOrder(){return 2}compareTo(e){if(e instanceof nt){let t=this.key.compareTo(e.key);return 0===t&&(t=this.value.compareTo(e.value)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof nt&&(this.key.equals(e.key)&&this.value.equivalentTo(e.value,t))}keyEquals(e){return"string"==typeof e&&this.key instanceof yt?this.key.value===e:e instanceof it?this.key.equals(e.key):this.key.equals(e)}equals(e){return this===e||e instanceof nt&&(this.key.equals(e.key)&&this.value.equals(e.value))}hashCode(){return i.mash(i.mix(i.mix(l.hash(nt),this.key.hashCode()),this.value.hashCode()))}debug(e){return e=e.write("Slot").write(46).write("of").write(40).display(this.key),this.value instanceof Et||(e=e.write(44).write(32).display(this.value)),e=e.write(41)}static of(e,t){return e=ht.fromAny(e),t=1===arguments.length?ht.extant():ht.fromAny(t),new nt(e,t)}}const st=function(e){const t=function(e,r){const i=function(e){const t=i.keyInterpolator(e),r=i.valueInterpolator(e);return nt.of(t,r)};return Object.setPrototypeOf(i,t.prototype),i.keyInterpolator=e.key.interpolateTo(r.key),i.valueInterpolator=e.value.interpolateTo(r.value),i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,Object.defineProperty(t.prototype,0,{get(){return nt.of(this.keyInterpolator[0],this.valueInterpolator[0])},configurable:!0}),Object.defineProperty(t.prototype,1,{get(){return nt.of(this.keyInterpolator[1],this.valueInterpolator[1])},configurable:!0}),t.prototype.equals=function(e){return this===e||e instanceof t&&(this.keyInterpolator.equals(e.keyInterpolator)&&this.valueInterpolator.equals(e.valueInterpolator))},t}(x);class ot extends it{constructor(e,t,r){super(),this.key=e,this.value=t,this.flags=void 0!==r?r:0}isConstant(){return this.key.isConstant()&&this.value.isConstant()}get name(){return this.key.value}setValue(e){if(0!=(this.flags&it.ImmutableFlag))throw new Error("immutable");const t=this.value;return this.value=e,t}updatedValue(e){return new ot(this.key,e)}bitwiseOr(e){if((e=tt.fromAny(e))instanceof At)return new Lt(this,e);let t;return t=e instanceof ot&&this.key.equals(e.key)?this.value.bitwiseOr(e.value):e instanceof ht?this.value.bitwiseOr(e):ht.absent(),t.isDefined()?new ot(this.key,t):tt.absent()}bitwiseXor(e){if((e=tt.fromAny(e))instanceof At)return new Ft(this,e);let t;return t=e instanceof ot&&this.key.equals(e.key)?this.value.bitwiseXor(e.value):e instanceof ht?this.value.bitwiseXor(e):ht.absent(),t.isDefined()?new ot(this.key,t):tt.absent()}bitwiseAnd(e){if((e=tt.fromAny(e))instanceof At)return new Bt(this,e);let t;return t=e instanceof ot&&this.key.equals(e.key)?this.value.bitwiseAnd(e.value):e instanceof ht?this.value.bitwiseAnd(e):ht.absent(),t.isDefined()?new ot(this.key,t):tt.absent()}plus(e){if((e=tt.fromAny(e))instanceof At)return new Gt(this,e);let t;return t=e instanceof ot&&this.key.equals(e.key)?this.value.plus(e.value):e instanceof ht?this.value.plus(e):ht.absent(),t.isDefined()?new ot(this.key,t):tt.absent()}minus(e){if((e=tt.fromAny(e))instanceof At)return new Qt(this,e);let t;return t=e instanceof ot&&this.key.equals(e.key)?this.value.minus(e.value):e instanceof ht?this.value.minus(e):ht.absent(),t.isDefined()?new ot(this.key,t):tt.absent()}times(e){if((e=tt.fromAny(e))instanceof At)return new Zt(this,e);let t;return t=e instanceof ot&&this.key.equals(e.key)?this.value.times(e.value):e instanceof ht?this.value.times(e):ht.absent(),t.isDefined()?new ot(this.key,t):tt.absent()}divide(e){if((e=tt.fromAny(e))instanceof At)return new Xt(this,e);let t;return t=e instanceof ot&&this.key.equals(e.key)?this.value.divide(e.value):e instanceof ht?this.value.divide(e):ht.absent(),t.isDefined()?new ot(this.key,t):tt.absent()}modulo(e){if((e=tt.fromAny(e))instanceof At)return new $t(this,e);let t;return t=e instanceof ot&&this.key.equals(e.key)?this.value.modulo(e.value):e instanceof ht?this.value.modulo(e):ht.absent(),t.isDefined()?new ot(this.key,t):tt.absent()}not(){const e=this.value.not();return e.isDefined()?new ot(this.key,e):tt.absent()}bitwiseNot(){const e=this.value.bitwiseNot();return e.isDefined()?new ot(this.key,e):tt.absent()}negative(){const e=this.value.negative();return e.isDefined()?new ot(this.key,e):tt.absent()}positive(){const e=this.value.positive();return e.isDefined()?new ot(this.key,e):tt.absent()}inverse(){const e=this.value.inverse();return e.isDefined()?new ot(this.key,e):tt.absent()}evaluate(e){e=zt.fromAny(e);const t=this.key.evaluate(e).toValue(),r=this.value.evaluate(e).toValue();return t===this.key&&r===this.value?this:t.isDefined()&&r.isDefined()?t instanceof yt?new ot(t,r):new nt(t,r):tt.absent()}substitute(e){e=zt.fromAny(e);const t=this.key.substitute(e).toValue(),r=this.value.substitute(e).toValue();return t===this.key&&r===this.value?this:t.isDefined()&&r.isDefined()?t instanceof yt?new ot(t,r):new nt(t,r):tt.absent()}toAny(){const e={};return e["@"+this.key.value]=this.value.toAny(),e}isAliased(){return!1}isMutable(){return 0==(this.flags&it.ImmutableFlag)}alias(){this.flags|=it.ImmutableFlag}branch(){return 0!=(this.flags&it.ImmutableFlag)?new ot(this.key,this.value,this.flags&~it.ImmutableFlag):this}clone(){return new ot(this.key.clone(),this.value.clone())}commit(){return this.flags|=it.ImmutableFlag,this.value.commit(),this}interpolateTo(e){return e instanceof ot?at(this,e):super.interpolateTo(e)}get typeOrder(){return 1}compareTo(e){if(e instanceof ot){let t=this.key.compareTo(e.key);return 0===t&&(t=this.value.compareTo(e.value)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof ot&&(this.key.equals(e.key)&&this.value.equivalentTo(e.value,t))}keyEquals(e){return"string"==typeof e?this.key.value===e:e instanceof it?this.key.equals(e.key):this.key.equals(e)}equals(e){return this===e||e instanceof ot&&(this.key.equals(e.key)&&this.value.equals(e.value))}hashCode(){return i.mash(i.mix(i.mix(l.hash(ot),this.key.hashCode()),this.value.hashCode()))}debug(e){return e=e.write("Attr").write(46).write("of").write(40).display(this.key),this.value instanceof Et||(e=e.write(44).write(32).display(this.value)),e=e.write(41)}static of(e,t){return e=yt.fromAny(e),t=1===arguments.length?ht.extant():ht.fromAny(t),new ot(e,t)}}const at=function(e){const t=function(e,r){const i=function(e){const t=i.keyInterpolator(e),r=i.valueInterpolator(e);return ot.of(t,r)};return Object.setPrototypeOf(i,t.prototype),i.keyInterpolator=e.key.interpolateTo(r.key),i.valueInterpolator=e.value.interpolateTo(r.value),i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,Object.defineProperty(t.prototype,0,{get(){return ot.of(this.keyInterpolator[0],this.valueInterpolator[0])},configurable:!0}),Object.defineProperty(t.prototype,1,{get(){return ot.of(this.keyInterpolator[1],this.valueInterpolator[1])},configurable:!0}),t.prototype.equals=function(e){return this===e||e instanceof t&&(this.keyInterpolator.equals(e.keyInterpolator)&&this.valueInterpolator.equals(e.valueInterpolator))},t}(x),ut=function(e){const t=function(e,r){const i=function(e){const t=i.keyInterpolator(e),r=i.valueInterpolator(e);return nt.of(t,r)};return Object.setPrototypeOf(i,t.prototype),i.keyInterpolator=e.key.interpolateTo(r.key),i.valueInterpolator=e.value.interpolateTo(r.value),i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,Object.defineProperty(t.prototype,0,{get(){return nt.of(this.keyInterpolator[0],this.valueInterpolator[0])},configurable:!0}),Object.defineProperty(t.prototype,1,{get(){return nt.of(this.keyInterpolator[1],this.valueInterpolator[1])},configurable:!0}),t.prototype.equals=function(e){return this===e||e instanceof t&&(this.keyInterpolator.equals(e.keyInterpolator)&&this.valueInterpolator.equals(e.valueInterpolator))},t}(x);class ht extends tt{constructor(){super()}isDefined(){return!0}isDistinct(){return!0}isDefinite(){return!0}get key(){return ht.absent()}toValue(){return this}get tag(){}get target(){return this}flattened(){return this}unflattened(){return lt.of(this)}header(e){return ht.absent()}headers(e){}head(){return tt.absent()}tail(){return lt.empty()}body(){return ht.extant()}get length(){return 0}has(e){return!1}get(e){return ht.absent()}getAttr(e){return ht.absent()}getSlot(e){return ht.absent()}getField(e){}getItem(e){return tt.absent()}deleted(e){return this}conditional(e,t){return e=tt.fromAny(e)}or(e){return this}and(e){return e=tt.fromAny(e)}bitwiseOr(e){if((e=tt.fromAny(e))instanceof At)return new Lt(this,e);if(e instanceof ot){const t=this.bitwiseOr(e.value);if(t.isDefined())return new ot(e.key,t)}else if(e instanceof nt){const t=this.bitwiseOr(e.value);if(t.isDefined())return new nt(e.key,t)}return tt.absent()}bitwiseXor(e){if((e=tt.fromAny(e))instanceof At)return new Ft(this,e);if(e instanceof ot){const t=this.bitwiseXor(e.value);if(t.isDefined())return new ot(e.key,t)}else if(e instanceof nt){const t=this.bitwiseXor(e.value);if(t.isDefined())return new nt(e.key,t)}return tt.absent()}bitwiseAnd(e){if((e=tt.fromAny(e))instanceof At)return new Bt(this,e);if(e instanceof ot){const t=this.bitwiseAnd(e.value);if(t.isDefined())return new ot(e.key,t)}else if(e instanceof nt){const t=this.bitwiseAnd(e.value);if(t.isDefined())return new nt(e.key,t)}return tt.absent()}lt(e){return(e=tt.fromAny(e))instanceof At?new Ut(this,e):super.lt(e)}le(e){return(e=tt.fromAny(e))instanceof At?new Wt(this,e):super.le(e)}eq(e){return(e=tt.fromAny(e))instanceof At?new Rt(this,e):super.eq(e)}ne(e){return(e=tt.fromAny(e))instanceof At?new Ht(this,e):super.ne(e)}ge(e){return(e=tt.fromAny(e))instanceof At?new Kt(this,e):super.ge(e)}gt(e){return(e=tt.fromAny(e))instanceof At?new _t(this,e):super.gt(e)}plus(e){if((e=tt.fromAny(e))instanceof At)return new Gt(this,e);if(e instanceof ot){const t=this.plus(e.value);if(t.isDefined())return new ot(e.key,t)}else if(e instanceof nt){const t=this.plus(e.value);if(t.isDefined())return new nt(e.key,t)}return tt.absent()}minus(e){if((e=tt.fromAny(e))instanceof At)return new Qt(this,e);if(e instanceof ot){const t=this.minus(e.value);if(t.isDefined())return new ot(e.key,t)}else if(e instanceof nt){const t=this.minus(e.value);if(t.isDefined())return new nt(e.key,t)}return tt.absent()}times(e){if((e=tt.fromAny(e))instanceof At)return new Zt(this,e);if(e instanceof ot){const t=this.times(e.value);if(t.isDefined())return new ot(e.key,t)}else if(e instanceof nt){const t=this.times(e.value);if(t.isDefined())return new nt(e.key,t)}return tt.absent()}divide(e){if((e=tt.fromAny(e))instanceof At)return new Xt(this,e);if(e instanceof ot){const t=this.divide(e.value);if(t.isDefined())return new ot(e.key,t)}else if(e instanceof nt){const t=this.divide(e.value);if(t.isDefined())return new nt(e.key,t)}return tt.absent()}modulo(e){if((e=tt.fromAny(e))instanceof At)return new $t(this,e);if(e instanceof ot){const t=this.modulo(e.value);if(t.isDefined())return new ot(e.key,t)}else if(e instanceof nt){const t=this.modulo(e.value);if(t.isDefined())return new nt(e.key,t)}return tt.absent()}not(){return ht.absent()}bitwiseNot(){return ht.absent()}negative(){return ht.absent()}positive(){return ht.absent()}inverse(){return ht.absent()}lambda(e){return new mr(this,e)}stringValue(e){return e}numberValue(e){return e}booleanValue(e){return e}isAliased(){return!1}isMutable(){return!1}alias(){}branch(){return this}clone(){return this}commit(){return this}interpolateTo(e){return super.interpolateTo(e)}keyEquals(e){return!1}static builder(){return new ct}static empty(){return lt.empty()}static extant(){return Et.extant()}static absent(){return Ct.absent()}static fromAny(e){if(e instanceof ht)return e;if(void 0===e)return Ct.absent();if(null===e)return Et.extant();if("boolean"==typeof e)return Ot.from(e);if("number"==typeof e)return vt.from(e);if("string"==typeof e)return yt.from(e);if(e instanceof Uint8Array)return mt.wrap(e);if(Array.isArray(e))return lt.fromArray(e);if("object"==typeof e)return lt.fromObject(e);throw new TypeError(""+e)}}class lt extends ht{constructor(){super()}isDefinite(){return!this.isEmpty()}isArray(){return 0===this.fieldCount}isObject(){return 0===this.valueCount}get valueCount(){let e=0;return this.forEach((function(t){t instanceof ht&&(e+=1)}),this),e}isConstant(){return void 0===this.forEach((function(e){return!!e.isConstant()&&void 0}),this)}get tag(){const e=this.head();if(e instanceof ot)return e.key.value}get target(){let e,t,r=!1;return this.forEach((function(i){i instanceof ot?r=!0:void 0===e&&i instanceof ht?e=i:(void 0===t&&(t=lt.create(),void 0!==e&&t.push(e)),t.push(i))}),this),void 0===e?ht.extant():void 0===t?e:r?t:this}flattened(){if(this.isEmpty())return ht.extant();{const e=this.iterator(),t=e.head();return e.step(),e.isEmpty()&&t instanceof ht?t:this.branch()}}unflattened(){return this}header(e){const t=this.head();return t instanceof ot&&t.key.value===e?t.value:ht.absent()}headers(e){const t=this.head();if(t instanceof ot&&t.key.value===e){const e=t.value;return e instanceof lt?e:lt.of(e)}}head(){return this.forEach((function(e){return e}),this)||tt.absent()}tail(){const e=lt.create();return this.forEach((function(t,r){r>0&&e.push(t)}),this),e}body(){const e=this.tail();return e.isEmpty()?ht.absent():e.flattened()}has(e){return e=ht.fromAny(e),this.forEach((function(t){return!!(t instanceof it&&t.key.equals(e))||void 0}),this)||!1}indexOf(e,t=0){e=tt.fromAny(e),t<0&&(t=Math.max(0,this.length+t));const r=this.forEach((function(r,i){return i>=t&&e.equals(r)?i:void 0}),this);return void 0!==r?r:-1}lastIndexOf(e,t){e=tt.fromAny(e);const r=this.length;for(void 0===t?t=r-1:t<0&&(t=r+t),t=Math.min(t,r-1);t>=0;){if(e.equals(this.getItem(t)))return t;t-=1}return-1}get(e){return e=ht.fromAny(e),this.forEach((function(t){return t instanceof it&&t.key.equals(e)?t.value:void 0}),this)||ht.absent()}getAttr(e){return e=yt.fromAny(e),this.forEach((function(t){return t instanceof ot&&t.key.equals(e)?t.value:void 0}),this)||ht.absent()}getSlot(e){return e=ht.fromAny(e),this.forEach((function(t){return t instanceof nt&&t.key.equals(e)?t.value:void 0}),this)||ht.absent()}getField(e){return e=ht.fromAny(e),this.forEach((function(t){return t instanceof it&&t.key.equals(e)?t:void 0}),this)}set(e,t){e=ht.fromAny(e),t=ht.fromAny(t);const r=this.iterator();for(;!r.isEmpty();){const i=r.head();if(i instanceof it&&i.key.equals(e))return i.isMutable()?i.setValue(t):r.set(i.updatedValue(t)),this;r.step()}return this.push(new nt(e,t)),this}setAttr(e,t){e=yt.fromAny(e),t=ht.fromAny(t);const r=this.iterator();for(;!r.isEmpty();){const i=r.head();if(i instanceof it&&i.key.equals(e))return i instanceof ot&&i.isMutable()?i.setValue(t):r.set(new ot(e,t)),this;r.step()}return this.push(new ot(e,t)),this}setSlot(e,t){e=ht.fromAny(e),t=ht.fromAny(t);const r=this.iterator();for(;!r.isEmpty();){const i=r.head();if(i instanceof it&&i.key.equals(e))return i instanceof nt&&i.isMutable()?i.setValue(t):r.set(new nt(e,t)),this;r.step()}return this.push(new nt(e,t)),this}updated(e,t){e=ht.fromAny(e),t=ht.fromAny(t);const r=this.isMutable()?this:this.branch(),i=r.iterator();for(;!i.isEmpty();){const n=i.head();if(n.key.equals(e))return n instanceof it&&n.isMutable()?n.setValue(t):i.set(new nt(e,t)),r;i.step()}return r.push(new nt(e,t)),r}updatedAttr(e,t){e=yt.fromAny(e),t=ht.fromAny(t);const r=this.isMutable()?this:this.branch(),i=r.iterator();for(;!i.isEmpty();){const n=i.head();if(n.key.equals(e))return n instanceof ot&&n.isMutable()?n.setValue(t):i.set(new ot(e,t)),r;i.step()}return r.push(new ot(e,t)),r}updatedSlot(e,t){e=ht.fromAny(e),t=ht.fromAny(t);const r=this.isMutable()?this:this.branch(),i=r.iterator();for(;!i.isEmpty();){const n=i.head();if(n.key.equals(e))return n instanceof nt&&n.isMutable()?n.setValue(t):i.set(new nt(e,t)),r;i.step()}return r.push(new nt(e,t)),r}appended(...e){const t=this.isMutable()?this:this.branch();return t.push(...e),t}prepended(...e){const t=this.isMutable()?this:this.branch();return t.splice(0,0,...e),t}deleted(e){const t=this.isMutable()?this:this.branch();return t.delete(e),t}concat(...e){const t=this.isMutable()?this:this.branch();for(let r=0,i=e.length;r<i;r+=1)tt.fromAny(e[r]).forEach((function(e){t.push(e)}));return t}slice(e,t){return this.subRecord(e,t).branch()}attr(e,t){let r;return r=1===arguments.length?ot.of(e):ot.of(e,t),this.push(r),this}slot(e,t){let r;return r=1===arguments.length?nt.of(e):nt.of(e,t),this.push(r),this}item(e){return this.push(e),this}items(...e){return this.push(this,...e),this}evaluate(e){e=zt.fromAny(e);const t=lt.create();e.pushScope(t);let r=!1;return this.forEach((function(i){const n=i.evaluate(e);n.isDefined()&&t.push(n),i!==n&&(r=!0)}),this),e.popScope(),r?t:this}substitute(e){e=zt.fromAny(e);const t=lt.create();e.pushScope(t);let r=!1;return this.forEach((function(i){const n=i.substitute(e);n.isDefined()&&t.push(n),i!==n&&(r=!0)}),this),e.popScope(),r?t:this}stringValue(e){let t="";return void 0===this.forEach((function(e){if(e instanceof ht){const r=e.stringValue();if(void 0!==r)return void(t+=r)}return null}),this)?t:void 0}toAny(){return!this.isEmpty()&&this.isArray()?this.toArray():this.toObject()}toArray(){const e=new Array(this.length);return this.forEach((function(t,r){t instanceof ht?e[r]=t.toAny():t instanceof it&&(e[r]={$key:t.key.toAny(),$value:t.value.toAny()})}),this),e}toObject(){const e={};return this.forEach((function(t,r){t instanceof ot?e["@"+t.key.value]=t.value.toAny():t instanceof nt?t.key instanceof yt?e[t.key.value]=t.value.toAny():e["$"+r]={$key:t.key.toAny(),$value:t.value.toAny()}:t instanceof ht&&(e["$"+r]=t.toAny())}),this),e}isAliased(){return!1}isMutable(){return!0}alias(){}branch(){const e=lt.create();return this.forEach((function(t){e.push(t)}),this),e}clone(){const e=lt.create();return this.forEach((function(t){e.push(t.clone())}),this),e}commit(){return this}bind(){return this}subRecord(e,t){const r=this.length;void 0===e?e=0:e<0&&(e=r+e),e=Math.min(Math.max(0,e),r),void 0===t?t=r:t<0&&(t=r+t);const i=lt.create();return this.forEach((function(r,n){return n<e?void 0:n<t?void i.push(r):null}),this),i}iterator(){return new pt(this)}interpolateTo(e){return e instanceof lt?dt(this,e):super.interpolateTo(e)}get typeOrder(){return 3}compareTo(e){if(e instanceof lt){const t=this.iterator(),r=e.iterator();let i=0;do{if(t.isEmpty()||r.isEmpty())break;i=t.head().compareTo(r.head()),t.step(),r.step()}while(0===i);return 0!==i?i:t.isEmpty()&&!r.isEmpty()?-1:!t.isEmpty()&&r.isEmpty()?1:0}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){if(this===e)return!0;if(e instanceof lt){const r=this.iterator(),i=e.iterator();for(;!r.isEmpty()&&!i.isEmpty();){if(!r.head().equivalentTo(i.head(),t))return!1;r.step(),i.step()}return r.isEmpty()&&i.isEmpty()}return!1}equals(e){if(this===e)return!0;if(e instanceof lt){const t=this.iterator(),r=e.iterator();for(;!t.isEmpty()&&!r.isEmpty();){if(!t.head().equals(r.head()))return!1;t.step(),r.step()}return t.isEmpty()&&r.isEmpty()}return!1}hashCode(){let e=l.hash(lt);return this.forEach((function(t){e=i.mix(e,t.hashCode())}),this),e}debug(e){return e=e.write("Record").write(46),this.isEmpty()?e=e.write("empty").write(40).write(41):(e=e.write("of").write(40),this.forEach((function(t,r){0!==r&&(e=e.write(44).write(32)),e=e.display(t)}),this),e=e.write(41)),e}static empty(){return ft.empty()}static create(e){return ft.create(e)}static of(...e){return ft.of(...e)}static fromAny(e){if(e instanceof lt)return e;if(Array.isArray(e))return lt.fromArray(e);if("object"==typeof e&&null!==e)return lt.fromObject(e);throw new TypeError(""+e)}static fromArray(e){const t=e.length||0,r=lt.create(t);for(let i=0;i<t;i+=1)r.push(tt.fromAny(e[i]));return r}static fromObject(e){const t=lt.create();for(const r in e){const i=e[r];36===r.charCodeAt(0)?i&&"object"==typeof i&&Object.prototype.hasOwnProperty.call(i,"$key")?t.push(it.of(i.$key,i.$value)):t.push(ht.fromAny(i)):t.push(it.of(r,i))}return t}static expand(e){return e=Math.max(8,e)-1,e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,(e|=e>>16)+1}}lt.AliasedFlag=1,lt.ImmutableFlag=2,Object.defineProperty(lt.prototype,"fieldCount",{get(){let e=0;return this.forEach((function(t){t instanceof it&&(e+=1)}),this),e},configurable:!0});class ct{constructor(){this.record=null,this.value=null}push(...e){for(let t=0,r=e.length;t<r;t+=1){const r=e[t];if(r instanceof it)return this.pushField(r);if(r instanceof ht)return this.pushValue(r);throw new TypeError(""+r)}}pushField(e){null===this.record&&(this.record=lt.create(),null!==this.value&&(this.record.push(this.value),this.value=null)),this.record.push(e)}pushValue(e){null!==this.record?this.record.push(e):null===this.value?this.value=e:(this.record=lt.create(),this.record.push(this.value),this.value=null,this.record.push(e))}bind(){return null!==this.record?this.record:null!==this.value?this.value:ht.absent()}}const dt=function(e){const t=function(e,r){const i=function(e){const t=i.interpolators,r=t.length,n=lt.create(r);for(let i=0;i<r;i+=1)n.push(t[i](e));return n};Object.setPrototypeOf(i,t.prototype);const n=Math.min(e.length,r.length),s=new Array(n);for(let t=0;t<n;t+=1)s[t]=e.getItem(t).interpolateTo(r.getItem(t));return i.interpolators=s,i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,Object.defineProperty(t.prototype,0,{get(){const e=this.interpolators,t=e.length,r=lt.create(t);for(let i=0;i<t;i+=1)r.push(e[i][0]);return r},configurable:!0}),Object.defineProperty(t.prototype,1,{get(){const e=this.interpolators,t=e.length,r=lt.create(t);for(let i=0;i<t;i+=1)r.push(e[i][1]);return r},configurable:!0}),t.prototype.equals=function(e){if(this===e)return!0;if(e instanceof t){const t=this.interpolators.length;if(t===e.interpolators.length){for(let r=0;r<t;r+=1)if(!this.interpolators[r].equals(e.interpolators[r]))return!1;return!0}}return!1},t}(x);class pt extends j{constructor(e,t,r,i){super(),void 0===t&&(t=0),void 0===r&&(r=e.length),void 0===i&&(i=t),this.record=e,this.lower=t,this.upper=r,this.index=i,this.direction=0}isEmpty(){return this.index>=this.upper}head(){if(this.direction=0,this.index<this.upper)return this.record.getItem(this.index);throw new Error("empty")}step(){this.direction=0;const e=this.index;if(!(e<this.upper))throw new Error("empty");this.index=e+1}skip(e){this.index=Math.min(Math.max(this.lower,this.index+e,this.upper))}hasNext(){return this.index<this.upper}nextIndex(){return this.index-this.lower}next(){this.direction=1;const e=this.index;return e<this.upper?(this.index=e+1,{value:this.record.getItem(e),done:this.index===this.upper}):(this.index=this.upper,{done:!0})}hasPrevious(){return this.index>this.lower}previousIndex(){return this.index-this.lower-1}previous(){this.direction=-1;const e=this.index-1;return e>=this.lower?(this.index=e,{value:this.record.getItem(e),done:e===this.lower}):(this.index=0,{done:!0})}set(e){this.direction>0?this.record.setItem(this.index-1,e):this.record.setItem(this.index,e)}delete(){let e=this.index;this.direction>0&&(e-=1,this.index=e),this.record.splice(e,1),this.direction=0}}class ft extends lt{constructor(e,t,r,i,n){super(),this.array=e,this.table=t,Object.defineProperty(this,"length",{value:r,writable:!0,enumerable:!0,configurable:!0}),Object.defineProperty(this,"fieldCount",{value:i,writable:!0,enumerable:!0,configurable:!0}),this.flags=n}isEmpty(){return 0===this.length}get valueCount(){return this.length-this.fieldCount}isConstant(){const e=this.array;for(let t=0,r=this.length;t<r;t+=1)if(!e[t].isConstant())return!1;return!0}get tag(){if(this.fieldCount>0){const e=this.array[0];if(e instanceof ot)return e.key.value}}get target(){let e,t,r=!1;const i=this.array;for(let n=0,s=this.length;n<s;n+=1){const s=i[n];s instanceof ot?r=!0:void 0===e&&s instanceof ht?e=s:(void 0===t&&(t=lt.create(),void 0!==e&&t.push(e)),t.push(s))}return void 0===e?ht.extant():void 0===t?e:r?t:this}head(){return this.length>0?this.array[0]:tt.absent()}tail(){const e=this.length;return e>0?new wt(this,1,e):lt.empty()}body(){const e=this.length;if(e>2)return new wt(this,1,e).branch();if(2===e){const e=this.array[1];return e instanceof ht?e:lt.of(e)}return ht.absent()}has(e){if(0!==this.fieldCount){e=ht.fromAny(e);const t=this.hashTable(),r=t.length,i=Math.abs(e.hashCode()%r);let n=i;do{const i=t[n];if(void 0===i)break;if(i.key.equals(e))return!0;n=(n+1)%r}while(n!==i)}return!1}indexOf(e,t=0){e=tt.fromAny(e);const r=this.array,i=this.length;for(t<0&&(t=Math.max(0,i+t));t<i;){if(e.equals(r[t]))return t;t+=1}return-1}lastIndexOf(e,t){e=tt.fromAny(e);const r=this.array,i=this.length;for(void 0===t?t=i-1:t<0&&(t=i+t),t=Math.min(t,i-1);t>=0;){if(e.equals(r[t]))return t;t-=1}return-1}get(e){if(this.fieldCount>0){e=ht.fromAny(e);const t=this.hashTable(),r=t.length,i=Math.abs(e.hashCode()%r);let n=i;do{const i=t[n];if(void 0===i)break;if(i.key.equals(e))return i.value;n=(n+1)%r}while(n!==i)}return ht.absent()}getAttr(e){if(this.fieldCount>0){e=yt.fromAny(e);const t=this.hashTable(),r=t.length,i=Math.abs(e.hashCode()%r);let n=i;do{const i=t[n];if(void 0===i)break;if(i instanceof ot&&i.key.equals(e))return i.value;n=(n+1)%r}while(n!==i)}return ht.absent()}getSlot(e){if(this.fieldCount>0){e=ht.fromAny(e);const t=this.hashTable(),r=t.length,i=Math.abs(e.hashCode()%r);let n=i;do{const i=t[n];if(void 0===i)break;if(i instanceof nt&&i.key.equals(e))return i.value;n=(n+1)%r}while(n!==i)}return ht.absent()}getField(e){if(this.fieldCount>0){e=ht.fromAny(e);const t=this.hashTable(),r=t.length,i=Math.abs(e.hashCode()%r);let n=i;do{const i=t[n];if(void 0===i)break;if(i.key.equals(e))return i;n=(n+1)%r}while(n!==i)}}getItem(e){e instanceof vt&&(e=e.value);const t=this.length;return e<0&&(e=t+e),e>=0&&e<t?this.array[e]:tt.absent()}set(e,t){if(0!=(this.flags&lt.ImmutableFlag))throw new Error("immutable");return e=ht.fromAny(e),t=ht.fromAny(t),0!=(this.flags&lt.AliasedFlag)?this.fieldCount>0?this.setAliased(e,t):this.pushAliased(new nt(e,t)):this.fieldCount>0?null!==this.table?this.setMutable(e,t):this.updateMutable(e,t):this.pushMutable(new nt(e,t)),this}setAliased(e,t){const r=this.length,i=this.array,n=new Array(lt.expand(r+1));for(let s=0;s<r;s+=1){const o=i[s];if(o instanceof it&&o.key.equals(e)){for(n[s]=o.updatedValue(t),s+=1;s<r;)n[s]=i[s],s+=1;return this.array=n,this.table=null,void(this.flags&=~lt.AliasedFlag)}n[s]=o}n[r]=new nt(e,t),this.array=n,this.table=null,this.length=r+1,this.fieldCount+=1,this.flags&=~lt.AliasedFlag}setMutable(e,t){const r=this.table,i=r.length,n=Math.abs(e.hashCode()%i);let s=n;do{const n=r[s];if(void 0===n)break;if(n.key.equals(e))return n.isMutable()?void n.setValue(t):void this.updateMutable(e,t);s=(s+1)%i}while(s!==n);const o=new nt(e,t);this.pushMutable(o),ft.put(r,o)}updateMutable(e,t){const r=this.array;for(let i=0,n=this.length;i<n;i+=1){const n=r[i];if(n instanceof it&&n.key.equals(e))return r[i]=n.updatedValue(t),void(this.table=null)}const i=new nt(e,t);this.pushMutable(i),ft.put(this.table,i)}setAttr(e,t){if(0!=(this.flags&lt.ImmutableFlag))throw new Error("immutable");return e=yt.fromAny(e),t=ht.fromAny(t),0!=(this.flags&lt.AliasedFlag)?this.fieldCount>0?this.setAttrAliased(e,t):this.pushAliased(new ot(e,t)):this.fieldCount>0?null!==this.table?this.setAttrMutable(e,t):this.updateAttrMutable(e,t):this.pushMutable(new ot(e,t)),this}setAttrAliased(e,t){const r=this.length,i=this.array,n=new Array(lt.expand(r+1));for(let s=0;s<r;s+=1){const o=i[s];if(o instanceof it&&o.key.equals(e)){for(n[s]=new ot(e,t),s+=1;s<r;)n[s]=i[s],s+=1;return this.array=n,this.table=null,void(this.flags&=~lt.AliasedFlag)}n[s]=o}n[r]=new ot(e,t),this.array=n,this.table=null,this.length=r+1,this.fieldCount+=1,this.flags&=~lt.AliasedFlag}setAttrMutable(e,t){const r=this.table,i=r.length,n=Math.abs(e.hashCode()%i);let s=n;do{const n=r[s];if(void 0===n)break;if(n.key.equals(e))return void(n instanceof ot&&n.isMutable()?n.setValue(t):this.updateAttrMutable(e,t));s=(s+1)%i}while(s!==n);const o=new ot(e,t);this.push(o),ft.put(r,o)}updateAttrMutable(e,t){const r=this.array;for(let i=0,n=this.length;i<n;i+=1){const n=r[i];if(n instanceof it&&n.key.equals(e))return r[i]=new ot(e,t),void(this.table=null)}const i=new ot(e,t);this.push(i),ft.put(this.table,i)}setSlot(e,t){if(0!=(this.flags&lt.ImmutableFlag))throw new Error("immutable");return e=ht.fromAny(e),t=ht.fromAny(t),0!=(this.flags&lt.AliasedFlag)?this.fieldCount>0?this.setSlotAliased(e,t):this.pushAliased(new nt(e,t)):this.fieldCount>0?null!==this.table?this.setSlotMutable(e,t):this.updateSlotMutable(e,t):this.pushMutable(new nt(e,t)),this}setSlotAliased(e,t){const r=this.length,i=this.array,n=new Array(lt.expand(r+1));for(let s=0;s<r;s+=1){const o=i[s];if(o instanceof it&&o.key.equals(e)){for(n[s]=new nt(e,t),s+=1;s<r;)n[s]=i[s],s+=1;return this.array=n,this.table=null,void(this.flags&=~lt.AliasedFlag)}n[s]=o}n[r]=new nt(e,t),this.array=n,this.table=null,this.length=r+1,this.fieldCount+=1,this.flags&=~lt.AliasedFlag}setSlotMutable(e,t){const r=this.table,i=r.length,n=Math.abs(e.hashCode()%i);let s=n;do{const n=r[s];if(void 0===n)break;if(n.key.equals(e))return void(n instanceof nt&&n.isMutable()?n.setValue(t):this.updateSlotMutable(e,t));s=(s+1)%i}while(s!==n);const o=new nt(e,t);this.push(o),ft.put(r,o)}updateSlotMutable(e,t){const r=this.array;for(let i=0,n=this.length;i<n;i+=1){const n=r[i];if(n instanceof it&&n.key.equals(e))return r[i]=new nt(e,t),void(this.table=null)}const i=new nt(e,t);this.push(i),ft.put(this.table,i)}setItem(e,t){if(0!=(this.flags&lt.ImmutableFlag))throw new Error("immutable");t=tt.fromAny(t);const r=this.length;if(e<0&&(e=r+e),e<0||e>r)throw new RangeError(""+e);return 0!=(this.flags&lt.AliasedFlag)?this.setItemAliased(e,t):this.setItemMutable(e,t),this}setItemAliased(e,t){const r=this.length,i=this.array,n=new Array(lt.expand(r));for(let e=0;e<r;e+=1)n[e]=i[e];const s=i[e];n[e]=t,this.array=n,this.table=null,t instanceof it?s instanceof it||(this.fieldCount+=1):s instanceof it&&(this.fieldCount-=1),this.flags&=~lt.AliasedFlag}setItemMutable(e,t){const r=this.array,i=r[e];r[e]=t,t instanceof it?(this.table=null,i instanceof it||(this.fieldCount+=1)):i instanceof it&&(this.table=null,this.fieldCount-=1)}updated(e,t){e=ht.fromAny(e),t=ht.fromAny(t);const r=0==(this.flags&lt.ImmutableFlag)?this:this.branch();return 0!=(r.flags&lt.AliasedFlag)?r.fieldCount>0?r.setAliased(e,t):r.pushAliased(new nt(e,t)):r.fieldCount>0?null!==r.table?r.setMutable(e,t):r.updateMutable(e,t):r.pushMutable(new nt(e,t)),r}updatedAttr(e,t){e=yt.fromAny(e),t=ht.fromAny(t);const r=0==(this.flags&lt.ImmutableFlag)?this:this.branch();return 0!=(r.flags&lt.AliasedFlag)?r.fieldCount>0?r.setAttrAliased(e,t):r.pushAliased(new ot(e,t)):r.fieldCount>0?null!==r.table?r.setAttrMutable(e,t):r.updateAttrMutable(e,t):r.pushMutable(new ot(e,t)),r}updatedSlot(e,t){e=ht.fromAny(e),t=ht.fromAny(t);const r=0==(this.flags&lt.ImmutableFlag)?this:this.branch();return 0!=(r.flags&lt.AliasedFlag)?r.fieldCount>0?r.setSlotAliased(e,t):r.pushAliased(new nt(e,t)):r.fieldCount>0?null!==r.table?r.setSlotMutable(e,t):r.updateSlotMutable(e,t):r.pushMutable(new nt(e,t)),r}push(...e){if(0!=(this.flags&lt.ImmutableFlag))throw new Error("immutable");return 0!=(this.flags&lt.AliasedFlag)?this.pushAliased(...e):this.pushMutable(...e),this.length}pushAliased(...e){const t=e.length;let r=this.length,i=this.fieldCount;const n=this.array,s=new Array(lt.expand(r+t));if(null!==n)for(let e=0;e<r;e+=1)s[e]=n[e];for(let n=0;n<t;n+=1){const t=tt.fromAny(e[n]);s[r]=t,r+=1,t instanceof it&&(i+=1)}this.array=s,this.table=null,this.length=r,this.fieldCount=i,this.flags&=~lt.AliasedFlag}pushMutable(...e){const t=e.length;let r=this.length,i=this.fieldCount;const n=this.array;let s;if(null===n||r+t>n.length){if(s=new Array(lt.expand(r+t)),null!==n)for(let e=0;e<r;e+=1)s[e]=n[e]}else s=n;for(let n=0;n<t;n+=1){const t=tt.fromAny(e[n]);s[r]=t,r+=1,t instanceof it&&(i+=1,this.table=null)}this.array=s,this.length=r,this.fieldCount=i}splice(e,t=0,...r){if(0!=(this.flags&lt.ImmutableFlag))throw new Error("immutable");const i=this.length;return e<0&&(e=i+e),e=Math.min(Math.max(0,e),i),t=Math.min(Math.max(0,t),i-e),0!=(this.flags&lt.AliasedFlag)?this.spliceAliased(e,t,...r):this.spliceMutable(e,t,...r)}spliceAliased(e,t,...r){const i=r.length;let n=this.length,s=this.fieldCount;const o=this.array,a=new Array(lt.expand(n-t+i));for(let t=0;t<e;t+=1)a[t]=o[t];const u=[];for(let r=e;r<e+t;r+=1){const e=o[r];u.push(e),n-=1,e instanceof it&&(s-=1)}for(let r=e;r<n;r+=1)a[r+i]=o[r+t];for(let t=0;t<i;t+=1){const i=tt.fromAny(r[t]);a[t+e]=i,n+=1,i instanceof it&&(s+=1)}return this.array=a,this.table=null,this.length=n,this.fieldCount=s,this.flags&=~lt.AliasedFlag,u}spliceMutable(e,t,...r){const i=r.length;let n=this.length,s=this.fieldCount;const o=this.array;let a;if(null===o||n-t+i>o.length){if(a=new Array(lt.expand(n-t+i)),null!==o)for(let t=0;t<e;t+=1)a[t]=o[t]}else a=o;const u=[];for(let r=e;r<e+t;r+=1){const e=o[r];u.push(e),n-=1,e instanceof it&&(s-=1)}if(i>t)for(let r=n-1;r>=e;r-=1)a[r+i]=o[r+t];else for(let r=e;r<n;r+=1)a[r+i]=o[r+t];for(let t=0;t<i;t+=1){const i=tt.fromAny(r[t]);a[t+e]=i,n+=1,i instanceof it&&(s+=1)}return this.array=a,this.length=n,this.fieldCount=s,u}delete(e){if(0!=(this.flags&lt.ImmutableFlag))throw new Error("immutable");return e=ht.fromAny(e),0!=(this.flags&lt.AliasedFlag)?this.deleteAliased(e):this.deleteMutable(e)}deleteAliased(e){const t=this.length,r=this.array,i=new Array(lt.expand(t));for(let n=0;n<t;n+=1){const s=r[n];if(s instanceof it&&s.key.equals(e)){for(let e=n+1;e<t;e+=1,n+=1)i[n]=r[e];return this.array=i,this.table=null,this.length=t-1,this.fieldCount-=1,this.flags&=~lt.AliasedFlag,s}i[n]=s}return tt.absent()}deleteMutable(e){const t=this.length,r=this.array;for(let i=0;i<t;i+=1){const n=r[i];if(n instanceof it&&n.key.equals(e)){for(let e=i+1;e<t;e+=1,i+=1)r[i]=r[e];return r[t-1]=void 0,this.table=null,this.length=t-1,this.fieldCount-=1,n}}return tt.absent()}clear(){if(0!=(this.flags&lt.ImmutableFlag))throw new Error("immutable");this.array=null,this.table=null,this.length=0,this.fieldCount=0,this.flags=0}isAliased(){return 0!=(this.flags&lt.AliasedFlag)}isMutable(){return 0==(this.flags&lt.ImmutableFlag)}alias(){this.flags|=lt.AliasedFlag}branch(){if(0==(this.flags&(lt.AliasedFlag|lt.ImmutableFlag))){const e=this.array;for(let t=0,r=this.length;t<r;t+=1)e[t].alias()}return this.flags|=lt.AliasedFlag,new ft(this.array,this.table,this.length,this.fieldCount,lt.AliasedFlag)}clone(){const e=this.length,t=this.array,r=new Array(e);for(let i=0;i<e;i+=1)r[i]=t[i].clone();return new ft(r,null,e,this.fieldCount,0)}commit(){if(0==(this.flags&lt.ImmutableFlag)){this.flags|=lt.ImmutableFlag;const e=this.array;for(let t=0,r=this.length;t<r;t+=1)e[t].commit()}return this}hashTable(){const e=this.fieldCount;let t=this.table;if(0!==e&&null===t){t=new Array(lt.expand(Math.max(e,10*e/7)));const r=this.array;for(let e=0,i=this.length;e<i;e+=1){const i=r[e];i instanceof it&&ft.put(t,i)}this.table=t}return t}static put(e,t){if(null!==e){const r=e.length,i=Math.abs(t.key.hashCode()%r);let n=i;do{const i=e[n];if(void 0===i)return void(e[n]=t);if(t.key.equals(i.key))return void(e[n]=t);n=(n+1)%r}while(n!==i);throw new Error}}evaluate(e){e=zt.fromAny(e);const t=this.array,r=this.length,i=lt.create(r);e.pushScope(i);let n=!1;for(let s=0;s<r;s+=1){const r=t[s],o=r.evaluate(e);o.isDefined()&&i.push(o),r!==o&&(n=!0)}return e.popScope(),n?i:this}substitute(e){e=zt.fromAny(e);const t=this.array,r=this.length,i=lt.create(r);e.pushScope(i);let n=!1;for(let s=0;s<r;s+=1){const r=t[s],o=r.substitute(e);o.isDefined()&&i.push(o),r!==o&&(n=!0)}return e.popScope(),n?i:this}subRecord(e,t){const r=this.length;if(void 0===e?e=0:e<0&&(e=r+e),void 0===t?t=r:t<0&&(t=r+t),e<0||t>r||e>t)throw new RangeError(e+", "+t);return new wt(this,e,t)}forEach(e,t){const r=this.array;for(let i=0,n=this.length;i<n;i+=1){const n=e.call(t,r[i],i);if(void 0!==n)return n}}static empty(){return new ft(null,null,0,0,lt.AliasedFlag|lt.ImmutableFlag)}static create(e){return void 0===e?new ft(null,null,0,0,lt.AliasedFlag):new ft(new Array(e),null,0,0,0)}static of(...e){const t=e.length;if(0===t)return new ft(null,null,0,0,lt.AliasedFlag);{const r=new Array(t);let i=0,n=0;for(let s=0;s<t;s+=1){const t=tt.fromAny(e[s]);r[s]=t,i+=1,t instanceof it&&(n+=1)}return new ft(r,null,i,n,0)}}}e([n],ft,"empty",null);class wt extends lt{constructor(e,t,r){super(),this.record=e,this.lower=t,this.upper=r}isEmpty(){return this.lower===this.upper}isArray(){const e=this.record.array;for(let t=this.lower,r=this.upper;t<r;t+=1)if(e[t]instanceof it)return!1;return!0}isObject(){const e=this.record.array;for(let t=this.lower,r=this.upper;t<r;t+=1)if(e[t]instanceof ht)return!1;return!0}get length(){return this.upper-this.lower}get valueCount(){let e=0;const t=this.record.array;for(let r=this.lower,i=this.upper;r<i;r+=1)t[r]instanceof ht&&(e+=1);return e}isConstant(){const e=this.record.array;for(let t=this.lower,r=this.upper;t<r;t+=1)if(!e[t].isConstant())return!1;return!0}get tag(){if(this.length>0){const e=this.record.array[this.lower];if(e instanceof ot)return e.key.value}}get target(){let e,t,r=!1;const i=this.record.array;for(let n=this.lower,s=this.upper;n<s;n+=1){const s=i[n];s instanceof ot?r=!0:void 0===e&&s instanceof ht?e=s:(void 0===t&&(t=lt.create(),void 0!==e&&t.push(e)),t.push(s))}return void 0===e?ht.extant():void 0===t?e:r?t:this}head(){return this.length>0?this.record.array[this.lower]:tt.absent()}tail(){return this.length>0?new wt(this.record,this.lower+1,this.upper):lt.empty()}body(){const e=this.length;if(e>2)return new wt(this.record,this.lower+1,this.upper).branch();if(2===e){const e=this.record.array[this.lower+1];return e instanceof ht?e:lt.of(e)}return ht.absent()}indexOf(e,t=0){e=tt.fromAny(e);const r=this.record.array,i=this.length;for(t<0&&(t=Math.max(0,i+t)),t=this.lower+t;t<this.upper;){if(e.equals(r[t]))return t-this.lower;t+=1}return-1}lastIndexOf(e,t){e=tt.fromAny(e);const r=this.record.array,i=this.length;for(void 0===t?t=i-1:t<0&&(t=i+t),t=this.lower+Math.min(t,i-1);t>=this.lower;){if(e.equals(r[t]))return t-this.lower;t-=1}return-1}getItem(e){e instanceof vt&&(e=e.value);const t=this.length;return e<0&&(e=t+e),e>=0&&e<t?this.record.array[this.lower+e]:tt.absent()}setItem(e,t){if(0!=(this.record.flags&lt.ImmutableFlag))throw new Error("immutable");t=tt.fromAny(t);const r=this.length;if(e<0&&(e=r+e),e<0||e>r)throw new RangeError(""+e);return 0!=(this.record.flags&lt.AliasedFlag)?this.setItemAliased(e,t):this.setItemMutable(e,t),this}setItemAliased(e,t){const r=this.record,i=r.length,n=r.array,s=new Array(lt.expand(i));for(let e=0;e<i;e+=1)s[e]=n[e];const o=null!==n?n[this.lower+e]:null;s[this.lower+e]=t,r.array=s,r.table=null,t instanceof it?o instanceof it||(r.fieldCount+=1):o instanceof it&&(r.fieldCount-=1),r.flags&=~lt.AliasedFlag}setItemMutable(e,t){const r=this.record,i=r.array,n=i[this.lower+e];i[this.lower+e]=t,t instanceof it?(r.table=null,n instanceof it||(r.fieldCount+=1)):n instanceof it&&(r.table=null,r.fieldCount-=1)}push(...e){if(0!=(this.record.flags&lt.ImmutableFlag))throw new Error("immutable");return 0!=(this.record.flags&lt.AliasedFlag)?this.pushAliased(...e):this.pushMutable(...e),this.length}pushAliased(...e){const t=this.record,r=e.length;let i=t.length,n=t.fieldCount;const s=t.array,o=new Array(lt.expand(i+r));if(null!==s){for(let e=0;e<this.upper;e+=1)o[e]=s[e];for(let e=this.upper;e<i;e+=1)o[e+r]=s[e]}for(let t=0;t<r;t+=1){const r=tt.fromAny(e[t]);o[t+this.upper]=r,i+=1,r instanceof it&&(n+=1)}t.array=o,t.table=null,t.length=i,t.fieldCount=n,t.flags&=~lt.AliasedFlag,this.upper+=r}pushMutable(...e){const t=this.record,r=e.length;let i=t.length,n=t.fieldCount;const s=t.array;let o;if(null===s||i+r>s.length){if(o=new Array(lt.expand(i+r)),null!==s)for(let e=0;e<this.upper;e+=1)o[e]=s[e]}else o=s;for(let e=i-1;e>=this.upper;e-=1)o[e+r]=s[e];for(let s=0;s<r;s+=1){const r=tt.fromAny(e[s]);o[s+this.upper]=r,i+=1,r instanceof it&&(n+=1,t.table=null)}t.array=o,t.length=i,t.fieldCount=n,this.upper+=r}splice(e,t=0,...r){if(0!=(this.record.flags&lt.ImmutableFlag))throw new Error("immutable");const i=this.length;let n;return e<0&&(e=i+e),e=Math.min(Math.max(0,e),i),t=Math.min(Math.max(0,t),i-e),n=0!=(this.record.flags&lt.AliasedFlag)?this.record.spliceAliased(this.lower+e,t,...r):this.record.spliceMutable(this.lower+e,t,...r),this.upper+=r.length-n.length,n}delete(e){if(0!=(this.record.flags&lt.ImmutableFlag))throw new Error("immutable");return e=ht.fromAny(e),0!=(this.record.flags&lt.AliasedFlag)?this.deleteAliased(e):this.deleteMutable(e)}deleteAliased(e){const t=this.record,r=t.length,i=t.array,n=new Array(lt.expand(r));for(let s=this.lower;s<this.upper;s+=1){const o=i[s];if(o instanceof it&&o.key.equals(e)){for(let e=s+1;e<r;e+=1,s+=1)n[s]=i[e];return t.array=n,t.table=null,t.length=r-1,t.fieldCount-=1,t.flags&=~lt.AliasedFlag,this.upper-=1,o}n[s]=o}return tt.absent()}deleteMutable(e){const t=this.record,r=t.length,i=t.array;for(let n=this.lower;n<this.upper;n+=1){const s=i[n];if(s instanceof it&&s.key.equals(e)){for(let e=n+1;e<r;e+=1,n+=1)i[n]=i[e];return i[r-1]=void 0,t.table=null,t.length=r-1,t.fieldCount-=1,this.upper-=1,s}}return tt.absent()}clear(){if(0!=(this.record.flags&lt.ImmutableFlag))throw new Error("immutable");0!=(this.record.flags&lt.AliasedFlag)?this.clearAliased():this.clearMutable()}clearAliased(){const e=this.record,t=e.length;let r=e.fieldCount;const i=t-this.length,n=e.array,s=new Array(lt.expand(i));let o=0;for(;o<this.lower;)s[o]=n[o],o+=1;for(;o<this.upper;)n[o]instanceof it&&(r-=1),o+=1;o=this.lower;let a=this.upper;for(;a<t;)s[o]=n[a],o+=1,a+=1;e.array=s,e.table=null,e.length=i,e.fieldCount=r,e.flags&=~lt.AliasedFlag,this.upper=this.lower}clearMutable(){const e=this.record,t=e.length;let r=e.fieldCount;const i=e.array;let n=this.lower;for(;n<this.upper;)i[n]instanceof it&&(r-=1),n+=1;n=this.lower;let s=this.upper;for(;s<t;){const t=i[s];t instanceof it&&(e.table=null),i[n]=t,n+=1,s+=1}for(e.length=n,e.fieldCount=r;n<t;)i[n]=void 0,n+=1;this.upper=this.lower}isAliased(){return 0!=(this.record.flags&lt.AliasedFlag)}isMutable(){return 0==(this.record.flags&lt.ImmutableFlag)}alias(){this.record.flags|=lt.AliasedFlag}branch(){const e=this.length;let t=0;const r=this.record.array,i=new Array(lt.expand(e));let n=this.lower,s=0;for(;s<e;){const e=r[n];i[s]=e,e instanceof it&&(t+=1),n+=1,s+=1}return new ft(i,null,e,t,0)}clone(){const e=this.length;let t=0;const r=this.record.array,i=new Array(lt.expand(e));let n=this.lower,s=0;for(;s<e;){const e=r[n];i[s]=e.clone(),e instanceof it&&(t+=1),n+=1,s+=1}return new ft(i,null,e,t,0)}commit(){return this.record.commit(),this}subRecord(e,t){const r=this.length;if(void 0===e?e=0:e<0&&(e=r+e),void 0===t?t=r:t<0&&(t=r+t),e<0||t>r||e>t)throw new RangeError(e+", "+t);return new wt(this.record,this.lower+e,this.upper+t)}forEach(e,t){const r=this.record.array;for(let i=this.lower,n=this.upper;i<n;i+=1){const n=e.call(t,r[i],i);if(void 0!==n)return n}}}Object.defineProperty(wt.prototype,"fieldCount",{get(){const e=this.record.array;let t=0;for(let r=this.lower,i=this.upper;r<i;r+=1)e[r]instanceof it&&(t+=1);return t},configurable:!0});class mt extends ht{constructor(e,t,r){super(),this.array=e,this.size=t,this.flags=r}isConstant(){return!0}getByte(e){if(e<0||e>=this.size)throw new RangeError(""+e);return this.array[e]}setByte(e,t){const r=this.flags;if(0!=(r&mt.ImmutableFlag))throw new Error("immutable");if(e<0||e>=this.size)throw new RangeError(""+e);return 0!=(r&mt.AliasedFlag)?this.setByteAliased(e,t):this.setByteMutable(e,t)}setByteAliased(e,t){const r=this.size,i=this.array,n=new Uint8Array(mt.expand(r));return n.set(i,0),n[e]=t,this.array=n,this.flags&=~mt.AliasedFlag,this}setByteMutable(e,t){return this.array[e]=t,this}addByte(e){const t=this.flags;if(0!=(t&mt.ImmutableFlag))throw new Error("immutable");return 0!=(t&mt.AliasedFlag)?this.addByteAliased(e):this.addByteMutable(e)}addByteAliased(e){const t=this.size,r=this.array,i=new Uint8Array(mt.expand(t+1));return null!==r&&i.set(r,0),i[t]=e,this.array=i,this.size=t+1,this.flags&=~mt.AliasedFlag,this}addByteMutable(e){const t=this.size,r=this.array;let i;return null===r||t+1>r.length?(i=new Uint8Array(mt.expand(t+1)),null!==r&&i.set(r,0),this.array=i):i=r,i[t]=e,this.size=t+1,this}addData(e){let t=e.array;if(null!==t){const r=e.size;return t.length>r&&(t=t.slice(0,r)),this.addUint8Array(t)}return this}addUint8Array(e){const t=this.flags;if(0!=(t&mt.ImmutableFlag))throw new Error("immutable");return 0!=(t&mt.AliasedFlag)?this.addUint8ArrayAliased(e):this.addUint8ArrayMutable(e)}addUint8ArrayAliased(e){const t=e.length;if(0===t)return this;const r=this.size,i=this.array,n=new Uint8Array(mt.expand(r+t));return null!==i&&n.set(i,0),n.set(e,r),this.array=n,this.size=r+t,this.flags&=~mt.AliasedFlag,this}addUint8ArrayMutable(e){const t=e.length;if(0===t)return this;const r=this.size,i=this.array;let n;return null===i||r+t>i.length?(n=new Uint8Array(mt.expand(r+t)),null!==i&&n.set(i,0),this.array=n):n=i,n.set(e,r),this.size=r+t,this}clear(){if(0!=(this.flags&mt.ImmutableFlag))throw new Error("immutable");this.array=null,this.size=0,this.flags=mt.AliasedFlag}toUint8Array(){const e=this.array,t=this.flags;if(0!=(t&mt.ImmutableFlag))return null!==e?e.slice(0):new Uint8Array(0);if(0!=(t&mt.AliasedFlag)||this.size!==e.length){const t=null!==e?e.slice(0):new Uint8Array(0);return this.array=t,this.flags&=~mt.AliasedFlag,t}return e}asUint8Array(){let e;return null!==this.array&&this.size>0?(e=this.array,e.length!==this.size&&(e=new Uint8Array(e.buffer,e.byteOffset,this.size))):e=void 0,e}toAny(){return this.toUint8Array()}isAliased(){return 0!=(this.flags&mt.AliasedFlag)}isMutable(){return 0==(this.flags&mt.ImmutableFlag)}branch(){return this.flags|=mt.AliasedFlag,new mt(this.array,this.size,mt.AliasedFlag)}clone(){return this.branch()}commit(){return this.flags|=mt.ImmutableFlag,this}writeBase16(e,t=Be.uppercase){let r=this.array;const i=this.size;return null!==r&&0!==i?(r.length!==i&&(r=r.slice(0,i)),t.writeUint8Array(e,r)):oe.end()}toBase16(e=Be.uppercase){const t=ue.stringOutput();return this.writeBase16(t,e).bind(),t.bind()}writeBase64(e,t=Xe.standard()){let r=this.array;const i=this.size;return null!==r&&0!==i?(r.length!==i&&(r=r.slice(0,i)),t.writeUint8Array(e,r)):oe.end()}toBase64(e=Xe.standard()){const t=ue.stringOutput();return this.writeBase64(t,e),t.bind()}interpolateTo(e){return super.interpolateTo(e)}get typeOrder(){return 4}compareTo(e){if(e instanceof mt){const t=this.array,r=e.array,i=this.size,n=e.size;let s=0,o=0;do{if(!(o<i&&o<n))break;s=t[o]-r[o],o+=1}while(0===s);return s>0?1:s<0?-1:i>n?1:i<n?-1:0}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e){return this.equals(e)}equals(e){if(this===e)return!0;if(e instanceof mt){const t=this.array,r=e.array,i=this.size;if(i!==e.size)return!1;for(let e=0;e<i;e+=1)if(t[e]!==r[e])return!1;return!0}return!1}hashCode(){return i.mash(i.mixUint8Array(l.hash(mt),null!==this.array?this.array:new Uint8Array(0)))}debug(e){if(e=e.write("Data").write(46),0===this.size)e=e.write("empty").write(40).write(41);else{e=e.write("base16").write(40).write(34);const t=this.writeBase16(e);if(!t.isDone())return ie.error(t.trap());e=e.write(34).write(41)}return e}static empty(){return new mt(null,0,mt.AliasedFlag|mt.ImmutableFlag)}static create(e){return void 0===e?new mt(null,0,mt.AliasedFlag):new mt(new Uint8Array(e),0,0)}static wrap(e){return new mt(e,e.length,mt.AliasedFlag)}static fromBase16(e){return"string"==typeof e&&(e=ue.stringInput(e)),Be.parse(e,mt.output()).bind()}static fromBase64(e,t=Xe.standard()){return"string"==typeof e&&(e=ue.stringInput(e)),t.parse(e,mt.output()).bind()}static fromAny(e){if(e instanceof mt)return e;if(e instanceof Uint8Array)return mt.wrap(e);throw new TypeError(""+e)}static random(e){const r=new Uint8Array(e);return t.fillBytes(r),mt.wrap(r)}static output(e){return e instanceof mt||(e=mt.create(e)),new gt(e,X.standard())}static expand(e){return e=Math.max(32,e)-1,e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,(e|=e>>16)+1}}mt.AliasedFlag=1,mt.ImmutableFlag=2,e([n],mt,"empty",null);class gt extends ie{constructor(e,t){super(),this.data=e,this.settings=t}isCont(){return!0}isFull(){return!1}isDone(){return!1}isError(){return!1}isPart(){return!1}asPart(e){return this}write(e){if("number"==typeof e)return this.data.addByte(e),this;throw new TypeError(""+e)}writeln(e){throw new TypeError(""+e)}withSettings(e){return e=X.fromAny(e),this.settings=e,this}bind(){return this.data}clone(){return new gt(this.data.branch(),this.settings)}}class yt extends ht{constructor(e){super(),this.value=e,this.hashValue=void 0}isConstant(){return!0}get size(){return this.value.length}stringValue(e){return this.value}numberValue(e){try{return vt.parse(this.value).numberValue()}catch(t){return e}}booleanValue(e){return"true"===this.value||"false"!==this.value&&e}toAny(){return this.value}valueOf(){return this.value}plus(e){return(e=tt.fromAny(e))instanceof yt?yt.from(this.value+e.value):super.plus(e)}branch(){return this}clone(){return this}commit(){return this}interpolateTo(e){return super.interpolateTo(e)}get typeOrder(){return 5}compareTo(e){return e instanceof yt?this.value.localeCompare(e.value):e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e){return this.equals(e)}equals(e){return this===e||e instanceof yt&&this.value===e.value}hashCode(){let e=this.hashValue;return void 0===e&&(e=u.hash(this.value),this.hashValue=e),e}debug(e){return e=e.write("Text").write(46),e=0===this.value.length?e.write("empty").write(40).write(41):e.write("from").write(40).debug(this.value).write(41)}display(e){return he.debugAny(e,this.value)}toString(){return this.value}static empty(){return new yt("")}static from(e){const t=e.length;if(0===t)return yt.empty();{let r=new yt(e);return t<=64&&(r=yt.cache.put(r)),r}}static fromAny(e){if(e instanceof yt)return e;if("string"==typeof e)return yt.from(e);throw new TypeError(""+e)}static output(e){return void 0===e&&(e=X.standard()),new bt("",e)}static get cache(){return new R(128)}}e([n],yt,"empty",null),e([n],yt,"cache",null);class bt extends ie{constructor(e,t){super(),this.string=e,this.settings=t}isCont(){return!0}isFull(){return!1}isDone(){return!1}isError(){return!1}isPart(){return!1}asPart(e){return this}write(e){if("number"==typeof e)if(e>=0&&e<=55295||e>=57344&&e<=65535)e=String.fromCharCode(e);else if(e>=65536&&e<=1114111){const t=e-65536;e=String.fromCharCode(55296|t>>>10,56320|1023&t)}else e="";return this.string+=e,this}withSettings(e){return e=X.fromAny(e),this.settings=e,this}bind(){return yt.from(this.string)}clone(){return new bt(this.string,this.settings)}toString(){return this.string}}class vt extends ht{constructor(e,t){super(),this.value=e,this.flags=void 0!==t?t:0}isConstant(){return!0}isNaN(){return isNaN(this.value)}isInfinite(){return!isNaN(this.value)&&!isFinite(this.value)}isUint32(){return 0!=(this.flags&vt.Uint32Flag)}isUint64(){return 0!=(this.flags&vt.Uint64Flag)}stringValue(e){return""+this.value}numberValue(e){return this.value}booleanValue(e){return!!this.value}toAny(){return this.value}valueOf(){return this.value}bitwiseOr(e){return(e=tt.fromAny(e))instanceof vt?vt.from((this.value|e.value)>>>0):super.bitwiseOr(e)}bitwiseXor(e){return(e=tt.fromAny(e))instanceof vt?vt.from((this.value^e.value)>>>0):super.bitwiseXor(e)}bitwiseAnd(e){return(e=tt.fromAny(e))instanceof vt?vt.from((this.value&e.value)>>>0):super.bitwiseAnd(e)}plus(e){return(e=tt.fromAny(e))instanceof vt?vt.from(this.value+e.value):super.plus(e)}minus(e){return(e=tt.fromAny(e))instanceof vt?vt.from(this.value-e.value):super.minus(e)}times(e){return(e=tt.fromAny(e))instanceof vt?vt.from(this.value*e.value):super.times(e)}divide(e){return(e=tt.fromAny(e))instanceof vt?vt.from(this.value/e.value):super.divide(e)}modulo(e){return(e=tt.fromAny(e))instanceof vt?vt.from(this.value%e.value):super.modulo(e)}bitwiseNot(){return vt.from(~this.value>>>0)}negative(){return vt.from(-this.value)}positive(){return this}inverse(){return vt.from(1/this.value)}abs(){return vt.from(Math.abs(this.value))}ceil(){return vt.from(Math.ceil(this.value))}floor(){return vt.from(Math.floor(this.value))}round(){return vt.from(Math.round(this.value))}sqrt(){return vt.from(Math.sqrt(this.value))}pow(e){return e=vt.fromAny(e),vt.from(Math.pow(this.value,e.value))}max(e){return this.compareTo(e)>=0?this:e}min(e){return this.compareTo(e)<=0?this:e}interpolateTo(e){return e instanceof vt?xt(this,e):super.interpolateTo(e)}get typeOrder(){return 6}compareTo(e){if(e instanceof vt){const t=this.value,r=e.value;return t<r?-1:t>r?1:isNaN(r)?isNaN(t)?0:-1:isNaN(t)?1:0}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){if(this===e)return!0;if(e instanceof vt){const r=this.value,i=e.value;return r===i||isNaN(r)&&isNaN(i)||Math.abs(i-r)<(void 0!==t?t:o.Epsilon)}return!1}equals(e){if(this===e)return!0;if(e instanceof vt){const t=this.value,r=e.value;return t===r||isNaN(t)&&isNaN(r)}return!1}hashCode(){return a.hash(this.value)}debug(e){return e=e.write("Num").write(46).write("from").write(40).display(this).write(41)}display(e){return he.displayNumber(e,this.value)}static get zero(){return new vt(0)}static get negativeZero(){return new vt(-0)}static get one(){return new vt(1)}static get negativeOne(){return new vt(-1)}static get nan(){return new vt(NaN)}static uint32(e){return new vt(e,vt.Uint32Flag)}static uint64(e){return new vt(e,vt.Uint64Flag)}static from(e){return 0===e?1/e==-1/0?vt.negativeZero:vt.zero:1===e?vt.one:-1===e?vt.negativeOne:isNaN(e)?vt.nan:vt.cache.put(new vt(e))}static fromAny(e){if(e instanceof vt)return e;if("number"==typeof e)return vt.from(e);throw new TypeError(""+e)}static parse(e){if("NaN"===e)return vt.nan;{const t=+e;if(isFinite(t))return vt.from(t)}throw new Error(e)}static get cache(){return new R(128)}}vt.Uint32Flag=1,vt.Uint64Flag=2,vt.TypeMask=3,e([n],vt,"zero",null),e([n],vt,"negativeZero",null),e([n],vt,"one",null),e([n],vt,"negativeOne",null),e([n],vt,"nan",null),e([n],vt,"cache",null);const xt=function(e){const t=function(e,r){const i=function(e){const t=i[0].value,r=i[1].value;return vt.from(t+e*(r-t))};return Object.setPrototypeOf(i,t.prototype),i[0]=e,i[1]=r,i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t}(x);class Ot extends ht{constructor(e){super(),Object.defineProperty(this,"value",{value:e,enumerable:!0}),Object.defineProperty(this,"hashValue",{value:u.hash(e?"true":"false")})}isDefinite(){return this.value}isConstant(){return!0}stringValue(e){return this.value?"true":"false"}booleanValue(e){return this.value}toAny(){return this.value}valueOf(){return this.value}conditional(e,t){return this.value?tt.fromAny(e):tt.fromAny(t)}or(e){return this.value?this:tt.fromAny(e)}and(e){return this.value?tt.fromAny(e):this}not(){return Ot.from(!this.value)}get typeOrder(){return 7}compareTo(e){return e instanceof Ot?this.value&&!e.value?-1:!this.value&&e.value?1:0:e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e){return this.equals(e)}equals(e){return this===e||e instanceof Ot&&this.value===e.value}hashCode(){return this.hashValue}debug(e){return e=e.write("Bool").write(46).write("from").write(40).write(this.value?"true":"false").write(41)}display(e){return e=e.write(this.value?"true":"false")}static get true(){return new Ot(!0)}static get false(){return new Ot(!1)}static from(e){return e?Ot.true:Ot.false}static fromAny(e){if(e instanceof Ot)return e;if("boolean"==typeof e)return Ot.from(e);throw new TypeError(""+e)}}e([n],Ot,"true",null),e([n],Ot,"false",null);class Et extends ht{constructor(){super()}isDefined(){return!0}isDistinct(){return!1}isDefinite(){return!1}isConstant(){return!0}unflattened(){return lt.empty()}not(){return ht.absent()}stringValue(e){return""}booleanValue(e){return!0}toAny(){return null}interpolateTo(e){return super.interpolateTo(e)}get typeOrder(){return 98}compareTo(e){return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e){return this===e}equals(e){return this===e}hashCode(){return l.hash(Et)}debug(e){return e=e.write("Value").write(46).write("extant").write(40).write(41)}display(e){return e=e.write("null")}static extant(){return new Et}static fromAny(e){if(e instanceof Et)return e;if(null===e)return Et.extant();throw new TypeError(""+e)}}e([n],Et,"extant",null);class Ct extends ht{constructor(){super()}isDefined(){return!1}isDistinct(){return!1}isDefinite(){return!1}isConstant(){return!0}unflattened(){return lt.empty()}updated(e,t){return lt.of(nt.of(e,t))}updatedAttr(e,t){return lt.of(ot.of(e,t))}updatedSlot(e,t){return lt.of(nt.of(e,t))}appended(...e){return lt.of(e)}prepended(...e){return lt.of(e)}concat(...e){const t=lt.create();for(let r=0,i=e.length;r<i;r+=1)tt.fromAny(e[r]).forEach((function(e){t.push(e)}));return t}conditional(e,t){return tt.fromAny(t)}or(e){return tt.fromAny(e)}and(e){return this}not(){return ht.extant()}booleanValue(e){return!1}toAny(){}forEach(e,t){}iterator(){return j.empty()}interpolateTo(e){return super.interpolateTo(e)}get typeOrder(){return 99}compareTo(e){return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e){return this===e}equals(e){return this===e}hashCode(){return l.hash(Ct)}debug(e){return e=e.write("Value").write(46).write("absent").write(40).write(41)}display(e){return e=e.write("undefined")}static absent(){return new Ct}static fromAny(e){if(e instanceof Ct)return e;if(void 0===e)return Ct.absent();throw new TypeError(""+e)}}e([n],Ct,"absent",null);class At extends ht{constructor(){super()}conditional(e,t){return e=tt.fromAny(e),t=tt.fromAny(t),new qt(this,e,t)}or(e){return e=tt.fromAny(e),new Mt(this,e)}and(e){return e=tt.fromAny(e),new jt(this,e)}bitwiseOr(e){return e=tt.fromAny(e),new Lt(this,e)}bitwiseXor(e){return e=tt.fromAny(e),new Ft(this,e)}bitwiseAnd(e){return e=tt.fromAny(e),new Bt(this,e)}lt(e){return e=tt.fromAny(e),new Ut(this,e)}le(e){return e=tt.fromAny(e),new Wt(this,e)}eq(e){return e=tt.fromAny(e),new Rt(this,e)}ne(e){return e=tt.fromAny(e),new Ht(this,e)}ge(e){return e=tt.fromAny(e),new Kt(this,e)}gt(e){return e=tt.fromAny(e),new _t(this,e)}plus(e){return e=tt.fromAny(e),new Gt(this,e)}minus(e){return e=tt.fromAny(e),new Qt(this,e)}times(e){return e=tt.fromAny(e),new Zt(this,e)}divide(e){return e=tt.fromAny(e),new Xt(this,e)}modulo(e){return e=tt.fromAny(e),new $t(this,e)}not(){return new Yt(this)}bitwiseNot(){return new Jt(this)}negative(){return new er(this)}positive(){return new tr(this)}inverse(){return new Xt(vt.one,this)}toAny(){return this}}class St extends At{constructor(){super()}static binary(e,t,r){switch(t){case"||":return new Mt(e,r);case"&&":return new jt(e,r);case"|":return new Lt(e,r);case"^":return new Ft(e,r);case"&":return new Bt(e,r);case"<":return new Ut(e,r);case"<=":return new Wt(e,r);case"==":return new Rt(e,r);case"!=":return new Ht(e,r);case">=":return new Kt(e,r);case">":return new _t(e,r);case"+":return new Gt(e,r);case"-":return new Qt(e,r);case"*":return new Zt(e,r);case"/":return new Xt(e,r);case"%":return new $t(e,r);default:throw new Error(t)}}static unary(e,t){switch(e){case"!":return new Yt(t);case"~":return new Jt(t);case"-":return new er(t);case"+":return new tr(t);default:throw new Error(e)}}}class kt extends St{constructor(e,t){super(),this.operand1=e,this.operand2=t}isConstant(){return this.operand1.isConstant()&&this.operand2.isConstant()}interpolateTo(e){return e instanceof kt&&this.operator===e.operator?Tt(this,e):super.interpolateTo(e)}}const Tt=function(e){const t=function(e,r){const i=e.operator;if(i!==r.operator)throw new Error;const n=function(e){const t=n.operand1Interpolator(e),r=n.operand2Interpolator(e);return St.binary(t,n.operator,r)};return Object.setPrototypeOf(n,t.prototype),n.operand1Interpolator=e.operand1.interpolateTo(r.operand1),n.operator=i,n.operand2Interpolator=e.operand2.interpolateTo(r.operand2),n};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,Object.defineProperty(t.prototype,0,{get(){const e=this.operand1Interpolator[0],t=this.operand2Interpolator[0];return St.binary(e,this.operator,t)},configurable:!0}),Object.defineProperty(t.prototype,1,{get(){const e=this.operand1Interpolator[1],t=this.operand2Interpolator[1];return St.binary(e,this.operator,t)},configurable:!0}),t.prototype.equals=function(e){return this===e||e instanceof t&&(this.operator===e.operator&&this.operand1Interpolator.equals(e.operand1Interpolator)&&this.operand2Interpolator.equals(e.operand2Interpolator))},t}(x);class Pt extends St{constructor(e){super(),this.operand=e}isConstant(){return this.operand.isConstant()}interpolateTo(e){return e instanceof Pt&&this.operator===e.operator?Dt(this,e):super.interpolateTo(e)}}const Dt=function(e){const t=function(e,r){const i=e.operator;if(i!==r.operator)throw new Error;const n=function(e){const t=n.operandInterpolator(e);return St.unary(n.operator,t)};return Object.setPrototypeOf(n,t.prototype),n.operator=i,n.operandInterpolator=e.operand.interpolateTo(r.operand),n};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,Object.defineProperty(t.prototype,0,{get(){const e=this.operandInterpolator[0];return St.unary(this.operator,e)},configurable:!0}),Object.defineProperty(t.prototype,1,{get(){const e=this.operandInterpolator[1];return St.unary(this.operator,e)},configurable:!0}),t.prototype.equals=function(e){return this===e||e instanceof t&&(this.operator===e.operator&&this.operandInterpolator.equals(e.operandInterpolator))},t}(x);class qt extends St{constructor(e,t,r){super(),this.ifTerm=e.commit(),this.thenTerm=t.commit(),this.elseTerm=r.commit()}isConstant(){return this.ifTerm.isConstant()&&this.thenTerm.isConstant()&&this.elseTerm.isConstant()}get precedence(){return 2}evaluate(e){let t;(e=zt.fromAny(e)).willOperate(this);if(this.ifTerm.evaluate(e).isDefinite()){t=this.thenTerm.evaluate(e)}else{t=this.elseTerm.evaluate(e)}return e.didOperate(this,t),t}substitute(e){e=zt.fromAny(e);const t=this.ifTerm.substitute(e),r=this.thenTerm.substitute(e),i=this.elseTerm.substitute(e);return new qt(t,r,i)}interpolateTo(e){return e instanceof qt?It(this,e):super.interpolateTo(e)}get typeOrder(){return 20}compareTo(e){if(e instanceof qt){let t=this.ifTerm.compareTo(e.ifTerm);return 0===t&&(t=this.thenTerm.compareTo(e.thenTerm),0===t&&(t=this.elseTerm.compareTo(e.elseTerm))),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof qt&&(this.ifTerm.equivalentTo(e.ifTerm,t)&&this.thenTerm.equivalentTo(e.thenTerm,t)&&this.elseTerm.equivalentTo(e.elseTerm,t))}equals(e){return this===e||e instanceof qt&&(this.ifTerm.equals(e.ifTerm)&&this.thenTerm.equals(e.thenTerm)&&this.elseTerm.equals(e.elseTerm))}hashCode(){return i.mash(i.mix(i.mix(i.mix(l.hash(qt),this.ifTerm.hashCode()),this.thenTerm.hashCode()),this.elseTerm.hashCode()))}debug(e){return e=e.debug(this.ifTerm).write(46).write("conditional").write(40).debug(this.thenTerm).write(44).write(32).debug(this.elseTerm).write(41)}clone(){return new qt(this.ifTerm.clone(),this.thenTerm.clone(),this.elseTerm.clone())}}const It=function(e){const t=function(e,r){const i=function(e){const t=i.ifTermInterpolator(e),r=i.thenTermInterpolator(e),n=i.elseTermInterpolator(e);return new qt(t,r,n)};return Object.setPrototypeOf(i,t.prototype),i.ifTermInterpolator=e.ifTerm.interpolateTo(r.ifTerm),i.thenTermInterpolator=e.thenTerm.interpolateTo(r.thenTerm),i.elseTermInterpolator=e.elseTerm.interpolateTo(r.elseTerm),i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,Object.defineProperty(t.prototype,0,{get(){const e=this.ifTermInterpolator[0],t=this.thenTermInterpolator[0],r=this.elseTermInterpolator[0];return new qt(e,t,r)},configurable:!0}),Object.defineProperty(t.prototype,1,{get(){const e=this.ifTermInterpolator[1],t=this.thenTermInterpolator[1],r=this.elseTermInterpolator[1];return new qt(e,t,r)},configurable:!0}),t.prototype.equals=function(e){return this===e||e instanceof t&&(this.ifTermInterpolator.equals(e.ifTermInterpolator)&&this.thenTermInterpolator.equals(e.thenTermInterpolator)&&this.elseTermInterpolator.equals(e.elseTermInterpolator))},t}(x);class Vt extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Vt.prototype)}}class Nt{constructor(e){Object.defineProperty(this,"maxScopeDepth",{value:e,enumerable:!0})}withMaxScopeDepth(e){return this.copy(e)}copy(e){return new Nt(e)}canEqual(e){return e instanceof Nt}equals(e){return this===e||e instanceof Nt&&(e.canEqual(this)&&this.maxScopeDepth===e.maxScopeDepth)}hashCode(){return i.mash(i.mix(l.hash(Nt),a.hash(this.maxScopeDepth)))}debug(e){return e=e.write("new").write(32).write("InterpreterSettings").write(40).debug(this.maxScopeDepth).write(41)}toString(){return he.debug(this)}static standard(){return new Nt(1024)}}e([n],Nt,"standard",null);class zt{constructor(e,t,r){this.settings=void 0!==e?e:Nt.standard(),this.scopeStack=void 0!==t?t:null,this.scopeDepth=void 0!==r?r:0}withSettings(e){return this.settings=e,this}peekScope(){const e=this.scopeDepth;if(e<=0)throw new Vt("scope stack empty");return this.scopeStack[e-1]}getScope(e){if(e<0||e>=this.scopeDepth)throw new RangeError(""+e);return this.scopeStack[e]}pushScope(e){const t=this.scopeDepth;if(t>=this.settings.maxScopeDepth)throw new Vt("scope stack overflow");const r=this.scopeStack;let i;if(null===r||t+1>r.length){if(i=new Array(zt.expand(t+1)),null!==r)for(let e=0;e<t;e+=1)i[e]=r[e];this.scopeStack=i}else i=r;i[t]=e,this.scopeDepth+=1}popScope(){const e=this.scopeDepth;if(e<=0)throw new Vt("scope stack empty");const t=this.scopeStack,r=t[e-1];return t[e-1]=void 0,this.scopeDepth-=1,r}swapScope(e){const t=this.scopeDepth;if(t<=0)throw new Vt("scope stack empty");const r=this.scopeStack,i=r[t-1];return r[t-1]=e,i}willOperate(e){}didOperate(e,t){}willSelect(e){}didSelect(e,t){}willTransform(e){}didTransform(e,t){}static of(...e){const t=e.length,r=new Array(zt.expand(t));for(let i=0;i<t;i+=1){const t=tt.fromAny(e[i]);r[i]=t}return new zt(Nt.standard(),r,t)}static fromAny(e,t=tt.globalScope()){if(!(e instanceof zt)){const r=e;e=new zt,void 0!==t&&e.pushScope(t),void 0!==r&&e.pushScope(tt.fromAny(r))}return e}static expand(e){return e=Math.max(32,e)-1,e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,(e|=e>>16)+1}}class Mt extends kt{constructor(e,t){super(e,t)}get operator(){return"||"}get precedence(){return 3}evaluate(e){let t;(e=zt.fromAny(e)).willOperate(this);const r=this.operand1.evaluate(e);if(r.isDefinite())t=r;else{t=this.operand2.evaluate(e)}return e.didOperate(this,t),t}substitute(e){e=zt.fromAny(e);const t=this.operand1.substitute(e),r=this.operand2.substitute(e);return t.or(r)}get typeOrder(){return 21}compareTo(e){if(e instanceof Mt){let t=this.operand1.compareTo(e.operand1);return 0===t&&(t=this.operand2.compareTo(e.operand2)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof Mt&&(this.operand1.equivalentTo(e.operand1,t)&&this.operand2.equivalentTo(e.operand2,t))}equals(e){return this===e||e instanceof Mt&&(this.operand1.equals(e.operand1)&&this.operand2.equals(e.operand2))}hashCode(){return i.mash(i.mix(i.mix(l.hash(Mt),this.operand1.hashCode()),this.operand2.hashCode()))}debug(e){return e=e.debug(this.operand1).write(46).write("or").write(40).debug(this.operand2).write(41)}clone(){return new Mt(this.operand1.clone(),this.operand2.clone())}}class jt extends kt{constructor(e,t){super(e,t)}get operator(){return"&&"}get precedence(){return 4}evaluate(e){let t;(e=zt.fromAny(e)).willOperate(this);const r=this.operand1.evaluate(e);if(r.isDefinite()){t=this.operand2.evaluate(e)}else t=r;return e.didOperate(this,t),t}substitute(e){e=zt.fromAny(e);const t=this.operand1.substitute(e),r=this.operand2.substitute(e);return t.and(r)}get typeOrder(){return 22}compareTo(e){if(e instanceof jt){let t=this.operand1.compareTo(e.operand1);return 0===t&&(t=this.operand2.compareTo(e.operand2)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof jt&&(this.operand1.equivalentTo(e.operand1,t)&&this.operand2.equivalentTo(e.operand2,t))}equals(e){return this===e||e instanceof jt&&(this.operand1.equals(e.operand1)&&this.operand2.equals(e.operand2))}hashCode(){return i.mash(i.mix(i.mix(l.hash(jt),this.operand1.hashCode()),this.operand2.hashCode()))}debug(e){return e=e.debug(this.operand1).write(46).write("and").write(40).debug(this.operand2).write(41)}clone(){return new jt(this.operand1.clone(),this.operand2.clone())}}class Lt extends kt{constructor(e,t){super(e,t)}get operator(){return"|"}get precedence(){return 5}evaluate(e){(e=zt.fromAny(e)).willOperate(this);const t=this.operand1.evaluate(e),r=this.operand2.evaluate(e),i=t.bitwiseOr(r);return e.didOperate(this,i),i}substitute(e){e=zt.fromAny(e);const t=this.operand1.substitute(e),r=this.operand2.substitute(e);return t.bitwiseOr(r)}get typeOrder(){return 23}compareTo(e){if(e instanceof Lt){let t=this.operand1.compareTo(e.operand1);return 0===t&&(t=this.operand2.compareTo(e.operand2)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof Lt&&(this.operand1.equivalentTo(e.operand1,t)&&this.operand2.equivalentTo(e.operand2,t))}equals(e){return this===e||e instanceof Lt&&(this.operand1.equals(e.operand1)&&this.operand2.equals(e.operand2))}hashCode(){return i.mash(i.mix(i.mix(l.hash(Lt),this.operand1.hashCode()),this.operand2.hashCode()))}debug(e){return e=e.debug(this.operand1).write(46).write("bitwiseOr").write(40).debug(this.operand2).write(41)}clone(){return new Lt(this.operand1.clone(),this.operand2.clone())}}class Ft extends kt{constructor(e,t){super(e,t)}get operator(){return"^"}get precedence(){return 6}evaluate(e){(e=zt.fromAny(e)).willOperate(this);const t=this.operand1.evaluate(e),r=this.operand2.evaluate(e),i=t.bitwiseXor(r);return e.didOperate(this,i),i}substitute(e){e=zt.fromAny(e);const t=this.operand1.substitute(e),r=this.operand2.substitute(e);return t.bitwiseXor(r)}get typeOrder(){return 24}compareTo(e){if(e instanceof Ft){let t=this.operand1.compareTo(e.operand1);return 0===t&&(t=this.operand2.compareTo(e.operand2)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof Ft&&(this.operand1.equivalentTo(e.operand1,t)&&this.operand2.equivalentTo(e.operand2,t))}equals(e){return this===e||e instanceof Ft&&(this.operand1.equals(e.operand1)&&this.operand2.equals(e.operand2))}hashCode(){return i.mash(i.mix(i.mix(l.hash(Ft),this.operand1.hashCode()),this.operand2.hashCode()))}debug(e){return e=e.debug(this.operand1).write(46).write("bitwiseXor").write(40).debug(this.operand2).write(41)}clone(){return new Ft(this.operand1.clone(),this.operand2.clone())}}class Bt extends kt{constructor(e,t){super(e,t)}get operator(){return"&"}get precedence(){return 7}evaluate(e){(e=zt.fromAny(e)).willOperate(this);const t=this.operand1.evaluate(e),r=this.operand2.evaluate(e),i=t.bitwiseAnd(r);return e.didOperate(this,i),i}substitute(e){e=zt.fromAny(e);const t=this.operand1.substitute(e),r=this.operand2.substitute(e);return t.bitwiseAnd(r)}get typeOrder(){return 25}compareTo(e){if(e instanceof Bt){let t=this.operand1.compareTo(e.operand1);return 0===t&&(t=this.operand2.compareTo(e.operand2)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof Bt&&(this.operand1.equivalentTo(e.operand1,t)&&this.operand2.equivalentTo(e.operand2,t))}equals(e){return this===e||e instanceof Bt&&(this.operand1.equals(e.operand1)&&this.operand2.equals(e.operand2))}hashCode(){return i.mash(i.mix(i.mix(l.hash(Bt),this.operand1.hashCode()),this.operand2.hashCode()))}debug(e){return e=e.debug(this.operand1).write(46).write("bitwiseAnd").write(40).debug(this.operand2).write(41)}clone(){return new Bt(this.operand1.clone(),this.operand2.clone())}}class Ut extends kt{constructor(e,t){super(e,t)}get operator(){return"<"}get precedence(){return 0}evaluate(e){(e=zt.fromAny(e)).willOperate(this);const t=this.operand1.evaluate(e),r=this.operand2.evaluate(e),i=t.lt(r);return e.didOperate(this,i),i}substitute(e){e=zt.fromAny(e);const t=this.operand1.substitute(e),r=this.operand2.substitute(e);return t.lt(r)}get typeOrder(){return 26}compareTo(e){if(e instanceof Ut){let t=this.operand1.compareTo(e.operand1);return 0===t&&(t=this.operand2.compareTo(e.operand2)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof Ut&&(this.operand1.equivalentTo(e.operand1,t)&&this.operand2.equivalentTo(e.operand2,t))}equals(e){return this===e||e instanceof Ut&&(this.operand1.equals(e.operand1)&&this.operand2.equals(e.operand2))}hashCode(){return i.mash(i.mix(i.mix(l.hash(Ut),this.operand1.hashCode()),this.operand2.hashCode()))}debug(e){return e.debug(this.operand1).write(46).write("lt").write(40).debug(this.operand2).write(41)}clone(){return new Ut(this.operand1.clone(),this.operand2.clone())}}class Wt extends kt{constructor(e,t){super(e,t)}get operator(){return"<="}get precedence(){return 0}evaluate(e){(e=zt.fromAny(e)).willOperate(this);const t=this.operand1.evaluate(e),r=this.operand2.evaluate(e),i=t.le(r);return e.didOperate(this,i),i}substitute(e){e=zt.fromAny(e);const t=this.operand1.substitute(e),r=this.operand2.substitute(e);return t.le(r)}get typeOrder(){return 27}compareTo(e){if(e instanceof Wt){let t=this.operand1.compareTo(e.operand1);return 0===t&&(t=this.operand2.compareTo(e.operand2)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof Wt&&(this.operand1.equivalentTo(e.operand1,t)&&this.operand2.equivalentTo(e.operand2,t))}equals(e){return this===e||e instanceof Wt&&(this.operand1.equals(e.operand1)&&this.operand2.equals(e.operand2))}hashCode(){return i.mash(i.mix(i.mix(l.hash(Wt),this.operand1.hashCode()),this.operand2.hashCode()))}debug(e){return e.debug(this.operand1).write(46).write("le").write(40).debug(this.operand2).write(41)}clone(){return new Wt(this.operand1.clone(),this.operand2.clone())}}class Rt extends kt{constructor(e,t){super(e,t)}get operator(){return"=="}get precedence(){return 0}evaluate(e){(e=zt.fromAny(e)).willOperate(this);const t=this.operand1.evaluate(e),r=this.operand2.evaluate(e),i=t.eq(r);return e.didOperate(this,i),i}substitute(e){e=zt.fromAny(e);const t=this.operand1.substitute(e),r=this.operand2.substitute(e);return t.eq(r)}get typeOrder(){return 28}compareTo(e){if(e instanceof Rt){let t=this.operand1.compareTo(e.operand1);return 0===t&&(t=this.operand2.compareTo(e.operand2)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof Rt&&(this.operand1.equivalentTo(e.operand1,t)&&this.operand2.equivalentTo(e.operand2,t))}equals(e){return this===e||e instanceof Rt&&(this.operand1.equals(e.operand1)&&this.operand2.equals(e.operand2))}hashCode(){return i.mash(i.mix(i.mix(l.hash(Rt),this.operand1.hashCode()),this.operand2.hashCode()))}debug(e){return e=e.debug(this.operand1).write(46).write("eq").write(40).debug(this.operand2).write(41)}clone(){return new Rt(this.operand1.clone(),this.operand2.clone())}}class Ht extends kt{constructor(e,t){super(e,t)}get operator(){return"!="}get precedence(){return 0}evaluate(e){(e=zt.fromAny(e)).willOperate(this);const t=this.operand1.evaluate(e),r=this.operand2.evaluate(e),i=t.ne(r);return e.didOperate(this,i),i}substitute(e){e=zt.fromAny(e);const t=this.operand1.substitute(e),r=this.operand2.substitute(e);return t.ne(r)}get typeOrder(){return 29}compareTo(e){if(e instanceof Ht){let t=this.operand1.compareTo(e.operand1);return 0===t&&(t=this.operand2.compareTo(e.operand2)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof Ht&&(this.operand1.equivalentTo(e.operand1,t)&&this.operand2.equivalentTo(e.operand2,t))}equals(e){return this===e||e instanceof Ht&&(this.operand1.equals(e.operand1)&&this.operand2.equals(e.operand2))}hashCode(){return i.mash(i.mix(i.mix(l.hash(Ht),this.operand1.hashCode()),this.operand2.hashCode()))}debug(e){return e=e.debug(this.operand1).write(46).write("ne").write(40).debug(this.operand2).write(41)}clone(){return new Ht(this.operand1.clone(),this.operand2.clone())}}class Kt extends kt{constructor(e,t){super(e,t)}get operator(){return">="}get precedence(){return 0}evaluate(e){(e=zt.fromAny(e)).willOperate(this);const t=this.operand1.evaluate(e),r=this.operand2.evaluate(e),i=t.ge(r);return e.didOperate(this,i),i}substitute(e){e=zt.fromAny(e);const t=this.operand1.substitute(e),r=this.operand2.substitute(e);return t.ge(r)}get typeOrder(){return 30}compareTo(e){if(e instanceof Kt){let t=this.operand1.compareTo(e.operand1);return 0===t&&(t=this.operand2.compareTo(e.operand2)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof Kt&&(this.operand1.equivalentTo(e.operand1,t)&&this.operand2.equivalentTo(e.operand2,t))}equals(e){return this===e||e instanceof Kt&&(this.operand1.equals(e.operand1)&&this.operand2.equals(e.operand2))}hashCode(){return i.mash(i.mix(i.mix(l.hash(Kt),this.operand1.hashCode()),this.operand2.hashCode()))}debug(e){return e=e.debug(this.operand1).write(46).write("ge").write(40).debug(this.operand2).write(41)}clone(){return new Kt(this.operand1.clone(),this.operand2.clone())}}class _t extends kt{constructor(e,t){super(e,t)}get operator(){return">"}get precedence(){return 0}evaluate(e){(e=zt.fromAny(e)).willOperate(this);const t=this.operand1.evaluate(e),r=this.operand2.evaluate(e),i=t.gt(r);return e.didOperate(this,i),i}substitute(e){e=zt.fromAny(e);const t=this.operand1.substitute(e),r=this.operand2.substitute(e);return t.gt(r)}get typeOrder(){return 31}compareTo(e){if(e instanceof _t){let t=this.operand1.compareTo(e.operand1);return 0===t&&(t=this.operand2.compareTo(e.operand2)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof _t&&(this.operand1.equivalentTo(e.operand1,t)&&this.operand2.equivalentTo(e.operand2,t))}equals(e){return this===e||e instanceof _t&&(this.operand1.equals(e.operand1)&&this.operand2.equals(e.operand2))}hashCode(){return i.mash(i.mix(i.mix(l.hash(_t),this.operand1.hashCode()),this.operand2.hashCode()))}debug(e){return e=e.debug(this.operand1).write(46).write("gt").write(40).debug(this.operand2).write(41)}clone(){return new _t(this.operand1.clone(),this.operand2.clone())}}class Gt extends kt{constructor(e,t){super(e,t)}get operator(){return"+"}get precedence(){return 8}evaluate(e){(e=zt.fromAny(e)).willOperate(this);const t=this.operand1.evaluate(e),r=this.operand2.evaluate(e),i=t.plus(r);return e.didOperate(this,i),i}substitute(e){e=zt.fromAny(e);const t=this.operand1.substitute(e),r=this.operand2.substitute(e);return t.plus(r)}get typeOrder(){return 32}compareTo(e){if(e instanceof Gt){let t=this.operand1.compareTo(e.operand1);return 0===t&&(t=this.operand2.compareTo(e.operand2)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof Gt&&(this.operand1.equivalentTo(e.operand1,t)&&this.operand2.equivalentTo(e.operand2,t))}equals(e){return this===e||e instanceof Gt&&(this.operand1.equals(e.operand1)&&this.operand2.equals(e.operand2))}hashCode(){return i.mash(i.mix(i.mix(l.hash(Gt),this.operand1.hashCode()),this.operand2.hashCode()))}debug(e){return e=e.debug(this.operand1).write(46).write("plus").write(40).debug(this.operand2).write(41)}clone(){return new Gt(this.operand1.clone(),this.operand2.clone())}}class Qt extends kt{constructor(e,t){super(e,t)}get operator(){return"-"}get precedence(){return 8}evaluate(e){(e=zt.fromAny(e)).willOperate(this);const t=this.operand1.evaluate(e),r=this.operand2.evaluate(e),i=t.minus(r);return e.didOperate(this,i),i}substitute(e){e=zt.fromAny(e);const t=this.operand1.substitute(e),r=this.operand2.substitute(e);return t.minus(r)}get typeOrder(){return 33}compareTo(e){if(e instanceof Qt){let t=this.operand1.compareTo(e.operand1);return 0===t&&(t=this.operand2.compareTo(e.operand2)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof Qt&&(this.operand1.equivalentTo(e.operand1,t)&&this.operand2.equivalentTo(e.operand2,t))}equals(e){return this===e||e instanceof Qt&&(this.operand1.equals(e.operand1)&&this.operand2.equals(e.operand2))}hashCode(){return i.mash(i.mix(i.mix(l.hash(Qt),this.operand1.hashCode()),this.operand2.hashCode()))}debug(e){return e=e.debug(this.operand1).write(46).write("minus").write(40).debug(this.operand2).write(41)}clone(){return new Qt(this.operand1.clone(),this.operand2.clone())}}class Zt extends kt{constructor(e,t){super(e,t)}get operator(){return"*"}get precedence(){return 9}evaluate(e){(e=zt.fromAny(e)).willOperate(this);const t=this.operand1.evaluate(e),r=this.operand2.evaluate(e),i=t.times(r);return e.didOperate(this,i),i}substitute(e){e=zt.fromAny(e);const t=this.operand1.substitute(e),r=this.operand2.substitute(e);return t.times(r)}get typeOrder(){return 34}compareTo(e){if(e instanceof Zt){let t=this.operand1.compareTo(e.operand1);return 0===t&&(t=this.operand2.compareTo(e.operand2)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof Zt&&(this.operand1.equivalentTo(e.operand1,t)&&this.operand2.equivalentTo(e.operand2,t))}equals(e){return this===e||e instanceof Zt&&(this.operand1.equals(e.operand1)&&this.operand2.equals(e.operand2))}hashCode(){return i.mash(i.mix(i.mix(l.hash(Zt),this.operand1.hashCode()),this.operand2.hashCode()))}debug(e){return e=e.debug(this.operand1).write(46).write("times").write(40).debug(this.operand2).write(41)}clone(){return new Zt(this.operand1.clone(),this.operand2.clone())}}class Xt extends kt{constructor(e,t){super(e,t)}get operator(){return"/"}get precedence(){return 9}evaluate(e){(e=zt.fromAny(e)).willOperate(this);const t=this.operand1.evaluate(e),r=this.operand2.evaluate(e),i=t.divide(r);return e.didOperate(this,i),i}substitute(e){e=zt.fromAny(e);const t=this.operand1.substitute(e),r=this.operand2.substitute(e);return t.divide(r)}get typeOrder(){return 35}compareTo(e){if(e instanceof Xt){let t=this.operand1.compareTo(e.operand1);return 0===t&&(t=this.operand2.compareTo(e.operand2)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof Xt&&(this.operand1.equivalentTo(e.operand1,t)&&this.operand2.equivalentTo(e.operand2,t))}equals(e){return this===e||e instanceof Xt&&(this.operand1.equals(e.operand1)&&this.operand2.equals(e.operand2))}hashCode(){return i.mash(i.mix(i.mix(l.hash(Xt),this.operand1.hashCode()),this.operand2.hashCode()))}debug(e){return e=e.debug(this.operand1).write(46).write("divide").write(40).debug(this.operand2).write(41)}clone(){return new Xt(this.operand1.clone(),this.operand2.clone())}}class $t extends kt{constructor(e,t){super(e,t)}get operator(){return"%"}get precedence(){return 9}evaluate(e){(e=zt.fromAny(e)).willOperate(this);const t=this.operand1.evaluate(e),r=this.operand2.evaluate(e),i=t.modulo(r);return e.didOperate(this,i),i}substitute(e){e=zt.fromAny(e);const t=this.operand1.substitute(e),r=this.operand2.substitute(e);return t.modulo(r)}get typeOrder(){return 36}compareTo(e){if(e instanceof $t){let t=this.operand1.compareTo(e.operand1);return 0===t&&(t=this.operand2.compareTo(e.operand2)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof $t&&(this.operand1.equivalentTo(e.operand1,t)&&this.operand2.equivalentTo(e.operand2,t))}equals(e){return this===e||e instanceof $t&&(this.operand1.equals(e.operand1)&&this.operand2.equals(e.operand2))}hashCode(){return i.mash(i.mix(i.mix(l.hash($t),this.operand1.hashCode()),this.operand2.hashCode()))}debug(e){return e=e.debug(this.operand1).write(46).write("modulo").write(40).debug(this.operand2).write(41)}clone(){return new $t(this.operand1.clone(),this.operand2.clone())}}class Yt extends Pt{constructor(e){super(e)}get operator(){return"!"}get precedence(){return 10}evaluate(e){e=zt.fromAny(e);return this.operand.evaluate(e).not()}substitute(e){e=zt.fromAny(e);return this.operand.substitute(e).not()}get typeOrder(){return 37}compareTo(e){return a.compare(this.typeOrder,e.typeOrder)}equivalentTo(e,t){return this===e||e instanceof Yt&&this.operand.equivalentTo(e.operand,t)}equals(e){return this===e||e instanceof Yt&&this.operand.equals(e.operand)}hashCode(){return i.mash(i.mix(l.hash(Yt),this.operand.hashCode()))}debug(e){return e=e.debug(this.operand).write(46).write("not").write(40).write(41)}clone(){return new Yt(this.operand.clone())}}class Jt extends Pt{constructor(e){super(e)}get operator(){return"~"}get precedence(){return 10}evaluate(e){e=zt.fromAny(e);return this.operand.evaluate(e).bitwiseNot()}substitute(e){e=zt.fromAny(e);return this.operand.substitute(e).bitwiseNot()}get typeOrder(){return 38}compareTo(e){return e instanceof Jt?this.operand.compareTo(e.operand):e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof Jt&&this.operand.equivalentTo(e.operand,t)}equals(e){return this===e||e instanceof Jt&&this.operand.equals(e.operand)}hashCode(){return i.mash(i.mix(l.hash(Jt),this.operand.hashCode()))}debug(e){return e=e.debug(this.operand).write(46).write("bitwiseNot").write(40).write(41)}clone(){return new Jt(this.operand.clone())}}class er extends Pt{constructor(e){super(e)}get operator(){return"-"}get precedence(){return 10}evaluate(e){e=zt.fromAny(e);return this.operand.evaluate(e).negative()}substitute(e){e=zt.fromAny(e);return this.operand.substitute(e).negative()}get typeOrder(){return 39}compareTo(e){return e instanceof er?this.operand.compareTo(e.operand):e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof er&&this.operand.equivalentTo(e.operand,t)}equals(e){return this===e||e instanceof er&&this.operand.equals(e.operand)}hashCode(){return i.mash(i.mix(l.hash(er),this.operand.hashCode()))}debug(e){return e=e.debug(this.operand).write(46).write("negative").write(40).write(41)}clone(){return new er(this.operand.clone())}}class tr extends Pt{constructor(e){super(e)}get operator(){return"+"}get precedence(){return 10}evaluate(e){e=zt.fromAny(e);return this.operand.evaluate(e).positive()}substitute(e){e=zt.fromAny(e);return this.operand.substitute(e).positive()}get typeOrder(){return 40}compareTo(e){return e instanceof tr?this.operand.compareTo(e.operand):e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof tr&&this.operand.equivalentTo(e.operand,t)}equals(e){return this===e||e instanceof tr&&this.operand.equals(e.operand)}hashCode(){return i.mash(i.mix(l.hash(tr),this.operand.hashCode()))}debug(e){return e=e.debug(this.operand).write(46).write("positive").write(40).write(41)}clone(){return new tr(this.operand.clone())}}class rr extends St{constructor(e,t){super(),this.func=e,this.args=t.commit(),this.state=void 0}setState(e){this.state=e}isConstant(){return this.func.isConstant()&&this.args.isConstant()}get precedence(){return 11}evaluate(e){e=zt.fromAny(e);const t=this.func.evaluate(e);return t instanceof wr?t.invoke(this.args,e,this):tt.absent()}substitute(e){e=zt.fromAny(e);const t=this.func.evaluate(e);if(t instanceof wr){const r=t.expand(this.args,e,this);if(void 0!==r)return r}const r=this.args.substitute(e).toValue();return new rr(this.func,r)}interpolateTo(e){return e instanceof rr?ir(this,e):super.interpolateTo(e)}get typeOrder(){return 41}compareTo(e){if(e instanceof rr){let t=this.func.compareTo(e.func);return 0===t&&(t=this.args.compareTo(e.args)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof rr&&(this.func.equals(e.func)&&this.args.equivalentTo(e.args,t))}equals(e){return this===e||e instanceof rr&&(this.func.equals(e.func)&&this.args.equals(e.args))}hashCode(){return i.mash(i.mix(i.mix(l.hash(rr),this.func.hashCode()),this.args.hashCode()))}debug(e){return e=e.debug(this.func).write(46).write("invoke").write(40).debug(this.args).write(41)}clone(){return new rr(this.func.clone(),this.args.clone())}}const ir=function(e){const t=function(e,r){const i=function(e){const t=i.funcInterpolator(e),r=i.argsInterpolator(e);return new rr(t,r)};return Object.setPrototypeOf(i,t.prototype),i.funcInterpolator=e.func.interpolateTo(r.func),i.argsInterpolator=e.args.interpolateTo(r.args),i};return t.prototype=Object.create(e.prototype),t.prototype.constructor=t,Object.defineProperty(t.prototype,0,{get(){const e=this.funcInterpolator[0],t=this.argsInterpolator[0];return new rr(e,t)},configurable:!0}),Object.defineProperty(t.prototype,1,{get(){const e=this.funcInterpolator[1],t=this.argsInterpolator[1];return new rr(e,t)},configurable:!0}),t.prototype.equals=function(e){return this===e||e instanceof t&&(this.funcInterpolator.equals(e.funcInterpolator)&&this.argsInterpolator.equals(e.argsInterpolator))},t}(x);class nr extends At{constructor(){super()}isConstant(){return!1}evaluate(e){e=zt.fromAny(e);const t=lt.create();return this.forSelected(e,(function(e){const r=e.peekScope();void 0!==r&&t.push(r)}),this),t.isEmpty()?tt.absent():t.flattened()}get(e){return e=ht.fromAny(e),this.andThen(new or(e,nr.identity()))}getAttr(e){return e=yt.fromAny(e),this.andThen(new ar(e,nr.identity()))}getItem(e){return e=vt.fromAny(e),this.andThen(new ur(e,nr.identity()))}keys(){return this.andThen(nr.keys())}values(){return this.andThen(nr.values())}children(){return this.andThen(nr.children())}descendants(){return this.andThen(nr.descendants())}filter(e){return 0===arguments.length?new pr(this,nr.identity()):(e=tt.fromAny(e),this.andThen(e.filter()))}invoke(e){return new rr(this,e)}get precedence(){return 11}debug(e){return e=e.write("Selector").write(46).write("identity").write(40).write(41),e=this.debugThen(e)}static identity(){return new sr}static get(e){return e=ht.fromAny(e),new or(e,nr.identity())}static getAttr(e){return e=yt.fromAny(e),new ar(e,nr.identity())}static getItem(e){return e=vt.fromAny(e),new ur(e,nr.identity())}static keys(){return new hr(nr.identity())}static values(){return new lr(nr.identity())}static children(){return new cr(nr.identity())}static descendants(){return new dr(nr.identity())}static literal(e){return(e=tt.fromAny(e))instanceof nr||(e=new fr(e,nr.identity())),e}}e([n],nr,"identity",null),e([n],nr,"keys",null),e([n],nr,"values",null),e([n],nr,"children",null),e([n],nr,"descendants",null);class sr extends nr{get then(){return this}forSelected(e,t,r){let i;if(e.willSelect(this),0!==e.scopeDepth){const n=e.popScope(),s=n.evaluate(e);e.pushScope(s),i=t.call(r,e),e.swapScope(n)}return e.didSelect(this,i),i}mapSelected(e,t,r){return t.call(r,e)}substitute(e){return(e=zt.fromAny(e)).peekScope().substitute(e)}get(e){return e=ht.fromAny(e),new or(e,this)}getAttr(e){return e=yt.fromAny(e),new ar(e,this)}getItem(e){return e=vt.fromAny(e),new ur(e,this)}andThen(e){return e}keys(){return nr.keys()}values(){return nr.values()}children(){return nr.children()}descendants(){return nr.descendants()}filter(e){return 0===arguments.length?new pr(this,this):(e=tt.fromAny(e)).filter()}get typeOrder(){return 10}compareTo(e){return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e){return this===e}equals(e){return this===e}hashCode(){return l.hash(sr)}debugThen(e){return e}clone(){return this}}class or extends nr{constructor(e,t){super(),this.item=e.commit(),this.then=t}forSelected(e,t,r){e.willSelect(this);const i=this.item.evaluate(e).toValue(),n=or.forSelected(i,this.then,e,t,r);return e.didSelect(this,n),n}static forSelected(e,t,r,i,n){let s;if(0!==r.scopeDepth){const o=r.popScope().toValue();let a;o instanceof lt&&(a=o.getField(e),void 0!==a&&(r.pushScope(a.toValue()),s=t.forSelected(r,i,n),r.popScope())),void 0===a&&void 0===s&&or.forSelected(e,t,r,i,n),r.pushScope(o)}return s}mapSelected(e,t,r){let i;e.willTransform(this);const n=this.item.evaluate(e).toValue();if(0!==e.scopeDepth){const s=e.popScope().toValue();if(s instanceof lt){const i=s.getField(n);if(void 0!==i){e.pushScope(i.toValue());const o=this.then.mapSelected(e,t,r);e.popScope(),o instanceof it?n.equals(o.key)?s.set(n,o.toValue()):(s.delete(n),s.push(o)):o.isDefined()?s.set(n,o.toValue()):s.delete(n)}}e.pushScope(s),i=s}else i=tt.absent();return e.didTransform(this,i),i}substitute(e){e=zt.fromAny(e);const t=this.item.evaluate(e).toValue(),r=or.substitute(t,this.then,e);if(void 0!==r)return r;let i=this.then.substitute(e);return i instanceof nr||(i=this.then),new or(this.item,i)}static substitute(e,t,r){let i;if(0!==r.scopeDepth){const n=r.popScope().toValue();let s;n instanceof lt&&(s=n.getField(e),void 0!==s&&(i=s.toValue().substitute(r))),void 0===s&&void 0===i&&or.substitute(e,t,r),r.pushScope(n)}return i}andThen(e){return new or(this.item,this.then.andThen(e))}get typeOrder(){return 12}compareTo(e){if(e instanceof or){let t=this.item.compareTo(e.item);return 0===t&&(t=this.then.compareTo(e.then)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof or&&(this.item.equals(e.item)&&this.then.equivalentTo(e.then,t))}equals(e){return this===e||e instanceof or&&(this.item.equals(e.item)&&this.then.equals(e.then))}hashCode(){return i.mash(i.mix(i.mix(l.hash(or),this.item.hashCode()),this.then.hashCode()))}debugThen(e){return e=e.write(46).write("get").write(40).debug(this.item).write(41),e=this.then.debugThen(e)}clone(){return new or(this.item.clone(),this.then.clone())}}class ar extends nr{constructor(e,t){super(),this.item=e,this.then=t}forSelected(e,t,r){e.willSelect(this);const i=this.item,n=ar.forSelected(i,this.then,e,t);return e.didSelect(this,n),n}static forSelected(e,t,r,i,n){let s;if(0!==r.scopeDepth){const o=r.popScope().toValue();let a;o instanceof lt&&(a=o.getField(e),a instanceof ot&&(r.pushScope(a.toValue()),s=t.forSelected(r,i,n),r.popScope())),void 0===a&&void 0===s&&ar.forSelected(e,t,r,i,n),r.pushScope(o)}return s}mapSelected(e,t,r){let i;e.willTransform(this);const n=this.item;if(0!==e.scopeDepth){const s=e.popScope().toValue();if(s instanceof lt){const i=s.getField(n);if(i instanceof ot){e.pushScope(i.toValue());const o=this.then.mapSelected(e,t,r);e.popScope(),o instanceof it?n.equals(o.key)?s.setAttr(n,o.toValue()):(s.delete(n),s.push(o)):o.isDefined()?s.setAttr(n,o.toValue()):s.delete(n)}}e.pushScope(s),i=s}else i=tt.absent();return e.didTransform(this,i),i}substitute(e){e=zt.fromAny(e);const t=this.item,r=ar.substitute(t,this.then,e);if(void 0!==r)return r;let i=this.then.substitute(e);return i instanceof nr||(i=this.then),new ar(this.item,i)}static substitute(e,t,r){let i;if(0!==r.scopeDepth){const n=r.popScope().toValue();let s;n instanceof lt&&(s=n.getField(e),s instanceof ot&&(i=s.toValue().substitute(r))),void 0===s&&void 0===i&&ar.substitute(e,t,r),r.pushScope(n)}return i}andThen(e){return new ar(this.item,this.then.andThen(e))}get typeOrder(){return 13}compareTo(e){if(e instanceof ar){let t=this.item.compareTo(e.item);return 0===t&&(t=this.then.compareTo(e.then)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof ar&&(this.item.equals(e.item)&&this.then.equivalentTo(e.then,t))}equals(e){return this===e||e instanceof ar&&(this.item.equals(e.item)&&this.then.equals(e.then))}hashCode(){return i.mash(i.mix(i.mix(l.hash(ar),this.item.hashCode()),this.then.hashCode()))}debugThen(e){return e=e.write(46).write("getAttr").write(40).debug(this.item).write(41),e=this.then.debugThen(e)}clone(){return new ar(this.item.clone(),this.then.clone())}}class ur extends nr{constructor(e,t){super(),this.item=e,this.then=t}forSelected(e,t,r){let i;e.willSelect(this);const n=this.item.numberValue();if(0!==e.scopeDepth){const s=e.popScope().toValue();if(s instanceof lt&&n<s.length){const o=s.getItem(n);e.pushScope(o),i=this.then.forSelected(e,t,r),e.popScope()}e.pushScope(s)}return e.didSelect(this,i),i}mapSelected(e,t,r){let i;if(e.willTransform(this),0!==e.scopeDepth){const n=e.popScope().toValue(),s=this.item.numberValue();if(n instanceof lt&&s<n.length){const i=n.getItem(s);e.pushScope(i);const o=this.then.mapSelected(e,t,r);e.popScope(),o.isDefined()?n.setItem(s,o):n.splice(s,1)}e.pushScope(n),i=n}else i=tt.absent();return e.didTransform(this,i),i}substitute(e){e=zt.fromAny(e);const t=this.item.numberValue();if(0!==e.scopeDepth){const r=e.popScope().toValue();let i;if(r instanceof lt&&t<r.length){i=r.getItem(t).substitute(e)}if(e.pushScope(r),void 0!==i)return i}let r=this.then.substitute(e);return r instanceof nr||(r=this.then),new ur(this.item,r)}andThen(e){return new ur(this.item,this.then.andThen(e))}get typeOrder(){return 14}compareTo(e){if(e instanceof ur){let t=this.item.compareTo(e.item);return 0===t&&(t=this.then.compareTo(e.then)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof ur&&(this.item.equals(e.item)&&this.then.equivalentTo(e.then,t))}equals(e){return this===e||e instanceof ur&&(this.item.equals(e.item)&&this.then.equals(e.then))}hashCode(){return i.mash(i.mix(i.mix(l.hash(ur),this.item.hashCode()),this.then.hashCode()))}debugThen(e){return e=e.write(46).write("getItem").write(40).debug(this.item).write(41),e=this.then.debugThen(e)}clone(){return new ur(this.item,this.then.clone())}}class hr extends nr{constructor(e){super(),this.then=e}forSelected(e,t,r){let i;if(e.willSelect(this),0!==e.scopeDepth){const n=e.popScope();if(n instanceof lt){const s=n.iterator();for(;void 0===i&&s.hasNext();){const n=s.next().value;n instanceof it&&(e.pushScope(n.key),i=this.then.forSelected(e,t,r),e.popScope())}}else n instanceof it&&(e.pushScope(n.key),i=this.then.forSelected(e,t,r),e.popScope());e.pushScope(n)}return e.didSelect(this,i),i}mapSelected(e,t,r){let i;if(e.willTransform(this),0!==e.scopeDepth){let n=e.popScope();if(n instanceof lt){const i=n.iterator();for(;i.hasNext();){const s=i.next().value;if(s instanceof it){const o=s.key;e.pushScope(o);const a=this.then.mapSelected(e,t,r).toValue();e.popScope(),a.isDefined()?o!==a&&(n instanceof ot&&a instanceof yt?i.set(ot.of(a,n.toValue())):i.set(nt.of(a,n.toValue()))):i.delete()}}}else if(n instanceof it){const i=n.key;e.pushScope(i);const s=this.then.mapSelected(e,t,r).toValue();e.popScope(),s.isDefined()?i!==s&&(n=n instanceof ot&&s instanceof yt?ot.of(s,n.toValue()):nt.of(s,n.toValue())):n=tt.absent()}e.pushScope(n),i=n}else i=tt.absent();return e.didTransform(this,i),i}substitute(e){e=zt.fromAny(e);let t=this.then.substitute(e);return t instanceof nr||(t=this.then),new hr(t)}andThen(e){return new hr(this.then.andThen(e))}get typeOrder(){return 15}compareTo(e){return e instanceof hr?this.then.compareTo(e.then):e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof hr&&this.then.equivalentTo(e.then,t)}equals(e){return this===e||e instanceof hr&&this.then.equals(e.then)}hashCode(){return i.mash(i.mix(l.hash(hr),this.then.hashCode()))}debugThen(e){return e=e.write(46).write("keys").write(40).write(41),e=this.then.debugThen(e)}clone(){return new hr(this.then.clone())}}class lr extends nr{constructor(e){super(),this.then=e}forSelected(e,t,r){let i;if(e.willSelect(this),0!==e.scopeDepth){const n=e.popScope();if(n instanceof lt){const s=n.iterator();for(;void 0===i&&s.hasNext();){const n=s.next().value;e.pushScope(n.toValue()),i=this.then.forSelected(e,t,r),e.popScope()}}else e.pushScope(n.toValue()),i=this.then.forSelected(e,t,r),e.popScope();e.pushScope(n)}return e.didSelect(this,i),i}mapSelected(e,t,r){let i;if(e.willTransform(this),0!==e.scopeDepth){let n=e.popScope();if(n instanceof lt){const i=n.iterator();for(;i.hasNext();){const n=i.next().value;if(n instanceof it){const s=n.toValue();e.pushScope(s);const o=this.then.mapSelected(e,t,r);e.popScope(),o.isDefined()?o instanceof it?i.set(o):o!==s&&i.set(n.updatedValue(o.toValue())):i.delete()}else{e.pushScope(n.toValue());const s=this.then.mapSelected(e,t,r);e.popScope(),s.isDefined()?n!==s&&i.set(s):i.delete()}}}else if(n instanceof it){const i=n.toValue();e.pushScope(i);const s=this.then.mapSelected(e,t,r);e.popScope(),s.isDefined()?s instanceof it?n=s:s!==i&&(n=n.updatedValue(s.toValue())):n=tt.absent()}else e.pushScope(n),n=this.then.mapSelected(e,t,r),e.popScope();e.pushScope(n),i=n}else i=tt.absent();return e.didTransform(this,i),i}substitute(e){e=zt.fromAny(e);let t=this.then.substitute(e);return t instanceof nr||(t=this.then),new lr(t)}andThen(e){return new lr(this.then.andThen(e))}get typeOrder(){return 16}compareTo(e){return e instanceof lr?this.then.compareTo(e.then):e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof lr&&this.then.equivalentTo(e.then,t)}equals(e){return this===e||e instanceof lr&&this.then.equals(e.then)}hashCode(){return i.mash(i.mix(l.hash(lr),this.then.hashCode()))}debugThen(e){return e=e.write(46).write("values").write(40).write(41),e=this.then.debugThen(e)}clone(){return new lr(this.then.clone())}}class cr extends nr{constructor(e){super(),this.then=e}forSelected(e,t,r){let i;if(e.willSelect(this),0!==e.scopeDepth){const n=e.popScope().toValue();if(n instanceof lt){const s=n.iterator();for(;void 0===i&&s.hasNext();){const n=s.next().value;e.pushScope(n),i=this.then.forSelected(e,t,r),e.popScope()}}e.pushScope(n)}return e.didSelect(this,i),i}mapSelected(e,t,r){let i;if(e.willTransform(this),0!==e.scopeDepth){const r=e.popScope().toValue();if(r instanceof lt){const i=r.iterator();for(;i.hasNext();){const r=i.next().value;e.pushScope(r);const n=this.then.mapSelected(e,t);e.popScope(),n.isDefined()?n!==r&&i.set(n):i.delete()}}e.pushScope(r),i=r}else i=tt.absent();return e.didTransform(this,i),i}substitute(e){e=zt.fromAny(e);let t=this.then.substitute(e);return t instanceof nr||(t=this.then),new cr(t)}andThen(e){return new cr(this.then.andThen(e))}get typeOrder(){return 17}compareTo(e){return e instanceof cr?this.then.compareTo(e.then):e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof cr&&this.then.equivalentTo(e.then,t)}equals(e){return this===e||e instanceof cr&&this.then.equals(e.then)}hashCode(){return i.mash(i.mix(l.hash(cr),this.then.hashCode()))}debugThen(e){return e=e.write(46).write("children").write(40).write(41),e=this.then.debugThen(e)}clone(){return new cr(this.then.clone())}}class dr extends nr{constructor(e){super(),this.then=e}forSelected(e,t,r){let i;if(e.willSelect(this),0!==e.scopeDepth){const n=e.popScope().toValue();if(n instanceof lt){const s=n.iterator();for(;void 0===i&&s.hasNext();){const n=s.next().value;e.pushScope(n),i=this.then.forSelected(e,t,r),void 0===i&&this.forSelected(e,t,r),e.popScope()}}e.pushScope(n)}return e.didSelect(this,i),i}mapSelected(e,t,r){let i;if(e.willTransform(this),0!==e.scopeDepth){const n=e.popScope().toValue();if(n instanceof lt){const i=n.iterator();for(;i.hasNext();){const n=i.next().value;e.pushScope(n);let s=this.then.mapSelected(e,t,r);s.isDefined()&&(s=this.mapSelected(e,t,r)),e.popScope(),s.isDefined()?s!==n&&i.set(s):i.delete()}}e.pushScope(n),i=n}else i=tt.absent();return e.didTransform(this,i),i}substitute(e){e=zt.fromAny(e);let t=this.then.substitute(e);return t instanceof nr||(t=this.then),new dr(t)}andThen(e){return new dr(this.then.andThen(e))}get typeOrder(){return 18}compareTo(e){return e instanceof dr?this.then.compareTo(e.then):e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof dr&&this.then.equivalentTo(e.then,t)}equals(e){return this===e||e instanceof dr&&this.then.equals(e.then)}hashCode(){return i.mash(i.mix(l.hash(dr),this.then.hashCode()))}debugThen(e){return e=e.write(46).write("descendants").write(40).write(41),e=this.then.debugThen(e)}clone(){return new dr(this.then.clone())}}class pr extends nr{constructor(e,t){super(),this.predicate=e,this.then=t}forSelected(e,t,r){let i;return e.willSelect(this),0!==e.scopeDepth&&this.filterSelected(e)&&(i=this.then.forSelected(e,t,r)),e.didSelect(this,i),i}mapSelected(e,t,r){let i;return e.willTransform(this),i=0!==e.scopeDepth?this.filterSelected(e)?this.then.mapSelected(e,t,r):e.peekScope().toValue():tt.absent(),e.didTransform(this,i),i}substitute(e){e=zt.fromAny(e);let t=this.predicate.substitute(e);t instanceof nr||(t=this.predicate);let r=this.then.substitute(e);return r instanceof nr||(r=this.then),new pr(t,r)}filterSelected(e){return void 0!==this.predicate.forSelected(e,this.selected,this)}selected(e){return null}andThen(e){return new pr(this.predicate,this.then.andThen(e))}filter(e){return 0===arguments.length?this:(e=tt.fromAny(e),this.andThen(e.filter()))}get typeOrder(){return 19}compareTo(e){if(e instanceof pr){let t=this.predicate.compareTo(e.predicate);return 0===t&&(t=this.then.compareTo(e.then)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof pr&&(this.predicate.equivalentTo(e.predicate,t)&&this.then.equivalentTo(e.then,t))}equals(e){return this===e||e instanceof pr&&(this.predicate.equals(e.predicate)&&this.then.equals(e.then))}hashCode(){return i.mash(i.mix(i.mix(l.hash(pr),this.predicate.hashCode()),this.then.hashCode()))}debugThen(e){return e=e.write(46).write("filter").write(40).debug(this.predicate).write(41),e=this.then.debugThen(e)}clone(){return new pr(this.predicate.clone(),this.then.clone())}}class fr extends nr{constructor(e,t){super(),this.item=e.commit(),this.then=t}forSelected(e,t,r){let i;if(e.willSelect(this),0!==e.scopeDepth){const n=this.item.evaluate(e);n.isDefined()&&(e.pushScope(n),i=this.then.forSelected(e,t,r),e.popScope())}return e.didSelect(this,i),i}mapSelected(e,t,r){let i;if(e.willTransform(this),0!==e.scopeDepth){let n=this.item.evaluate(e);n.isDefined()&&(e.pushScope(n),n=this.then.mapSelected(e,t,r),e.popScope()),i=n}else i=tt.absent();return e.didTransform(this,i),i}substitute(e){e=zt.fromAny(e);const t=this.item.substitute(e);let r=this.then.substitute(e);return r instanceof nr||(r=this.then),new fr(t,r)}andThen(e){return new fr(this.item,this.then.andThen(e))}get precedence(){return this.item.precedence}get typeOrder(){return 11}compareTo(e){if(e instanceof fr){let t=this.item.compareTo(e.item);return 0===t&&(t=this.then.compareTo(e.then)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof fr&&(this.item.equivalentTo(e.item,t)&&this.then.equivalentTo(e.then,t))}equals(e){return this===e||e instanceof fr&&(this.item.equals(e.item)&&this.then.equals(e.then))}hashCode(){return i.mash(i.mix(i.mix(l.hash(fr),this.item.hashCode()),this.then.hashCode()))}debug(e){return e=e.write("Selector").write(46).write("literal").write(40).debug(this.item).write(41),e=this.then.debugThen(e)}debugThen(e){return e}clone(){return new fr(this.item.clone(),this.then.clone())}}class wr extends At{constructor(){super()}isConstant(){return!1}expand(e,t,r){}}class mr extends wr{constructor(e,t){super(),this.bindings=e,this.template=t}get precedence(){return 1}invoke(e,t,r){t=zt.fromAny(t);const i=this.bindings,n=Math.max(1,i.length),s=lt.create(n);let o=0,a=0;for(;o<n;){const t=i instanceof lt?i.getItem(o):0===o?i:tt.absent(),r=e instanceof lt?e.getItem(a).toValue():0===a?e:ht.absent();t instanceof yt&&r.isDistinct()?(s.push(nt.of(t,r)),a+=1):t instanceof nt&&(r.isDistinct()?s.push(t.updatedValue(r)):s.push(t),a+=1),o+=1}t.pushScope(s);const u=this.template.evaluate(t);return t.popScope(),u}get typeOrder(){return 50}compareTo(e){if(e instanceof mr){let t=this.bindings.compareTo(e.bindings);return 0===t&&(t=this.template.compareTo(e.template)),t}return e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e,t){return this===e||e instanceof mr&&(this.bindings.equivalentTo(e.bindings,t)&&this.template.equivalentTo(e.template,t))}equals(e){return this===e||e instanceof mr&&(this.bindings.equals(e.bindings)&&this.template.equals(e.template))}hashCode(){return i.mash(i.mix(i.mix(l.hash(mr),this.bindings.hashCode()),this.template.hashCode()))}debug(e){return e=e.debug(this.bindings).write(46).write("lambda").write(40).debug(this.template).write(41)}}class gr extends wr{get typeOrder(){return 51}compareTo(e){return e instanceof gr?l.compare(this.constructor,e.constructor):e instanceof tt?a.compare(this.typeOrder,e.typeOrder):NaN}equivalentTo(e){return this===e}equals(e){return this===e}hashCode(){return l.hash(this.constructor)}debug(e){return e=e.write(this.constructor.name)}}const yr=function(){const e={};Object.defineProperty(e,"max",{get(){const r=new t;return Object.defineProperty(e,"max",{value:r,enumerable:!0,configurable:!0}),r},enumerable:!0,configurable:!0}),Object.defineProperty(e,"min",{get(){const t=new r;return Object.defineProperty(e,"min",{value:t,enumerable:!0,configurable:!0}),t},enumerable:!0,configurable:!0}),Object.defineProperty(e,"abs",{get(){const t=new i;return Object.defineProperty(e,"abs",{value:t,enumerable:!0,configurable:!0}),t},enumerable:!0,configurable:!0}),Object.defineProperty(e,"ceil",{get(){const t=new n;return Object.defineProperty(e,"ceil",{value:t,enumerable:!0,configurable:!0}),t},enumerable:!0,configurable:!0}),Object.defineProperty(e,"floor",{get(){const t=new s;return Object.defineProperty(e,"floor",{value:t,enumerable:!0,configurable:!0}),t},enumerable:!0,configurable:!0}),Object.defineProperty(e,"round",{get(){const t=new o;return Object.defineProperty(e,"round",{value:t,enumerable:!0,configurable:!0}),t},enumerable:!0,configurable:!0}),Object.defineProperty(e,"sqrt",{get(){const t=new a;return Object.defineProperty(e,"sqrt",{value:t,enumerable:!0,configurable:!0}),t},enumerable:!0,configurable:!0}),Object.defineProperty(e,"pow",{get(){const t=new u;return Object.defineProperty(e,"pow",{value:t,enumerable:!0,configurable:!0}),t},enumerable:!0,configurable:!0}),Object.defineProperty(e,"rate",{get(){const t=new h;return Object.defineProperty(e,"rate",{value:t,enumerable:!0,configurable:!0}),t},enumerable:!0,configurable:!0}),Object.defineProperty(e,"random",{get(){const t=new l;return Object.defineProperty(e,"random",{value:t,enumerable:!0,configurable:!0}),t},enumerable:!0,configurable:!0}),Object.defineProperty(e,"scope",{get(){const t=lt.create(10).slot("max",e.max).slot("min",e.min).slot("abs",e.abs).slot("ceil",e.ceil).slot("floor",e.floor).slot("round",e.round).slot("pow",e.pow).slot("sqrt",e.sqrt).slot("rate",e.rate).slot("random",e.random).commit();return Object.defineProperty(e,"scope",{value:t,configurable:!0,enumerable:!0}),t},enumerable:!0,configurable:!0});class t extends gr{invoke(e,t,r){let i,n;if(t=zt.fromAny(t),e.length>=2?(i=e.getItem(0).evaluate(t),n=e.getItem(1).evaluate(t)):i=e.evaluate(t),void 0!==n)return i.max(n);if(void 0!==r){n=r.state;const e=void 0!==n?i.max(n):i;return r.setState(e),e}return tt.absent()}expand(e,t,r){if(1===e.length)return e=e.evaluate(t).toValue(),this.invoke(e,t,r)}}class r extends gr{invoke(e,t,r){let i,n;if(t=zt.fromAny(t),e.length>=2?(i=e.getItem(0).evaluate(t),n=e.getItem(1).evaluate(t)):i=e.evaluate(t),void 0!==n)return i.min(n);if(void 0!==r){n=r.state;const e=void 0!==n?i.min(n):i;return r.setState(e),e}return tt.absent()}expand(e,t,r){if(1===e.length)return e=e.evaluate(t).toValue(),this.invoke(e,t,r)}}class i extends gr{invoke(e,t,r){return(e=e.evaluate(t).toValue())instanceof vt?e.abs():tt.absent()}}class n extends gr{invoke(e,t,r){return(e=e.evaluate(t).toValue())instanceof vt?e.ceil():tt.absent()}}class s extends gr{invoke(e,t,r){return(e=e.evaluate(t).toValue())instanceof vt?e.floor():tt.absent()}}class o extends gr{invoke(e,t,r){return(e=e.evaluate(t).toValue())instanceof vt?e.round():tt.absent()}}class a extends gr{invoke(e,t,r){return(e=e.evaluate(t).toValue())instanceof vt?e.sqrt():tt.absent()}}class u extends gr{invoke(e,t,r){t=zt.fromAny(t);const i=e.getItem(0).evaluate(t),n=e.getItem(1).evaluate(t);return i instanceof vt&&n instanceof vt?i.pow(n):tt.absent()}}class h extends gr{invoke(e,t,r){let i,n;if(t=zt.fromAny(t),e.length>=2?(i=e.getItem(0).evaluate(t).numberValue(NaN),n=e.getItem(1).evaluate(t).numberValue(1e3)):(i=e.evaluate(t).numberValue(NaN),n=1e3),isFinite(i)&&void 0!==r){let e=r.state;if(void 0===e)e={v0:i,t0:Date.now(),dv:0,dt:0},r.setState(e);else{const t=Date.now(),s=t-e.t0;if(s>n&&t>e.t0||s>2*n){const r=i-e.v0;e.v0=i,e.t0=t,e.dv=r,e.dt=s}if(r.setState(e),0!==e.dt){const t=n*e.dv/e.dt;return vt.from(t)}}}return tt.absent()}expand(e,t,r){return e=e.evaluate(t).toValue(),this.invoke(e,t,r)}}class l extends gr{invoke(e,t,r){const i=(e=e.evaluate(t).toValue()).length>=1?e.getItem(0).numberValue(0):0,n=e.length>=2?e.getItem(1).numberValue(i+1):i+1,s=i+Math.random()*(n-i);return vt.from(s)}}return e}();class br{withTag(e){return void 0!==e&&e!==this.tag?new vr(this,e):this}withUnit(e){return e!==this.unit?new xr(this,e):this}static forString(){return new Or("")}static forNumber(){return new Er(0)}static forBoolean(){return new Cr(!1)}static forAny(){return new Ar(void 0)}static forItem(){return new Sr(tt.absent())}static forValue(){return new kr(ht.absent())}}e([n],br,"forString",null),e([n],br,"forNumber",null),e([n],br,"forBoolean",null),e([n],br,"forAny",null),e([n],br,"forItem",null),e([n],br,"forValue",null),Object.defineProperty(br.prototype,"tag",{get(){},configurable:!0}),Object.defineProperty(br.prototype,"unit",{get(){},configurable:!0});class vr extends br{constructor(e,t){super(),this.form=e,this.tag=t}withTag(e){return void 0!==e&&e!==this.tag?new vr(this.form,e):void 0===e?this.form:this}withUnit(e){return e!==this.unit?new vr(this.form.withUnit(e),this.tag):this}mold(e,t){return(t=this.form.mold(e,t)).header(this.tag).isDefined()||(t=t.prepended(ot.of(this.tag))),t}cast(e,t){return e.header(this.tag).isDefined()?this.form.cast(e,t):e.keyEquals(this.tag)?this.form.cast(e.toValue(),t):void 0}}Object.defineProperty(vr.prototype,"unit",{get(){return this.form.unit},configurable:!0});class xr extends br{constructor(e,t){super(),this.form=e,Object.defineProperty(this,"unit",{value:t,enumerable:!0})}withTag(e){return e!==this.tag?new xr(this.form.withTag(e),this.unit):this}withUnit(e){return e!==this.unit?new xr(this.form,e):e===this.form.unit?this.form:this}mold(e,t){return 1===arguments.length?this.form.mold(e):this.form.mold(e,t)}cast(e,t){return 1===arguments.length?this.form.cast(e):this.form.cast(e,t)}}Object.defineProperty(xr.prototype,"tag",{get(){return this.form.tag},configurable:!0});class Or extends br{constructor(e){super(),Object.defineProperty(this,"unit",{value:e,enumerable:!0})}withUnit(e){return e!==this.unit?new Or(e):this}mold(e,t){return void 0===t?yt.from(e):t.concat(yt.from(e))}cast(e,t){const r=e.target;try{return r.stringValue()}catch(e){return}}}class Er extends br{constructor(e){super(),Object.defineProperty(this,"unit",{value:e,enumerable:!0})}withUnit(e){return e!==this.unit?new Er(e):this}mold(e,t){return void 0===t?vt.from(e):t.concat(vt.from(e))}cast(e,t){const r=e.target;try{return r.numberValue()}catch(e){return}}}class Cr extends br{constructor(e){super(),Object.defineProperty(this,"unit",{value:e,enumerable:!0})}withUnit(e){return e!==this.unit?new Cr(e):this}mold(e,t){return void 0===t?Ot.from(e):t.concat(Ot.from(e))}cast(e,t){const r=e.target;try{return r.booleanValue()}catch(e){return}}}class Ar extends br{constructor(e){super(),Object.defineProperty(this,"unit",{value:e,enumerable:!0})}withUnit(e){return e!==this.unit?new Ar(e):this}mold(e,t){return e=tt.fromAny(e),void 0!==t&&(e=t.concat(e)),e}cast(e,t){return e.toAny()}}class Sr extends br{constructor(e){super(),Object.defineProperty(this,"unit",{value:void 0!==e?e.commit():void 0,enumerable:!0})}withUnit(e){return e!==this.unit?new Sr(e):this}mold(e,t){return e=tt.fromAny(e),void 0!==t&&(e=t.concat(e)),e}cast(e,t){return e}}class kr extends br{constructor(e){super(),Object.defineProperty(this,"unit",{value:void 0!==e?e.commit():void 0,enumerable:!0})}withUnit(e){return e!==this.unit?new kr(e):this}mold(e,t){return e=ht.fromAny(e),void 0!==t&&(e=t.concat(e)),e}cast(e,t){return e.toValue()}}const Tr=function(){const e={};return Object.defineProperty(e,"structureParser",{value:function(){const t=new ni;return Object.defineProperty(e,"structureParser",{value:function(){return t},enumerable:!0,configurable:!0}),t},enumerable:!0,configurable:!0}),Object.defineProperty(e,"structureWriter",{value:function(){const t=new ki;return Object.defineProperty(e,"structureWriter",{value:function(){return t},enumerable:!0,configurable:!0}),t},enumerable:!0,configurable:!0}),e.parse=function(t){return e.structureParser().parseBlockString(t)},e.parser=function(){return e.structureParser().blockParser()},e.sizeOf=function(t){return e.structureWriter().sizeOfItem(t)},e.sizeOfBlock=function(t){return e.structureWriter().sizeOfBlockItem(t)},e.write=function(t,r){return e.structureWriter().writeItem(t,r)},e.writeBlock=function(t,r){return e.structureWriter().writeBlockItem(t,r)},e.toString=function(t){let r=ue.stringOutput();const i=e.write(r,t);return i.isDone()||(r=ie.error(i.trap())),r.bind()},e.toBlockString=function(t){let r=ue.stringOutput();const i=e.writeBlock(r,t);return i.isDone()||(r=ie.error(i.trap())),r.bind()},e.toData=function(t){let r=Re.encodedOutput(mt.output());const i=e.write(r,t);return i.isDone()||(r=ie.error(i.trap())),r.bind()},e.toBlockData=function(t){let r=Re.encodedOutput(mt.output());const i=e.writeBlock(r,t);return i.isDone()||(r=ie.error(i.trap())),r.bind()},e.isSpace=function(e){return 32===e||9===e},e.isNewline=function(e){return 10===e||13===e},e.isWhitespace=function(t){return e.isSpace(t)||e.isNewline(t)},e.isIdentStartChar=function(e){return e>=65&&e<=90||95===e||e>=97&&e<=122||e>=192&&e<=214||e>=216&&e<=246||e>=248&&e<=767||e>=880&&e<=893||e>=895&&e<=8191||e>=8204&&e<=8205||e>=8304&&e<=8591||e>=11264&&e<=12271||e>=12289&&e<=55295||e>=63744&&e<=64975||e>=65008&&e<=65533||e>=65536&&e<=983039},e.isIdentChar=function(e){return 45===e||e>=48&&e<=57||e>=65&&e<=90||95===e||e>=97&&e<=122||183===e||e>=192&&e<=214||e>=216&&e<=246||e>=248&&e<=893||e>=895&&e<=8191||e>=8204&&e<=8205||e>=8255&&e<=8256||e>=8304&&e<=8591||e>=11264&&e<=12271||e>=12289&&e<=55295||e>=63744&&e<=64975||e>=65008&&e<=65533||e>=65536&&e<=983039},tt.prototype.toRecon=function(){return e.toString(this)},tt.prototype.toReconBlock=function(){return e.toBlockString(this)},e}();ht.parseRecon=function(e){return Tr.parse(e)};class Pr extends Se{constructor(e,t,r,i,n){super(),this.recon=e,this.builder=t,this.keyParser=r,this.valueParser=i,this.step=n}feed(e){return Pr.parse(e,this.recon,this.builder,this.keyParser,this.valueParser,this.step)}static parse(e,t,r,i,n,s=1){let o=0;e:for(;;){if(1===s){for(;e.isCont()&&(o=e.head(),Tr.isWhitespace(o));)e=e.step();if(e.isCont())if(33===o||34===o||36===o||37===o||39===o||40===o||43===o||45===o||o>=48&&o<=57||64===o||91===o||96===o||123===o||126===o||Tr.isIdentStartChar(o))r=r||t.valueBuilder(),s=2;else{if(35!==o)return void 0!==r?Se.done(r.bind()):Se.done(t.absent());e=e.step(),s=7}else if(e.isDone())return void 0!==r?Se.done(r.bind()):Se.done(t.absent())}if(2===s){for(void 0===i&&(i=t.parseBlockExpression(e));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())s=3;else if(i.isError())return i}if(3===s){for(;e.isCont()&&(o=e.head(),Tr.isSpace(o));)e=e.step();if(e.isCont())58===o?(e=e.step(),s=4):(r.push(t.item(i.bind())),i=void 0,s=6);else if(e.isDone())return r.push(t.item(i.bind())),Se.done(r.bind())}if(4===s){for(;e.isCont()&&Tr.isSpace(e.head());)e=e.step();if(e.isCont())s=5;else if(e.isDone())return r.push(t.slot(i.bind())),Se.done(r.bind())}if(5===s){for(void 0===n&&(n=t.parseBlockExpression(e));n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone())r.push(t.slot(i.bind(),n.bind())),i=void 0,n=void 0,s=6;else if(n.isError())return n}if(6===s){for(;e.isCont()&&(o=e.head(),Tr.isSpace(o));)e=e.step();if(e.isCont()){if(44===o||59===o||Tr.isNewline(o)){e=e.step(),s=1;continue}if(35!==o)return Se.done(r.bind());e=e.step(),s=7}else if(e.isDone())return Se.done(r.bind())}if(7===s){for(;e.isCont();){if(o=e.head(),Tr.isNewline(o)){s=1;continue e}e=e.step()}if(e.isDone()){s=1;continue}}break}return new Pr(t,r,i,n,s)}}class Dr extends Se{constructor(e,t,r,i){super(),this.recon=e,this.keyParser=t,this.valueParser=r,this.step=i}feed(e){return Dr.parse(e,this.recon,this.keyParser,this.valueParser,this.step)}static parse(e,t,r,i,n=1){let s=0;if(1===n)if(e.isCont()){if(s=e.head(),64!==s)return Se.error(ce.expected(64,e));e=e.step(),n=2}else if(e.isDone())return Se.error(ce.expected(64,e));if(2===n){if(void 0===r){if(e.isCont())if(s=e.head(),34===s||39===s)r=t.parseString(e);else{if(!Tr.isIdentStartChar(s))return Se.error(ce.expected("attribute name",e));r=t.parseIdent(e)}else if(e.isDone())return Se.error(ce.expected("attribute name",e))}else r=r.feed(e);if(void 0!==r)if(r.isDone())n=3;else if(r.isError())return r.asError()}if(3===n)if(e.isCont()&&40===e.head())e=e.step(),n=4;else if(!e.isEmpty())return Se.done(t.attr(r.bind()));if(4===n){for(;e.isCont()&&(s=e.head(),Tr.isWhitespace(s));)e=e.step();if(e.isCont()){if(41===s)return e=e.step(),Se.done(t.attr(r.bind()));n=5}else if(e.isDone())return Se.error(ce.expected(")",e))}if(5===n){for(void 0===i&&(i=t.parseBlock(e));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())n=6;else if(i.isError())return i.asError()}if(6===n){for(;e.isCont()&&(s=e.head(),Tr.isWhitespace(s));)e=e.step();if(e.isCont())return 41===s?(e=e.step(),Se.done(t.attr(r.bind(),i.bind()))):Se.error(ce.expected(")",e));if(e.isDone())return Se.error(ce.expected(")",e))}return new Dr(t,r,i,n)}}class qr extends Se{constructor(e,t,r,i,n){super(),this.recon=e,this.builder=t,this.fieldParser=r,this.valueParser=i,this.step=n}feed(e){return qr.parse(e,this.recon,this.builder,this.fieldParser,this.valueParser,this.step)}static parse(e,t,r,i,n,s=1){let o=0;for(;;){if(1===s)if(e.isCont())if(o=e.head(),64===o)i=t.parseAttr(e),s=2;else if(123===o)r=r||t.recordBuilder(),n=t.parseRecord(e,r),s=5;else if(91===o)r=r||t.recordBuilder(),n=t.parseMarkup(e,r),s=5;else if(Tr.isIdentStartChar(o))n=t.parseIdent(e),s=4;else if(34===o||39===o)n=t.parseString(e),s=4;else if(96===o)n=t.parseRawString(e),s=4;else if(45===o||o>=48&&o<=57)n=t.parseNumber(e),s=4;else if(37===o)n=t.parseData(e),s=4;else{if(36!==o)return void 0===r?Se.done(t.extant()):Se.done(r.bind());n=t.parseSelector(e),s=4}else if(e.isDone())return void 0===r?Se.done(t.extant()):Se.done(r.bind());if(2===s){for(;i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())(r=r||t.valueBuilder()).push(i.bind()),i=void 0,s=3;else if(i.isError())return i.asError()}if(3===s){for(;e.isCont()&&Tr.isSpace(e.head());)e=e.step();if(e.isCont()){s=1;continue}if(e.isDone())return Se.done(r.bind())}if(4===s){for(;n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone())(r=r||t.valueBuilder()).push(t.item(n.bind())),n=void 0,s=6;else if(n.isError())return n}if(5===s){for(;n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone())n=void 0,s=6;else if(n.isError())return n}if(6===s){for(;e.isCont()&&Tr.isSpace(e.head());)e=e.step();if(e.isCont()){if(64!==e.head())return Se.done(r.bind());s=1}else if(e.isDone())return Se.done(r.bind())}break}return new qr(t,r,i,n,s)}}class Ir extends Se{constructor(e,t,r,i,n){super(),this.recon=e,this.builder=t,this.fieldParser=r,this.valueParser=i,this.step=n}feed(e){return Ir.parse(e,this.recon,this.builder,this.fieldParser,this.valueParser,this.step)}static parse(e,t,r,i,n,s=1){let o=0;if(1===s)if(e.isCont())if(o=e.head(),64===o)i=t.parseAttr(e),s=2;else if(123===o)void 0!==r?(n=t.parseRecord(e,r),s=5):(n=t.parseRecord(e),s=4);else{if(91!==o)return void 0===r?Se.done(t.extant()):Se.done(r.bind());void 0!==r?(n=t.parseMarkup(e,r),s=5):(n=t.parseMarkup(e),s=4)}else if(e.isDone())return void 0===r?Se.done(t.extant()):Se.done(r.bind());if(2===s){for(;i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())(r=r||t.valueBuilder()).push(i.bind()),i=void 0,s=3;else if(i.isError())return i.asError()}if(3===s)if(e.isCont())if(o=e.head(),123===o)n=t.parseRecord(e,r),s=5;else{if(91!==o)return Se.done(r.bind());n=t.parseMarkup(e,r),s=5}else if(e.isDone())return Se.done(r.bind());if(4===s){for(;n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone())return(r=r||t.valueBuilder()).push(t.item(n.bind())),Se.done(r.bind());if(n.isError())return n}if(5===s){for(;n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone())return Se.done(r.bind());if(n.isError())return n}return new Ir(t,r,i,n,s)}}class Vr extends Se{constructor(e,t,r,i,n){super(),this.recon=e,this.builder=t,this.keyParser=r,this.valueParser=i,this.step=n}feed(e){return Vr.parse(e,this.recon,this.builder,this.keyParser,this.valueParser,this.step)}static parse(e,t,r,i,n,s=1){let o=0;if(1===s)if(e.isCont()){if(o=e.head(),123!==o)return Se.error(ce.expected(123,e));e=e.step(),s=2}else if(e.isDone())return Se.error(ce.expected(123,e));e:for(;;){if(2===s){for(;e.isCont()&&(o=e.head(),Tr.isWhitespace(o));)e=e.step();if(e.isCont()){if(r=r||t.recordBuilder(),125===o)return e=e.step(),Se.done(r.bind());35===o?(e=e.step(),s=8):s=3}else if(e.isDone())return Se.error(ce.expected(125,e))}if(3===s){for(void 0===i&&(i=t.parseBlockExpression(e));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())s=4;else if(i.isError())return i}if(4===s){for(;e.isCont()&&(o=e.head(),Tr.isSpace(o));)e=e.step();if(e.isCont())58===o?(e=e.step(),s=5):(r.push(t.item(i.bind())),i=void 0,s=7);else if(e.isDone())return Se.error(ce.expected(125,e))}if(5===s){for(;e.isCont()&&Tr.isSpace(e.head());)e=e.step();if(e.isCont())s=6;else if(e.isDone())return r.push(t.slot(i.bind())),Se.done(r.bind())}if(6===s){for(void 0===n&&(n=t.parseBlockExpression(e));n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone())r.push(t.slot(i.bind(),n.bind())),i=void 0,n=void 0,s=7;else if(n.isError())return n}if(7===s){for(;e.isCont()&&(o=e.head(),Tr.isSpace(o));)e=e.step();if(e.isCont()){if(44===o||59===o||Tr.isNewline(o)){e=e.step(),s=2;continue}if(35!==o)return 125===o?(e=e.step(),Se.done(r.bind())):Se.error(ce.expected("\'}\', \';\', \',\', or newline",e));e=e.step(),s=8}else if(e.isDone())return Se.error(ce.expected(125,e))}if(8===s){for(;e.isCont();){if(o=e.head(),Tr.isNewline(o)){s=2;continue e}e=e.step()}if(e.isDone()){s=2;continue}}break}return new Vr(t,r,i,n,s)}}class Nr extends Se{constructor(e,t,r,i,n){super(),this.recon=e,this.builder=t,this.textOutput=r,this.valueParser=i,this.step=n}feed(e){return Nr.parse(e,this.recon,this.builder,this.textOutput,this.valueParser,this.step)}static parse(e,t,r,i,n,s=1){let o=0;if(1===s)if(e.isCont()){if(o=e.head(),91!==o)return Se.error(ce.expected(91,e));e=e.step(),s=2}else if(e.isDone())return Se.error(ce.expected(91,e));for(;;){if(2===s){for(;e.isCont()&&(o=e.head(),64!==o&&91!==o&&92!==o&&93!==o&&123!==o&&125!==o);)e=e.step(),(i=i||t.textOutput()).write(o);if(e.isCont()){if(93===o)return e=e.step(),r=r||t.recordBuilder(),void 0!==i&&r.push(t.item(i.bind())),Se.done(r.bind());if(64===o)r=r||t.recordBuilder(),void 0!==i&&(r.push(t.item(i.bind())),i=void 0),n=t.parseInlineItem(e),s=3;else if(123===o)r=r||t.recordBuilder(),void 0!==i&&(r.push(t.item(i.bind())),i=void 0),n=t.parseRecord(e,r),s=4;else if(91===o)r=r||t.recordBuilder(),void 0!==i&&(r.push(t.item(i.bind())),i=void 0),n=t.parseMarkup(e,r),s=4;else{if(92!==o)return Se.error(ce.unexpected(e));e=e.step(),s=5}}else if(e.isDone())return Se.error(ce.unexpected(e))}if(3===s){for(;n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone()){r.push(t.item(n.bind())),n=void 0,s=2;continue}if(n.isError())return n}if(4===s){for(;n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone()){n=void 0,s=2;continue}if(n.isError())return n}if(5===s){if(e.isCont()){if(o=e.head(),i=i||t.textOutput(),34===o||36===o||39===o||47===o||64===o||91===o||92===o||93===o||123===o||125===o)e=e.step(),i.write(o),s=2;else if(98===o)e=e.step(),i.write(8),s=2;else if(102===o)e=e.step(),i.write(12),s=2;else if(110===o)e=e.step(),i.write(10),s=2;else if(114===o)e=e.step(),i.write(13),s=2;else{if(116!==o)return Se.error(ce.expected("escape character",e));e=e.step(),i.write(9),s=2}continue}if(e.isDone())return Se.error(ce.expected("escape character",e))}break}return new Nr(t,r,i,n,s)}}class zr extends Se{constructor(e,t,r){super(),this.recon=e,this.base64Parser=t,this.step=r}feed(e){return zr.parse(e,this.recon,this.base64Parser,this.step)}static parse(e,t,r,i=1){let n=0;if(1===i)if(e.isCont()){if(n=e.head(),37!==n)return Se.error(ce.expected(37,e));e=e.step(),i=2}else if(e.isDone())return Se.error(ce.expected(37,e));if(2===i){for(void 0===r&&(r=Xe.standard().parse(e,t.dataOutput()));r.isCont()&&!e.isEmpty();)r=r.feed(e);if(r.isDone())return r;if(r.isError())return r}return new zr(t,r,i)}}class Mr extends Se{constructor(e,t,r){super(),this.recon=e,this.output=t,this.step=r}feed(e){return Mr.parse(e,this.recon,this.output,this.step)}static parse(e,t,r,i=1){let n=0;if(1===i)if(e.isCont()){if(n=e.head(),!Tr.isIdentStartChar(n))return Se.error(ce.expected("identifier",e));e=e.step(),r=(r=r||t.textOutput()).write(n),i=2}else if(e.isDone())return Se.error(ce.expected("identifier",e));if(2===i){for(;e.isCont()&&(n=e.head(),Tr.isIdentChar(n));)e=e.step(),r.write(n);if(!e.isEmpty())return Se.done(t.ident(r.bind()))}return new Mr(t,r,i)}}class jr extends Se{constructor(e,t,r,i,n){super(),this.recon=e,this.output=t,this.quote=r,this.code=i,this.step=n}feed(e){return jr.parse(e,this.recon,this.output,this.quote,this.code,this.step)}static parse(e,t,r,i=0,n=0,s=1){let o=0;if(1===s){for(;e.isCont()&&(o=e.head(),Tr.isWhitespace(o));)e=e.step();if(e.isCont()){if(34!==o&&39!==o||i!==o&&0!==i)return Se.error(ce.expected("string",e));e=e.step(),r=r||t.textOutput(),i=o,s=2}else if(e.isDone())return Se.error(ce.expected("string",e))}e:for(;;){if(2===s){for(;e.isCont()&&(o=e.head(),o>=32&&o!==i&&92!==o);)e=e.step(),r=r.write(o);if(e.isCont()){if(o===i)return e=e.step(),Se.done(r.bind());if(92!==o)return Se.error(ce.expected(i,e));e=e.step(),s=3}else if(e.isDone())return Se.error(ce.expected(i,e))}if(3===s)if(e.isCont()){if(o=e.head(),34===o||36===o||39===o||47===o||64===o||91===o||92===o||93===o||123===o||125===o){e=e.step(),r=r.write(o),s=2;continue}if(98===o){e=e.step(),r=r.write(8),s=2;continue}if(102===o){e=e.step(),r=r.write(12),s=2;continue}if(110===o){e=e.step(),r=r.write(10),s=2;continue}if(114===o){e=e.step(),r=r.write(13),s=2;continue}if(116===o){e=e.step(),r=r.write(9),s=2;continue}if(117!==o)return Se.error(ce.expected("escape character",e));e=e.step(),s=4}else if(e.isDone())return Se.error(ce.expected("escape character",e));if(s>=4)for(;;){if(e.isCont()){if(o=e.head(),Be.isDigit(o)){if(e=e.step(),n=16*n+Be.decodeDigit(o),s<=6){s+=1;continue}r=r.write(n),n=0,s=2;continue e}return Se.error(ce.expected("hex digit",e))}if(e.isDone())return Se.error(ce.expected("hex digit",e));break}break}return new jr(t,r,i,n,s)}}class Lr extends Se{constructor(e,t,r,i){super(),this.recon=e,this.output=t,this.count=r,this.step=i}feed(e){return Lr.parse(e,this.recon,this.output,this.count,this.step)}static parse(e,t,r,i=0,n=1){let s=0;if(1===n){for(;e.isCont()&&(s=e.head(),Tr.isWhitespace(s));)e=e.step();if(e.isCont()&&96===s)e=e.step(),i=1,n=2;else if(e.isDone())return Se.error(ce.expected("raw string",e))}if(2===n)if(e.isCont())96===e.head()?(e=e.step(),i=2,n=3):(r=r||t.textOutput(),n=4);else if(e.isDone())return Se.error(ce.expected("raw string",e));if(3===n)if(e.isCont()){if(96!==e.head())return r=r||t.textOutput(),Se.done(r.bind());e=e.step(),r=r||t.textOutput(),i=3,n=4}else if(e.isDone())return r=r||t.textOutput(),Se.done(r.bind());for(;;){if(4===n){for(;e.isCont()&&(s=e.head(),(1!==i||s>=32)&&96!==s&&92!==s);)e=e.step(),r=r.write(s);if(e.isCont())if(92===s)e=e.step(),n=5;else{if(96!==s)return Se.error(ce.expected(96,e));if(e=e.step(),1===i)return Se.done(r.bind());n=6}else if(e.isDone())return Se.error(ce.expected(96,e))}if(5===n){if(e.isCont()){s=e.head(),e=e.step(),92!==s&&96!==s&&(r=r.write(92)),r=r.write(s),n=4;continue}if(e.isDone())return Se.error(ce.expected("escape character",e))}if(6===n)if(e.isCont()){if(96!==e.head()){r=r.write(96),n=4;continue}e=e.step(),n=7}else if(e.isDone())return Se.error(ce.message("unclosed raw string",e));if(7===n){if(e.isCont()){if(96===e.head())return e=e.step(),Se.done(r.bind());r=(r=r.write(96)).write(96),n=4;continue}if(e.isDone())return Se.error(ce.message("unclosed raw string",e))}break}return new Lr(t,r,i,n)}}class Fr extends Se{constructor(e,t,r,i,n){super(),this.recon=e,this.sign=t,this.value=r,this.mode=i,this.step=n}feed(e){return Fr.parse(e,this.recon,this.sign,this.value,this.mode,this.step)}static parse(e,t,r=1,i=0,n=2,s=1){let o=0;if(1===s){for(;e.isCont()&&(o=e.head(),Tr.isWhitespace(o));)e=e.step();if(e.isCont())45===o&&(e=e.step(),r=-1),s=2;else if(e.isDone())return Se.error(ce.expected("number",e))}if(2===s)if(e.isCont())if(o=e.head(),48===o)e=e.step(),s=4;else{if(!(o>=49&&o<=57))return Se.error(ce.expected("digit",e));e=e.step(),i=r*(o-48),s=3}else if(e.isDone())return Se.error(ce.expected("digit",e));if(3===s){for(;e.isCont()&&(o=e.head(),o>=48&&o<=57);){const t=10*i+r*(o-48);if(!(-9007199254740991<=t&&t<=9007199254740992))return Se.error(ce.message("integer overflow",e));i=t,e=e.step()}if(e.isCont())s=4;else if(e.isDone())return Se.done(t.num(i))}if(4===s){if(e.isCont()){if(o=e.head(),n>0&&46===o||n>1&&(69===o||101===o)){let s=ue.stringOutput();return s=r<0&&0===i?s.write(45).write(48):s.write(""+i),Br.parse(e,t,s,n)}return 120===o&&r>0&&0===i?(e=e.step(),Ur.parse(e,t)):Se.done(t.num(i))}if(e.isDone())return Se.done(t.num(i))}return new Fr(t,r,i,n,s)}static parseInteger(e,t){return Fr.parse(e,t,void 0,void 0,0)}static parseDecimal(e,t){return Fr.parse(e,t,void 0,void 0,1)}}class Br extends Se{constructor(e,t,r,i){super(),this.recon=e,this.output=t,this.mode=r,this.step=i}feed(e){return Br.parse(e,this.recon,this.output,this.mode,this.step)}static parse(e,t,r,i=2,n=1){let s=0;if(1===n)if(e.isCont())if(s=e.head(),46===s)e=e.step(),r=r.write(s),n=2;else{if(!(i>1)||69!==s&&101!==s)return Se.error(ce.expected("decimal or exponent",e));e=e.step(),r=r.write(s),n=5}else if(e.isDone())return Se.error(ce.expected("decimal or exponent",e));if(2===n)if(e.isCont()){if(s=e.head(),!(s>=48&&s<=57))return Se.error(ce.expected("digit",e));e=e.step(),r=r.write(s),n=3}else if(e.isDone())return Se.error(ce.expected("digit",e));if(3===n){for(;e.isCont()&&(s=e.head(),s>=48&&s<=57);)e=e.step(),r=r.write(s);if(e.isCont()){if(!(i>1))return Se.done(t.num(r.bind()));n=4}else if(e.isDone())return Se.done(t.num(r.bind()))}if(4===n){if(s=e.head(),69!==s&&101!==s)return Se.done(t.num(r.bind()));e=e.step(),r=r.write(s),n=5}if(5===n)if(e.isCont())s=e.head(),43!==s&&45!==s||(e=e.step(),r=r.write(s)),n=6;else if(e.isDone())return Se.error(ce.unexpected(e));if(6===n)if(e.isCont()){if(s=e.head(),!(s>=48&&s<=57))return Se.error(ce.expected("digit",e));e=e.step(),r=r.write(s),n=7}else if(e.isDone())return Se.error(ce.expected("digit",e));if(7===n){for(;e.isCont()&&(s=e.head(),s>=48&&s<=57);)e=e.step(),r=r.write(s);if(!e.isEmpty())return Se.done(t.num(r.bind()))}return new Br(t,r,i,n)}}class Ur extends Se{constructor(e,t,r){super(),this.recon=e,this.value=t,this.size=r}feed(e){return Ur.parse(e,this.recon,this.value,this.size)}static parse(e,t,r=0,i=0){let n=0;for(;e.isCont()&&(n=e.head(),Be.isDigit(n));)e=e.step(),r=16*r+Be.decodeDigit(n),i+=1;return e.isEmpty()?new Ur(t,r,i):i>0?i<=8?Se.done(t.uint32(r)):Se.done(t.uint64(r)):Se.error(ce.expected("hex digit",e))}}class Wr extends Se{constructor(e,t,r,i,n){super(),this.recon=e,this.builder=t,this.bindingsParser=r,this.templateParser=i,this.step=n}feed(e){return Wr.parse(e,this.recon,this.builder,this.bindingsParser,this.templateParser,this.step)}static parse(e,t,r,i,n,s=1){let o=0;if(1===s){for(void 0===i&&(i=t.parseConditionalOperator(e,r));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())s=2;else if(i.isError())return i.asError()}if(2===s)if(e.isCont()){if(o=e.head(),62!==o)return i;e=e.step(),s=3}else if(e.isDone())return i;if(3===s){for(void 0===n&&(n=t.parseConditionalOperator(e));n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone()){const e=i.bind(),r=n.bind();return Se.done(t.lambda(e,r))}if(n.isError())return n.asError()}return new Wr(t,r,i,n,s)}}class Rr extends Se{constructor(e,t,r,i,n,s){super(),this.recon=e,this.builder=t,this.ifParser=r,this.thenParser=i,this.elseParser=n,this.step=s}feed(e){return Rr.parse(e,this.recon,this.builder,this.ifParser,this.thenParser,this.elseParser,this.step)}static parse(e,t,r,i,n,s,o=1){let a=0;if(1===o){for(void 0===i&&(i=t.parseOrOperator(e,r));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())o=2;else if(i.isError())return i.asError()}if(2===o){for(;e.isCont()&&(a=e.head(),Tr.isSpace(a));)e=e.step();if(e.isCont()){if(63!==a)return i;e=e.step(),o=3}else if(e.isDone())return i}if(3===o){for(void 0===n&&(n=t.parseConditionalOperator(e,r));n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone())o=4;else if(n.isError())return n.asError()}if(4===o){for(;e.isCont()&&(a=e.head(),Tr.isSpace(a));)e=e.step();if(e.isCont()){if(58!==a)return Se.error(ce.expected(58,e));e=e.step(),o=5}else if(e.isDone())return Se.error(ce.expected(58,e))}if(5===o){for(void 0===s&&(s=t.parseConditionalOperator(e,r));s.isCont()&&!e.isEmpty();)s=s.feed(e);if(s.isDone()){const e=i.bind(),r=n.bind(),o=s.bind();return Se.done(t.conditional(e,r,o))}if(s.isError())return s.asError()}return new Rr(t,r,i,n,s,o)}}class Hr extends Se{constructor(e,t,r,i,n){super(),this.recon=e,this.builder=t,this.lhsParser=r,this.rhsParser=i,this.step=n}feed(e){return Hr.parse(e,this.recon,this.builder,this.lhsParser,this.rhsParser,this.step)}static parse(e,t,r,i,n,s=1){let o=0;for(;;){if(1===s){for(void 0===i&&(i=t.parseAndOperator(e,r));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())s=2;else if(i.isError())return i.asError()}if(2===s)if(e.isCont()){if(o=e.head(),124!==o)return i;e=e.step(),s=3}else if(e.isDone())return i;if(3===s){for(void 0===n&&(n=t.parseAndOperator(e,r));n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone()){const e=i.bind(),r=n.bind();i=Se.done(t.or(e,r)),n=void 0,s=2;continue}if(n.isError())return n.asError()}break}return new Hr(t,r,i,n,s)}}class Kr extends Se{constructor(e,t,r,i,n){super(),this.recon=e,this.builder=t,this.lhsParser=r,this.rhsParser=i,this.step=n}feed(e){return Kr.parse(e,this.recon,this.builder,this.lhsParser,this.rhsParser,this.step)}static parse(e,t,r,i,n,s=1){let o=0;for(;;){if(1===s){for(void 0===i&&(i=t.parseBitwiseOrOperator(e,r));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())s=2;else if(i.isError())return i.asError()}if(2===s)if(e.isCont()){if(o=e.head(),38!==o)return i;e=e.step(),s=3}else if(e.isDone())return i;if(3===s){for(void 0===n&&(n=t.parseBitwiseOrOperator(e,r));n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone()){const e=i.bind(),r=n.bind();i=Se.done(t.and(e,r)),n=void 0,s=2;continue}if(n.isError())return n.asError()}break}return new Kr(t,r,i,n,s)}}class _r extends Se{constructor(e,t,r,i,n){super(),this.recon=e,this.builder=t,this.lhsParser=r,this.rhsParser=i,this.step=n}feed(e){return _r.parse(e,this.recon,this.builder,this.lhsParser,this.rhsParser,this.step)}static parse(e,t,r,i,n,s=1){let o=0;for(;;){if(1===s){for(void 0===i&&(i=t.parseBitwiseXorOperator(e,r));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())s=2;else if(i.isError())return i.asError()}if(2===s){for(;e.isCont()&&(o=e.head(),Tr.isSpace(o));)e=e.step();if(e.isCont()){if(124!==o)return i;e=e.step(),s=3}else if(e.isDone())return i}if(3===s)if(e.isCont()){if(o=e.head(),124===o)return i;s=4}else if(e.isDone())return Se.error(ce.unexpected(e));if(4===s){for(void 0===n&&(n=t.parseBitwiseXorOperator(e,r));n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone()){const e=i.bind(),r=n.bind();i=Se.done(t.bitwiseOr(e,r)),n=void 0,s=2;continue}if(n.isError())return n.asError()}break}return new _r(t,r,i,n,s)}}class Gr extends Se{constructor(e,t,r,i,n){super(),this.recon=e,this.builder=t,this.lhsParser=r,this.rhsParser=i,this.step=n}feed(e){return Gr.parse(e,this.recon,this.builder,this.lhsParser,this.rhsParser,this.step)}static parse(e,t,r,i,n,s=1){let o=0;for(;;){if(1===s){for(void 0===i&&(i=t.parseBitwiseAndOperator(e,r));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())s=2;else if(i.isError())return i.asError()}if(2===s){for(;e.isCont()&&(o=e.head(),Tr.isSpace(o));)e=e.step();if(e.isCont()){if(94!==o)return i;e=e.step(),s=3}else if(e.isDone())return i}if(3===s){for(void 0===n&&(n=t.parseBitwiseAndOperator(e,r));n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone()){const e=i.bind(),r=n.bind();i=Se.done(t.bitwiseXor(e,r)),n=void 0,s=2;continue}if(n.isError())return n.asError()}break}return new Gr(t,r,i,n,s)}}class Qr extends Se{constructor(e,t,r,i,n){super(),this.recon=e,this.builder=t,this.lhsParser=r,this.rhsParser=i,this.step=n}feed(e){return Qr.parse(e,this.recon,this.builder,this.lhsParser,this.rhsParser,this.step)}static parse(e,t,r,i,n,s=1){let o=0;for(;;){if(1===s){for(void 0===i&&(i=t.parseComparisonOperator(e,r));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())s=2;else if(i.isError())return i.asError()}if(2===s){for(;e.isCont()&&(o=e.head(),Tr.isSpace(o));)e=e.step();if(e.isCont()){if(38!==o)return i;e=e.step(),s=3}else if(e.isDone())return i}if(3===s)if(e.isCont()){if(o=e.head(),38===o)return i;s=4}else if(e.isDone())return Se.error(ce.unexpected(e));if(4===s){for(void 0===n&&(n=t.parseComparisonOperator(e,r));n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone()){const e=i.bind(),r=n.bind();i=Se.done(t.bitwiseAnd(e,r)),n=void 0,s=2;continue}if(n.isError())return n.asError()}break}return new Qr(t,r,i,n,s)}}class Zr extends Se{constructor(e,t,r,i,n,s){super(),this.recon=e,this.builder=t,this.lhsParser=r,this.operator=i,this.rhsParser=n,this.step=s}feed(e){return Zr.parse(e,this.recon,this.builder,this.lhsParser,this.operator,this.rhsParser,this.step)}static parse(e,t,r,i,n,s,o=1){let a=0;if(1===o){for(void 0===i&&(i=t.parseAttrExpression(e,r));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())o=2;else if(i.isError())return i.asError()}if(2===o){for(;e.isCont()&&(a=e.head(),Tr.isSpace(a));)e=e.step();if(e.isCont())if(33===a)e=e.step(),o=3;else if(60===a)e=e.step(),o=4;else if(62===a)e=e.step(),o=5;else{if(61!==a)return i;e=e.step(),o=6}else if(e.isDone())return i}if(3===o)if(e.isCont())a=e.head(),61===a?(e=e.step(),n="!=",o=7):(n="!",o=7);else if(e.isDone())return Se.error(ce.unexpected(e));if(4===o)if(e.isCont())a=e.head(),61===a?(e=e.step(),n="<=",o=7):(n="<",o=7);else if(e.isDone())return Se.error(ce.unexpected(e));if(5===o)if(e.isCont())a=e.head(),61===a?(e=e.step(),n=">=",o=7):(n=">",o=7);else if(e.isDone())return Se.error(ce.unexpected(e));if(6===o)if(e.isCont())if(a=e.head(),61===a)e=e.step(),n="==",o=7;else{if(62===a)return i;n="=",o=7}else if(e.isDone())return Se.error(ce.unexpected(e));if(7===o){for(void 0===s&&(s=t.parseAttrExpression(e,r));s.isCont()&&!e.isEmpty();)s=s.feed(e);if(s.isDone()){const r=i.bind(),o=s.bind();return"<"===n?Se.done(t.lt(r,o)):"<="===n?Se.done(t.le(r,o)):"=="===n?Se.done(t.eq(r,o)):"!="===n?Se.done(t.ne(r,o)):">="===n?Se.done(t.ge(r,o)):">"===n?Se.done(t.gt(r,o)):Se.error(ce.message(n,e))}if(s.isError())return s.asError()}return new Zr(t,r,i,n,s,o)}}class Xr extends Se{constructor(e,t,r,i,n){super(),this.recon=e,this.builder=t,this.fieldParser=r,this.valueParser=i,this.step=n}feed(e){return Xr.parse(e,this.recon,this.builder,this.fieldParser,this.valueParser,this.step)}static parse(e,t,r,i,n,s=1){let o=0;for(;;){if(1===s){for(;e.isCont()&&(o=e.head(),Tr.isSpace(o));)e=e.step();if(e.isCont())if(64===o)s=2;else if(123===o||91===o)r=r||t.recordBuilder(),s=5;else if(40===o)s=4;else{if(!(33===o||34===o||36===o||37===o||39===o||43===o||45===o||o>=48&&o<=57||96===o||126===o||Tr.isIdentStartChar(o)))return void 0===r?Se.done(t.extant()):Se.done(r.bind());s=3}else if(e.isDone())return void 0===r?Se.done(t.extant()):Se.done(r.bind())}if(2===s){for(void 0===i&&(i=t.parseAttr(e));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone()){(r=r||t.recordBuilder()).push(i.bind()),i=void 0,s=1;continue}if(i.isError())return i.asError()}if(3===s){for(void 0===n&&(n=t.parseAdditiveOperator(e));n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone())(r=r||t.valueBuilder()).push(t.item(n.bind())),n=void 0,s=6;else if(n.isError())return n.asError()}if(4===s){for(void 0===n&&(n=t.parseAdditiveOperator(e,r));n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone())void 0===r&&(r=t.valueBuilder()).push(t.item(n.bind())),n=void 0,s=6;else if(n.isError())return n.asError()}if(5===s){for(void 0===n&&(n=t.parseAdditiveOperator(e,r));n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone())n=void 0,s=6;else if(n.isError())return n.asError()}if(6===s){for(;e.isCont()&&(o=e.head(),Tr.isSpace(o));)e=e.step();if(e.isCont()){if(64===o){s=1;continue}return Se.done(r.bind())}if(e.isDone())return Se.done(r.bind())}break}return new Xr(t,r,i,n,s)}}class $r extends Se{constructor(e,t,r,i,n,s){super(),this.recon=e,this.builder=t,this.lhsParser=r,this.operator=i,this.rhsParser=n,this.step=s}feed(e){return $r.parse(e,this.recon,this.builder,this.lhsParser,this.operator,this.rhsParser,this.step)}static parse(e,t,r,i,n,s,o=1){let a=0;for(;;){if(1===o){for(void 0===i&&(i=t.parseMultiplicativeOperator(e,r));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())o=2;else if(i.isError())return i.asError()}if(2===o){for(;e.isCont()&&(a=e.head(),Tr.isSpace(a));)e=e.step();if(e.isCont())if(43===a)e=e.step(),n="+",o=3;else{if(45!==a)return i;e=e.step(),n="-",o=3}else if(e.isDone())return i}if(3===o){for(void 0===s&&(s=t.parseMultiplicativeOperator(e,r));s.isCont()&&!e.isEmpty();)s=s.feed(e);if(s.isDone()){const r=i.bind(),a=s.bind();if("+"===n)i=Se.done(t.plus(r,a));else{if("-"!==n)return Se.error(ce.message(n,e));i=Se.done(t.minus(r,a))}s=void 0,n=void 0,o=2;continue}if(s.isError())return s.asError()}break}return new $r(t,r,i,n,s,o)}}class Yr extends Se{constructor(e,t,r,i,n,s){super(),this.recon=e,this.builder=t,this.lhsParser=r,this.operator=i,this.rhsParser=n,this.step=s}feed(e){return Yr.parse(e,this.recon,this.builder,this.lhsParser,this.operator,this.rhsParser,this.step)}static parse(e,t,r,i,n,s,o=1){let a=0;for(;;){if(1===o){for(void 0===i&&(i=t.parsePrefixOperator(e,r));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())o=2;else if(i.isError())return i.asError()}if(2===o){for(;e.isCont()&&(a=e.head(),Tr.isSpace(a));)e=e.step();if(e.isCont())if(42===a)e=e.step(),n="*",o=3;else if(47===a)e=e.step(),n="/",o=3;else{if(37!==a)return i;e=e.step(),n="%",o=3}else if(e.isDone())return i}if(3===o){for(void 0===s&&(s=t.parsePrefixOperator(e,r));s.isCont()&&!e.isEmpty();)s=s.feed(e);if(s.isDone()){const r=i.bind(),a=s.bind();if("*"===n)i=Se.done(t.times(r,a));else if("/"===n)i=Se.done(t.divide(r,a));else{if("%"!==n)return Se.error(ce.message(n,e));i=Se.done(t.modulo(r,a))}s=void 0,n=void 0,o=2;continue}if(s.isError())return s.asError()}break}return new Yr(t,r,i,n,s,o)}}class Jr extends Se{constructor(e,t,r,i,n){super(),this.recon=e,this.builder=t,this.operator=r,this.operandParser=i,this.step=n}feed(e){return Jr.parse(e,this.recon,this.builder,this.operator,this.operandParser,this.step)}static parse(e,t,r,i,n,s=1){let o=0;if(1===s){for(;e.isCont()&&(o=e.head(),Tr.isSpace(o));)e=e.step();if(e.isCont()){if(33===o)e=e.step(),i="!";else if(126===o)e=e.step(),i="~";else if(45===o)e=e.step(),i="-";else{if(43!==o)return t.parseInvokeOperator(e,r);e=e.step(),i="+"}s=2}else if(e.isDone())return t.parseInvokeOperator(e,r)}if(2===s){for(void 0===n&&(n=t.parsePrefixOperator(e,r));n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone()){const r=n.bind();return t.isDistinct(r)?"!"===i?Se.done(t.not(r)):"~"===i?Se.done(t.bitwiseNot(r)):"-"===i?Se.done(t.negative(r)):"+"===i?Se.done(t.positive(r)):Se.error(ce.message(i,e)):Se.error(ce.expected("value",e))}if(n.isError())return n.asError()}return new Jr(t,r,i,n,s)}}class ei extends Se{constructor(e,t,r,i,n){super(),this.recon=e,this.builder=t,this.exprParser=r,this.argsParser=i,this.step=n}feed(e){return ei.parse(e,this.recon,this.builder,this.exprParser,this.argsParser,this.step)}static parse(e,t,r,i,n,s=1){let o=0;if(1===s){for(void 0===i&&(i=t.parsePrimary(e,r));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())s=2;else if(i.isError())return i.asError()}for(;;){if(2===s){for(;e.isCont()&&(o=e.head(),Tr.isSpace(o));)e=e.step();if(e.isCont()){if(40!==o)return i;e=e.step(),s=3}else if(e.isDone())return i}if(3===s){for(;e.isCont()&&(o=e.head(),Tr.isWhitespace(o));)e=e.step();if(e.isCont()){if(41===o){e=e.step();const r=i.bind();i=Se.done(t.invoke(r,t.extant())),s=2;continue}s=4}else if(e.isDone())return Se.error(ce.expected(41,e))}if(4===s){for(void 0===n&&(n=t.parseBlock(e));n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone())s=5;else if(n.isError())return n.asError()}if(5===s){for(;e.isCont()&&(o=e.head(),Tr.isWhitespace(o));)e=e.step();if(e.isCont()){if(41===o){e=e.step();const r=i.bind(),o=n.bind();i=Se.done(t.invoke(r,o)),n=void 0,s=2;continue}return Se.error(ce.expected(41,e))}if(e.isDone())return Se.error(ce.expected(41,e))}break}return new ei(t,r,i,n,s)}}class ti extends Se{constructor(e,t,r,i){super(),this.recon=e,this.builder=t,this.exprParser=r,this.step=i}feed(e){return ti.parse(e,this.recon,this.builder,this.exprParser,this.step)}static parse(e,t,r,i,n=1){let s=0;if(1===n){for(;e.isCont()&&(s=e.head(),Tr.isSpace(s));)e=e.step();e.isCont()?40===s?(e=e.step(),n=3):n=2:e.isDone()&&(n=2)}if(2===n){for(void 0===i&&(i=t.parseLiteral(e,r));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())return i;if(i.isError())return i.asError()}if(3===n){for(void 0===i&&(i=t.parseBlockExpression(e,r));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())n=4;else if(i.isError())return i.asError()}for(;;){if(4===n){for(;e.isCont()&&(s=e.head(),Tr.isSpace(s));)e=e.step();if(e.isCont()){if(44!==s)return 41===s?(e=e.step(),void 0!==i?i:Se.done(r.bind())):Se.error(ce.expected(41,e));e=e.step(),void 0!==i&&(void 0===r&&(r=t.recordBuilder()).push(t.item(i.bind())),i=void 0),n=5}else if(e.isDone())return Se.error(ce.expected(41,e))}if(5===n){for(void 0===i&&(i=t.parseBlockExpression(e,r));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone()){i=void 0,n=4;continue}if(i.isError())return i.asError()}break}return new ti(t,r,i,n)}}class ri extends Se{constructor(e,t,r,i){super(),this.recon=e,this.builder=t,this.valueParser=r,this.step=i}feed(e){return ri.parse(e,this.recon,this.builder,this.valueParser,this.step)}static parse(e,t,r,i,n=1){let s=0;if(1===n){for(;e.isCont()&&(s=e.head(),Tr.isSpace(s));)e=e.step();if(e.isCont())if(40===s)e=e.step(),n=4;else if(123===s)r=r||t.recordBuilder(),i=t.parseRecord(e,r),n=3;else if(91===s)r=r||t.recordBuilder(),i=t.parseMarkup(e,r),n=3;else if(Tr.isIdentStartChar(s))i=t.parseIdent(e),n=2;else if(34===s||39===s)i=t.parseString(e),n=2;else if(96===s)i=t.parseRawString(e),n=2;else if(45===s||s>=48&&s<=57)i=t.parseNumber(e),n=2;else if(37===s)i=t.parseData(e),n=2;else{if(36!==s)return void 0===r?Se.done(t.extant()):Se.done(r.bind());i=t.parseSelector(e),n=2}else if(e.isDone())return void 0===r?Se.done(t.extant()):Se.done(r.bind())}if(2===n){for(;i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())return(r=r||t.valueBuilder()).push(t.item(i.bind())),Se.done(r.bind());if(i.isError())return i.asError()}if(3===n){for(;i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())return Se.done(r.bind());if(i.isError())return i.asError()}if(4===n){for(void 0===i&&(i=t.parseBlockExpression(e));i.isCont()&&!e.isEmpty();)i=i.feed(e);if(i.isDone())n=5;else if(i.isError())return i.asError()}if(5===n){for(;e.isCont()&&(s=e.head(),Tr.isWhitespace(s));)e=e.step();if(e.isCont())return 41===s?(e=e.step(),(r=r||t.valueBuilder()).push(t.item(i.bind())),Se.done(r.bind())):Se.error(ce.expected(41,e));if(e.isDone())return Se.error(ce.expected(41,e))}return new ri(t,r,i,n)}}class ii extends Se{constructor(e,t,r,i,n){super(),this.recon=e,this.builder=t,this.selector=r,this.valueParser=i,this.step=n}feed(e){return ii.parse(e,this.recon,this.builder,this.selector,this.valueParser,this.step)}static parse(e,t,r,i,n,s=1){let o=0;if(1===s){for(;e.isCont()&&(o=e.head(),Tr.isSpace(o));)e=e.step();if(e.isCont()&&36===o)e=e.step(),i=i||t.selector(),s=2;else if(e.isDone())return Se.error(ce.expected(36,e))}if(2===s)if(e.isCont())o=e.head(),91===o?(e=e.step(),s=8):64===o?(e=e.step(),s=7):58===o?(e=e.step(),s=6):42===o?(e=e.step(),s=5):35===o?(e=e.step(),s=4):s=3;else if(e.isDone())return Se.error(ce.unexpected(e));for(;;){if(3===s){for(void 0===n&&(n=t.parseLiteral(e,t.valueBuilder()));n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone())i=t.get(i,n.bind()),n=void 0,s=10;else if(n.isError())return n.asError()}if(4===s){for(void 0===n&&(n=t.parseInteger(e));n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone())i=t.value(t.getItem(i,n.bind())),n=void 0,s=10;else if(n.isError())return n.asError()}if(5===s&&(e.isCont()?(o=e.head(),58===o?(e=e.step(),i=t.keys(i),s=10):42===o?(e=e.step(),i=t.descendants(i),s=10):(i=t.children(i),s=10)):e.isDone()&&(i=t.children(i),s=10)),6===s)if(e.isCont()){if(o=e.head(),42!==o)return Se.error(ce.expected(42,e));e=e.step(),i=t.values(i),s=10}else if(e.isDone())return Se.error(ce.expected(42,e));if(7===s){for(void 0===n&&(n=t.parseIdent(e));n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone())i=t.getAttr(i,n.bind()),n=void 0,s=10;else if(n.isError())return n.asError()}if(8===s){for(void 0===n&&(n=t.parseBlockExpression(e));n.isCont()&&!e.isEmpty();)n=n.feed(e);if(n.isDone())s=9;else if(n.isError())return n.asError()}if(9===s){for(;e.isCont()&&(o=e.head(),Tr.isSpace(o));)e=e.step();if(e.isCont()){if(93!==o)return Se.error(ce.expected(93,e));e=e.step(),i=t.filter(i,n.bind()),n=void 0,s=10}else if(e.isDone())return Se.error(ce.expected(93,e))}if(10===s)if(e.isCont()){if(o=e.head(),91===o){e=e.step(),s=8;continue}if(35===o){e=e.step(),s=4;continue}if(46!==o)return void 0!==r?(r.push(t.item(i)),Se.done(r.bind())):Se.done(i);e=e.step(),s=11}else if(e.isDone())return void 0!==r?(r.push(t.item(i)),Se.done(r.bind())):Se.done(i);if(11===s){if(e.isCont()){if(o=e.head(),64===o){e=e.step(),s=7;continue}if(58===o){e=e.step(),s=6;continue}if(42===o){e=e.step(),s=5;continue}s=3;continue}if(e.isDone())return Se.error(ce.unexpected(e))}break}return new ii(t,r,i,n,s)}}class ni extends class{parseBlock(e){return Pr.parse(e,this)}parseAttr(e){return Dr.parse(e,this)}parseBlockItem(e){return qr.parse(e,this)}parseInlineItem(e){return Ir.parse(e,this)}parseRecord(e,t){return Vr.parse(e,this,t)}parseMarkup(e,t){return Nr.parse(e,this,t)}parseData(e){return zr.parse(e,this)}parseIdent(e){return Mr.parse(e,this)}parseString(e){return jr.parse(e,this)}parseRawString(e){return Lr.parse(e,this)}parseNumber(e){return Fr.parse(e,this)}parseInteger(e){return Fr.parseInteger(e,this)}parseBlockExpression(e,t){return this.parseLambdaFunc(e,t)}parseLambdaFunc(e,t){return Wr.parse(e,this,t)}parseConditionalOperator(e,t){return Rr.parse(e,this,t)}parseOrOperator(e,t){return Hr.parse(e,this,t)}parseAndOperator(e,t){return Kr.parse(e,this,t)}parseBitwiseOrOperator(e,t){return _r.parse(e,this,t)}parseBitwiseXorOperator(e,t){return Gr.parse(e,this,t)}parseBitwiseAndOperator(e,t){return Qr.parse(e,this,t)}parseComparisonOperator(e,t){return Zr.parse(e,this,t)}parseAttrExpression(e,t){return Xr.parse(e,this,t)}parseAdditiveOperator(e,t){return $r.parse(e,this,t)}parseMultiplicativeOperator(e,t){return Yr.parse(e,this,t)}parsePrefixOperator(e,t){return Jr.parse(e,this,t)}parseInvokeOperator(e,t){return ei.parse(e,this,t)}parsePrimary(e,t){return ti.parse(e,this,t)}parseLiteral(e,t){return ri.parse(e,this,t)}parseSelector(e,t){return ii.parse(e,this,t)}blockParser(){return new Pr(this)}parseBlockString(e){let t=ue.stringInput(e);for(;t.isCont()&&Tr.isWhitespace(t.head());)t=t.step();let r=this.parseBlock(t);if(r.isDone())for(;t.isCont()&&Tr.isWhitespace(t.head());)t=t.step();return t.isCont()&&!r.isError()&&(r=Se.error(ce.unexpected(t))),r.bind()}}{isDistinct(e){return e.isDistinct()}item(e){return e}value(e){return e.toValue()}attr(e,t){return 1===arguments.length?ot.of(e):ot.of(e,t)}slot(e,t){return 1===arguments.length?nt.of(e):nt.of(e,t)}valueBuilder(){return ht.builder()}recordBuilder(){return lt.create()}dataOutput(){return mt.output()}textOutput(){return yt.output()}ident(e){if(e instanceof yt){const t=e.stringValue();if("true"===t)return Ot.from(!0);if("false"===t)return Ot.from(!1)}return e}num(e){if("number"==typeof e)return vt.from(e);if("string"==typeof e)return vt.from(+e);throw new TypeError(""+e)}uint32(e){return vt.uint32(e)}uint64(e){return vt.uint64(e)}bool(e){return Ot.from(e)}selector(){return nr.identity()}extant(){return ht.extant()}absent(){return ht.absent()}conditional(e,t,r){return e.conditional(t,r)}or(e,t){return new Mt(e,t)}and(e,t){return new jt(e,t)}bitwiseOr(e,t){return new Lt(e,t)}bitwiseXor(e,t){return new Ft(e,t)}bitwiseAnd(e,t){return new Bt(e,t)}lt(e,t){return new Ut(e,t)}le(e,t){return new Wt(e,t)}eq(e,t){return new Rt(e,t)}ne(e,t){return new Ht(e,t)}ge(e,t){return new Kt(e,t)}gt(e,t){return new _t(e,t)}plus(e,t){return new Gt(e,t)}minus(e,t){return new Qt(e,t)}times(e,t){return new Zt(e,t)}divide(e,t){return new Xt(e,t)}modulo(e,t){return new $t(e,t)}not(e){return new Yt(e)}bitwiseNot(e){return new Jt(e)}negative(e){return e instanceof vt?e.negative():new er(e)}positive(e){return new tr(e)}invoke(e,t){return new rr(e,t)}lambda(e,t){return e.lambda(t)}get(e,t){return e.get(t)}getAttr(e,t){return e.getAttr(t)}getItem(e,t){return e.getItem(t)}children(e){return nr.literal(e).children()}descendants(e){return nr.literal(e).descendants()}keys(e){return nr.literal(e).keys()}values(e){return nr.literal(e).values()}filter(e,t){return e.filter(t)}}class si extends oe{constructor(e,t,r,i,n){super(),this.recon=e,this.key=t,this.value=r,this.part=i,this.step=n}pull(e){return si.write(e,this.recon,this.key,this.value,this.part,this.step)}static sizeOf(e,t,r){let i=0;return i+=1,i+=e.sizeOfValue(t),e.isExtant(e.item(r))||(i+=1,i+=e.sizeOfBlockValue(r),i+=1),i}static write(e,t,r,i,n,s=1){if(1===s&&e.isCont()&&(e=e.write(64),s=2),2===s)if((n=void 0===n?t.writeValue(e,r):n.pull(e)).isDone()){if(n=void 0,t.isExtant(t.item(i)))return oe.end();s=3}else if(n.isError())return n.asError();if(3===s&&e.isCont()&&(e=e.write(40),s=4),4===s)if((n=void 0===n?t.writeBlockValue(e,i):n.pull(e)).isDone())n=void 0,s=5;else if(n.isError())return n.asError();return 5===s&&e.isCont()?(e=e.write(41),oe.end()):e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new si(t,r,i,n,s)}}class oi extends oe{constructor(e,t,r,i,n){super(),this.recon=e,this.key=t,this.value=r,this.part=i,this.step=n}pull(e){return oi.write(e,this.recon,this.key,this.value,this.part,this.step)}static sizeOf(e,t,r){let i=0;return i+=e.sizeOfValue(t),i+=1,e.isExtant(e.item(r))||(i+=e.sizeOfValue(r)),i}static write(e,t,r,i,n,s=1){if(1===s)if((n=void 0===n?t.writeValue(e,r):n.pull(e)).isDone())n=void 0,s=2;else if(n.isError())return n.asError();if(2===s&&e.isCont()){if(e=e.write(58),t.isExtant(t.item(i)))return oe.end();s=3}if(3===s){if((n=void 0===n?t.writeValue(e,i):n.pull(e)).isDone())return oe.end();if(n.isError())return n.asError()}return e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new oi(t,r,i,n,s)}}class ai extends oe{constructor(e,t,r,i,n,s,o,a,u,h,l,c){super(),this.recon=e,this.items=t,this.inBlock=r,this.inMarkup=i,this.inBraces=n,this.inBrackets=s,this.first=o,this.markupSafe=a,this.item=u,this.next=h,this.part=l,this.step=c}pull(e){return ai.write(e,this.recon,this.items,this.inBlock,this.inMarkup,this.inBraces,this.inBrackets,this.first,this.markupSafe,this.item,this.next,this.part,this.step)}static sizeOf(e,t,r,i){let n,s=0,o=!1,a=!1,u=!0,h=!0;for(;void 0!==n||t.hasNext();){let l;void 0===n?l=t.next().value:(l=n,n=void 0),t.hasNext()&&(n=t.next().value),e.isExpression(l)&&(h=!1),a&&e.isAttr(l)&&(o&&(s+=1,o=!1),s+=1,a=!1),e.isAttr(l)?(o?(s+=1,o=!1):a&&(s+=1,a=!1),s+=e.sizeOfItem(l),u=!1):a&&e.isText(l)?(o&&(s+=1,o=!1),s+=e.sizeOfMarkupText(l)):o?(u?u=!1:s+=1,s+=ai.sizeOfBlockItem(e,l)):a?e.isRecord(l)&&e.isMarkupSafe(e.items(l))?(s+=e.sizeOfBlock(e.items(l),!1,!0),void 0!==n&&e.isText(n)?(s+=e.sizeOfMarkupText(n),n=void 0):void 0===n||e.isAttr(n)?(s+=1,a=!1):(s+=1,o=!0,u=!0)):(s+=1,s+=e.sizeOfItem(l),o=!0,u=!1):!h||!e.isText(l)||void 0===n||e.isField(n)||e.isText(n)||e.isBool(n)?r&&!o?(u?u=!1:s+=1,s+=ai.sizeOfBlockItem(e,l)):i&&e.isText(l)&&void 0===n?(s+=1,s+=e.sizeOfMarkupText(l),s+=1):!i&&e.isValue(l)&&!e.isRecord(l)&&(!u&&void 0===n||void 0!==n&&e.isAttr(n))?(!u&&(e.isText(l)&&e.isIdent(l)||e.isNum(l)||e.isBool(l))&&(s+=1),s+=e.sizeOfItem(l)):(s+=1,s+=e.sizeOfItem(l),o=!0,u=!1):(s+=1,s+=e.sizeOfMarkupText(l),a=!0)}return o&&(s+=1),a&&(s+=1),s}static sizeOfBlockItem(e,t){let r=0;return e.isField(t)?r+=e.sizeOfSlot(e.key(t),e.value(t)):r+=e.sizeOfItem(t),r}static write(e,t,r,i,n,s=!1,o=!1,a=!0,u=!0,h,l,c,d=1){for(;;){if(1===d){if(void 0===l&&!r.hasNext()){d=10;break}void 0===l?h=r.next().value:(h=l,l=void 0),r.hasNext()&&(l=r.next().value),t.isExpression(h)&&(u=!1),d=2}if(2===d&&e.isCont()&&(o&&t.isAttr(h)?(s&&(e=e.write(125),s=!1),d=3):d=4),3===d&&e.isCont()&&(e=e.write(93),o=!1,d=4),4===d&&e.isCont()&&(t.isAttr(h)?(s?(e=e.write(125),s=!1):o&&(e=e.write(93),o=!1),c=t.writeItem(e,h),a=!1,d=7):o&&t.isText(h)?(s&&(e=e.write(125),s=!1),c=t.writeMarkupText(e,h),d=7):s?(a?a=!1:e=e.write(44),c=ai.writeBlockItem(e,t,h),d=7):o?t.isRecord(h)&&t.isMarkupSafe(t.items(h))?(c=t.writeBlock(e,t.items(h),!1,!0),d=5):(e=e.write(123),c=t.writeItem(e,h),s=!0,a=!1,d=7):!u||!t.isText(h)||void 0===l||t.isField(l)||t.isText(l)||t.isBool(l)?i&&!s?(a?a=!1:e=e.write(44),c=ai.writeBlockItem(e,t,h),d=7):n&&t.isText(h)&&void 0===l?(e=e.write(91),c=t.writeMarkupText(e,h),d=8):!n&&t.isValue(h)&&!t.isRecord(h)&&(!a&&void 0===l||void 0!==l&&t.isAttr(l))?(!a&&(t.isText(h)&&t.isIdent(h)||t.isNum(h)||t.isBool(h))&&(e=e.write(32)),c=t.writeItem(e,h),d=7):(e=e.write(123),c=t.writeItem(e,h),s=!0,a=!1,d=7):(e=e.write(91),c=t.writeMarkupText(e,h),o=!0,d=7)),5===d)if((c=c.pull(e)).isDone())c=void 0,d=6;else if(c.isError())return c.asError();if(6===d&&e.isCont()){if(void 0===l||!t.isText(l)){if(void 0===l||t.isAttr(l)){e=e.write(93),o=!1,d=1;continue}e=e.write(123),s=!0,a=!0,d=1;continue}c=t.writeMarkupText(e,l),l=void 0,d=7}if(7===d){if((c=c.pull(e)).isDone()){c=void 0,d=1;continue}if(c.isError())return c.asError()}if(8===d)if((c=c.pull(e)).isDone())c=void 0,d=9;else if(c.isError())return c.asError();if(9!==d||!e.isCont())break;e=e.write(93),d=1}if(10===d&&(s?e.isCont()&&(e=e.write(125),d=11):d=11),11===d){if(!o)return oe.end();if(e.isCont())return e=e.write(93),oe.end()}return e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new ai(t,r,i,n,s,o,a,u,h,l,c,d)}static writeBlockItem(e,t,r){return t.isField(r)?t.writeSlot(e,t.key(r),t.value(r)):t.writeItem(e,r)}}class ui extends oe{constructor(e,t,r,i,n,s,o,a){super(),this.recon=e,this.items=t,this.inParens=r,this.first=i,this.item=n,this.next=s,this.part=o,this.step=a}pull(e){return ui.write(e,this.recon,this.items,this.inParens,this.first,this.item,this.next,this.part,this.step)}static sizeOf(e,t){let r,i=0,n=!1,s=!0;for(;void 0!==r||t.hasNext();){let o;void 0===r?o=t.next().value:(o=r,r=void 0),t.hasNext()&&(r=t.next().value),n||s||(i+=1),e.isAttr(o)?(n&&(i+=1,n=!1),i+=e.sizeOfItem(o),s=!1):n?(s?s=!1:i+=1,i+=e.sizeOfBlockItem(o)):e.isValue(o)&&!e.isRecord(o)&&(!s&&void 0===r||void 0!==r&&e.isAttr(r))?i+=e.sizeOfItem(o):(i+=1,i+=e.sizeOfItem(o),n=!0,s=!1)}return n&&(i+=1),i}static write(e,t,r,i=!1,n=!0,s,o,a,u=1){for(;;){if(1===u){if(void 0===o&&!r.hasNext()){u=5;break}void 0===o?s=r.next().value:(s=o,o=void 0),r.hasNext()&&(o=r.next().value),u=2}if(2===u&&e.isCont()&&(i||n||(e=e.write(32)),u=3),3===u&&e.isCont()&&(t.isAttr(s)?(i&&(e=e.write(41),i=!1),a=t.writeItem(e,s),n=!1,u=4):i?(n?n=!1:e=e.write(44),a=t.writeBlockItem(e,s),u=4):t.isValue(s)&&!t.isRecord(s)&&(!n&&void 0===o||void 0!==o&&t.isAttr(o))?(a=t.writeItem(e,s),u=4):(e=e.write(40),a=t.writeItem(e,s),i=!0,n=!1,u=4)),4===u){if((a=a.pull(e)).isDone()){a=void 0,u=1;continue}if(a.isError())return a.asError()}break}if(5===u){if(!i)return oe.end();if(e.isCont())return e=e.write(41),oe.end()}return e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new ui(t,r,i,n,s,o,a,u)}}class hi extends oe{constructor(e,t,r,i){super(),this.text=e,this.index=t,this.escape=r,this.step=i}pull(e){return hi.write(e,this.text,this.index,this.escape,this.step)}static sizeOf(e){let t=0;for(let r=0,i=e.length;r<i;r=u.offsetByCodePoints(e,r,1)){let i=e.codePointAt(r);void 0===i&&(i=e.charCodeAt(r)),t+=36===i||64===i||91===i||92===i||93===i||123===i||125===i||8===i||12===i||10===i||13===i||9===i?2:i<32?6:Re.sizeOf(i)}return t}static write(e,t,r=0,i=0,n=1){const s=t.length;for(;e.isCont();)if(1===n){if(!(r<s))return oe.end();{let s=t.codePointAt(r);void 0===s&&(s=t.charCodeAt(r)),r=u.offsetByCodePoints(t,r,1),36===s||64===s||91===s||92===s||93===s||123===s||125===s?(e=e.write(92),i=s,n=2):8===s?(e=e.write(92),i=98,n=2):12===s?(e=e.write(92),i=102,n=2):10===s?(e=e.write(92),i=110,n=2):13===s?(e=e.write(92),i=114,n=2):9===s?(e=e.write(92),i=116,n=2):s<32?(e=e.write(92),i=s,n=3):e=e.write(s)}}else 2===n?(e=e.write(i),i=0,n=1):3===n?(e=e.write(117),n=4):4===n?(e=e.write(Be.uppercase.encodeDigit(i>>>12&15)),n=5):5===n?(e=e.write(Be.uppercase.encodeDigit(i>>>8&15)),n=6):6===n?(e=e.write(Be.uppercase.encodeDigit(i>>>4&15)),n=7):7===n&&(e=e.write(Be.uppercase.encodeDigit(15&i)),i=0,n=1);return e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new hi(t,r,i,n)}}class li extends oe{constructor(e,t,r){super(),this.array=e,this.part=t,this.step=r}pull(e){return li.write(e,this.array,this.part,this.step)}static sizeOf(e){return 1+(Math.floor(4*e/3)+3&-4)}static write(e,t,r,i=1){if(1===i&&e.isCont()&&(e=e.write(37),i=2),2===i){if((r=void 0===r?Xe.standard().writeUint8Array(e,t):r.pull(e)).isDone())return r=void 0,oe.end();if(r.isError())return r.asError()}return e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new li(t,r,i)}}class ci extends oe{constructor(e,t){super(),this.ident=e,this.index=t}pull(e){return ci.write(e,this.ident,this.index)}static sizeOf(e){return Re.sizeOf(e)}static write(e,t,r=0){let i;const n=t.length;if(0===n)return oe.error(new se("empty identifier"));for(0===r&&e.isCont()&&(i=t.codePointAt(0),void 0===i&&(i=t.charCodeAt(0)),Tr.isIdentStartChar(i)&&(e=e.write(i),r=u.offsetByCodePoints(t,0,1)));r<n&&e.isCont();){if(i=t.codePointAt(r),void 0===i&&(i=t.charCodeAt(r)),!Tr.isIdentChar(i))return oe.error(new se("invalid identifier"));e=e.write(i),r=u.offsetByCodePoints(t,r,1)}return r>=n?oe.end():e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new ci(t,r)}}class di extends oe{constructor(e,t,r,i){super(),this.string=e,this.index=t,this.escape=r,this.step=i}pull(e){return di.write(e,this.string,this.index,this.escape,this.step)}static sizeOf(e){let t=0;t+=1;for(let r=0,i=e.length;r<i;r=u.offsetByCodePoints(e,r,1)){let i=e.codePointAt(r);void 0===i&&(i=e.charCodeAt(r)),t+=34===i||92===i||8===i||12===i||10===i||13===i||9===i?2:i<32?6:Re.sizeOf(i)}return t+=1,t}static write(e,t,r=0,i=0,n=1){1===n&&e.isCont()&&(e=e.write(34),n=2);const s=t.length;for(;n>=2&&n<=8&&e.isCont();)if(2===n){if(!(r<s)){n=9;break}{let s=t.codePointAt(r);void 0===s&&(s=t.charCodeAt(r)),r=u.offsetByCodePoints(t,r,1),34===s||92===s?(e=e.write(92),i=s,n=3):8===s?(e=e.write(92),i=98,n=3):12===s?(e=e.write(92),i=102,n=3):10===s?(e=e.write(92),i=110,n=3):13===s?(e=e.write(92),i=114,n=3):9===s?(e=e.write(92),i=116,n=3):s<32?(e=e.write("\\\\"),i=s,n=4):e=e.write(s)}}else 3===n?(e=e.write(i),i=0,n=2):4===n?(e=e.write(117),n=5):5===n?(e=e.write(Be.uppercase.encodeDigit(i>>>12&15)),n=6):6===n?(e=e.write(Be.uppercase.encodeDigit(i>>>8&15)),n=7):7===n?(e=e.write(Be.uppercase.encodeDigit(i>>>4&15)),n=8):8===n&&(e=e.write(Be.uppercase.encodeDigit(15&i)),i=0,n=2);return 9===n&&e.isCont()?(e=e.write(34),oe.end()):e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new di(t,r,i,n)}}class pi extends oe{constructor(e,t,r,i,n){super(),this.recon=e,this.bindings=t,this.template=r,this.part=i,this.step=n}pull(e){return pi.write(e,this.recon,this.bindings,this.template,this.part,this.step)}static sizeOf(e,t,r){let i=0;return i+=e.sizeOfPrimary(t),i+=4,i+=e.sizeOfValue(r),i}static write(e,t,r,i,n,s=1){if(1===s)if((n=void 0===n?t.writePrimary(e,r):n.pull(e)).isDone())n=void 0,s=2;else if(n.isError())return n.asError();if(2===s&&e.isCont()&&(e=e.write(32),s=3),3===s&&e.isCont()&&(e=e.write(61),s=4),4===s&&e.isCont()&&(e=e.write(62),s=5),5===s&&e.isCont()&&(e=e.write(32),s=6),6===s){if((n=void 0===n?t.writeValue(e,i):n.pull(e)).isDone())return oe.end();if(n.isError())return n.asError()}return e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new pi(t,r,i,n,s)}}class fi extends oe{constructor(e,t,r,i,n,s,o){super(),this.recon=e,this.ifTerm=t,this.thenTerm=r,this.elseTerm=i,this.precedence=n,this.part=s,this.step=o}pull(e){return fi.write(e,this.recon,this.ifTerm,this.thenTerm,this.elseTerm,this.precedence,this.part,this.step)}static sizeOf(e,t,r,i,n){let s=0;return e.precedence(t)>0&&e.precedence(t)<=n?(s+=1,s+=e.sizeOfItem(t),s+=1):s+=e.sizeOfItem(t),s+=3,s+=e.sizeOfItem(r),s+=3,s+=e.sizeOfItem(i),s}static write(e,t,r,i,n,s,o,a=1){if(1===a&&(t.precedence(r)>0&&t.precedence(r)<=s?e.isCont()&&(e=e.write(40),a=2):a=2),2===a)if((o=void 0===o?t.writeItem(e,r):o.pull(e)).isDone())o=void 0,a=3;else if(o.isError())return o.asError();if(3===a&&(t.precedence(r)>0&&t.precedence(r)<=s?e.isCont()&&(e=e.write(41),a=4):a=4),4===a&&e.isCont()&&(e=e.write(32),a=5),5===a&&e.isCont()&&(e=e.write(63),a=6),6===a&&e.isCont()&&(e=e.write(32),a=7),7===a)if((o=void 0===o?t.writeItem(e,i):o.pull(e)).isDone())o=void 0,a=8;else if(o.isError())return o.asError();if(8===a&&e.isCont()&&(e=e.write(32),a=9),9===a&&e.isCont()&&(e=e.write(58),a=10),10===a&&e.isCont()&&(e=e.write(32),a=11),11===a){if((o=void 0===o?t.writeItem(e,n):o.pull(e)).isDone())return oe.end();if(o.isError())return o.asError()}return e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new fi(t,r,i,n,s,o,a)}}class wi extends oe{constructor(e,t,r,i,n,s,o){super(),this.recon=e,this.lhs=t,this.operator=r,this.rhs=i,this.precedence=n,this.part=s,this.step=o}pull(e){return wi.write(e,this.recon,this.lhs,this.operator,this.rhs,this.precedence,this.part,this.step)}static sizeOf(e,t,r,i,n){let s=0;return e.precedence(t)<n?(s+=1,s+=e.sizeOfItem(t),s+=1):s+=e.sizeOfItem(t),s+=1,s+=Re.sizeOf(r),s+=1,e.precedence(i)<n?(s+=1,s+=e.sizeOfItem(i),s+=1):s+=e.sizeOfItem(i),s}static write(e,t,r,i,n,s,o,a=1){if(1===a&&(t.precedence(r)<s?e.isCont()&&(e=e.write(40),a=2):a=2),2===a)if((o=void 0===o?t.writeItem(e,r):o.pull(e)).isDone())o=void 0,a=3;else if(o.isError())return o.asError();if(3===a&&(t.precedence(r)<s?e.isCont()&&(e=e.write(41),a=4):a=4),4===a&&e.isCont()&&(e=e.write(32),a=5),5===a)if((o=void 0===o?ue.writeString(e,i):o.pull(e)).isDone())o=void 0,a=6;else if(o.isError())return o.asError();if(6===a&&e.isCont()&&(e=e.write(32),a=7),7===a&&(t.precedence(n)<s?e.isCont()&&(e=e.write(40),a=8):a=8),8===a)if((o=void 0===o?t.writeItem(e,n):o.pull(e)).isDone())o=void 0,a=9;else if(o.isError())return o.asError();if(9===a){if(!(t.precedence(n)<s))return oe.end();if(e.isCont())return e=e.write(41),oe.end()}return e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new wi(t,r,i,n,s,o,a)}}class mi extends oe{constructor(e,t,r,i,n,s){super(),this.recon=e,this.operator=t,this.rhs=r,this.precedence=i,this.part=n,this.step=s}pull(e){return mi.write(e,this.recon,this.operator,this.rhs,this.precedence,this.part,this.step)}static sizeOf(e,t,r,i){let n=0;return n+=Re.sizeOf(t),e.precedence(r)<i?(n+=1,n+=e.sizeOfItem(r),n+=1):n+=e.sizeOfItem(r),n}static write(e,t,r,i,n,s,o=1){if(1===o)if((s=void 0===s?ue.writeString(e,r):s.pull(e)).isDone())s=void 0,o=2;else if(s.isError())return s.asError();if(2===o&&(t.precedence(i)<n?e.isCont()&&(e=e.write(40),o=3):o=3),3===o)if((s=void 0===s?t.writeItem(e,i):s.pull(e)).isDone())s=void 0,o=4;else if(s.isError())return s.asError();if(4===o){if(!(t.precedence(i)<n))return oe.end();if(e.isCont())return e=e.write(41),oe.end()}return e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new mi(t,r,i,n,s,o)}}class gi extends oe{constructor(e,t,r,i,n){super(),this.recon=e,this.func=t,this.args=r,this.part=i,this.step=n}pull(e){return gi.write(e,this.recon,this.func,this.args,this.part,this.step)}static sizeOf(e,t,r){let i=0;return i+=e.sizeOfValue(t),i+=1,i+=e.sizeOfBlockValue(r),i+=1,i}static write(e,t,r,i,n,s=1){if(1===s)if((n=void 0===n?t.writeValue(e,r):n.pull(e)).isDone())n=void 0,s=2;else if(n.isError())return n.asError();if(2===s&&e.isCont()&&(e=e.write(40),s=3),3===s)if((n=void 0===n?t.writeBlockValue(e,i):n.pull(e)).isDone())n=void 0,s=4;else if(n.isError())return n.asError();return 4===s&&e.isCont()?(e=e.write(41),oe.end()):e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new gi(t,r,i,n,s)}}class yi extends oe{constructor(e,t,r,i,n){super(),this.recon=e,this.item=t,this.then=r,this.part=i,this.step=n}pull(e){return yi.write(e,this.recon,this.item,this.then,this.part,this.step)}static sizeOf(e,t,r){let i=0;return e.precedence(t)<e.precedence(e.item(r))?(i+=1,i+=e.sizeOfItem(t),i+=1):i+=e.sizeOfItem(t),i+=e.sizeOfThen(r),i}static write(e,t,r,i,n,s=1){if(1===s&&(t.precedence(r)<t.precedence(t.item(i))?e.isCont()&&(e=e.write(40),s=2):s=2),2===s)if((n=void 0===n?t.writeItem(e,r):n.pull(e)).isDone())n=void 0,s=3;else if(n.isError())return n.asError();return 3===s&&(t.precedence(r)<t.precedence(t.item(i))?e.isCont()&&(e=e.write(41),s=4):s=4),4===s?t.writeThen(e,i):e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new yi(t,r,i,n,s)}}class bi extends oe{constructor(e,t,r,i,n){super(),this.recon=e,this.key=t,this.then=r,this.part=i,this.step=n}pull(e){return bi.write(e,this.recon,this.key,this.then,this.part,this.step)}static sizeOf(e,t,r){let i=1;return e.isRecord(e.item(t))?(i+=1,i+=e.sizeOfBlockValue(t),i+=1):i+=e.sizeOfValue(t),i+=e.sizeOfThen(r),i}static write(e,t,r,i,n,s=1){if(1===s&&e.isCont()?(e=e.write(36),s=3):2===s&&e.isCont()&&(e=e.write(46),s=3),3===s&&(t.isRecord(t.item(r))?e.isCont()&&(e=e.write(123),s=4):s=4),4===s)if((n=void 0===n?t.isRecord(t.item(r))?t.writeBlockValue(e,r):t.writeValue(e,r):n.pull(e)).isDone())n=void 0,s=5;else if(n.isError())return n.asError();return 5===s&&(t.isRecord(t.item(r))?e.isCont()&&(e=e.write(125),s=6):s=6),6===s?t.writeThen(e,i):e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new bi(t,r,i,n,s)}static writeThen(e,t,r,i){return bi.write(e,t,r,i,void 0,2)}}class vi extends oe{constructor(e,t,r,i,n){super(),this.recon=e,this.key=t,this.then=r,this.part=i,this.step=n}pull(e){return vi.write(e,this.recon,this.key,this.then,this.part,this.step)}static sizeOf(e,t,r){let i=2;return i+=e.sizeOfValue(t),i+=e.sizeOfThen(r),i}static write(e,t,r,i,n,s=1){if(1===s&&e.isCont()?(e=e.write(36),s=3):2===s&&e.isCont()&&(e=e.write(46),s=3),3===s&&e.isCont()&&(e=e.write(64),s=4),4===s){if((n=void 0===n?t.writeValue(e,r):n.pull(e)).isDone())return t.writeThen(e,i);if(n.isError())return n.asError()}return e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new vi(t,r,i,n,s)}static writeThen(e,t,r,i){return vi.write(e,t,r,i,void 0,2)}}class xi extends oe{constructor(e,t,r,i,n){super(),this.recon=e,this.index=t,this.then=r,this.part=i,this.step=n}pull(e){return xi.write(e,this.recon,this.index,this.then,this.part,this.step)}static sizeOf(e,t,r){let i=2;return i+=e.sizeOfValue(t),i+=e.sizeOfThen(r),i}static sizeOfThen(e,t,r){let i=1;return i+=e.sizeOfValue(t),i+=e.sizeOfThen(r),i}static write(e,t,r,i,n,s=1){if(1===s&&e.isCont()&&(e=e.write(36),s=2),2===s&&e.isCont()&&(e=e.write(35),s=3),3===s){if((n=void 0===n?t.writeValue(e,r):n.pull(e)).isDone())return t.writeThen(e,i);if(n.isError())return n.asError()}return e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new xi(t,r,i,n,s)}static writeThen(e,t,r,i){return xi.write(e,t,r,i,void 0,2)}}class Oi extends oe{constructor(e,t,r){super(),this.recon=e,this.then=t,this.step=r}pull(e){return Oi.write(e,this.recon,this.then,this.step)}static sizeOf(e,t){let r=3;return r+=e.sizeOfThen(t),r}static write(e,t,r,i=1){return 1===i&&e.isCont()?(e=e.write(36),i=3):2===i&&e.isCont()&&(e=e.write(46),i=3),3===i&&e.isCont()&&(e=e.write(42),i=4),4===i&&e.isCont()?(e=e.write(58),t.writeThen(e,r)):e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new Oi(t,r,i)}static writeThen(e,t,r){return Oi.write(e,t,r,2)}}class Ei extends oe{constructor(e,t,r){super(),this.recon=e,this.then=t,this.step=r}pull(e){return Ei.write(e,this.recon,this.then,this.step)}static sizeOf(e,t){let r=3;return r+=e.sizeOfThen(t),r}static write(e,t,r,i=1){return 1===i&&e.isCont()?(e=e.write(36),i=3):2===i&&e.isCont()&&(e=e.write(46),i=3),3===i&&e.isCont()&&(e=e.write(58),i=4),4===i&&e.isCont()?(e=e.write(42),t.writeThen(e,r)):e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new Ei(t,r,i)}static writeThen(e,t,r){return Ei.write(e,t,r,2)}}class Ci extends oe{constructor(e,t,r){super(),this.recon=e,this.then=t,this.step=r}pull(e){return Ci.write(e,this.recon,this.then,this.step)}static sizeOf(e,t){let r=2;return r+=e.sizeOfThen(t),r}static write(e,t,r,i=1){return 1===i&&e.isCont()?(e=e.write(36),i=3):2===i&&e.isCont()&&(e=e.write(46),i=3),3===i&&e.isCont()?(e=e.write(42),t.writeThen(e,r)):e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new Ci(t,r,i)}static writeThen(e,t,r){return Ci.write(e,t,r,2)}}class Ai extends oe{constructor(e,t,r){super(),this.recon=e,this.then=t,this.step=r}pull(e){return Ai.write(e,this.recon,this.then,this.step)}static sizeOf(e,t){let r=3;return r+=e.sizeOfThen(t),r}static write(e,t,r,i=1){return 1===i&&e.isCont()?(e=e.write(36),i=3):2===i&&e.isCont()&&(e=e.write(46),i=3),3===i&&e.isCont()&&(e=e.write(42),i=4),4===i&&e.isCont()?(e=e.write(42),t.writeThen(e,r)):e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new Ai(t,r,i)}static writeThen(e,t,r){return Ai.write(e,t,r,2)}}class Si extends oe{constructor(e,t,r,i,n){super(),this.recon=e,this.predicate=t,this.then=r,this.part=i,this.step=n}pull(e){return Si.write(e,this.recon,this.predicate,this.then,this.part,this.step)}static sizeOf(e,t,r){let i=2;return i+=e.sizeOfValue(t),i+=1,i+=e.sizeOfThen(r),i}static sizeOfThen(e,t,r){let i=1;return i+=e.sizeOfValue(t),i+=1,i+=e.sizeOfThen(r),i}static write(e,t,r,i,n,s=1){if(1===s&&e.isCont()&&(e=e.write(36),s=2),2===s&&e.isCont()&&(e=e.write(91),s=3),3===s)if((n=void 0===n?t.writeValue(e,r):n.pull(e)).isDone())n=void 0,s=4;else if(n.isError())return n.asError();return 4===s&&e.isCont()?(e=e.write(93),t.writeThen(e,i)):e.isDone()?oe.error(new se("truncated")):e.isError()?oe.error(e.trap()):new Si(t,r,i,n,s)}static writeThen(e,t,r,i){return Si.write(e,t,r,i,void 0,2)}}class ki extends class{sizeOfAttr(e,t){return si.sizeOf(this,e,t)}writeAttr(e,t,r){return si.write(e,this,t,r)}sizeOfSlot(e,t){return oi.sizeOf(this,e,t)}writeSlot(e,t,r){return oi.write(e,this,t,r)}sizeOfBlock(e,t,r){if(3===arguments.length)return ai.sizeOf(this,e,t,r);{const t=this.items(e);return t.hasNext()?ai.sizeOf(this,t,this.isBlockSafe(this.items(e)),!1):2}}writeBlock(e,t,r,i){if(4===arguments.length)return ai.write(e,this,t,r,i);{const r=this.items(t);return r.hasNext()?ai.write(e,this,r,this.isBlockSafe(this.items(t)),!1):ue.writeString(e,"{}")}}sizeOfRecord(e){const t=this.items(e);return t.hasNext()?ai.sizeOf(this,t,!1,!1):2}writeRecord(e,t){const r=this.items(t);return r.hasNext()?ai.write(e,this,r,!1,!1):ue.writeString(e,"{}")}sizeOfPrimary(e){if(this.isRecord(this.item(e))){const t=this.items(this.item(e));if(t.hasNext())return ui.sizeOf(this,t)}else if(!this.isExtant(this.item(e)))return this.sizeOfValue(e);return 2}writePrimary(e,t){if(this.isRecord(this.item(t))){const r=this.items(this.item(t));if(r.hasNext())return ui.write(e,this,r)}else if(!this.isExtant(this.item(t)))return this.writeValue(e,t);return ue.writeString(e,"()")}isBlockSafe(e){for(;e.hasNext();)if(this.isAttr(e.next().value))return!1;return!0}isMarkupSafe(e){if(!e.hasNext()||!this.isAttr(e.next().value))return!1;for(;e.hasNext();)if(this.isAttr(e.next().value))return!1;return!0}sizeOfMarkupText(e){return"string"!=typeof e&&(e=this.string(e)),hi.sizeOf(e)}writeMarkupText(e,t){return"string"!=typeof t&&(t=this.string(t)),hi.write(e,t)}sizeOfData(e){return li.sizeOf(e)}writeData(e,t){return void 0!==t?li.write(e,t):ue.writeString(e,"%")}isIdent(e){"string"!=typeof e&&(e=this.string(e));const t=e.length;let r;if(0===t||(r=e.codePointAt(0),void 0!==r&&!Tr.isIdentStartChar(r)))return!1;for(let i=u.offsetByCodePoints(e,0,1);i<t;i=u.offsetByCodePoints(e,i,1))if(r=e.codePointAt(i),void 0===r||!Tr.isIdentChar(r))return!1;return!0}sizeOfText(e){return this.isIdent(e)?ci.sizeOf(e):di.sizeOf(e)}writeText(e,t){return this.isIdent(t)?ci.write(e,t):di.write(e,t)}sizeOfNum(e){if(isFinite(e)&&Math.floor(e)===e&&Math.abs(e)<2147483648){let t=le.countDigits(e);return e<0&&(t+=1),t}return(""+e).length}writeNum(e,t){return isFinite(t)&&Math.floor(t)===t&&Math.abs(t)<2147483648?le.writeInteger(e,t):ue.writeString(e,""+t)}sizeOfUint32(e){return 10}writeUint32(e,t){return Be.lowercase.writeIntegerLiteral(e,t,8)}sizeOfUint64(e){return 18}writeUint64(e,t){return Be.lowercase.writeIntegerLiteral(e,t,16)}sizeOfBool(e){return e?4:5}writeBool(e,t){return ue.writeString(e,t?"true":"false")}sizeOfLambdaFunc(e,t){return pi.sizeOf(this,e,t)}writeLambdaFunc(e,t,r){return pi.write(e,this,t,r)}sizeOfConditionalOperator(e,t,r,i){return fi.sizeOf(this,e,t,r,i)}writeConditionalOperator(e,t,r,i,n){return fi.write(e,this,t,r,i,n)}sizeOfInfixOperator(e,t,r,i){return wi.sizeOf(this,e,t,r,i)}writeInfixOperator(e,t,r,i,n){return wi.write(e,this,t,r,i,n)}sizeOfPrefixOperator(e,t,r){return mi.sizeOf(this,e,t,r)}writePrefixOperator(e,t,r,i){return mi.write(e,this,t,r,i)}sizeOfInvokeOperator(e,t){return gi.sizeOf(this,e,t)}writeInvokeOperator(e,t,r){return gi.write(e,this,t,r)}sizeOfIdentitySelector(){return 0}writeIdentitySelector(e){return oe.end()}sizeOfThenIdentitySelector(){return 0}writeThenIdentitySelector(e){return oe.end()}sizeOfLiteralSelector(e,t){return yi.sizeOf(this,e,t)}writeLiteralSelector(e,t,r){return yi.write(e,this,t,r)}sizeOfThenLiteralSelector(e,t){return 0}writeThenLiteralSelector(e,t,r){return oe.end()}sizeOfGetSelector(e,t){return bi.sizeOf(this,e,t)}writeGetSelector(e,t,r){return bi.write(e,this,t,r)}sizeOfThenGetSelector(e,t){return bi.sizeOf(this,e,t)}writeThenGetSelector(e,t,r){return bi.writeThen(e,this,t,r)}sizeOfGetAttrSelector(e,t){return vi.sizeOf(this,e,t)}writeGetAttrSelector(e,t,r){return vi.write(e,this,t,r)}sizeOfThenGetAttrSelector(e,t){return vi.sizeOf(this,e,t)}writeThenGetAttrSelector(e,t,r){return vi.writeThen(e,this,t,r)}sizeOfGetItemSelector(e,t){return xi.sizeOf(this,e,t)}writeGetItemSelector(e,t,r){return xi.write(e,this,t,r)}sizeOfThenGetItemSelector(e,t){return xi.sizeOfThen(this,e,t)}writeThenGetItemSelector(e,t,r){return xi.writeThen(e,this,t,r)}sizeOfKeysSelector(e){return Oi.sizeOf(this,e)}writeKeysSelector(e,t){return Oi.write(e,this,t)}sizeOfThenKeysSelector(e){return Oi.sizeOf(this,e)}writeThenKeysSelector(e,t){return Oi.writeThen(e,this,t)}sizeOfValuesSelector(e){return Ei.sizeOf(this,e)}writeValuesSelector(e,t){return Ei.write(e,this,t)}sizeOfThenValuesSelector(e){return Ei.sizeOf(this,e)}writeThenValuesSelector(e,t){return Ei.writeThen(e,this,t)}sizeOfChildrenSelector(e){return Ci.sizeOf(this,e)}writeChildrenSelector(e,t){return Ci.write(e,this,t)}sizeOfThenChildrenSelector(e){return Ci.sizeOf(this,e)}writeThenChildrenSelector(e,t){return Ci.writeThen(e,this,t)}sizeOfDescendantsSelector(e){return Ai.sizeOf(this,e)}writeDescendantsSelector(e,t){return Ai.write(e,this,t)}sizeOfThenDescendantsSelector(e){return Ai.sizeOf(this,e)}writeThenDescendantsSelector(e,t){return Ai.writeThen(e,this,t)}sizeOfFilterSelector(e,t){return Si.sizeOf(this,e,t)}writeFilterSelector(e,t,r){return Si.write(e,this,t,r)}sizeOfThenFilterSelector(e,t){return Si.sizeOfThen(this,e,t)}writeThenFilterSelector(e,t,r){return Si.writeThen(e,this,t,r)}sizeOfExtant(){return 0}writeExtant(e){return oe.end()}sizeOfAbsent(){return 0}writeAbsent(e){return oe.end()}}{isField(e){return e instanceof it}isAttr(e){return e instanceof ot}isSlot(e){return e instanceof nt}isValue(e){return e instanceof ht}isRecord(e){return e instanceof lt}isText(e){return e instanceof yt}isNum(e){return e instanceof vt}isBool(e){return e instanceof Ot}isExpression(e){return e instanceof At}isExtant(e){return e instanceof Et}items(e){return e.iterator()}item(e){return e}key(e){return e.key}value(e){return e.toValue()}string(e){return e.stringValue("")}precedence(e){return e.precedence}sizeOfItem(e){if(e instanceof it){if(e instanceof ot)return this.sizeOfAttr(e.key,e.value);if(e instanceof nt)return this.sizeOfSlot(e.key,e.value)}else if(e instanceof ht)return this.sizeOfValue(e);throw new se("No Recon serialization for "+e)}writeItem(e,t){if(t instanceof it){if(t instanceof ot)return this.writeAttr(e,t.key,t.value);if(t instanceof nt)return this.writeSlot(e,t.key,t.value)}else if(t instanceof ht)return this.writeValue(e,t);return oe.error(new se("No Recon serialization for "+t))}sizeOfValue(e){if(e instanceof lt)return this.sizeOfRecord(e);if(e instanceof mt)return this.sizeOfData(e.size);if(e instanceof yt)return this.sizeOfText(e.value);if(e instanceof vt)return e.isUint32()?this.sizeOfUint32(e.value):e.isUint64()?this.sizeOfUint64(e.value):this.sizeOfNum(e.value);if(e instanceof Ot)return this.sizeOfBool(e.value);if(e instanceof nr)return this.sizeOfSelector(e);if(e instanceof St)return this.sizeOfOperator(e);if(e instanceof wr)return this.sizeOfFunc(e);if(e instanceof Et)return this.sizeOfExtant();if(e instanceof Ct)return this.sizeOfAbsent();throw new se("No Recon serialization for "+e)}writeValue(e,t){return t instanceof lt?this.writeRecord(e,t):t instanceof mt?this.writeData(e,t.asUint8Array()):t instanceof yt?this.writeText(e,t.value):t instanceof vt?t.isUint32()?this.writeUint32(e,t.value):t.isUint64()?this.writeUint64(e,t.value):this.writeNum(e,t.value):t instanceof Ot?this.writeBool(e,t.value):t instanceof nr?this.writeSelector(e,t):t instanceof St?this.writeOperator(e,t):t instanceof wr?this.writeFunc(e,t):t instanceof Et?this.writeExtant(e):t instanceof Ct?this.writeAbsent(e):oe.error(new se("No Recon serialization for "+t))}sizeOfSelector(e){if(e instanceof sr)return this.sizeOfIdentitySelector();if(e instanceof fr)return this.sizeOfLiteralSelector(e.item,e.then);if(e instanceof or)return this.sizeOfGetSelector(e.item,e.then);if(e instanceof ar)return this.sizeOfGetAttrSelector(e.item,e.then);if(e instanceof ur)return this.sizeOfGetItemSelector(e.item,e.then);if(e instanceof hr)return this.sizeOfKeysSelector(e.then);if(e instanceof lr)return this.sizeOfValuesSelector(e.then);if(e instanceof cr)return this.sizeOfChildrenSelector(e.then);if(e instanceof dr)return this.sizeOfDescendantsSelector(e.then);if(e instanceof pr)return this.sizeOfFilterSelector(e.predicate,e.then);throw new se("No Recon serialization for "+e)}writeSelector(e,t){return t instanceof sr?this.writeIdentitySelector(e):t instanceof fr?this.writeLiteralSelector(e,t.item,t.then):t instanceof or?this.writeGetSelector(e,t.item,t.then):t instanceof ar?this.writeGetAttrSelector(e,t.item,t.then):t instanceof ur?this.writeGetItemSelector(e,t.item,t.then):t instanceof hr?this.writeKeysSelector(e,t.then):t instanceof lr?this.writeValuesSelector(e,t.then):t instanceof cr?this.writeChildrenSelector(e,t.then):t instanceof dr?this.writeDescendantsSelector(e,t.then):t instanceof pr?this.writeFilterSelector(e,t.predicate,t.then):oe.error(new se("No Recon serialization for "+t))}sizeOfOperator(e){if(e instanceof kt)return this.sizeOfInfixOperator(e.operand1,e.operator,e.operand2,e.precedence);if(e instanceof Pt)return this.sizeOfPrefixOperator(e.operator,e.operand,e.precedence);if(e instanceof rr)return this.sizeOfInvokeOperator(e.func,e.args);if(e instanceof qt)return this.sizeOfConditionalOperator(e.ifTerm,e.thenTerm,e.elseTerm,e.precedence);throw new se("No Recon serialization for "+e)}writeOperator(e,t){return t instanceof kt?this.writeInfixOperator(e,t.operand1,t.operator,t.operand2,t.precedence):t instanceof Pt?this.writePrefixOperator(e,t.operator,t.operand,t.precedence):t instanceof rr?this.writeInvokeOperator(e,t.func,t.args):t instanceof qt?this.writeConditionalOperator(e,t.ifTerm,t.thenTerm,t.elseTerm,t.precedence):oe.error(new se("No Recon serialization for "+t))}sizeOfFunc(e){if(e instanceof mr)return this.sizeOfLambdaFunc(e.bindings,e.template);if(e instanceof gr)return 0;throw new se("No Recon serialization for "+e)}writeFunc(e,t){return t instanceof mr?this.writeLambdaFunc(e,t.bindings,t.template):t instanceof gr?oe.end():oe.error(new se("No Recon serialization for "+t))}sizeOfBlockItem(e){if(e instanceof it)return this.sizeOfItem(e);if(e instanceof ht)return this.sizeOfBlockValue(e);throw new se("No Recon serialization for "+e)}writeBlockItem(e,t){return t instanceof it?this.writeItem(e,t):t instanceof ht?this.writeBlockValue(e,t):oe.error(new se("No Recon serialization for "+t))}sizeOfBlockValue(e){return e instanceof lt?this.sizeOfBlock(e):this.sizeOfValue(e)}writeBlockValue(e,t){return t instanceof lt?this.writeBlock(e,t):this.writeValue(e,t)}sizeOfThen(e){if(e instanceof nr){if(e instanceof sr)return this.sizeOfThenIdentitySelector();if(e instanceof fr)return this.sizeOfThenLiteralSelector(e.item,e.then);if(e instanceof or)return this.sizeOfThenGetSelector(e.item,e.then);if(e instanceof ar)return this.sizeOfThenGetAttrSelector(e.item,e.then);if(e instanceof ur)return this.sizeOfThenGetItemSelector(e.item,e.then);if(e instanceof hr)return this.sizeOfThenKeysSelector(e.then);if(e instanceof lr)return this.sizeOfThenValuesSelector(e.then);if(e instanceof cr)return this.sizeOfThenChildrenSelector(e.then);if(e instanceof dr)return this.sizeOfThenDescendantsSelector(e.then);if(e instanceof pr)return this.sizeOfThenFilterSelector(e.predicate,e.then)}throw new se("No Recon serialization for "+e)}writeThen(e,t){if(t instanceof nr){if(t instanceof sr)return this.writeThenIdentitySelector(e);if(t instanceof fr)return this.writeThenLiteralSelector(e,t.item,t.then);if(t instanceof or)return this.writeThenGetSelector(e,t.item,t.then);if(t instanceof ar)return this.writeThenGetAttrSelector(e,t.item,t.then);if(t instanceof ur)return this.writeThenGetItemSelector(e,t.item,t.then);if(t instanceof hr)return this.writeThenKeysSelector(e,t.then);if(t instanceof lr)return this.writeThenValuesSelector(e,t.then);if(t instanceof cr)return this.writeThenChildrenSelector(e,t.then);if(t instanceof dr)return this.writeThenDescendantsSelector(e,t.then);if(t instanceof pr)return this.writeThenFilterSelector(e,t.predicate,t.then)}return oe.error(new se("No Recon serialization for "+t))}}class Ti extends Error{constructor(e){super(e instanceof ce?e.message:e),Object.setPrototypeOf(this,Ti.prototype),this.diagnostic=e instanceof ce?e:null}toString(){return null!==this.diagnostic?this.diagnostic.toString():super.toString()}}class Pi{constructor(e,t,r,i,n){this.scheme=e,this.authority=t,this.path=r,this.query=i,this.fragment=n,this.hashValue=void 0,this.stringValue=void 0}isDefined(){return this.scheme.isDefined()||this.authority.isDefined()||this.path.isDefined()||this.query.isDefined()||this.fragment.isDefined()}isEmpty(){return!this.scheme.isDefined()&&!this.authority.isDefined()&&this.path.isEmpty()&&!this.query.isDefined()&&!this.fragment.isDefined()}withScheme(e){return(e=Di.fromAny(e))!==this.scheme?this.copy(e,this.authority,this.path,this.query,this.fragment):this}get schemePart(){return this.scheme.toString()}withSchemePart(e){return this.withScheme(Di.parse(e))}get schemeName(){return this.scheme.name}withSchemeName(e){return this.withScheme(Di.create(e))}withAuthority(e){return(e=qi.fromAny(e))!==this.authority?this.copy(this.scheme,e,this.path,this.query,this.fragment):this}get authorityPart(){return this.authority.toString()}withAuthorityPart(e){return this.withAuthority(qi.parse(e))}get user(){return this.authority.user}withUser(e){return this.withAuthority(this.authority.withUser(e))}get userPart(){return this.authority.userPart}withUserPart(e){return this.withAuthority(this.authority.withUserPart(e))}get username(){return this.authority.username}withUsername(e,t){return 1===arguments.length?this.withAuthority(this.authority.withUsername(e)):this.withAuthority(this.authority.withUsername(e,t))}get password(){return this.authority.password}withPassword(e){return this.withAuthority(this.authority.withPassword(e))}get host(){return this.authority.host}withHost(e){return this.withAuthority(this.authority.withHost(e))}get hostPart(){return this.authority.hostPart}withHostPart(e){return this.withAuthority(this.authority.withHostPart(e))}get hostAddress(){return this.authority.hostAddress}get hostName(){return this.authority.hostName}withHostName(e){return this.withAuthority(this.authority.withHostName(e))}get hostIPv4(){return this.authority.hostIPv4}withHostIPv4(e){return this.withAuthority(this.authority.withHostIPv4(e))}get hostIPv6(){return this.authority.hostIPv6}withHostIPv6(e){return this.withAuthority(this.authority.withHostIPv6(e))}get port(){return this.authority.port}withPort(e){return this.withAuthority(this.authority.withPort(e))}get portPart(){return this.authority.portPart}withPortPart(e){return this.withAuthority(this.authority.withPortPart(e))}get portNumber(){return this.authority.portNumber}withPortNumber(e){return this.withAuthority(this.authority.withPortNumber(e))}withPath(...e){const t=Fi.of(...e);return t!==this.path?this.copy(this.scheme,this.authority,t,this.query,this.fragment):this}get pathPart(){return this.path.toString()}withPathPart(e){return this.withPath(Fi.parse(e))}get pathName(){return this.path.name}withPathName(e){return this.withPath(this.path.withName(e))}parentPath(){return this.path.parent()}basePath(){return this.path.base()}parent(){return Pi.create(this.scheme,this.authority,this.path.parent())}base(){return Pi.create(this.scheme,this.authority,this.path.base())}appendedPath(...e){return this.withPath(this.path.appended(...e))}appendedSlash(){return this.withPath(this.path.appendedSlash())}appendedSegment(e){return this.withPath(this.path.appendedSegment(e))}prependedPath(...e){return this.withPath(this.path.prepended(...e))}prependedSlash(){return this.withPath(this.path.prependedSlash())}prependedSegment(e){return this.withPath(this.path.prependedSegment(e))}withQuery(e){return(e=Ki.fromAny(e))!==this.query?this.copy(this.scheme,this.authority,this.path,e,this.fragment):this}get queryPart(){return this.query.toString()}withQueryPart(e){return this.withQuery(Ki.parse(e))}updatedQuery(e,t){return this.withQuery(this.query.updated(e,t))}removedQuery(e){return this.withQuery(this.query.removed(e))}appendedQuery(e,t){return this.withQuery(this.query.appended(e,t))}prependedQuery(e,t){return this.withQuery(this.query.prepended(e,t))}withFragment(e){return(e=Zi.fromAny(e))!==this.fragment?Pi.create(this.scheme,this.authority,this.path,this.query,e):this}get fragmentPart(){return this.fragment.toString()}withFragmentPart(e){return this.withFragment(Zi.parse(e))}get fragmentIdentifier(){return this.fragment.identifier}withFragmentIdentifier(e){return this.withFragment(Zi.create(e))}endpoint(){return this.path.isDefined()||this.query.isDefined()||this.fragment.isDefined()?Pi.create(this.scheme,this.authority):this}resolve(e){const t=Pi.fromAny(e);return t.scheme.isDefined()?this.copy(t.scheme,t.authority,t.path.removeDotSegments(),t.query,t.fragment):t.authority.isDefined()?this.copy(this.scheme,t.authority,t.path.removeDotSegments(),t.query,t.fragment):t.path.isEmpty()?this.copy(this.scheme,this.authority,this.path,t.query.isDefined()?t.query:this.query,t.fragment):t.path.isAbsolute()?this.copy(this.scheme,this.authority,t.path.removeDotSegments(),t.query,t.fragment):this.copy(this.scheme,this.authority,this.merge(t.path).removeDotSegments(),t.query,t.fragment)}merge(e){return this.authority.isDefined()&&this.path.isEmpty()?e.prependedSlash():this.path.isEmpty()?e:this.path.merge(e)}unresolve(e){const t=Pi.fromAny(e);return this.scheme.equals(t.scheme)&&this.authority.equals(t.authority)?Pi.create(Di.undefined(),qi.undefined(),this.path.unmerge(t.path),t.query,t.fragment):t}copy(e,t,r,i,n){return Pi.create(e,t,r,i,n)}toAny(){const e={};return e.scheme=this.scheme.toAny(),this.authority.toAny(e),e.path=this.path.toAny(),e.query=this.query.toAny(),e.fragment=this.fragment.toAny(),e}compareTo(e){return e instanceof Pi?this.toString().localeCompare(e.toString()):NaN}equals(e){return this===e||e instanceof Pi&&this.toString()===e.toString()}hashCode(){let e=this.hashValue;return void 0===e&&(e=u.hash(this.toString()),this.hashValue=e),e}debug(e){return e=e.write("Uri").write(46),e=this.isDefined()?e.write("parse").write(40).write(34).display(this).write(34).write(41):e.write("empty").write(40).write(41)}display(e){const t=this.stringValue;return void 0!==t?e=e.write(t):(this.scheme.isDefined()&&(e=e.display(this.scheme).write(58)),this.authority.isDefined()&&(e=e.write(47).write(47).display(this.authority)),e=e.display(this.path),this.query.isDefined()&&(e=e.write(63).display(this.query)),this.fragment.isDefined()&&(e=e.write(35).display(this.fragment))),e}toString(){let e=this.stringValue;return void 0===e&&(e=he.display(this),this.stringValue=e),e}static empty(){return new Pi(Di.undefined(),qi.undefined(),Fi.empty(),Ki.undefined(),Zi.undefined())}static create(e=Di.undefined(),t=qi.undefined(),r=Fi.empty(),i=Ki.undefined(),n=Zi.undefined()){return e.isDefined()||t.isDefined()||r.isDefined()||i.isDefined()||n.isDefined()?new Pi(e,t,r,i,n):Pi.empty()}static fromInit(e){const t=Di.fromAny(e.scheme),r=qi.fromAny(void 0!==e.authority?e.authority:e),i=Fi.fromAny(e.path),n=Ki.fromAny(e.query),s=Zi.fromAny(e.fragment);return t.isDefined()||r.isDefined()||i.isDefined()||n.isDefined()||s.isDefined()?new Pi(t,r,i,n,s):Pi.empty()}static fromAny(e){if(null==e)return Pi.empty();if(e instanceof Pi)return e;if("object"==typeof e)return Pi.fromInit(e);if("string"==typeof e)return Pi.parse(e);throw new TypeError(""+e)}static scheme(e){return e=Di.fromAny(e),Pi.create(e,void 0,void 0,void 0,void 0)}static schemePart(e){const t=Di.parse(e);return Pi.create(t,void 0,void 0,void 0,void 0)}static schemeName(e){const t=Di.create(e);return Pi.create(t,void 0,void 0,void 0,void 0)}static authority(e){return e=qi.fromAny(e),Pi.create(void 0,e,void 0,void 0,void 0)}static authorityPart(e){const t=qi.parse(e);return Pi.create(void 0,t,void 0,void 0,void 0)}static user(e){const t=qi.user(e);return Pi.create(void 0,t,void 0,void 0,void 0)}static userPart(e){const t=qi.userPart(e);return Pi.create(void 0,t,void 0,void 0,void 0)}static username(e,t){const r=qi.username(e,t);return Pi.create(void 0,r,void 0,void 0,void 0)}static password(e){const t=qi.password(e);return Pi.create(void 0,t,void 0,void 0,void 0)}static host(e){const t=qi.host(e);return Pi.create(void 0,t,void 0,void 0,void 0)}static hostPart(e){const t=qi.hostPart(e);return Pi.create(void 0,t,void 0,void 0,void 0)}static hostName(e){const t=qi.hostName(e);return Pi.create(void 0,t,void 0,void 0,void 0)}static hostIPv4(e){const t=qi.hostIPv4(e);return Pi.create(void 0,t,void 0,void 0,void 0)}static hostIPv6(e){const t=qi.hostIPv6(e);return Pi.create(void 0,t,void 0,void 0,void 0)}static port(e){const t=qi.port(e);return Pi.create(void 0,t,void 0,void 0,void 0)}static portPart(e){const t=qi.portPart(e);return Pi.create(void 0,t,void 0,void 0,void 0)}static portNumber(e){const t=qi.portNumber(e);return Pi.create(void 0,t,void 0,void 0,void 0)}static path(...e){const t=Fi.of(...e);return Pi.create(void 0,void 0,t,void 0,void 0)}static pathPart(e){const t=Fi.parse(e);return Pi.create(void 0,void 0,t,void 0,void 0)}static query(e){return e=Ki.fromAny(e),Pi.create(void 0,void 0,void 0,e,void 0)}static queryPart(e){const t=Ki.parse(e);return Pi.create(void 0,void 0,void 0,t,void 0)}static fragment(e){return e=Zi.fromAny(e),Pi.create(void 0,void 0,void 0,void 0,e)}static fragmentPart(e){const t=Zi.parse(e);return Pi.create(void 0,void 0,void 0,void 0,t)}static fragmentIdentifier(e){const t=Zi.create(e);return Pi.create(void 0,void 0,void 0,void 0,t)}static get standardParser(){return new $i}static parse(e){return Pi.standardParser.parseAbsoluteString(e)}static pathBuilder(){return new Ri}static queryBuilder(){return new Qi}static form(){return new Xi(Pi.empty())}static isUnreservedChar(e){return e>=65&&e<=90||e>=97&&e<=122||e>=48&&e<=57||45===e||46===e||95===e||126===e}static isSubDelimChar(e){return 33===e||36===e||38===e||40===e||41===e||42===e||43===e||44===e||59===e||61===e||39===e}static isSchemeChar(e){return e>=65&&e<=90||e>=97&&e<=122||e>=48&&e<=57||43===e||45===e||46===e}static isUserInfoChar(e){return Pi.isUnreservedChar(e)||Pi.isSubDelimChar(e)||58===e}static isUserChar(e){return Pi.isUnreservedChar(e)||Pi.isSubDelimChar(e)}static isHostChar(e){return Pi.isUnreservedChar(e)||Pi.isSubDelimChar(e)}static isPathChar(e){return Pi.isUnreservedChar(e)||Pi.isSubDelimChar(e)||58===e||64===e}static isQueryChar(e){return Pi.isUnreservedChar(e)||Pi.isSubDelimChar(e)||47===e||58===e||63===e||64===e}static isParamChar(e){return Pi.isUnreservedChar(e)||33===e||36===e||40===e||41===e||42===e||43===e||44===e||47===e||58===e||59===e||63===e||64===e||39===e}static isFragmentChar(e){return Pi.isUnreservedChar(e)||Pi.isSubDelimChar(e)||47===e||58===e||63===e||64===e}static isAlpha(e){return e>=65&&e<=90||e>=97&&e<=122}static toLowerCase(e){return e>=65&&e<=90?e+32:e}static writeScheme(e,t){for(let r=0,i=t.length;r<i;r+=1){const i=t.charCodeAt(r);e=r>0&&Pi.isSchemeChar(i)||0===r&&Pi.isAlpha(i)?e.write(i):ie.error(new Ti("Invalid scheme: "+t))}return e}static writeUserInfo(e,t){for(let r=0,i=t.length;r<i;r+=1){const i=t.charCodeAt(r);e=Pi.isUserInfoChar(i)?e.write(i):Pi.writeEncoded(e,i)}return e}static writeUser(e,t){for(let r=0,i=t.length;r<i;r+=1){const i=t.charCodeAt(r);e=Pi.isUserChar(i)?e.write(i):Pi.writeEncoded(e,i)}return e}static writeHost(e,t){for(let r=0,i=t.length;r<i;r+=1){const i=t.charCodeAt(r);e=Pi.isHostChar(i)?e.write(i):Pi.writeEncoded(e,i)}return e}static writeHostLiteral(e,t){for(let r=0,i=t.length;r<i;r+=1){const i=t.charCodeAt(r);e=Pi.isHostChar(i)||58===i?e.write(i):Pi.writeEncoded(e,i)}return e}static writePathSegment(e,t){for(let r=0,i=t.length;r<i;r+=1){const i=t.charCodeAt(r);e=Pi.isPathChar(i)?e.write(i):Pi.writeEncoded(e,i)}return e}static writeQuery(e,t){for(let r=0,i=t.length;r<i;r+=1){const i=t.charCodeAt(r);e=Pi.isQueryChar(i)?e.write(i):Pi.writeEncoded(e,i)}return e}static writeParam(e,t){for(let r=0,i=t.length;r<i;r+=1){const i=t.charCodeAt(r);e=Pi.isParamChar(i)?e.write(i):Pi.writeEncoded(e,i)}return e}static writeFragment(e,t){for(let r=0,i=t.length;r<i;r+=1){const i=t.charCodeAt(r);e=Pi.isFragmentChar(i)?e.write(i):Pi.writeEncoded(e,i)}return e}static writeEncoded(e,t){return 0===t?(e=Pi.writePctEncoded(e,192),e=Pi.writePctEncoded(e,128)):t>=0&&t<=127?e=Pi.writePctEncoded(e,t):t>=128&&t<=2047?(e=Pi.writePctEncoded(e,192|t>>>6),e=Pi.writePctEncoded(e,128|63&t)):t>=2048&&t<=65535?(e=Pi.writePctEncoded(e,224|t>>>12),e=Pi.writePctEncoded(e,128|t>>>6&63),e=Pi.writePctEncoded(e,128|63&t)):t>=65536&&t<=1114111?(e=Pi.writePctEncoded(e,240|t>>>18),e=Pi.writePctEncoded(e,128|t>>>12&63),e=Pi.writePctEncoded(e,128|t>>>6&63),e=Pi.writePctEncoded(e,128|63&t)):(e=Pi.writePctEncoded(e,239),e=Pi.writePctEncoded(e,191),e=Pi.writePctEncoded(e,189)),e}static writePctEncoded(e,t){const r=Be.lowercase;return e=e.write(37).write(r.encodeDigit(t>>>4&15)).write(r.encodeDigit(15&t))}}e([n],Pi,"empty",null),e([n],Pi,"standardParser",null),e([n],Pi,"form",null);class Di{constructor(e){this.name=e}isDefined(){return 0!==this.name.length}toAny(){return 0!==this.name.length?this.name:void 0}compareTo(e){return e instanceof Di?this.name.localeCompare(e.name):NaN}equals(e){return this===e||e instanceof Di&&this.name===e.name}hashCode(){return u.hash(this.name)}debug(e){return e=e.write("UriScheme").write(46),e=this.isDefined()?e.write("parse").write(40).write(34).display(this).write(34).write(41):e.write("undefined").write(40).write(41)}display(e){return e=Pi.writeScheme(e,this.name)}toString(){return this.name}static undefined(){return new Di("")}static create(e){const t=Di.cache,r=t.get(e);return void 0!==r?r:t.put(e,new Di(e))}static fromAny(e){if(null==e)return Di.undefined();if(e instanceof Di)return e;if("string"==typeof e)return Di.parse(e);throw new TypeError(""+e)}static parse(e){return Pi.standardParser.parseSchemeString(e)}static get cache(){return new U(4)}}e([n],Di,"undefined",null),e([n],Di,"cache",null);class qi{constructor(e,t,r){this.user=e,this.host=t,this.port=r,this.hashValue=void 0,this.stringValue=void 0}isDefined(){return this.user.isDefined()||this.host.isDefined()||this.port.isDefined()}withUser(e){return(e=Ii.fromAny(e))!==this.user?this.copy(e,this.host,this.port):this}get userPart(){return this.user.toString()}withUserPart(e){return this.withUser(Ii.parse(e))}get username(){return this.user.username}withUsername(e,t){return 1===arguments.length?this.withUser(this.user.withUsername(e)):this.withUser(Ii.create(e,t))}get password(){return this.user.password}withPassword(e){return this.withUser(this.user.withPassword(e))}withHost(e){return(e=Vi.fromAny(e))!==this.host?this.copy(this.user,e,this.port):this}get hostPart(){return this.host.toString()}withHostPart(e){return this.withHost(Vi.parse(e))}get hostAddress(){return this.host.address}get hostName(){return this.host.name}withHostName(e){return this.withHost(Vi.hostname(e))}get hostIPv4(){return this.host.ipv4}withHostIPv4(e){return this.withHost(Vi.ipv4(e))}get hostIPv6(){return this.host.ipv6}withHostIPv6(e){return this.withHost(Vi.ipv6(e))}withPort(e){return(e=Li.fromAny(e))!==this.port?this.copy(this.user,this.host,e):this}get portPart(){return this.port.toString()}withPortPart(e){return this.withPort(Li.parse(e))}get portNumber(){return this.port.number}withPortNumber(e){return this.withPort(Li.create(e))}copy(e,t,r){return qi.create(e,t,r)}toAny(e){return this.isDefined()&&(void 0===e&&(e={}),this.user.toAny(e),this.host.isDefined()&&(e.host=this.host.toAny()),this.port.isDefined()&&(e.port=this.port.toAny())),e}compareTo(e){return e instanceof qi?this.toString().localeCompare(e.toString()):NaN}equals(e){return this===e||e instanceof qi&&this.toString()===e.toString()}hashCode(){let e=this.hashValue;return void 0===e&&(e=u.hash(this.toString()),this.hashValue=e),e}debug(e){return e=e.write("UriAuthority").write(46),e=this.isDefined()?e.write("parse").write(40).write(34).display(this).write(34).write(41):e.write("undefined").write(40).write(41)}display(e){const t=this.stringValue;if(void 0!==t)e=e.write(t);else{const t=this.user;t.isDefined()&&(e=e.display(t).write(64)),e=e.display(this.host);const r=this.port;r.isDefined()&&(e=e.write(58).display(r))}return e}toString(){let e=this.stringValue;return void 0===e&&(e=he.display(this),this.stringValue=e),e}static undefined(){return new qi(Ii.undefined(),Vi.undefined(),Li.undefined())}static create(e=Ii.undefined(),t=Vi.undefined(),r=Li.undefined()){return e.isDefined()||t.isDefined()||r.isDefined()?new qi(e,t,r):qi.undefined()}static fromInit(e){const t=Ii.fromAny(void 0!==e.user?e.user:e),r=Vi.fromAny(e.host),i=Li.fromAny(e.port);return qi.create(t,r,i)}static fromAny(e){if(null==e)return qi.undefined();if(e instanceof qi)return e;if("object"==typeof e)return qi.fromInit(e);if("string"==typeof e)return qi.parse(e);throw new TypeError(""+e)}static user(e){return e=Ii.fromAny(e),qi.create(e,void 0,void 0)}static userPart(e){const t=Ii.parse(e);return qi.create(t,void 0,void 0)}static username(e,t){const r=Ii.create(e,t);return qi.create(r,void 0,void 0)}static password(e){const t=Ii.create("",e);return qi.create(t,void 0,void 0)}static host(e){return e=Vi.fromAny(e),qi.create(void 0,e,void 0)}static hostPart(e){const t=Vi.parse(e);return qi.create(void 0,t,void 0)}static hostName(e){const t=Vi.hostname(e);return qi.create(void 0,t,void 0)}static hostIPv4(e){const t=Vi.ipv4(e);return qi.create(void 0,t,void 0)}static hostIPv6(e){const t=Vi.ipv6(e);return qi.create(void 0,t,void 0)}static port(e){return e=Li.fromAny(e),qi.create(void 0,void 0,e)}static portPart(e){const t=Li.parse(e);return qi.create(void 0,void 0,t)}static portNumber(e){const t=Li.create(e);return qi.create(void 0,void 0,t)}static parse(e){return Pi.standardParser.parseAuthorityString(e)}}e([n],qi,"undefined",null);class Ii{constructor(e,t){this.username=e,this.password=t}isDefined(){return void 0!==this.username}withUsername(e){return e!==this.username?this.copy(e,this.password):this}withPassword(e){return e!==this.password?this.copy(this.username,e):this}copy(e,t){return Ii.create(e,t)}toAny(e){return void 0!==this.username&&(void 0===e&&(e={}),e.username=this.username,void 0!==this.password&&(e.password=this.password)),e}equals(e){return this===e||e instanceof Ii&&(this.username===e.username&&this.password===e.password)}hashCode(){return u.hash(this.toString())}debug(e){return e=e.write("UriUser").write(46),e=this.isDefined()?e.write("parse").write(40).write(34).display(this).write(34).write(41):e.write("undefined").write(40).write(41)}display(e){return void 0!==this.username&&(e=Pi.writeUser(e,this.username),void 0!==this.password&&(e=e.write(58),e=Pi.writeUser(e,this.password))),e}toString(){return he.display(this)}static undefined(){return new Ii(void 0,void 0)}static create(e,t){return void 0!==e||void 0!==t?new Ii(e,t):Ii.undefined()}static fromInit(e){return Ii.create(e.username,e.password)}static fromAny(e){if(null==e)return Ii.undefined();if(e instanceof Ii)return e;if("object"==typeof e)return Ii.fromInit(e);if("string"==typeof e)return Ii.parse(e);throw new TypeError(""+e)}static parse(e){return Pi.standardParser.parseUserString(e)}}e([n],Ii,"undefined",null);class Vi{constructor(){}isDefined(){return!0}get name(){}get ipv4(){}get ipv6(){}toAny(){return this.toString()}compareTo(e){return e instanceof Vi?this.toString().localeCompare(e.toString()):NaN}equals(e){return this===e||e instanceof Vi&&this.toString()===e.toString()}hashCode(){return u.hash(this.toString())}static undefined(){return new ji}static hostname(e){const t=Vi.cache,r=t.get(e);return r instanceof Ni?r:t.put(e,new Ni(e))}static ipv4(e){const t=Vi.cache,r=t.get(e);return r instanceof zi?r:t.put(e,new zi(e))}static ipv6(e){const t=Vi.cache,r=t.get(e);return r instanceof Mi?r:t.put(e,new Mi(e))}static fromAny(e){if(null==e)return Vi.undefined();if(e instanceof Vi)return e;if("string"==typeof e)return Vi.parse(e);throw new TypeError(""+e)}static parse(e){return Pi.standardParser.parseHostString(e)}static get cache(){return new U(16)}}e([n],Vi,"undefined",null),e([n],Vi,"cache",null);class Ni extends Vi{constructor(e){super(),this.address=e}get name(){return this.address}debug(e){return e=e.write("UriHost").write(46).write("hostname").write(40).debug(this.address).write(41)}display(e){return e=Pi.writeHost(e,this.address)}toString(){return this.address}}class zi extends Vi{constructor(e){super(),this.address=e}get ipv4(){return this.address}debug(e){return e=e.write("UriHost").write(46).write("ipv4").write(40).debug(this.address).write(41)}display(e){return e=Pi.writeHost(e,this.address)}toString(){return this.address}}class Mi extends Vi{constructor(e){super(),this.address=e}get ipv6(){return this.address}debug(e){return e=e.write("UriHost").write(46).write("ipv6").write(40).debug(this.address).write(41)}display(e){return e=e.write(91),e=(e=Pi.writeHostLiteral(e,this.address)).write(93)}toString(){return"["+this.address+"]"}}class ji extends Vi{constructor(){super()}isDefined(){return!1}get address(){return""}debug(e){return e=e.write("UriHost").write(46).write("undefined").write(40).write(41)}display(e){return e}toString(){return""}}class Li{constructor(e){this.number=e}isDefined(){return 0!==this.number}valueOf(){return this.number}toAny(){return this.number}compareTo(e){return e instanceof Li?this.number<e.number?-1:this.number>e.number?1:0:NaN}equals(e){return this===e||e instanceof Li&&this.number===e.number}hashCode(){return u.hash(this.toString())}debug(e){return e=e.write("UriPort").write(46),this.isDefined()?(e=e.write("create").write(40),e=he.displayNumber(e,this.number)):e=e.write("undefined").write(40),e=e.write(41)}display(e){return e=he.displayNumber(e,this.number)}toString(){return""+this.number}static undefined(){return new Li(0)}static create(e){if(0===e)return Li.undefined();if(e>0){const t=Li.cache,r=t.get(e);return void 0!==r?r:t.put(e,new Li(e))}throw new TypeError(""+e)}static fromAny(e){if(null==e)return Li.undefined();if(e instanceof Li)return e;if("number"==typeof e)return Li.create(e);if("string"==typeof e)return Li.parse(e);throw new TypeError(""+e)}static parse(e){return Pi.standardParser.parsePortString(e)}static get cache(){return new U(16)}}e([n],Li,"undefined",null),e([n],Li,"cache",null);class Fi{constructor(){}get length(){let e=0,t=this;for(;!t.isEmpty();)e+=1,t=t.tail();return e}get(e){let t=0,r=this;for(;!r.isEmpty();){if(!(t<e))return r.head();t+=1,r=r.tail()}}get name(){if(this.isEmpty())return"";let e=this;for(;;){const t=e.tail();if(t.isEmpty())return e.isRelative()?e.head():"";e=t}}withName(e){const t=new Ri;return t.addPath(this.base()),t.addSegment(e),t.bind()}foot(){if(this.isEmpty())return this;let e=this;for(;;){const t=e.tail();if(t.isEmpty())return e;e=t}}isSubpathOf(e){e=Fi.fromAny(e);let t=this;for(;!t.isEmpty()&&!e.isEmpty();){if(t.head()!==e.head())return!1;t=t.tail(),e=e.tail()}return e.isEmpty()}appended(...e){if(arguments.length>0){const t=new Ri;return t.addPath(this),t.push(...e),t.bind()}return this}appendedSlash(){const e=new Ri;return e.addPath(this),e.addSlash(),e.bind()}appendedSegment(e){const t=new Ri;return t.addPath(this),t.addSegment(e),t.bind()}prepended(...e){if(arguments.length>0){const t=new Ri;return t.push(...e),t.addPath(this),t.bind()}return this}prependedSlash(){return new Ui(this)}prependedSegment(e){return this.isEmpty()||this.isAbsolute()?Fi.segment(e,this):Fi.segment(e,this.prependedSlash())}resolve(e){return e.isEmpty()?this:e.isAbsolute()||this.isEmpty()?e.removeDotSegments():this.merge(e).removeDotSegments()}removeDotSegments(){let e=this;const t=new Ri;for(;!e.isEmpty();){const r=e.head();if("."===r||".."===r)e=e.tail(),e.isEmpty()||(e=e.tail());else if(e.isAbsolute()){const i=e.tail();if(i.isEmpty())t.push(e.head()),e=e.tail();else{const n=i.head();"."===n?(e=i.tail(),e.isEmpty()&&(e=Fi.slash())):".."===n?(e=i.tail(),e.isEmpty()&&(e=Fi.slash()),t.isEmpty()||t.pop().isAbsolute()||t.isEmpty()||t.pop()):(t.push(r,n),e=i.tail())}}else t.push(e.head()),e=e.tail()}return t.bind()}merge(e){if(this.isEmpty())return e;{const t=new Ri;let r=this;for(;;){const e=r.tail();if(e.isEmpty()){r.isAbsolute()&&t.addSlash();break}r.isAbsolute()?t.addSlash():t.addSegment(r.head()),r=e}return t.addPath(e),t.bind()}}unmerge(e,t=e){let r=this;for(;;){if(r.isEmpty())return e.isEmpty()||e.tail().isEmpty()?e:e.tail();if(r.isRelative())return e;if(e.isRelative())return e.prependedSlash();{let i=r.tail(),n=e.tail();if(!i.isEmpty()&&n.isEmpty())return Fi.slash();if(i.isEmpty()||n.isEmpty()||i.head()!==n.head())return n;if(i=i.tail(),n=n.tail(),!i.isEmpty()&&n.isEmpty())return t;r=i,e=n}}}toAny(){const e=[];let t=this;for(;!t.isEmpty();)e.push(t.head()),t=t.tail();return e}compareTo(e){return e instanceof Fi?this.toString().localeCompare(e.toString()):NaN}equals(e){return this===e||e instanceof Fi&&this.toString()===e.toString()}hashCode(){return u.hash(this.toString())}display(e){let t=this;for(;!t.isEmpty();)e=t.isAbsolute()?e.write(47):Pi.writePathSegment(e,t.head()),t=t.tail();return e}static empty(){return new Wi}static slash(){return new Ui(Fi.empty())}static segment(e,t){return void 0===t&&(t=Fi.empty()),e=this.cacheSegment(e),new Bi(e,t)}static of(...e){const t=new Ri;return t.push(...e),t.bind()}static fromAny(e){if(null==e)return Fi.empty();if(e instanceof Fi)return e;if(Array.isArray(e))return Fi.of(...e);if("string"==typeof e)return Fi.parse(e);throw new TypeError(""+e)}static parse(e){return Pi.standardParser.parsePathString(e)}static builder(){return new Ri}static pathForm(){return new Hi(Fi.empty())}static get segmentCache(){return new R(64)}static cacheSegment(e){return e.length<=32?this.segmentCache.put(e):e}}e([n],Fi,"empty",null),e([n],Fi,"slash",null),e([n],Fi,"pathForm",null),e([n],Fi,"segmentCache",null);class Bi extends Fi{constructor(e,t){super(),this.segment=e,this.rest=t,this.stringValue=void 0}isDefined(){return!0}isAbsolute(){return!1}isRelative(){return!0}isEmpty(){return!1}head(){return this.segment}tail(){return this.rest}setTail(e){if(e instanceof Bi)throw new Error("adjacent path segments");this.rest=e}dealias(){return new Bi(this.segment,this.rest)}parent(){const e=this.rest;if(e.isEmpty())return Fi.empty();return e.tail().isEmpty()?Fi.empty():new Bi(this.segment,e.parent())}base(){const e=this.rest;return e.isEmpty()?Fi.empty():new Bi(this.segment,e.base())}prependedSegment(e){return Fi.segment(e,this.prependedSlash())}debug(e){return e=e.write("UriPath").write(46).write("parse").write(40).write(34).display(this).write(34).write(41)}display(e){const t=this.stringValue;return e=void 0!==t?e.write(t):super.display(e)}toString(){let e=this.stringValue;return void 0===e&&(e=he.display(this),this.stringValue=e),e}}class Ui extends Fi{constructor(e){super(),this.rest=e,this.stringValue=void 0}isDefined(){return!0}isAbsolute(){return!0}isRelative(){return!1}isEmpty(){return!1}head(){return"/"}tail(){return this.rest}setTail(e){this.rest=e}dealias(){return new Ui(this.rest)}parent(){const e=this.rest;if(e.isEmpty())return Fi.empty();return e.tail().isEmpty()?Fi.slash():new Ui(e.parent())}base(){const e=this.rest;return e.isEmpty()?this:new Ui(e.base())}prependedSegment(e){return Fi.segment(e,this)}debug(e){return e=e.write("UriPath").write(46).write("parse").write(40).write(34).display(this).write(34).write(41)}display(e){const t=this.stringValue;return e=void 0!==t?e.write(t):super.display(e)}toString(){let e=this.stringValue;return void 0===e&&(e=he.display(this),this.stringValue=e),e}}class Wi extends Fi{constructor(){super()}isDefined(){return!1}isAbsolute(){return!1}isRelative(){return!0}isEmpty(){return!0}head(){throw new Error("empty path")}tail(){throw new Error("empty path")}setTail(e){throw new Error("empty path")}dealias(){return this}parent(){return this}base(){return this}appended(...e){return Fi.of(...e)}appendedSlash(){return Fi.slash()}appendedSegment(e){return Fi.segment(e)}prepended(...e){return Fi.of(...e)}prependedSlash(){return Fi.slash()}prependedSegment(e){return Fi.segment(e)}merge(e){return e}debug(e){return e=e.write("UriPath").write(46).write("empty").write(40).write(41)}display(e){return e}toString(){return""}}class Ri{constructor(){this.first=Fi.empty(),this.last=null,this.size=0,this.aliased=0}isEmpty(){return 0===this.size}push(...e){for(let t=0;t<e.length;t+=1){const r=e[t];r instanceof Fi?this.addPath(r):Array.isArray(r)?this.push(...r):"/"===r?this.addSlash():this.addSegment(r)}}bind(){return this.aliased=0,this.first}addSlash(){const e=Fi.slash().dealias(),t=this.size;0===t?this.first=e:this.dealias(t-1).setTail(e),this.last=e,this.size=t+1,this.aliased+=1}addSegment(e){const t=Fi.segment(e,Fi.empty());let r=this.size;if(0===r)this.first=t;else{const e=this.dealias(r-1);e.isAbsolute()?e.setTail(t):(e.setTail(t.prependedSlash()),r+=1,this.aliased+=1)}this.last=t,this.size=r+1,this.aliased+=1}addPath(e){if(!e.isEmpty()){let t=this.size;if(0===t)this.first=e;else{const r=this.dealias(t-1);r.isAbsolute()||e.isAbsolute()?r.setTail(e):(r.setTail(e.prependedSlash()),t+=1,this.aliased+=1)}for(t+=1;;){const r=e.tail();if(r.isEmpty())break;e=r,t+=1}this.last=e,this.size=t}}pop(){const e=this.size,t=this.aliased;if(0===e)throw new Error("Empty UriPath");if(1===e){const r=this.first;return this.first=r.tail(),r.tail().isEmpty()&&(this.last=null),this.size=e-1,t>0&&(this.aliased=t-1),r}{const r=this.dealias(e-2);return r.setTail(Fi.empty()),this.last=r,this.size=e-1,this.aliased=t-1,r.tail()}}dealias(e){let t=0,r=null,i=this.first;if(this.aliased<=e){for(;t<this.aliased;)r=i,i=i.tail(),t+=1;for(;t<=e;){const e=i.dealias();0===t?this.first=e:r.setTail(e),r=e,i=i.tail(),t+=1}t===this.size&&(this.last=r),this.aliased=t}else if(0===e)r=this.first;else if(e===this.size-1)r=this.last;else for(;t<=e;)r=i,i=i.tail(),t+=1;return r}}class Hi extends br{constructor(e){super(),Object.defineProperty(this,"unit",{value:e,enumerable:!0})}withUnit(e){return e!==this.unit?new Hi(e):this}mold(e,t){return e=Fi.fromAny(e),void 0===t?yt.from(e.toString()):t.concat(yt.from(e.toString()))}cast(e,t){const r=e.target;try{const e=r.stringValue();if("string"==typeof e)return Fi.parse(e)}catch(e){}}}class Ki{get length(){let e=0,t=this;for(;!t.isEmpty();)e+=1,t=t.tail();return e}has(e){let t=this;for(;!t.isEmpty();){if(e===t.key)return!0;t=t.tail()}return!1}get(e){let t=this;for(;!t.isEmpty();){if(e===t.key)return t.value;t=t.tail()}}updated(e,t){let r=this;const i=new Qi;let n=!1;for(;!r.isEmpty();)e===r.key?(i.addParam(e,t),n=!0):i.addParam(r.key,r.value),r=r.tail();return n||i.addParam(e,t),i.bind()}removed(e){let t=this;const r=new Qi;let i=!1;for(;!t.isEmpty();)e===t.key?i=!0:r.addParam(t.key,t.value),t=t.tail();return i?r.bind():this}appended(e,t){const r=new Qi;return r.addQuery(this),r.add(e,t),r.bind()}prepended(e,t){const r=new Qi;return r.add(e,t),r.addQuery(this),r.bind()}toAny(e){if(this.isDefined()){e=e||{};let t=this,r=0;for(;!t.isEmpty();){const i=t.key;void 0!==i?e[i]=t.value:e["$"+r]=t.value,t=t.tail(),r+=1}}return e}compareTo(e){return e instanceof Ki?this.toString().localeCompare(e.toString()):NaN}equals(e){return this===e||e instanceof Ki&&this.toString()===e.toString()}hashCode(){return u.hash(this.toString())}display(e){let t=this,r=!0;for(;!t.isEmpty();){r?r=!1:e=e.write(38);const i=t.key;void 0!==i&&(e=(e=Pi.writeParam(e,i)).write(61)),e=Pi.writeQuery(e,t.value),t=t.tail()}return e}static undefined(){return new Gi}static param(e,t,r){return void 0===r?(r=t,t=e,e=void 0):void 0!==e&&(e=this.cacheKey(e)),void 0===r&&(r=Ki.undefined()),new _i(e,t,r)}static fromAny(e){if(null==e)return Ki.undefined();if(e instanceof Ki)return e;if("object"==typeof e){const t=new Qi;return t.add(e),t.bind()}if("string"==typeof e)return Ki.parse(e);throw new TypeError(""+e)}static parse(e){return Pi.standardParser.parseQueryString(e)}static builder(){return new Qi}static get keyCache(){return new R(64)}static cacheKey(e){return e.length<=32?Ki.keyCache.put(e):e}}e([n],Ki,"undefined",null),e([n],Ki,"keyCache",null);class _i extends Ki{constructor(e,t,r){super(),this.key=e,this.value=t,this.rest=r,this.stringValue=void 0}isDefined(){return!0}isEmpty(){return!1}head(){return[this.key,this.value]}tail(){return this.rest}setTail(e){this.rest=e}dealias(){return new _i(this.key,this.value,this.rest)}debug(e){return e=e.write("UriQuery").write(46).write("parse").write(40).write(34).display(this).write(34).write(41)}display(e){const t=this.stringValue;return e=void 0!==t?e.write(t):super.display(e)}toString(){let e=this.stringValue;return void 0===e&&(e=he.display(this),this.stringValue=e),e}}class Gi extends Ki{isDefined(){return!1}isEmpty(){return!0}head(){throw new Error("undefined query")}get key(){throw new Error("undefined query")}get value(){throw new Error("undefined query")}tail(){throw new Error("undefined query")}setTail(e){throw new Error("undefined query")}dealias(){return this}updated(e,t){return Ki.param(e,t,this)}removed(e){return this}appended(e,t){const r=new Qi;return r.add(e,t),r.bind()}prepended(e,t){const r=new Qi;return r.add(e,t),r.bind()}debug(e){return e=e.write("UriQuery").write(46).write("undefined").write(40).write(41)}display(e){return e}toString(){return""}}class Qi{constructor(){this.first=Ki.undefined(),this.last=null,this.size=0,this.aliased=0}isEmpty(){return 0===this.size}add(e,t){if(void 0!==t)this.addParam(e,t);else if("string"==typeof e)this.addParam(void 0,e);else if(e instanceof Ki)this.addQuery(e);else{const t=e;for(const e in t){let r=e;const i=t[e];36===e.charCodeAt(0)&&(r=void 0),this.addParam(r,i)}}}bind(){return this.aliased=0,this.first}addParam(e,t){void 0===t&&(t=e,e=void 0);const r=Ki.param(e,t,Ki.undefined()),i=this.size;0===i?this.first=r:this.dealias(i-1).setTail(r),this.last=r,this.size=i+1,this.aliased+=1}addQuery(e){if(!e.isEmpty()){let t=this.size;for(0===t?this.first=e:this.dealias(t-1).setTail(e),t+=1;;){const r=e.tail();if(r.isEmpty())break;e=r,t+=1}this.last=e,this.size=t}}dealias(e){let t=0,r=null,i=this.first;if(this.aliased<=e){for(;t<this.aliased;)r=i,i=i.tail(),t+=1;for(;t<=e;){const e=i.dealias();0===t?this.first=e:r.setTail(e),r=e,i=i.tail(),t+=1}t===this.size&&(this.last=r),this.aliased=t}else if(0===e)r=this.first;else if(e===this.size-1)r=this.last;else for(;t<=e;)r=i,i=i.tail(),t+=1;return r}}class Zi{constructor(e){this.identifier=e,this.stringValue=void 0}isDefined(){return void 0!==this.identifier}toAny(){return this.identifier}compareTo(e){return e instanceof Zi?this.toString().localeCompare(e.toString()):NaN}equals(e){return this===e||e instanceof Zi&&this.identifier===e.identifier}hashCode(){return u.hash(this.identifier)}debug(e){return e=e.write("UriFragment").write(46),e=this.isDefined()?e.write("parse").write(40).write(34).display(this).write(34).write(41):e.write("undefined").write(40).write(41)}display(e){const t=this.stringValue;return void 0!==t?e=e.write(t):void 0!==this.identifier&&(e=Pi.writeFragment(e,this.identifier)),e}toString(){let e=this.stringValue;return void 0===e&&(e=he.display(this),this.stringValue=e),e}static undefined(){return new Zi(void 0)}static create(e){if(void 0!==e){const t=Zi.cache,r=t.get(e);return void 0!==r?r:t.put(e,new Zi(e))}return Zi.undefined()}static fromAny(e){if(null==e)return Zi.undefined();if(e instanceof Zi)return e;if("string"==typeof e)return Zi.parse(e);throw new TypeError(""+e)}static parse(e){return Pi.standardParser.parseFragmentString(e)}static get cache(){return new U(32)}}e([n],Zi,"undefined",null),e([n],Zi,"cache",null);class Xi extends br{constructor(e){super(),Object.defineProperty(this,"unit",{value:e,enumerable:!0})}withUnit(e){return e!==this.unit?new Xi(e):this}mold(e,t){return e=Pi.fromAny(e),void 0===t?yt.from(e.toString()):t.concat(yt.from(e.toString()))}cast(e,t){const r=e.target;try{const e=r.stringValue();if("string"==typeof e)return Pi.parse(e)}catch(e){}}}class $i{absolute(e,t,r,i,n){return Pi.create(e,t,r,i,n)}scheme(e){return Di.create(e)}authority(e,t,r){return qi.create(e,t,r)}user(e,t){return Ii.create(e,t)}hostName(e){return Vi.hostname(e)}hostIPv4(e){return Vi.ipv4(e)}hostIPv6(e){return Vi.ipv6(e)}port(e){return Li.create(e)}pathEmpty(){return Fi.empty()}pathBuilder(){return new Ri}queryBuilder(){return new Qi}fragment(e){return Zi.create(e)}absoluteParser(){return new Yi(this)}parseAbsolute(e){return Yi.parse(e,this)}parseAbsoluteString(e){const t=ue.stringInput(e);let r=this.parseAbsolute(t);return t.isCont()&&!r.isError()&&(r=Se.error(ce.unexpected(t))),r.bind()}schemeParser(){return new Ji(this)}parseScheme(e){return Ji.parse(e,this)}parseSchemeString(e){const t=ue.stringInput(e);let r=this.parseScheme(t);return t.isCont()&&!r.isError()&&(r=Se.error(ce.unexpected(t))),r.bind()}authorityParser(){return new en(this)}parseAuthority(e){return en.parse(e,this)}parseAuthorityString(e){const t=ue.stringInput(e);let r=this.parseAuthority(t);return t.isCont()&&!r.isError()&&(r=Se.error(ce.unexpected(t))),r.bind()}userParser(){return new tn(this)}parseUser(e){return tn.parse(e,this)}parseUserString(e){const t=ue.stringInput(e);let r=this.parseUser(t);return t.isCont()&&!r.isError()&&(r=Se.error(ce.unexpected(t))),r.bind()}hostParser(){return new rn(this)}parseHost(e){return rn.parse(e,this)}parseHostString(e){const t=ue.stringInput(e);let r=this.parseHost(t);return t.isCont()&&!r.isError()&&(r=Se.error(ce.unexpected(t))),r.bind()}hostAddressParser(){return new nn(this)}parseHostAddress(e){return nn.parse(e,this)}hostLiteralParser(){return new sn(this)}parseHostLiteral(e){return sn.parse(e,this)}portParser(){return new on(this)}parsePort(e){return on.parse(e,this)}parsePortString(e){const t=ue.stringInput(e);let r=this.parsePort(t);return t.isCont()&&!r.isError()&&(r=Se.error(ce.unexpected(t))),r.bind()}pathParser(e){return new an(this,e)}parsePath(e,t){return an.parse(e,this,t)}parsePathString(e){const t=ue.stringInput(e);let r=this.parsePath(t);return t.isCont()&&!r.isError()&&(r=Se.error(ce.unexpected(t))),r.bind()}queryParser(e){return new un(this,e)}parseQuery(e,t){return un.parse(e,this,t)}parseQueryString(e){const t=ue.stringInput(e);let r=this.parseQuery(t);return t.isCont()&&!r.isError()&&(r=Se.error(ce.unexpected(t))),r.bind()}fragmentParser(){return new hn(this)}parseFragment(e){return hn.parse(e,this)}parseFragmentString(e){const t=ue.stringInput(e);let r=this.parseFragment(t);return t.isCont()&&!r.isError()&&(r=Se.error(ce.unexpected(t))),r.bind()}}class Yi extends Se{constructor(e,t,r,i,n,s,o){super(),this.uri=e,this.schemeParser=t,this.authorityParser=r,this.pathParser=i,this.queryParser=n,this.fragmentParser=s,this.step=o}feed(e){return Yi.parse(e,this.uri,this.schemeParser,this.authorityParser,this.pathParser,this.queryParser,this.fragmentParser,this.step)}static parse(e,t,r,i,n,s,o,a=1){let u=0;if(1===a)if(e.isCont()){const t=e.clone();for(;t.isCont()&&(u=t.head(),Pi.isSchemeChar(u));)t.step();a=t.isCont()&&58===u?2:3}else e.isDone()&&(a=3);if(2===a)if((r=void 0===r?t.parseScheme(e):r.feed(e)).isDone()){if(e.isCont()&&58===e.head())e=e.step(),a=3;else if(!e.isEmpty())return Se.error(ce.expected(58,e))}else if(r.isError())return r.asError();if(3===a)if(e.isCont())u=e.head(),47===u?(e=e.step(),a=4):63===u?(e=e.step(),a=7):35===u?(e=e.step(),a=8):a=6;else if(e.isDone())return Se.done(t.absolute(void 0!==r?r.bind():void 0));if(4===a)if(e.isCont()&&47===e.head())e=e.step(),a=5;else if(e.isCont()){const r=t.pathBuilder();r.addSlash(),n=t.parsePath(e,r),a=6}else if(e.isDone())return Se.done(t.absolute(void 0!==r?r.bind():void 0,void 0,Fi.slash()));if(5===a)if((i=void 0===i?t.parseAuthority(e):i.feed(e)).isDone()){if(e.isCont())u=e.head(),63===u?(e=e.step(),a=7):35===u?(e=e.step(),a=8):a=6;else if(e.isDone())return Se.done(t.absolute(void 0!==r?r.bind():void 0,void 0!==i?i.bind():void 0))}else if(i.isError())return i.asError();if(6===a)if((n=void 0===n?t.parsePath(e):n.feed(e)).isDone()){if(e.isCont()&&63===e.head())e=e.step(),a=7;else if(e.isCont()&&35===e.head())e=e.step(),a=8;else if(!e.isEmpty())return Se.done(t.absolute(void 0!==r?r.bind():void 0,void 0!==i?i.bind():void 0,n.bind()))}else if(n.isError())return n.asError();if(7===a)if((s=void 0===s?t.parseQuery(e):s.feed(e)).isDone()){if(e.isCont()&&35===e.head())e=e.step(),a=8;else if(!e.isEmpty())return Se.done(t.absolute(void 0!==r?r.bind():void 0,void 0!==i?i.bind():void 0,void 0!==n?n.bind():void 0,s.bind()))}else if(s.isError())return s.asError();if(8===a){if((o=void 0===o?t.parseFragment(e):o.feed(e)).isDone())return Se.done(t.absolute(void 0!==r?r.bind():void 0,void 0!==i?i.bind():void 0,void 0!==n?n.bind():void 0,void 0!==s?s.bind():void 0,o.bind()));if(o.isError())return o.asError()}return new Yi(t,r,i,n,s,o,a)}}class Ji extends Se{constructor(e,t,r){super(),this.uri=e,this.output=t,this.step=r}feed(e){return Ji.parse(e,this.uri,this.output,this.step)}static parse(e,t,r,i=1){let n=0;if(1===i)if(e.isCont()&&(n=e.head(),Pi.isAlpha(n)))e=e.step(),r=(r=r||Re.decodedString()).write(Pi.toLowerCase(n)),i=2;else if(!e.isEmpty())return Se.error(ce.expected("scheme",e));if(2===i){for(;e.isCont()&&(n=e.head(),Pi.isSchemeChar(n));)e=e.step(),r.write(Pi.toLowerCase(n));if(!e.isEmpty())return Se.done(t.scheme(r.bind()))}return new Ji(t,r,i)}}class en extends Se{constructor(e,t,r,i,n){super(),this.uri=e,this.userParser=t,this.hostParser=r,this.portParser=i,this.step=n}feed(e){return en.parse(e,this.uri,this.userParser,this.hostParser,this.portParser,this.step)}static parse(e,t,r,i,n,s=1){let o=0;if(1===s)if(e.isCont()){const t=e.clone();for(;t.isCont()&&(o=t.head(),64!==o&&47!==o);)t.step();s=t.isCont()&&64===o?2:3}else e.isDone()&&(s=3);if(2===s)if((r=void 0===r?t.parseUser(e):r.feed(e)).isDone()){if(e.isCont()&&64===e.head())e=e.step(),s=3;else if(!e.isEmpty())return Se.error(ce.expected(64,e))}else if(r.isError())return r.asError();if(3===s)if((i=void 0===i?t.parseHost(e):i.feed(e)).isDone()){if(e.isCont()&&58===e.head())e=e.step(),s=4;else if(!e.isEmpty())return Se.done(t.authority(void 0!==r?r.bind():void 0,i.bind()))}else if(i.isError())return i.asError();if(4===s){if((n=void 0===n?t.parsePort(e):n.feed(e)).isDone())return Se.done(t.authority(void 0!==r?r.bind():void 0,i.bind(),n.bind()));if(n.isError())return n.asError()}return new en(t,r,i,n,s)}}class tn extends Se{constructor(e,t,r,i,n){super(),this.uri=e,this.usernameOutput=t,this.passwordOutput=r,this.c1=i,this.step=n}feed(e){return tn.parse(e,this.uri,this.usernameOutput,this.passwordOutput,this.c1,this.step)}static parse(e,t,r,i,n=0,s=1){let o=0;for(;;){if(1===s){for(r=r||Re.decodedString();e.isCont()&&(o=e.head(),Pi.isUserChar(o));)e=e.step(),r.write(o);if(e.isCont()&&58===o)e=e.step(),s=4;else if(e.isCont()&&37===o)e=e.step(),s=2;else if(!e.isEmpty())return Se.done(t.user(r.bind()))}if(2===s)if(e.isCont()&&(o=e.head(),Be.isDigit(o)))e=e.step(),n=o,s=3;else if(!e.isEmpty())return Se.error(ce.expected("hex digit",e));if(3===s){if(e.isCont()&&(o=e.head(),Be.isDigit(o))){e=e.step(),r.write(Be.decodeDigit(n)<<4|Be.decodeDigit(o)),n=0,s=1;continue}if(!e.isEmpty())return Se.error(ce.expected("hex digit",e))}if(4===s){for(i=i||Re.decodedString();e.isCont()&&(o=e.head(),Pi.isUserInfoChar(o));)e=e.step(),i.write(o);if(e.isCont()&&37===o)e=e.step(),s=5;else if(!e.isEmpty())return Se.done(t.user(r.bind(),i.bind()))}if(5===s)if(e.isCont()&&(o=e.head(),Be.isDigit(o)))e=e.step(),n=o,s=6;else if(!e.isEmpty())return Se.error(ce.expected("hex digit",e));if(6===s){if(e.isCont()&&(o=e.head(),Be.isDigit(o))){e=e.step(),i.write(Be.decodeDigit(n)<<4|Be.decodeDigit(o)),n=0,s=4;continue}if(!e.isEmpty())return Se.error(ce.expected("hex digit",e))}break}return new tn(t,r,i,n,s)}}class rn extends Se{constructor(e){super(),this.uri=e}feed(e){return rn.parse(e,this.uri)}static parse(e,t){if(e.isCont()){return 91===e.head()?t.parseHostLiteral(e):t.parseHostAddress(e)}return e.isDone()?Se.done(t.hostName("")):new rn(t)}}class nn extends Se{constructor(e,t,r,i,n){super(),this.uri=e,this.output=t,this.c1=r,this.x=i,this.step=n}feed(e){return nn.parse(e,this.uri,this.output,this.c1,this.x,this.step)}static parse(e,t,r,i=0,n=0,s=1){let o=0;for(r=r||Re.decodedString();s<=4;){for(;e.isCont()&&(o=e.head(),le.isDigit(o));)e=e.step(),r=r.write(o),n=10*n+le.decodeDigit(o);if(!e.isCont()){if(e.isEmpty())break;return 4===s&&n<=255?Se.done(t.hostIPv4(r.bind())):Se.done(t.hostName(r.bind()))}if(!(46===o&&s<4&&n<=255)){if(!Pi.isHostChar(o)&&37!==o&&4===s&&n<=255)return Se.done(t.hostIPv4(r.bind()));n=0,s=5;break}e=e.step(),r=r.write(o),n=0,s+=1}for(;;){if(5===s){for(;e.isCont()&&(o=e.head(),Pi.isHostChar(o));)e=e.step(),r.write(Pi.toLowerCase(o));if(e.isCont()&&37===o)e=e.step(),s=6;else if(!e.isEmpty())return Se.done(t.hostName(r.bind()))}if(6===s)if(e.isCont()&&(o=e.head(),Be.isDigit(o)))e=e.step(),i=o,s=7;else if(!e.isEmpty())return Se.error(ce.expected("hex digit",e));if(7===s){if(e.isCont()&&(o=e.head(),Be.isDigit(o))){e=e.step(),r.write(Be.decodeDigit(i)<<4|Be.decodeDigit(o)),i=0,s=5;continue}if(!e.isEmpty())return Se.error(ce.expected("hex digit",e))}break}return new nn(t,r,i,n,s)}}class sn extends Se{constructor(e,t,r){super(),this.uri=e,this.output=t,this.step=r}feed(e){return sn.parse(e,this.uri,this.output,this.step)}static parse(e,t,r,i=1){let n=0;if(1===i)if(e.isCont()&&91===e.head())e=e.step(),i=2;else if(!e.isEmpty())return Se.error(ce.expected(91,e));if(2===i){for(r=r||Re.decodedString();e.isCont()&&(n=e.head(),Pi.isHostChar(n)||58===n);)e=e.step(),r=r.write(Pi.toLowerCase(n));if(e.isCont()&&93===n)return e=e.step(),Se.done(t.hostIPv6(r.bind()));if(!e.isEmpty())return Se.error(ce.expected(93,e))}return new sn(t,r,i)}}class on extends Se{constructor(e,t){super(),this.uri=e,this.number=t}feed(e){return on.parse(e,this.uri,this.number)}static parse(e,t,r=0){let i=0;for(;e.isCont()&&(i=e.head(),le.isDigit(i));)e=e.step(),r=10*r+le.decodeDigit(i);return e.isEmpty()?new on(t,r):Se.done(t.port(r))}}class an extends Se{constructor(e,t,r,i,n){super(),this.uri=e,this.builder=t,this.output=r,this.c1=i,this.step=n}feed(e){return an.parse(e,this.uri,this.builder,this.output,this.c1,this.step)}static parse(e,t,r,i,n=0,s=1){let o=0;for(;;){if(1===s){for(;e.isCont()&&(o=e.head(),Pi.isPathChar(o));)i=i||Re.decodedString(),e=e.step(),i=i.write(o);if(e.isCont()&&47===o){e=e.step(),r=r||t.pathBuilder(),void 0!==i&&(r.addSegment(i.bind()),i=void 0),r.addSlash();continue}if(e.isCont()&&37===o)e=e.step(),s=2;else if(!e.isEmpty())return void 0!==i&&(r=r||t.pathBuilder()).addSegment(i.bind()),void 0!==r?Se.done(r.bind()):Se.done(t.pathEmpty())}if(2===s)if(e.isCont()&&(o=e.head(),Be.isDigit(o)))e=e.step(),n=o,s=3;else if(!e.isEmpty())return Se.error(ce.expected("hex digit",e));if(3===s){if(e.isCont()&&(o=e.head(),Be.isDigit(o))){i=i||Re.decodedString(),e=e.step(),i=i.write(Be.decodeDigit(n)<<4|Be.decodeDigit(o)),n=0,s=1;continue}if(!e.isEmpty())return Se.error(ce.expected("hex digit",e))}break}return new an(t,r,i,n,s)}}class un extends Se{constructor(e,t,r,i,n,s){super(),this.uri=e,this.builder=t,this.keyOutput=r,this.valueOutput=i,this.c1=n,this.step=s}feed(e){return un.parse(e,this.uri,this.builder,this.keyOutput,this.valueOutput,this.c1,this.step)}static parse(e,t,r,i,n,s=0,o=1){let a=0;for(;;){if(1===o){for(i=i||Re.decodedString();e.isCont()&&(a=e.head(),Pi.isParamChar(a));)e=e.step(),i.write(a);if(e.isCont()&&61===a)e=e.step(),o=4;else{if(e.isCont()&&38===a){e=e.step(),(r=r||t.queryBuilder()).addParam(i.bind()),i=void 0;continue}if(e.isCont()&&37===a)e=e.step(),o=2;else if(!e.isEmpty())return(r=r||t.queryBuilder()).addParam(i.bind()),Se.done(r.bind())}}if(2===o)if(e.isCont()&&(a=e.head(),Be.isDigit(a)))e=e.step(),s=a,o=3;else if(!e.isEmpty())return Se.error(ce.expected("hex digit",e));if(3===o){if(e.isCont()&&(a=e.head(),Be.isDigit(a))){e=e.step(),i.write(Be.decodeDigit(s)<<4|Be.decodeDigit(a)),s=0,o=1;continue}if(!e.isEmpty())return Se.error(ce.expected("hex digit",e))}if(4===o){for(n=n||Re.decodedString();e.isCont()&&(a=e.head(),Pi.isParamChar(a)||61===a);)e=e.step(),n.write(a);if(e.isCont()&&38===a){e=e.step(),(r=r||t.queryBuilder()).addParam(i.bind(),n.bind()),i=void 0,n=void 0,o=1;continue}if(e.isCont()&&37===a)e=e.step(),o=5;else if(!e.isEmpty())return(r=r||t.queryBuilder()).addParam(i.bind(),n.bind()),Se.done(r.bind())}if(5===o)if(e.isCont()&&(a=e.head(),Be.isDigit(a)))e=e.step(),s=a,o=6;else if(!e.isEmpty())return Se.error(ce.expected("hex digit",e));if(6===o){if(e.isCont()&&(a=e.head(),Be.isDigit(a))){e=e.step(),n.write(Be.decodeDigit(s)<<4|Be.decodeDigit(a)),s=0,o=4;continue}if(!e.isEmpty())return Se.error(ce.expected("hex digit",e))}break}return new un(t,r,i,n,s,o)}}class hn extends Se{constructor(e,t,r,i){super(),this.uri=e,this.output=t,this.c1=r,this.step=i}feed(e){return hn.parse(e,this.uri,this.output,this.c1,this.step)}static parse(e,t,r,i=0,n=1){let s=0;for(r=r||Re.decodedString();;){if(1===n){for(;e.isCont()&&(s=e.head(),Pi.isFragmentChar(s));)e=e.step(),r=r.write(s);if(e.isCont()&&37===s)e=e.step(),n=2;else if(!e.isEmpty())return Se.done(t.fragment(r.bind()))}if(2===n)if(e.isCont()&&(s=e.head(),Be.isDigit(s)))e=e.step(),i=s,n=3;else if(!e.isEmpty())return Se.error(ce.expected("hex digit",e));if(3===n){if(e.isCont()&&(s=e.head(),Be.isDigit(s))){e=e.step(),r=r.write(Be.decodeDigit(i)<<4|Be.decodeDigit(s)),i=0,n=1;continue}if(!e.isEmpty())return Se.error(ce.expected("hex digit",e))}break}return new hn(t,r,i,n)}}class ln{get tag(){return this.constructor.tag}toAny(){return this.toValue().toAny()}toRecon(){return Tr.toString(this.toValue())}toString(){return he.debug(this)}static fromValue(e){switch(e.tag){case"open":return pn.fromValue(e);case"opened":return fn.fromValue(e);case"close":return wn.fromValue(e);case"closed":return mn.fromValue(e);case"connect":return gn.fromValue(e);case"connected":return yn.fromValue(e);case"disconnect":return bn.fromValue(e);case"disconnected":return vn.fromValue(e);case"error":return xn.fromValue(e);case"event":return Sn.fromValue(e);case"command":return kn.fromValue(e);case"link":return Tn.fromValue(e);case"linked":return Pn.fromValue(e);case"sync":return Dn.fromValue(e);case"synced":return qn.fromValue(e);case"unlink":return In.fromValue(e);case"unlinked":return Vn.fromValue(e);case"auth":return Nn.fromValue(e);case"authed":return zn.fromValue(e);case"deauth":return Mn.fromValue(e);case"deauthed":return jn.fromValue(e);default:return null}}static parseRecon(e){return this.fromValue(Tr.parse(e))}}class cn extends ln{static fromValue(e){switch(e.tag){case"open":return pn.fromValue(e);case"opened":return fn.fromValue(e);case"close":return wn.fromValue(e);case"closed":return mn.fromValue(e);case"connect":return gn.fromValue(e);case"connected":return yn.fromValue(e);case"disconnect":return bn.fromValue(e);case"disconnected":return vn.fromValue(e);case"error":return xn.fromValue(e);default:return null}}static parseRecon(e){return this.fromValue(Tr.parse(e))}}class dn extends cn{constructor(e,t){super(),this.host=e,this.body=t}withHost(e){return e=Pi.fromAny(e),this.copy(e,this.body)}withBody(e){return e=ht.fromAny(e),this.copy(this.host,e)}copy(e,t){return new this.constructor(e,t)}equals(e){return this===e||e instanceof dn&&(this.constructor===e.constructor&&this.host.equals(e.host)&&this.body.equals(e.body))}hashCode(){return i.mash(i.mix(i.mix(l.hash(this.constructor),this.host.hashCode()),this.body.hashCode()))}debug(e){return e=e.write(this.constructor.name).write(46).write("create").write(40).debug(this.host.toString()),this.body.isDefined()&&(e=e.write(", ").debug(this.body)),e=e.write(41)}toValue(){const e=lt.create(1).slot("host",this.host.toString());return ot.of(this.tag,e).concat(this.body)}static fromValue(e){let t;if(e.header(this.tag).forEach((function(e,r){const i=e.key.stringValue(void 0);void 0!==i?"host"===i&&(t=Pi.parse(e.toValue().stringValue(""))):e instanceof ht&&0===r&&(t=Pi.parse(e.stringValue("")))})),void 0!==t){const r=e.body();return new this(t,r)}return null}static create(e,t){return new this(e=Pi.fromAny(e),t=void 0===t?ht.absent():ht.fromAny(t))}}class pn extends dn{}pn.tag="open";class fn extends dn{}fn.tag="opened";class wn extends dn{}wn.tag="close";class mn extends dn{}mn.tag="closed";class gn extends dn{}gn.tag="connect";class yn extends dn{}yn.tag="connected";class bn extends dn{}bn.tag="disconnect";class vn extends dn{}vn.tag="disconnected";class xn extends dn{}xn.tag="error";class On extends ln{withPrio(e){return this}withRate(e){return this}static fromValue(e){switch(e.tag){case"event":return Sn.fromValue(e);case"command":return kn.fromValue(e);case"link":return Tn.fromValue(e);case"linked":return Pn.fromValue(e);case"sync":return Dn.fromValue(e);case"synced":return qn.fromValue(e);case"unlink":return In.fromValue(e);case"unlinked":return Vn.fromValue(e);case"auth":return Nn.fromValue(e);case"authed":return zn.fromValue(e);case"deauth":return Mn.fromValue(e);case"deauthed":return jn.fromValue(e);default:return null}}static parseRecon(e){return this.fromValue(Tr.parse(e))}}Object.defineProperty(On.prototype,"prio",{get:()=>0,configurable:!0}),Object.defineProperty(On.prototype,"rate",{get:()=>0,configurable:!0});class En extends On{constructor(e){super(),this.body=e}get node(){return Pi.empty()}withNode(e){return this}get lane(){return Pi.empty()}withLane(e){return this}withBody(e){return e=ht.fromAny(e),this.copy(e)}copy(e){return new this.constructor(e)}equals(e){return this===e||e instanceof En&&(this.constructor===e.constructor&&this.body.equals(e.body))}hashCode(){return i.mash(i.mix(l.hash(this.constructor),this.body.hashCode()))}debug(e){return e=e.write(this.constructor.name).write(46).write("create").write(40),this.body.isDefined()&&(e=e.debug(this.body)),e=e.write(41)}toValue(){return ot.of(this.tag).concat(this.body)}static fromValue(e){if(e.header(this.tag).isDefined()){return new this(e.body())}return null}static create(e){return new this(e=void 0===e?ht.absent():ht.fromAny(e))}}class Cn extends On{constructor(e,t,r){super(),this.node=e,this.lane=t,this.body=r}withNode(e){return e=Pi.fromAny(e),this.copy(e,this.lane,this.body)}withLane(e){return e=Pi.fromAny(e),this.copy(this.node,e,this.body)}withBody(e){return e=ht.fromAny(e),this.copy(this.node,this.lane,e)}copy(e,t,r){return new this.constructor(e,t,r)}equals(e){return this===e||e instanceof Cn&&(this.constructor===e.constructor&&this.node.equals(e.node)&&this.lane.equals(e.lane)&&this.body.equals(e.body))}hashCode(){return i.mash(i.mix(i.mix(i.mix(l.hash(this.constructor),this.node.hashCode()),this.lane.hashCode()),this.body.hashCode()))}debug(e){return e=e.write(this.constructor.name).write(46).write("create").write(40).debug(this.node.toString()).write(", ").debug(this.lane.toString()),this.body.isDefined()&&(e=e.write(", ").debug(this.body)),e=e.write(41)}toValue(){const e=lt.create(2).slot("node",this.node.toString()).slot("lane",this.lane.toString());return ot.of(this.tag,e).concat(this.body)}static fromValue(e){let t,r;if(e.header(this.tag).forEach((function(e,i){const n=e.key.stringValue(void 0);void 0!==n?"node"===n?t=Pi.parse(e.toValue().stringValue("")):"lane"===n&&(r=Pi.parse(e.toValue().stringValue(""))):e instanceof ht&&(0===i?t=Pi.parse(e.stringValue("")):1===i&&(r=Pi.parse(e.stringValue(""))))})),void 0!==t&&void 0!==r){const i=e.body();return new this(t,r,i)}return null}static create(e,t,r){return new this(e=Pi.fromAny(e),t=Pi.fromAny(t),r=void 0===r?ht.absent():ht.fromAny(r))}}class An extends On{constructor(e,t,r,i,n){super(),this.node=e,this.lane=t,Object.defineProperty(this,"prio",{value:r,writable:!0,enumerable:!0,configurable:!0}),Object.defineProperty(this,"rate",{value:i,writable:!0,enumerable:!0,configurable:!0}),this.body=n}withNode(e){return e=Pi.fromAny(e),this.copy(e,this.lane,this.prio,this.rate,this.body)}withLane(e){return e=Pi.fromAny(e),this.copy(this.node,e,this.prio,this.rate,this.body)}withPrio(e){return this.copy(this.node,this.lane,e,this.rate,this.body)}withRate(e){return this.copy(this.node,this.lane,this.prio,e,this.body)}withBody(e){return e=ht.fromAny(e),this.copy(this.node,this.lane,this.prio,this.rate,e)}copy(e,t,r,i,n){return new this.constructor(e,t,r,i,n)}equals(e){return this===e||e instanceof An&&(this.constructor===e.constructor&&this.node.equals(e.node)&&this.lane.equals(e.lane)&&this.prio===e.prio&&this.rate===e.rate&&this.body.equals(e.body))}hashCode(){return i.mash(i.mix(i.mix(i.mix(i.mix(i.mix(l.hash(this.constructor),this.node.hashCode()),this.lane.hashCode()),a.hash(this.prio)),a.hash(this.rate)),this.body.hashCode()))}debug(e){return e=e.write(this.constructor.name).write(46).write("create").write(40).debug(this.node.toString()).write(", ").debug(this.lane.toString()),0===this.prio&&0===this.rate||(e=e.write(", ").debug(this.prio).write(", ").debug(this.rate)),this.body.isDefined()&&(e=e.write(", ").debug(this.body)),e=e.write(41)}toValue(){const e=lt.create(4).slot("node",this.node.toString()).slot("lane",this.lane.toString());return 0!==this.prio&&e.slot("prio",this.prio),0!==this.rate&&e.slot("rate",this.rate),ot.of(this.tag,e).concat(this.body)}static fromValue(e){let t,r,i=0,n=0;if(e.header(this.tag).forEach((function(e,s){const o=e.key.stringValue(void 0);void 0!==o?"node"===o?t=Pi.parse(e.toValue().stringValue("")):"lane"===o?r=Pi.parse(e.toValue().stringValue("")):"prio"===o?i=e.numberValue(i):"rate"===o&&(n=e.numberValue(n)):e instanceof ht&&(0===s?t=Pi.parse(e.stringValue("")):1===s&&(r=Pi.parse(e.stringValue(""))))})),void 0!==t&&void 0!==r){const s=e.body();return new this(t,r,i,n,s)}return null}static create(e,t,r,i,n){return void 0===r&&(r=0),void 0===i&&(i=0),new this(e=Pi.fromAny(e),t=Pi.fromAny(t),r,i,n=void 0===n?ht.absent():ht.fromAny(n))}}class Sn extends Cn{}Sn.tag="event";class kn extends Cn{}kn.tag="command";class Tn extends An{}Tn.tag="link";class Pn extends An{}Pn.tag="linked";class Dn extends An{}Dn.tag="sync";class qn extends Cn{}qn.tag="synced";class In extends Cn{}In.tag="unlink";class Vn extends Cn{}Vn.tag="unlinked";class Nn extends En{}Nn.tag="auth";class zn extends En{}zn.tag="authed";class Mn extends En{}Mn.tag="deauth";class jn extends En{}jn.tag="deauthed";class Ln{constructor(e,t){this.hostUri=e,this.options=t,this.sendBuffer=[],this.channel=new MessageChannel,this.socket=null,this.onPortReceive=this.onPortReceive.bind(this),this.channel.port1.addEventListener("message",this.onPortReceive),this.channel.port1.start()}get sendBufferSize(){var e;return null!==(e=this.options.sendBufferSize)&&void 0!==e?e:Ln.SendBufferSize}onPortReceive(e){const t=ht.fromAny(e.data),r=ln.fromValue(t);null!==r?this.onReceiveMessage(r):this.onReceiveUnknownMessage(t)}onReceiveMessage(e){e instanceof cn?this.onReceiveSignal(e):e instanceof On?this.onReceiveEnvelope(e):this.onReceiveUnknownMessage(e)}onReceiveEnvelope(e){this.push(e)}onReceiveSignal(e){e instanceof gn?this.onConnectSignal(e):e instanceof bn?this.onDisconnectSignal(e):this.onReceiveUnexpectedSignal(e)}onConnectSignal(e){this.open()}onDisconnectSignal(e){null!==this.socket&&this.socket.close()}onReceiveUnexpectedSignal(e){throw new Error("unexpected warp host signal: "+e)}onReceiveUnknownMessage(e){throw new Error("unknown warp host message: "+e)}onReceiveUnknownEnvelope(e){throw new Error("unknown warp host envelope: "+e)}get connected(){return null!==this.socket&&this.socket.readyState===this.socket.OPEN}open(){let e=this.socket;if(null===e){let t;if(void 0!==this.options.WebSocket)t=this.options.WebSocket;else if("undefined"!=typeof WebSocket)t=WebSocket;else{if(null===Ln.WebSocket)throw new Error("Missing WebSocket implementation");t=Ln.WebSocket}let r=this.hostUri;const i=r.schemeName;"warp"===i||"swim"===i?r=r.withSchemeName("ws"):"warps"!==i&&"swims"!==i||(r=r.withSchemeName("wss")),e=void 0!==this.options.protocols?new t(r.toString(),this.options.protocols):new t(r.toString()),this.socket=e,e.onopen=this.onWebSocketOpen.bind(this),e.onmessage=this.onWebSocketMessage.bind(this),e.onclose=this.onWebSocketClose.bind(this),e.onerror=this.onWebSocketError.bind(this)}}close(){null!==this.socket&&this.socket.close()}closeUp(){null!==this.socket&&this.socket.close()}onConnect(){this.channel.port1.postMessage(yn.create(this.hostUri).toAny())}onDisconnect(){this.channel.port1.postMessage(vn.create(this.hostUri).toAny())}onError(e){this.channel.port1.postMessage(xn.create(this.hostUri).toAny())}onEnvelope(e){this.channel.port1.postMessage(e.toAny())}push(e){if(this.connected){const t=e.toRecon();this.socket.send(t)}else{if(!(this.sendBuffer.length<this.sendBufferSize))throw new Error("send buffer overflow");this.sendBuffer.push(e),this.open()}}onWebSocketOpen(){if(this.connected){let e;for(this.onConnect();(e=this.sendBuffer.shift())&&this.connected;)this.push(e)}else this.close()}onWebSocketMessage(e){const t=e.data;if("string"==typeof t){const e=On.parseRecon(t);null!==e?this.onEnvelope(e):this.onReceiveUnknownEnvelope(t)}}onWebSocketClose(){const e=this.socket;null!==e&&(e.onopen=null,e.onmessage=null,e.onclose=null,e.onerror=null,this.socket=null),this.onDisconnect()}onWebSocketError(){null!==this.socket&&(this.socket.close(),this.onError())}}Ln.SendBufferSize=1024,Ln.WebSocket=null,"undefined"!=typeof WebSocket&&(Ln.WebSocket=WebSocket);new class{constructor(e,t={}){this.scope=e,this.options=t,this.hosts={},this.onWorkerReceive=this.onWorkerReceive.bind(this),this.scope.addEventListener("message",this.onWorkerReceive)}getHost(e){e=Pi.fromAny(e);const t=this.hosts[e.toString()];return void 0!==t?t:null}openHost(e,t){e=Pi.fromAny(e);const r=this.hosts;let i=r[e.toString()];return void 0===i&&(i=new Ln(e,t),r[e.toString()]=i),i}closeHost(e){const t=this.hosts;void 0!==t[e.hostUri.toString()]&&(delete t[e.hostUri.toString()],e.closeUp())}onWorkerReceive(e){const t=ht.fromAny(e.data),r=ln.fromValue(t);null!==r?this.onMessage(r):this.onUnknownMessage(t)}onMessage(e){e instanceof cn?this.onSignal(e):e instanceof On?this.onEnvelope(e):this.onUnknownMessage(e)}onSignal(e){e instanceof pn?this.onOpenSignal(e):e instanceof wn?this.onCloseSignal(e):this.onUnexpectedSignal(e)}onOpenSignal(e){const t=e.host,r=this.openHost(t,{});r instanceof Ln&&(this.scope.postMessage(fn.create(t).toAny(),[r.channel.port2]),r.open())}onCloseSignal(e){const t=e.host,r=this.getHost(t);r instanceof Ln&&(this.closeHost(r),this.scope.postMessage(mn.create(t).toAny()))}onUnexpectedSignal(e){throw new Error("unexpected warp signal: "+e)}onEnvelope(e){throw new Error("unexpected warp envelope: "+e)}onUnknownMessage(e){throw new Error("unknown warp message: "+e)}}(self)}();';
  class Host {}
  class RemoteHost extends Host {
    constructor(context, hostUri, options) {
      super();
      this.context = context;
      this.hostUri = hostUri;
      this.options = options;
      this.authenticated = false;
      this.session = Value.absent();
      this.sendBuffer = [];
      this.downlinks = new BTree;
      this.downlinkCount = 0;
      this.uriCache = new UriCache(hostUri);
      this.reconnectTimer = 0;
      this.reconnectTimeout = 0;
      this.idleTimer = 0;
    }
    get credentials() {
      var _a;
      return (_a = this.options.credentials) !== null && _a !== void 0 ? _a : Value.absent();
    }
    get unlinkDelay() {
      var _a;
      return (_a = this.options.unlinkDelay) !== null && _a !== void 0 ? _a : RemoteHost.UnlinkDelay;
    }
    get maxReconnectTimeout() {
      var _a;
      return (_a = this.options.maxReconnectTimeout) !== null && _a !== void 0 ? _a : RemoteHost.MaxReconnectTimeout;
    }
    get idleTimeout() {
      var _a;
      return (_a = this.options.idleTimeout) !== null && _a !== void 0 ? _a : RemoteHost.IdleTimeout;
    }
    get sendBufferSize() {
      var _a;
      return (_a = this.options.sendBufferSize) !== null && _a !== void 0 ? _a : RemoteHost.SendBufferSize;
    }
    get idle() {
      return this.sendBuffer.length === 0 && this.downlinkCount === 0;
    }
    resolve(relative) {
      return this.uriCache.resolve(relative);
    }
    unresolve(absolute) {
      return this.uriCache.unresolve(absolute);
    }
    authenticate(credentials) {
      credentials = Value.fromAny(credentials);
      if (!credentials.equals(this.options.credentials)) {
        this.options.credentials = credentials;
        if (this.connected) {
          const request = new AuthRequest(credentials);
          this.push(request);
        } else {
          this.open();
        }
      }
    }
    openDownlink(downlink) {
      this.clearIdle();
      const nodeUri = this.resolve(downlink.nodeUri);
      const laneUri = downlink.laneUri;
      if (this.downlinkCount === 0) {
        this.open();
      }
      let nodeDownlinks = this.downlinks.get(nodeUri);
      if (nodeDownlinks === void 0) {
        nodeDownlinks = new BTree;
        this.downlinks.set(nodeUri, nodeDownlinks);
      }
      if (nodeDownlinks.get(laneUri) !== void 0) {
        throw new Error("duplicate downlink");
      }
      nodeDownlinks.set(laneUri, downlink);
      this.downlinkCount += 1;
      downlink.openUp(this);
      if (this.connected) {
        downlink.hostDidConnect(this);
      }
    }
    unlinkDownlink(downlink) {
      const nodeUri = this.resolve(downlink.nodeUri);
      const laneUri = downlink.laneUri;
      const nodeDownlinks = this.downlinks.get(nodeUri);
      if (nodeDownlinks !== void 0 && nodeDownlinks.get(laneUri) && this.connected) {
        const request = new UnlinkRequest(this.unresolve(nodeUri), laneUri, Value.absent());
        downlink.onUnlinkRequest(request, this);
        this.push(request);
      }
    }
    closeDownlink(downlink) {
      const nodeUri = this.resolve(downlink.nodeUri);
      const laneUri = downlink.laneUri;
      const nodeDownlinks = this.downlinks.get(nodeUri);
      if (nodeDownlinks !== void 0) {
        if (nodeDownlinks.get(laneUri)) {
          this.downlinkCount -= 1;
          nodeDownlinks.delete(laneUri);
          if (nodeDownlinks.isEmpty()) {
            this.downlinks.delete(nodeUri);
          }
          if (this.downlinkCount === 0) {
            this.watchIdle();
          }
          downlink.closeUp(this);
        }
      }
    }
    command(nodeUri, laneUri, body) {
      nodeUri = Uri.fromAny(nodeUri);
      nodeUri = this.resolve(nodeUri);
      laneUri = Uri.fromAny(laneUri);
      body = Value.fromAny(body);
      const message = new CommandMessage(this.unresolve(nodeUri), laneUri, body);
      this.push(message);
    }
    onEnvelope(envelope) {
      if (envelope instanceof EventMessage) {
        this.onEventMessage(envelope);
      } else if (envelope instanceof CommandMessage) {
        this.onCommandMessage(envelope);
      } else if (envelope instanceof LinkRequest) {
        this.onLinkRequest(envelope);
      } else if (envelope instanceof LinkedResponse) {
        this.onLinkedResponse(envelope);
      } else if (envelope instanceof SyncRequest) {
        this.onSyncRequest(envelope);
      } else if (envelope instanceof SyncedResponse) {
        this.onSyncedResponse(envelope);
      } else if (envelope instanceof UnlinkRequest) {
        this.onUnlinkRequest(envelope);
      } else if (envelope instanceof UnlinkedResponse) {
        this.onUnlinkedResponse(envelope);
      } else if (envelope instanceof AuthRequest) {
        this.onAuthRequest(envelope);
      } else if (envelope instanceof AuthedResponse) {
        this.onAuthedResponse(envelope);
      } else if (envelope instanceof DeauthRequest) {
        this.onDeauthRequest(envelope);
      } else if (envelope instanceof DeauthedResponse) {
        this.onDeauthedResponse(envelope);
      } else {
        this.onUnknownEnvelope(envelope);
      }
    }
    onEventMessage(message) {
      const nodeUri = this.resolve(message.node);
      const laneUri = message.lane;
      const nodeDownlinks = this.downlinks.get(nodeUri);
      if (nodeDownlinks !== void 0) {
        const downlink = nodeDownlinks.get(laneUri);
        if (downlink !== void 0) {
          const resolvedMessage = message.withNode(nodeUri);
          downlink.onEventMessage(resolvedMessage, this);
        }
      }
    }
    onCommandMessage(message) {}
    onLinkRequest(request) {}
    onLinkedResponse(response) {
      const nodeUri = this.resolve(response.node);
      const laneUri = response.lane;
      const nodeDownlinks = this.downlinks.get(nodeUri);
      if (nodeDownlinks !== void 0) {
        const downlink = nodeDownlinks.get(laneUri);
        if (downlink !== void 0) {
          const resolvedResponse = response.withNode(nodeUri);
          downlink.onLinkedResponse(resolvedResponse, this);
        }
      }
    }
    onSyncRequest(request) {}
    onSyncedResponse(response) {
      const nodeUri = this.resolve(response.node);
      const laneUri = response.lane;
      const nodeDownlinks = this.downlinks.get(nodeUri);
      if (nodeDownlinks !== void 0) {
        const downlink = nodeDownlinks.get(laneUri);
        if (downlink !== void 0) {
          const resolvedResponse = response.withNode(nodeUri);
          downlink.onSyncedResponse(resolvedResponse, this);
        }
      }
    }
    onUnlinkRequest(request) {}
    onUnlinkedResponse(response) {
      const nodeUri = this.resolve(response.node);
      const laneUri = response.lane;
      const nodeDownlinks = this.downlinks.get(nodeUri);
      if (nodeDownlinks !== void 0) {
        const downlink = nodeDownlinks.get(laneUri);
        if (downlink !== void 0) {
          const resolvedResponse = response.withNode(nodeUri);
          downlink.onUnlinkedResponse(resolvedResponse, this);
        }
      }
    }
    onAuthRequest(request) {}
    onAuthedResponse(response) {
      this.authenticated = true;
      this.session = response.body;
      this.context.hostDidAuthenticate(response.body, this);
    }
    onDeauthRequest(request) {}
    onDeauthedResponse(response) {
      this.authenticated = false;
      this.session = Value.absent();
      this.context.hostDidDeauthenticate(response.body, this);
    }
    onUnknownEnvelope(envelope) {}
    onConnect() {
      this.reconnectTimeout = 0;
      this.context.hostDidConnect(this);
      this.downlinks.forEach((function(nodeUri, nodeDownlinks) {
        nodeDownlinks.forEach((function(laneUri, downlink) {
          downlink.hostDidConnect(this);
        }), this);
      }), this);
    }
    onDisconnect() {
      this.authenticated = false;
      this.session = Value.absent();
      this.context.hostDidDisconnect(this);
      this.downlinks.forEach((function(nodeUri, nodeDownlinks) {
        nodeDownlinks.forEach((function(laneUri, downlink) {
          downlink.hostDidDisconnect(this);
        }), this);
      }), this);
    }
    onError(error) {
      this.context.hostDidFail(error, this);
      this.downlinks.forEach((function(nodeUri, nodeDownlinks) {
        nodeDownlinks.forEach((function(laneUri, downlink) {
          downlink.hostDidFail(error, this);
        }), this);
      }), this);
    }
    reconnect() {
      if (this.reconnectTimer === 0) {
        if (this.reconnectTimeout === 0) {
          this.reconnectTimeout = Math.floor(500 + 1e3 * Math.random());
        } else {
          this.reconnectTimeout = Math.min(Math.floor(1.8 * this.reconnectTimeout), this.maxReconnectTimeout);
        }
        this.reconnectTimer = setTimeout(this.open.bind(this), this.reconnectTimeout);
      }
    }
    clearReconnect() {
      if (this.reconnectTimer !== 0) {
        clearTimeout(this.reconnectTimer);
        this.reconnectTimer = 0;
      }
    }
    watchIdle() {
      if (this.idleTimer === 0 && this.connected && this.idle) {
        this.idleTimer = setTimeout(this.checkIdle.bind(this), this.idleTimeout);
      }
    }
    clearIdle() {
      if (this.idleTimer !== 0) {
        clearTimeout(this.idleTimer);
        this.idleTimer = 0;
      }
    }
    checkIdle() {
      if (this.connected && this.idle) {
        this.close();
      }
    }
    close() {
      this.context.closeHost(this);
    }
    closeUp() {
      this.downlinks.forEach((function(nodeUri, nodeDownlinks) {
        nodeDownlinks.forEach((function(laneUri, downlink) {
          downlink.closeUp(this);
        }), this);
      }), this);
    }
  }
  RemoteHost.UnlinkDelay = 0;
  RemoteHost.MaxReconnectTimeout = 3e4;
  RemoteHost.IdleTimeout = 1e3;
  RemoteHost.SendBufferSize = 1024;
  class WebSocketHost extends RemoteHost {
    constructor(context, hostUri, options) {
      super(context, hostUri, options);
      this.socket = null;
    }
    get connected() {
      return this.socket !== null && this.socket.readyState === this.socket.OPEN;
    }
    open() {
      this.clearReconnect();
      let socket = this.socket;
      if (socket === null) {
        let WebSocketConstructor;
        if (this.options.WebSocket !== void 0) {
          WebSocketConstructor = this.options.WebSocket;
        } else if (typeof WebSocket !== "undefined") {
          WebSocketConstructor = WebSocket;
        } else if (WebSocketHost.WebSocket !== null) {
          WebSocketConstructor = WebSocketHost.WebSocket;
        } else {
          throw new Error("Missing WebSocket implementation");
        }
        let hostUri = this.hostUri;
        const schemeName = hostUri.schemeName;
        if (schemeName === "warp" || schemeName === "swim") {
          hostUri = hostUri.withSchemeName("ws");
        } else if (schemeName === "warps" || schemeName === "swims") {
          hostUri = hostUri.withSchemeName("wss");
        }
        if (this.options.protocols !== void 0) {
          socket = new WebSocketConstructor(hostUri.toString(), this.options.protocols);
        } else {
          socket = new WebSocketConstructor(hostUri.toString());
        }
        this.socket = socket;
        socket.onopen = this.onWebSocketOpen.bind(this);
        socket.onmessage = this.onWebSocketMessage.bind(this);
        socket.onclose = this.onWebSocketClose.bind(this);
        socket.onerror = this.onWebSocketError.bind(this);
      }
    }
    close() {
      this.clearReconnect();
      this.clearIdle();
      if (this.socket !== null) {
        this.socket.close();
        if (!this.context.online) {
          this.onWebSocketClose();
        }
      } else {
        super.close();
      }
    }
    push(envelope) {
      if (this.connected) {
        this.clearIdle();
        const text = envelope.toRecon();
        this.socket.send(text);
        this.watchIdle();
      } else if (envelope instanceof CommandMessage) {
        if (this.sendBuffer.length < this.sendBufferSize) {
          this.sendBuffer.push(envelope);
        } else {
          throw new Error("send buffer overflow");
        }
        this.open();
      }
    }
    onWebSocketOpen() {
      if (this.connected) {
        const credentials = this.credentials;
        if (credentials.isDefined()) {
          const request = new AuthRequest(credentials);
          this.push(request);
        }
        this.onConnect();
        let envelope;
        while ((envelope = this.sendBuffer.shift()) && this.connected) {
          this.push(envelope);
        }
        this.watchIdle();
      } else {
        this.close();
      }
    }
    onWebSocketMessage(message) {
      const data = message.data;
      if (typeof data === "string") {
        const envelope = Envelope.parseRecon(data);
        if (envelope !== null) {
          this.onEnvelope(envelope);
        } else {
          this.onUnknownEnvelope(data);
        }
      }
    }
    onWebSocketClose() {
      const socket = this.socket;
      if (socket !== null) {
        socket.onopen = null;
        socket.onmessage = null;
        socket.onclose = null;
        socket.onerror = null;
        this.socket = null;
      }
      this.onDisconnect();
      this.clearIdle();
      if (!this.idle) {
        if (this.context.online) {
          this.reconnect();
        }
      } else {
        this.close();
      }
    }
    onWebSocketError() {
      if (this.socket !== null) {
        this.socket.close();
        if (!this.context.online) {
          this.onWebSocketClose();
        } else {
          this.onError();
        }
      }
    }
  }
  WebSocketHost.WebSocket = null;
  if (typeof WebSocket !== "undefined") {
    WebSocketHost.WebSocket = WebSocket;
  } else if (typeof ws !== "undefined" && ws.WebSocket !== void 0) {
    WebSocketHost.WebSocket = ws.WebSocket;
  }
  class WarpWorkerHost extends RemoteHost {
    constructor(context, hostUri, options, worker) {
      super(context, hostUri, options);
      this.worker = worker;
      this.port = null;
      this.connected = false;
      this.onWorkerReceive = this.onWorkerReceive.bind(this);
      this.onPortReceive = this.onPortReceive.bind(this);
      this.worker.addEventListener("message", this.onWorkerReceive);
      this.worker.postMessage(OpenSignal.create(this.hostUri).toAny());
    }
    open() {
      const port = this.port;
      if (port !== null) {
        port.postMessage(ConnectSignal.create(this.hostUri).toAny());
      }
    }
    close() {
      this.clearIdle();
      if (this.port !== null) {
        this.worker.postMessage(CloseSignal.create(this.hostUri).toAny());
        if (!this.context.online) {
          this.closeDown();
        }
      } else {
        super.close();
      }
    }
    push(envelope) {
      if (this.connected) {
        this.clearIdle();
        this.port.postMessage(envelope.toAny());
        this.watchIdle();
      } else if (envelope instanceof CommandMessage) {
        if (this.sendBuffer.length < this.sendBufferSize) {
          this.sendBuffer.push(envelope);
        } else {
          throw new Error("send buffer overflow");
        }
      }
    }
    onWorkerReceive(event) {
      const value = Value.fromAny(event.data);
      const signal = Signal.fromValue(value);
      if (signal !== null && signal.host.equals(this.hostUri)) {
        this.onSignal(signal, event);
      }
    }
    onPortReceive(event) {
      const value = Value.fromAny(event.data);
      const message = Message.fromValue(value);
      if (message !== null) {
        this.onMessage(message, event);
      } else {
        this.onUnknownMessage(value);
      }
    }
    onMessage(message, event) {
      if (message instanceof Signal) {
        this.onSignal(message, event);
      } else if (message instanceof Envelope) {
        this.onEnvelope(message);
      } else {
        this.onUnknownMessage(message);
      }
    }
    onSignal(signal, event) {
      if (signal instanceof OpenedSignal) {
        this.onOpenedSignal(signal, event);
      } else if (signal instanceof ClosedSignal) {
        this.onClosedSignal(signal);
      } else if (signal instanceof ConnectedSignal) {
        this.onConnectedSignal(signal);
      } else if (signal instanceof DisconnectedSignal) {
        this.onDisconnectedSignal(signal);
      } else if (signal instanceof ErrorSignal) {
        this.onErrorSignal(signal);
      } else {
        this.onUnexpectedSignal(signal);
      }
    }
    onOpenedSignal(response, event) {
      const port = event.ports[0];
      if (port !== void 0) {
        this.port = port;
        port.addEventListener("message", this.onPortReceive);
        port.start();
      }
    }
    onClosedSignal(response) {
      const port = this.port;
      if (port !== null) {
        this.port = null;
        port.removeEventListener("message", this.onPortReceive);
      }
      this.closeDown();
    }
    onConnectedSignal(response) {
      this.connected = true;
      const credentials = this.credentials;
      if (credentials.isDefined()) {
        const request = new AuthRequest(credentials);
        this.push(request);
      }
      this.onConnect();
      let envelope;
      while ((envelope = this.sendBuffer.shift()) && this.connected) {
        this.push(envelope);
      }
      this.watchIdle();
    }
    onDisconnectedSignal(response) {
      this.connected = false;
      this.onDisconnect();
      this.clearIdle();
      if (!this.idle) {
        if (this.context.online) {
          this.reconnect();
        }
      } else {
        this.close();
      }
    }
    onErrorSignal(response) {}
    onUnexpectedSignal(signal) {
      throw new Error("unexpected warp host signal: " + signal);
    }
    onUnknownMessage(message) {
      throw new Error("unknown warp host message: " + message);
    }
    closeDown() {
      this.onDisconnect();
      this.clearIdle();
      if (!this.idle) {
        if (this.context.online) {
          this.reconnect();
        }
      } else {
        this.close();
      }
    }
    static create(context, hostUri, options) {
      try {
        if (options.worker !== false && this.webworker !== void 0 && typeof Blob !== "undefined") {
          let webworkerUrl = this.webworkerUrl;
          if (webworkerUrl === void 0) {
            const webworkerBlob = new Blob([ this.webworker ], {
              type: "text/javascript"
            });
            webworkerUrl = URL.createObjectURL(webworkerBlob);
            this.webworkerUrl = webworkerUrl;
          }
          const worker = new Worker(webworkerUrl, {
            name: hostUri.toString(),
            type: "classic",
            credentials: "same-origin"
          });
          return new WarpWorkerHost(context, hostUri, options, worker);
        }
      } catch (error) {}
      return null;
    }
  }
  WarpWorkerHost.webworker = e;
  WarpWorkerHost.webworkerUrl = void 0;
  class DownlinkModel {
    constructor(context, hostUri, nodeUri, laneUri, prio = 0, rate = 0, body = Value.absent()) {
      this.context = context;
      this.hostUri = hostUri;
      this.nodeUri = nodeUri;
      this.laneUri = laneUri;
      this.prio = prio;
      this.rate = rate;
      this.body = body;
      this.views = Arrays.empty;
      this.host = null;
      this.status = 0;
    }
    keepLinked() {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        if (views[i].keepLinked()) {
          return true;
        }
      }
      return false;
    }
    keepSynced() {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        if (this.views[i].keepSynced()) {
          return true;
        }
      }
      return false;
    }
    get unlinkDelay() {
      const host = this.host;
      return host !== null ? host.unlinkDelay : 0;
    }
    get connected() {
      const host = this.host;
      return host !== null && host.connected;
    }
    get authenticated() {
      const host = this.host;
      return host !== null && host.authenticated;
    }
    get linked() {
      return (this.status & DownlinkModel.Linked) !== 0;
    }
    get synced() {
      return (this.status & DownlinkModel.Synced) !== 0;
    }
    get session() {
      const host = this.host;
      return host !== null ? host.session : Value.absent();
    }
    addDownlink(view) {
      this.views = Arrays.inserted(view, this.views);
    }
    removeDownlink(view) {
      const oldViews = this.views;
      const newViews = Arrays.removed(view, oldViews);
      if (oldViews !== newViews) {
        this.views = newViews;
        view.closeUp();
        if (newViews.length === 0) {
          const unlinkDelay = this.unlinkDelay;
          if (unlinkDelay < 0) {
            this.unlink();
          } else {
            setTimeout(this.doUnlink.bind(this), unlinkDelay);
          }
        }
      }
    }
    onEventMessage(message, host) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].onEventMessage(message);
      }
    }
    onCommandMessage(body) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].onCommandMessage(body);
      }
    }
    onLinkRequest(request) {
      this.status |= DownlinkModel.Linking;
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].onLinkRequest(request);
      }
    }
    onLinkedResponse(response, host) {
      this.status = this.status & ~DownlinkModel.Linking | DownlinkModel.Linked;
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].onLinkedResponse(response);
      }
    }
    onSyncRequest(request) {
      this.status |= DownlinkModel.Syncing;
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].onSyncRequest(request);
      }
    }
    onSyncedResponse(response, host) {
      this.status = this.status & ~DownlinkModel.Syncing | DownlinkModel.Synced;
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].onSyncedResponse(response);
      }
    }
    onUnlinkRequest(request, host) {
      this.status = this.status & ~(DownlinkModel.Linking | DownlinkModel.Syncing) | DownlinkModel.Unlinking;
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].onUnlinkRequest(request);
      }
    }
    onUnlinkedResponse(response, host) {
      this.status &= ~DownlinkModel.Unlinking;
      const views = this.views;
      if (views.length === 0 || this.status !== 0) {
        for (let i = 0, n = views.length; i < n; i += 1) {
          views[i].onUnlinkedResponse(response);
        }
        this.close();
      } else {
        if (this.keepSynced()) {
          this.sync();
        } else {
          this.link();
        }
      }
    }
    hostDidConnect(host) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].hostDidConnect();
      }
      if (this.keepSynced()) {
        this.sync();
      } else {
        this.link();
      }
    }
    hostDidDisconnect(host) {
      this.status = 0;
      let keepLinked = false;
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        const view = views[i];
        view.hostDidDisconnect();
        keepLinked = keepLinked || view.keepLinked();
      }
      if (!keepLinked) {
        this.close();
      }
    }
    hostDidFail(error, host) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].hostDidFail(error);
      }
    }
    command(body) {
      body = Value.fromAny(body);
      this.onCommandMessage(body);
      this.host.command(this.nodeUri, this.laneUri, body);
    }
    sync() {
      const nodeUri = this.host.unresolve(this.nodeUri);
      const request = new SyncRequest(nodeUri, this.laneUri, this.prio, this.rate, this.body);
      this.onSyncRequest(request);
      this.host.push(request);
    }
    link() {
      const nodeUri = this.host.unresolve(this.nodeUri);
      const request = new LinkRequest(nodeUri, this.laneUri, this.prio, this.rate, this.body);
      this.onLinkRequest(request);
      this.host.push(request);
    }
    unlink() {
      this.status = DownlinkModel.Unlinking;
      this.context.unlinkDownlink(this);
    }
    doUnlink() {
      if (this.views.length === 0) {
        this.unlink();
      }
    }
    close() {
      this.context.closeDownlink(this);
    }
    openUp(host) {
      this.host = host;
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        this.views[i].openUp(host);
      }
    }
    closeUp() {
      const views = this.views;
      this.views = Arrays.empty;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].closeUp();
      }
    }
  }
  DownlinkModel.Linking = 1 << 0;
  DownlinkModel.Linked = 1 << 1;
  DownlinkModel.Syncing = 1 << 2;
  DownlinkModel.Synced = 1 << 3;
  DownlinkModel.Unlinking = 1 << 4;
  exports.DownlinkFlags = void 0;
  (function(DownlinkFlags) {
    DownlinkFlags[DownlinkFlags["KeepLinked"] = 1] = "KeepLinked";
    DownlinkFlags[DownlinkFlags["KeepSynced"] = 2] = "KeepSynced";
    DownlinkFlags[DownlinkFlags["KeepLinkedSynced"] = 3] = "KeepLinkedSynced";
  })(exports.DownlinkFlags || (exports.DownlinkFlags = {}));
  class Downlink {
    constructor(context, owner, init, hostUri = Uri.empty(), nodeUri = Uri.empty(), laneUri = Uri.empty(), prio = 0, rate = 0, body = Value.absent(), flags = 0, observers) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      let observer;
      if (observers === void 0) {
        observers = Arrays.empty;
      } else if (!Array.isArray(observers)) {
        observer = observers;
        observers = [ observer ];
      }
      if (init !== void 0) {
        hostUri = init.hostUri !== void 0 ? Uri.fromAny(init.hostUri) : hostUri;
        nodeUri = init.nodeUri !== void 0 ? Uri.fromAny(init.nodeUri) : nodeUri;
        laneUri = init.laneUri !== void 0 ? Uri.fromAny(init.laneUri) : laneUri;
        prio = init.prio !== void 0 ? init.prio : prio;
        rate = init.rate !== void 0 ? init.rate : rate;
        body = init.body !== void 0 ? Value.fromAny(init.body) : body;
        observer = observer !== null && observer !== void 0 ? observer : {};
        observers = Arrays.inserted(observer, observers);
        observer.onEvent = (_a = init.onEvent) !== null && _a !== void 0 ? _a : observer.onEvent;
        observer.onCommand = (_b = init.onCommand) !== null && _b !== void 0 ? _b : observer.onCommand;
        observer.willLink = (_c = init.willLink) !== null && _c !== void 0 ? _c : observer.willLink;
        observer.didLink = (_d = init.didLink) !== null && _d !== void 0 ? _d : observer.didLink;
        observer.willSync = (_e = init.willSync) !== null && _e !== void 0 ? _e : observer.willSync;
        observer.didSync = (_f = init.didSync) !== null && _f !== void 0 ? _f : observer.didSync;
        observer.willUnlink = (_g = init.willUnlink) !== null && _g !== void 0 ? _g : observer.willUnlink;
        observer.didUnlink = (_h = init.didUnlink) !== null && _h !== void 0 ? _h : observer.didUnlink;
        observer.didConnect = (_j = init.didConnect) !== null && _j !== void 0 ? _j : observer.didConnect;
        observer.didDisconnect = (_k = init.didDisconnect) !== null && _k !== void 0 ? _k : observer.didDisconnect;
        observer.didClose = (_l = init.didClose) !== null && _l !== void 0 ? _l : observer.didClose;
        observer.didFail = (_m = init.didFail) !== null && _m !== void 0 ? _m : observer.didFail;
      }
      this.context = context;
      this.owner = owner;
      this.ownHostUri = hostUri;
      this.ownNodeUri = nodeUri;
      this.ownLaneUri = laneUri;
      this.ownPrio = prio;
      this.ownRate = rate;
      this.ownBody = body;
      this.flags = flags;
      this.model = null;
      this.observers = observers;
    }
    hostUri(hostUri) {
      if (hostUri === void 0) {
        return this.ownHostUri;
      } else {
        hostUri = Uri.fromAny(hostUri);
        return this.copy(this.context, this.owner, hostUri, this.ownNodeUri, this.ownLaneUri, this.ownPrio, this.ownRate, this.ownBody, this.flags, this.observers);
      }
    }
    nodeUri(nodeUri) {
      if (nodeUri === void 0) {
        return this.ownNodeUri;
      } else {
        nodeUri = Uri.fromAny(nodeUri);
        return this.copy(this.context, this.owner, this.ownHostUri, nodeUri, this.ownLaneUri, this.ownPrio, this.ownRate, this.ownBody, this.flags, this.observers);
      }
    }
    laneUri(laneUri) {
      if (laneUri === void 0) {
        return this.ownLaneUri;
      } else {
        laneUri = Uri.fromAny(laneUri);
        return this.copy(this.context, this.owner, this.ownHostUri, this.ownNodeUri, laneUri, this.ownPrio, this.ownRate, this.ownBody, this.flags, this.observers);
      }
    }
    prio(prio) {
      if (prio === void 0) {
        return this.ownPrio;
      } else {
        return this.copy(this.context, this.owner, this.ownHostUri, this.ownNodeUri, this.ownLaneUri, prio, this.ownRate, this.ownBody, this.flags, this.observers);
      }
    }
    rate(rate) {
      if (rate === void 0) {
        return this.ownRate;
      } else {
        return this.copy(this.context, this.owner, this.ownHostUri, this.ownNodeUri, this.ownLaneUri, this.ownPrio, rate, this.ownBody, this.flags, this.observers);
      }
    }
    body(body) {
      if (body === void 0) {
        return this.ownBody;
      } else {
        body = Value.fromAny(body);
        return this.copy(this.context, this.owner, this.ownHostUri, this.ownNodeUri, this.ownLaneUri, this.ownPrio, this.ownRate, body, this.flags, this.observers);
      }
    }
    keepLinked(keepLinked) {
      if (keepLinked === void 0) {
        return (this.flags & 1) !== 0;
      } else {
        const flags = keepLinked ? this.flags | 1 : this.flags & ~1;
        return this.copy(this.context, this.owner, this.ownHostUri, this.ownNodeUri, this.ownLaneUri, this.ownPrio, this.ownRate, this.ownBody, flags, this.observers);
      }
    }
    keepSynced(keepSynced) {
      if (keepSynced === void 0) {
        return (this.flags & 2) !== 0;
      } else {
        const flags = keepSynced ? this.flags | 2 : this.flags & ~2;
        return this.copy(this.context, this.owner, this.ownHostUri, this.ownNodeUri, this.ownLaneUri, this.ownPrio, this.ownRate, this.ownBody, flags, this.observers);
      }
    }
    observe(observer) {
      this.observers = Arrays.inserted(observer, this.observers);
      return this;
    }
    unobserve(observer) {
      const oldObservers = this.observers;
      const n = oldObservers.length;
      for (let i = 0; i < n; i += 1) {
        const oldObserver = oldObservers[i];
        let found = oldObserver === observer;
        if (!found) {
          for (const key in oldObserver) {
            if (oldObserver[key] === observer) {
              found = true;
              break;
            }
          }
        }
        if (found) {
          if (n > 1) {
            const newObservers = new Array(n - 1);
            for (let j = 0; j < i; j += 1) {
              newObservers[j] = oldObservers[j];
            }
            for (let j = i + 1; j < n; j += 1) {
              newObservers[j - 1] = oldObservers[j];
            }
            this.observers = newObservers;
          } else {
            this.observers = Arrays.empty;
          }
          break;
        }
      }
      return this;
    }
    onEvent(onEvent) {
      return this.observe({
        onEvent: onEvent
      });
    }
    onCommand(onCommand) {
      return this.observe({
        onCommand: onCommand
      });
    }
    willLink(willLink) {
      return this.observe({
        willLink: willLink
      });
    }
    didLink(didLink) {
      return this.observe({
        didLink: didLink
      });
    }
    willSync(willSync) {
      return this.observe({
        willSync: willSync
      });
    }
    didSync(didSync) {
      return this.observe({
        didSync: didSync
      });
    }
    willUnlink(willUnlink) {
      return this.observe({
        willUnlink: willUnlink
      });
    }
    didUnlink(didUnlink) {
      return this.observe({
        didUnlink: didUnlink
      });
    }
    didConnect(didConnect) {
      return this.observe({
        didConnect: didConnect
      });
    }
    didDisconnect(didDisconnect) {
      return this.observe({
        didDisconnect: didDisconnect
      });
    }
    didClose(didClose) {
      return this.observe({
        didClose: didClose
      });
    }
    didFail(didFail) {
      return this.observe({
        didFail: didFail
      });
    }
    get connected() {
      const model = this.model;
      return model !== null && model.connected;
    }
    get authenticated() {
      const model = this.model;
      return model !== null && model.authenticated;
    }
    get linked() {
      const model = this.model;
      return model !== null && model.linked;
    }
    get synced() {
      const model = this.model;
      return model !== null && model.synced;
    }
    get session() {
      const model = this.model;
      return model !== null ? model.session : Value.absent();
    }
    onEventMessage(message) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.onEvent !== void 0) {
          observer.onEvent(message.body, this);
        }
      }
    }
    onCommandMessage(body) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.onCommand !== void 0) {
          observer.onCommand(body, this);
        }
      }
    }
    onLinkRequest(request) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.willLink !== void 0) {
          observer.willLink(this);
        }
      }
    }
    onLinkedResponse(response) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didLink !== void 0) {
          observer.didLink(this);
        }
      }
    }
    onSyncRequest(request) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.willSync !== void 0) {
          observer.willSync(this);
        }
      }
    }
    onSyncedResponse(response) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didSync !== void 0) {
          observer.didSync(this);
        }
      }
    }
    onUnlinkRequest(request) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.willUnlink !== void 0) {
          observer.willUnlink(this);
        }
      }
    }
    onUnlinkedResponse(response) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didUnlink !== void 0) {
          observer.didUnlink(this);
        }
      }
    }
    hostDidConnect() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didConnect !== void 0) {
          observer.didConnect(this);
        }
      }
    }
    hostDidDisconnect() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didDisconnect !== void 0) {
          observer.didDisconnect(this);
        }
      }
    }
    hostDidFail(error) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didFail !== void 0) {
          observer.didFail(error, this);
        }
      }
    }
    command(body) {
      this.model.command(body);
    }
    close() {
      const owner = this.owner;
      if (owner !== null) {
        owner.removeDownlink(this);
      }
      const model = this.model;
      if (model !== null) {
        model.removeDownlink(this);
      }
    }
    openUp(host) {}
    closeUp() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didClose !== void 0) {
          observer.didClose(this);
        }
      }
    }
    static initForm() {
      return new DownlinkInitForm;
    }
  }
  __decorate([ Lazy ], Downlink, "initForm", null);
  class DownlinkInitForm extends Form {
    mold(init) {
      if (init !== void 0) {
        const header = Record.create();
        if (init.hostUri !== void 0) {
          header.slot("host", Uri.fromAny(init.hostUri).toString());
        }
        if (init.nodeUri !== void 0) {
          header.slot("node", Uri.fromAny(init.nodeUri).toString());
        }
        if (init.laneUri !== void 0) {
          header.slot("lane", Uri.fromAny(init.laneUri).toString());
        }
        if (init.prio !== void 0) {
          header.slot("prio", init.prio);
        }
        if (init.rate !== void 0) {
          header.slot("rate", init.rate);
        }
        if (init.body !== void 0) {
          header.slot("body", init.body);
        }
        if (init.type !== void 0) {
          header.slot("type", init.type);
        }
        return Record.of(Attr.of("link", header));
      } else {
        return Item.extant();
      }
    }
    cast(item) {
      const value = item.toValue();
      const header = value.get("link");
      if (header.isDefined()) {
        const init = {};
        const host = header.get("host");
        if (host.isDefined()) {
          init.hostUri = host.cast(Uri.form());
        }
        const node = header.get("node");
        if (node.isDefined()) {
          init.nodeUri = node.cast(Uri.form());
        }
        const lane = header.get("lane");
        if (lane.isDefined()) {
          init.laneUri = lane.cast(Uri.form());
        }
        const prio = header.get("prio");
        if (prio.isDefined()) {
          init.prio = prio.numberValue();
        }
        const rate = header.get("rate");
        if (rate.isDefined()) {
          init.rate = rate.numberValue();
        }
        const body = header.get("body");
        if (body.isDefined()) {
          init.body = body;
        }
        const type = header.get("type");
        if (type.isDefined()) {
          init.type = type.stringValue();
        }
        return init;
      }
      return void 0;
    }
  }
  Object.defineProperty(DownlinkInitForm.prototype, "tag", {
    get() {
      return "link";
    },
    configurable: true
  });
  class EventDownlinkModel extends DownlinkModel {
    constructor(context, hostUri, nodeUri, laneUri, prio, rate, body) {
      super(context, hostUri, nodeUri, laneUri, prio, rate, body);
    }
    get type() {
      return "event";
    }
  }
  class EventDownlink extends Downlink {
    constructor(context, owner, init, hostUri, nodeUri, laneUri, prio, rate, body, flags = 1, observers) {
      super(context, owner, init, hostUri, nodeUri, laneUri, prio, rate, body, flags, observers);
    }
    get type() {
      return "event";
    }
    copy(context, owner, hostUri, nodeUri, laneUri, prio, rate, body, flags, observers) {
      return new EventDownlink(context, owner, void 0, hostUri, nodeUri, laneUri, prio, rate, body, flags, observers);
    }
    observe(observer) {
      return super.observe(observer);
    }
    open() {
      const laneUri = this.ownLaneUri;
      if (laneUri.isEmpty()) {
        throw new Error("no lane");
      }
      let nodeUri = this.ownNodeUri;
      if (nodeUri.isEmpty()) {
        throw new Error("no node");
      }
      let hostUri = this.ownHostUri;
      if (hostUri.isEmpty()) {
        hostUri = nodeUri.endpoint();
        nodeUri = hostUri.unresolve(nodeUri);
      }
      let model = this.context.getDownlink(hostUri, nodeUri, laneUri);
      if (model !== void 0) {
        if (!(model instanceof EventDownlinkModel)) {
          throw new Error("downlink type mismatch");
        }
        model.addDownlink(this);
      } else {
        model = new EventDownlinkModel(this.context, hostUri, nodeUri, laneUri, this.ownPrio, this.ownRate, this.ownBody);
        model.addDownlink(this);
        this.context.openDownlink(model);
      }
      this.model = model;
      if (this.owner !== null) {
        this.owner.addDownlink(this);
      }
      return this;
    }
  }
  class ListDownlinkModel extends DownlinkModel {
    constructor(context, hostUri, nodeUri, laneUri, prio, rate, body, state = new STree) {
      super(context, hostUri, nodeUri, laneUri, prio, rate, body);
      this.state = state;
    }
    get type() {
      return "list";
    }
    get length() {
      return this.state.length;
    }
    isEmpty() {
      return this.state.isEmpty();
    }
    get(index, key) {
      return this.state.get(index, key) || Value.absent();
    }
    getEntry(index, key) {
      return this.state.getEntry(index, key);
    }
    set(index, newValue, key) {
      if (key !== void 0) {
        index = this.state.lookup(key, index);
        if (index < 0) {
          throw new RangeError("" + key);
        }
      }
      if (index < 0 || index >= this.state.length) {
        throw new RangeError("" + index);
      }
      newValue = this.listWillUpdate(index, newValue);
      const oldEntry = this.state.getEntry(index);
      this.state.set(index, newValue);
      this.listDidUpdate(index, newValue, oldEntry[1]);
      const header = Record.create(2).slot("key", oldEntry[0]).slot("index", index);
      this.command(Attr.of("update", header).concat(newValue));
      return this;
    }
    insert(index, newValue, key) {
      if (index < 0 || index > this.state.length) {
        throw new RangeError("" + index);
      }
      newValue = this.listWillUpdate(index, newValue);
      this.state.insert(index, newValue, key);
      const newEntry = this.state.getEntry(index);
      this.listDidUpdate(index, newValue, Value.absent());
      const header = Record.create(2).slot("key", newEntry[0]).slot("index", index);
      this.command(Attr.of("update", header).concat(newValue));
      return this;
    }
    remove(index, key) {
      if (key !== void 0) {
        index = this.state.lookup(key, index);
        if (index < 0) {
          throw new RangeError("" + key);
        }
      }
      if (index < 0 || index > this.state.length) {
        throw new RangeError("" + index);
      }
      this.listWillRemove(index);
      const oldEntry = this.state.getEntry(index);
      this.state.remove(index);
      this.listDidRemove(index, oldEntry[1]);
      const header = Record.create(2).slot("key", oldEntry[0]).slot("index", index);
      this.command(Record.create(1).attr("remove", header));
      return this;
    }
    push(...newValues) {
      for (let i = 0; i < newValues.length; i += 1) {
        const index = this.state.length + i;
        const newValue = this.listWillUpdate(index, newValues[i]);
        this.state.insert(index, newValue);
        const newEntry = this.state.getEntry(index);
        this.listDidUpdate(index, newValue, Value.absent());
        const header = Record.create(2).slot("key", newEntry[0]).slot("index", index);
        this.command(Attr.of("update", header).concat(newValue));
      }
      return this.state.length;
    }
    pop() {
      const index = this.state.length - 1;
      if (index >= 0) {
        this.listWillRemove(index);
        const oldEntry = this.state.getEntry(index);
        this.state.remove(index);
        this.listDidRemove(index, oldEntry[1]);
        const header = Record.create(2).slot("key", oldEntry[0]).slot("index", index);
        this.command(Record.create(1).attr("remove", header));
        return oldEntry[1];
      } else {
        return Value.absent();
      }
    }
    unshift(...newValues) {
      for (let i = newValues.length - 1; i >= 0; i -= 1) {
        const newValue = this.listWillUpdate(0, newValues[i]);
        this.state.insert(0, newValue);
        const newEntry = this.state.getEntry(0);
        this.listDidUpdate(0, newValue, Value.absent());
        const header = Record.create(2).slot("key", newEntry[0]).slot("index", 0);
        this.command(Attr.of("update", header).concat(newValue));
      }
      return this.state.length;
    }
    shift() {
      if (this.state.length > 0) {
        this.listWillRemove(0);
        const oldEntry = this.state.getEntry(0);
        this.state.remove(0);
        this.listDidRemove(0, oldEntry[1]);
        const header = Record.create(2).slot("key", oldEntry[0]).slot("index", 0);
        this.command(Record.create(1).attr("remove", header));
        return oldEntry[1];
      } else {
        return Value.absent();
      }
    }
    move(fromIndex, toIndex, key) {
      if (key !== void 0) {
        fromIndex = this.state.lookup(key, fromIndex);
        if (fromIndex < 0) {
          throw new RangeError("" + key);
        }
      }
      if (fromIndex < 0 || fromIndex >= this.state.length) {
        throw new RangeError("" + fromIndex);
      }
      if (toIndex < 0 || toIndex >= this.state.length) {
        throw new RangeError("" + toIndex);
      }
      if (fromIndex !== toIndex) {
        const entry = this.state.getEntry(fromIndex);
        this.listWillMove(fromIndex, toIndex, entry[1]);
        this.state.remove(fromIndex).insert(toIndex, entry[1], entry[0]);
        this.listDidMove(fromIndex, toIndex, entry[1]);
        const header = Record.create(2).slot("key", entry[0]).slot("from", fromIndex).slot("to", toIndex);
        this.command(Record.create(1).attr("move", header));
      }
      return this;
    }
    splice(start, deleteCount, ...newValues) {
      if (start < 0) {
        start = this.state.length + start;
      }
      start = Math.min(Math.max(0, start), this.state.length);
      if (deleteCount === void 0) {
        deleteCount = this.state.length - start;
      }
      const deleted = [];
      for (let i = start, n = start + deleteCount; i < n; i += 1) {
        this.listWillRemove(start);
        const oldEntry = this.state.getEntry(start);
        deleted.push(oldEntry[1]);
        this.state.remove(start);
        this.listDidRemove(start, oldEntry[1]);
        const header = Record.create(2).slot("key", oldEntry[0]).slot("index", start);
        this.command(Record.create(1).attr("remove", header));
      }
      for (let i = 0; i < newValues.length; i += 1) {
        const index = start + i;
        const newValue = this.listWillUpdate(index, newValues[i]);
        this.state.insert(index, newValue);
        const newEntry = this.state.getEntry(index);
        this.listDidUpdate(index, newValue, Value.absent());
        const header = Record.create(2).slot("key", newEntry[0]).slot("index", index);
        this.command(Attr.of("update", header).concat(newValue));
      }
      return deleted;
    }
    clear() {
      this.listWillClear();
      this.state.clear();
      this.listDidClear();
      this.command(Record.create(1).attr("clear"));
    }
    forEach(callback, thisArg) {
      return this.state.forEach(callback, thisArg);
    }
    values() {
      return this.state.values();
    }
    keys() {
      return this.state.keys();
    }
    entries() {
      return this.state.entries();
    }
    snapshot() {
      return this.state.clone();
    }
    setState(state) {
      this.state = state;
    }
    onEventMessage(message, host) {
      super.onEventMessage(message, host);
      const event = message.body;
      const tag = event.tag;
      if (tag === "update") {
        const header = event.head().toValue();
        const index = this.state.lookup(header.get("key"), header.get("index").numberValue());
        if (index >= 0) {
          this.onUpdateEvent(index, event.body(), header.get("key"));
        } else {
          this.onInsertEvent(header.get("index").numberValue(0), event.body(), header.get("key"));
        }
      } else if (tag === "move") {
        const header = event.head().toValue();
        const index = this.state.lookup(header.get("key"), header.get("from").numberValue());
        if (index >= 0) {
          this.onMoveEvent(index, header.get("to").numberValue(0), header.get("key"));
        }
      } else if (tag === "remove") {
        const header = event.head().toValue();
        const index = this.state.lookup(header.get("key"), header.get("index").numberValue());
        if (index >= 0) {
          this.onRemoveEvent(index, header.get("key"));
        }
      } else if (tag === "drop") {
        const header = event.head();
        this.onDropEvent(header.numberValue(0));
      } else if (tag === "take") {
        const header = event.head();
        this.onTakeEvent(header.numberValue(0));
      } else if (tag === "clear") {
        this.onClearEvent();
      }
    }
    onInsertEvent(index, newValue, key) {
      newValue = this.listWillUpdate(index, newValue);
      this.state.insert(index, newValue, key);
      this.listDidUpdate(index, newValue, Value.absent());
    }
    onUpdateEvent(index, newValue, key) {
      newValue = this.listWillUpdate(index, newValue);
      const oldValue = this.state.get(index) || Value.absent();
      this.state.set(index, newValue);
      this.listDidUpdate(index, newValue, oldValue);
    }
    onMoveEvent(fromIndex, toIndex, key) {
      toIndex = Math.min(Math.max(0, toIndex), this.state.length);
      if (fromIndex !== toIndex) {
        const value = this.state.get(fromIndex) || Value.absent();
        this.listWillMove(fromIndex, toIndex, value);
        this.state.remove(fromIndex).insert(toIndex, value, key);
        this.listDidMove(fromIndex, toIndex, value);
      }
    }
    onRemoveEvent(index, key) {
      this.listWillRemove(index);
      const oldValue = this.state.get(index) || Value.absent();
      this.state.remove(index);
      this.listDidRemove(index, oldValue);
    }
    onDropEvent(lower) {
      this.listWillDrop(lower);
      this.state.drop(lower);
      this.listDidDrop(lower);
    }
    onTakeEvent(upper) {
      this.listWillTake(upper);
      this.state.take(upper);
      this.listDidTake(upper);
    }
    onClearEvent() {
      this.listWillClear();
      this.state.clear();
      this.listDidClear();
    }
    listWillUpdate(index, newValue) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        newValue = views[i].listWillUpdate(index, newValue);
      }
      return newValue;
    }
    listDidUpdate(index, newValue, oldValue) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].listDidUpdate(index, newValue, oldValue);
      }
    }
    listWillMove(fromIndex, toIndex, value) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].listWillMove(fromIndex, toIndex, value);
      }
    }
    listDidMove(fromIndex, toIndex, value) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].listDidMove(fromIndex, toIndex, value);
      }
    }
    listWillRemove(index) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].listWillRemove(index);
      }
    }
    listDidRemove(index, oldValue) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].listDidRemove(index, oldValue);
      }
    }
    listWillDrop(lower) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].listWillDrop(lower);
      }
    }
    listDidDrop(lower) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].listDidDrop(lower);
      }
    }
    listWillTake(upper) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].listWillTake(upper);
      }
    }
    listDidTake(upper) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].listDidTake(upper);
      }
    }
    listWillClear() {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].listWillClear();
      }
    }
    listDidClear() {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].listDidClear();
      }
    }
  }
  class ListDownlink extends Downlink {
    constructor(context, owner, init, hostUri, nodeUri, laneUri, prio, rate, body, flags = 3, observers, valueForm, state0 = null) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      super(context, owner, init, hostUri, nodeUri, laneUri, prio, rate, body, flags, observers);
      if (init !== void 0) {
        const observer = this.observers[this.observers.length - 1];
        observer.willUpdate = (_a = init.willUpdate) !== null && _a !== void 0 ? _a : observer.willUpdate;
        observer.didUpdate = (_b = init.didUpdate) !== null && _b !== void 0 ? _b : observer.didUpdate;
        observer.willMove = (_c = init.willMove) !== null && _c !== void 0 ? _c : observer.willMove;
        observer.didMove = (_d = init.didMove) !== null && _d !== void 0 ? _d : observer.didMove;
        observer.willRemove = (_e = init.willRemove) !== null && _e !== void 0 ? _e : observer.willRemove;
        observer.didRemove = (_f = init.didRemove) !== null && _f !== void 0 ? _f : observer.didRemove;
        observer.willDrop = (_g = init.willDrop) !== null && _g !== void 0 ? _g : observer.willDrop;
        observer.didDrop = (_h = init.didDrop) !== null && _h !== void 0 ? _h : observer.didDrop;
        observer.willTake = (_j = init.willTake) !== null && _j !== void 0 ? _j : observer.willTake;
        observer.didTake = (_k = init.didTake) !== null && _k !== void 0 ? _k : observer.didTake;
        observer.willClear = (_l = init.willClear) !== null && _l !== void 0 ? _l : observer.willClear;
        observer.didClear = (_m = init.didClear) !== null && _m !== void 0 ? _m : observer.didClear;
        valueForm = init.valueForm !== void 0 ? init.valueForm : valueForm;
      }
      this.ownValueForm = valueForm !== void 0 ? valueForm : Form.forValue();
      this.state0 = state0;
    }
    get type() {
      return "list";
    }
    copy(context, owner, hostUri, nodeUri, laneUri, prio, rate, body, flags, observers, valueForm, state0) {
      if (arguments.length === 10) {
        valueForm = this.ownValueForm;
        state0 = this.state0;
      }
      return new ListDownlink(context, owner, void 0, hostUri, nodeUri, laneUri, prio, rate, body, flags, observers, valueForm, state0);
    }
    valueForm(valueForm) {
      if (valueForm === void 0) {
        return this.ownValueForm;
      } else {
        return this.copy(this.context, this.owner, this.ownHostUri, this.ownNodeUri, this.ownLaneUri, this.ownPrio, this.ownRate, this.ownBody, this.flags, this.observers, valueForm, this.state0);
      }
    }
    get length() {
      return this.model.length;
    }
    isEmpty() {
      return this.model.isEmpty();
    }
    get(index, id) {
      const value = this.model.get(index, id);
      return value.coerce(this.ownValueForm);
    }
    getEntry(index, id) {
      const entry = this.model.getEntry(index, id);
      if (entry !== void 0) {
        return [ entry[0].coerce(this.ownValueForm), entry[1] ];
      }
      return void 0;
    }
    set(index, newObject, id) {
      const newValue = this.ownValueForm.mold(newObject);
      this.model.set(index, newValue, id);
      return this;
    }
    insert(index, newObject, id) {
      const newValue = this.ownValueForm.mold(newObject);
      this.model.insert(index, newValue, id);
      return this;
    }
    remove(index, id) {
      this.model.remove(index, id);
      return this;
    }
    push(...newObjects) {
      const newValues = new Array(newObjects.length);
      for (let i = 0; i < newObjects.length; i += 1) {
        newValues[i] = this.ownValueForm.mold(newObjects[i]);
      }
      return this.model.push.apply(this.model, newValues);
    }
    pop() {
      const value = this.model.pop();
      return value.coerce(this.ownValueForm);
    }
    unshift(...newObjects) {
      const newValues = new Array(newObjects.length);
      for (let i = 0; i < newObjects.length; i += 1) {
        newValues[i] = this.ownValueForm.mold(newObjects[i]);
      }
      return this.model.unshift.apply(this.model, newValues);
    }
    shift() {
      const value = this.model.shift();
      return value.coerce(this.ownValueForm);
    }
    move(fromIndex, toIndex, id) {
      this.model.move(fromIndex, toIndex, id);
      return this;
    }
    splice(start, deleteCount, ...newObjects) {
      const newValues = new Array(newObjects.length);
      for (let i = 0; i < newObjects.length; i += 1) {
        newValues[i] = this.ownValueForm.mold(newObjects[i]);
      }
      const oldValues = this.model.splice(start, deleteCount, ...newValues);
      const oldObjects = new Array(oldValues.length);
      for (let i = 0; i < oldValues.length; i += 1) {
        oldObjects[i] = oldValues[i].coerce(this.ownValueForm);
      }
      return oldObjects;
    }
    clear() {
      this.model.clear();
    }
    forEach(callback, thisArg) {
      if (this.ownValueForm === Form.forValue()) {
        return this.model.state.forEach(callback, thisArg);
      } else {
        return this.model.state.forEach((function(value, index, id) {
          const object = value.coerce(this.ownValueForm);
          return callback.call(thisArg, object, index, id);
        }), this);
      }
    }
    values() {
      const cursor = this.model.values();
      if (this.ownValueForm === Form.forValue()) {
        return cursor;
      } else {
        return new ValueCursor(cursor, this.ownValueForm);
      }
    }
    keys() {
      return this.model.keys();
    }
    entries() {
      const cursor = this.model.entries();
      if (this.ownValueForm === Form.forValue()) {
        return cursor;
      } else {
        return new ValueEntryCursor(cursor, Form.forValue(), this.ownValueForm);
      }
    }
    snapshot() {
      return this.model.snapshot();
    }
    setState(state) {
      this.model.setState(state);
    }
    observe(observer) {
      return super.observe(observer);
    }
    willUpdate(willUpdate) {
      return this.observe({
        willUpdate: willUpdate
      });
    }
    didUpdate(didUpdate) {
      return this.observe({
        didUpdate: didUpdate
      });
    }
    willMove(willMove) {
      return this.observe({
        willMove: willMove
      });
    }
    didMove(didMove) {
      return this.observe({
        didMove: didMove
      });
    }
    willRemove(willRemove) {
      return this.observe({
        willRemove: willRemove
      });
    }
    didRemove(didRemove) {
      return this.observe({
        didRemove: didRemove
      });
    }
    willDrop(willDrop) {
      return this.observe({
        willDrop: willDrop
      });
    }
    didDrop(didDrop) {
      return this.observe({
        didDrop: didDrop
      });
    }
    willTake(willTake) {
      return this.observe({
        willTake: willTake
      });
    }
    didTake(didTake) {
      return this.observe({
        didTake: didTake
      });
    }
    willClear(willClear) {
      return this.observe({
        willClear: willClear
      });
    }
    didClear(didClear) {
      return this.observe({
        didClear: didClear
      });
    }
    listWillUpdate(index, newValue) {
      let newObject;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.willUpdate !== void 0) {
          if (newObject === void 0) {
            newObject = newValue.coerce(this.ownValueForm);
          }
          const newResult = observer.willUpdate(index, newObject, this);
          if (newResult !== void 0) {
            newObject = newResult;
            newValue = this.ownValueForm.mold(newObject);
          }
        }
      }
      return newValue;
    }
    listDidUpdate(index, newValue, oldValue) {
      let newObject;
      let oldObject;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didUpdate !== void 0) {
          if (newObject === void 0) {
            newObject = newValue.coerce(this.ownValueForm);
          }
          if (oldObject === void 0) {
            oldObject = oldValue.coerce(this.ownValueForm);
          }
          observer.didUpdate(index, newObject, oldObject, this);
        }
      }
    }
    listWillMove(fromIndex, toIndex, value) {
      let object;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.willMove !== void 0) {
          if (object === void 0) {
            object = value.coerce(this.ownValueForm);
          }
          observer.willMove(fromIndex, toIndex, object, this);
        }
      }
    }
    listDidMove(fromIndex, toIndex, value) {
      let object;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didMove !== void 0) {
          if (object === void 0) {
            object = value.coerce(this.ownValueForm);
          }
          observer.didMove(fromIndex, toIndex, object, this);
        }
      }
    }
    listWillRemove(index) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.willRemove !== void 0) {
          observer.willRemove(index, this);
        }
      }
    }
    listDidRemove(index, oldValue) {
      let oldObject;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didRemove !== void 0) {
          if (oldObject === void 0) {
            oldObject = oldValue.coerce(this.ownValueForm);
          }
          observer.didRemove(index, oldObject, this);
        }
      }
    }
    listWillDrop(lower) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.willDrop !== void 0) {
          observer.willDrop(lower, this);
        }
      }
    }
    listDidDrop(lower) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didDrop !== void 0) {
          observer.didDrop(lower, this);
        }
      }
    }
    listWillTake(upper) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.willTake !== void 0) {
          observer.willTake(upper, this);
        }
      }
    }
    listDidTake(upper) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didTake !== void 0) {
          observer.didTake(upper, this);
        }
      }
    }
    listWillClear() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.willClear !== void 0) {
          observer.willClear(this);
        }
      }
    }
    listDidClear() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didClear !== void 0) {
          observer.didClear(this);
        }
      }
    }
    initialState(state0) {
      if (state0 === void 0) {
        return this.state0;
      } else {
        return this.copy(this.context, this.owner, this.ownHostUri, this.ownNodeUri, this.ownLaneUri, this.ownPrio, this.ownRate, this.ownBody, this.flags, this.observers, this.ownValueForm, state0);
      }
    }
    didAliasModel() {
      this.onLinkedResponse();
      this.model.state.forEach((function(value, index) {
        this.listDidUpdate(index, value, Value.absent());
      }), this);
      this.onSyncedResponse();
    }
    open() {
      var _a;
      const laneUri = this.ownLaneUri;
      if (laneUri.isEmpty()) {
        throw new Error("no lane");
      }
      let nodeUri = this.ownNodeUri;
      if (nodeUri.isEmpty()) {
        throw new Error("no node");
      }
      let hostUri = this.ownHostUri;
      if (hostUri.isEmpty()) {
        hostUri = nodeUri.endpoint();
        nodeUri = hostUri.unresolve(nodeUri);
      }
      let model = this.context.getDownlink(hostUri, nodeUri, laneUri);
      if (model !== void 0) {
        if (!(model instanceof ListDownlinkModel)) {
          throw new Error("downlink type mismatch");
        }
        model.addDownlink(this);
        this.model = model;
        setTimeout(this.didAliasModel.bind(this));
      } else {
        model = new ListDownlinkModel(this.context, hostUri, nodeUri, laneUri, this.ownPrio, this.ownRate, this.ownBody, (_a = this.state0) !== null && _a !== void 0 ? _a : void 0);
        model.addDownlink(this);
        this.context.openDownlink(model);
        this.model = model;
      }
      if (this.owner !== null) {
        this.owner.addDownlink(this);
      }
      return this;
    }
  }
  class MapDownlinkModel extends DownlinkModel {
    constructor(context, hostUri, nodeUri, laneUri, prio, rate, body, state = new BTree) {
      super(context, hostUri, nodeUri, laneUri, prio, rate, body);
      this.state = state;
    }
    get type() {
      return "map";
    }
    get size() {
      return this.state.size;
    }
    isEmpty() {
      return this.state.isEmpty();
    }
    has(key) {
      return this.state.has(key);
    }
    get(key) {
      var _a;
      return (_a = this.state.get(key)) !== null && _a !== void 0 ? _a : Value.absent();
    }
    getEntry(index) {
      return this.state.getEntry(index);
    }
    set(key, newValue) {
      var _a;
      newValue = this.mapWillUpdate(key, newValue);
      const oldValue = (_a = this.state.get(key)) !== null && _a !== void 0 ? _a : Value.absent();
      this.state.set(key, newValue);
      this.mapDidUpdate(key, newValue, oldValue);
      const header = Record.create(1).slot("key", key);
      this.command(Attr.of("update", header).concat(newValue));
      return this;
    }
    delete(key) {
      var _a;
      if (this.state.has(key)) {
        this.mapWillRemove(key);
        const oldValue = (_a = this.state.get(key)) !== null && _a !== void 0 ? _a : Value.absent();
        this.state.delete(key);
        this.mapDidRemove(key, oldValue);
        const header = Record.create(1).slot("key", key);
        this.command(Record.create(1).attr("remove", header));
        return true;
      } else {
        return false;
      }
    }
    drop(lower) {
      this.mapWillDrop(lower);
      this.state.drop(lower);
      this.mapDidDrop(lower);
      this.command(Record.create(1).attr("drop", lower));
      return this;
    }
    take(upper) {
      this.mapWillTake(upper);
      this.state.take(upper);
      this.mapDidTake(upper);
      this.command(Record.create(1).attr("take", upper));
      return this;
    }
    clear() {
      this.mapWillClear();
      this.state.clear();
      this.mapDidClear();
      this.command(Record.create(1).attr("clear"));
    }
    forEach(callback, thisArg) {
      return this.state.forEach(callback, thisArg);
    }
    keys() {
      return this.state.keys();
    }
    values() {
      return this.state.values();
    }
    entries() {
      return this.state.entries();
    }
    snapshot() {
      return this.state.clone();
    }
    setState(state) {
      this.state = state;
    }
    onEventMessage(message, host) {
      super.onEventMessage(message, host);
      const event = message.body;
      const tag = event.tag;
      if (tag === "update") {
        const header = event.head().toValue();
        this.onUpdateEvent(header.get("key"), event.body());
      } else if (tag === "remove") {
        const header = event.head().toValue();
        this.onRemoveEvent(header.get("key"));
      } else if (tag === "drop") {
        const header = event.head().toValue();
        this.onDropEvent(header.numberValue(0));
      } else if (tag === "take") {
        const header = event.head().toValue();
        this.onTakeEvent(header.numberValue(0));
      } else if (tag === "clear") {
        this.onClearEvent();
      }
    }
    onUpdateEvent(key, newValue) {
      var _a;
      newValue = this.mapWillUpdate(key, newValue);
      const oldValue = (_a = this.state.get(key)) !== null && _a !== void 0 ? _a : Value.absent();
      this.state.set(key, newValue);
      this.mapDidUpdate(key, newValue, oldValue);
    }
    onRemoveEvent(key) {
      var _a;
      this.mapWillRemove(key);
      const oldValue = (_a = this.state.get(key)) !== null && _a !== void 0 ? _a : Value.absent();
      this.state.delete(key);
      this.mapDidRemove(key, oldValue);
    }
    onDropEvent(lower) {
      this.mapWillDrop(lower);
      this.state.drop(lower);
      this.mapDidDrop(lower);
    }
    onTakeEvent(upper) {
      this.mapWillTake(upper);
      this.state.take(upper);
      this.mapDidTake(upper);
    }
    onClearEvent() {
      this.mapWillClear();
      this.state.clear();
      this.mapDidClear();
    }
    mapWillUpdate(key, newValue) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        newValue = views[i].mapWillUpdate(key, newValue);
      }
      return newValue;
    }
    mapDidUpdate(key, newValue, oldValue) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].mapDidUpdate(key, newValue, oldValue);
      }
    }
    mapWillRemove(key) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].mapWillRemove(key);
      }
    }
    mapDidRemove(key, oldValue) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].mapDidRemove(key, oldValue);
      }
    }
    mapWillDrop(lower) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].mapWillDrop(lower);
      }
    }
    mapDidDrop(lower) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].mapDidDrop(lower);
      }
    }
    mapWillTake(upper) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].mapWillTake(upper);
      }
    }
    mapDidTake(upper) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].mapDidTake(upper);
      }
    }
    mapWillClear() {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].mapWillClear();
      }
    }
    mapDidClear() {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].mapDidClear();
      }
    }
  }
  class MapDownlink extends Downlink {
    constructor(context, owner, init, hostUri, nodeUri, laneUri, prio, rate, body, flags = 3, observers, keyForm, valueForm, state0 = null) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      super(context, owner, init, hostUri, nodeUri, laneUri, prio, rate, body, flags, observers);
      if (init !== void 0) {
        const observer = this.observers[this.observers.length - 1];
        observer.willUpdate = (_a = init.willUpdate) !== null && _a !== void 0 ? _a : observer.willUpdate;
        observer.didUpdate = (_b = init.didUpdate) !== null && _b !== void 0 ? _b : observer.didUpdate;
        observer.willRemove = (_c = init.willRemove) !== null && _c !== void 0 ? _c : observer.willRemove;
        observer.didRemove = (_d = init.didRemove) !== null && _d !== void 0 ? _d : observer.didRemove;
        observer.willDrop = (_e = init.willDrop) !== null && _e !== void 0 ? _e : observer.willDrop;
        observer.didDrop = (_f = init.didDrop) !== null && _f !== void 0 ? _f : observer.didDrop;
        observer.willTake = (_g = init.willTake) !== null && _g !== void 0 ? _g : observer.willTake;
        observer.didTake = (_h = init.didTake) !== null && _h !== void 0 ? _h : observer.didTake;
        observer.willClear = (_j = init.willClear) !== null && _j !== void 0 ? _j : observer.willClear;
        observer.didClear = (_k = init.didClear) !== null && _k !== void 0 ? _k : observer.didClear;
        keyForm = init.keyForm !== void 0 ? init.keyForm : keyForm;
        valueForm = init.valueForm !== void 0 ? init.valueForm : valueForm;
      }
      this.ownKeyForm = keyForm !== void 0 ? keyForm : Form.forValue();
      this.ownValueForm = valueForm !== void 0 ? valueForm : Form.forValue();
      this.state0 = state0;
      this.input = null;
      this.effects = new BTree;
      this.outlets = new BTree;
      this.outputs = Arrays.empty;
      this.version = -1;
    }
    get type() {
      return "map";
    }
    copy(context, owner, hostUri, nodeUri, laneUri, prio, rate, body, flags, observers, keyForm, valueForm, state0) {
      if (arguments.length === 10) {
        state0 = this.state0;
        keyForm = this.ownKeyForm;
        valueForm = this.ownValueForm;
      }
      return new MapDownlink(context, owner, void 0, hostUri, nodeUri, laneUri, prio, rate, body, flags, observers, keyForm, valueForm, state0);
    }
    keyForm(keyForm) {
      if (keyForm === void 0) {
        return this.ownKeyForm;
      } else {
        return this.copy(this.context, this.owner, this.ownHostUri, this.ownNodeUri, this.ownLaneUri, this.ownPrio, this.ownRate, this.ownBody, this.flags, this.observers, keyForm, this.ownValueForm, this.state0);
      }
    }
    valueForm(valueForm) {
      if (valueForm === void 0) {
        return this.ownValueForm;
      } else {
        return this.copy(this.context, this.owner, this.ownHostUri, this.ownNodeUri, this.ownLaneUri, this.ownPrio, this.ownRate, this.ownBody, this.flags, this.observers, this.ownKeyForm, valueForm, this.state0);
      }
    }
    get size() {
      return this.model.size;
    }
    isEmpty() {
      return this.model.isEmpty();
    }
    has(key) {
      const keyObject = this.ownKeyForm.mold(key);
      return this.model.has(keyObject);
    }
    get(key) {
      if (key === void 0) {
        return this;
      } else {
        const keyObject = this.ownKeyForm.mold(key);
        const value = this.model.get(keyObject);
        return value.coerce(this.ownValueForm);
      }
    }
    getEntry(index) {
      const entry = this.model.getEntry(index);
      if (entry !== void 0) {
        return [ entry[0].coerce(this.ownKeyForm), entry[1].coerce(this.ownValueForm) ];
      }
      return void 0;
    }
    firstKey() {
      const key = this.model.state.firstKey();
      if (key !== void 0) {
        const keyObject = this.ownKeyForm.cast(key);
        if (keyObject !== void 0) {
          return keyObject;
        }
      }
      return this.ownKeyForm.unit;
    }
    firstValue() {
      const value = this.model.state.firstValue();
      if (value !== void 0) {
        const object = this.ownValueForm.cast(value);
        if (object !== void 0) {
          return object;
        }
      }
      return this.ownValueForm.unit;
    }
    firstEntry() {
      const entry = this.model.state.firstEntry();
      if (entry !== void 0) {
        const keyObject = this.ownKeyForm.cast(entry[0]);
        const object = this.ownValueForm.cast(entry[1]);
        return [ keyObject, object ];
      }
      return void 0;
    }
    lastKey() {
      const key = this.model.state.lastKey();
      if (key !== void 0) {
        const keyObject = this.ownKeyForm.cast(key);
        if (keyObject !== void 0) {
          return keyObject;
        }
      }
      return this.ownKeyForm.unit;
    }
    lastValue() {
      const value = this.model.state.lastValue();
      if (value !== void 0) {
        const object = this.ownValueForm.cast(value);
        if (object !== void 0) {
          return object;
        }
      }
      return this.ownValueForm.unit;
    }
    lastEntry() {
      const entry = this.model.state.lastEntry();
      if (entry !== void 0) {
        const keyObject = this.ownKeyForm.cast(entry[0]);
        const object = this.ownValueForm.cast(entry[1]);
        return [ keyObject, object ];
      }
      return void 0;
    }
    nextKey(keyObject) {
      const key = this.ownKeyForm.mold(keyObject);
      const nextKey = this.model.state.nextKey(key);
      if (nextKey !== void 0) {
        const nextKeyObject = this.ownKeyForm.cast(nextKey);
        if (nextKeyObject !== void 0) {
          return nextKeyObject;
        }
      }
      return this.ownKeyForm.unit;
    }
    nextValue(keyObject) {
      const key = this.ownKeyForm.mold(keyObject);
      const nextValue = this.model.state.nextValue(key);
      if (nextValue !== void 0) {
        const nextObject = this.ownValueForm.cast(nextValue);
        if (nextObject !== void 0) {
          return nextObject;
        }
      }
      return this.ownValueForm.unit;
    }
    nextEntry(keyObject) {
      const key = this.ownKeyForm.mold(keyObject);
      const entry = this.model.state.nextEntry(key);
      if (entry !== void 0) {
        const keyObject = this.ownKeyForm.cast(entry[0]);
        const object = this.ownValueForm.cast(entry[1]);
        return [ keyObject, object ];
      }
      return void 0;
    }
    previousKey(keyObject) {
      const key = this.ownKeyForm.mold(keyObject);
      const previousKey = this.model.state.previousKey(key);
      if (previousKey !== void 0) {
        const previousKeyObject = this.ownKeyForm.cast(previousKey);
        if (previousKeyObject !== void 0) {
          return previousKeyObject;
        }
      }
      return this.ownKeyForm.unit;
    }
    previousValue(keyObject) {
      const key = this.ownKeyForm.mold(keyObject);
      const previousValue = this.model.state.previousValue(key);
      if (previousValue !== void 0) {
        const previousObject = this.ownValueForm.cast(previousValue);
        if (previousObject !== void 0) {
          return previousObject;
        }
      }
      return this.ownValueForm.unit;
    }
    previousEntry(keyObject) {
      const key = this.ownKeyForm.mold(keyObject);
      const entry = this.model.state.previousEntry(key);
      if (entry !== void 0) {
        const keyObject = this.ownKeyForm.cast(entry[0]);
        const object = this.ownValueForm.cast(entry[1]);
        return [ keyObject, object ];
      }
      return void 0;
    }
    set(key, newValue) {
      const keyObject = this.ownKeyForm.mold(key);
      const newObject = this.ownValueForm.mold(newValue);
      this.model.set(keyObject, newObject);
      return this;
    }
    delete(key) {
      const keyObject = this.ownKeyForm.mold(key);
      return this.model.delete(keyObject);
    }
    drop(lower) {
      this.model.drop(lower);
      return this;
    }
    take(upper) {
      this.model.take(upper);
      return this;
    }
    clear() {
      this.model.clear();
    }
    forEach(callback, thisArg) {
      if (this.ownKeyForm === Form.forValue() && this.ownValueForm === Form.forValue()) {
        return this.model.state.forEach(callback, thisArg);
      } else {
        return this.model.state.forEach((function(key, value) {
          const keyObject = key.coerce(this.ownKeyForm);
          const object = value.coerce(this.ownValueForm);
          return callback.call(thisArg, keyObject, object);
        }), this);
      }
    }
    keys() {
      const cursor = this.model.keys();
      if (this.ownKeyForm === Form.forValue()) {
        return cursor;
      } else {
        return new ValueCursor(cursor, this.ownKeyForm);
      }
    }
    values() {
      const cursor = this.model.values();
      if (this.ownValueForm === Form.forValue()) {
        return cursor;
      } else {
        return new ValueCursor(cursor, this.ownValueForm);
      }
    }
    entries() {
      const cursor = this.model.entries();
      if (this.ownKeyForm === Form.forValue() && this.ownValueForm === Form.forValue()) {
        return cursor;
      } else {
        return new ValueEntryCursor(cursor, this.ownKeyForm, this.ownValueForm);
      }
    }
    snapshot() {
      return this.model.snapshot();
    }
    setState(state) {
      this.model.setState(state);
    }
    observe(observer) {
      return super.observe(observer);
    }
    willUpdate(willUpdate) {
      return this.observe({
        willUpdate: willUpdate
      });
    }
    didUpdate(didUpdate) {
      return this.observe({
        didUpdate: didUpdate
      });
    }
    willRemove(willRemove) {
      return this.observe({
        willRemove: willRemove
      });
    }
    didRemove(didRemove) {
      return this.observe({
        didRemove: didRemove
      });
    }
    willDrop(willDrop) {
      return this.observe({
        willDrop: willDrop
      });
    }
    didDrop(didDrop) {
      return this.observe({
        didDrop: didDrop
      });
    }
    willTake(willTake) {
      return this.observe({
        willTake: willTake
      });
    }
    didTake(didTake) {
      return this.observe({
        didTake: didTake
      });
    }
    willClear(willClear) {
      return this.observe({
        willClear: willClear
      });
    }
    didClear(didClear) {
      return this.observe({
        didClear: didClear
      });
    }
    mapWillUpdate(key, newValue) {
      let keyObject;
      let newObject;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.willUpdate !== void 0) {
          if (keyObject === void 0) {
            keyObject = key.coerce(this.ownKeyForm);
          }
          if (newObject === void 0) {
            newObject = newValue.coerce(this.ownValueForm);
          }
          const newResult = observer.willUpdate(keyObject, newObject, this);
          if (newResult !== void 0) {
            newObject = newResult;
            newValue = this.ownValueForm.mold(newObject);
          }
        }
      }
      return newValue;
    }
    mapDidUpdate(key, newValue, oldValue) {
      const keyObject = key.coerce(this.ownKeyForm);
      let newObject;
      let oldObject;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didUpdate !== void 0) {
          if (newObject === void 0) {
            newObject = newValue.coerce(this.ownValueForm);
          }
          if (oldObject === void 0) {
            oldObject = oldValue.coerce(this.ownValueForm);
          }
          observer.didUpdate(keyObject, newObject, oldObject, this);
        }
      }
      this.decohereInputKey(keyObject, 0);
      this.recohereInput(0);
    }
    mapWillRemove(key) {
      let keyObject;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.willRemove !== void 0) {
          if (keyObject === void 0) {
            keyObject = key.coerce(this.ownKeyForm);
          }
          observer.willRemove(keyObject, this);
        }
      }
    }
    mapDidRemove(key, oldValue) {
      const keyObject = key.coerce(this.ownKeyForm);
      let oldObject;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didRemove !== void 0) {
          if (oldObject === void 0) {
            oldObject = oldValue.coerce(this.ownValueForm);
          }
          observer.didRemove(keyObject, oldObject, this);
        }
      }
      this.decohereInputKey(keyObject, 1);
      this.recohereInput(0);
    }
    mapWillDrop(lower) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.willDrop !== void 0) {
          observer.willDrop(lower, this);
        }
      }
    }
    mapDidDrop(lower) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didDrop !== void 0) {
          observer.didDrop(lower, this);
        }
      }
    }
    mapWillTake(upper) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.willTake !== void 0) {
          observer.willTake(upper, this);
        }
      }
    }
    mapDidTake(upper) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didTake !== void 0) {
          observer.didTake(upper, this);
        }
      }
    }
    mapWillClear() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.willClear !== void 0) {
          observer.willClear(this);
        }
      }
    }
    mapDidClear() {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didClear !== void 0) {
          observer.didClear(this);
        }
      }
    }
    initialState(state0) {
      if (state0 === void 0) {
        return this.state0;
      } else {
        return this.copy(this.context, this.owner, this.ownHostUri, this.ownNodeUri, this.ownLaneUri, this.ownPrio, this.ownRate, this.ownBody, this.flags, this.observers, this.ownKeyForm, this.ownValueForm, state0);
      }
    }
    didAliasModel() {
      this.onLinkedResponse();
      this.model.state.forEach((function(key, value) {
        this.mapDidUpdate(key, value, Value.absent());
      }), this);
      this.onSyncedResponse();
    }
    open() {
      var _a;
      const laneUri = this.ownLaneUri;
      if (laneUri.isEmpty()) {
        throw new Error("no lane");
      }
      let nodeUri = this.ownNodeUri;
      if (nodeUri.isEmpty()) {
        throw new Error("no node");
      }
      let hostUri = this.ownHostUri;
      if (hostUri.isEmpty()) {
        hostUri = nodeUri.endpoint();
        nodeUri = hostUri.unresolve(nodeUri);
      }
      let model = this.context.getDownlink(hostUri, nodeUri, laneUri);
      if (model !== void 0) {
        if (!(model instanceof MapDownlinkModel)) {
          throw new Error("downlink type mismatch");
        }
        model.addDownlink(this);
        this.model = model;
        setTimeout(this.didAliasModel.bind(this));
      } else {
        model = new MapDownlinkModel(this.context, hostUri, nodeUri, laneUri, this.ownPrio, this.ownRate, this.ownBody, (_a = this.state0) !== null && _a !== void 0 ? _a : void 0);
        model.addDownlink(this);
        this.context.openDownlink(model);
        this.model = model;
      }
      if (this.owner !== null) {
        this.owner.addDownlink(this);
      }
      return this;
    }
    keyIterator() {
      return this.keys();
    }
    bindInput(newInput) {
      if (!MapOutlet.is(newInput)) {
        throw new TypeError("" + newInput);
      }
      const oldInput = this.input;
      if (oldInput !== newInput) {
        if (oldInput !== null) {
          oldInput.unbindOutput(this);
        }
        this.input = newInput;
        if (newInput !== null) {
          newInput.bindOutput(this);
        }
      }
    }
    unbindInput() {
      const oldInput = this.input;
      if (oldInput !== null) {
        oldInput.unbindOutput(this);
        this.input = null;
      }
    }
    disconnectInputs() {
      const oldInput = this.input;
      if (oldInput !== null) {
        oldInput.unbindOutput(this);
        this.input = null;
        oldInput.disconnectInputs();
      }
    }
    outlet(key) {
      const oldOutlets = this.outlets;
      let outlet = oldOutlets.get(key);
      if (outlet === void 0) {
        outlet = new KeyOutlet(this, key);
        this.outlets = oldOutlets.updated(key, outlet);
      }
      return outlet;
    }
    outputIterator() {
      return Cursor.array(this.outputs);
    }
    bindOutput(output) {
      this.outputs = Arrays.inserted(output, this.outputs);
    }
    unbindOutput(output) {
      this.outputs = Arrays.removed(output, this.outputs);
    }
    unbindOutputs() {
      const oldOutlets = this.outlets;
      if (oldOutlets.isEmpty()) {
        this.outlets = new BTree;
        oldOutlets.forEach((function(key, keyOutlet) {
          keyOutlet.unbindOutputs();
        }), this);
      }
      const oldOutputs = this.outputs;
      this.outputs = Arrays.empty;
      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {
        const output = oldOutputs[i];
        output.unbindInput();
      }
    }
    disconnectOutputs() {
      const oldOutlets = this.outlets;
      if (oldOutlets.isEmpty()) {
        this.outlets = new BTree;
        oldOutlets.forEach((function(key, keyOutlet) {
          keyOutlet.disconnectOutputs();
        }), this);
      }
      const oldOutputs = this.outputs;
      this.outputs = Arrays.empty;
      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {
        const output = oldOutputs[i];
        output.unbindInput();
        output.disconnectOutputs();
      }
    }
    decohereOutputKey(key, effect) {
      this.decohereKey(key, effect);
    }
    decohereInputKey(key, effect) {
      this.decohereKey(key, effect);
    }
    decohereKey(key, effect) {
      const oldEffects = this.effects;
      if (oldEffects.get(key) !== effect) {
        this.willDecohereKey(key, effect);
        this.effects = oldEffects.updated(key, effect);
        this.version = -1;
        this.onDecohereKey(key, effect);
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          const output = outputs[i];
          if (MapInlet.is(output)) {
            output.decohereOutputKey(key, effect);
          } else {
            output.decohereOutput();
          }
        }
        const outlet = this.outlets.get(key);
        if (outlet !== void 0) {
          outlet.decohereInput();
        }
        this.didDecohereKey(key, effect);
      }
    }
    decohereOutput() {
      this.decohere();
    }
    decohereInput() {
      this.decohere();
    }
    decohere() {
      if (this.version >= 0) {
        this.willDecohere();
        this.version = -1;
        this.onDecohere();
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          const output = outputs[i];
          output.decohereOutput();
        }
        this.outlets.forEach((function(key, outlet) {
          outlet.decohereInput();
        }), this);
        this.didDecohere();
      }
    }
    recohereOutputKey(key, version) {
      this.recohereKey(key, version);
    }
    recohereInputKey(key, version) {
      this.recohereKey(key, version);
    }
    recohereKey(key, version) {
      if (this.version < 0) {
        const oldEffects = this.effects;
        const effect = oldEffects.get(key);
        if (effect !== void 0) {
          this.willRecohereKey(key, effect, version);
          this.effects = oldEffects.removed(key);
          if (this.input !== null) {
            this.input.recohereInputKey(key, version);
          }
          this.onRecohereKey(key, effect, version);
          const outputs = this.outputs;
          for (let i = 0, n = outputs.length; i < n; i += 1) {
            const output = outputs[i];
            if (MapInlet.is(output)) {
              output.recohereOutputKey(key, version);
            }
          }
          const outlet = this.outlets.get(key);
          if (outlet !== void 0) {
            outlet.recohereInput(version);
          }
          this.didRecohereKey(key, effect, version);
        }
      }
    }
    recohereOutput(version) {
      this.recohere(version);
    }
    recohereInput(version) {
      this.recohere(version);
    }
    recohere(version) {
      if (this.version < 0) {
        this.willRecohere(version);
        this.effects.forEach((function(key) {
          this.recohereKey(key, version);
        }), this);
        this.version = version;
        this.onRecohere(version);
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          const output = outputs[i];
          output.recohereOutput(version);
        }
        this.didRecohere(version);
      }
    }
    willDecohereKey(key, effect) {}
    onDecohereKey(key, effect) {}
    didDecohereKey(key, effect) {}
    willDecohere() {}
    onDecohere() {}
    didDecohere() {}
    willRecohereKey(key, effect, version) {}
    onRecohereKey(key, effect, version) {
      if (effect === 0) {
        const input = this.input;
        if (input !== null) {
          const value = input.get(key);
          if (value !== void 0) {
            this.set(key, value);
          } else {
            this.delete(key);
          }
        }
      } else if (effect === 1) {
        this.delete(key);
      }
    }
    didRecohereKey(key, effect, version) {}
    willRecohere(version) {}
    onRecohere(version) {}
    didRecohere(version) {}
  }
  MapOutletCombinators.define(MapDownlink.prototype);
  class ValueDownlinkModel extends DownlinkModel {
    constructor(context, hostUri, nodeUri, laneUri, prio, rate, body, state = Value.absent()) {
      super(context, hostUri, nodeUri, laneUri, prio, rate, body);
      this.state = state;
    }
    get type() {
      return "value";
    }
    get() {
      return this.state;
    }
    set(newValue) {
      newValue = this.valueWillSet(newValue);
      const oldValue = this.state;
      this.setState(newValue);
      this.valueDidSet(newValue, oldValue);
      this.command(newValue);
    }
    setState(state) {
      this.state = state;
    }
    onEventMessage(message, host) {
      super.onEventMessage(message, host);
      this.onSetEvent(message.body);
    }
    onSetEvent(newValue) {
      newValue = this.valueWillSet(newValue);
      const oldValue = this.state;
      this.setState(newValue);
      this.valueDidSet(newValue, oldValue);
    }
    valueWillSet(newValue) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        newValue = views[i].valueWillSet(newValue);
      }
      return newValue;
    }
    valueDidSet(newValue, oldValue) {
      const views = this.views;
      for (let i = 0, n = views.length; i < n; i += 1) {
        views[i].valueDidSet(newValue, oldValue);
      }
    }
  }
  class ValueDownlink extends Downlink {
    constructor(context, owner, init, hostUri, nodeUri, laneUri, prio, rate, body, flags = 3, observers, valueForm, state0 = Value.absent()) {
      var _a, _b;
      super(context, owner, init, hostUri, nodeUri, laneUri, prio, rate, body, flags, observers);
      if (init !== void 0) {
        const observer = this.observers[this.observers.length - 1];
        observer.willSet = (_a = init.willSet) !== null && _a !== void 0 ? _a : observer.willSet;
        observer.didSet = (_b = init.didSet) !== null && _b !== void 0 ? _b : observer.didSet;
        valueForm = init.valueForm !== void 0 ? init.valueForm : valueForm;
      }
      this.ownValueForm = valueForm !== void 0 ? valueForm : Form.forValue();
      this.state0 = state0;
      this.input = null;
      this.outputs = Arrays.empty;
      this.version = -1;
    }
    get type() {
      return "value";
    }
    copy(context, owner, hostUri, nodeUri, laneUri, prio, rate, body, flags, observers, valueForm, state0) {
      if (arguments.length === 10) {
        state0 = this.state0;
        valueForm = this.ownValueForm;
      }
      return new ValueDownlink(context, owner, void 0, hostUri, nodeUri, laneUri, prio, rate, body, flags, observers, valueForm, state0);
    }
    valueForm(valueForm) {
      if (valueForm === void 0) {
        return this.ownValueForm;
      } else {
        return this.copy(this.context, this.owner, this.ownHostUri, this.ownNodeUri, this.ownLaneUri, this.ownPrio, this.ownRate, this.ownBody, this.flags, this.observers, valueForm, this.state0);
      }
    }
    get() {
      const value = this.model.get();
      const object = value.coerce(this.ownValueForm);
      return object;
    }
    set(newObject) {
      const newValue = this.ownValueForm.mold(newObject);
      this.model.set(newValue);
    }
    setState(state) {
      this.model.setState(state);
    }
    observe(observer) {
      return super.observe(observer);
    }
    willSet(willSet) {
      return this.observe({
        willSet: willSet
      });
    }
    didSet(didSet) {
      return this.observe({
        didSet: didSet
      });
    }
    valueWillSet(newValue) {
      let newObject;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.willSet !== void 0) {
          if (newObject === void 0) {
            newObject = newValue.coerce(this.ownValueForm);
          }
          const newResult = observer.willSet(newObject, this);
          if (newResult !== void 0) {
            newObject = newResult;
            newValue = this.ownValueForm.mold(newObject);
          }
        }
      }
      return newValue;
    }
    valueDidSet(newValue, oldValue) {
      let newObject;
      let oldObject;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didSet !== void 0) {
          if (newObject === void 0) {
            newObject = newValue.coerce(this.ownValueForm);
          }
          if (oldObject === void 0) {
            oldObject = oldValue.coerce(this.ownValueForm);
          }
          observer.didSet(newObject, oldObject, this);
        }
      }
      this.decohere();
      this.recohere(0);
    }
    initialState(state0) {
      if (state0 === void 0) {
        return this.state0;
      } else {
        return this.copy(this.context, this.owner, this.ownHostUri, this.ownNodeUri, this.ownLaneUri, this.ownPrio, this.ownRate, this.ownBody, this.flags, this.observers, this.ownValueForm, state0);
      }
    }
    didAliasModel() {
      this.onLinkedResponse();
      this.valueDidSet(this.model.get(), Value.absent());
      this.onSyncedResponse();
    }
    open() {
      const laneUri = this.ownLaneUri;
      if (laneUri.isEmpty()) {
        throw new Error("no lane");
      }
      let nodeUri = this.ownNodeUri;
      if (nodeUri.isEmpty()) {
        throw new Error("no node");
      }
      let hostUri = this.ownHostUri;
      if (hostUri.isEmpty()) {
        hostUri = nodeUri.endpoint();
        nodeUri = hostUri.unresolve(nodeUri);
      }
      let model = this.context.getDownlink(hostUri, nodeUri, laneUri);
      if (model !== void 0) {
        if (!(model instanceof ValueDownlinkModel)) {
          throw new Error("downlink type mismatch");
        }
        model.addDownlink(this);
        this.model = model;
        setTimeout(this.didAliasModel.bind(this));
      } else {
        model = new ValueDownlinkModel(this.context, hostUri, nodeUri, laneUri, this.ownPrio, this.ownRate, this.ownBody, this.state0);
        model.addDownlink(this);
        this.context.openDownlink(model);
        this.model = model;
      }
      if (this.owner !== null) {
        this.owner.addDownlink(this);
      }
      return this;
    }
    bindInput(newInput) {
      const oldInput = this.input;
      if (oldInput !== newInput) {
        if (oldInput !== null) {
          oldInput.unbindOutput(this);
        }
        this.input = newInput;
        if (newInput !== null) {
          newInput.bindOutput(this);
        }
      }
    }
    unbindInput() {
      const oldInput = this.input;
      if (oldInput !== null) {
        oldInput.unbindOutput(this);
        this.input = null;
      }
    }
    disconnectInputs() {
      const oldInput = this.input;
      if (oldInput !== null) {
        oldInput.unbindOutput(this);
        this.input = null;
        oldInput.disconnectInputs();
      }
    }
    outputIterator() {
      return Cursor.array(this.outputs);
    }
    bindOutput(output) {
      this.outputs = Arrays.inserted(output, this.outputs);
    }
    unbindOutput(output) {
      this.outputs = Arrays.removed(output, this.outputs);
    }
    unbindOutputs() {
      const oldOutputs = this.outputs;
      this.outputs = Arrays.empty;
      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {
        const output = oldOutputs[i];
        output.unbindInput();
      }
    }
    disconnectOutputs() {
      const oldOutputs = this.outputs;
      this.outputs = Arrays.empty;
      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {
        const output = oldOutputs[i];
        output.unbindInput();
        output.disconnectOutputs();
      }
    }
    decohereOutput() {
      this.decohere();
    }
    decohereInput() {
      this.decohere();
    }
    decohere() {
      if (this.version >= 0) {
        this.willDecohere();
        this.version = -1;
        this.onDecohere();
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          outputs[i].decohereOutput();
        }
        this.didDecohere();
      }
    }
    recohereOutput(version) {
      this.recohere(version);
    }
    recohereInput(version) {
      this.recohere(version);
    }
    recohere(version) {
      if (this.version < 0) {
        this.willRecohere(version);
        this.version = version;
        if (this.input !== null) {
          this.input.recohereInput(version);
        }
        this.onRecohere(version);
        const outputs = this.outputs;
        for (let i = 0, n = outputs.length; i < n; i += 1) {
          outputs[i].recohereOutput(version);
        }
        this.didRecohere(version);
      }
    }
    willDecohere() {}
    onDecohere() {}
    didDecohere() {}
    willRecohere(version) {}
    onRecohere(version) {
      const input = this.input;
      if (input !== null) {
        const value = input.get();
        if (value !== void 0) {
          this.set(value);
        }
      }
    }
    didRecohere(version) {}
  }
  OutletCombinators.define(ValueDownlink.prototype);
  class DownlinkRecord extends AbstractRecordOutlet {}
  class ListDownlinkRecord extends DownlinkRecord {
    constructor(downlink) {
      super();
      this.downlink = downlink;
    }
    isEmpty() {
      return this.downlink.isEmpty();
    }
    isArray() {
      return true;
    }
    isObject() {
      return this.downlink.isEmpty();
    }
    get length() {
      return this.downlink.length;
    }
    has(key) {
      return false;
    }
    get(key) {
      if (key === void 0) {
        return this;
      } else {
        return Value.absent();
      }
    }
    getAttr(key) {
      return Value.absent();
    }
    getSlot(key) {
      return Value.absent();
    }
    getItem(index) {
      if (index instanceof Num) {
        index = index.value;
      }
      const n = this.downlink.length;
      if (index < 0) {
        index = n + index;
      }
      index = Math.min(Math.max(0, index), n - 1);
      if (index >= 0) {
        return this.downlink.get(index);
      }
      return Item.absent();
    }
    set(key, newValue) {
      throw new Error("unsupported");
    }
    setAttr(key, newValue) {
      throw new Error("unsupported");
    }
    setSlot(key, newValue) {
      throw new Error("unsupported");
    }
    setItem(index, newItem) {
      if (index instanceof Num) {
        index = index.value;
      }
      const n = this.downlink.length;
      if (index < 0) {
        index = n + index;
      }
      index = Math.min(Math.max(0, index), n - 1);
      if (index >= 0) {
        this.downlink.set(index, Value.fromAny(newItem));
      }
      return this;
    }
    push(...newItems) {
      return this.downlink.push(...newItems);
    }
    splice(start, deleteCount, ...newItems) {
      return this.downlink.splice(start, deleteCount, ...newItems);
    }
    delete(key) {
      return Item.absent();
    }
    clear() {
      this.downlink.clear();
    }
    forEach(callback, thisArg) {
      return this.downlink.forEach(callback, thisArg);
    }
    keyIterator() {
      return Cursor.empty();
    }
  }
  class MapDownlinkRecord extends DownlinkRecord {
    constructor(downlink) {
      super();
      this.downlink = downlink;
      downlink.observe(this);
    }
    isEmpty() {
      return this.downlink.isEmpty();
    }
    isArray() {
      return this.downlink.isEmpty();
    }
    isObject() {
      return true;
    }
    get length() {
      return this.downlink.size;
    }
    has(key) {
      return this.downlink.has(key);
    }
    get(key) {
      if (key === void 0) {
        return this;
      } else {
        return this.downlink.get(key);
      }
    }
    getAttr(key) {
      return Value.absent();
    }
    getSlot(key) {
      return this.get(key);
    }
    getItem(index) {
      if (index instanceof Num) {
        index = index.value;
      }
      const n = this.downlink.size;
      if (index < 0) {
        index = n + index;
      }
      index = Math.min(Math.max(0, index), n - 1);
      if (index >= 0) {
        const entry = this.downlink.getEntry(index);
        return Slot.of(entry[0], entry[1]);
      }
      return Item.absent();
    }
    set(key, newValue) {
      this.downlink.set(key, newValue);
      return this;
    }
    setAttr(key, newValue) {
      throw new Error("unsupported");
    }
    setSlot(key, newValue) {
      return this.set(key, newValue);
    }
    setItem(index, newItem) {
      throw new Error("unsupported");
    }
    push(...newItems) {
      throw new Error("unsupported");
    }
    splice(start, deleteCount, ...newItems) {
      throw new Error("unsupported");
    }
    delete(key) {
      key = Value.fromAny(key);
      const oldValue = this.downlink.get(key);
      if (this.downlink.delete(key)) {
        return Slot.of(key, oldValue);
      }
      return Item.absent();
    }
    clear() {
      this.downlink.clear();
    }
    forEach(callback, thisArg) {
      let index = 0;
      return this.downlink.forEach((function(key, value) {
        const result = callback.call(thisArg, Slot.of(key, value), index);
        index += 1;
        return result;
      }));
    }
    keyIterator() {
      return this.downlink.keys();
    }
    didUpdate(key, newValue, oldValue) {
      this.decohereInputKey(key, 0);
      this.recohereInput(0);
    }
    didRemove(key, oldValue) {
      this.decohereInputKey(key, 1);
      this.recohereInput(0);
    }
    didDrop(lower) {}
    didTake(upper) {}
    didClear() {}
  }
  class ValueDownlinkRecord extends DownlinkRecord {
    constructor(downlink) {
      super();
      this.downlink = downlink;
      downlink.observe(this);
    }
    isEmpty() {
      const value = this.downlink.get();
      if (value instanceof Record) {
        return value.isEmpty();
      } else {
        return !value.isDefined();
      }
    }
    isArray() {
      const value = this.downlink.get();
      if (value instanceof Record) {
        return value.isArray();
      } else {
        return true;
      }
    }
    isObject() {
      const value = this.downlink.get();
      if (value instanceof Record) {
        return value.isObject();
      } else {
        return !value.isDefined();
      }
    }
    get length() {
      const value = this.downlink.get();
      if (value instanceof Record) {
        return value.length;
      } else if (value.isDefined()) {
        return 1;
      } else {
        return 0;
      }
    }
    has(key) {
      const value = this.downlink.get();
      if (value instanceof Record) {
        return value.has(key);
      } else {
        return false;
      }
    }
    get(key) {
      if (key === void 0) {
        return this;
      } else {
        const value = this.downlink.get();
        if (value instanceof Record) {
          return value.get(key);
        } else {
          return Value.absent();
        }
      }
    }
    getAttr(key) {
      const value = this.downlink.get();
      if (value instanceof Record) {
        return value.getAttr(key);
      } else {
        return Value.absent();
      }
    }
    getSlot(key) {
      const value = this.downlink.get();
      if (value instanceof Record) {
        return value.getSlot(key);
      } else {
        return Value.absent();
      }
    }
    getField(key) {
      const value = this.downlink.get();
      if (value instanceof Record) {
        return value.getField(key);
      } else {
        return void 0;
      }
    }
    getItem(index) {
      const value = this.downlink.get();
      if (value instanceof Record) {
        return value.getItem(index);
      } else {
        return value;
      }
    }
    set(key, newValue) {
      const value = this.downlink.get();
      if (value instanceof Record) {
        value.set(key, newValue);
      } else {
        throw new Error("unsupported");
      }
      return this;
    }
    setAttr(key, newValue) {
      const value = this.downlink.get();
      if (value instanceof Record) {
        value.setAttr(key, newValue);
      } else {
        throw new Error("unsupported");
      }
      return this;
    }
    setSlot(key, newValue) {
      const value = this.downlink.get();
      if (value instanceof Record) {
        value.setSlot(key, newValue);
      } else {
        throw new Error("unsupported");
      }
      return this;
    }
    setItem(index, newItem) {
      const value = this.downlink.get();
      if (value instanceof Record) {
        value.setItem(index, newItem);
      } else {
        this.downlink.set(Item.fromAny(newItem).toValue());
      }
      return this;
    }
    push(...newItems) {
      const value = this.downlink.get();
      if (value instanceof Record) {
        return value.push(...newItems);
      } else {
        throw new Error("unsupported");
      }
    }
    splice(start, deleteCount, ...newItems) {
      const value = this.downlink.get();
      if (value instanceof Record) {
        return value.splice(start, deleteCount, ...newItems);
      } else {
        throw new Error("unsupported");
      }
    }
    delete(key) {
      const value = this.downlink.get();
      if (value instanceof Record) {
        return value.delete(key);
      } else {
        return Value.absent();
      }
    }
    clear() {
      const value = this.downlink.get();
      if (value instanceof Record) {
        value.clear();
      } else {
        throw new Error("unsupported");
      }
    }
    forEach(callback, thisArg) {
      const value = this.downlink.get();
      return value.forEach(callback, thisArg);
    }
    keyIterator() {
      const value = this.downlink.get();
      if (value instanceof Record) {
        throw new Error;
      } else {
        return Cursor.empty();
      }
    }
    didSet(newValue, oldValue) {
      this.decohereInput();
      this.recohereInput(0);
    }
  }
  class DownlinkReifier extends Reifier {
    constructor(warp = null) {
      super();
      this.warp = warp;
    }
    reify(item) {
      if (item instanceof Field) {
        return this.reifyField(item);
      } else {
        return this.reifyValue(item);
      }
    }
    reifyField(field) {
      const oldValue = field.value;
      const newValue = this.reifyValue(oldValue);
      if (oldValue !== newValue) {
        return field.updatedValue(newValue);
      } else {
        return field;
      }
    }
    reifyValue(value) {
      if (value instanceof RecordModel) {
        return this.reifyModel(value);
      } else {
        return value;
      }
    }
    reifyModel(model) {
      if (model.tag === "link") {
        const streamlet = new DownlinkStreamlet(this.warp, model);
        streamlet.compile();
        return streamlet;
      }
      return model;
    }
  }
  class DownlinkStreamlet extends AbstractRecordStreamlet {
    constructor(warp = null, scope) {
      super(scope);
      this.hostUri = this.inoutlet();
      this.nodeUri = this.inoutlet();
      this.laneUri = this.inoutlet();
      this.prio = this.inoutlet();
      this.rate = this.inoutlet();
      this.bodyValue = this.inoutlet();
      this.type = this.inoutlet();
      this.state = this.outlet();
      this.warp = warp;
      this.downlink = null;
      this.downlinkRecord = null;
      this.inputHostUri = void 0;
      this.inputNodeUri = void 0;
      this.inputLaneUri = void 0;
      this.inputPrio = void 0;
      this.inputRate = void 0;
      this.inputBody = void 0;
      this.inputType = void 0;
    }
    getOutput(outlet) {
      outlet = this.outlet(outlet);
      if (outlet === this.state) {
        if (this.downlink instanceof ValueDownlink) {
          return this.downlink.get();
        } else if (this.downlinkRecord !== null) {
          return this.downlinkRecord;
        }
      }
      return void 0;
    }
    onRecohere(version) {
      var _a;
      const hostUri = this.castInput(this.hostUri, Form.forString());
      const nodeUri = this.castInput(this.nodeUri, Form.forString());
      const laneUri = this.castInput(this.laneUri, Form.forString());
      const prio = this.castInput(this.prio, Form.forNumber(), 0);
      const rate = this.castInput(this.rate, Form.forNumber(), 0);
      const body = this.getInput(this.bodyValue);
      const type = this.castInput(this.type, Form.forString(), void 0);
      if (hostUri !== this.inputHostUri || nodeUri !== this.inputNodeUri || laneUri !== this.inputLaneUri || prio !== this.inputPrio || rate !== this.inputRate || (body === void 0 ? this.inputBody !== void 0 : !body.equals(this.inputBody)) || type !== this.inputType) {
        if (this.downlink !== null) {
          this.downlink.close();
          this.downlink = null;
          this.downlinkRecord = null;
        }
        this.inputHostUri = hostUri;
        this.inputNodeUri = nodeUri;
        this.inputLaneUri = laneUri;
        this.inputPrio = prio;
        this.inputRate = rate;
        this.inputBody = body;
        this.inputType = type;
        const warp = (_a = this.warp) !== null && _a !== void 0 ? _a : client;
        if (type === "map") {
          let downlink = warp.downlinkMap();
          if (hostUri !== void 0) {
            downlink = downlink.hostUri(hostUri);
          }
          if (nodeUri !== void 0) {
            downlink = downlink.nodeUri(nodeUri);
          }
          if (laneUri !== void 0) {
            downlink = downlink.laneUri(laneUri);
          }
          if (prio !== 0) {
            downlink = downlink.prio(prio);
          }
          if (rate !== 0) {
            downlink = downlink.rate(rate);
          }
          if (body !== void 0) {
            downlink = downlink.body(body);
          }
          downlink = downlink.open();
          this.state = downlink;
          this.downlink = downlink;
          this.downlinkRecord = new MapDownlinkRecord(downlink);
        } else if (type === "value") {
          let downlink = warp.downlinkValue();
          if (hostUri !== void 0) {
            downlink = downlink.hostUri(hostUri);
          }
          if (nodeUri !== void 0) {
            downlink = downlink.nodeUri(nodeUri);
          }
          if (laneUri !== void 0) {
            downlink = downlink.laneUri(laneUri);
          }
          if (prio !== void 0) {
            downlink = downlink.prio(prio);
          }
          if (rate !== void 0) {
            downlink = downlink.rate(rate);
          }
          if (body !== void 0) {
            downlink = downlink.body(body);
          }
          downlink = downlink.open();
          this.state = downlink;
          this.downlink = downlink;
        }
      }
    }
    static reifier(warp) {
      if (warp === void 0) {
        if (DownlinkStreamlet._reifier === void 0) {
          DownlinkStreamlet._reifier = new DownlinkReifier;
        }
        return DownlinkStreamlet._reifier;
      } else {
        return new DownlinkReifier(warp);
      }
    }
  }
  __decorate([ Inout ], DownlinkStreamlet.prototype, "hostUri", void 0);
  __decorate([ Inout ], DownlinkStreamlet.prototype, "nodeUri", void 0);
  __decorate([ Inout ], DownlinkStreamlet.prototype, "laneUri", void 0);
  __decorate([ Inout ], DownlinkStreamlet.prototype, "prio", void 0);
  __decorate([ Inout ], DownlinkStreamlet.prototype, "rate", void 0);
  __decorate([ Inout("body") ], DownlinkStreamlet.prototype, "bodyValue", void 0);
  __decorate([ Inout ], DownlinkStreamlet.prototype, "type", void 0);
  __decorate([ Out ], DownlinkStreamlet.prototype, "state", void 0);
  class BaseRef {
    constructor(context) {
      this.context = context;
      this.host = null;
      this.downlinks = [];
      this.observers = Arrays.empty;
    }
    get connected() {
      const host = this.host;
      return host !== null && host.connected;
    }
    get authenticated() {
      const host = this.host;
      return host !== null && host.authenticated;
    }
    get session() {
      const host = this.host;
      return host !== null ? host.session : Value.absent();
    }
    authenticate(credentials) {
      this.context.authenticate(this.hostUri, credentials);
    }
    addDownlink(downlink) {
      const downlinks = this.downlinks;
      if (downlinks.length === 0) {
        this.open();
      }
      downlinks.push(downlink);
    }
    removeDownlink(downlink) {
      const downlinks = this.downlinks;
      const i = downlinks.indexOf(downlink);
      if (i >= 0) {
        downlinks.splice(i, 1);
        if (downlinks.length === 0) {
          this.close();
        }
      }
    }
    open() {
      this.context.openRef(this);
    }
    close() {
      this.context.closeRef(this);
    }
    closeUp() {
      const downlinks = this.downlinks;
      this.downlinks = [];
      for (let i = 0, n = downlinks.length; i < n; i += 1) {
        downlinks[i].close();
      }
    }
    observe(observer) {
      this.observers = Arrays.inserted(observer, this.observers);
      return this;
    }
    unobserve(observer) {
      const oldObservers = this.observers;
      const n = oldObservers.length;
      for (let i = 0; i < n; i += 1) {
        const oldObserver = oldObservers[i];
        let found = oldObserver === observer;
        if (!found) {
          for (const key in oldObserver) {
            if (oldObserver[key] === observer) {
              found = true;
              break;
            }
          }
        }
        if (found) {
          if (n > 1) {
            const newObservers = new Array(n - 1);
            for (let j = 0; j < i; j += 1) {
              newObservers[j] = oldObservers[j];
            }
            for (let j = i + 1; j < n; j += 1) {
              newObservers[j - 1] = oldObservers[j];
            }
            this.observers = newObservers;
          } else {
            this.observers = Arrays.empty;
          }
          break;
        }
      }
      return this;
    }
    didConnect(didConnect) {
      return this.observe({
        didConnect: didConnect
      });
    }
    didAuthenticate(didAuthenticate) {
      return this.observe({
        didAuthenticate: didAuthenticate
      });
    }
    didDeauthenticate(didDeauthenticate) {
      return this.observe({
        didDeauthenticate: didDeauthenticate
      });
    }
    didDisconnect(didDisconnect) {
      return this.observe({
        didDisconnect: didDisconnect
      });
    }
    didFail(didFail) {
      return this.observe({
        didFail: didFail
      });
    }
    hostDidConnect(host) {
      this.host = host;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didConnect !== void 0) {
          observer.didConnect(host, this);
        }
      }
    }
    hostDidAuthenticate(body, host) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didAuthenticate !== void 0) {
          observer.didAuthenticate(body, host, this);
        }
      }
    }
    hostDidDeauthenticate(body, host) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didDeauthenticate !== void 0) {
          observer.didDeauthenticate(body, host, this);
        }
      }
    }
    hostDidDisconnect(host) {
      this.host = null;
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didDisconnect !== void 0) {
          observer.didDisconnect(host, this);
        }
      }
    }
    hostDidFail(error, host) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didFail !== void 0) {
          observer.didFail(error, host, this);
        }
      }
    }
  }
  class LaneRef extends BaseRef {
    constructor(context, hostUri, nodeUri, laneUri) {
      super(context);
      this.hostUri = hostUri;
      this.nodeUri = nodeUri;
      this.laneUri = laneUri;
    }
    hostRef(hostUri) {
      hostUri = Uri.fromAny(hostUri);
      return new HostRef(this.context, hostUri);
    }
    nodeRef(nodeUri) {
      nodeUri = Uri.fromAny(nodeUri);
      return new NodeRef(this.context, this.hostUri, nodeUri);
    }
    laneRef(laneUri) {
      laneUri = Uri.fromAny(laneUri);
      return new LaneRef(this.context, this.hostUri, this.nodeUri, laneUri);
    }
    downlink(init) {
      return new EventDownlink(this.context, this, init, this.hostUri, this.nodeUri, this.laneUri);
    }
    downlinkList(init) {
      return new ListDownlink(this.context, this, init, this.hostUri, this.nodeUri, this.laneUri);
    }
    downlinkMap(init) {
      return new MapDownlink(this.context, this, init, this.hostUri, this.nodeUri, this.laneUri);
    }
    downlinkValue(init) {
      return new ValueDownlink(this.context, this, init, this.hostUri, this.nodeUri, this.laneUri);
    }
    command(body) {
      this.context.command(this.hostUri, this.nodeUri, this.laneUri, body);
    }
  }
  class NodeRef extends BaseRef {
    constructor(context, hostUri, nodeUri) {
      super(context);
      this.hostUri = hostUri;
      this.nodeUri = nodeUri;
    }
    hostRef(hostUri) {
      hostUri = Uri.fromAny(hostUri);
      return new HostRef(this.context, hostUri);
    }
    nodeRef(nodeUri) {
      nodeUri = Uri.fromAny(nodeUri);
      return new NodeRef(this.context, this.hostUri, nodeUri);
    }
    laneRef(laneUri) {
      laneUri = Uri.fromAny(laneUri);
      return new LaneRef(this.context, this.hostUri, this.nodeUri, laneUri);
    }
    downlink(init) {
      return new EventDownlink(this.context, this, init, this.hostUri, this.nodeUri);
    }
    downlinkList(init) {
      return new ListDownlink(this.context, this, init, this.hostUri, this.nodeUri);
    }
    downlinkMap(init) {
      return new MapDownlink(this.context, this, init, this.hostUri, this.nodeUri);
    }
    downlinkValue(init) {
      return new ValueDownlink(this.context, this, init, this.hostUri, this.nodeUri);
    }
    command(laneUri, body) {
      this.context.command(this.hostUri, this.nodeUri, laneUri, body);
    }
  }
  class HostRef extends BaseRef {
    constructor(context, hostUri) {
      super(context);
      this.hostUri = hostUri;
    }
    hostRef(hostUri) {
      hostUri = Uri.fromAny(hostUri);
      return new HostRef(this.context, hostUri);
    }
    nodeRef(nodeUri) {
      nodeUri = Uri.fromAny(nodeUri);
      return new NodeRef(this.context, this.hostUri, nodeUri);
    }
    laneRef(nodeUri, laneUri) {
      nodeUri = Uri.fromAny(nodeUri);
      laneUri = Uri.fromAny(laneUri);
      return new LaneRef(this.context, this.hostUri, nodeUri, laneUri);
    }
    downlink(init) {
      return new EventDownlink(this.context, this, init, this.hostUri);
    }
    downlinkList(init) {
      return new ListDownlink(this.context, this, init, this.hostUri);
    }
    downlinkMap(init) {
      return new MapDownlink(this.context, this, init, this.hostUri);
    }
    downlinkValue(init) {
      return new ValueDownlink(this.context, this, init, this.hostUri);
    }
    command(nodeUri, laneUri, body) {
      this.context.command(this.hostUri, nodeUri, laneUri, body);
    }
  }
  class WarpClient {
    constructor(options = {}) {
      if (options.keepOnline === void 0) {
        options.keepOnline = true;
      }
      this.options = options;
      this.hosts = new BTree;
      this.downlinks = new BTree;
      this.downlinkCount = 0;
      this.refs = [];
      this.online = true;
      this.observers = Arrays.empty;
      this.onOnline = this.onOnline.bind(this);
      this.onOffline = this.onOffline.bind(this);
      this.watchOnline(!!options.keepOnline);
    }
    setOnline(online) {
      if (this.online !== online) {
        this.online = online;
        if (online) {
          this.hosts.forEach((function(hostUri, host) {
            host.open();
          }), this);
        }
      }
    }
    keepOnline(keepOnline) {
      if (keepOnline === void 0) {
        return !!this.options.keepOnline;
      } else {
        if (this.options.keepOnline !== keepOnline) {
          this.options.keepOnline = keepOnline;
          this.watchOnline(keepOnline);
        }
        return this;
      }
    }
    watchOnline(keepOnline) {
      if (typeof window === "object") {
        if (keepOnline) {
          window.addEventListener("online", this.onOnline);
          window.addEventListener("offline", this.onOffline);
        } else {
          window.removeEventListener("online", this.onOnline);
          window.removeEventListener("offline", this.onOffline);
        }
      }
    }
    onOnline(event) {
      this.setOnline(true);
    }
    onOffline(event) {
      this.setOnline(false);
    }
    getHost(hostUri) {
      hostUri = Uri.fromAny(hostUri);
      return this.hosts.get(hostUri);
    }
    openHost(hostUri) {
      hostUri = Uri.fromAny(hostUri);
      let host = this.hosts.get(hostUri);
      if (host === void 0) {
        host = WarpWorkerHost.create(this, hostUri, this.options);
        if (host === null) {
          host = new WebSocketHost(this, hostUri, this.options);
        }
        this.hosts.set(hostUri, host);
      }
      return host;
    }
    closeHost(host) {
      if (this.hosts.get(host.hostUri) !== void 0) {
        this.hosts.delete(host.hostUri);
        host.closeUp();
      }
    }
    getDownlink(hostUri, nodeUri, laneUri) {
      const hostDownlinks = this.downlinks.get(hostUri);
      if (hostDownlinks !== void 0) {
        const nodeDownlinks = hostDownlinks.get(nodeUri);
        if (nodeDownlinks !== void 0) {
          return nodeDownlinks.get(laneUri);
        }
      }
      return void 0;
    }
    openDownlink(downlink) {
      const hostUri = downlink.hostUri;
      const nodeUri = downlink.nodeUri;
      const laneUri = downlink.laneUri;
      let hostDownlinks = this.downlinks.get(hostUri);
      if (hostDownlinks === void 0) {
        hostDownlinks = new BTree;
        this.downlinks.set(hostUri, hostDownlinks);
      }
      let nodeDownlinks = hostDownlinks.get(nodeUri);
      if (nodeDownlinks === void 0) {
        nodeDownlinks = new BTree;
        hostDownlinks.set(nodeUri, nodeDownlinks);
      }
      if (nodeDownlinks.has(laneUri)) {
        throw new Error("duplicate downlink");
      }
      nodeDownlinks.set(laneUri, downlink);
      this.downlinkCount += 1;
      const host = this.openHost(hostUri);
      host.openDownlink(downlink);
    }
    unlinkDownlink(downlink) {
      const hostUri = downlink.hostUri;
      const host = this.getHost(hostUri);
      if (host !== void 0) {
        host.unlinkDownlink(downlink);
      }
    }
    closeDownlink(downlink) {
      const hostUri = downlink.hostUri;
      const nodeUri = downlink.nodeUri;
      const laneUri = downlink.laneUri;
      const hostDownlinks = this.downlinks.get(hostUri);
      if (hostDownlinks !== void 0) {
        const nodeDownlinks = hostDownlinks.get(nodeUri);
        if (nodeDownlinks !== void 0) {
          if (nodeDownlinks.get(laneUri)) {
            this.downlinkCount -= 1;
            nodeDownlinks.delete(laneUri);
            if (nodeDownlinks.isEmpty()) {
              hostDownlinks.delete(nodeUri);
              if (hostDownlinks.isEmpty()) {
                this.downlinks.delete(hostUri);
              }
            }
            const host = this.getHost(hostUri);
            if (host !== void 0) {
              host.closeDownlink(downlink);
            }
          }
        }
      }
    }
    downlink(init) {
      return new EventDownlink(this, null, init);
    }
    downlinkList(init) {
      return new ListDownlink(this, null, init);
    }
    downlinkMap(init) {
      return new MapDownlink(this, null, init);
    }
    downlinkValue(init) {
      return new ValueDownlink(this, null, init);
    }
    openRef(ref) {
      this.refs.push(ref);
    }
    closeRef(ref) {
      const refs = this.refs;
      const index = refs.indexOf(ref);
      if (index >= 0) {
        refs.splice(index, 1);
        ref.closeUp();
      }
    }
    hostRef(hostUri) {
      hostUri = Uri.fromAny(hostUri);
      return new HostRef(this, hostUri);
    }
    nodeRef(hostUri, nodeUri) {
      hostUri = Uri.fromAny(hostUri);
      if (nodeUri === void 0) {
        nodeUri = hostUri;
        hostUri = nodeUri.endpoint();
        nodeUri = hostUri.unresolve(nodeUri);
      } else {
        nodeUri = Uri.fromAny(nodeUri);
      }
      return new NodeRef(this, hostUri, nodeUri);
    }
    laneRef(hostUri, nodeUri, laneUri) {
      hostUri = Uri.fromAny(hostUri);
      nodeUri = Uri.fromAny(nodeUri);
      if (laneUri === void 0) {
        laneUri = nodeUri;
        nodeUri = hostUri;
        hostUri = nodeUri.endpoint();
        nodeUri = hostUri.unresolve(nodeUri);
      } else {
        laneUri = Uri.fromAny(laneUri);
      }
      return new LaneRef(this, hostUri, nodeUri, laneUri);
    }
    authenticate(hostUri, credentials) {
      hostUri = Uri.fromAny(hostUri);
      credentials = Value.fromAny(credentials);
      const host = this.openHost(hostUri);
      host.authenticate(credentials);
    }
    command(hostUri, nodeUri, laneUri, body) {
      hostUri = Uri.fromAny(hostUri);
      nodeUri = Uri.fromAny(nodeUri);
      if (arguments.length === 3) {
        body = laneUri;
        laneUri = nodeUri;
        nodeUri = hostUri;
        hostUri = nodeUri.endpoint();
        nodeUri = hostUri.unresolve(nodeUri);
      } else {
        laneUri = Uri.fromAny(laneUri);
      }
      body = Value.fromAny(body);
      const host = this.openHost(hostUri);
      host.command(nodeUri, laneUri, body);
    }
    close() {
      const refs = this.refs;
      this.refs = [];
      for (let i = 0; i < refs.length; i += 1) {
        refs[i].closeUp();
      }
      const downlinks = this.downlinks.clone();
      this.downlinks.clear();
      this.downlinkCount = 0;
      downlinks.forEach((function(hostUri, hostDownlinks) {
        hostDownlinks.forEach((function(nodeUri, nodeDownlinks) {
          nodeDownlinks.forEach((function(laneUri, downlink) {
            downlink.closeUp();
            const host = this.getHost(hostUri);
            if (host !== void 0) {
              host.closeDownlink(downlink);
            }
          }), this);
        }), this);
      }), this);
      const hosts = this.hosts.clone();
      this.hosts.clear();
      hosts.forEach((function(hostUri, host) {
        host.closeUp();
      }), this);
    }
    observe(observer) {
      this.observers = Arrays.inserted(observer, this.observers);
      return this;
    }
    unobserve(observer) {
      const oldObservers = this.observers;
      const n = oldObservers.length;
      for (let i = 0; i < n; i += 1) {
        const oldObserver = oldObservers[i];
        let found = oldObserver === observer;
        if (!found) {
          for (const key in oldObserver) {
            if (oldObserver[key] === observer) {
              found = true;
              break;
            }
          }
        }
        if (found) {
          if (n > 1) {
            const newObservers = new Array(n - 1);
            for (let j = 0; j < i; j += 1) {
              newObservers[j] = oldObservers[j];
            }
            for (let j = i + 1; j < n; j += 1) {
              newObservers[j - 1] = oldObservers[j];
            }
            this.observers = newObservers;
          } else {
            this.observers = Arrays.empty;
          }
          break;
        }
      }
      return this;
    }
    didConnect(didConnect) {
      return this.observe({
        didConnect: didConnect
      });
    }
    didAuthenticate(didAuthenticate) {
      return this.observe({
        didAuthenticate: didAuthenticate
      });
    }
    didDeauthenticate(didDeauthenticate) {
      return this.observe({
        didDeauthenticate: didDeauthenticate
      });
    }
    didDisconnect(didDisconnect) {
      return this.observe({
        didDisconnect: didDisconnect
      });
    }
    didFail(didFail) {
      return this.observe({
        didFail: didFail
      });
    }
    hostDidConnect(host) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didConnect !== void 0) {
          observer.didConnect(host, this);
        }
      }
      const refs = this.refs;
      for (let i = 0, n = refs.length; i < n; i += 1) {
        const ref = refs[i];
        if (ref.hostUri.equals(host.hostUri)) {
          ref.hostDidConnect(host);
        }
      }
    }
    hostDidAuthenticate(body, host) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didAuthenticate !== void 0) {
          observer.didAuthenticate(body, host, this);
        }
      }
      const refs = this.refs;
      for (let i = 0, n = refs.length; i < n; i += 1) {
        const ref = refs[i];
        if (ref.hostUri.equals(host.hostUri)) {
          ref.hostDidAuthenticate(body, host);
        }
      }
    }
    hostDidDeauthenticate(body, host) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didDeauthenticate !== void 0) {
          observer.didDeauthenticate(body, host, this);
        }
      }
      const refs = this.refs;
      for (let i = 0, n = refs.length; i < n; i += 1) {
        const ref = refs[i];
        if (ref.hostUri.equals(host.hostUri)) {
          ref.hostDidDeauthenticate(body, host);
        }
      }
    }
    hostDidDisconnect(host) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didDisconnect !== void 0) {
          observer.didDisconnect(host, this);
        }
      }
      const refs = this.refs;
      for (let i = 0, n = refs.length; i < n; i += 1) {
        const ref = refs[i];
        if (ref.hostUri.equals(host.hostUri)) {
          ref.hostDidDisconnect(host);
        }
      }
    }
    hostDidFail(error, host) {
      const observers = this.observers;
      for (let i = 0, n = observers.length; i < n; i += 1) {
        const observer = observers[i];
        if (observer.didFail !== void 0) {
          observer.didFail(error, host, this);
        }
      }
      const refs = this.refs;
      for (let i = 0, n = refs.length; i < n; i += 1) {
        const ref = refs[i];
        if (ref.hostUri.equals(host.hostUri)) {
          ref.hostDidFail(error, host);
        }
      }
    }
  }
  const client = new WarpClient;
  const downlink = client.downlink.bind(client);
  const downlinkList = client.downlinkList.bind(client);
  const downlinkMap = client.downlinkMap.bind(client);
  const downlinkValue = client.downlinkValue.bind(client);
  const hostRef = client.hostRef.bind(client);
  const nodeRef = client.nodeRef.bind(client);
  const laneRef = client.laneRef.bind(client);
  const authenticate = client.authenticate.bind(client);
  const command = client.command.bind(client);
  class WarpService extends Service {
    constructor(client) {
      super();
      this.client = client;
    }
    static global() {
      return new WarpService(client);
    }
  }
  __decorate([ Lazy ], WarpService, "global", null);
  const WarpProvider = function(_super) {
    const WarpProvider = _super.extend("WarpProvider");
    Object.defineProperty(WarpProvider.prototype, "client", {
      get() {
        let service = this.service;
        if (service === void 0 || service === null) {
          service = WarpService.global();
        }
        return service.client;
      },
      configurable: true
    });
    WarpProvider.prototype.createService = function() {
      return WarpService.global();
    };
    return WarpProvider;
  }(Provider);
  const DownlinkFastener = function(_super) {
    const DownlinkFastener = _super.extend("DownlinkFastener");
    Object.defineProperty(DownlinkFastener.prototype, "fastenerType", {
      get: function() {
        return DownlinkFastener;
      },
      configurable: true
    });
    DownlinkFastener.prototype.onInherit = function(superFastener) {};
    DownlinkFastener.prototype.hostUri = function(hostUri) {
      if (hostUri === void 0) {
        if (this.ownHostUri !== null) {
          return this.ownHostUri;
        } else {
          hostUri = this.initHostUri !== void 0 ? this.initHostUri() : null;
          if (hostUri !== null) {
            hostUri = Uri.fromAny(hostUri);
            this.ownHostUri = hostUri;
          }
          return hostUri;
        }
      } else {
        if (hostUri !== null) {
          hostUri = Uri.fromAny(hostUri);
        }
        if (!Equals(this.ownHostUri, hostUri)) {
          this.ownHostUri = hostUri;
          this.relink();
        }
        return this;
      }
    };
    DownlinkFastener.prototype.nodeUri = function(nodeUri) {
      if (nodeUri === void 0) {
        if (this.ownNodeUri !== null) {
          return this.ownNodeUri;
        } else {
          nodeUri = this.initNodeUri !== void 0 ? this.initNodeUri() : null;
          if (nodeUri !== null) {
            nodeUri = Uri.fromAny(nodeUri);
            this.ownNodeUri = nodeUri;
          }
          return nodeUri;
        }
      } else {
        if (nodeUri !== null) {
          nodeUri = Uri.fromAny(nodeUri);
        }
        if (!Equals(this.ownNodeUri, nodeUri)) {
          this.ownNodeUri = nodeUri;
          this.relink();
        }
        return this;
      }
    };
    DownlinkFastener.prototype.laneUri = function(laneUri) {
      if (laneUri === void 0) {
        if (this.ownLaneUri !== null) {
          return this.ownLaneUri;
        } else {
          laneUri = this.initLaneUri !== void 0 ? this.initLaneUri() : null;
          if (laneUri !== null) {
            laneUri = Uri.fromAny(laneUri);
            this.ownLaneUri = laneUri;
          }
          return laneUri;
        }
      } else {
        if (laneUri !== null) {
          laneUri = Uri.fromAny(laneUri);
        }
        if (!Equals(this.ownLaneUri, laneUri)) {
          this.ownLaneUri = laneUri;
          this.relink();
        }
        return this;
      }
    };
    DownlinkFastener.prototype.prio = function(prio) {
      if (arguments.length === 0) {
        if (this.ownPrio !== void 0) {
          return this.ownPrio;
        } else {
          prio = this.initPrio !== void 0 ? this.initPrio() : void 0;
          if (prio !== void 0) {
            this.ownPrio = prio;
          }
          return prio;
        }
      } else {
        if (this.ownPrio !== prio) {
          this.ownPrio = prio;
          this.relink();
        }
        return this;
      }
    };
    DownlinkFastener.prototype.rate = function(rate) {
      if (arguments.length === 0) {
        if (this.ownRate !== void 0) {
          return this.ownRate;
        } else {
          rate = this.initRate !== void 0 ? this.initRate() : void 0;
          if (rate !== void 0) {
            this.ownRate = rate;
          }
          return rate;
        }
      } else {
        if (this.ownRate !== rate) {
          this.ownRate = rate;
          this.relink();
        }
        return this;
      }
    };
    DownlinkFastener.prototype.body = function(body) {
      if (body === void 0) {
        if (this.ownBody !== null) {
          return this.ownBody;
        } else {
          body = this.initBody !== void 0 ? this.initBody() : null;
          if (body !== null) {
            body = Value.fromAny(body);
            this.ownBody = body;
          }
          return body;
        }
      } else {
        if (body !== null) {
          body = Value.fromAny(body);
        }
        if (!Equals(this.ownBody, body)) {
          this.ownBody = body;
          this.relink();
        }
        return this;
      }
    };
    DownlinkFastener.prototype.warp = function(warp) {
      if (warp === void 0) {
        return this.ownWarp;
      } else {
        if (this.ownWarp !== warp) {
          this.ownWarp = warp;
          this.relink();
        }
        return this;
      }
    };
    DownlinkFastener.prototype.link = function() {
      if (this.downlink === null) {
        let warp = this.ownWarp;
        if (warp === null) {
          warp = this.owner.warpRef.value;
        }
        if (warp === null) {
          warp = this.owner.warpProvider.service.client;
        }
        let downlink = this.createDownlink(warp);
        downlink = this.bindDownlink(downlink);
        if (this.initDownlink !== void 0) {
          downlink = this.initDownlink(downlink);
        }
        downlink = downlink.observe(this);
        this.downlink = downlink.open();
        this.setFlags(this.flags & ~DownlinkFastener.PendingFlag);
      }
    };
    DownlinkFastener.prototype.unlink = function() {
      const downlink = this.downlink;
      if (downlink !== null) {
        downlink.close();
        this.downlink = null;
        this.setFlags(this.flags | DownlinkFastener.PendingFlag);
      }
    };
    DownlinkFastener.prototype.relink = function() {
      this.setFlags(this.flags | DownlinkFastener.PendingFlag);
      if ((this.flags & DownlinkFastener.ConsumingFlag) !== 0) {
        this.setCoherent(false);
        this.decohere();
      }
    };
    DownlinkFastener.prototype.bindDownlink = function(downlink) {
      const hostUri = this.hostUri();
      if (hostUri !== null) {
        downlink = downlink.hostUri(hostUri);
      }
      const nodeUri = this.nodeUri();
      if (nodeUri !== null) {
        downlink = downlink.nodeUri(nodeUri);
      }
      const laneUri = this.laneUri();
      if (laneUri !== null) {
        downlink = downlink.laneUri(laneUri);
      }
      const prio = this.prio();
      if (prio !== void 0) {
        downlink = downlink.prio(prio);
      }
      const rate = this.rate();
      if (rate !== void 0) {
        downlink = downlink.rate(rate);
      }
      const body = this.body();
      if (body !== null) {
        downlink = downlink.body(body);
      }
      return downlink;
    };
    DownlinkFastener.prototype.recohere = function(t) {
      this.setCoherent(true);
      if (this.downlink !== null && (this.flags & DownlinkFastener.RelinkMask) === DownlinkFastener.RelinkMask) {
        this.unlink();
        this.link();
      } else if (this.downlink === null && (this.flags & DownlinkFastener.ConsumingFlag) !== 0) {
        this.link();
      } else if (this.downlink !== null && (this.flags & DownlinkFastener.ConsumingFlag) === 0) {
        this.unlink();
      }
    };
    DownlinkFastener.prototype.consume = function(downlinkConsumer) {
      const oldConsumers = this.consumers;
      const newConsumerrss = Arrays.inserted(downlinkConsumer, oldConsumers);
      if (oldConsumers !== newConsumerrss) {
        this.willConsume(downlinkConsumer);
        this.consumers = newConsumerrss;
        this.onConsume(downlinkConsumer);
        this.didConsume(downlinkConsumer);
        if (oldConsumers.length === 0) {
          this.startConsuming();
        }
      }
    };
    DownlinkFastener.prototype.willConsume = function(downlinkConsumer) {};
    DownlinkFastener.prototype.onConsume = function(downlinkConsumer) {};
    DownlinkFastener.prototype.didConsume = function(downlinkConsumer) {};
    DownlinkFastener.prototype.unconsume = function(downlinkConsumer) {
      const oldConsumers = this.consumers;
      const newConsumerrss = Arrays.removed(downlinkConsumer, oldConsumers);
      if (oldConsumers !== newConsumerrss) {
        this.willUnconsume(downlinkConsumer);
        this.consumers = newConsumerrss;
        this.onUnconsume(downlinkConsumer);
        this.didUnconsume(downlinkConsumer);
        if (newConsumerrss.length === 0) {
          this.stopConsuming();
        }
      }
    };
    DownlinkFastener.prototype.willUnconsume = function(downlinkConsumer) {};
    DownlinkFastener.prototype.onUnconsume = function(downlinkConsumer) {};
    DownlinkFastener.prototype.didUnconsume = function(downlinkConsumer) {};
    Object.defineProperty(DownlinkFastener.prototype, "consuming", {
      get() {
        return (this.flags & DownlinkFastener.ConsumingFlag) !== 0;
      },
      configurable: true
    });
    DownlinkFastener.prototype.startConsuming = function() {
      if ((this.flags & DownlinkFastener.ConsumingFlag) === 0) {
        this.willStartConsuming();
        this.setFlags(this.flags | DownlinkFastener.ConsumingFlag);
        this.onStartConsuming();
        this.didStartConsuming();
      }
    };
    DownlinkFastener.prototype.willStartConsuming = function() {};
    DownlinkFastener.prototype.onStartConsuming = function() {
      this.setCoherent(false);
      this.decohere();
    };
    DownlinkFastener.prototype.didStartConsuming = function() {};
    DownlinkFastener.prototype.stopConsuming = function() {
      if ((this.flags & DownlinkFastener.ConsumingFlag) !== 0) {
        this.willStopConsuming();
        this.setFlags(this.flags & ~DownlinkFastener.ConsumingFlag);
        this.onStopConsuming();
        this.didStopConsuming();
      }
    };
    DownlinkFastener.prototype.willStopConsuming = function() {};
    DownlinkFastener.prototype.onStopConsuming = function() {
      this.setCoherent(false);
      this.decohere();
    };
    DownlinkFastener.prototype.didStopConsuming = function() {};
    DownlinkFastener.prototype.onMount = function() {
      _super.prototype.onMount.call(this);
      if ((this.flags & DownlinkFastener.ConsumingFlag) !== 0) {
        this.setCoherent(false);
        this.decohere();
      }
    };
    DownlinkFastener.prototype.onUnmount = function() {
      _super.prototype.onUnmount.call(this);
      this.unlink();
    };
    Object.defineProperty(DownlinkFastener.prototype, "lazy", {
      get: function() {
        return false;
      },
      configurable: true
    });
    Object.defineProperty(DownlinkFastener.prototype, "static", {
      get: function() {
        return true;
      },
      configurable: true
    });
    DownlinkFastener.construct = function(fastenerClass, fastener, owner) {
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.ownHostUri = null;
      fastener.ownNodeUri = null;
      fastener.ownLaneUri = null;
      fastener.ownPrio = void 0;
      fastener.ownRate = void 0;
      fastener.ownBody = null;
      fastener.ownWarp = null;
      fastener.downlink = null;
      fastener.consumers = Arrays.empty;
      return fastener;
    };
    DownlinkFastener.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      let hostUri = descriptor.hostUri;
      let nodeUri = descriptor.nodeUri;
      let laneUri = descriptor.laneUri;
      let prio = descriptor.prio;
      let rate = descriptor.rate;
      let body = descriptor.body;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.hostUri;
      delete descriptor.nodeUri;
      delete descriptor.laneUri;
      delete descriptor.prio;
      delete descriptor.rate;
      delete descriptor.body;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        if (hostUri !== void 0) {
          fastener.ownHostUri = hostUri;
        }
        if (nodeUri !== void 0) {
          fastener.ownNodeUri = nodeUri;
        }
        if (laneUri !== void 0) {
          fastener.ownLaneUri = laneUri;
        }
        if (prio !== void 0) {
          fastener.ownPrio = prio;
        }
        if (rate !== void 0) {
          fastener.ownRate = rate;
        }
        if (body !== void 0) {
          fastener.ownBody = body;
        }
        return fastener;
      };
      if (typeof hostUri === "function") {
        fastenerClass.prototype.initHostUri = hostUri;
        hostUri = void 0;
      } else if (hostUri !== void 0) {
        hostUri = Uri.fromAny(hostUri);
      }
      if (typeof nodeUri === "function") {
        fastenerClass.prototype.initNodeUri = nodeUri;
        nodeUri = void 0;
      } else if (nodeUri !== void 0) {
        nodeUri = Uri.fromAny(nodeUri);
      }
      if (typeof laneUri === "function") {
        fastenerClass.prototype.initLaneUri = laneUri;
        laneUri = void 0;
      } else if (laneUri !== void 0) {
        laneUri = Uri.fromAny(laneUri);
      }
      if (typeof prio === "function") {
        fastenerClass.prototype.initPrio = prio;
        prio = void 0;
      }
      if (typeof rate === "function") {
        fastenerClass.prototype.initRate = rate;
        rate = void 0;
      }
      if (typeof body === "function") {
        fastenerClass.prototype.initBody = body;
        body = void 0;
      } else if (body !== void 0) {
        body = Value.fromAny(body);
      }
      return fastenerClass;
    };
    DownlinkFastener.ConsumingFlag = 1 << _super.FlagShift + 0;
    DownlinkFastener.PendingFlag = 1 << _super.FlagShift + 1;
    DownlinkFastener.RelinkMask = DownlinkFastener.ConsumingFlag | DownlinkFastener.PendingFlag;
    DownlinkFastener.FlagShift = _super.FlagShift + 2;
    DownlinkFastener.FlagMask = (1 << DownlinkFastener.FlagShift) - 1;
    return DownlinkFastener;
  }(Fastener);
  const EventDownlinkFastener = function(_super) {
    const EventDownlinkFastener = _super.extend("EventDownlinkFastener");
    EventDownlinkFastener.prototype.createDownlink = function(warp) {
      return warp.downlink();
    };
    EventDownlinkFastener.construct = function(fastenerClass, fastener, owner) {
      fastener = _super.construct(fastenerClass, fastener, owner);
      return fastener;
    };
    EventDownlinkFastener.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      let hostUri = descriptor.hostUri;
      let nodeUri = descriptor.nodeUri;
      let laneUri = descriptor.laneUri;
      let prio = descriptor.prio;
      let rate = descriptor.rate;
      let body = descriptor.body;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.hostUri;
      delete descriptor.nodeUri;
      delete descriptor.laneUri;
      delete descriptor.prio;
      delete descriptor.rate;
      delete descriptor.body;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        if (hostUri !== void 0) {
          fastener.ownHostUri = hostUri;
        }
        if (nodeUri !== void 0) {
          fastener.ownNodeUri = nodeUri;
        }
        if (laneUri !== void 0) {
          fastener.ownLaneUri = laneUri;
        }
        if (prio !== void 0) {
          fastener.ownPrio = prio;
        }
        if (rate !== void 0) {
          fastener.ownRate = rate;
        }
        if (body !== void 0) {
          fastener.ownBody = body;
        }
        return fastener;
      };
      if (typeof hostUri === "function") {
        fastenerClass.prototype.initHostUri = hostUri;
        hostUri = void 0;
      } else if (hostUri !== void 0) {
        hostUri = Uri.fromAny(hostUri);
      }
      if (typeof nodeUri === "function") {
        fastenerClass.prototype.initNodeUri = nodeUri;
        nodeUri = void 0;
      } else if (nodeUri !== void 0) {
        nodeUri = Uri.fromAny(nodeUri);
      }
      if (typeof laneUri === "function") {
        fastenerClass.prototype.initLaneUri = laneUri;
        laneUri = void 0;
      } else if (laneUri !== void 0) {
        laneUri = Uri.fromAny(laneUri);
      }
      if (typeof prio === "function") {
        fastenerClass.prototype.initPrio = prio;
        prio = void 0;
      }
      if (typeof rate === "function") {
        fastenerClass.prototype.initRate = rate;
        rate = void 0;
      }
      if (typeof body === "function") {
        fastenerClass.prototype.initBody = body;
        body = void 0;
      } else if (body !== void 0) {
        body = Value.fromAny(body);
      }
      return fastenerClass;
    };
    return EventDownlinkFastener;
  }(DownlinkFastener);
  const ListDownlinkFastener = function(_super) {
    const ListDownlinkFastener = _super.extend("ListDownlinkFastener");
    ListDownlinkFastener.prototype.valueForm = function(valueForm) {
      if (valueForm === void 0) {
        return this.ownValueForm;
      } else {
        if (this.ownValueForm !== valueForm) {
          this.ownValueForm = valueForm;
          this.relink();
        }
        return this;
      }
    };
    Object.defineProperty(ListDownlinkFastener.prototype, "length", {
      get: function() {
        const downlink = this.downlink;
        return downlink !== null ? downlink.length : 0;
      },
      configurable: true
    });
    ListDownlinkFastener.prototype.isEmpty = function() {
      const downlink = this.downlink;
      return downlink !== null ? downlink.isEmpty() : true;
    };
    ListDownlinkFastener.prototype.get = function(index, id) {
      const downlink = this.downlink;
      return downlink !== null ? downlink.get(index, id) : void 0;
    };
    ListDownlinkFastener.prototype.getEntry = function(index, id) {
      const downlink = this.downlink;
      return downlink !== null ? downlink.getEntry(index, id) : void 0;
    };
    ListDownlinkFastener.prototype.set = function(index, newObject, id) {
      const downlink = this.downlink;
      if (downlink != null) {
        downlink.set(index, newObject, id);
      }
      return this;
    };
    ListDownlinkFastener.prototype.insert = function(index, newObject, id) {
      const downlink = this.downlink;
      if (downlink != null) {
        downlink.insert(index, newObject, id);
      }
      return this;
    };
    ListDownlinkFastener.prototype.remove = function(index, id) {
      const downlink = this.downlink;
      if (downlink != null) {
        downlink.remove(index, id);
      }
      return this;
    };
    ListDownlinkFastener.prototype.push = function(...newObjects) {
      const downlink = this.downlink;
      return downlink !== null ? downlink.push(...newObjects) : 0;
    };
    ListDownlinkFastener.prototype.pop = function() {
      const downlink = this.downlink;
      return downlink !== null ? downlink.pop() : void 0;
    };
    ListDownlinkFastener.prototype.unshift = function(...newObjects) {
      const downlink = this.downlink;
      return downlink !== null ? downlink.unshift(...newObjects) : 0;
    };
    ListDownlinkFastener.prototype.shift = function() {
      const downlink = this.downlink;
      return downlink !== null ? downlink.shift() : void 0;
    };
    ListDownlinkFastener.prototype.move = function(fromIndex, toIndex, id) {
      const downlink = this.downlink;
      if (downlink != null) {
        downlink.move(fromIndex, toIndex, id);
      }
      return this;
    };
    ListDownlinkFastener.prototype.splice = function(start, deleteCount, ...newObjects) {
      const downlink = this.downlink;
      return downlink !== null ? downlink.splice(start, deleteCount, ...newObjects) : [];
    };
    ListDownlinkFastener.prototype.clear = function() {
      const downlink = this.downlink;
      if (downlink != null) {
        downlink.clear();
      }
    };
    ListDownlinkFastener.prototype.forEach = function(callback, thisArg) {
      const downlink = this.downlink;
      return downlink !== null ? downlink.forEach(callback, thisArg) : void 0;
    };
    ListDownlinkFastener.prototype.values = function() {
      const downlink = this.downlink;
      return downlink !== null ? downlink.values() : Cursor.empty();
    };
    ListDownlinkFastener.prototype.keys = function() {
      const downlink = this.downlink;
      return downlink !== null ? downlink.keys() : Cursor.empty();
    };
    ListDownlinkFastener.prototype.entries = function() {
      const downlink = this.downlink;
      return downlink !== null ? downlink.entries() : Cursor.empty();
    };
    ListDownlinkFastener.prototype.createDownlink = function(warp) {
      let downlink = warp.downlinkList();
      if (this.ownValueForm !== null) {
        downlink = downlink.valueForm(this.ownValueForm);
      }
      return downlink;
    };
    ListDownlinkFastener.construct = function(fastenerClass, fastener, owner) {
      if (fastener === null) {
        fastener = function(index, value) {
          if (arguments.length === 0) {
            return fastener.get(index);
          } else {
            fastener.set(index, value);
            return fastener.owner;
          }
        };
        delete fastener.name;
        Object.setPrototypeOf(fastener, fastenerClass.prototype);
      }
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.ownValueForm = null;
      return fastener;
    };
    ListDownlinkFastener.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const valueForm = descriptor.valueForm;
      let hostUri = descriptor.hostUri;
      let nodeUri = descriptor.nodeUri;
      let laneUri = descriptor.laneUri;
      let prio = descriptor.prio;
      let rate = descriptor.rate;
      let body = descriptor.body;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.valueForm;
      delete descriptor.hostUri;
      delete descriptor.nodeUri;
      delete descriptor.laneUri;
      delete descriptor.prio;
      delete descriptor.rate;
      delete descriptor.body;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        if (hostUri !== void 0) {
          fastener.ownHostUri = hostUri;
        }
        if (nodeUri !== void 0) {
          fastener.ownNodeUri = nodeUri;
        }
        if (laneUri !== void 0) {
          fastener.ownLaneUri = laneUri;
        }
        if (prio !== void 0) {
          fastener.ownPrio = prio;
        }
        if (rate !== void 0) {
          fastener.ownRate = rate;
        }
        if (body !== void 0) {
          fastener.ownBody = body;
        }
        if (valueForm !== void 0) {
          fastener.ownValueForm = valueForm;
        }
        return fastener;
      };
      if (typeof hostUri === "function") {
        fastenerClass.prototype.initHostUri = hostUri;
        hostUri = void 0;
      } else if (hostUri !== void 0) {
        hostUri = Uri.fromAny(hostUri);
      }
      if (typeof nodeUri === "function") {
        fastenerClass.prototype.initNodeUri = nodeUri;
        nodeUri = void 0;
      } else if (nodeUri !== void 0) {
        nodeUri = Uri.fromAny(nodeUri);
      }
      if (typeof laneUri === "function") {
        fastenerClass.prototype.initLaneUri = laneUri;
        laneUri = void 0;
      } else if (laneUri !== void 0) {
        laneUri = Uri.fromAny(laneUri);
      }
      if (typeof prio === "function") {
        fastenerClass.prototype.initPrio = prio;
        prio = void 0;
      }
      if (typeof rate === "function") {
        fastenerClass.prototype.initRate = rate;
        rate = void 0;
      }
      if (typeof body === "function") {
        fastenerClass.prototype.initBody = body;
        body = void 0;
      } else if (body !== void 0) {
        body = Value.fromAny(body);
      }
      return fastenerClass;
    };
    return ListDownlinkFastener;
  }(DownlinkFastener);
  const MapDownlinkFastener = function(_super) {
    const MapDownlinkFastener = _super.extend("MapDownlinkFastener");
    MapDownlinkFastener.prototype.keyForm = function(keyForm) {
      if (keyForm === void 0) {
        return this.ownKeyForm;
      } else {
        if (this.ownKeyForm !== keyForm) {
          this.ownKeyForm = keyForm;
          this.relink();
        }
        return this;
      }
    };
    MapDownlinkFastener.prototype.valueForm = function(valueForm) {
      if (valueForm === void 0) {
        return this.ownValueForm;
      } else {
        if (this.ownValueForm !== valueForm) {
          this.ownValueForm = valueForm;
          this.relink();
        }
        return this;
      }
    };
    Object.defineProperty(MapDownlinkFastener.prototype, "size", {
      get: function() {
        const downlink = this.downlink;
        return downlink !== null ? downlink.size : 0;
      },
      configurable: true
    });
    MapDownlinkFastener.prototype.isEmpty = function() {
      const downlink = this.downlink;
      return downlink !== null ? downlink.isEmpty() : true;
    };
    MapDownlinkFastener.prototype.has = function(key) {
      const downlink = this.downlink;
      return downlink !== null ? downlink.has(key) : false;
    };
    MapDownlinkFastener.prototype.get = function(key) {
      const downlink = this.downlink;
      let value;
      if (downlink !== null) {
        value = downlink.get(key);
      }
      if (value === void 0 && this.ownValueForm !== null) {
        value = this.ownValueForm.unit;
      }
      return value;
    };
    MapDownlinkFastener.prototype.getEntry = function(index) {
      const downlink = this.downlink;
      return downlink !== null ? downlink.getEntry(index) : void 0;
    };
    MapDownlinkFastener.prototype.firstKey = function() {
      const downlink = this.downlink;
      return downlink !== null ? downlink.firstKey() : void 0;
    };
    MapDownlinkFastener.prototype.firstValue = function() {
      const downlink = this.downlink;
      return downlink !== null ? downlink.firstValue() : void 0;
    };
    MapDownlinkFastener.prototype.firstEntry = function() {
      const downlink = this.downlink;
      return downlink !== null ? downlink.firstEntry() : void 0;
    };
    MapDownlinkFastener.prototype.lastKey = function() {
      const downlink = this.downlink;
      return downlink !== null ? downlink.lastKey() : void 0;
    };
    MapDownlinkFastener.prototype.lastValue = function() {
      const downlink = this.downlink;
      return downlink !== null ? downlink.lastValue() : void 0;
    };
    MapDownlinkFastener.prototype.lastEntry = function() {
      const downlink = this.downlink;
      return downlink !== null ? downlink.lastEntry() : void 0;
    };
    MapDownlinkFastener.prototype.nextKey = function(keyObject) {
      const downlink = this.downlink;
      return downlink !== null ? downlink.nextKey(keyObject) : void 0;
    };
    MapDownlinkFastener.prototype.nextValue = function(keyObject) {
      const downlink = this.downlink;
      return downlink !== null ? downlink.nextValue(keyObject) : void 0;
    };
    MapDownlinkFastener.prototype.nextEntry = function(keyObject) {
      const downlink = this.downlink;
      return downlink !== null ? downlink.nextEntry(keyObject) : void 0;
    };
    MapDownlinkFastener.prototype.previousKey = function(keyObject) {
      const downlink = this.downlink;
      return downlink !== null ? downlink.previousKey(keyObject) : void 0;
    };
    MapDownlinkFastener.prototype.previousValue = function(keyObject) {
      const downlink = this.downlink;
      return downlink !== null ? downlink.previousValue(keyObject) : void 0;
    };
    MapDownlinkFastener.prototype.previousEntry = function(keyObject) {
      const downlink = this.downlink;
      return downlink !== null ? downlink.previousEntry(keyObject) : void 0;
    };
    MapDownlinkFastener.prototype.set = function(key, newValue) {
      const downlink = this.downlink;
      if (downlink !== null) {
        downlink.set(key, newValue);
      }
      return this;
    };
    MapDownlinkFastener.prototype.delete = function(key) {
      const downlink = this.downlink;
      return downlink !== null ? downlink.delete(key) : false;
    };
    MapDownlinkFastener.prototype.drop = function(lower) {
      const downlink = this.downlink;
      if (downlink !== null) {
        downlink.drop(lower);
      }
      return this;
    };
    MapDownlinkFastener.prototype.take = function(upper) {
      const downlink = this.downlink;
      if (downlink !== null) {
        downlink.take(upper);
      }
      return this;
    };
    MapDownlinkFastener.prototype.clear = function() {
      const downlink = this.downlink;
      if (downlink !== null) {
        downlink.clear();
      }
    };
    MapDownlinkFastener.prototype.forEach = function(callback, thisArg) {
      const downlink = this.downlink;
      return downlink !== null ? downlink.forEach(callback, thisArg) : void 0;
    };
    MapDownlinkFastener.prototype.keys = function() {
      const downlink = this.downlink;
      return downlink !== null ? downlink.keys() : Cursor.empty();
    };
    MapDownlinkFastener.prototype.values = function() {
      const downlink = this.downlink;
      return downlink !== null ? downlink.values() : Cursor.empty();
    };
    MapDownlinkFastener.prototype.entries = function() {
      const downlink = this.downlink;
      return downlink !== null ? downlink.entries() : Cursor.empty();
    };
    MapDownlinkFastener.prototype.createDownlink = function(warp) {
      let downlink = warp.downlinkMap();
      if (this.ownKeyForm !== null) {
        downlink = downlink.keyForm(this.ownKeyForm);
      }
      if (this.ownValueForm !== null) {
        downlink = downlink.valueForm(this.ownValueForm);
      }
      return downlink;
    };
    MapDownlinkFastener.construct = function(fastenerClass, fastener, owner) {
      if (fastener === null) {
        fastener = function(key, value) {
          if (arguments.length === 1) {
            return fastener.get(key);
          } else {
            fastener.set(key, value);
            return fastener.owner;
          }
        };
        delete fastener.name;
        Object.setPrototypeOf(fastener, fastenerClass.prototype);
      }
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.ownKeyForm = null;
      fastener.ownValueForm = null;
      return fastener;
    };
    MapDownlinkFastener.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const keyForm = descriptor.keyForm;
      const valueForm = descriptor.valueForm;
      let hostUri = descriptor.hostUri;
      let nodeUri = descriptor.nodeUri;
      let laneUri = descriptor.laneUri;
      let prio = descriptor.prio;
      let rate = descriptor.rate;
      let body = descriptor.body;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.keyForm;
      delete descriptor.valueForm;
      delete descriptor.hostUri;
      delete descriptor.nodeUri;
      delete descriptor.laneUri;
      delete descriptor.prio;
      delete descriptor.rate;
      delete descriptor.body;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        if (hostUri !== void 0) {
          fastener.ownHostUri = hostUri;
        }
        if (nodeUri !== void 0) {
          fastener.ownNodeUri = nodeUri;
        }
        if (laneUri !== void 0) {
          fastener.ownLaneUri = laneUri;
        }
        if (prio !== void 0) {
          fastener.ownPrio = prio;
        }
        if (rate !== void 0) {
          fastener.ownRate = rate;
        }
        if (body !== void 0) {
          fastener.ownBody = body;
        }
        if (keyForm !== void 0) {
          fastener.ownKeyForm = keyForm;
        }
        if (valueForm !== void 0) {
          fastener.ownValueForm = valueForm;
        }
        return fastener;
      };
      if (typeof hostUri === "function") {
        fastenerClass.prototype.initHostUri = hostUri;
        hostUri = void 0;
      } else if (hostUri !== void 0) {
        hostUri = Uri.fromAny(hostUri);
      }
      if (typeof nodeUri === "function") {
        fastenerClass.prototype.initNodeUri = nodeUri;
        nodeUri = void 0;
      } else if (nodeUri !== void 0) {
        nodeUri = Uri.fromAny(nodeUri);
      }
      if (typeof laneUri === "function") {
        fastenerClass.prototype.initLaneUri = laneUri;
        laneUri = void 0;
      } else if (laneUri !== void 0) {
        laneUri = Uri.fromAny(laneUri);
      }
      if (typeof prio === "function") {
        fastenerClass.prototype.initPrio = prio;
        prio = void 0;
      }
      if (typeof rate === "function") {
        fastenerClass.prototype.initRate = rate;
        rate = void 0;
      }
      if (typeof body === "function") {
        fastenerClass.prototype.initBody = body;
        body = void 0;
      } else if (body !== void 0) {
        body = Value.fromAny(body);
      }
      return fastenerClass;
    };
    return MapDownlinkFastener;
  }(DownlinkFastener);
  const ValueDownlinkFastener = function(_super) {
    const ValueDownlinkFastener = _super.extend("ValueDownlinkFastener");
    ValueDownlinkFastener.prototype.valueForm = function(valueForm) {
      if (valueForm === void 0) {
        return this.ownValueForm;
      } else {
        if (this.ownValueForm !== valueForm) {
          this.ownValueForm = valueForm;
          this.relink();
        }
        return this;
      }
    };
    ValueDownlinkFastener.prototype.get = function() {
      const downlink = this.downlink;
      return downlink !== null ? downlink.get() : void 0;
    };
    ValueDownlinkFastener.prototype.set = function(value) {
      const downlink = this.downlink;
      if (downlink !== null) {
        downlink.set(value);
      }
    };
    ValueDownlinkFastener.prototype.createDownlink = function(warp) {
      let downlink = warp.downlinkValue();
      if (this.ownValueForm !== null) {
        downlink = downlink.valueForm(this.ownValueForm);
      }
      return downlink;
    };
    ValueDownlinkFastener.construct = function(fastenerClass, fastener, owner) {
      if (fastener === null) {
        fastener = function(value) {
          if (arguments.length === 0) {
            return fastener.get();
          } else {
            fastener.set(value);
            return fastener.owner;
          }
        };
        delete fastener.name;
        Object.setPrototypeOf(fastener, fastenerClass.prototype);
      }
      fastener = _super.construct(fastenerClass, fastener, owner);
      fastener.ownValueForm = null;
      return fastener;
    };
    ValueDownlinkFastener.define = function(className, descriptor) {
      let superClass = descriptor.extends;
      const affinity = descriptor.affinity;
      const inherits = descriptor.inherits;
      const valueForm = descriptor.valueForm;
      let hostUri = descriptor.hostUri;
      let nodeUri = descriptor.nodeUri;
      let laneUri = descriptor.laneUri;
      let prio = descriptor.prio;
      let rate = descriptor.rate;
      let body = descriptor.body;
      delete descriptor.extends;
      delete descriptor.implements;
      delete descriptor.affinity;
      delete descriptor.inherits;
      delete descriptor.valueForm;
      delete descriptor.hostUri;
      delete descriptor.nodeUri;
      delete descriptor.laneUri;
      delete descriptor.prio;
      delete descriptor.rate;
      delete descriptor.body;
      if (superClass === void 0 || superClass === null) {
        superClass = this;
      }
      const fastenerClass = superClass.extend(className, descriptor);
      fastenerClass.construct = function(fastenerClass, fastener, owner) {
        fastener = superClass.construct(fastenerClass, fastener, owner);
        if (affinity !== void 0) {
          fastener.initAffinity(affinity);
        }
        if (inherits !== void 0) {
          fastener.initInherits(inherits);
        }
        if (hostUri !== void 0) {
          fastener.ownHostUri = hostUri;
        }
        if (nodeUri !== void 0) {
          fastener.ownNodeUri = nodeUri;
        }
        if (laneUri !== void 0) {
          fastener.ownLaneUri = laneUri;
        }
        if (prio !== void 0) {
          fastener.ownPrio = prio;
        }
        if (rate !== void 0) {
          fastener.ownRate = rate;
        }
        if (body !== void 0) {
          fastener.ownBody = body;
        }
        if (valueForm !== void 0) {
          fastener.ownValueForm = valueForm;
        }
        return fastener;
      };
      if (typeof hostUri === "function") {
        fastenerClass.prototype.initHostUri = hostUri;
        hostUri = void 0;
      } else if (hostUri !== void 0) {
        hostUri = Uri.fromAny(hostUri);
      }
      if (typeof nodeUri === "function") {
        fastenerClass.prototype.initNodeUri = nodeUri;
        nodeUri = void 0;
      } else if (nodeUri !== void 0) {
        nodeUri = Uri.fromAny(nodeUri);
      }
      if (typeof laneUri === "function") {
        fastenerClass.prototype.initLaneUri = laneUri;
        laneUri = void 0;
      } else if (laneUri !== void 0) {
        laneUri = Uri.fromAny(laneUri);
      }
      if (typeof prio === "function") {
        fastenerClass.prototype.initPrio = prio;
        prio = void 0;
      }
      if (typeof rate === "function") {
        fastenerClass.prototype.initRate = rate;
        rate = void 0;
      }
      if (typeof body === "function") {
        fastenerClass.prototype.initBody = body;
        body = void 0;
      } else if (body !== void 0) {
        body = Value.fromAny(body);
      }
      return fastenerClass;
    };
    return ValueDownlinkFastener;
  }(DownlinkFastener);
  exports.Absent = Absent;
  exports.AbstractInlet = AbstractInlet;
  exports.AbstractInoutlet = AbstractInoutlet;
  exports.AbstractMapInlet = AbstractMapInlet;
  exports.AbstractMapInletMapOutlet = AbstractMapInletMapOutlet;
  exports.AbstractMapInletOutlet = AbstractMapInletOutlet;
  exports.AbstractMapInoutlet = AbstractMapInoutlet;
  exports.AbstractMapOutlet = AbstractMapOutlet;
  exports.AbstractOutlet = AbstractOutlet;
  exports.AbstractRecordOutlet = AbstractRecordOutlet;
  exports.AbstractRecordStreamlet = AbstractRecordStreamlet;
  exports.AbstractStreamlet = AbstractStreamlet;
  exports.AffineTransform = AffineTransform;
  exports.AffineTransformInterpolator = AffineTransformInterpolator;
  exports.AffineTransformParser = AffineTransformParser;
  exports.Affinity = Affinity;
  exports.AndOperator = AndOperator;
  exports.AndOutlet = AndOutlet;
  exports.Angle = Angle;
  exports.AngleForm = AngleForm;
  exports.AngleInterpolator = AngleInterpolator;
  exports.AngleParser = AngleParser;
  exports.Animator = Animator;
  exports.AnyForm = AnyForm;
  exports.ArrayInterpolator = ArrayInterpolator;
  exports.Arrays = Arrays;
  exports.AssertException = AssertException;
  exports.Attr = Attr;
  exports.AttrInterpolator = AttrInterpolator;
  exports.AuthRequest = AuthRequest;
  exports.AuthedResponse = AuthedResponse;
  exports.BTree = BTree;
  exports.BTreeContext = BTreeContext;
  exports.BTreeLeaf = BTreeLeaf;
  exports.BTreeNode = BTreeNode;
  exports.BTreeNodeCursor = BTreeNodeCursor;
  exports.BTreePage = BTreePage;
  exports.Base10 = Base10;
  exports.Base10IntegerWriter = Base10IntegerWriter;
  exports.Base10NumberParser = Base10NumberParser;
  exports.Base16 = Base16;
  exports.Base16IntegerWriter = Base16IntegerWriter;
  exports.Base16Parser = Base16Parser;
  exports.Base16Writer = Base16Writer;
  exports.Base64 = Base64;
  exports.Base64Parser = Base64Parser;
  exports.Base64Writer = Base64Writer;
  exports.BaseRef = BaseRef;
  exports.Binary = Binary;
  exports.BinaryOperator = BinaryOperator;
  exports.BinaryOperatorInterpolator = BinaryOperatorInterpolator;
  exports.BinaryOutlet = BinaryOutlet;
  exports.BitwiseAndOperator = BitwiseAndOperator;
  exports.BitwiseAndOutlet = BitwiseAndOutlet;
  exports.BitwiseNotOperator = BitwiseNotOperator;
  exports.BitwiseNotOutlet = BitwiseNotOutlet;
  exports.BitwiseOrOperator = BitwiseOrOperator;
  exports.BitwiseOrOutlet = BitwiseOrOutlet;
  exports.BitwiseXorOperator = BitwiseXorOperator;
  exports.BitwiseXorOutlet = BitwiseXorOutlet;
  exports.Bool = Bool;
  exports.BooleanAnimator = BooleanAnimator;
  exports.BooleanForm = BooleanForm;
  exports.BooleanProperty = BooleanProperty;
  exports.Booleans = Booleans;
  exports.BridgeFunc = BridgeFunc;
  exports.ByteOrder = ByteOrder;
  exports.ByteOutput = ByteOutput;
  exports.ByteOutputBuffer = ByteOutputBuffer;
  exports.ByteOutputUint8Array = ByteOutputUint8Array;
  exports.ChildrenSelector = ChildrenSelector;
  exports.CloseSignal = CloseSignal;
  exports.ClosedSignal = ClosedSignal;
  exports.CommandMessage = CommandMessage;
  exports.Compare = Compare;
  exports.Component = Component;
  exports.ComponentRef = ComponentRef;
  exports.ComponentRelation = ComponentRelation;
  exports.ComponentSet = ComponentSet;
  exports.ConditionalOperator = ConditionalOperator;
  exports.ConditionalOperatorInterpolator = ConditionalOperatorInterpolator;
  exports.ConditionalOutlet = ConditionalOutlet;
  exports.ConnectSignal = ConnectSignal;
  exports.ConnectedSignal = ConnectedSignal;
  exports.Constraint = Constraint;
  exports.ConstraintAnimator = ConstraintAnimator;
  exports.ConstraintConstant = ConstraintConstant;
  exports.ConstraintDummy = ConstraintDummy;
  exports.ConstraintError = ConstraintError;
  exports.ConstraintExpression = ConstraintExpression;
  exports.ConstraintGroup = ConstraintGroup;
  exports.ConstraintId = ConstraintId;
  exports.ConstraintInvalid = ConstraintInvalid;
  exports.ConstraintMap = ConstraintMap;
  exports.ConstraintProduct = ConstraintProduct;
  exports.ConstraintProperty = ConstraintProperty;
  exports.ConstraintRow = ConstraintRow;
  exports.ConstraintScope = ConstraintScope;
  exports.ConstraintSlack = ConstraintSlack;
  exports.ConstraintSolver = ConstraintSolver;
  exports.ConstraintStrength = ConstraintStrength;
  exports.ConstraintSum = ConstraintSum;
  exports.ConstraintSymbol = ConstraintSymbol;
  exports.ConstraintTerm = ConstraintTerm;
  exports.Constructors = Constructors;
  exports.Consumable = Consumable;
  exports.ContinuousScale = ContinuousScale;
  exports.Creatable = Creatable;
  exports.Cursor = Cursor;
  exports.CursorArray = CursorArray;
  exports.CursorEmpty = CursorEmpty;
  exports.CursorUnary = CursorUnary;
  exports.Data = Data;
  exports.DataOutput = DataOutput;
  exports.Dataflow = Dataflow;
  exports.DateTime = DateTime;
  exports.DateTimeForm = DateTimeForm;
  exports.DateTimeFormat = DateTimeFormat;
  exports.DateTimeInterpolator = DateTimeInterpolator;
  exports.DateTimeLocale = DateTimeLocale;
  exports.DateTimeParser = DateTimeParser;
  exports.DateTimeSpecifiers = DateTimeSpecifiers;
  exports.DayInterval = DayInterval;
  exports.DayOfMonthFormat = DayOfMonthFormat;
  exports.DayOfMonthParser = DayOfMonthParser;
  exports.DeauthRequest = DeauthRequest;
  exports.DeauthedResponse = DeauthedResponse;
  exports.DegAngle = DegAngle;
  exports.DescendantsSelector = DescendantsSelector;
  exports.Diagnostic = Diagnostic;
  exports.DisconnectSignal = DisconnectSignal;
  exports.DisconnectedSignal = DisconnectedSignal;
  exports.DivideOperator = DivideOperator;
  exports.DivideOutlet = DivideOutlet;
  exports.Domain = Domain;
  exports.Downlink = Downlink;
  exports.DownlinkFastener = DownlinkFastener;
  exports.DownlinkModel = DownlinkModel;
  exports.DownlinkRecord = DownlinkRecord;
  exports.DownlinkReifier = DownlinkReifier;
  exports.DownlinkStreamlet = DownlinkStreamlet;
  exports.Easing = Easing;
  exports.EmLength = EmLength;
  exports.Envelope = Envelope;
  exports.EqOperator = EqOperator;
  exports.EqOutlet = EqOutlet;
  exports.Equals = Equals;
  exports.Equivalent = Equivalent;
  exports.ErrorSignal = ErrorSignal;
  exports.EventDownlink = EventDownlink;
  exports.EventDownlinkFastener = EventDownlinkFastener;
  exports.EventDownlinkModel = EventDownlinkModel;
  exports.EventMessage = EventMessage;
  exports.Expression = Expression;
  exports.Extant = Extant;
  exports.Fastener = Fastener;
  exports.FastenerContext = FastenerContext;
  exports.Field = Field;
  exports.FieldInterpolator = FieldInterpolator;
  exports.FilterFieldsCombinator = FilterFieldsCombinator;
  exports.FilterFieldsOperator = FilterFieldsOperator;
  exports.FilterSelector = FilterSelector;
  exports.FilterTimeInterval = FilterTimeInterval;
  exports.Form = Form;
  exports.FormException = FormException;
  exports.Format = Format;
  exports.FromAny = FromAny;
  exports.Func = Func;
  exports.Functions = Functions;
  exports.GeOperator = GeOperator;
  exports.GeOutlet = GeOutlet;
  exports.GeoBox = GeoBox;
  exports.GeoBoxInterpolator = GeoBoxInterpolator;
  exports.GeoCurve = GeoCurve;
  exports.GeoGroup = GeoGroup;
  exports.GeoJson = GeoJson;
  exports.GeoJsonFeature = GeoJsonFeature;
  exports.GeoJsonFeatureCollection = GeoJsonFeatureCollection;
  exports.GeoJsonGeometry = GeoJsonGeometry;
  exports.GeoJsonGeometryCollection = GeoJsonGeometryCollection;
  exports.GeoJsonLineString = GeoJsonLineString;
  exports.GeoJsonMultiLineString = GeoJsonMultiLineString;
  exports.GeoJsonMultiPoint = GeoJsonMultiPoint;
  exports.GeoJsonMultiPolygon = GeoJsonMultiPolygon;
  exports.GeoJsonPoint = GeoJsonPoint;
  exports.GeoJsonPolygon = GeoJsonPolygon;
  exports.GeoPath = GeoPath;
  exports.GeoPathBuilder = GeoPathBuilder;
  exports.GeoPoint = GeoPoint;
  exports.GeoPointInterpolator = GeoPointInterpolator;
  exports.GeoProjection = GeoProjection;
  exports.GeoSegment = GeoSegment;
  exports.GeoSegmentInterpolator = GeoSegmentInterpolator;
  exports.GeoShape = GeoShape;
  exports.GeoSpline = GeoSpline;
  exports.GeoSplineBuilder = GeoSplineBuilder;
  exports.GeoTile = GeoTile;
  exports.GetAttrSelector = GetAttrSelector;
  exports.GetItemSelector = GetItemSelector;
  exports.GetOutlet = GetOutlet;
  exports.GetSelector = GetSelector;
  exports.GradAngle = GradAngle;
  exports.GtOperator = GtOperator;
  exports.GtOutlet = GtOutlet;
  exports.HashCode = HashCode;
  exports.HashGenCacheMap = HashGenCacheMap;
  exports.HashGenCacheMapBucket = HashGenCacheMapBucket;
  exports.HashGenCacheSet = HashGenCacheSet;
  exports.HashGenCacheSetBucket = HashGenCacheSetBucket;
  exports.Host = Host;
  exports.HostAddressed = HostAddressed;
  exports.HostRef = HostRef;
  exports.Hour12Format = Hour12Format;
  exports.Hour12Parser = Hour12Parser;
  exports.Hour24Format = Hour24Format;
  exports.Hour24Parser = Hour24Parser;
  exports.HourInterval = HourInterval;
  exports.Identifiers = Identifiers;
  exports.Identity = Identity;
  exports.IdentityInterpolator = IdentityInterpolator;
  exports.IdentitySelector = IdentitySelector;
  exports.IdentityTransform = IdentityTransform;
  exports.In = In;
  exports.Initable = Initable;
  exports.Inlet = Inlet;
  exports.InletDescriptor = InletDescriptor;
  exports.Inout = Inout;
  exports.InoutletDescriptor = InoutletDescriptor;
  exports.Input = Input;
  exports.InputBuffer = InputBuffer;
  exports.InputBufferDone = InputBufferDone;
  exports.InputBufferEmpty = InputBufferEmpty;
  exports.InputBufferError = InputBufferError;
  exports.InputDone = InputDone;
  exports.InputEmpty = InputEmpty;
  exports.InputError = InputError;
  exports.InputException = InputException;
  exports.InputSettings = InputSettings;
  exports.Interpolate = Interpolate;
  exports.Interpolator = Interpolator;
  exports.InterpolatorInterpolator = InterpolatorInterpolator;
  exports.InterpolatorMap = InterpolatorMap;
  exports.Interpreter = Interpreter;
  exports.InterpreterException = InterpreterException;
  exports.InterpreterSettings = InterpreterSettings;
  exports.InvokeOperator = InvokeOperator;
  exports.InvokeOperatorInterpolator = InvokeOperatorInterpolator;
  exports.InvokeOutlet = InvokeOutlet;
  exports.Item = Item;
  exports.ItemForm = ItemForm;
  exports.ItemInterpolator = ItemInterpolator;
  exports.KeyOutlet = KeyOutlet;
  exports.KeysCursor = KeysCursor;
  exports.KeysSelector = KeysSelector;
  exports.LambdaFunc = LambdaFunc;
  exports.LaneAddressed = LaneAddressed;
  exports.LaneRef = LaneRef;
  exports.Lazy = Lazy;
  exports.LeOperator = LeOperator;
  exports.LeOutlet = LeOutlet;
  exports.Length = Length;
  exports.LengthException = LengthException;
  exports.LengthForm = LengthForm;
  exports.LengthInterpolator = LengthInterpolator;
  exports.LengthParser = LengthParser;
  exports.LinearDomain = LinearDomain;
  exports.LinearDomainInterpolator = LinearDomainInterpolator;
  exports.LinearRange = LinearRange;
  exports.LinearRangeInterpolator = LinearRangeInterpolator;
  exports.LinearScale = LinearScale;
  exports.LinearScaleInterpolator = LinearScaleInterpolator;
  exports.LinkAddressed = LinkAddressed;
  exports.LinkRequest = LinkRequest;
  exports.LinkedResponse = LinkedResponse;
  exports.ListDownlink = ListDownlink;
  exports.ListDownlinkFastener = ListDownlinkFastener;
  exports.ListDownlinkModel = ListDownlinkModel;
  exports.ListDownlinkRecord = ListDownlinkRecord;
  exports.LiteralSelector = LiteralSelector;
  exports.LtOperator = LtOperator;
  exports.LtOutlet = LtOutlet;
  exports.MapDownlink = MapDownlink;
  exports.MapDownlinkFastener = MapDownlinkFastener;
  exports.MapDownlinkModel = MapDownlinkModel;
  exports.MapDownlinkRecord = MapDownlinkRecord;
  exports.MapFieldValuesCombinator = MapFieldValuesCombinator;
  exports.MapFieldValuesOperator = MapFieldValuesOperator;
  exports.MapInlet = MapInlet;
  exports.MapInput = MapInput;
  exports.MapOutlet = MapOutlet;
  exports.MapOutletCombinators = MapOutletCombinators;
  exports.MapOutput = MapOutput;
  exports.MapValueCombinator = MapValueCombinator;
  exports.MapValueOperator = MapValueOperator;
  exports.Mapping = Mapping;
  exports.Mark = Mark;
  exports.MathModule = MathModule;
  exports.MemoizeMapCombinator = MemoizeMapCombinator;
  exports.MemoizeValueCombinator = MemoizeValueCombinator;
  exports.Message = Message;
  exports.MillisecondFormat = MillisecondFormat;
  exports.MillisecondInterval = MillisecondInterval;
  exports.MillisecondParser = MillisecondParser;
  exports.MillisecondsInterval = MillisecondsInterval;
  exports.MinusOperator = MinusOperator;
  exports.MinusOutlet = MinusOutlet;
  exports.MinuteFormat = MinuteFormat;
  exports.MinuteInterval = MinuteInterval;
  exports.MinuteParser = MinuteParser;
  exports.ModuloOperator = ModuloOperator;
  exports.ModuloOutlet = ModuloOutlet;
  exports.MonthFormat = MonthFormat;
  exports.MonthInterval = MonthInterval;
  exports.MonthOfYearFormat = MonthOfYearFormat;
  exports.MonthOfYearParser = MonthOfYearParser;
  exports.MonthParser = MonthParser;
  exports.Murmur3 = Murmur3;
  exports.NeOperator = NeOperator;
  exports.NeOutlet = NeOutlet;
  exports.NegativeOperator = NegativeOperator;
  exports.NegativeOutlet = NegativeOutlet;
  exports.NodeCursor = NodeCursor;
  exports.NodeRef = NodeRef;
  exports.NotOperator = NotOperator;
  exports.NotOutlet = NotOutlet;
  exports.Num = Num;
  exports.NumInterpolator = NumInterpolator;
  exports.NumberAnimator = NumberAnimator;
  exports.NumberForm = NumberForm;
  exports.NumberInterpolator = NumberInterpolator;
  exports.NumberProperty = NumberProperty;
  exports.Numbers = Numbers;
  exports.Objects = Objects;
  exports.Observable = Observable;
  exports.OpenSignal = OpenSignal;
  exports.OpenedSignal = OpenedSignal;
  exports.Operator = Operator;
  exports.OrOperator = OrOperator;
  exports.OrOutlet = OrOutlet;
  exports.Out = Out;
  exports.Outlet = Outlet;
  exports.OutletCombinators = OutletCombinators;
  exports.OutletDescriptor = OutletDescriptor;
  exports.OutletInlet = OutletInlet;
  exports.OutletMapInlet = OutletMapInlet;
  exports.Output = Output;
  exports.OutputBuffer = OutputBuffer;
  exports.OutputBufferDone = OutputBufferDone;
  exports.OutputBufferError = OutputBufferError;
  exports.OutputBufferFull = OutputBufferFull;
  exports.OutputDone = OutputDone;
  exports.OutputError = OutputError;
  exports.OutputException = OutputException;
  exports.OutputFull = OutputFull;
  exports.OutputSettings = OutputSettings;
  exports.OutputStyle = OutputStyle;
  exports.Parser = Parser;
  exports.ParserDone = ParserDone;
  exports.ParserError = ParserError;
  exports.ParserException = ParserException;
  exports.PatternFormat = PatternFormat;
  exports.PatternParser = PatternParser;
  exports.PctLength = PctLength;
  exports.PeriodFormat = PeriodFormat;
  exports.PeriodParser = PeriodParser;
  exports.PlusOperator = PlusOperator;
  exports.PlusOutlet = PlusOutlet;
  exports.PositiveOperator = PositiveOperator;
  exports.PositiveOutlet = PositiveOutlet;
  exports.Property = Property;
  exports.Provider = Provider;
  exports.PxLength = PxLength;
  exports.R2BezierCurve = R2BezierCurve;
  exports.R2Box = R2Box;
  exports.R2BoxInterpolator = R2BoxInterpolator;
  exports.R2Circle = R2Circle;
  exports.R2CircleInterpolator = R2CircleInterpolator;
  exports.R2CubicCurve = R2CubicCurve;
  exports.R2CubicCurveParser = R2CubicCurveParser;
  exports.R2Curve = R2Curve;
  exports.R2CurveParser = R2CurveParser;
  exports.R2EllipticCurve = R2EllipticCurve;
  exports.R2EllipticCurveParser = R2EllipticCurveParser;
  exports.R2Group = R2Group;
  exports.R2Path = R2Path;
  exports.R2PathBuilder = R2PathBuilder;
  exports.R2PathParser = R2PathParser;
  exports.R2Point = R2Point;
  exports.R2PointInterpolator = R2PointInterpolator;
  exports.R2QuadraticCurve = R2QuadraticCurve;
  exports.R2QuadraticCurveParser = R2QuadraticCurveParser;
  exports.R2Segment = R2Segment;
  exports.R2SegmentInterpolator = R2SegmentInterpolator;
  exports.R2SegmentParser = R2SegmentParser;
  exports.R2Shape = R2Shape;
  exports.R2Spline = R2Spline;
  exports.R2SplineBuilder = R2SplineBuilder;
  exports.R2SplineParser = R2SplineParser;
  exports.R2Vector = R2Vector;
  exports.R2VectorInterpolator = R2VectorInterpolator;
  exports.RadAngle = RadAngle;
  exports.Random = Random;
  exports.Range = Range;
  exports.Recon = Recon;
  exports.ReconParser = ReconParser;
  exports.ReconStructureParser = ReconStructureParser;
  exports.ReconStructureWriter = ReconStructureWriter;
  exports.ReconWriter = ReconWriter;
  exports.Record = Record;
  exports.RecordCursor = RecordCursor;
  exports.RecordFieldUpdater = RecordFieldUpdater;
  exports.RecordInterpolator = RecordInterpolator;
  exports.RecordMap = RecordMap;
  exports.RecordMapView = RecordMapView;
  exports.RecordModel = RecordModel;
  exports.RecordOutlet = RecordOutlet;
  exports.RecordScope = RecordScope;
  exports.RecordStreamlet = RecordStreamlet;
  exports.ReduceFieldsCombinator = ReduceFieldsCombinator;
  exports.ReduceFieldsOperator = ReduceFieldsOperator;
  exports.Reifier = Reifier;
  exports.RemLength = RemLength;
  exports.RemoteHost = RemoteHost;
  exports.RotateTransform = RotateTransform;
  exports.RotateTransformInterpolator = RotateTransformInterpolator;
  exports.RotateTransformParser = RotateTransformParser;
  exports.STree = STree;
  exports.STreeContext = STreeContext;
  exports.STreeLeaf = STreeLeaf;
  exports.STreeNode = STreeNode;
  exports.STreeNodeCursor = STreeNodeCursor;
  exports.STreePage = STreePage;
  exports.Scale = Scale;
  exports.ScaleTransform = ScaleTransform;
  exports.ScaleTransformInterpolator = ScaleTransformInterpolator;
  exports.ScaleTransformParser = ScaleTransformParser;
  exports.SecondFormat = SecondFormat;
  exports.SecondInterval = SecondInterval;
  exports.SecondParser = SecondParser;
  exports.Selector = Selector;
  exports.Service = Service;
  exports.Severity = Severity;
  exports.ShortMonthFormat = ShortMonthFormat;
  exports.ShortMonthParser = ShortMonthParser;
  exports.ShortWeekdayFormat = ShortWeekdayFormat;
  exports.ShortWeekdayParser = ShortWeekdayParser;
  exports.Signal = Signal;
  exports.SkewTransform = SkewTransform;
  exports.SkewTransformInterpolator = SkewTransformInterpolator;
  exports.SkewTransformParser = SkewTransformParser;
  exports.Slot = Slot;
  exports.SlotInterpolator = SlotInterpolator;
  exports.Span = Span;
  exports.StepInterpolator = StepInterpolator;
  exports.Streamlet = Streamlet;
  exports.StreamletException = StreamletException;
  exports.StreamletInlet = StreamletInlet;
  exports.StreamletInoutlet = StreamletInoutlet;
  exports.StreamletOutlet = StreamletOutlet;
  exports.StreamletScope = StreamletScope;
  exports.StringAnimator = StringAnimator;
  exports.StringForm = StringForm;
  exports.StringInput = StringInput;
  exports.StringOutput = StringOutput;
  exports.StringProperty = StringProperty;
  exports.StringWriter = StringWriter$1;
  exports.Strings = Strings;
  exports.SyncRequest = SyncRequest;
  exports.SyncedResponse = SyncedResponse;
  exports.Tag = Tag;
  exports.TagForm = TagForm;
  exports.Text = Text;
  exports.TextOutput = TextOutput;
  exports.TimeDomain = TimeDomain;
  exports.TimeDomainInterpolator = TimeDomainInterpolator;
  exports.TimeInterval = TimeInterval;
  exports.TimeRange = TimeRange;
  exports.TimeRangeInterpolator = TimeRangeInterpolator;
  exports.TimeScale = TimeScale;
  exports.TimeScaleInterpolator = TimeScaleInterpolator;
  exports.TimeZone = TimeZone;
  exports.TimeZoneForm = TimeZoneForm;
  exports.Timer = Timer;
  exports.TimesOperator = TimesOperator;
  exports.TimesOutlet = TimesOutlet;
  exports.Timing = Timing;
  exports.ToAny = ToAny;
  exports.Transform = Transform;
  exports.TransformForm = TransformForm;
  exports.TransformList = TransformList;
  exports.TransformListInterpolator = TransformListInterpolator;
  exports.TransformListParser = TransformListParser;
  exports.TransformParser = TransformParser;
  exports.TranslateTransform = TranslateTransform;
  exports.TranslateTransformInterpolator = TranslateTransformInterpolator;
  exports.TranslateTransformParser = TranslateTransformParser;
  exports.TurnAngle = TurnAngle;
  exports.Tweening = Tweening;
  exports.UnaryOperator = UnaryOperator;
  exports.UnaryOperatorInterpolator = UnaryOperatorInterpolator;
  exports.UnaryOutlet = UnaryOutlet;
  exports.Unicode = Unicode;
  exports.UnitForm = UnitForm;
  exports.UnitTimeInterval = UnitTimeInterval;
  exports.UnitlessLength = UnitlessLength;
  exports.UnlinkRequest = UnlinkRequest;
  exports.UnlinkedResponse = UnlinkedResponse;
  exports.Uri = Uri;
  exports.UriAbsoluteParser = UriAbsoluteParser;
  exports.UriAuthority = UriAuthority;
  exports.UriAuthorityParser = UriAuthorityParser;
  exports.UriCache = UriCache;
  exports.UriException = UriException;
  exports.UriForm = UriForm;
  exports.UriFragment = UriFragment;
  exports.UriFragmentParser = UriFragmentParser;
  exports.UriHost = UriHost;
  exports.UriHostAddressParser = UriHostAddressParser;
  exports.UriHostIPv4 = UriHostIPv4;
  exports.UriHostIPv6 = UriHostIPv6;
  exports.UriHostLiteralParser = UriHostLiteralParser;
  exports.UriHostName = UriHostName;
  exports.UriHostParser = UriHostParser;
  exports.UriHostUndefined = UriHostUndefined;
  exports.UriParser = UriParser;
  exports.UriPath = UriPath;
  exports.UriPathBuilder = UriPathBuilder;
  exports.UriPathEmpty = UriPathEmpty;
  exports.UriPathForm = UriPathForm;
  exports.UriPathParser = UriPathParser;
  exports.UriPathSegment = UriPathSegment;
  exports.UriPathSlash = UriPathSlash;
  exports.UriPort = UriPort;
  exports.UriPortParser = UriPortParser;
  exports.UriQuery = UriQuery;
  exports.UriQueryBuilder = UriQueryBuilder;
  exports.UriQueryParam = UriQueryParam;
  exports.UriQueryParser = UriQueryParser;
  exports.UriQueryUndefined = UriQueryUndefined;
  exports.UriScheme = UriScheme;
  exports.UriSchemeParser = UriSchemeParser;
  exports.UriUser = UriUser;
  exports.UriUserParser = UriUserParser;
  exports.Utf8 = Utf8;
  exports.Utf8DecodedOutput = Utf8DecodedOutput;
  exports.Utf8EncodedOutput = Utf8EncodedOutput;
  exports.UtfErrorMode = UtfErrorMode;
  exports.UtfErrorModeFatal = UtfErrorModeFatal;
  exports.UtfErrorModeReplacement = UtfErrorModeReplacement;
  exports.Value = Value;
  exports.ValueBuilder = ValueBuilder;
  exports.ValueCursor = ValueCursor;
  exports.ValueDownlink = ValueDownlink;
  exports.ValueDownlinkFastener = ValueDownlinkFastener;
  exports.ValueDownlinkModel = ValueDownlinkModel;
  exports.ValueDownlinkRecord = ValueDownlinkRecord;
  exports.ValueEntryCursor = ValueEntryCursor;
  exports.ValueForm = ValueForm;
  exports.ValueInput = ValueInput;
  exports.ValueOutput = ValueOutput;
  exports.Values = Values;
  exports.ValuesCursor = ValuesCursor;
  exports.ValuesSelector = ValuesSelector;
  exports.WarpClient = WarpClient;
  exports.WarpProvider = WarpProvider;
  exports.WarpService = WarpService;
  exports.WarpWorkerHost = WarpWorkerHost;
  exports.WatchFieldsCombinator = WatchFieldsCombinator;
  exports.WatchFieldsOperator = WatchFieldsOperator;
  exports.WatchValueCombinator = WatchValueCombinator;
  exports.WatchValueOperator = WatchValueOperator;
  exports.WebSocketHost = WebSocketHost;
  exports.WeekInterval = WeekInterval;
  exports.WeekdayFormat = WeekdayFormat;
  exports.WeekdayParser = WeekdayParser;
  exports.WorkerAddressed = WorkerAddressed;
  exports.Writer = Writer;
  exports.WriterDone = WriterDone;
  exports.WriterEnd = WriterEnd;
  exports.WriterError = WriterError;
  exports.WriterException = WriterException;
  exports.WriterSequence = WriterSequence;
  exports.YearFormat = YearFormat;
  exports.YearInterval = YearInterval;
  exports.YearParser = YearParser;
  exports.YearsInterval = YearsInterval;
  exports.assert = assert;
  exports.authenticate = authenticate;
  exports.client = client;
  exports.command = command;
  exports.downlink = downlink;
  exports.downlinkList = downlinkList;
  exports.downlinkMap = downlinkMap;
  exports.downlinkValue = downlinkValue;
  exports.hostRef = hostRef;
  exports.laneRef = laneRef;
  exports.nodeRef = nodeRef;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
}));
//# sourceMappingURL=swim-runtime.js.map
